<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info>
<title>Scalability and performance</title>
<date>2024-02-23</date>
<title>Scalability and performance</title>
<productname>OpenShift Container Platform</productname>
<productnumber>4.14</productnumber>
<subtitle>Enter a short description here.</subtitle>
<abstract>
    <para>A short overview and summary of the book's subject and purpose, traditionally no more than one paragraph long.</para>
</abstract>
<authorgroup>
    <orgname>Red Hat OpenShift Documentation Team</orgname>
</authorgroup>
<xi:include href="Common_Content/Legal_Notice.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</info>
<chapter xml:id="_recommended-performance-and-scalability-practices">
<title>Recommended performance and scalability practices</title>
<section xml:id="recommended-control-plane-practices">
<title>Recommended control plane practices</title>
<simpara>This topic provides recommended performance and scalability practices for control planes in OpenShift Container Platform.</simpara>
<section xml:id="recommended-scale-practices_recommended-control-plane-practices">
<title>Recommended practices for scaling the cluster</title>
<simpara>The guidance in this section is only relevant for installations with cloud provider integration.</simpara>
<simpara>Apply the following best practices to scale the number of worker machines in your OpenShift Container Platform cluster. You scale the worker machines by increasing or decreasing the number of replicas that are defined in the worker machine set.</simpara>
<simpara>When scaling up the cluster to higher node counts:</simpara>
<itemizedlist>
<listitem>
<simpara>Spread nodes across all of the available zones for higher availability.</simpara>
</listitem>
<listitem>
<simpara>Scale up by no more than 25 to 50 machines at once.</simpara>
</listitem>
<listitem>
<simpara>Consider creating new compute machine sets in each available zone with alternative instance types of similar size to help mitigate any periodic provider capacity constraints. For example, on AWS, use m5.large and m5d.large.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Cloud providers might implement a quota for API services. Therefore, gradually scale the cluster.</simpara>
</note>
<simpara>The controller might not be able to create the machines if the replicas in the compute machine sets are set to higher numbers all at one time. The number of requests the cloud platform, which OpenShift Container Platform is deployed on top of, is able to handle impacts the process. The controller will start to query more while trying to create, check, and update the machines with the status. The cloud platform on which OpenShift Container Platform is deployed has API request limits;  excessive queries might lead to machine creation failures due to cloud platform limitations.</simpara>
<simpara>Enable machine health checks when scaling to large node counts. In case of failures, the health checks monitor the condition and automatically repair unhealthy machines.</simpara>
<note>
<simpara>When scaling large and dense clusters to lower node counts, it might take large amounts of time because the process involves draining or evicting the objects running on the nodes being terminated in parallel. Also, the client might start to throttle the requests if there are too many objects to evict. The default client queries per second (QPS) and burst rates are currently set to <literal>50</literal> and <literal>100</literal> respectively. These values cannot be modified in OpenShift Container Platform.</simpara>
</note>
</section>
<section xml:id="master-node-sizing_recommended-control-plane-practices">
<title>Control plane node sizing</title>
<simpara>The control plane node resource requirements depend on the number and type of nodes and objects in the cluster. The following control plane node size recommendations are based on the results of a control plane density focused testing, or <emphasis>Cluster-density</emphasis>. This test creates the following objects across a given number of namespaces:</simpara>
<itemizedlist>
<listitem>
<simpara>1 image stream</simpara>
</listitem>
<listitem>
<simpara>1 build</simpara>
</listitem>
<listitem>
<simpara>5 deployments, with 2 pod replicas in a <literal>sleep</literal> state, mounting 4 secrets, 4 config maps, and 1 downward API volume each</simpara>
</listitem>
<listitem>
<simpara>5 services, each one pointing to the TCP/8080 and TCP/8443 ports of one of the previous deployments</simpara>
</listitem>
<listitem>
<simpara>1 route pointing to the first of the previous services</simpara>
</listitem>
<listitem>
<simpara>10 secrets containing 2048 random string characters</simpara>
</listitem>
<listitem>
<simpara>10 config maps containing 2048 random string characters</simpara>
</listitem>
</itemizedlist>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Number of worker nodes</entry>
<entry align="left" valign="top">Cluster-density (namespaces)</entry>
<entry align="left" valign="top">CPU cores</entry>
<entry align="left" valign="top">Memory (GB)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>252</simpara></entry>
<entry align="left" valign="top"><simpara>4000</simpara></entry>
<entry align="left" valign="top"><simpara>16, but 24 if using the OVN-Kubernetes network plug-in</simpara></entry>
<entry align="left" valign="top"><simpara>64, but 128 if using the OVN-Kubernetes network plug-in</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>501, but untested with the OVN-Kubernetes network plug-in</simpara></entry>
<entry align="left" valign="top"><simpara>4000</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>96</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The data from the table above is based on an OpenShift Container Platform running on top of AWS, using r5.4xlarge instances as control-plane nodes and m5.2xlarge instances as worker nodes.</simpara>
<simpara>On a large and dense cluster with three control plane nodes, the CPU and memory usage will spike up when one of the nodes is stopped, rebooted, or fails. The failures can be due to unexpected issues with power, network, underlying infrastructure, or intentional cases where the cluster is restarted after shutting it down to save costs. The remaining two control plane nodes must handle the load in order to be highly available, which leads to increase in the resource usage. This is also expected during upgrades because the control plane nodes are cordoned, drained, and rebooted serially to apply the operating system updates, as well as the control plane Operators update. To avoid cascading failures, keep the overall CPU and memory resource usage on the control plane nodes to at most 60% of all available capacity to handle the resource usage spikes. Increase the CPU and memory on the control plane nodes accordingly to avoid potential downtime due to lack of resources.</simpara>
<important>
<simpara>The node sizing varies depending on the number of nodes and object counts in the cluster. It also depends on whether the objects are actively being created on the cluster. During object creation, the control plane is more active in terms of resource usage compared to when the objects are in the <literal>running</literal> phase.</simpara>
</important>
<simpara>Operator Lifecycle Manager (OLM ) runs on the control plane nodes and its memory footprint depends on the number of namespaces and user installed operators that OLM needs to manage on the cluster. Control plane nodes need to be sized accordingly to avoid OOM kills. Following data points are based on the results from cluster maximums testing.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Number of namespaces</entry>
<entry align="left" valign="top">OLM memory at idle state (GB)</entry>
<entry align="left" valign="top">OLM memory with 5 user operators installed (GB)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>0.823</simpara></entry>
<entry align="left" valign="top"><simpara>1.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>1.2</simpara></entry>
<entry align="left" valign="top"><simpara>2.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1500</simpara></entry>
<entry align="left" valign="top"><simpara>1.7</simpara></entry>
<entry align="left" valign="top"><simpara>3.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2000</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>4.4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3000</simpara></entry>
<entry align="left" valign="top"><simpara>2.7</simpara></entry>
<entry align="left" valign="top"><simpara>5.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4000</simpara></entry>
<entry align="left" valign="top"><simpara>3.8</simpara></entry>
<entry align="left" valign="top"><simpara>7.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5000</simpara></entry>
<entry align="left" valign="top"><simpara>4.2</simpara></entry>
<entry align="left" valign="top"><simpara>9.02</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6000</simpara></entry>
<entry align="left" valign="top"><simpara>5.8</simpara></entry>
<entry align="left" valign="top"><simpara>11.3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7000</simpara></entry>
<entry align="left" valign="top"><simpara>6.6</simpara></entry>
<entry align="left" valign="top"><simpara>12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8000</simpara></entry>
<entry align="left" valign="top"><simpara>6.9</simpara></entry>
<entry align="left" valign="top"><simpara>14.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9000</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>17.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10,000</simpara></entry>
<entry align="left" valign="top"><simpara>9.9</simpara></entry>
<entry align="left" valign="top"><simpara>21.6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<important>
<simpara>You can modify the control plane node size in a running OpenShift Container Platform 4.14 cluster for the following configurations only:</simpara>
<itemizedlist>
<listitem>
<simpara>Clusters installed with a user-provisioned installation method.</simpara>
</listitem>
<listitem>
<simpara>AWS clusters installed with an installer-provisioned infrastructure installation method.</simpara>
</listitem>
<listitem>
<simpara>Clusters that use a control plane machine set to manage control plane machines.</simpara>
</listitem>
</itemizedlist>
<simpara>For all other configurations, you must estimate your total node count and use the suggested control plane node size during installation.</simpara>
</important>
<important>
<simpara>The recommendations are based on the data points captured on OpenShift Container Platform clusters with OpenShift SDN as the network plugin.</simpara>
</important>
<note>
<simpara>In OpenShift Container Platform 4.14, half of a CPU core (500 millicore) is now reserved by the system by default compared to OpenShift Container Platform 3.11 and previous versions. The sizes are determined taking that into consideration.</simpara>
</note>
<section xml:id="increasing-aws-flavor-size_recommended-control-plane-practices">
<title>Selecting a larger Amazon Web Services instance type for control plane machines</title>
<simpara>If the control plane machines in an Amazon Web Services (AWS) cluster require more resources, you can select a larger AWS instance type for the control plane machines to use.</simpara>
<note>
<simpara>The procedure for clusters that use a control plane machine set is different from the procedure for clusters that do not use a control plane machine set.</simpara>
<simpara>If you are uncertain about the state of the <literal>ControlPlaneMachineSet</literal> CR in your cluster, you can <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#cpmso-checking-status_cpmso-getting-started">verify the CR status</link>.</simpara>
</note>
<section xml:id="cpms-changing-aws-instance-type_recommended-control-plane-practices">
<title>Changing the Amazon Web Services instance type by using a control plane machine set</title>
<simpara>You can change the Amazon Web Services (AWS) instance type that your control plane machines use by updating the specification in the control plane machine set custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your AWS cluster uses a control plane machine set.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit your control plane machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace openshift-machine-api edit controlplanemachineset.machine.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Edit the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    ...
    instanceType: &lt;compatible_aws_instance_type&gt; <co xml:id="CO1-1"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Specify a larger AWS instance type with the same base as the previous selection. For example, you can change <literal>m6i.xlarge</literal> to <literal>m6i.2xlarge</literal> or <literal>m6i.4xlarge</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
<itemizedlist>
<listitem>
<simpara>For clusters that use the default <literal>RollingUpdate</literal> update strategy, the Operator automatically propagates the changes to your control plane configuration.</simpara>
</listitem>
<listitem>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, you must replace your control plane machines manually.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#cpmso-using">Managing control plane machines with control plane machine sets</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="aws-console-changing-aws-instance-type_recommended-control-plane-practices">
<title>Changing the Amazon Web Services instance type by using the AWS console</title>
<simpara>You can change the Amazon Web Services (AWS) instance type that your control plane machines use by updating the instance type in the AWS console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the AWS console with the permissions required to modify the EC2 Instance for your cluster.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the AWS console and fetch the instances for the control plane machines.</simpara>
</listitem>
<listitem>
<simpara>Choose one control plane machine instance.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>For the selected control plane machine, back up the etcd data by creating an etcd snapshot. For more information, see "Backing up etcd".</simpara>
</listitem>
<listitem>
<simpara>In the AWS console, stop the control plane machine instance.</simpara>
</listitem>
<listitem>
<simpara>Select the stopped instance, and click <emphasis role="strong">Actions</emphasis> &#8594; <emphasis role="strong">Instance Settings</emphasis> &#8594; <emphasis role="strong">Change instance type</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Change the instance to a larger type, ensuring that the type is the same base as the previous selection, and apply changes. For example, you can change <literal>m6i.xlarge</literal> to <literal>m6i.2xlarge</literal> or <literal>m6i.4xlarge</literal>.</simpara>
</listitem>
<listitem>
<simpara>Start the instance.</simpara>
</listitem>
<listitem>
<simpara>If your OpenShift Container Platform cluster has a corresponding <literal>Machine</literal> object for the instance, update the instance type of the object to match the instance type set in the AWS console.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Repeat this process for each control plane machine.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/backup_and_restore/#backing-up-etcd">Backing up etcd</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-resize.html">AWS documentation about changing the instance type</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</section>
<section xml:id="recommended-infrastructure-practices">
<title>Recommended infrastructure practices</title>
<simpara>This topic provides recommended performance and scalability practices for infrastructure in OpenShift Container Platform.</simpara>
<section xml:id="infrastructure-node-sizing_recommended-infrastructure-practices">
<title>Infrastructure node sizing</title>
<simpara><emphasis>Infrastructure nodes</emphasis> are nodes that are labeled to run pieces of the OpenShift Container Platform environment. The infrastructure node resource requirements depend on the cluster age, nodes, and objects in the cluster, as these factors can lead to an increase in the number of metrics or time series in Prometheus. The following infrastructure node size recommendations are based on the results observed in cluster-density testing detailed in the <emphasis role="strong">Control plane node sizing</emphasis> section, where the monitoring stack and the default ingress-controller were moved to these nodes.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Number of worker nodes</entry>
<entry align="left" valign="top">Cluster density, or number of namespaces</entry>
<entry align="left" valign="top">CPU cores</entry>
<entry align="left" valign="top">Memory (GB)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>24</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>48</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>252</simpara></entry>
<entry align="left" valign="top"><simpara>4000</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>128</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>501</simpara></entry>
<entry align="left" valign="top"><simpara>4000</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>128</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In general, three infrastructure nodes are recommended per cluster.</simpara>
<important>
<simpara>These sizing recommendations should be used as a guideline. Prometheus is a highly memory intensive application; the resource usage depends on various factors including the number of nodes, objects, the Prometheus metrics scraping interval, metrics or time series, and the age of the cluster. In addition, the router resource usage can also be affected by the number of routes and the amount/type of inbound requests.</simpara>
<simpara>These recommendations apply only to infrastructure nodes hosting Monitoring, Ingress and Registry infrastructure components installed during cluster creation.</simpara>
</important>
<note>
<simpara>In OpenShift Container Platform 4.14, half of a CPU core (500 millicore) is now reserved by the system by default compared to OpenShift Container Platform 3.11 and previous versions. This influences the stated sizing recommendations.</simpara>
</note>
</section>
<section xml:id="scaling-cluster-monitoring-operator_recommended-infrastructure-practices">
<title>Scaling the Cluster Monitoring Operator</title>
<simpara>OpenShift Container Platform exposes metrics that the Cluster Monitoring Operator collects and stores in the Prometheus-based monitoring stack. As an administrator, you can view dashboards for system resources, containers, and components metrics in the OpenShift Container Platform web console by navigating to <emphasis role="strong">Observe</emphasis> &#8594; <emphasis role="strong">Dashboards</emphasis>.</simpara>
</section>
<section xml:id="prometheus-database-storage-requirements_recommended-infrastructure-practices">
<title>Prometheus database storage requirements</title>
<simpara>Red Hat performed various tests for different scale sizes.</simpara>
<note>
<simpara>The Prometheus storage requirements below are not prescriptive and should be used as a reference. Higher resource consumption might be observed in your cluster depending on workload activity and resource density, including the number of pods, containers, routes, or other resources exposing metrics collected by Prometheus.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Prometheus Database storage requirements based on number of nodes/pods in the cluster</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Number of Nodes</entry>
<entry align="left" valign="top">Number of pods (2 containers per pod)</entry>
<entry align="left" valign="top">Prometheus storage growth per day</entry>
<entry align="left" valign="top">Prometheus storage growth per 15 days</entry>
<entry align="left" valign="top">Network (per tsdb chunk)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>1800</simpara></entry>
<entry align="left" valign="top"><simpara>6.3 GB</simpara></entry>
<entry align="left" valign="top"><simpara>94 GB</simpara></entry>
<entry align="left" valign="top"><simpara>16 MB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>3600</simpara></entry>
<entry align="left" valign="top"><simpara>13 GB</simpara></entry>
<entry align="left" valign="top"><simpara>195 GB</simpara></entry>
<entry align="left" valign="top"><simpara>26 MB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>150</simpara></entry>
<entry align="left" valign="top"><simpara>5400</simpara></entry>
<entry align="left" valign="top"><simpara>19 GB</simpara></entry>
<entry align="left" valign="top"><simpara>283 GB</simpara></entry>
<entry align="left" valign="top"><simpara>36 MB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>7200</simpara></entry>
<entry align="left" valign="top"><simpara>25 GB</simpara></entry>
<entry align="left" valign="top"><simpara>375 GB</simpara></entry>
<entry align="left" valign="top"><simpara>46 MB</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Approximately 20 percent of the expected size was added as overhead to ensure that the storage requirements do not exceed the calculated value.</simpara>
<simpara>The above calculation is for the default OpenShift Container Platform Cluster Monitoring Operator.</simpara>
<note>
<simpara>CPU utilization has minor impact. The ratio is approximately 1 core out of 40 per 50 nodes and 1800 pods.</simpara>
</note>
<simpara><emphasis role="strong">Recommendations for OpenShift Container Platform</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Use at least two infrastructure (infra) nodes.</simpara>
</listitem>
<listitem>
<simpara>Use at least three <emphasis role="strong">openshift-container-storage</emphasis> nodes with non-volatile memory express (SSD or NVMe) drives.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-cluster-monitoring_recommended-infrastructure-practices">
<title>Configuring cluster monitoring</title>
<simpara role="_abstract">You can increase the storage capacity for the Prometheus component in the cluster monitoring stack.</simpara>
<formalpara>
<title>Procedure</title>
<para>To increase the storage capacity for Prometheus:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML configuration file, <literal>cluster-monitoring-config.yaml</literal>. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
data:
  config.yaml: |
    prometheusK8s:
      retention: {{PROMETHEUS_RETENTION_PERIOD}} <co xml:id="CO2-1"/>
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      volumeClaimTemplate:
        spec:
          storageClassName: {{STORAGE_CLASS}} <co xml:id="CO2-2"/>
          resources:
            requests:
              storage: {{PROMETHEUS_STORAGE_SIZE}} <co xml:id="CO2-3"/>
    alertmanagerMain:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      volumeClaimTemplate:
        spec:
          storageClassName: {{STORAGE_CLASS}} <co xml:id="CO2-4"/>
          resources:
            requests:
              storage: {{ALERTMANAGER_STORAGE_SIZE}} <co xml:id="CO2-5"/>
metadata:
  name: cluster-monitoring-config
  namespace: openshift-monitoring</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>The default value of Prometheus retention is <literal>PROMETHEUS_RETENTION_PERIOD=15d</literal>. Units are measured in time using one of these suffixes: s, m, h, d.</para>
</callout>
<callout arearefs="CO2-2 CO2-4">
<para>The storage class for your cluster.</para>
</callout>
<callout arearefs="CO2-3">
<para>A typical value is <literal>PROMETHEUS_STORAGE_SIZE=2000Gi</literal>. Storage values can be a plain integer or a fixed-point integer using one of these suffixes: E, P, T, G, M, K. You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi, Mi, Ki.</para>
</callout>
<callout arearefs="CO2-5">
<para>A typical value is <literal>ALERTMANAGER_STORAGE_SIZE=20Gi</literal>. Storage values can be a plain integer or a fixed-point integer using one of these suffixes: E, P, T, G, M, K. You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi, Mi, Ki.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add values for the retention period, storage class, and storage sizes.</simpara>
</listitem>
<listitem>
<simpara>Save the file.</simpara>
</listitem>
<listitem>
<simpara>Apply the changes by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cluster-monitoring-config.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/solutions/5034771">Infrastructure Nodes in OpenShift 4</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="planning-your-environment-according-to-object-maximums">OpenShift Container Platform cluster maximums</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#creating-infrastructure-machinesets">Creating infrastructure machine sets</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="recommended-etcd-practices">
<title>Recommended etcd practices</title>
<simpara>This topic provides recommended performance and scalability practices for etcd in OpenShift Container Platform.</simpara>
<section xml:id="recommended-etcd-practices_recommended-etcd-practices">
<title>Recommended etcd practices</title>
<simpara>Because etcd writes data to disk and persists proposals on disk, its performance depends on disk performance.
Although etcd is not particularly I/O intensive, it requires a low latency block device for optimal performance and stability. Because etcd&#8217;s consensus protocol depends on persistently storing metadata to a log (WAL), etcd is sensitive to disk-write latency. Slow disks and disk activity from other processes can cause long fsync latencies.</simpara>
<simpara>Those latencies can cause etcd to miss heartbeats, not commit new proposals to the disk on time, and ultimately experience request timeouts and temporary leader loss. High write latencies also lead to an OpenShift API slowness, which affects cluster performance. Because of these reasons, avoid colocating other workloads on the control-plane nodes that are I/O sensitive or intensive and share the same underlying I/O infrastructure.</simpara>
<simpara>In terms of latency, run etcd on top of a block device that can write at least 50 IOPS of 8000 bytes long sequentially. That is, with a latency of 10ms, keep in mind that uses fdatasync to synchronize each write in the WAL. For heavy loaded clusters, sequential 500 IOPS of 8000 bytes (2 ms) are recommended. To measure those numbers, you can use a benchmarking tool, such as fio.</simpara>
<simpara>To achieve such performance, run etcd on machines that are backed by SSD or NVMe disks with low latency and high throughput. Consider single-level cell (SLC) solid-state drives (SSDs), which provide 1 bit per memory cell, are durable and reliable, and are ideal for write-intensive workloads.</simpara>
<note>
<simpara>The load on etcd arises from static factors, such as the number of nodes and pods, and dynamic factors, including changes in endpoints due to pod autoscaling, pod restarts, job executions, and other workload-related events. To accurately size your etcd setup, you must analyze the specific requirements of your workload. Consider the number of nodes, pods, and other relevant factors that impact the load on etcd.</simpara>
</note>
<simpara>The following hard disk features provide optimal etcd performance:</simpara>
<itemizedlist>
<listitem>
<simpara>Low latency to support fast read operation.</simpara>
</listitem>
<listitem>
<simpara>High-bandwidth writes for faster compactions and defragmentation.</simpara>
</listitem>
<listitem>
<simpara>High-bandwidth reads for faster recovery from failures.</simpara>
</listitem>
<listitem>
<simpara>Solid state drives as a minimum selection, however NVMe drives are preferred.</simpara>
</listitem>
<listitem>
<simpara>Server-grade hardware from various manufacturers for increased reliability.</simpara>
</listitem>
<listitem>
<simpara>RAID 0 technology for increased performance.</simpara>
</listitem>
<listitem>
<simpara>Dedicated etcd drives. Do not place log files or other heavy workloads on etcd drives.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Avoid NAS or SAN setups and spinning drives. Ceph Rados Block Device (RBD) and other types of network-attached storage can result in unpredictable network latency. To provide fast storage to etcd nodes at scale, use PCI passthrough to pass NVM devices directly to the nodes.</simpara>
</note>
<simpara>Always benchmark by using utilities such as fio. You can use such utilities to continuously monitor the cluster performance as it increases.</simpara>
<note>
<simpara>Avoid using the Network File System (NFS) protocol or other network based file systems.</simpara>
</note>
<simpara>Some key metrics to monitor on a deployed OpenShift Container Platform cluster are p99 of etcd disk write ahead log duration and the number of etcd leader changes. Use Prometheus to track these metrics.</simpara>
<note>
<simpara>The etcd member database sizes can vary in a cluster during normal operations. This difference does not affect cluster upgrades, even if the leader size is different from the other members.</simpara>
</note>
<simpara>To validate the hardware for etcd before or after you create the OpenShift Container Platform cluster, you can use fio.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Container runtimes such as Podman or Docker are installed on the machine that you&#8217;re testing.</simpara>
</listitem>
<listitem>
<simpara>Data is written to the <literal>/var/lib/etcd</literal> path.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run fio and analyze the results:</simpara>
<itemizedlist>
<listitem>
<simpara>If you use Podman, run this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo podman run --volume /var/lib/etcd:/var/lib/etcd:Z quay.io/cloud-bulldozer/etcd-perf</programlisting>
</listitem>
<listitem>
<simpara>If you use Docker, run this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo docker run --volume /var/lib/etcd:/var/lib/etcd:Z quay.io/cloud-bulldozer/etcd-perf</programlisting>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The output reports whether the disk is fast enough to host etcd by comparing the 99th percentile of the fsync metric captured from the run to see if it is less than 10 ms. A few of the most important etcd metrics that might affected by I/O performance are as follow:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>etcd_disk_wal_fsync_duration_seconds_bucket</literal> metric reports the etcd&#8217;s WAL fsync duration</simpara>
</listitem>
<listitem>
<simpara><literal>etcd_disk_backend_commit_duration_seconds_bucket</literal>  metric reports the etcd backend commit latency duration</simpara>
</listitem>
<listitem>
<simpara><literal>etcd_server_leader_changes_seen_total</literal> metric reports the leader changes</simpara>
</listitem>
</itemizedlist>
<simpara>Because etcd replicates the requests among all the members, its performance strongly depends on network input/output (I/O) latency. High network latencies result in etcd heartbeats taking longer than the election timeout, which results in leader elections that are disruptive to the cluster. A key metric to monitor on a deployed OpenShift Container Platform cluster is the 99th percentile of etcd network peer latency on each etcd cluster member. Use Prometheus to track the metric.</simpara>
<simpara>The <literal>histogram_quantile(0.99, rate(etcd_network_peer_round_trip_time_seconds_bucket[2m]))</literal> metric reports the round trip time for etcd to finish replicating the client requests between the members. Ensure that it is less than 50 ms.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/solutions/4885641">How to use <literal>fio</literal> to check etcd disk performance in OpenShift Container Platform</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/articles/6271341">etcd performance troubleshooting guide for OpenShift Container Platform</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="move-etcd-different-disk_recommended-etcd-practices">
<title>Moving etcd to a different disk</title>
<simpara>You can move etcd from a shared disk to a separate disk to prevent or resolve performance issues.</simpara>
<simpara>The Machine Config Operator (MCO) is responsible for mounting a secondary disk for OpenShift Container Platform 4.14 container storage.</simpara>
<note>
<simpara>This procedure does not move parts of the root file system, such as <literal>/var/</literal>, to another disk or partition on an installed node.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>The <literal>MachineConfigPool</literal> must match <literal>metadata.labels[machineconfiguration.openshift.io/role]</literal>. This applies to a controller, worker, or a custom pool.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Attach the new disk to the cluster and verify that the disk is detected in the node by using the <literal>lsblk</literal> command in a debug shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered"># lsblk</programlisting>
<simpara>Note the device name of the new disk reported by the <literal>lsblk</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>MachineConfig</literal> YAML file named <literal>etcd-mc.yml</literal> with contents such as the following, replacing instances of <literal>&lt;new_disk_name&gt;</literal> with the noted device name:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 98-var-lib-etcd
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - contents: |
          [Unit]
          Description=Make File System on /dev/&lt;new_disk_name&gt;
          DefaultDependencies=no
          BindsTo=dev-&lt;new_disk_name&gt;.device
          After=dev-&lt;new_disk_name&gt;.device var.mount
          Before=systemd-fsck@dev-&lt;new_disk_name&gt;.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          ExecStart=/usr/lib/systemd/systemd-makefs xfs /dev/&lt;new_disk_name&gt;
          TimeoutSec=0

          [Install]
          WantedBy=var-lib-containers.mount
        enabled: true
        name: systemd-mkfs@dev-&lt;new_disk_name&gt;.service
      - contents: |
          [Unit]
          Description=Mount /dev/&lt;new_disk_name&gt; to /var/lib/etcd
          Before=local-fs.target
          Requires=systemd-mkfs@dev-&lt;new_disk_name&gt;.service
          After=systemd-mkfs@dev-&lt;new_disk_name&gt;.service var.mount

          [Mount]
          What=/dev/&lt;new_disk_name&gt;
          Where=/var/lib/etcd
          Type=xfs
          Options=defaults,prjquota

          [Install]
          WantedBy=local-fs.target
        enabled: true
        name: var-lib-etcd.mount
      - contents: |
          [Unit]
          Description=Sync etcd data if new mount is empty
          DefaultDependencies=no
          After=var-lib-etcd.mount var.mount
          Before=crio.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          ExecCondition=/usr/bin/test ! -d /var/lib/etcd/member
          ExecStart=semanage fcontext -a -e /sysroot/ostree/deploy/rhcos/var/lib/etcd/ /var/lib/etcd/
          ExecStart=/bin/rsync -ar /sysroot/ostree/deploy/rhcos/var/lib/etcd/ /var/lib/etcd/
          TimeoutSec=0

          [Install]
          WantedBy=multi-user.target graphical.target
        enabled: true
        name: sync-var-lib-etcd-to-etcd.service
      - contents: |
          [Unit]
          Description=Restore recursive SELinux security contexts
          DefaultDependencies=no
          After=var-lib-etcd.mount
          Before=crio.service

          [Service]
          Type=oneshot
          RemainAfterExit=yes
          ExecStart=/sbin/restorecon -R /var/lib/etcd/
          TimeoutSec=0

          [Install]
          WantedBy=multi-user.target graphical.target
        enabled: true
        name: restorecon-var-lib-etcd.service</programlisting>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user with <literal>cluster-admin</literal> privileges and create the machine configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt; -p &lt;password&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f etcd-mc.yml</programlisting>
<simpara>The nodes are updated and rebooted. After the reboot completes, the following events occur:</simpara>
<itemizedlist>
<listitem>
<simpara>An XFS file system is created on the specified disk.</simpara>
</listitem>
<listitem>
<simpara>The disk mounts to <literal>/var/lib/etcd</literal>.</simpara>
</listitem>
<listitem>
<simpara>The content from <literal>/sysroot/ostree/deploy/rhcos/var/lib/etcd</literal> syncs to <literal>/var/lib/etcd</literal>.</simpara>
</listitem>
<listitem>
<simpara>A restore of <literal>SELinux</literal> labels is forced for <literal>/var/lib/etcd</literal>.</simpara>
</listitem>
<listitem>
<simpara>The old content is not removed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After the nodes are on a separate disk, update the <literal>etcd-mc.yml</literal> file with contents such as the following, replacing instances of <literal>&lt;new_disk_name&gt;</literal> with the noted device name:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 98-var-lib-etcd
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - contents: |
          [Unit]
          Description=Mount /dev/&lt;new_disk_name&gt; to /var/lib/etcd
          Before=local-fs.target
          After=var.mount

          [Mount]
          What=/dev/&lt;new_disk_name&gt;
          Where=/var/lib/etcd
          Type=xfs
          Options=defaults,prjquota

          [Install]
          WantedBy=local-fs.target
        enabled: true
        name: var-lib-etcd.mount</programlisting>
</listitem>
<listitem>
<simpara>Apply the modified version that removes the logic for creating and syncing the device to prevent the nodes from rebooting:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc replace -f etcd-mc.yml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification steps</title>
<listitem>
<simpara>Run the <literal>grep &lt;new_disk_name&gt; /proc/mounts</literal> command in a debug shell for the node to ensure that the disk mounted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered"># grep &lt;new_disk_name&gt; /proc/mounts</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/dev/nvme1n1 /var/lib/etcd xfs rw,seclabel,relatime,attr2,inode64,logbufs=8,logbsize=32k,prjquota 0 0</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/container-platform/4.11/architecture/architecture-rhcos.html">Red Hat Enterprise Linux CoreOS (RHCOS)</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="etcd-defrag_recommended-etcd-practices">
<title>Defragmenting etcd data</title>
<simpara>For large and dense clusters, etcd can suffer from poor performance if the keyspace grows too large and exceeds the space quota. Periodically maintain and defragment etcd to free up space in the data store. Monitor Prometheus for etcd metrics and defragment it when required; otherwise, etcd can raise a cluster-wide alarm that puts the cluster into a maintenance mode that accepts only key reads and deletes.</simpara>
<simpara>Monitor these key metrics:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>etcd_server_quota_backend_bytes</literal>, which is the current quota limit</simpara>
</listitem>
<listitem>
<simpara><literal>etcd_mvcc_db_total_size_in_use_in_bytes</literal>, which indicates the actual database usage after a history compaction</simpara>
</listitem>
<listitem>
<simpara><literal>etcd_mvcc_db_total_size_in_bytes</literal>, which shows the database size, including free space waiting for defragmentation</simpara>
</listitem>
</itemizedlist>
<simpara>Defragment etcd data to reclaim disk space after events that cause disk fragmentation, such as etcd history compaction.</simpara>
<simpara>History compaction is performed automatically every five minutes and leaves gaps in the back-end database. This fragmented space is available for use by etcd, but is not available to the host file system. You must defragment etcd to make this space available to the host file system.</simpara>
<simpara>Defragmentation occurs automatically, but you can also trigger it manually.</simpara>
<note>
<simpara>Automatic defragmentation is good for most cases, because the etcd operator uses cluster information to determine the most efficient operation for the user.</simpara>
</note>
<section xml:id="automatic-defrag-etcd-data_recommended-etcd-practices">
<title>Automatic defragmentation</title>
<simpara>The etcd Operator automatically defragments disks. No manual intervention is needed.</simpara>
<simpara>Verify that the defragmentation process is successful by viewing one of these logs:</simpara>
<itemizedlist>
<listitem>
<simpara>etcd logs</simpara>
</listitem>
<listitem>
<simpara>cluster-etcd-operator pod</simpara>
</listitem>
<listitem>
<simpara>operator status error log</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Automatic defragmentation can cause leader election failure in various OpenShift core components, such as the Kubernetes controller manager, which triggers a restart of the failing component. The restart is harmless and either triggers failover to the next running instance or the component resumes work again after the restart.</simpara>
</warning>
<formalpara>
<title>Example log output for successful defragmentation</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">etcd member has been defragmented: <emphasis>&lt;member_name&gt;</emphasis>, memberID: <emphasis>&lt;member_id&gt;</emphasis></programlisting>
</para>
</formalpara>
<formalpara>
<title>Example log output for unsuccessful defragmentation</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">failed defrag on member: <emphasis>&lt;member_name&gt;</emphasis>, memberID: <emphasis>&lt;member_id&gt;</emphasis>: <emphasis>&lt;error_message&gt;</emphasis></programlisting>
</para>
</formalpara>
</section>
<section xml:id="manual-defrag-etcd-data_recommended-etcd-practices">
<title>Manual defragmentation</title>
<simpara>A Prometheus alert indicates when you need to use manual defragmentation. The alert is displayed in two cases:</simpara>
<itemizedlist>
<listitem>
<simpara>When etcd uses more than 50% of its available space for more than 10 minutes</simpara>
</listitem>
<listitem>
<simpara>When etcd is actively using less than 50% of its total database size for more than 10 minutes</simpara>
</listitem>
</itemizedlist>
<simpara>You can also determine whether defragmentation is needed by checking the etcd database size in MB that will be freed by defragmentation with the PromQL expression: <literal>(etcd_mvcc_db_total_size_in_bytes - etcd_mvcc_db_total_size_in_use_in_bytes)/1024/1024</literal></simpara>
<warning>
<simpara>Defragmenting etcd is a blocking action. The etcd member will not respond until defragmentation is complete. For this reason, wait at least one minute between defragmentation actions on each of the pods to allow the cluster to recover.</simpara>
</warning>
<simpara>Follow this procedure to defragment etcd data on each etcd member.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Determine which etcd member is the leader, because the leader should be defragmented last.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get the list of etcd pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-etcd get pods -l k8s-app=etcd -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">etcd-ip-10-0-159-225.example.redhat.com                3/3     Running     0          175m   10.0.159.225   ip-10-0-159-225.example.redhat.com   &lt;none&gt;           &lt;none&gt;
etcd-ip-10-0-191-37.example.redhat.com                 3/3     Running     0          173m   10.0.191.37    ip-10-0-191-37.example.redhat.com    &lt;none&gt;           &lt;none&gt;
etcd-ip-10-0-199-170.example.redhat.com                3/3     Running     0          176m   10.0.199.170   ip-10-0-199-170.example.redhat.com   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Choose a pod and run the following command to determine which etcd member is the leader:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh -n openshift-etcd etcd-ip-10-0-159-225.example.redhat.com etcdctl endpoint status --cluster -w table</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Defaulting container name to etcdctl.
Use 'oc describe pod/etcd-ip-10-0-159-225.example.redhat.com -n openshift-etcd' to see all of the containers in this pod.
+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|         ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|  https://10.0.191.37:2379 | 251cd44483d811c3 |   3.5.9 |  104 MB |     false |      false |         7 |      91624 |              91624 |        |
| https://10.0.159.225:2379 | 264c7c58ecbdabee |   3.5.9 |  104 MB |     false |      false |         7 |      91624 |              91624 |        |
| https://10.0.199.170:2379 | 9ac311f93915cc79 |   3.5.9 |  104 MB |      true |      false |         7 |      91624 |              91624 |        |
+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+</programlisting>
</para>
</formalpara>
<simpara>Based on the <literal>IS LEADER</literal> column of this output, the <literal>https://10.0.199.170:2379</literal> endpoint is the leader. Matching this endpoint with the output of the previous step, the pod name of the leader is <literal>etcd-ip-10-0-199-170.example.redhat.com</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Defragment an etcd member.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Connect to the running etcd container, passing in the name of a pod that is <emphasis>not</emphasis> the leader:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh -n openshift-etcd etcd-ip-10-0-159-225.example.redhat.com</programlisting>
</listitem>
<listitem>
<simpara>Unset the <literal>ETCDCTL_ENDPOINTS</literal> environment variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# unset ETCDCTL_ENDPOINTS</programlisting>
</listitem>
<listitem>
<simpara>Defragment the etcd member:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# etcdctl --command-timeout=30s --endpoints=https://localhost:2379 defrag</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Finished defragmenting etcd member[https://localhost:2379]</programlisting>
</para>
</formalpara>
<simpara>If a timeout error occurs, increase the value for <literal>--command-timeout</literal> until the command succeeds.</simpara>
</listitem>
<listitem>
<simpara>Verify that the database size was reduced:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# etcdctl endpoint status -w table --cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|         ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |
+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+
|  https://10.0.191.37:2379 | 251cd44483d811c3 |   3.5.9 |  104 MB |     false |      false |         7 |      91624 |              91624 |        |
| https://10.0.159.225:2379 | 264c7c58ecbdabee |   3.5.9 |   41 MB |     false |      false |         7 |      91624 |              91624 |        | <co xml:id="CO3-1"/>
| https://10.0.199.170:2379 | 9ac311f93915cc79 |   3.5.9 |  104 MB |      true |      false |         7 |      91624 |              91624 |        |
+---------------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+</programlisting>
</para>
</formalpara>
<simpara>This example shows that the database size for this etcd member is now 41 MB as opposed to the starting size of 104 MB.</simpara>
</listitem>
<listitem>
<simpara>Repeat these steps to connect to each of the other etcd members and defragment them. Always defragment the leader last.</simpara>
<simpara>Wait at least one minute between defragmentation actions to allow the etcd pod to recover. Until the etcd pod recovers, the etcd member will not respond.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If any <literal>NOSPACE</literal> alarms were triggered due to the space quota being exceeded, clear them.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check if there are any <literal>NOSPACE</literal> alarms:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# etcdctl alarm list</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">memberID:12345678912345678912 alarm:NOSPACE</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Clear the alarms:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# etcdctl alarm disarm</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="etcd-tuning-parameters_recommended-etcd-practices">
<title>Setting tuning parameters for etcd</title>
<simpara>You can set the control plane hardware speed to <literal>"Standard"</literal>, <literal>"Slower"</literal>, or the default, which is <literal>""</literal>.</simpara>
<simpara>The default setting allows the system to decide which speed to use. This value enables upgrades from versions where this feature does not exist, as the system can select values from previous versions.</simpara>
<simpara>By selecting one of the other values, you are overriding the default. If you see many leader elections due to timeouts or missed heartbeats and your system is set to <literal>""</literal> or <literal>"Standard"</literal>, set the hardware speed to <literal>"Slower"</literal> to make the system more tolerant to the increased latency.</simpara>
<important>
<simpara>Tuning etcd latency tolerances is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="etcd-changing-hardware-speed-tolerance_recommended-etcd-practices">
<title>Changing hardware speed tolerance</title>
<simpara>To change the hardware speed tolerance for etcd, complete the following steps.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have edited the cluster instance to enable Technology Preview features. For more information, see "Understanding feature gates".</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check to see what the current value is by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe etcd/cluster | grep "Control Plane Hardware Speed"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Control Plane Hardware Speed:  &lt;VALUE&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>If the output is empty, the field has not been set and should be considered as the default ("").</simpara>
</note>
</listitem>
<listitem>
<simpara>Change the value by entering the following command. Replace <literal>&lt;value&gt;</literal> with one of the valid values: <literal>""</literal>, <literal>"Standard"</literal>, or <literal>"Slower"</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc patch etcd/cluster --type=merge -p '{"spec": {"controlPlaneHardwareSpeed": "&lt;value&gt;"}}'</programlisting>
<simpara>The following table indicates the heartbeat interval and leader election timeout for each profile. These values are subject to change.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Profile</simpara></entry>
<entry align="left" valign="top"><simpara>ETCD_HEARTBEAT_INTERVAL</simpara></entry>
<entry align="left" valign="top"><simpara>ETCD_LEADER_ELECTION_TIMEOUT</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>""</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Varies depending on platform</simpara></entry>
<entry align="left" valign="top"><simpara>Varies depending on platform</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Standard</literal></simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Slower</literal></simpara></entry>
<entry align="left" valign="top"><simpara>500</simpara></entry>
<entry align="left" valign="top"><simpara>2500</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Review the output:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">etcd.operator.openshift.io/cluster patched</programlisting>
</para>
</formalpara>
<simpara>If you enter any value besides the valid values, error output is displayed. For example, if you entered <literal>"Faster"</literal> as the value, the output is as follows:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">The Etcd "cluster" is invalid: spec.controlPlaneHardwareSpeed: Unsupported value: "Faster": supported values: "", "Standard", "Slower"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the value was changed by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe etcd/cluster | grep "Control Plane Hardware Speed"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Control Plane Hardware Speed:  ""</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Wait for etcd pods to roll out:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get pods -n openshift-etcd -w</programlisting>
<simpara>The following output shows the expected entries for master-0. Before you continue, wait until all masters show a status of <literal>4/4 Running</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     Pending             0          0s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     Pending             0          0s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     ContainerCreating   0          0s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     ContainerCreating   0          1s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           1/1     Running             0          2s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     Completed           0          34s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     Completed           0          36s
installer-9-ci-ln-qkgs94t-72292-9clnd-master-0           0/1     Completed           0          36s
etcd-guard-ci-ln-qkgs94t-72292-9clnd-master-0            0/1     Running             0          26m
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  4/4     Terminating         0          11m
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  4/4     Terminating         0          11m
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  0/4     Pending             0          0s
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  0/4     Init:1/3            0          1s
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  0/4     Init:2/3            0          2s
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  0/4     PodInitializing     0          3s
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  3/4     Running             0          4s
etcd-guard-ci-ln-qkgs94t-72292-9clnd-master-0            1/1     Running             0          26m
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  3/4     Running             0          20s
etcd-ci-ln-qkgs94t-72292-9clnd-master-0                  4/4     Running             0          20s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Enter the following command to review to the values:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -n openshift-etcd pod/&lt;ETCD_PODNAME&gt; | grep -e HEARTBEAT_INTERVAL -e ELECTION_TIMEOUT</programlisting>
<note>
<simpara>These values might not have changed from the default.</simpara>
</note>
</listitem>
</orderedlist>
<formalpara role="_additional-resources">
<title>Additional resources</title>
<para><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-cluster-enabling-features-about_nodes-cluster-enabling">Understanding feature gates</link></para>
</formalpara>
</section>
</section>
</section>
</chapter>
<chapter xml:id="planning-your-environment-according-to-object-maximums">
<title>Planning your environment according to object maximums</title>
<simpara>Consider the following tested object maximums when you plan your OpenShift Container Platform cluster.</simpara>
<simpara>These guidelines are based on the largest possible cluster. For smaller clusters, the maximums are lower. There are many factors that influence the stated thresholds, including the etcd version or storage data format.</simpara>
<simpara>In most cases, exceeding these numbers results in lower overall performance. It does not necessarily mean that the cluster will fail.</simpara>
<warning>
<simpara>Clusters that experience rapid change, such as those with many starting and stopping pods, can have a lower practical maximum size than documented.</simpara>
</warning>
<section xml:id="cluster-maximums-major-releases_object-limits">
<title>OpenShift Container Platform tested cluster maximums for major releases</title>
<note>
<simpara>Red Hat does not provide direct guidance on sizing your OpenShift Container Platform cluster. This is because determining whether your cluster is within the supported bounds of OpenShift Container Platform requires careful consideration of all the multidimensional factors that limit the cluster scale.</simpara>
</note>
<simpara>OpenShift Container Platform supports tested cluster maximums rather than absolute cluster maximums. Not every combination of OpenShift Container Platform version, control plane workload, and network plugin are tested, so the following table does not represent an absolute expectation of scale for all deployments. It might not be possible to scale to a maximum on all dimensions simultaneously. The table contains tested maximums for specific workload and deployment configurations, and serves as a scale guide as to what can be expected with similar deployments.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Maximum type</entry>
<entry align="left" valign="top">4.x tested maximum</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Number of nodes</simpara></entry>
<entry align="left" valign="top"><simpara>2,000 <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of pods <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>150,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of pods per node</simpara></entry>
<entry align="left" valign="top"><simpara>2,500 <superscript>[3][4]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of pods per core</simpara></entry>
<entry align="left" valign="top"><simpara>There is no default value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of namespaces <superscript>[5]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>10,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of builds</simpara></entry>
<entry align="left" valign="top"><simpara>10,000 (Default pod RAM 512 Mi) - Source-to-Image (S2I) build strategy</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of pods per namespace <superscript>[6]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>25,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of routes and back ends per Ingress Controller</simpara></entry>
<entry align="left" valign="top"><simpara>2,000 per router</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of secrets</simpara></entry>
<entry align="left" valign="top"><simpara>80,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of config maps</simpara></entry>
<entry align="left" valign="top"><simpara>90,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of services <superscript>[7]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>10,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of services per namespace</simpara></entry>
<entry align="left" valign="top"><simpara>5,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of back-ends per service</simpara></entry>
<entry align="left" valign="top"><simpara>5,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of deployments per namespace <superscript>[6]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>2,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of build configs</simpara></entry>
<entry align="left" valign="top"><simpara>12,000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of custom resource definitions (CRD)</simpara></entry>
<entry align="left" valign="top"><simpara>1,024 <superscript>[8]</superscript></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Pause pods were deployed to stress the control plane components of OpenShift Container Platform at 2000 node scale. The ability to scale to similar numbers will vary depending upon specific deployment and workload parameters.</simpara>
</listitem>
<listitem>
<simpara>The pod count displayed here is the number of test pods. The actual number of pods depends on the application&#8217;s memory, CPU, and storage requirements.</simpara>
</listitem>
<listitem>
<simpara>This was tested on a cluster with 31 servers: 3 control planes, 2 infrastructure nodes, and 26 worker nodes. If you need 2,500 user pods, you need both a <literal>hostPrefix</literal> of <literal>20</literal>, which allocates a network large enough for each node to contain more than 2000 pods, and a custom kubelet config with <literal>maxPods</literal> set to <literal>2500</literal>. For more information, see <link xlink:href="https://cloud.redhat.com/blog/running-2500-pods-per-node-on-ocp-4.13">Running 2500 pods per node on OCP 4.13</link>.</simpara>
</listitem>
<listitem>
<simpara>The maximum tested pods per node is 2,500 for clusters using the <literal>OVNKubernetes</literal> network plugin. The maximum tested pods per node for the <literal>OpenShiftSDN</literal> network plugin is 500 pods.</simpara>
</listitem>
<listitem>
<simpara>When there are a large number of active projects, etcd might suffer from poor performance if the keyspace grows excessively large and exceeds the space quota. Periodic maintenance of etcd, including defragmentation, is highly recommended to free etcd storage.</simpara>
</listitem>
<listitem>
<simpara>There are several control loops in the system that must iterate over all objects in a given namespace as a reaction to some changes in state. Having a large number of objects of a given type in a single namespace can make those loops expensive and slow down processing given state changes. The limit assumes that the system has enough CPU, memory, and disk to satisfy the application requirements.</simpara>
</listitem>
<listitem>
<simpara>Each service port and each service back-end has a corresponding entry in <literal>iptables</literal>. The number of back-ends of a given service impact the size of the <literal>Endpoints</literal> objects, which impacts the size of data that is being sent all over the system.</simpara>
</listitem>
<listitem>
<simpara>Tested on a cluster with 29 servers: 3 control planes, 2 infrastructure nodes, and 24 worker nodes. The cluster had 500 namespaces. OpenShift Container Platform has a limit of 1,024 total custom resource definitions (CRD), including those installed by OpenShift Container Platform, products integrating with OpenShift Container Platform and user-created CRDs. If there are more than 1,024 CRDs created, then there is a possibility that <literal>oc</literal> command requests might be throttled.</simpara>
</listitem>
</orderedlist>
</para>
<section xml:id="cluster-maximums-major-releases-example-scenario_object-limits">
<title>Example scenario</title>
<simpara>As an example, 500 worker nodes (m5.2xl) were tested, and are supported, using OpenShift Container Platform 4.14, the OVN-Kubernetes network plugin, and the following workload objects:</simpara>
<itemizedlist>
<listitem>
<simpara>200 namespaces, in addition to the defaults</simpara>
</listitem>
<listitem>
<simpara>60 pods per node; 30 server and 30 client pods (30k total)</simpara>
</listitem>
<listitem>
<simpara>57 image streams/ns (11.4k total)</simpara>
</listitem>
<listitem>
<simpara>15 services/ns backed by the server pods (3k total)</simpara>
</listitem>
<listitem>
<simpara>15 routes/ns backed by the previous services (3k total)</simpara>
</listitem>
<listitem>
<simpara>20 secrets/ns (4k total)</simpara>
</listitem>
<listitem>
<simpara>10 config maps/ns (2k total)</simpara>
</listitem>
<listitem>
<simpara>6 network policies/ns, including deny-all, allow-from ingress and intra-namespace rules</simpara>
</listitem>
<listitem>
<simpara>57 builds/ns</simpara>
</listitem>
</itemizedlist>
<simpara>The following factors are known to affect cluster workload scaling, positively or negatively, and should be factored into the scale numbers when planning a deployment.  For additional information and guidance, contact your sales representative or <link xlink:href="https://access.redhat.com/support/">Red Hat support</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>Number of pods per node</simpara>
</listitem>
<listitem>
<simpara>Number of containers per pod</simpara>
</listitem>
<listitem>
<simpara>Type of probes used (for example, liveness/readiness, exec/http)</simpara>
</listitem>
<listitem>
<simpara>Number of network policies</simpara>
</listitem>
<listitem>
<simpara>Number of projects, or namespaces</simpara>
</listitem>
<listitem>
<simpara>Number of image streams per project</simpara>
</listitem>
<listitem>
<simpara>Number of builds per project</simpara>
</listitem>
<listitem>
<simpara>Number of services/endpoints and type</simpara>
</listitem>
<listitem>
<simpara>Number of routes</simpara>
</listitem>
<listitem>
<simpara>Number of shards</simpara>
</listitem>
<listitem>
<simpara>Number of secrets</simpara>
</listitem>
<listitem>
<simpara>Number of config maps</simpara>
</listitem>
<listitem>
<simpara>Rate of API calls, or the cluster churn, which is an estimation of how quickly things change in the cluster configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>Prometheus query for pod creation requests per second over 5 minute windows: <literal>sum(irate(apiserver_request_count{resource="pods",verb="POST"}[5m]))</literal></simpara>
</listitem>
<listitem>
<simpara>Prometheus query for all API requests per second over 5 minute windows: <literal>sum(irate(apiserver_request_count{}[5m]))</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cluster node resource consumption of CPU</simpara>
</listitem>
<listitem>
<simpara>Cluster node resource consumption of memory</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cluster-maximums-environment_object-limits">
<title>OpenShift Container Platform environment and configuration on which the cluster maximums are tested</title>
<section xml:id="_aws-cloud-platform">
<title>AWS cloud platform</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="8">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="12.5*"/>
<colspec colname="col_3" colwidth="12.5*"/>
<colspec colname="col_4" colwidth="12.5*"/>
<colspec colname="col_5" colwidth="12.5*"/>
<colspec colname="col_6" colwidth="12.5*"/>
<colspec colname="col_7" colwidth="12.5*"/>
<colspec colname="col_8" colwidth="12.5*"/>
<thead>
<row>
<entry align="left" valign="top">Node</entry>
<entry align="left" valign="top">Flavor</entry>
<entry align="left" valign="top">vCPU</entry>
<entry align="left" valign="top">RAM(GiB)</entry>
<entry align="left" valign="top">Disk type</entry>
<entry align="left" valign="top">Disk size(GiB)/IOS</entry>
<entry align="left" valign="top">Count</entry>
<entry align="left" valign="top">Region</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Control plane/etcd <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>r5.4xlarge</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>128</simpara></entry>
<entry align="left" valign="top"><simpara>gp3</simpara></entry>
<entry align="left" valign="top"><simpara>220</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>us-west-2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Infra <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>m5.12xlarge</simpara></entry>
<entry align="left" valign="top"><simpara>48</simpara></entry>
<entry align="left" valign="top"><simpara>192</simpara></entry>
<entry align="left" valign="top"><simpara>gp3</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>us-west-2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Workload <superscript>[3]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>m5.4xlarge</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>gp3</simpara></entry>
<entry align="left" valign="top"><simpara>500 <superscript>[4]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>us-west-2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Compute</simpara></entry>
<entry align="left" valign="top"><simpara>m5.2xlarge</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>gp3</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>3/25/250/500 <superscript>[5]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>us-west-2</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>gp3 disks with a baseline performance of 3000 IOPS and 125 MiB per second are used for control plane/etcd nodes because etcd is latency sensitive. gp3 volumes do not use burst performance.</simpara>
</listitem>
<listitem>
<simpara>Infra nodes are used to host Monitoring, Ingress, and Registry components to ensure they have enough resources to run at large scale.</simpara>
</listitem>
<listitem>
<simpara>Workload node is dedicated to run performance and scalability workload generators.</simpara>
</listitem>
<listitem>
<simpara>Larger disk size is used so that there is enough space to store the large amounts of data that is collected during the performance and scalability test run.</simpara>
</listitem>
<listitem>
<simpara>Cluster is scaled in iterations and performance and scalability tests are executed at the specified node counts.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="_ibm-power-platform">
<title>IBM Power platform</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6666*"/>
<colspec colname="col_6" colwidth="16.667*"/>
<thead>
<row>
<entry align="left" valign="top">Node</entry>
<entry align="left" valign="top">vCPU</entry>
<entry align="left" valign="top">RAM(GiB)</entry>
<entry align="left" valign="top">Disk type</entry>
<entry align="left" valign="top">Disk size(GiB)/IOS</entry>
<entry align="left" valign="top">Count</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Control plane/etcd <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>io1</simpara></entry>
<entry align="left" valign="top"><simpara>120 / 10 IOPS per GiB</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Infra <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>gp2</simpara></entry>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Workload <superscript>[3]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>256</simpara></entry>
<entry align="left" valign="top"><simpara>gp2</simpara></entry>
<entry align="left" valign="top"><simpara>120 <superscript>[4]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Compute</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>gp2</simpara></entry>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>2 to 100 <superscript>[5]</superscript></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>io1 disks with 120 / 10 IOPS per GiB are used for control plane/etcd nodes as etcd is I/O intensive and latency sensitive.</simpara>
</listitem>
<listitem>
<simpara>Infra nodes are used to host Monitoring, Ingress, and Registry components to ensure they have enough resources to run at large scale.</simpara>
</listitem>
<listitem>
<simpara>Workload node is dedicated to run performance and scalability workload generators.</simpara>
</listitem>
<listitem>
<simpara>Larger disk size is used so that there is enough space to store the large amounts of data that is collected during the performance and scalability test run.</simpara>
</listitem>
<listitem>
<simpara>Cluster is scaled in iterations.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="_ibm-z-platform">
<title>IBM Z platform</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6666*"/>
<colspec colname="col_6" colwidth="16.667*"/>
<thead>
<row>
<entry align="left" valign="top">Node</entry>
<entry align="left" valign="top">vCPU <superscript>[4]</superscript></entry>
<entry align="left" valign="top">RAM(GiB)<superscript>[5]</superscript></entry>
<entry align="left" valign="top">Disk type</entry>
<entry align="left" valign="top">Disk size(GiB)/IOS</entry>
<entry align="left" valign="top">Count</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Control plane/etcd <superscript>[1,2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>ds8k</simpara></entry>
<entry align="left" valign="top"><simpara>300 / LCU 1</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Compute <superscript>[1,3]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>ds8k</simpara></entry>
<entry align="left" valign="top"><simpara>150 / LCU 2</simpara></entry>
<entry align="left" valign="top"><simpara>4 nodes (scaled to 100/250/500 pods per node)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Nodes are distributed between two logical control units (LCUs) to optimize disk I/O load of the control plane/etcd nodes as etcd is I/O intensive and latency sensitive. Etcd I/O demand should not interfere with other workloads.</simpara>
</listitem>
<listitem>
<simpara>Four compute nodes are used for the tests running several iterations with 100/250/500 pods at the same time. First, idling pods were used to evaluate if pods can be instanced. Next, a network and CPU demanding client/server workload were used to evaluate the stability of the system under stress. Client and server pods were pairwise deployed and each pair was spread over two compute nodes.</simpara>
</listitem>
<listitem>
<simpara>No separate workload node was used. The workload simulates a microservice workload between two compute nodes.</simpara>
</listitem>
<listitem>
<simpara>Physical number of processors used is six Integrated Facilities for Linux (IFLs).</simpara>
</listitem>
<listitem>
<simpara>Total physical memory used is 512 GiB.</simpara>
</listitem>
</orderedlist>
</para>
</section>
</section>
<section xml:id="how-to-plan-according-to-cluster-maximums_object-limits">
<title>How to plan your environment according to tested cluster maximums</title>
<important>
<simpara>Oversubscribing the physical resources on a node affects resource guarantees the Kubernetes scheduler makes during pod placement. Learn what measures you can take to avoid memory swapping.</simpara>
<simpara>Some of the tested maximums are stretched only in a single dimension. They will vary when many objects are running on the cluster.</simpara>
<simpara>The numbers noted in this documentation are based on Red Hat&#8217;s test methodology, setup, configuration, and tunings. These numbers can vary based on your own individual setup and environments.</simpara>
</important>
<simpara>While planning your environment, determine how many pods are expected to fit per node:</simpara>
<screen>required pods per cluster / pods per node = total number of nodes needed</screen>
<simpara>The default maximum number of pods per node is 250. However, the number of pods that fit on a node is dependent on the application itself. Consider the application&#8217;s memory, CPU, and storage requirements, as described in "How to plan your environment according to application requirements".</simpara>
<formalpara>
<title>Example scenario</title>
<para>If you want to scope your cluster for 2200 pods per cluster, you would need at least five nodes, assuming that there are 500 maximum pods per node:</para>
</formalpara>
<screen>2200 / 500 = 4.4</screen>
<simpara>If you increase the number of nodes to 20, then the pod distribution changes to 110 pods per node:</simpara>
<screen>2200 / 20 = 110</screen>
<simpara>Where:</simpara>
<screen>required pods per cluster / total number of nodes = expected pods per node</screen>
<simpara>OpenShift Container Platform comes with several system pods, such as SDN, DNS, Operators, and others, which run across every worker node by default. Therefore, the result of the above formula can vary.</simpara>
</section>
<section xml:id="how-to-plan-according-to-application-requirements_object-limits">
<title>How to plan your environment according to application requirements</title>
<simpara>Consider an example application environment:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Pod type</entry>
<entry align="left" valign="top">Pod quantity</entry>
<entry align="left" valign="top">Max memory</entry>
<entry align="left" valign="top">CPU cores</entry>
<entry align="left" valign="top">Persistent storage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>apache</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>500 MB</simpara></entry>
<entry align="left" valign="top"><simpara>0.5</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>node.js</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>postgresql</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>10 GB</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>JBoss EAP</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>1 GB</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Extrapolated requirements: 550 CPU cores, 450GB RAM, and 1.4TB storage.</simpara>
<simpara>Instance size for nodes can be modulated up or down, depending on your
preference. Nodes are often resource overcommitted. In this deployment
scenario, you can choose to run additional smaller nodes or fewer larger nodes
to provide the same amount of resources. Factors such as operational agility and
cost-per-instance should be considered.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Node type</entry>
<entry align="left" valign="top">Quantity</entry>
<entry align="left" valign="top">CPUs</entry>
<entry align="left" valign="top">RAM (GB)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Nodes (option 1)</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nodes (option 2)</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nodes (option 3)</simpara></entry>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Some applications lend themselves well to overcommitted environments, and some
do not. Most Java applications and applications that use huge pages are examples
of applications that would not allow for overcommitment. That memory can not be
used for other applications. In the example above, the environment would be
roughly 30 percent overcommitted, a common ratio.</simpara>
<simpara>The application pods can access a service either by using environment variables or DNS.
If using environment variables, for each active service the variables are injected by the
kubelet when a pod is run on a node. A cluster-aware DNS server watches the Kubernetes API
for new services and creates a set of DNS records for each one. If DNS is enabled throughout
your cluster, then all pods should automatically be able to resolve services by their DNS name.
Service discovery using DNS can be used in case you must go beyond 5000 services. When using
environment variables for service discovery, the argument list exceeds the allowed length after
5000 services in a namespace, then the pods and deployments will start failing. Disable the service
links in the deployment&#8217;s service specification file to overcome this:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: deployment-config-template
  creationTimestamp:
  annotations:
    description: This template will create a deploymentConfig with 1 replica, 4 env vars and a service.
    tags: ''
objects:
- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    name: deploymentconfig${IDENTIFIER}
  spec:
    template:
      metadata:
        labels:
          name: replicationcontroller${IDENTIFIER}
      spec:
        enableServiceLinks: false
        containers:
        - name: pause${IDENTIFIER}
          image: "${IMAGE}"
          ports:
          - containerPort: 8080
            protocol: TCP
          env:
          - name: ENVVAR1_${IDENTIFIER}
            value: "${ENV_VALUE}"
          - name: ENVVAR2_${IDENTIFIER}
            value: "${ENV_VALUE}"
          - name: ENVVAR3_${IDENTIFIER}
            value: "${ENV_VALUE}"
          - name: ENVVAR4_${IDENTIFIER}
            value: "${ENV_VALUE}"
          resources: {}
          imagePullPolicy: IfNotPresent
          capabilities: {}
          securityContext:
            capabilities: {}
            privileged: false
        restartPolicy: Always
        serviceAccount: ''
    replicas: 1
    selector:
      name: replicationcontroller${IDENTIFIER}
    triggers:
    - type: ConfigChange
    strategy:
      type: Rolling
- apiVersion: v1
  kind: Service
  metadata:
    name: service${IDENTIFIER}
  spec:
    selector:
      name: replicationcontroller${IDENTIFIER}
    ports:
    - name: serviceport${IDENTIFIER}
      protocol: TCP
      port: 80
      targetPort: 8080
    clusterIP: ''
    type: ClusterIP
    sessionAffinity: None
  status:
    loadBalancer: {}
parameters:
- name: IDENTIFIER
  description: Number to append to the name of resources
  value: '1'
  required: true
- name: IMAGE
  description: Image to use for deploymentConfig
  value: gcr.io/google-containers/pause-amd64:3.0
  required: false
- name: ENV_VALUE
  description: Value to use for environment variables
  generate: expression
  from: "[A-Za-z0-9]{255}"
  required: false
labels:
  template: deployment-config-template</programlisting>
<simpara>The number of application pods that can run in a namespace is dependent on the number of services and the length of the service name when the environment variables are used for service discovery. <literal>ARG_MAX</literal> on the system defines the maximum argument length for a new process and it is set to 2097152 bytes (2 MiB) by default. The Kubelet injects environment variables in to each pod scheduled to run in the namespace including:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_SERVICE_HOST=&lt;IP&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_SERVICE_PORT=&lt;PORT&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_PORT=tcp://&lt;IP&gt;:&lt;PORT&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_PORT_&lt;PORT&gt;_TCP=tcp://&lt;IP&gt;:&lt;PORT&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_PORT_&lt;PORT&gt;_TCP_PROTO=tcp</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_PORT_&lt;PORT&gt;_TCP_PORT=&lt;PORT&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>&lt;SERVICE_NAME&gt;_PORT_&lt;PORT&gt;_TCP_ADDR=&lt;ADDR&gt;</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The pods in the namespace will start to fail if the argument length exceeds the allowed value and the number of
characters in a service name impacts it. For example, in a namespace with 5000 services, the limit on the service name
is 33 characters, which enables you to run 5000 pods in the namespace.</simpara>
</section>
</chapter>
<chapter xml:id="ibm-z-recommended-host-practices">
<title>Recommended host practices for IBM Z &amp; IBM LinuxONE environments</title>
<simpara>This topic provides recommended host practices for OpenShift Container Platform on IBM Z&#174; and IBM&#174; LinuxONE.</simpara>
<note>
<simpara>The s390x architecture is unique in many aspects. Therefore, some recommendations made here might not apply to other platforms.</simpara>
</note>
<note>
<simpara>Unless stated otherwise, these practices apply to both z/VM and Red Hat Enterprise Linux (RHEL) KVM installations on IBM Z&#174; and IBM&#174; LinuxONE.</simpara>
</note>
<section xml:id="ibm-z-managing-cpu-overcommitment_ibm-z-recommended-host-practices">
<title>Managing CPU overcommitment</title>
<simpara>In a highly virtualized IBM Z&#174; environment, you must carefully plan the infrastructure setup and sizing. One of the most important features of virtualization is the capability to do resource overcommitment, allocating more resources to the virtual machines than actually available at the hypervisor level. This is very workload dependent and there is no golden rule that can be applied to all setups.</simpara>
<simpara>Depending on your setup, consider these best practices regarding CPU overcommitment:</simpara>
<itemizedlist>
<listitem>
<simpara>At LPAR level (PR/SM hypervisor), avoid assigning all available physical cores (IFLs) to each LPAR. For example, with four physical IFLs available, you should not define three LPARs with four logical IFLs each.</simpara>
</listitem>
<listitem>
<simpara>Check and understand LPAR shares and weights.</simpara>
</listitem>
<listitem>
<simpara>An excessive number of virtual CPUs can adversely affect performance. Do not define more virtual processors to a guest than logical processors are defined to the LPAR.</simpara>
</listitem>
<listitem>
<simpara>Configure the number of virtual processors per guest for peak workload, not more.</simpara>
</listitem>
<listitem>
<simpara>Start small and monitor the workload. Increase the vCPU number incrementally if necessary.</simpara>
</listitem>
<listitem>
<simpara>Not all workloads are suitable for high overcommitment ratios. If the workload is CPU intensive, you will probably not be able to achieve high ratios without performance problems. Workloads that are more I/O intensive can keep consistent performance even with high overcommitment ratios.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://www.vm.ibm.com/perf/tips/prgcom.html">z/VM Common Performance Problems and Solutions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/linux-on-systems?topic=overcommitment-considerations">z/VM overcommitment considerations</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/zos/2.2.0?topic=director-lpar-cpu-management">LPAR CPU management</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ibm-z-disable-thp_ibm-z-recommended-host-practices">
<title>Disable Transparent Huge Pages</title>
<simpara>Transparent Huge Pages (THP) attempt to automate most aspects of creating, managing, and using huge pages. Since THP automatically manages the huge pages, this is not always handled optimally for all types of workloads. THP can lead to performance regressions, since many applications handle huge pages on their own. Therefore, consider disabling THP.</simpara>
</section>
<section xml:id="ibm-z-boost-networking-performance-with-rfs_ibm-z-recommended-host-practices">
<title>Boost networking performance with Receive Flow Steering</title>
<simpara>Receive Flow Steering (RFS) extends Receive Packet Steering (RPS) by further reducing network latency. RFS is technically based on RPS, and improves the efficiency of packet processing by increasing the CPU cache hit rate. RFS achieves this, and in addition considers queue length, by determining the most convenient CPU for computation so that cache hits are more likely to occur within the CPU. Thus, the CPU cache is invalidated less and requires fewer cycles to rebuild the cache. This can help reduce packet processing run time.</simpara>
<section xml:id="use-the-mco-to-activate-rfs_ibm-z-recommended-host-practices">
<title>Use the Machine Config Operator (MCO) to activate RFS</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Copy the following MCO sample profile into a YAML file. For example, <literal>enable-rfs.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 50-enable-rfs
spec:
  config:
    ignition:
      version: 2.2.0
    storage:
      files:
      - contents:
          source: data:text/plain;charset=US-ASCII,%23%20turn%20on%20Receive%20Flow%20Steering%20%28RFS%29%20for%20all%20network%20interfaces%0ASUBSYSTEM%3D%3D%22net%22%2C%20ACTION%3D%3D%22add%22%2C%20RUN%7Bprogram%7D%2B%3D%22/bin/bash%20-c%20%27for%20x%20in%20/sys/%24DEVPATH/queues/rx-%2A%3B%20do%20echo%208192%20%3E%20%24x/rps_flow_cnt%3B%20%20done%27%22%0A
        filesystem: root
        mode: 0644
        path: /etc/udev/rules.d/70-persistent-net.rules
      - contents:
          source: data:text/plain;charset=US-ASCII,%23%20define%20sock%20flow%20enbtried%20for%20%20Receive%20Flow%20Steering%20%28RFS%29%0Anet.core.rps_sock_flow_entries%3D8192%0A
        filesystem: root
        mode: 0644
        path: /etc/sysctl.d/95-enable-rps.conf</programlisting>
</listitem>
<listitem>
<simpara>Create the MCO profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f enable-rfs.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that an entry named <literal>50-enable-rfs</literal> is listed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mc</programlisting>
</listitem>
<listitem>
<simpara>To deactivate, enter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete mc 50-enable-rfs</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://developer.ibm.com/tutorials/red-hat-openshift-on-ibm-z-tune-your-network-performance-with-rfs/">OpenShift Container Platform on IBM Z&#174;: Tune your network performance with RFS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/performance_tuning_guide/sect-red_hat_enterprise_linux-performance_tuning_guide-networking-configuration_tools#sect-Red_Hat_Enterprise_Linux-Performance_Tuning_Guide-Configuration_tools-Configuring_Receive_Flow_Steering_RFS">Configuring Receive Flow Steering (RFS)</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">Scaling in the Linux Networking Stack</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ibm-z-choose-networking-setup_ibm-z-recommended-host-practices">
<title>Choose your networking setup</title>
<simpara>The networking stack is one of the most important components for a Kubernetes-based product like OpenShift Container Platform. For IBM Z&#174; setups, the networking setup depends on the hypervisor of your choice. Depending on the workload and the application, the best fit usually changes with the use case and the traffic pattern.</simpara>
<simpara>Depending on your setup, consider these best practices:</simpara>
<itemizedlist>
<listitem>
<simpara>Consider all options regarding networking devices to optimize your traffic pattern. Explore the advantages of OSA-Express, RoCE Express, HiperSockets, z/VM VSwitch, Linux Bridge (KVM), and others to decide which option leads to the greatest benefit for your setup.</simpara>
</listitem>
<listitem>
<simpara>Always use the latest available NIC version. For example, OSA Express 7S 10 GbE shows great improvement compared to OSA Express 6S 10 GbE with transactional workload types, although both are 10 GbE adapters.</simpara>
</listitem>
<listitem>
<simpara>Each virtual switch adds an additional layer of latency.</simpara>
</listitem>
<listitem>
<simpara>The load balancer plays an important role for network communication outside the cluster. Consider using a production-grade hardware load balancer if this is critical for your application.</simpara>
</listitem>
<listitem>
<simpara>OpenShift Container Platform SDN introduces flows and rules, which impact the networking performance. Make sure to consider pod affinities and placements, to benefit from the locality of services where communication is critical.</simpara>
</listitem>
<listitem>
<simpara>Balance the trade-off between performance and functionality.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/linux-on-systems?topic=openshift-performance#openshift_perf__ocp_eval">OpenShift Container Platform on IBM Z&#174; - Performance Experiences, Hints and Tips</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/linux-on-systems?topic=openshift-performance#openshift_perf__ocp_net">OpenShift Container Platform on IBM Z&#174; Networking Performance</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#controlling-pod-placement-on-nodes-using-node-affinity-rules">Controlling pod placement on nodes using node affinity rules</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ibm-z-ensure-high-disk-performance-hyperpav_ibm-z-recommended-host-practices">
<title>Ensure high disk performance with HyperPAV on z/VM</title>
<simpara>DASD and ECKD devices are commonly used disk types in IBM Z&#174; environments. In a typical OpenShift Container Platform setup in z/VM environments, DASD disks are commonly used to support the local storage for the nodes. You can set up HyperPAV alias devices to provide more throughput and overall better I/O performance for the DASD disks that support the z/VM guests.</simpara>
<simpara>Using HyperPAV for the local storage devices leads to a significant performance benefit. However, you must be aware that there is a trade-off between throughput and CPU costs.</simpara>
<section xml:id="use-the-mco-to-activate-hyperpav-aliases-in-nodes-using-zvm-full-pack-minidisks_ibm-z-recommended-host-practices">
<title>Use the Machine Config Operator (MCO) to activate HyperPAV aliases in nodes using z/VM full-pack minidisks</title>
<simpara>For z/VM-based OpenShift Container Platform setups that use full-pack minidisks, you can leverage the advantage of MCO profiles by activating HyperPAV aliases in all of the nodes. You must add YAML configurations for both control plane and compute nodes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Copy the following MCO sample profile into a YAML file for the control plane node. For example, <literal>05-master-kernelarg-hpav.yaml</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat 05-master-kernelarg-hpav.yaml
apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 05-master-kernelarg-hpav
spec:
  config:
    ignition:
      version: 3.1.0
  kernelArguments:
    - rd.dasd=800-805</programlisting>
</listitem>
<listitem>
<simpara>Copy the following MCO sample profile into a YAML file for the compute node. For example, <literal>05-worker-kernelarg-hpav.yaml</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat 05-worker-kernelarg-hpav.yaml
apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 05-worker-kernelarg-hpav
spec:
  config:
    ignition:
      version: 3.1.0
  kernelArguments:
    - rd.dasd=800-805</programlisting>
<note>
<simpara>You must modify the <literal>rd.dasd</literal> arguments to fit the device IDs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the MCO profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f 05-master-kernelarg-hpav.yaml</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f 05-worker-kernelarg-hpav.yaml</programlisting>
</listitem>
<listitem>
<simpara>To deactivate, enter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f 05-master-kernelarg-hpav.yaml</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f 05-worker-kernelarg-hpav.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/linux-on-systems?topic=io-using-hyperpav-eckd-dasd">Using HyperPAV for ECKD DASD</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://public.dhe.ibm.com/software/dw/linux390/perf/zvm_hpav00.pdf">Scaling HyperPAV alias devices on Linux guests on z/VM</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ibm-z-rhel-kvm-host-recommendations_ibm-z-recommended-host-practices">
<title>RHEL KVM on IBM Z host recommendations</title>
<simpara>Optimizing a KVM virtual server environment strongly depends on the workloads of the virtual servers and on the available resources. The same action that enhances performance in one environment can have adverse effects in another. Finding the best balance for a particular setting can be a challenge and often involves experimentation.</simpara>
<simpara>The following section introduces some best practices when using OpenShift Container Platform with RHEL KVM on IBM Z&#174; and IBM&#174; LinuxONE environments.</simpara>
<section xml:id="use-io-threads-for-your-virtual-block-devices_ibm-z-recommended-host-practices">
<title>Use I/O threads for your virtual block devices</title>
<simpara>To make virtual block devices use I/O threads, you must configure one or more I/O threads for the virtual server and each virtual block device to use one of these I/O threads.</simpara>
<simpara>The following example specifies <literal>&lt;iothreads&gt;3&lt;/iothreads&gt;</literal>  to configure three I/O threads, with consecutive decimal thread IDs 1, 2, and 3. The <literal>iothread="2"</literal> parameter specifies the driver element of the disk device to use the I/O thread with ID 2.</simpara>
<formalpara>
<title>Sample I/O thread specification</title>
<para>
<programlisting language="xml" linenumbering="unnumbered">...
&lt;domain&gt;
 	&lt;iothreads&gt;3&lt;/iothreads&gt;<co xml:id="CO3-2"/>
  	 ...
    	&lt;devices&gt;
       ...
          &lt;disk type="block" device="disk"&gt;<co xml:id="CO3-3"/>
&lt;driver ... iothread="2"/&gt;
    &lt;/disk&gt;
       ...
    	&lt;/devices&gt;
   ...
&lt;/domain&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1 CO3-2">
<para>The number of I/O threads.</para>
</callout>
<callout arearefs="CO3-3">
<para>The driver element of the disk device.</para>
</callout>
</calloutlist>
<simpara>Threads can increase the performance of I/O operations for disk devices, but they also use memory and CPU resources. You can configure multiple devices to use the same thread. The best mapping of threads to devices depends on the available resources and the workload.</simpara>
<simpara>Start with a small number of I/O threads. Often, a single I/O thread for all disk devices is sufficient. Do not configure more threads than the number of virtual CPUs, and do not configure idle threads.</simpara>
<simpara>You can use the <literal>virsh iothreadadd</literal> command to add I/O threads with specific thread IDs to a running virtual server.</simpara>
</section>
<section xml:id="avoid-virtual-scsi-devices_ibm-z-recommended-host-practices">
<title>Avoid virtual SCSI devices</title>
<simpara>Configure virtual SCSI devices only if you need to address the device through SCSI-specific interfaces. Configure disk space as virtual block devices rather than virtual SCSI devices, regardless of the backing on the host.</simpara>
<simpara>However, you might need SCSI-specific interfaces for:</simpara>
<itemizedlist>
<listitem>
<simpara>A LUN for a SCSI-attached tape drive on the host.</simpara>
</listitem>
<listitem>
<simpara>A DVD ISO file on the host file system that is mounted on a virtual DVD drive.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="configure-guest-caching-for-disk_ibm-z-recommended-host-practices">
<title>Configure guest caching for disk</title>
<simpara>Configure your disk devices to do caching by the guest and not by the host.</simpara>
<simpara>Ensure that the driver element of the disk device includes the <literal>cache="none"</literal> and <literal>io="native"</literal> parameters.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;disk type="block" device="disk"&gt;
    &lt;driver name="qemu" type="raw" cache="none" io="native" iothread="1"/&gt;
...
&lt;/disk&gt;</programlisting>
</section>
<section xml:id="exclude-the-memory-ballon-device_ibm-z-recommended-host-practices">
<title>Exclude the memory balloon device</title>
<simpara>Unless you need a dynamic memory size, do not define a memory balloon device and ensure that libvirt does not create one for you. Include the <literal>memballoon</literal> parameter as a child of the devices element in your domain configuration XML file.</simpara>
<itemizedlist>
<listitem>
<simpara>Check the list of active profiles:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;memballoon model="none"/&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="tune-the-cpu-migration-algorithm-of-the-host-scheduler_ibm-z-recommended-host-practices">
<title>Tune the CPU migration algorithm of the host scheduler</title>
<important>
<simpara>Do not change the scheduler settings unless you are an expert who understands the implications. Do not apply changes to production systems without testing them and confirming that they have the intended effect.</simpara>
</important>
<simpara>The <literal>kernel.sched_migration_cost_ns</literal> parameter specifies a time interval in nanoseconds. After the last execution of a task, the CPU cache is considered to have useful content until this interval expires. Increasing this interval results in fewer task migrations. The default value is 500000 ns.</simpara>
<simpara>If the CPU idle time is higher than expected when there are runnable processes, try reducing this interval. If tasks bounce between CPUs or nodes too often, try increasing it.</simpara>
<simpara>To dynamically set the interval to 60000 ns, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># sysctl kernel.sched_migration_cost_ns=60000</programlisting>
<simpara>To persistently change the value to 60000 ns, add the following entry to <literal>/etc/sysctl.conf</literal>:</simpara>
<programlisting language="config" linenumbering="unnumbered">kernel.sched_migration_cost_ns=60000</programlisting>
</section>
<section xml:id="disable-the-cpuset-cgroup-controller_ibm-z-recommended-host-practices">
<title>Disable the cpuset cgroup controller</title>
<note>
<simpara>This setting applies only to KVM hosts with cgroups version 1. To enable CPU hotplug on the host, disable the cgroup controller.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open <literal>/etc/libvirt/qemu.conf</literal> with an editor of your choice.</simpara>
</listitem>
<listitem>
<simpara>Go to the <literal>cgroup_controllers</literal> line.</simpara>
</listitem>
<listitem>
<simpara>Duplicate the entire line and remove the leading number sign (#) from the copy.</simpara>
</listitem>
<listitem>
<simpara>Remove the <literal>cpuset</literal> entry, as follows:</simpara>
<programlisting language="config" linenumbering="unnumbered">cgroup_controllers = [ "cpu", "devices", "memory", "blkio", "cpuacct" ]</programlisting>
</listitem>
<listitem>
<simpara>For the new setting to take effect, you must restart the libvirtd daemon:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Stop all virtual machines.</simpara>
</listitem>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># systemctl restart libvirtd</programlisting>
</listitem>
<listitem>
<simpara>Restart the virtual machines.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>This setting persists across host reboots.</simpara>
</section>
<section xml:id="tune-the-polling-period-for-idle-virtual-cpus_ibm-z-recommended-host-practices">
<title>Tune the polling period for idle virtual CPUs</title>
<simpara>When a virtual CPU becomes idle, KVM polls for wakeup conditions for the virtual CPU before allocating the host resource. You can specify the time interval, during which polling takes place in sysfs at <literal>/sys/module/kvm/parameters/halt_poll_ns</literal>. During the specified time, polling reduces the wakeup latency for the virtual CPU at the expense of resource usage. Depending on the workload, a longer or shorter time for polling can be beneficial. The time interval is specified in nanoseconds. The default is 50000 ns.</simpara>
<itemizedlist>
<listitem>
<simpara>To optimize for low CPU consumption, enter a small value or write 0 to disable polling:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># echo 0 &gt; /sys/module/kvm/parameters/halt_poll_ns</programlisting>
</listitem>
<listitem>
<simpara>To optimize for low latency, for example for transactional workloads, enter a large value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># echo 80000 &gt; /sys/module/kvm/parameters/halt_poll_ns</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://www.ibm.com/docs/en/linux-on-systems?topic=v-kvm">Linux on IBM Z&#174; Performance Tuning for KVM</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_virtualization/getting-started-with-virtualization-in-rhel-8-on-ibm-z_configuring-and-managing-virtualization">Getting started with virtualization on IBM Z&#174;</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="using-node-tuning-operator">
<title>Using the Node Tuning Operator</title>
<simpara>Learn about the Node Tuning Operator and how you can use it to manage node-level
tuning by orchestrating the tuned daemon.</simpara>
<section xml:id="about-node-tuning-operator_node-tuning-operator">
<title>About the Node Tuning Operator</title>
<simpara>The Node Tuning Operator helps you manage node-level tuning by orchestrating the TuneD daemon and achieves low latency performance by using the Performance Profile controller. The majority of high-performance applications require some level of kernel tuning. The Node Tuning Operator provides a unified management interface to users of node-level sysctls and more flexibility to add custom tuning specified by user needs.</simpara>
<simpara>The Operator manages the containerized TuneD daemon for OpenShift Container Platform as a Kubernetes daemon set. It ensures the custom tuning specification is passed to all containerized TuneD daemons running in the cluster in the format that the daemons understand. The daemons run on all nodes in the cluster, one per node.</simpara>
<simpara>Node-level settings applied by the containerized TuneD daemon are rolled back on an event that triggers a profile change or when the containerized TuneD daemon is terminated gracefully by receiving and handling a termination signal.</simpara>
<simpara>The Node Tuning Operator uses the Performance Profile controller to implement automatic tuning to achieve low latency performance for OpenShift Container Platform applications.</simpara>
<simpara>The cluster administrator configures a performance profile to define node-level settings such as the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Updating the kernel to kernel-rt.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for housekeeping.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for running workloads.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<simpara>The Node Tuning Operator is part of a standard OpenShift Container Platform installation in version 4.1 and later.</simpara>
<note>
<simpara>In earlier versions of OpenShift Container Platform, the Performance Addon Operator was used to implement automatic tuning to achieve low latency performance for OpenShift applications. In OpenShift Container Platform 4.11 and later, this functionality is part of the Node Tuning Operator.</simpara>
</note>
</section>
<section xml:id="accessing-an-example-node-tuning-operator-specification_node-tuning-operator">
<title>Accessing an example Node Tuning Operator specification</title>
<simpara>Use this process to access an example Node Tuning Operator specification.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to access an example Node Tuning Operator specification:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get tuned.tuned.openshift.io/default -o yaml -n openshift-cluster-node-tuning-operator</programlisting>
</listitem>
</itemizedlist>
<simpara>The default CR is meant for delivering standard node-level tuning for the OpenShift Container Platform platform and it can only be modified to set the Operator Management state. Any other custom changes to the default CR will be overwritten by the Operator. For custom tuning, create your own Tuned CRs. Newly created CRs will be combined with the default CR and custom tuning applied to OpenShift Container Platform nodes based on node or pod labels and profile priorities.</simpara>
<warning>
<simpara>While in certain situations the support for pod labels can be a convenient way of automatically delivering required tuning, this practice is discouraged and strongly advised against, especially in large-scale clusters. The default Tuned CR ships without pod label matching. If a custom profile is created with pod label matching, then the functionality will be enabled at that time. The pod label functionality will be deprecated in future versions of the Node Tuning Operator.</simpara>
</warning>
</section>
<section xml:id="custom-tuning-default-profiles-set_node-tuning-operator">
<title>Default profiles set on a cluster</title>
<simpara>The following are the default profiles set on a cluster.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: default
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Optimize systems running OpenShift (provider specific parent profile)
      include=-provider-${f:exec:cat:/var/lib/tuned/provider},openshift
    name: openshift
  recommend:
  - profile: openshift-control-plane
    priority: 30
    match:
    - label: node-role.kubernetes.io/master
    - label: node-role.kubernetes.io/infra
  - profile: openshift-node
    priority: 40</programlisting>
<simpara>Starting with OpenShift Container Platform 4.9, all OpenShift TuneD profiles are shipped with
the TuneD package. You can use the <literal>oc exec</literal> command to view the contents of these profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec $tuned_pod -n openshift-cluster-node-tuning-operator -- find /usr/lib/tuned/openshift{,-control-plane,-node} -name tuned.conf -exec grep -H ^ {} \;</programlisting>
</section>
<section xml:id="verifying-tuned-profiles-are-applied_node-tuning-operator">
<title>Verifying that the TuneD profiles are applied</title>
<simpara>Verify the TuneD profiles that are applied to your cluster node.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get profile.tuned.openshift.io -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             TUNED                     APPLIED   DEGRADED   AGE
master-0         openshift-control-plane   True      False      6h33m
master-1         openshift-control-plane   True      False      6h33m
master-2         openshift-control-plane   True      False      6h33m
worker-a         openshift-node            True      False      6h28m
worker-b         openshift-node            True      False      6h28m</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>NAME</literal>: Name of the Profile object. There is one Profile object per node and their names match.</simpara>
</listitem>
<listitem>
<simpara><literal>TUNED</literal>: Name of the desired TuneD profile to apply.</simpara>
</listitem>
<listitem>
<simpara><literal>APPLIED</literal>: <literal>True</literal> if the TuneD daemon applied the desired profile. (<literal>True/False/Unknown</literal>).</simpara>
</listitem>
<listitem>
<simpara><literal>DEGRADED</literal>: <literal>True</literal> if any errors were reported during application of the TuneD profile (<literal>True/False/Unknown</literal>).</simpara>
</listitem>
<listitem>
<simpara><literal>AGE</literal>: Time elapsed since the creation of Profile object.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>ClusterOperator/node-tuning</literal> object also contains useful information about the Operator and its node agents' health. For example, Operator misconfiguration is reported by <literal>ClusterOperator/node-tuning</literal> status messages.</simpara>
<simpara>To get status information about the <literal>ClusterOperator/node-tuning</literal> object, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get co/node-tuning -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME          VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE   MESSAGE
node-tuning   4.14.1    True        False         True       60m     1/5 Profiles with bootcmdline conflict</programlisting>
</para>
</formalpara>
<simpara>If either the <literal>ClusterOperator/node-tuning</literal> or a profile object&#8217;s status is <literal>DEGRADED</literal>, additional information is provided in the Operator or operand logs.</simpara>
</section>
<section xml:id="custom-tuning-specification_node-tuning-operator">
<title>Custom tuning specification</title>
<simpara>The custom resource (CR) for the Operator has two major sections. The first section, <literal>profile:</literal>, is a list of TuneD profiles and their names. The second, <literal>recommend:</literal>, defines the profile selection logic.</simpara>
<simpara>Multiple custom tuning specifications can co-exist as multiple CRs in the Operator&#8217;s namespace. The existence of new CRs or the deletion of old CRs is detected by the Operator. All existing custom tuning specifications are merged and appropriate objects for the containerized TuneD daemons are updated.</simpara>
<simpara><emphasis role="strong">Management state</emphasis></simpara>
<simpara>The Operator Management state is set by adjusting the default Tuned CR. By default, the Operator is in the Managed state and the <literal>spec.managementState</literal> field is not present in the default Tuned CR. Valid values for the Operator Management state are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>Managed: the Operator will update its operands as configuration resources are updated</simpara>
</listitem>
<listitem>
<simpara>Unmanaged: the Operator will ignore changes to the configuration resources</simpara>
</listitem>
<listitem>
<simpara>Removed: the Operator will remove its operands and resources the Operator provisioned</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Profile data</emphasis></simpara>
<simpara>The <literal>profile:</literal> section lists TuneD profiles and their names.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">profile:
- name: tuned_profile_1
  data: |
    # TuneD profile specification
    [main]
    summary=Description of tuned_profile_1 profile

    [sysctl]
    net.ipv4.ip_forward=1
    # ... other sysctl's or other TuneD daemon plugins supported by the containerized TuneD

# ...

- name: tuned_profile_n
  data: |
    # TuneD profile specification
    [main]
    summary=Description of tuned_profile_n profile

    # tuned_profile_n profile settings</programlisting>
<simpara><emphasis role="strong">Recommended profiles</emphasis></simpara>
<simpara>The <literal>profile:</literal> selection logic is defined by the <literal>recommend:</literal> section of the CR. The <literal>recommend:</literal> section is a list of items to recommend the profiles based on a selection criteria.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">recommend:
&lt;recommend-item-1&gt;
# ...
&lt;recommend-item-n&gt;</programlisting>
<simpara>The individual items of the list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- machineConfigLabels: <co xml:id="CO4-1"/>
    &lt;mcLabels&gt; <co xml:id="CO4-2"/>
  match: <co xml:id="CO4-3"/>
    &lt;match&gt; <co xml:id="CO4-4"/>
  priority: &lt;priority&gt; <co xml:id="CO4-5"/>
  profile: &lt;tuned_profile_name&gt; <co xml:id="CO4-6"/>
  operand: <co xml:id="CO4-7"/>
    debug: &lt;bool&gt; <co xml:id="CO4-8"/>
    tunedConfig:
      reapply_sysctl: &lt;bool&gt; <co xml:id="CO4-9"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Optional.</para>
</callout>
<callout arearefs="CO4-2">
<para>A dictionary of key/value <literal>MachineConfig</literal> labels. The keys must be unique.</para>
</callout>
<callout arearefs="CO4-3">
<para>If omitted, profile match is assumed unless a profile with a higher priority matches first or <literal>machineConfigLabels</literal> is set.</para>
</callout>
<callout arearefs="CO4-4">
<para>An optional list.</para>
</callout>
<callout arearefs="CO4-5">
<para>Profile ordering priority. Lower numbers mean higher priority (<literal>0</literal> is the highest priority).</para>
</callout>
<callout arearefs="CO4-6">
<para>A TuneD profile to apply on a match. For example <literal>tuned_profile_1</literal>.</para>
</callout>
<callout arearefs="CO4-7">
<para>Optional operand configuration.</para>
</callout>
<callout arearefs="CO4-8">
<para>Turn debugging on or off for the TuneD daemon. Options are <literal>true</literal> for on or <literal>false</literal> for off. The default is <literal>false</literal>.</para>
</callout>
<callout arearefs="CO4-9">
<para>Turn <literal>reapply_sysctl</literal> functionality on or off for the TuneD daemon. Options are <literal>true</literal> for on and <literal>false</literal> for off.</para>
</callout>
</calloutlist>
<simpara><literal>&lt;match&gt;</literal> is an optional list recursively defined as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- label: &lt;label_name&gt; <co xml:id="CO5-1"/>
  value: &lt;label_value&gt; <co xml:id="CO5-2"/>
  type: &lt;label_type&gt; <co xml:id="CO5-3"/>
    &lt;match&gt; <co xml:id="CO5-4"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Node or pod label name.</para>
</callout>
<callout arearefs="CO5-2">
<para>Optional node or pod label value. If omitted, the presence of <literal>&lt;label_name&gt;</literal> is enough to match.</para>
</callout>
<callout arearefs="CO5-3">
<para>Optional object type (<literal>node</literal> or <literal>pod</literal>). If omitted, <literal>node</literal> is assumed.</para>
</callout>
<callout arearefs="CO5-4">
<para>An optional <literal>&lt;match&gt;</literal> list.</para>
</callout>
</calloutlist>
<simpara>If <literal>&lt;match&gt;</literal> is not omitted, all nested <literal>&lt;match&gt;</literal> sections must also evaluate to <literal>true</literal>. Otherwise, <literal>false</literal> is assumed and the profile with the respective <literal>&lt;match&gt;</literal> section will not be applied or recommended. Therefore, the nesting (child <literal>&lt;match&gt;</literal> sections) works as logical AND operator. Conversely, if any item of the <literal>&lt;match&gt;</literal> list matches, the entire <literal>&lt;match&gt;</literal> list evaluates to <literal>true</literal>. Therefore, the list acts as logical OR operator.</simpara>
<simpara>If <literal>machineConfigLabels</literal> is defined, machine config pool based matching is turned on for the given <literal>recommend:</literal> list item. <literal>&lt;mcLabels&gt;</literal> specifies the labels for a machine config. The machine config is created automatically to apply host settings, such as kernel boot parameters, for the profile <literal>&lt;tuned_profile_name&gt;</literal>. This involves finding all machine config pools with machine config selector matching <literal>&lt;mcLabels&gt;</literal> and setting the profile <literal>&lt;tuned_profile_name&gt;</literal> on all nodes that are assigned the found machine config pools. To target nodes that have both master and worker roles, you must use the master role.</simpara>
<simpara>The list items <literal>match</literal> and <literal>machineConfigLabels</literal> are connected by the logical OR operator. The <literal>match</literal> item is evaluated first in a short-circuit manner. Therefore, if it evaluates to <literal>true</literal>, the <literal>machineConfigLabels</literal> item is not considered.</simpara>
<important>
<simpara>When using machine config pool based matching, it is advised to group nodes with the same hardware configuration into the same machine config pool. Not following this practice might result in TuneD operands calculating conflicting kernel parameters for two or more nodes sharing the same machine config pool.</simpara>
</important>
<formalpara>
<title>Example: Node or pod label based matching</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">- match:
  - label: tuned.openshift.io/elasticsearch
    match:
    - label: node-role.kubernetes.io/master
    - label: node-role.kubernetes.io/infra
    type: pod
  priority: 10
  profile: openshift-control-plane-es
- match:
  - label: node-role.kubernetes.io/master
  - label: node-role.kubernetes.io/infra
  priority: 20
  profile: openshift-control-plane
- priority: 30
  profile: openshift-node</programlisting>
</para>
</formalpara>
<simpara>The CR above is translated for the containerized TuneD daemon into its <literal>recommend.conf</literal> file based on the profile priorities. The profile with the highest priority (<literal>10</literal>) is <literal>openshift-control-plane-es</literal> and, therefore, it is considered first. The containerized TuneD daemon running on a given node looks to see if there is a pod running on the same node with the <literal>tuned.openshift.io/elasticsearch</literal> label set. If not, the entire <literal>&lt;match&gt;</literal> section evaluates as <literal>false</literal>. If there is such a pod with the label, in order for the <literal>&lt;match&gt;</literal> section to evaluate to <literal>true</literal>, the node label also needs to be <literal>node-role.kubernetes.io/master</literal> or <literal>node-role.kubernetes.io/infra</literal>.</simpara>
<simpara>If the labels for the profile with priority <literal>10</literal> matched, <literal>openshift-control-plane-es</literal> profile is applied and no other profile is considered. If the node/pod label combination did not match, the second highest priority profile (<literal>openshift-control-plane</literal>) is considered. This profile is applied if the containerized TuneD pod runs on a node with labels <literal>node-role.kubernetes.io/master</literal> or <literal>node-role.kubernetes.io/infra</literal>.</simpara>
<simpara>Finally, the profile <literal>openshift-node</literal> has the lowest priority of <literal>30</literal>. It lacks the <literal>&lt;match&gt;</literal> section and, therefore, will always match. It acts as a profile catch-all to set <literal>openshift-node</literal> profile, if no other profile with higher priority matches on a given node.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/node-tuning-operator-workflow-revised.png"/>
</imageobject>
<textobject><phrase>Decision workflow</phrase></textobject>
</mediaobject>
</informalfigure>
<formalpara>
<title>Example: Machine config pool based matching</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: openshift-node-custom
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Custom OpenShift node profile with an additional kernel parameter
      include=openshift-node
      [bootloader]
      cmdline_openshift_node_custom=+skew_tick=1
    name: openshift-node-custom

  recommend:
  - machineConfigLabels:
      machineconfiguration.openshift.io/role: "worker-custom"
    priority: 20
    profile: openshift-node-custom</programlisting>
</para>
</formalpara>
<simpara>To minimize node reboots, label the target nodes with a label the machine config pool&#8217;s node selector will match, then create the Tuned CR above and finally create the custom machine config pool itself.</simpara>
<simpara><emphasis role="strong">Cloud provider-specific TuneD profiles</emphasis></simpara>
<simpara>With this functionality, all Cloud provider-specific nodes can conveniently be assigned a TuneD profile specifically tailored to a given Cloud provider on a OpenShift Container Platform cluster. This can be accomplished without adding additional node labels or grouping nodes into
machine config pools.</simpara>
<simpara>This functionality takes advantage of <literal>spec.providerID</literal> node object values in the form of <literal>&lt;cloud-provider&gt;://&lt;cloud-provider-specific-id&gt;</literal> and writes the file <literal>/var/lib/tuned/provider</literal> with the value <literal>&lt;cloud-provider&gt;</literal> in NTO operand containers.  The content of this file is then used by TuneD to load <literal>provider-&lt;cloud-provider&gt;</literal> profile if such profile exists.</simpara>
<simpara>The <literal>openshift</literal> profile that both <literal>openshift-control-plane</literal> and <literal>openshift-node</literal> profiles inherit settings from is now updated to use this functionality through the use of conditional profile loading. Neither NTO nor TuneD currently include any Cloud provider-specific profiles. However, it is possible to create a custom profile <literal>provider-&lt;cloud-provider&gt;</literal> that will be applied to all Cloud provider-specific cluster nodes.</simpara>
<formalpara>
<title>Example GCE Cloud provider profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: provider-gce
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=GCE Cloud provider-specific profile
      # Your tuning for GCE Cloud provider goes here.
    name: provider-gce</programlisting>
</para>
</formalpara>
<note>
<simpara>Due to profile inheritance, any setting specified in the <literal>provider-&lt;cloud-provider&gt;</literal> profile will be overwritten by the <literal>openshift</literal> profile and its child profiles.</simpara>
</note>
</section>
<section xml:id="custom-tuning-example_node-tuning-operator">
<title>Custom tuning examples</title>
<simpara><emphasis role="strong">Using TuneD profiles from the default CR</emphasis></simpara>
<simpara>The following CR applies custom node-level tuning for
OpenShift Container Platform nodes with label
<literal>tuned.openshift.io/ingress-node-label</literal> set to any value.</simpara>
<formalpara>
<title>Example: custom tuning using the openshift-control-plane TuneD profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: ingress
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=A custom OpenShift ingress profile
      include=openshift-control-plane
      [sysctl]
      net.ipv4.ip_local_port_range="1024 65535"
      net.ipv4.tcp_tw_reuse=1
    name: openshift-ingress
  recommend:
  - match:
    - label: tuned.openshift.io/ingress-node-label
    priority: 10
    profile: openshift-ingress</programlisting>
</para>
</formalpara>
<important>
<simpara>Custom profile writers are strongly encouraged to include the default TuneD
daemon profiles shipped within the default Tuned CR. The example above uses the
default <literal>openshift-control-plane</literal> profile to accomplish this.</simpara>
</important>
<simpara><emphasis role="strong">Using built-in TuneD profiles</emphasis></simpara>
<simpara>Given the successful rollout of the NTO-managed daemon set, the TuneD operands
all manage the same version of the TuneD daemon. To list the built-in TuneD
profiles supported by the daemon, query any TuneD pod in the following way:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec $tuned_pod -n openshift-cluster-node-tuning-operator -- find /usr/lib/tuned/ -name tuned.conf -printf '%h\n' | sed 's|^.*/||'</programlisting>
<simpara>You can use the profile names retrieved by this in your custom tuning specification.</simpara>
<formalpara>
<title>Example: using built-in hpc-compute TuneD profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: openshift-node-hpc-compute
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Custom OpenShift node profile for HPC compute workloads
      include=openshift-node,hpc-compute
    name: openshift-node-hpc-compute

  recommend:
  - match:
    - label: tuned.openshift.io/openshift-node-hpc-compute
    priority: 20
    profile: openshift-node-hpc-compute</programlisting>
</para>
</formalpara>
<simpara>In addition to the built-in <literal>hpc-compute</literal> profile, the example above includes
the <literal>openshift-node</literal> TuneD daemon profile shipped within the default
Tuned CR to use OpenShift-specific tuning for compute nodes.</simpara>
<simpara><emphasis role="strong">Overriding host-level sysctls</emphasis></simpara>
<simpara>Various kernel parameters can be changed at runtime by using <literal>/run/sysctl.d/</literal>, <literal>/etc/sysctl.d/</literal>, and <literal>/etc/sysctl.conf</literal> host configuration files. OpenShift Container Platform adds several host configuration files which set kernel parameters at runtime; for example, <literal>net.ipv[4-6].</literal>, <literal>fs.inotify.</literal>, and <literal>vm.max_map_count</literal>. These runtime parameters provide basic functional tuning for the system prior to the kubelet and the Operator start.</simpara>
<simpara>The Operator does not override these settings unless the <literal>reapply_sysctl</literal> option is set to <literal>false</literal>. Setting this option to <literal>false</literal> results in <literal>TuneD</literal> not applying the settings from the host configuration files after it applies its custom profile.</simpara>
<formalpara>
<title>Example: overriding host-level sysctls</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: openshift-no-reapply-sysctl
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Custom OpenShift profile
      include=openshift-node
      [sysctl]
      vm.max_map_count=&gt;524288
    name: openshift-no-reapply-sysctl
  recommend:
  - match:
    - label: tuned.openshift.io/openshift-no-reapply-sysctl
    priority: 15
    profile: openshift-no-reapply-sysctl
    operand:
      tunedConfig:
        reapply_sysctl: false</programlisting>
</para>
</formalpara>
</section>
<section xml:id="supported-tuned-daemon-plug-ins_node-tuning-operator">
<title>Supported TuneD daemon plugins</title>
<simpara>Excluding the <literal>[main]</literal> section, the following TuneD plugins are supported when
using custom profiles defined in the <literal>profile:</literal> section of the Tuned CR:</simpara>
<itemizedlist>
<listitem>
<simpara>audio</simpara>
</listitem>
<listitem>
<simpara>cpu</simpara>
</listitem>
<listitem>
<simpara>disk</simpara>
</listitem>
<listitem>
<simpara>eeepc_she</simpara>
</listitem>
<listitem>
<simpara>modules</simpara>
</listitem>
<listitem>
<simpara>mounts</simpara>
</listitem>
<listitem>
<simpara>net</simpara>
</listitem>
<listitem>
<simpara>scheduler</simpara>
</listitem>
<listitem>
<simpara>scsi_host</simpara>
</listitem>
<listitem>
<simpara>selinux</simpara>
</listitem>
<listitem>
<simpara>sysctl</simpara>
</listitem>
<listitem>
<simpara>sysfs</simpara>
</listitem>
<listitem>
<simpara>usb</simpara>
</listitem>
<listitem>
<simpara>video</simpara>
</listitem>
<listitem>
<simpara>vm</simpara>
</listitem>
<listitem>
<simpara>bootloader</simpara>
</listitem>
</itemizedlist>
<simpara>There is some dynamic tuning functionality provided by some of these plugins
that is not supported. The following TuneD plugins are currently not supported:</simpara>
<itemizedlist>
<listitem>
<simpara>script</simpara>
</listitem>
<listitem>
<simpara>systemd</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The TuneD bootloader plugin only supports Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes.</simpara>
</note>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/customizing-tuned-profiles_monitoring-and-managing-system-status-and-performance#available-tuned-plug-ins_customizing-tuned-profiles">Available TuneD Plugins</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance">Getting Started with TuneD</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="node-tuning-hosted-cluster_node-tuning-operator">
<title>Configuring node tuning in a hosted cluster</title>
<simpara>To set node-level tuning on the nodes in your hosted cluster, you can use the Node Tuning Operator. In hosted control planes, you can configure node tuning by creating config maps that contain <literal>Tuned</literal> objects and referencing those config maps in your node pools.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a config map that contains a valid tuned manifest, and reference the manifest in a node pool. In the following example, a <literal>Tuned</literal> manifest defines a profile that sets <literal>vm.dirty_ratio</literal> to 55 on nodes that contain the <literal>tuned-1-node-label</literal> node label with any value. Save the following <literal>ConfigMap</literal> manifest in a file named <literal>tuned-1.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: tuned-1
      namespace: clusters
    data:
      tuning: |
        apiVersion: tuned.openshift.io/v1
        kind: Tuned
        metadata:
          name: tuned-1
          namespace: openshift-cluster-node-tuning-operator
        spec:
          profile:
          - data: |
              [main]
              summary=Custom OpenShift profile
              include=openshift-node
              [sysctl]
              vm.dirty_ratio="55"
            name: tuned-1-profile
          recommend:
          - priority: 20
            profile: tuned-1-profile</programlisting>
<note>
<simpara>If you do not add any labels to an entry in the <literal>spec.recommend</literal> section of the Tuned spec, node-pool-based matching is assumed, so the highest priority profile in the <literal>spec.recommend</literal> section is applied to nodes in the pool. Although you can achieve more fine-grained node-label-based matching by setting a label value in the Tuned <literal>.spec.recommend.match</literal> section, node labels will not persist during an upgrade unless you set the <literal>.spec.management.upgradeType</literal> value of the node pool to <literal>InPlace</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>ConfigMap</literal> object in the management cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$MGMT_KUBECONFIG" create -f tuned-1.yaml</programlisting>
</listitem>
<listitem>
<simpara>Reference the <literal>ConfigMap</literal> object in the <literal>spec.tuningConfig</literal> field of the node pool, either by editing a node pool or creating one. In this example, assume that you have only one <literal>NodePool</literal>, named <literal>nodepool-1</literal>, which contains 2 nodes.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: hypershift.openshift.io/v1alpha1
    kind: NodePool
    metadata:
      ...
      name: nodepool-1
      namespace: clusters
    ...
    spec:
      ...
      tuningConfig:
      - name: tuned-1
    status:
    ...</programlisting>
<note>
<simpara>You can reference the same config map in multiple node pools. In hosted control planes, the Node Tuning Operator appends a hash of the node pool name and namespace to the name of the Tuned CRs to distinguish them. Outside of this case, do not create multiple TuneD profiles of the same name in different Tuned CRs for the same hosted cluster.</simpara>
</note>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Now that you have created the <literal>ConfigMap</literal> object that contains a <literal>Tuned</literal> manifest and referenced it in a <literal>NodePool</literal>, the Node Tuning Operator syncs the <literal>Tuned</literal> objects into the hosted cluster. You can verify which <literal>Tuned</literal> objects are defined and which TuneD profiles are applied to each node.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the <literal>Tuned</literal> objects in the hosted cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" get tuned.tuned.openshift.io -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       AGE
default    7m36s
rendered   7m36s
tuned-1    65s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>List the <literal>Profile</literal> objects in the hosted cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" get profile.tuned.openshift.io -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           TUNED            APPLIED   DEGRADED   AGE
nodepool-1-worker-1            tuned-1-profile  True      False      7m43s
nodepool-1-worker-2            tuned-1-profile  True      False      7m14s</programlisting>
</para>
</formalpara>
<note>
<simpara>If no custom profiles are created, the <literal>openshift-node</literal> profile is applied by default.</simpara>
</note>
</listitem>
<listitem>
<simpara>To confirm that the tuning was applied correctly, start a debug shell on a node and check the sysctl values:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" debug node/nodepool-1-worker-1 -- chroot /host sysctl vm.dirty_ratio</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">vm.dirty_ratio = 55</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="advanced-node-tuning-hosted-cluster_node-tuning-operator">
<title>Advanced node tuning for hosted clusters by setting kernel boot parameters</title>
<simpara>For more advanced tuning in hosted control planes, which requires setting kernel boot parameters, you can also use the Node Tuning Operator. The following example shows how you can create a node pool with huge pages reserved.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ConfigMap</literal> object that contains a <literal>Tuned</literal> object manifest for creating 10 huge pages that are 2 MB in size. Save this <literal>ConfigMap</literal> manifest in a file named <literal>tuned-hugepages.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: tuned-hugepages
      namespace: clusters
    data:
      tuning: |
        apiVersion: tuned.openshift.io/v1
        kind: Tuned
        metadata:
          name: hugepages
          namespace: openshift-cluster-node-tuning-operator
        spec:
          profile:
          - data: |
              [main]
              summary=Boot time configuration for hugepages
              include=openshift-node
              [bootloader]
              cmdline_openshift_node_hugepages=hugepagesz=2M hugepages=50
            name: openshift-node-hugepages
          recommend:
          - priority: 20
            profile: openshift-node-hugepages</programlisting>
<note>
<simpara>The <literal>.spec.recommend.match</literal> field is intentionally left blank. In this case, this <literal>Tuned</literal> object is applied to all nodes in the node pool where this <literal>ConfigMap</literal> object is referenced. Group nodes with the same hardware configuration into the same node pool. Otherwise, TuneD operands can calculate conflicting kernel parameters for two or more nodes that share the same node pool.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>ConfigMap</literal> object in the management cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$MGMT_KUBECONFIG" create -f tuned-hugepages.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>NodePool</literal> manifest YAML file, customize the upgrade type of the <literal>NodePool</literal>, and reference the <literal>ConfigMap</literal> object that you created in the <literal>spec.tuningConfig</literal> section. Create the <literal>NodePool</literal> manifest and save it in a file named <literal>hugepages-nodepool.yaml</literal> by using the <literal>hcp</literal> CLI:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    NODEPOOL_NAME=hugepages-example
    INSTANCE_TYPE=m5.2xlarge
    NODEPOOL_REPLICAS=2

    hcp create nodepool aws \
      --cluster-name $CLUSTER_NAME \
      --name $NODEPOOL_NAME \
      --node-count $NODEPOOL_REPLICAS \
      --instance-type $INSTANCE_TYPE \
      --render &gt; hugepages-nodepool.yaml</programlisting>
</listitem>
<listitem>
<simpara>In the <literal>hugepages-nodepool.yaml</literal> file, set <literal>.spec.management.upgradeType</literal> to <literal>InPlace</literal>, and set <literal>.spec.tuningConfig</literal> to reference the <literal>tuned-hugepages</literal> <literal>ConfigMap</literal> object that you created.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: hypershift.openshift.io/v1alpha1
    kind: NodePool
    metadata:
      name: hugepages-nodepool
      namespace: clusters
      ...
    spec:
      management:
        ...
        upgradeType: InPlace
      ...
      tuningConfig:
      - name: tuned-hugepages</programlisting>
<note>
<simpara>To avoid the unnecessary re-creation of nodes when you apply the new <literal>MachineConfig</literal> objects, set <literal>.spec.management.upgradeType</literal> to <literal>InPlace</literal>. If you use the <literal>Replace</literal> upgrade type, nodes are fully deleted and new nodes can replace them when you apply the new kernel boot parameters that the TuneD operand calculated.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>NodePool</literal> in the management cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$MGMT_KUBECONFIG" create -f hugepages-nodepool.yaml</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>After the nodes are available, the containerized TuneD daemon calculates the required kernel boot parameters based on the applied TuneD profile. After the nodes are ready and reboot once to apply the generated <literal>MachineConfig</literal> object, you can verify that the TuneD profile is applied and that the kernel boot parameters are set.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the <literal>Tuned</literal> objects in the hosted cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" get tuned.tuned.openshift.io -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 AGE
default              123m
hugepages-8dfb1fed   1m23s
rendered             123m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>List the <literal>Profile</literal> objects in the hosted cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" get profile.tuned.openshift.io -n openshift-cluster-node-tuning-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           TUNED                      APPLIED   DEGRADED   AGE
nodepool-1-worker-1            openshift-node             True      False      132m
nodepool-1-worker-2            openshift-node             True      False      131m
hugepages-nodepool-worker-1    openshift-node-hugepages   True      False      4m8s
hugepages-nodepool-worker-2    openshift-node-hugepages   True      False      3m57s</programlisting>
</para>
</formalpara>
<simpara>Both of the worker nodes in the new <literal>NodePool</literal> have the <literal>openshift-node-hugepages</literal> profile applied.</simpara>
</listitem>
<listitem>
<simpara>To confirm that the tuning was applied correctly, start a debug shell on a node and check <literal>/proc/cmdline</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --kubeconfig="$HC_KUBECONFIG" debug node/nodepool-1-worker-1 -- chroot /host cat /proc/cmdline</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">BOOT_IMAGE=(hd0,gpt3)/ostree/rhcos-... hugepagesz=2M hugepages=50</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<formalpara role="_additional-resources">
<title>Additional resources</title>
<para>For more information about hosted control planes, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#hosted-control-planes-intro">Hosted control planes</link>.</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="using-cpu-manager">
<title>Using CPU Manager and Topology Manager</title>
<simpara>CPU Manager manages groups of CPUs and constrains workloads to specific CPUs.</simpara>
<simpara>CPU Manager is useful for workloads that have some of these attributes:</simpara>
<itemizedlist>
<listitem>
<simpara>Require as much CPU time as possible.</simpara>
</listitem>
<listitem>
<simpara>Are sensitive to processor cache misses.</simpara>
</listitem>
<listitem>
<simpara>Are low-latency network applications.</simpara>
</listitem>
<listitem>
<simpara>Coordinate with other processes and benefit from sharing a single processor
cache.</simpara>
</listitem>
</itemizedlist>
<simpara>Topology Manager collects hints from the CPU Manager, Device Manager, and other Hint Providers to align pod resources, such as CPU, SR-IOV VFs, and other device resources, for all Quality of Service (QoS) classes on the same non-uniform memory access (NUMA) node.</simpara>
<simpara>Topology Manager uses topology information from the collected hints to decide if a pod can be accepted or rejected on a node, based on the configured Topology Manager policy and pod resources requested.</simpara>
<simpara>Topology Manager is useful for workloads that use hardware accelerators to support latency-critical execution and high throughput parallel computation.</simpara>
<simpara>To use Topology Manager you must configure CPU Manager with the <literal>static</literal> policy.</simpara>
<section xml:id="setting_up_cpu_manager_using-cpu-manager-and-topology_manager">
<title>Setting up CPU Manager</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Label a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc label node perf-node.example.com cpumanager=true</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>MachineConfigPool</literal> of the nodes where CPU Manager should be enabled. In this example, all workers have CPU Manager enabled:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc edit machineconfigpool worker</programlisting>
</listitem>
<listitem>
<simpara>Add a label to the worker machine config pool:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">metadata:
  creationTimestamp: 2020-xx-xxx
  generation: 3
  labels:
    custom-kubelet: cpumanager-enabled</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>KubeletConfig</literal>, <literal>cpumanager-kubeletconfig.yaml</literal>, custom resource (CR). Refer to the label created in the previous step to have the correct nodes updated with the new kubelet config. See the <literal>machineConfigPoolSelector</literal> section:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: cpumanager-enabled
spec:
  machineConfigPoolSelector:
    matchLabels:
      custom-kubelet: cpumanager-enabled
  kubeletConfig:
     cpuManagerPolicy: static <co xml:id="CO6-1"/>
     cpuManagerReconcilePeriod: 5s <co xml:id="CO6-2"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Specify a policy:</para>
<itemizedlist>
<listitem>
<simpara><literal>none</literal>. This policy explicitly enables the existing default CPU affinity scheme, providing no affinity beyond what the scheduler does automatically. This is the default policy.</simpara>
</listitem>
<listitem>
<simpara><literal>static</literal>. This policy allows containers in guaranteed pods with integer CPU requests. It also limits access to exclusive CPUs on the node. If <literal>static</literal>, you must use a lowercase <literal>s</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO6-2">
<para>Optional. Specify the CPU Manager reconcile frequency. The default is <literal>5s</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the dynamic kubelet config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f cpumanager-kubeletconfig.yaml</programlisting>
<simpara>This adds the CPU Manager feature to the kubelet config and, if needed, the Machine Config Operator (MCO) reboots the node. To enable CPU Manager, a reboot is not needed.</simpara>
</listitem>
<listitem>
<simpara>Check for the merged kubelet config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get machineconfig 99-worker-XXXXXX-XXXXX-XXXX-XXXXX-kubelet -o json | grep ownerReference -A7</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">       "ownerReferences": [
            {
                "apiVersion": "machineconfiguration.openshift.io/v1",
                "kind": "KubeletConfig",
                "name": "cpumanager-enabled",
                "uid": "7ed5616d-6b72-11e9-aae1-021e1ce18878"
            }
        ]</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the worker for the updated <literal>kubelet.conf</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc debug node/perf-node.example.com
sh-4.2# cat /host/etc/kubernetes/kubelet.conf | grep cpuManager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">cpuManagerPolicy: static        <co xml:id="CO7-1"/>
cpuManagerReconcilePeriod: 5s   <co xml:id="CO7-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para><literal>cpuManagerPolicy</literal> is defined when you create the <literal>KubeletConfig</literal> CR.</para>
</callout>
<callout arearefs="CO7-2">
<para><literal>cpuManagerReconcilePeriod</literal> is defined when you create the <literal>KubeletConfig</literal> CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a pod that requests a core or multiple cores. Both limits and requests must have their CPU value set to a whole integer. That is the number of cores that will be dedicated to this pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cat cpumanager-pod.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  generateName: cpumanager-
spec:
  containers:
  - name: cpumanager
    image: gcr.io/google_containers/pause:3.2
    resources:
      requests:
        cpu: 1
        memory: "1G"
      limits:
        cpu: 1
        memory: "1G"
  nodeSelector:
    cpumanager: "true"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f cpumanager-pod.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the pod is scheduled to the node that you labeled:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc describe pod cpumanager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:               cpumanager-6cqz7
Namespace:          default
Priority:           0
PriorityClassName:  &lt;none&gt;
Node:  perf-node.example.com/xxx.xx.xx.xxx
...
 Limits:
      cpu:     1
      memory:  1G
    Requests:
      cpu:        1
      memory:     1G
...
QoS Class:       Guaranteed
Node-Selectors:  cpumanager=true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the <literal>cgroups</literal> are set up correctly. Get the process ID (PID) of the <literal>pause</literal> process:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># init.scope
 1 /usr/lib/systemd/systemd --switched-root --system --deserialize 17
kubepods.slice
  kubepods-pod69c01f8e_6b74_11e9_ac0f_0a2b62178a22.slice
   crio-b5437308f1a574c542bdf08563b865c0345c8f8c0b0a655612c.scope
   32706 /pause</programlisting>
<simpara>Pods of quality of service (QoS) tier <literal>Guaranteed</literal> are placed within the <literal>kubepods.slice</literal>. Pods of other QoS tiers end up in child <literal>cgroups</literal> of <literal>kubepods</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cd /sys/fs/cgroup/cpuset/kubepods.slice/kubepods-pod69c01f8e_6b74_11e9_ac0f_0a2b62178a22.slice/crio-b5437308f1ad1a7db0574c542bdf08563b865c0345c86e9585f8c0b0a655612c.scope
# for i in `ls cpuset.cpus tasks` ; do echo -n "$i "; cat $i ; done</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">cpuset.cpus 1
tasks 32706</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the allowed CPU list for the task:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># grep ^Cpus_allowed_list /proc/32706/status</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"> Cpus_allowed_list:    1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that another pod (in this case, the pod in the <literal>burstable</literal> QoS tier) on the system cannot run on the core allocated for the <literal>Guaranteed</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cat /sys/fs/cgroup/cpuset/kubepods.slice/kubepods-besteffort.slice/kubepods-besteffort-podc494a073_6b77_11e9_98c0_06bba5c387ea.slice/crio-c56982f57b75a2420947f0afc6cafe7534c5734efc34157525fa9abbf99e3849.scope/cpuset.cpus
0
# oc describe node perf-node.example.com</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
Capacity:
 attachable-volumes-aws-ebs:  39
 cpu:                         2
 ephemeral-storage:           124768236Ki
 hugepages-1Gi:               0
 hugepages-2Mi:               0
 memory:                      8162900Ki
 pods:                        250
Allocatable:
 attachable-volumes-aws-ebs:  39
 cpu:                         1500m
 ephemeral-storage:           124768236Ki
 hugepages-1Gi:               0
 hugepages-2Mi:               0
 memory:                      7548500Ki
 pods:                        250
-------                               ----                           ------------  ----------  ---------------  -------------  ---
  default                                 cpumanager-6cqz7               1 (66%)       1 (66%)     1G (12%)         1G (12%)       29m

Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource                    Requests          Limits
  --------                    --------          ------
  cpu                         1440m (96%)       1 (66%)</programlisting>
</para>
</formalpara>
<simpara>This VM has two CPU cores. The <literal>system-reserved</literal> setting reserves 500 millicores, meaning that half of one core is subtracted from the total capacity of the node to arrive at the <literal>Node Allocatable</literal> amount. You can see that <literal>Allocatable CPU</literal> is 1500 millicores. This means you can run one of the CPU Manager pods since each will take one whole core. A whole core is equivalent to 1000 millicores. If you try to schedule a second pod, the system will accept the pod, but it will never be scheduled:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    READY   STATUS    RESTARTS   AGE
cpumanager-6cqz7        1/1     Running   0          33m
cpumanager-7qc2t        0/1     Pending   0          11s</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="topology_manager_policies_using-cpu-manager-and-topology_manager">
<title>Topology Manager policies</title>
<simpara>Topology Manager aligns <literal>Pod</literal> resources of all Quality of Service (QoS) classes by collecting topology hints from Hint Providers, such as CPU Manager and Device Manager, and using the collected hints to align the <literal>Pod</literal> resources.</simpara>
<simpara>Topology Manager supports four allocation policies, which you assign in the <literal>KubeletConfig</literal> custom resource (CR) named <literal>cpumanager-enabled</literal>:</simpara>
<variablelist>
<varlistentry>
<term><literal>none</literal> policy</term>
<listitem>
<simpara>This is the default policy and does not perform any topology alignment.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>best-effort</literal> policy</term>
<listitem>
<simpara>For each container in a pod with the <literal>best-effort</literal> topology management policy, kubelet calls each Hint Provider to discover their resource
availability. Using this information, the Topology Manager stores the preferred NUMA Node affinity for that container. If the affinity is not preferred, Topology Manager stores this and admits the pod to the node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>restricted</literal> policy</term>
<listitem>
<simpara>For each container in a pod with the <literal>restricted</literal> topology management policy, kubelet calls each Hint Provider to discover their resource
availability. Using this information, the Topology Manager stores the preferred NUMA Node affinity for that container. If the affinity is not
preferred, Topology Manager rejects this pod from the node, resulting in a pod in a <literal>Terminated</literal> state with a pod admission failure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>single-numa-node</literal> policy</term>
<listitem>
<simpara>For each container in a pod with the <literal>single-numa-node</literal> topology management policy, kubelet calls each Hint Provider to discover their resource availability. Using this information, the Topology Manager determines if a single NUMA Node affinity is possible. If it is, the pod is admitted to the node. If a single NUMA Node affinity is not possible, the Topology Manager rejects the pod from the node. This results in a pod in a Terminated state with a pod admission failure.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="setting_up_topology_manager_using-cpu-manager-and-topology_manager">
<title>Setting up Topology Manager</title>
<simpara>To use Topology Manager, you must configure an allocation policy in the <literal>KubeletConfig</literal> custom resource (CR) named <literal>cpumanager-enabled</literal>. This file might exist if you have set up CPU Manager. If the file does not exist, you can create the file.</simpara>
<itemizedlist>
<title>Prequisites</title>
<listitem>
<simpara>Configure the CPU Manager policy to be <literal>static</literal>.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To activate Topololgy Manager:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Configure the Topology Manager allocation policy in the custom resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit KubeletConfig cpumanager-enabled</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: cpumanager-enabled
spec:
  machineConfigPoolSelector:
    matchLabels:
      custom-kubelet: cpumanager-enabled
  kubeletConfig:
     cpuManagerPolicy: static <co xml:id="CO8-1"/>
     cpuManagerReconcilePeriod: 5s
     topologyManagerPolicy: single-numa-node <co xml:id="CO8-2"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>This parameter must be <literal>static</literal> with a lowercase <literal>s</literal>.</para>
</callout>
<callout arearefs="CO8-2">
<para>Specify your selected Topology Manager allocation policy. Here, the policy is <literal>single-numa-node</literal>.
Acceptable values are: <literal>default</literal>, <literal>best-effort</literal>, <literal>restricted</literal>, <literal>single-numa-node</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="pod-interactions-with-topology-manager_using-cpu-manager-and-topology_manager">
<title>Pod interactions with Topology Manager policies</title>
<simpara>The example <literal>Pod</literal> specs below help illustrate pod interactions with Topology Manager.</simpara>
<simpara>The following pod runs in the <literal>BestEffort</literal> QoS class because no resource requests or limits are specified.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers:
  - name: nginx
    image: nginx</programlisting>
<simpara>The next pod runs in the <literal>Burstable</literal> QoS class because requests are less than limits.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      limits:
        memory: "200Mi"
      requests:
        memory: "100Mi"</programlisting>
<simpara>If the selected policy is anything other than <literal>none</literal>, Topology Manager would not consider either of these <literal>Pod</literal> specifications.</simpara>
<simpara>The last example pod below runs in the Guaranteed QoS class because requests are equal to limits.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers:
  - name: nginx
    image: nginx
    resources:
      limits:
        memory: "200Mi"
        cpu: "2"
        example.com/device: "1"
      requests:
        memory: "200Mi"
        cpu: "2"
        example.com/device: "1"</programlisting>
<simpara>Topology Manager would consider this pod. The Topology Manager would consult the hint providers, which are CPU Manager and Device Manager, to get topology hints for the pod.</simpara>
<simpara>Topology Manager will use this information to store the best topology for this container. In the case of this pod, CPU Manager and Device Manager will use this stored information at the resource allocation stage.</simpara>
</section>
</chapter>
<chapter xml:id="cnf-numa-aware-scheduling">
<title>Scheduling NUMA-aware workloads</title>
<simpara>Learn about NUMA-aware scheduling and how you can use it to deploy high performance workloads in an OpenShift Container Platform cluster.</simpara>
<simpara>The NUMA Resources Operator allows you to schedule high-performance workloads in the same NUMA zone. It deploys a node resources exporting agent that reports on available cluster node NUMA resources, and a secondary scheduler that manages the workloads.</simpara>
<section xml:id="cnf-about-numa-aware-scheduling_numa-aware">
<title>About NUMA-aware scheduling</title>
<simpara>Non-Uniform Memory Access (NUMA) is a compute platform architecture that allows different CPUs to access different regions of memory at different speeds. NUMA resource topology refers to the locations of CPUs, memory, and PCI devices relative to each other in the compute node. Co-located resources are said to be in the same <emphasis>NUMA zone</emphasis>. For high-performance applications, the cluster needs to process pod workloads in a single NUMA zone.</simpara>
<simpara>NUMA architecture allows a CPU with multiple memory controllers to use any available memory across CPU complexes, regardless of where the memory is located. This allows for increased flexibility at the expense of performance. A CPU processing a workload using memory that is outside its NUMA zone is slower than a workload processed in a single NUMA zone. Also, for I/O-constrained workloads, the network interface on a distant NUMA zone slows down how quickly information can reach the application. High-performance workloads, such as telecommunications workloads, cannot operate to specification under these conditions. NUMA-aware scheduling aligns the requested cluster compute resources (CPUs, memory, devices) in the same NUMA zone to process latency-sensitive or high-performance workloads efficiently. NUMA-aware scheduling also improves pod density per compute node for greater resource efficiency.</simpara>
<simpara>By integrating the Node Tuning Operator&#8217;s performance profile with NUMA-aware scheduling, you can further configure CPU affinity to optimize performance for latency-sensitive workloads.</simpara>
<simpara>The default OpenShift Container Platform pod scheduler scheduling logic considers the available resources of the entire compute node, not individual NUMA zones. If the most restrictive resource alignment is requested in the kubelet topology manager, error conditions can occur when admitting the pod to a node. Conversely, if the most restrictive resource alignment is not requested, the pod can be admitted to the node without proper resource alignment, leading to worse or unpredictable performance. For example, runaway pod creation with <literal>Topology Affinity Error</literal> statuses can occur when the pod scheduler makes suboptimal scheduling decisions for guaranteed pod workloads by not knowing if the pod&#8217;s requested resources are available. Scheduling mismatch decisions can cause indefinite pod startup delays. Also, depending on the cluster state and resource allocation, poor pod scheduling decisions can cause extra load on the cluster because of failed startup attempts.</simpara>
<simpara>The NUMA Resources Operator deploys a custom NUMA resources secondary scheduler and other resources to mitigate against the shortcomings of the default OpenShift Container Platform pod scheduler. The following diagram provides a high-level overview of NUMA-aware pod scheduling.</simpara>
<figure>
<title>NUMA-aware scheduling overview</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/216_OpenShift_Topology-aware_Scheduling_0222.png"/>
</imageobject>
<textobject><phrase>Diagram of NUMA-aware scheduling that shows how the various components interact with each other in the cluster</phrase></textobject>
</mediaobject>
</figure>
<variablelist>
<varlistentry>
<term>NodeResourceTopology API</term>
<listitem>
<simpara>The <literal>NodeResourceTopology</literal> API describes the available NUMA zone resources in each compute node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NUMA-aware scheduler</term>
<listitem>
<simpara>The NUMA-aware secondary scheduler receives information about the available NUMA zones from the <literal>NodeResourceTopology</literal> API and schedules high-performance workloads on a node where it can be optimally processed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Node topology exporter</term>
<listitem>
<simpara>The node topology exporter exposes the available NUMA zone resources for each compute node to the <literal>NodeResourceTopology</literal> API. The node topology exporter daemon tracks the resource allocation from the kubelet by using the <literal>PodResources</literal> API.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>PodResources API</term>
<listitem>
<simpara>The <literal>PodResources</literal> API is local to each node and exposes the resource topology and available resources to the kubelet.</simpara>
<note>
<simpara>The <literal>List</literal> endpoint of the <literal>PodResources</literal> API exposes exclusive CPUs allocated to a particular container. The API does not expose CPUs that belong to a shared pool.</simpara>
<simpara>The <literal>GetAllocatableResources</literal> endpoint exposes allocatable resources available on a node.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>For more information about running secondary pod schedulers in your cluster and how to deploy pods with a secondary pod scheduler, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#secondary-scheduler-configuring">Scheduling pods using a secondary scheduler</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installing-the-numa-resources-operator_numa-aware">
<title>Installing the NUMA Resources Operator</title>
<simpara>NUMA Resources Operator deploys resources that allow you to schedule NUMA-aware workloads and deployments. You can install the NUMA Resources Operator using the OpenShift Container Platform CLI or the web console.</simpara>
<section xml:id="cnf-installing-numa-resources-operator-cli_numa-aware">
<title>Installing the NUMA Resources Operator using the CLI</title>
<simpara>As a cluster administrator, you can install the Operator using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a namespace for the NUMA Resources Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-namespace.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: openshift-numaresources</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-namespace.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the Operator group for the NUMA Resources Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-operatorgroup.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: numaresources-operator
  namespace: openshift-numaresources
spec:
  targetNamespaces:
  - openshift-numaresources</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the subscription for the NUMA Resources Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-sub.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: numaresources-operator
  namespace: openshift-numaresources
spec:
  channel: "4.14"
  name: numaresources-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-sub.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the installation succeeded by inspecting the CSV resource in the <literal>openshift-numaresources</literal> namespace. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                             DISPLAY                  VERSION   REPLACES   PHASE
numaresources-operator.v4.14.2   numaresources-operator   4.14.2               Succeeded</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cnf-installing-numa-resources-operator-console_numa-aware">
<title>Installing the NUMA Resources Operator using the web console</title>
<simpara>As a cluster administrator, you can install the NUMA Resources Operator using the web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a namespace for the NUMA Resources Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Namespace</emphasis>, enter <literal>openshift-numaresources</literal> in the <emphasis role="strong">Name</emphasis> field, and then click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">NUMA Resources Operator</emphasis> from the list of available Operators, and then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Installed Namespaces</emphasis> field, select the <literal>openshift-numaresources</literal> namespace, and then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Verify that the NUMA Resources Operator installed successfully:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Switch to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Ensure that <emphasis role="strong">NUMA Resources Operator</emphasis> is listed in the <literal>openshift-numaresources</literal> namespace with a <emphasis role="strong">Status</emphasis> of <emphasis role="strong">InstallSucceeded</emphasis>.</simpara>
<note>
<simpara>During installation an Operator might display a <emphasis role="strong">Failed</emphasis> status. If the installation later succeeds with an <emphasis role="strong">InstallSucceeded</emphasis> message, you can ignore the <emphasis role="strong">Failed</emphasis> message.</simpara>
</note>
<simpara>If the Operator does not appear as installed, to troubleshoot further:</simpara>
<itemizedlist>
<listitem>
<simpara>Go to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <emphasis role="strong">Operator Subscriptions</emphasis> and <emphasis role="strong">Install Plans</emphasis> tabs for any failure or errors under <emphasis role="strong">Status</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Go to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs for pods in the <literal>default</literal> project.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cnf-scheduling-numa-aware-workloads-overview_numa-aware">
<title>Scheduling NUMA-aware workloads</title>
<simpara>Clusters running latency-sensitive workloads typically feature performance profiles that help to minimize workload latency and optimize performance. The NUMA-aware scheduler deploys workloads based on available node NUMA resources and with respect to any performance profile settings applied to the node. The combination of NUMA-aware deployments, and the performance profile of the workload, ensures that workloads are scheduled in a way that maximizes performance.</simpara>
<section xml:id="cnf-creating-nrop-cr_numa-aware">
<title>Creating the NUMAResourcesOperator custom resource</title>
<simpara>When you have installed the NUMA Resources Operator, then create the <literal>NUMAResourcesOperator</literal> custom resource (CR) that instructs the NUMA Resources Operator to install all the cluster infrastructure needed to support the NUMA-aware scheduler, including daemon sets and APIs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>NUMAResourcesOperator</literal> custom resource:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nrop.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesOperator
metadata:
  name: numaresourcesoperator
spec:
  nodeGroups:
  - machineConfigPoolSelector:
      matchLabels:
        pools.operator.machineconfiguration.openshift.io/worker: ""</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesOperator</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nrop.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the NUMA Resources Operator deployed successfully by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesoperators.nodetopology.openshift.io</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    AGE
numaresourcesoperator   10m</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-deploying-the-numa-aware-scheduler_numa-aware">
<title>Deploying the NUMA-aware secondary pod scheduler</title>
<simpara>After you install the NUMA Resources Operator, do the following to deploy the NUMA-aware secondary pod scheduler:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure the performance profile.</simpara>
</listitem>
<listitem>
<simpara>Deploy the NUMA-aware secondary scheduler.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create the required machine config pool.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>PerformanceProfile</literal> custom resource (CR):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-perfprof.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: perfprof-nrop
spec:
  cpu: <co xml:id="CO9-1"/>
    isolated: "4-51,56-103"
    reserved: "0,1,2,3,52,53,54,55"
  nodeSelector:
    node-role.kubernetes.io/worker: ""
  numa:
    topologyPolicy: single-numa-node</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>The <literal>cpu.isolated</literal> and <literal>cpu.reserved</literal> specifications define ranges for isolated and reserved CPUs. Enter valid values for your CPU configuration. See the <emphasis>Additional resources</emphasis> section for more information about configuring a performance profile.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>PerformanceProfile</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-perfprof.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">performanceprofile.performance.openshift.io/perfprof-nrop created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesScheduler</literal> custom resource that deploys the NUMA-aware custom pod scheduler:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-scheduler.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesScheduler
metadata:
  name: numaresourcesscheduler
spec:
  imageSpec: "registry.redhat.io/openshift4/noderesourcetopology-scheduler-rhel9:v4.14"
  cacheResyncPeriod: "5s" <co xml:id="CO10-1"/></programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>Enter an interval value in seconds for synchronization of the scheduler cache. A value of <literal>5s</literal> is typical for most implementations.</para>
</callout>
</calloutlist>
<note>
<itemizedlist>
<listitem>
<simpara>Enable the <literal>cacheResyncPeriod</literal> specification to help the NUMA Resource Operator report more exact resource availability by monitoring pending resources on nodes and synchronizing this information in the scheduler cache at a defined interval. This also helps to minimize <literal>Topology Affinity Error</literal> errors because of sub-optimal scheduling decisions. The lower the interval the greater the network load. The <literal>cacheResyncPeriod</literal> specification is disabled by default.</simpara>
</listitem>
<listitem>
<simpara>Setting a value of <literal>Enabled</literal> for the <literal>podsFingerprinting</literal> specification in the <literal>NUMAResourcesOperator</literal> CR is a requirement for the implementation of the <literal>cacheResyncPeriod</literal> specification.</simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesScheduler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-scheduler.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the performance profile was applied by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe performanceprofile &lt;performance-profile-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Verify that the required resources deployed successfully by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                    READY   STATUS    RESTARTS   AGE
pod/numaresources-controller-manager-7575848485-bns4s   1/1     Running   0          13m
pod/numaresourcesoperator-worker-dvj4n                  2/2     Running   0          16m
pod/numaresourcesoperator-worker-lcg4t                  2/2     Running   0          16m
pod/secondary-scheduler-56994cf6cf-7qf4q                1/1     Running   0          16m
NAME                                          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                     AGE
daemonset.apps/numaresourcesoperator-worker   2         2         2       2            2           node-role.kubernetes.io/worker=   16m
NAME                                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/numaresources-controller-manager   1/1     1            1           13m
deployment.apps/secondary-scheduler                1/1     1            1           16m
NAME                                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/numaresources-controller-manager-7575848485   1         1         1       13m
replicaset.apps/secondary-scheduler-56994cf6cf                1         1         1       16m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cnf-about-the-profile-creator-tool_cnf-create-performance-profiles">About the Performance Profile Creator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-scheduling-numa-aware-workloads_numa-aware">
<title>Scheduling workloads with the NUMA-aware scheduler</title>
<simpara>You can schedule workloads with the NUMA-aware scheduler using <literal>Deployment</literal> CRs that specify the minimum required resources to process the workload.</simpara>
<simpara>The following example deployment uses NUMA-aware scheduling for a sample workload.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator and deploy the NUMA-aware secondary scheduler.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the name of the NUMA-aware scheduler that is deployed in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesschedulers.nodetopology.openshift.io numaresourcesscheduler -o json | jq '.status.schedulerName'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">topo-aware-scheduler</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>Deployment</literal> CR that uses scheduler named <literal>topo-aware-scheduler</literal>, for example:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-deployment.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: numa-deployment-1
  namespace: openshift-numaresources
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test
  template:
    metadata:
      labels:
        app: test
    spec:
      schedulerName: topo-aware-scheduler <co xml:id="CO11-1"/>
      containers:
      - name: ctnr
        image: quay.io/openshifttest/hello-openshift:openshift
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: "100Mi"
            cpu: "10"
          requests:
            memory: "100Mi"
            cpu: "10"
      - name: ctnr2
        image: registry.access.redhat.com/rhel:latest
        imagePullPolicy: IfNotPresent
        command: ["/bin/sh", "-c"]
        args: [ "while true; do sleep 1h; done;" ]
        resources:
          limits:
            memory: "100Mi"
            cpu: "8"
          requests:
            memory: "100Mi"
            cpu: "8"</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para><literal>schedulerName</literal> must match the name of the NUMA-aware scheduler that is deployed in your cluster, for example <literal>topo-aware-scheduler</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-deployment.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the deployment was successful:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                READY   STATUS    RESTARTS   AGE
numa-deployment-1-56954b7b46-pfgw8                  2/2     Running   0          129m
numaresources-controller-manager-7575848485-bns4s   1/1     Running   0          15h
numaresourcesoperator-worker-dvj4n                  2/2     Running   0          18h
numaresourcesoperator-worker-lcg4t                  2/2     Running   0          16h
secondary-scheduler-56994cf6cf-7qf4q                1/1     Running   0          18h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the <literal>topo-aware-scheduler</literal> is scheduling the deployed pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod numa-deployment-1-56954b7b46-pfgw8 -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Events:
  Type    Reason          Age   From                  Message
  ----    ------          ----  ----                  -------
  Normal  Scheduled       130m  topo-aware-scheduler  Successfully assigned openshift-numaresources/numa-deployment-1-56954b7b46-pfgw8 to compute-0.example.com</programlisting>
</para>
</formalpara>
<note>
<simpara>Deployments that request more resources than is available for scheduling will fail with a <literal>MinimumReplicasUnavailable</literal> error. The deployment succeeds when the required resources become available. Pods remain in the <literal>Pending</literal> state until the required resources are available.</simpara>
</note>
</listitem>
<listitem>
<simpara>Verify that the expected allocated resources are listed for the node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Identify the node that is running the deployment pod by running the following command, replacing &lt;namespace&gt; with the namespace you specified in the <literal>Deployment</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;namespace&gt; -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                 READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
numa-deployment-1-65684f8fcc-bw4bw   0/2     Running   0          82m   10.128.2.50   worker-0   &lt;none&gt;  &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command, replacing &lt;node_name&gt; with the name of that node that is running the deployment pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe noderesourcetopologies.topology.node.k8s.io &lt;node_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...

Zones:
  Costs:
    Name:   node-0
    Value:  10
    Name:   node-1
    Value:  21
  Name:     node-0
  Resources:
    Allocatable:  39
    Available:    21 <co xml:id="CO12-1"/>
    Capacity:     40
    Name:         cpu
    Allocatable:  6442450944
    Available:    6442450944
    Capacity:     6442450944
    Name:         hugepages-1Gi
    Allocatable:  134217728
    Available:    134217728
    Capacity:     134217728
    Name:         hugepages-2Mi
    Allocatable:  262415904768
    Available:    262206189568
    Capacity:     270146007040
    Name:         memory
  Type:           Node</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>The <literal>Available</literal> capacity is reduced because of the resources that have been allocated to the guaranteed pod.</para>
</callout>
</calloutlist>
<simpara>Resources consumed by guaranteed pods are subtracted from the available node resources listed under <literal>noderesourcetopologies.topology.node.k8s.io</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Resource allocations for pods with a <literal>Best-effort</literal> or <literal>Burstable</literal> quality of service (<literal>qosClass</literal>) are not reflected in the NUMA node resources under <literal>noderesourcetopologies.topology.node.k8s.io</literal>. If a pod&#8217;s consumed resources are not reflected in the node resource calculation, verify that the pod has <literal>qosClass</literal> of <literal>Guaranteed</literal> and the CPU request is an integer value, not a decimal value. You can verify the that the pod has a  <literal>qosClass</literal> of <literal>Guaranteed</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod &lt;pod_name&gt; -n &lt;pod_namespace&gt; -o jsonpath="{ .status.qosClass }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Guaranteed</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cnf-scheduling-numa-aware-workloads-with-manual-perofrmance-settings_numa-aware">
<title>Scheduling NUMA-aware workloads with manual performance settings</title>
<simpara>Clusters running latency-sensitive workloads typically feature performance profiles that help to minimize workload latency and optimize performance. However, you can schedule NUMA-aware workloads in a pristine cluster that does not feature a performance profile. The following workflow features a pristine cluster that you can manually configure for performance by using the <literal>KubeletConfig</literal> resource. This is not the typical environment for scheduling NUMA-aware workloads.</simpara>
<section xml:id="cnf-creating-nrop-cr-with-manual-performance-settings_numa-aware">
<title>Creating the NUMAResourcesOperator custom resource with manual performance settings</title>
<simpara>When you have installed the NUMA Resources Operator, then create the <literal>NUMAResourcesOperator</literal> custom resource (CR) that instructs the NUMA Resources Operator to install all the cluster infrastructure needed to support the NUMA-aware scheduler, including daemon sets and APIs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Create the <literal>MachineConfigPool</literal> custom resource that enables custom kubelet configurations for worker nodes:</simpara>
<note>
<simpara>By default, OpenShift Container Platform creates a <literal>MachineConfigPool</literal> resource for worker nodes in the cluster. You can create a custom <literal>MachineConfigPool</literal> resource if required.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-machineconfig.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  labels:
    cnf-worker-tuning: enabled
    machineconfiguration.openshift.io/mco-built-in: ""
    pools.operator.machineconfiguration.openshift.io/worker: ""
  name: worker
spec:
  machineConfigSelector:
    matchLabels:
      machineconfiguration.openshift.io/role: worker
  nodeSelector:
    matchLabels:
      node-role.kubernetes.io/worker: ""</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>MachineConfigPool</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-machineconfig.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesOperator</literal> custom resource:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nrop.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesOperator
metadata:
  name: numaresourcesoperator
spec:
  nodeGroups:
  - machineConfigPoolSelector:
      matchLabels:
        pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO13-1"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Should match the label applied to worker nodes in the related <literal>MachineConfigPool</literal> CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesOperator</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nrop.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the NUMA Resources Operator deployed successfully by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesoperators.nodetopology.openshift.io</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    AGE
numaresourcesoperator   10m</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-deploying-the-numa-aware-scheduler-with-manual-performance-settings_numa-aware">
<title>Deploying the NUMA-aware secondary pod scheduler with manual performance settings</title>
<simpara>After you install the NUMA Resources Operator, do the following to deploy the NUMA-aware secondary pod scheduler:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure the pod admittance policy for the required machine profile</simpara>
</listitem>
<listitem>
<simpara>Create the required machine config pool</simpara>
</listitem>
<listitem>
<simpara>Deploy the NUMA-aware secondary scheduler</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>KubeletConfig</literal> custom resource that configures the pod admittance policy for the machine profile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-kubeletconfig.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: cnf-worker-tuning
spec:
  machineConfigPoolSelector:
    matchLabels:
      cnf-worker-tuning: enabled
  kubeletConfig:
    cpuManagerPolicy: "static" <co xml:id="CO14-1"/>
    cpuManagerReconcilePeriod: "5s"
    reservedSystemCPUs: "0,1"
    memoryManagerPolicy: "Static" <co xml:id="CO14-2"/>
    evictionHard:
      memory.available: "100Mi"
    kubeReserved:
      memory: "512Mi"
    reservedMemory:
      - numaNode: 0
        limits:
          memory: "1124Mi"
    systemReserved:
      memory: "512Mi"
    topologyManagerPolicy: "single-numa-node" <co xml:id="CO14-3"/>
    topologyManagerScope: "pod"</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>For <literal>cpuManagerPolicy</literal>, <literal>static</literal> must use a lowercase <literal>s</literal>.</para>
</callout>
<callout arearefs="CO14-2">
<para>For <literal>memoryManagerPolicy</literal>, <literal>Static</literal> must use an uppercase <literal>S</literal>.</para>
</callout>
<callout arearefs="CO14-3">
<para><literal>topologyManagerPolicy</literal> must be set to <literal>single-numa-node</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>KubeletConfig</literal> custom resource (CR) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-kubeletconfig.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesScheduler</literal> custom resource that deploys the NUMA-aware custom pod scheduler:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-scheduler.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesScheduler
metadata:
  name: numaresourcesscheduler
spec:
  imageSpec: "registry.redhat.io/openshift4/noderesourcetopology-scheduler-container-rhel8:v4.14"
  cacheResyncPeriod: "5s" <co xml:id="CO15-1"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Enter an interval value in seconds for synchronization of the scheduler cache. A value of <literal>5s</literal> is typical for most implementations.</para>
</callout>
</calloutlist>
<note>
<itemizedlist>
<listitem>
<simpara>Enable the <literal>cacheResyncPeriod</literal> specification to help the NUMA Resource Operator report more exact resource availability by monitoring pending resources on nodes and synchronizing this information in the scheduler cache at a defined interval. This also helps to minimize <literal>Topology Affinity Error</literal> errors because of sub-optimal scheduling decisions. The lower the interval the greater the network load. The <literal>cacheResyncPeriod</literal> specification is disabled by default.</simpara>
</listitem>
<listitem>
<simpara>Setting a value of <literal>Enabled</literal> for the <literal>podsFingerprinting</literal> specification in the <literal>NUMAResourcesOperator</literal> CR is a requirement for the implementation of the <literal>cacheResyncPeriod</literal> specification.</simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>NUMAResourcesScheduler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-scheduler.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the required resources deployed successfully by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                    READY   STATUS    RESTARTS   AGE
pod/numaresources-controller-manager-7575848485-bns4s   1/1     Running   0          13m
pod/numaresourcesoperator-worker-dvj4n                  2/2     Running   0          16m
pod/numaresourcesoperator-worker-lcg4t                  2/2     Running   0          16m
pod/secondary-scheduler-56994cf6cf-7qf4q                1/1     Running   0          16m
NAME                                          DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR                     AGE
daemonset.apps/numaresourcesoperator-worker   2         2         2       2            2           node-role.kubernetes.io/worker=   16m
NAME                                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/numaresources-controller-manager   1/1     1            1           13m
deployment.apps/secondary-scheduler                1/1     1            1           16m
NAME                                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/numaresources-controller-manager-7575848485   1         1         1       13m
replicaset.apps/secondary-scheduler-56994cf6cf                1         1         1       16m</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-scheduling-numa-aware-workloads-with-manual-performance-setttings_numa-aware">
<title>Scheduling workloads with the NUMA-aware scheduler with manual performance settings</title>
<simpara>You can schedule workloads with the NUMA-aware scheduler using <literal>Deployment</literal> CRs that specify the minimum required resources to process the workload.</simpara>
<simpara>The following example deployment uses NUMA-aware scheduling for a sample workload.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator and deploy the NUMA-aware secondary scheduler.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the name of the NUMA-aware scheduler that is deployed in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesschedulers.nodetopology.openshift.io numaresourcesscheduler -o json | jq '.status.schedulerName'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">topo-aware-scheduler</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>Deployment</literal> CR that uses scheduler named <literal>topo-aware-scheduler</literal>, for example:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>nro-deployment.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: numa-deployment-1
  namespace: openshift-numaresources
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test
  template:
    metadata:
      labels:
        app: test
    spec:
      schedulerName: topo-aware-scheduler <co xml:id="CO16-1"/>
      containers:
      - name: ctnr
        image: quay.io/openshifttest/hello-openshift:openshift
        imagePullPolicy: IfNotPresent
        resources:
          limits:
            memory: "100Mi"
            cpu: "10"
          requests:
            memory: "100Mi"
            cpu: "10"
      - name: ctnr2
        image: registry.access.redhat.com/rhel:latest
        imagePullPolicy: IfNotPresent
        command: ["/bin/sh", "-c"]
        args: [ "while true; do sleep 1h; done;" ]
        resources:
          limits:
            memory: "100Mi"
            cpu: "8"
          requests:
            memory: "100Mi"
            cpu: "8"</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para><literal>schedulerName</literal> must match the name of the NUMA-aware scheduler that is deployed in your cluster, for example <literal>topo-aware-scheduler</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-deployment.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the deployment was successful:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                READY   STATUS    RESTARTS   AGE
numa-deployment-1-56954b7b46-pfgw8                  2/2     Running   0          129m
numaresources-controller-manager-7575848485-bns4s   1/1     Running   0          15h
numaresourcesoperator-worker-dvj4n                  2/2     Running   0          18h
numaresourcesoperator-worker-lcg4t                  2/2     Running   0          16h
secondary-scheduler-56994cf6cf-7qf4q                1/1     Running   0          18h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the <literal>topo-aware-scheduler</literal> is scheduling the deployed pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod numa-deployment-1-56954b7b46-pfgw8 -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Events:
  Type    Reason          Age   From                  Message
  ----    ------          ----  ----                  -------
  Normal  Scheduled       130m  topo-aware-scheduler  Successfully assigned openshift-numaresources/numa-deployment-1-56954b7b46-pfgw8 to compute-0.example.com</programlisting>
</para>
</formalpara>
<note>
<simpara>Deployments that request more resources than is available for scheduling will fail with a <literal>MinimumReplicasUnavailable</literal> error. The deployment succeeds when the required resources become available. Pods remain in the <literal>Pending</literal> state until the required resources are available.</simpara>
</note>
</listitem>
<listitem>
<simpara>Verify that the expected allocated resources are listed for the node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Identify the node that is running the deployment pod by running the following command, replacing &lt;namespace&gt; with the namespace you specified in the <literal>Deployment</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;namespace&gt; -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                 READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE   READINESS GATES
numa-deployment-1-65684f8fcc-bw4bw   0/2     Running   0          82m   10.128.2.50   worker-0   &lt;none&gt;  &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command, replacing &lt;node_name&gt; with the name of that node that is running the deployment pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe noderesourcetopologies.topology.node.k8s.io &lt;node_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...

Zones:
  Costs:
    Name:   node-0
    Value:  10
    Name:   node-1
    Value:  21
  Name:     node-0
  Resources:
    Allocatable:  39
    Available:    21 <co xml:id="CO17-1"/>
    Capacity:     40
    Name:         cpu
    Allocatable:  6442450944
    Available:    6442450944
    Capacity:     6442450944
    Name:         hugepages-1Gi
    Allocatable:  134217728
    Available:    134217728
    Capacity:     134217728
    Name:         hugepages-2Mi
    Allocatable:  262415904768
    Available:    262206189568
    Capacity:     270146007040
    Name:         memory
  Type:           Node</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>The <literal>Available</literal> capacity is reduced because of the resources that have been allocated to the guaranteed pod.</para>
</callout>
</calloutlist>
<simpara>Resources consumed by guaranteed pods are subtracted from the available node resources listed under <literal>noderesourcetopologies.topology.node.k8s.io</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Resource allocations for pods with a <literal>Best-effort</literal> or <literal>Burstable</literal> quality of service (<literal>qosClass</literal>) are not reflected in the NUMA node resources under <literal>noderesourcetopologies.topology.node.k8s.io</literal>. If a pod&#8217;s consumed resources are not reflected in the node resource calculation, verify that the pod has <literal>qosClass</literal> of <literal>Guaranteed</literal> and the CPU request is an integer value, not a decimal value. You can verify the that the pod has a  <literal>qosClass</literal> of <literal>Guaranteed</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod &lt;pod_name&gt; -n &lt;pod_namespace&gt; -o jsonpath="{ .status.qosClass }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Guaranteed</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cnf-configuring-node-groups-for-the-numaresourcesoperator_numa-aware">
<title>Optional: Configuring polling operations for NUMA resources updates</title>
<simpara>The daemons controlled by the NUMA Resources Operator in their <literal>nodeGroup</literal> poll resources to retrieve updates about available NUMA resources. You can fine-tune polling operations for these daemons by configuring the <literal>spec.nodeGroups</literal> specification in the <literal>NUMAResourcesOperator</literal> custom resource (CR). This provides advanced control of polling operations. Configure these specifications to improve scheduling behaviour and troubleshoot suboptimal scheduling decisions.</simpara>
<simpara>The configuration options are the following:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>infoRefreshMode</literal>: Determines the trigger condition for polling the kubelet. The NUMA Resources Operator reports the resulting information to the API server.</simpara>
</listitem>
<listitem>
<simpara><literal>infoRefreshPeriod</literal>: Determines the duration between polling updates.</simpara>
</listitem>
<listitem>
<simpara><literal>podsFingerprinting</literal>: Determines if point-in-time information for the current set of pods running on a node is exposed in polling updates.</simpara>
<note>
<simpara><literal>podsFingerprinting</literal> is enabled by default. <literal>podsFingerprinting</literal> is a requirement for the <literal>cacheResyncPeriod</literal> specification in the <literal>NUMAResourcesScheduler</literal> CR. The <literal>cacheResyncPeriod</literal> specification helps to report more exact resource availability by monitoring pending resources on nodes.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Configure the <literal>spec.nodeGroups</literal> specification in your <literal>NUMAResourcesOperator</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesOperator
metadata:
  name: numaresourcesoperator
spec:
  nodeGroups:
  - config:
      infoRefreshMode: Periodic <co xml:id="CO18-1"/>
      infoRefreshPeriod: 10s <co xml:id="CO18-2"/>
      podsFingerprinting: Enabled <co xml:id="CO18-3"/>
    name: worker</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Valid values are <literal>Periodic</literal>, <literal>Events</literal>, <literal>PeriodicAndEvents</literal>. Use <literal>Periodic</literal> to poll the kubelet at intervals that you define in <literal>infoRefreshPeriod</literal>. Use <literal>Events</literal> to poll the kubelet at every pod lifecycle event. Use <literal>PeriodicAndEvents</literal> to enable both methods.</para>
</callout>
<callout arearefs="CO18-2">
<para>Define the polling interval for <literal>Periodic</literal> or <literal>PeriodicAndEvents</literal> refresh modes. The field is ignored if the refresh mode is <literal>Events</literal>.</para>
</callout>
<callout arearefs="CO18-3">
<para>Valid values are <literal>Enabled</literal> or <literal>Disabled</literal>. Setting to <literal>Enabled</literal> is a requirement for the <literal>cacheResyncPeriod</literal> specification in the <literal>NUMAResourcesScheduler</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After you deploy the NUMA Resources Operator, verify that the node group configurations were applied by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresop numaresourcesoperator -o json | jq '.status'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">      ...

        "config": {
        "infoRefreshMode": "Periodic",
        "infoRefreshPeriod": "10s",
        "podsFingerprinting": "Enabled"
      },
      "name": "worker"

      ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cnf-troubleshooting-numa-aware-workloads_numa-aware">
<title>Troubleshooting NUMA-aware scheduling</title>
<simpara>To troubleshoot common problems with NUMA-aware pod scheduling, perform the following steps.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with cluster-admin privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator and deploy the NUMA-aware secondary scheduler.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Verify that the <literal>noderesourcetopologies</literal> CRD is deployed in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crd | grep noderesourcetopologies</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                              CREATED AT
noderesourcetopologies.topology.node.k8s.io                       2022-01-18T08:28:06Z</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the NUMA-aware scheduler name matches the name specified in your NUMA-aware workloads by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesschedulers.nodetopology.openshift.io numaresourcesscheduler -o json | jq '.status.schedulerName'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">topo-aware-scheduler</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that NUMA-aware scheduable nodes have the <literal>noderesourcetopologies</literal> CR applied to them. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get noderesourcetopologies.topology.node.k8s.io</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    AGE
compute-0.example.com   17h
compute-1.example.com   17h</programlisting>
</para>
</formalpara>
<note>
<simpara>The number of nodes should equal the number of worker nodes that are configured by the machine config pool (<literal>mcp</literal>) worker definition.</simpara>
</note>
</listitem>
<listitem>
<simpara>Verify the NUMA zone granularity for all scheduable nodes by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get noderesourcetopologies.topology.node.k8s.io -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
items:
- apiVersion: topology.node.k8s.io/v1
  kind: NodeResourceTopology
  metadata:
    annotations:
      k8stopoawareschedwg/rte-update: periodic
    creationTimestamp: "2022-06-16T08:55:38Z"
    generation: 63760
    name: worker-0
    resourceVersion: "8450223"
    uid: 8b77be46-08c0-4074-927b-d49361471590
  topologyPolicies:
  - SingleNUMANodeContainerLevel
  zones:
  - costs:
    - name: node-0
      value: 10
    - name: node-1
      value: 21
    name: node-0
    resources:
    - allocatable: "38"
      available: "38"
      capacity: "40"
      name: cpu
    - allocatable: "134217728"
      available: "134217728"
      capacity: "134217728"
      name: hugepages-2Mi
    - allocatable: "262352048128"
      available: "262352048128"
      capacity: "270107316224"
      name: memory
    - allocatable: "6442450944"
      available: "6442450944"
      capacity: "6442450944"
      name: hugepages-1Gi
    type: Node
  - costs:
    - name: node-0
      value: 21
    - name: node-1
      value: 10
    name: node-1
    resources:
    - allocatable: "268435456"
      available: "268435456"
      capacity: "268435456"
      name: hugepages-2Mi
    - allocatable: "269231067136"
      available: "269231067136"
      capacity: "270573244416"
      name: memory
    - allocatable: "40"
      available: "40"
      capacity: "40"
      name: cpu
    - allocatable: "1073741824"
      available: "1073741824"
      capacity: "1073741824"
      name: hugepages-1Gi
    type: Node
- apiVersion: topology.node.k8s.io/v1
  kind: NodeResourceTopology
  metadata:
    annotations:
      k8stopoawareschedwg/rte-update: periodic
    creationTimestamp: "2022-06-16T08:55:37Z"
    generation: 62061
    name: worker-1
    resourceVersion: "8450129"
    uid: e8659390-6f8d-4e67-9a51-1ea34bba1cc3
  topologyPolicies:
  - SingleNUMANodeContainerLevel
  zones: <co xml:id="CO19-1"/>
  - costs:
    - name: node-0
      value: 10
    - name: node-1
      value: 21
    name: node-0
    resources: <co xml:id="CO19-2"/>
    - allocatable: "38"
      available: "38"
      capacity: "40"
      name: cpu
    - allocatable: "6442450944"
      available: "6442450944"
      capacity: "6442450944"
      name: hugepages-1Gi
    - allocatable: "134217728"
      available: "134217728"
      capacity: "134217728"
      name: hugepages-2Mi
    - allocatable: "262391033856"
      available: "262391033856"
      capacity: "270146301952"
      name: memory
    type: Node
  - costs:
    - name: node-0
      value: 21
    - name: node-1
      value: 10
    name: node-1
    resources:
    - allocatable: "40"
      available: "40"
      capacity: "40"
      name: cpu
    - allocatable: "1073741824"
      available: "1073741824"
      capacity: "1073741824"
      name: hugepages-1Gi
    - allocatable: "268435456"
      available: "268435456"
      capacity: "268435456"
      name: hugepages-2Mi
    - allocatable: "269192085504"
      available: "269192085504"
      capacity: "270534262784"
      name: memory
    type: Node
kind: List
metadata:
  resourceVersion: ""
  selfLink: ""</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO19-1">
<para>Each stanza under <literal>zones</literal> describes the resources for a single NUMA zone.</para>
</callout>
<callout arearefs="CO19-2">
<para><literal>resources</literal> describes the current state of the NUMA zone resources. Check that resources listed under <literal>items.zones.resources.available</literal> correspond to the exclusive NUMA zone resources allocated to each guaranteed pod.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<section xml:id="cnf-checking-numa-aware-scheduler-logs_numa-aware">
<title>Checking the NUMA-aware scheduler logs</title>
<simpara>Troubleshoot problems with the NUMA-aware scheduler by reviewing the logs. If required, you can increase the scheduler log level by modifying the <literal>spec.logLevel</literal> field of the <literal>NUMAResourcesScheduler</literal> resource. Acceptable values are <literal>Normal</literal>, <literal>Debug</literal>, and <literal>Trace</literal>, with <literal>Trace</literal> being the most verbose option.</simpara>
<note>
<simpara>To change the log level of the secondary scheduler, delete the running scheduler resource and re-deploy it with the changed log level. The scheduler is unavailable for scheduling new workloads during this downtime.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Delete the currently running <literal>NUMAResourcesScheduler</literal> resource:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get the active <literal>NUMAResourcesScheduler</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get NUMAResourcesScheduler</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                     AGE
numaresourcesscheduler   90m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the secondary scheduler resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete NUMAResourcesScheduler numaresourcesscheduler</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">numaresourcesscheduler.nodetopology.openshift.io "numaresourcesscheduler" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Save the following YAML in the file <literal>nro-scheduler-debug.yaml</literal>. This example changes the log level to <literal>Debug</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodetopology.openshift.io/v1
kind: NUMAResourcesScheduler
metadata:
  name: numaresourcesscheduler
spec:
  imageSpec: "registry.redhat.io/openshift4/noderesourcetopology-scheduler-container-rhel8:v4.14"
  logLevel: Debug</programlisting>
</listitem>
<listitem>
<simpara>Create the updated <literal>Debug</literal> logging <literal>NUMAResourcesScheduler</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nro-scheduler-debug.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">numaresourcesscheduler.nodetopology.openshift.io/numaresourcesscheduler created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification steps</title>
<listitem>
<simpara>Check that the NUMA-aware scheduler was successfully deployed:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to check that the CRD is created succesfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crd | grep numaresourcesschedulers</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                              CREATED AT
numaresourcesschedulers.nodetopology.openshift.io                 2022-02-25T11:57:03Z</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the new custom scheduler is available by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesschedulers.nodetopology.openshift.io</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                     AGE
numaresourcesscheduler   3h26m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the logs for the scheduler shows the increased log level:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get the list of pods running in the <literal>openshift-numaresources</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               READY   STATUS    RESTARTS   AGE
numaresources-controller-manager-d87d79587-76mrm   1/1     Running   0          46h
numaresourcesoperator-worker-5wm2k                 2/2     Running   0          45h
numaresourcesoperator-worker-pb75c                 2/2     Running   0          45h
secondary-scheduler-7976c4d466-qm4sc               1/1     Running   0          21m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the logs for the secondary scheduler pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs secondary-scheduler-7976c4d466-qm4sc -n openshift-numaresources</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
I0223 11:04:55.614788       1 reflector.go:535] k8s.io/client-go/informers/factory.go:134: Watch close - *v1.Namespace total 11 items received
I0223 11:04:56.609114       1 reflector.go:535] k8s.io/client-go/informers/factory.go:134: Watch close - *v1.ReplicationController total 10 items received
I0223 11:05:22.626818       1 reflector.go:535] k8s.io/client-go/informers/factory.go:134: Watch close - *v1.StorageClass total 7 items received
I0223 11:05:31.610356       1 reflector.go:535] k8s.io/client-go/informers/factory.go:134: Watch close - *v1.PodDisruptionBudget total 7 items received
I0223 11:05:31.713032       1 eventhandlers.go:186] "Add event for scheduled pod" pod="openshift-marketplace/certified-operators-thtvq"
I0223 11:05:53.461016       1 eventhandlers.go:244] "Delete event for scheduled pod" pod="openshift-marketplace/certified-operators-thtvq"</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cnf-troubleshooting-resource-topo-exporter_numa-aware">
<title>Troubleshooting the resource topology exporter</title>
<simpara>Troubleshoot <literal>noderesourcetopologies</literal> objects where unexpected results are occurring by inspecting the corresponding <literal>resource-topology-exporter</literal> logs.</simpara>
<note>
<simpara>It is recommended that NUMA resource topology exporter instances in the cluster are named for nodes they refer to. For example, a worker node with the name <literal>worker</literal> should have a corresponding <literal>noderesourcetopologies</literal> object called <literal>worker</literal>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the daemonsets managed by the NUMA Resources Operator. Each daemonset has a corresponding <literal>nodeGroup</literal> in the <literal>NUMAResourcesOperator</literal> CR. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get numaresourcesoperators.nodetopology.openshift.io numaresourcesoperator -o jsonpath="{.status.daemonsets[0]}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"name":"numaresourcesoperator-worker","namespace":"openshift-numaresources"}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the label for the daemonset of interest using the value for <literal>name</literal> from the previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ds -n openshift-numaresources numaresourcesoperator-worker -o jsonpath="{.spec.selector.matchLabels}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"name":"resource-topology"}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the pods using the <literal>resource-topology</literal> label by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-numaresources -l name=resource-topology -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                 READY   STATUS    RESTARTS   AGE    IP            NODE
numaresourcesoperator-worker-5wm2k   2/2     Running   0          2d1h   10.135.0.64   compute-0.example.com
numaresourcesoperator-worker-pb75c   2/2     Running   0          2d1h   10.132.2.33   compute-1.example.com</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Examine the logs of the <literal>resource-topology-exporter</literal> container running on the worker pod that corresponds to the node you are troubleshooting. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-numaresources -c resource-topology-exporter numaresourcesoperator-worker-pb75c</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">I0221 13:38:18.334140       1 main.go:206] using sysinfo:
reservedCpus: 0,1
reservedMemory:
  "0": 1178599424
I0221 13:38:18.334370       1 main.go:67] === System information ===
I0221 13:38:18.334381       1 sysinfo.go:231] cpus: reserved "0-1"
I0221 13:38:18.334493       1 sysinfo.go:237] cpus: online "0-103"
I0221 13:38:18.546750       1 main.go:72]
cpus: allocatable "2-103"
hugepages-1Gi:
  numa cell 0 -&gt; 6
  numa cell 1 -&gt; 1
hugepages-2Mi:
  numa cell 0 -&gt; 64
  numa cell 1 -&gt; 128
memory:
  numa cell 0 -&gt; 45758Mi
  numa cell 1 -&gt; 48372Mi</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cnf-troubleshooting-missing-rte-config-maps_numa-aware">
<title>Correcting a missing resource topology exporter config map</title>
<simpara>If you install the NUMA Resources Operator in a cluster with misconfigured cluster settings, in some circumstances, the Operator is shown as active but the logs of the resource topology exporter (RTE) daemon set pods show that the configuration for the RTE is missing, for example:</simpara>
<programlisting language="text" linenumbering="unnumbered">Info: couldn't find configuration in "/etc/resource-topology-exporter/config.yaml"</programlisting>
<simpara>This log message indicates that the <literal>kubeletconfig</literal> with the required configuration was not properly applied in the cluster, resulting in a missing RTE <literal>configmap</literal>. For example, the following cluster is missing a <literal>numaresourcesoperator-worker</literal> <literal>configmap</literal> custom resource (CR):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmap</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           DATA   AGE
0e2a6bd3.openshift-kni.io      0      6d21h
kube-root-ca.crt               1      6d21h
openshift-service-ca.crt       1      6d21h
topo-aware-scheduler-config    1      6d18h</programlisting>
</para>
</formalpara>
<simpara>In a correctly configured cluster, <literal>oc get configmap</literal> also returns a <literal>numaresourcesoperator-worker</literal> <literal>configmap</literal> CR.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with cluster-admin privileges.</simpara>
</listitem>
<listitem>
<simpara>Install the NUMA Resources Operator and deploy the NUMA-aware secondary scheduler.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Compare the values for <literal>spec.machineConfigPoolSelector.matchLabels</literal> in <literal>kubeletconfig</literal> and
<literal>metadata.labels</literal> in the <literal>MachineConfigPool</literal> (<literal>mcp</literal>) worker CR using the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the <literal>kubeletconfig</literal> labels by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeletconfig -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">machineConfigPoolSelector:
  matchLabels:
    cnf-worker-tuning: enabled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>mcp</literal> labels by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp worker -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">labels:
  machineconfiguration.openshift.io/mco-built-in: ""
  pools.operator.machineconfiguration.openshift.io/worker: ""</programlisting>
</para>
</formalpara>
<simpara>The <literal>cnf-worker-tuning: enabled</literal> label is not present in the <literal>MachineConfigPool</literal> object.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Edit the <literal>MachineConfigPool</literal> CR to include the missing label, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit mcp worker -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">labels:
  machineconfiguration.openshift.io/mco-built-in: ""
  pools.operator.machineconfiguration.openshift.io/worker: ""
  cnf-worker-tuning: enabled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the label changes and wait for the cluster to apply the updated configuration. Run the following command:</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the missing <literal>numaresourcesoperator-worker</literal> <literal>configmap</literal> CR is applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmap</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           DATA   AGE
0e2a6bd3.openshift-kni.io      0      6d21h
kube-root-ca.crt               1      6d21h
numaresourcesoperator-worker   1      5m
openshift-service-ca.crt       1      6d21h
topo-aware-scheduler-config    1      6d18h</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-about-collecting-nro-data_numa-aware">
<title>Collecting NUMA Resources Operator data</title>
<simpara>You can use the <literal>oc adm must-gather</literal> CLI command to collect information about your cluster, including features and objects associated with the NUMA Resources Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To collect NUMA Resources Operator data with <literal>must-gather</literal>, you must specify the NUMA Resources Operator <literal>must-gather</literal> image.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/numaresources-must-gather/numaresources-must-gather-rhel9:4.14</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_scalability-and-performance-optimization">
<title>Scalability and performance optimization</title>
<section xml:id="optimizing-storage">
<title>Optimizing storage</title>
<simpara>Optimizing storage helps to minimize storage use across all resources. By
optimizing storage, administrators help ensure that existing storage resources
are working in an efficient manner.</simpara>
<section xml:id="available-persistent-storage-options_persistent-storage">
<title>Available persistent storage options</title>
<simpara>Understand your persistent storage options so that you can optimize your
OpenShift Container Platform environment.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Available storage options</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="12.5*"/>
<colspec colname="col_2" colwidth="50*"/>
<colspec colname="col_3" colwidth="37.5*"/>
<thead>
<row>
<entry align="left" valign="top">Storage type</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Examples</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Presented to the operating system (OS) as a block device</simpara>
</listitem>
<listitem>
<simpara>Suitable for applications that need full control of storage and operate at a low level on files
bypassing the file system</simpara>
</listitem>
<listitem>
<simpara>Also referred to as a Storage Area Network (SAN)</simpara>
</listitem>
<listitem>
<simpara>Non-shareable, which means that only one client at a time can mount an endpoint of this type</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>AWS EBS and VMware vSphere support dynamic persistent volume (PV) provisioning natively in OpenShift Container Platform.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Presented to the OS as a file system export to be mounted</simpara>
</listitem>
<listitem>
<simpara>Also referred to as Network Attached Storage (NAS)</simpara>
</listitem>
<listitem>
<simpara>Concurrency, latency, file locking mechanisms, and other capabilities vary widely between protocols, implementations, vendors, and scales.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>RHEL NFS, NetApp NFS <superscript>[1]</superscript>, and Vendor NFS</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Accessible through a REST API endpoint</simpara>
</listitem>
<listitem>
<simpara>Configurable for use in the OpenShift image registry</simpara>
</listitem>
<listitem>
<simpara>Applications must build their drivers into the application and/or container.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>AWS S3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>NetApp NFS supports dynamic PV provisioning when using the Trident plugin.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="recommended-configurable-storage-technology_persistent-storage">
<title>Recommended configurable storage technology</title>
<simpara>The following table summarizes the recommended and configurable storage technologies for the given OpenShift Container Platform cluster application.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Recommended and configurable storage technology</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Storage type</entry>
<entry align="left" valign="top">Block</entry>
<entry align="left" valign="top">File</entry>
<entry align="left" valign="top">Object</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ROX<superscript>1</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Yes<superscript>4</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Yes<superscript>4</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RWX<superscript>2</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Registry</simpara></entry>
<entry align="left" valign="top"><simpara>Configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Scaled registry</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Metrics<superscript>3</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>Configurable<superscript>5</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Elasticsearch Logging</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>Configurable<superscript>6</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Not supported<superscript>6</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Loki Logging</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Apps</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>Recommended</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable<superscript>7</superscript></simpara></entry>
</row>
</tbody>
<tfoot>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_4"><simpara><superscript>1</superscript> <literal>ReadOnlyMany</literal></simpara>
<simpara><superscript>2</superscript> <literal>ReadWriteMany</literal></simpara>
<simpara><superscript>3</superscript> Prometheus is the underlying technology used for metrics.</simpara>
<simpara><superscript>4</superscript> This does not apply to physical disk, VM physical disk, VMDK, loopback over NFS, AWS EBS, and Azure Disk.</simpara>
<simpara><superscript>5</superscript> For metrics, using file storage with the <literal>ReadWriteMany</literal> (RWX) access mode is unreliable. If you use file storage, do not configure the RWX access mode on any persistent volume claims (PVCs) that are configured for use with metrics.</simpara>
<simpara><superscript>6</superscript> For logging, review the recommended storage solution in Configuring persistent storage for the log store section. Using NFS storage as a persistent volume or through NAS, such as Gluster, can corrupt the data. Hence, NFS is not supported for Elasticsearch storage and LokiStack log store in OpenShift Container Platform Logging. You must use one persistent volume type per log store.</simpara>
<simpara><superscript>7</superscript> Object storage is not consumed through OpenShift Container Platform&#8217;s PVs or PVCs. Apps must integrate with the object storage REST API.</simpara></entry>
</row>
</tfoot>
</tgroup>
</table>
<note>
<simpara>A scaled registry is an OpenShift image registry where two or more pod replicas are running.</simpara>
</note>
<section xml:id="_specific-application-storage-recommendations">
<title>Specific application storage recommendations</title>
<important>
<simpara>Testing shows issues with using the NFS server on Red Hat Enterprise Linux (RHEL) as storage backend for core services. This includes the OpenShift Container Registry and Quay, Prometheus for monitoring storage, and Elasticsearch for logging storage. Therefore, using RHEL NFS to back PVs used by core services is not recommended.</simpara>
<simpara>Other NFS implementations on the marketplace might not have these issues. Contact the individual NFS implementation vendor for more information on any testing that was possibly completed against these OpenShift Container Platform core components.</simpara>
</important>
<section xml:id="_registry">
<title>Registry</title>
<simpara>In a non-scaled/high-availability (HA) OpenShift image registry cluster deployment:</simpara>
<itemizedlist>
<listitem>
<simpara>The storage technology does not have to support RWX access mode.</simpara>
</listitem>
<listitem>
<simpara>The storage technology must ensure read-after-write consistency.</simpara>
</listitem>
<listitem>
<simpara>The preferred storage technology is object storage followed by block storage.</simpara>
</listitem>
<listitem>
<simpara>File storage is not recommended for OpenShift image registry cluster deployment with production workloads.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_scaled-registry">
<title>Scaled registry</title>
<simpara>In a scaled/HA OpenShift image registry cluster deployment:</simpara>
<itemizedlist>
<listitem>
<simpara>The storage technology must support RWX access mode.</simpara>
</listitem>
<listitem>
<simpara>The storage technology must ensure read-after-write consistency.</simpara>
</listitem>
<listitem>
<simpara>The preferred storage technology is object storage.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Data Foundation (ODF), Amazon Simple Storage Service (Amazon S3), Google Cloud Storage (GCS), Microsoft Azure Blob Storage, and OpenStack Swift are supported.</simpara>
</listitem>
<listitem>
<simpara>Object storage should be S3 or Swift compliant.</simpara>
</listitem>
<listitem>
<simpara>For non-cloud platforms, such as vSphere and bare metal installations, the only configurable technology is file storage.</simpara>
</listitem>
<listitem>
<simpara>Block storage is not configurable.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_metrics">
<title>Metrics</title>
<simpara>In an OpenShift Container Platform hosted metrics cluster deployment:</simpara>
<itemizedlist>
<listitem>
<simpara>The preferred storage technology is block storage.</simpara>
</listitem>
<listitem>
<simpara>Object storage is not configurable.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>It is not recommended to use file storage for a hosted metrics cluster deployment with production workloads.</simpara>
</important>
</section>
<section xml:id="_logging">
<title>Logging</title>
<simpara>In an OpenShift Container Platform hosted logging cluster deployment:</simpara>
<itemizedlist>
<listitem>
<simpara>Loki Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>The preferred storage technology is S3 compatible Object storage.</simpara>
</listitem>
<listitem>
<simpara>Block storage is not configurable.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>OpenShift Elasticsearch Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>The preferred storage technology is block storage.</simpara>
</listitem>
<listitem>
<simpara>Object storage is not supported.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>As of logging version 5.4.3 the OpenShift Elasticsearch Operator is deprecated and is planned to be removed in a future release. Red Hat will provide bug fixes and support for this feature during the current release lifecycle, but this feature will no longer receive enhancements and will be removed. As an alternative to using the OpenShift Elasticsearch Operator to manage the default log storage, you can use the Loki Operator.</simpara>
</note>
</section>
<section xml:id="_applications">
<title>Applications</title>
<simpara>Application use cases vary from application to application, as described in the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara>Storage technologies that support dynamic PV provisioning have low mount time latencies, and are not tied to nodes to support a healthy cluster.</simpara>
</listitem>
<listitem>
<simpara>Application developers are responsible for knowing and understanding the storage requirements for their application, and how it works with the provided storage to ensure that issues do not occur when an application scales or interacts with the storage layer.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_other-specific-application-storage-recommendations">
<title>Other specific application storage recommendations</title>
<important>
<simpara>It is not recommended to use RAID configurations on <literal>Write</literal> intensive workloads, such as <literal>etcd</literal>. If you are running <literal>etcd</literal> with a RAID configuration, you might be at risk of encountering performance issues with your workloads.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenStack Platform (RHOSP) Cinder: RHOSP Cinder tends to be adept in ROX access mode use cases.</simpara>
</listitem>
<listitem>
<simpara>Databases: Databases (RDBMSs, NoSQL DBs, etc.) tend to perform best with dedicated block storage.</simpara>
</listitem>
<listitem>
<simpara>The etcd database must have enough storage and adequate performance capacity to enable a large cluster. Information about monitoring and benchmarking tools to establish ample storage and a high-performance environment is described in <emphasis>Recommended etcd practices</emphasis>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="data-storage-management_persistent-storage">
<title>Data storage management</title>
<simpara>The following table summarizes the main directories that OpenShift Container Platform components write data to.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Main directories for storing OpenShift Container Platform data</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Directory</entry>
<entry align="left" valign="top">Notes</entry>
<entry align="left" valign="top">Sizing</entry>
<entry align="left" valign="top">Expected growth</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>/var/lib/etcd</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Used for etcd storage when storing the database.</simpara></entry>
<entry align="left" valign="top"><simpara>Less than 20 GB.</simpara><simpara>Database can grow up to 8 GB.</simpara></entry>
<entry align="left" valign="top"><simpara>Will grow slowly with the environment. Only storing metadata.</simpara><simpara>Additional 20-25 GB for every additional 8 GB of memory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>/var/lib/containers</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>This is the mount point for the CRI-O runtime. Storage used for active container runtimes, including pods, and storage of local images. Not used for registry storage.</simpara></entry>
<entry align="left" valign="top"><simpara>50 GB for a node with 16 GB memory. Note that this sizing should not be used to determine minimum cluster requirements.</simpara><simpara>Additional 20-25 GB for every additional 8 GB of memory.</simpara></entry>
<entry align="left" valign="top"><simpara>Growth is limited by capacity for running containers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>/var/lib/kubelet</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Ephemeral volume storage for pods. This includes anything external that is mounted into a container at runtime. Includes environment variables, kube secrets, and data volumes not backed by persistent volumes.</simpara></entry>
<entry align="left" valign="top"><simpara>Varies</simpara></entry>
<entry align="left" valign="top"><simpara>Minimal if pods requiring storage are using persistent volumes. If using ephemeral storage, this can grow quickly.</simpara></entry>
</row>
</tbody>
<tfoot>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>/var/log</emphasis></emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Log files for all components.</simpara></entry>
<entry align="left" valign="top"><simpara>10 to 30 GB.</simpara></entry>
<entry align="left" valign="top"><simpara>Log files can grow quickly; size can be managed by growing disks or by using log rotate.</simpara></entry>
</row>
</tfoot>
</tgroup>
</table>
</section>
<section xml:id="optimizing-storage-azure_persistent-storage">
<title>Optimizing storage performance for Microsoft Azure</title>
<simpara>OpenShift Container Platform and Kubernetes are sensitive to disk performance, and faster storage is recommended, particularly for etcd on the control plane nodes.</simpara>
<simpara>For production Azure clusters and clusters with intensive workloads, the virtual machine operating system disk for control plane machines should be able to sustain a tested and recommended minimum throughput of 5000 IOPS / 200MBps.
This throughput can be provided by having a minimum of 1 TiB Premium SSD (P30).
In Azure and Azure Stack Hub, disk performance is directly dependent on SSD disk sizes. To achieve the throughput supported by a <literal>Standard_D8s_v3</literal> virtual machine, or other similar machine types, and the target of 5000 IOPS, at least a P30 disk is required.</simpara>
<simpara>Host caching must be set to <literal>ReadOnly</literal> for low latency and high IOPS and throughput when reading data. Reading data from the cache, which is present either in the VM memory or in the local SSD disk, is much faster than reading from the disk, which is in the blob storage.</simpara>
</section>
<section xml:id="admission-plug-ins-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/logging/#logging-config-es-store">Configuring the Elasticsearch log store</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="routing-optimization">
<title>Optimizing routing</title>
<simpara>The OpenShift Container Platform HAProxy router can be scaled or configured to optimize performance.</simpara>
<section xml:id="baseline-router-performance_routing-optimization">
<title>Baseline Ingress Controller (router) performance</title>
<simpara>The OpenShift Container Platform Ingress Controller, or router, is the ingress point for ingress traffic for applications and services that are configured using routes and ingresses.</simpara>
<simpara>When evaluating a single HAProxy router performance in terms of HTTP requests handled per second, the performance varies depending on many factors. In particular:</simpara>
<itemizedlist>
<listitem>
<simpara>HTTP keep-alive/close mode</simpara>
</listitem>
<listitem>
<simpara>Route type</simpara>
</listitem>
<listitem>
<simpara>TLS session resumption client support</simpara>
</listitem>
<listitem>
<simpara>Number of concurrent connections per target route</simpara>
</listitem>
<listitem>
<simpara>Number of target routes</simpara>
</listitem>
<listitem>
<simpara>Back end server page size</simpara>
</listitem>
<listitem>
<simpara>Underlying infrastructure (network/SDN solution, CPU, and so on)</simpara>
</listitem>
</itemizedlist>
<simpara>While performance in your specific environment will vary, Red Hat lab tests on a public cloud instance of size 4 vCPU/16GB RAM. A single HAProxy router handling 100 routes terminated by backends serving 1kB static pages is able to handle the following number of transactions per second.</simpara>
<simpara>In HTTP keep-alive mode scenarios:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Encryption</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">LoadBalancerService</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">HostNetwork</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>21515</simpara></entry>
<entry align="left" valign="top"><simpara>29622</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>edge</simpara></entry>
<entry align="left" valign="top"><simpara>16743</simpara></entry>
<entry align="left" valign="top"><simpara>22913</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>passthrough</simpara></entry>
<entry align="left" valign="top"><simpara>36786</simpara></entry>
<entry align="left" valign="top"><simpara>53295</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>re-encrypt</simpara></entry>
<entry align="left" valign="top"><simpara>21583</simpara></entry>
<entry align="left" valign="top"><simpara>25198</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In HTTP close (no keep-alive) scenarios:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Encryption</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">LoadBalancerService</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">HostNetwork</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>5719</simpara></entry>
<entry align="left" valign="top"><simpara>8273</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>edge</simpara></entry>
<entry align="left" valign="top"><simpara>2729</simpara></entry>
<entry align="left" valign="top"><simpara>4069</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>passthrough</simpara></entry>
<entry align="left" valign="top"><simpara>4121</simpara></entry>
<entry align="left" valign="top"><simpara>5344</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>re-encrypt</simpara></entry>
<entry align="left" valign="top"><simpara>2320</simpara></entry>
<entry align="left" valign="top"><simpara>2941</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The default Ingress Controller configuration was used with the <literal>spec.tuningOptions.threadCount</literal> field set to <literal>4</literal>. Two different endpoint publishing strategies were tested: Load Balancer Service and Host Network. TLS session resumption was used for encrypted routes. With HTTP keep-alive, a single HAProxy router is capable of saturating a 1 Gbit NIC at page sizes as small as 8 kB.</simpara>
<simpara>When running on bare metal with modern processors, you can expect roughly twice the performance of the public cloud instance above. This overhead is introduced by the virtualization layer in place on public clouds and holds mostly true for private cloud-based virtualization as well. The following table is a guide to how many applications to use behind the router:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Number of applications</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Application type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>5-10</simpara></entry>
<entry align="left" valign="top"><simpara>static file/web server or caching proxy</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100-1000</simpara></entry>
<entry align="left" valign="top"><simpara>applications generating dynamic content</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In general, HAProxy can support routes for up to 1000 applications, depending on the technology in use. Ingress Controller performance might be limited by the
capabilities and performance of the applications behind it, such as language or static versus dynamic content.</simpara>
<simpara>Ingress, or router, sharding should be used to serve more routes towards applications and help horizontally scale the routing tier.</simpara>
<simpara>For more information on Ingress sharding, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-ingress-sharding-route-labels_configuring-ingress">Configuring Ingress Controller sharding by using route labels</link> and <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-ingress-sharding-namespace-labels_configuring-ingress">Configuring Ingress Controller sharding by using namespace labels</link>.</simpara>
<simpara>You can modify the Ingress Controller deployment using the information provided in <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-ingress-setting-thread-count">Setting Ingress Controller thread count</link> for threads and <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-ingress-controller-configuration-parameters_configuring-ingress">Ingress Controller configuration parameters</link> for timeouts, and other tuning configurations in the Ingress Controller specification.</simpara>
</section>
<section xml:id="ingress-liveness-readiness-startup-probes_routing-optimization">
<title>Configuring Ingress Controller liveness, readiness, and startup probes</title>
<simpara>Cluster administrators can configure the timeout values for the kubelet&#8217;s liveness, readiness, and startup probes for router deployments that are managed by the OpenShift Container Platform Ingress Controller (router). The liveness and readiness probes of the router use the default timeout value
of 1 second, which is too brief when networking or runtime performance is severely degraded. Probe timeouts can cause unwanted router restarts that interrupt application connections. The ability to set larger timeout values can reduce the risk of unnecessary and unwanted restarts.</simpara>
<simpara>You can update the <literal>timeoutSeconds</literal> value on the <literal>livenessProbe</literal>, <literal>readinessProbe</literal>, and <literal>startupProbe</literal> parameters of the router container.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>livenessProbe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>livenessProbe</literal> reports to the kubelet whether a pod is dead and needs to be restarted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>readinessProbe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>readinessProbe</literal> reports whether a pod is healthy or unhealthy. When the readiness probe reports an unhealthy pod, then the kubelet marks the pod as not ready to accept traffic. Subsequently, the endpoints for that pod are marked as not ready, and this status propagates to the kube-proxy. On cloud platforms with a configured load balancer, the kube-proxy communicates to the cloud load-balancer not to send traffic to the node with that pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>startupProbe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>startupProbe</literal> gives the router pod up to 2 minutes to initialize before the kubelet begins sending the router liveness and readiness probes.  This initialization time can prevent routers with many routes or endpoints from prematurely restarting.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<important>
<simpara>The timeout configuration option is an advanced tuning technique that can be used to work around issues. However, these issues should eventually be diagnosed and possibly a support case or <link xlink:href="https://issues.redhat.com/secure/CreateIssueDetails!init.jspa?pid=12332330&amp;summary=Summary&amp;issuetype=1&amp;priority=10200&amp;versions=12385624">Jira issue</link> opened for any issues that causes probes to time out.</simpara>
</important>
<simpara>The following example demonstrates how you can directly patch the default router deployment to set a 5-second timeout for the liveness and readiness probes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-ingress patch deploy/router-default --type=strategic --patch='{"spec":{"template":{"spec":{"containers":[{"name":"router","livenessProbe":{"timeoutSeconds":5},"readinessProbe":{"timeoutSeconds":5}}]}}}}'</programlisting>
<formalpara>
<title>Verification</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-ingress describe deploy/router-default | grep -e Liveness: -e Readiness:
    Liveness:   http-get http://:1936/healthz delay=0s timeout=5s period=10s #success=1 #failure=3
    Readiness:  http-get http://:1936/healthz/ready delay=0s timeout=5s period=10s #success=1 #failure=3</programlisting>
</para>
</formalpara>
</section>
<section xml:id="configuring-haproxy-interval_routing-optimization">
<title>Configuring HAProxy reload interval</title>
<simpara>When you update a route or an endpoint associated with a route, OpenShift Container Platform router updates the configuration for HAProxy. Then, HAProxy reloads the updated configuration for those changes to take effect. When HAProxy reloads, it generates a new process that handles new connections using the updated configuration.</simpara>
<simpara>HAProxy keeps the old process running to handle existing connections until those connections are all closed. When old processes have long-lived connections, these processes can accumulate and consume resources.</simpara>
<simpara>The default minimum HAProxy reload interval is five seconds. You can configure an Ingress Controller using its <literal>spec.tuningOptions.reloadInterval</literal> field to set a longer minimum reload interval.</simpara>
<warning>
<simpara>Setting a large value for the minimum HAProxy reload interval can cause latency in observing updates to routes and their endpoints. To lessen the risk, avoid setting a value larger than the tolerable latency for updates.</simpara>
</warning>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Change the minimum HAProxy reload interval of the default Ingress Controller to 15 seconds by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-ingress-operator patch ingresscontrollers/default --type=merge --patch='{"spec":{"tuningOptions":{"reloadInterval":"15s"}}}'</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="optimizing-networking">
<title>Optimizing networking</title>
<simpara>The <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#about-openshift-sdn">OpenShift SDN</link> uses OpenvSwitch, virtual extensible LAN (VXLAN) tunnels, OpenFlow rules, and iptables. This network can be tuned by using jumbo frames, network interface controllers (NIC) offloads, multi-queue, and ethtool settings.</simpara>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#about-ovn-kubernetes">OVN-Kubernetes</link> uses Geneve (Generic Network Virtualization Encapsulation) instead of VXLAN as the tunnel protocol.</simpara>
<simpara>VXLAN provides benefits over VLANs, such as an increase in networks from 4096 to over 16 million, and layer 2 connectivity across physical networks. This allows for all pods behind a service to communicate with each other, even if they are running on different systems.</simpara>
<simpara>VXLAN encapsulates all tunneled traffic in user datagram protocol (UDP) packets. However, this leads to increased CPU utilization. Both these outer- and
inner-packets are subject to normal checksumming rules to guarantee data is not corrupted during transit. Depending on CPU performance, this additional
processing overhead can cause a reduction in throughput and increased latency when compared to traditional, non-overlay networks.</simpara>
<simpara>Cloud, VM, and bare metal CPU performance can be capable of handling much more than one Gbps network throughput. When using higher bandwidth links such as 10 or 40 Gbps, reduced performance can occur. This is a known issue in VXLAN-based environments and is not specific to containers or OpenShift Container Platform. Any network that relies on VXLAN tunnels will perform similarly because of the VXLAN implementation.</simpara>
<simpara>If you are looking to push beyond one Gbps, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Evaluate network plugins that implement different routing techniques, such as border gateway protocol (BGP).</simpara>
</listitem>
<listitem>
<simpara>Use VXLAN-offload capable network adapters. VXLAN-offload moves the packet checksum calculation and associated CPU overhead off of the system CPU and onto dedicated hardware on the network adapter. This frees up CPU cycles for use by pods and applications, and allows users to utilize the full bandwidth of their network infrastructure.</simpara>
</listitem>
</itemizedlist>
<simpara>VXLAN-offload does not reduce latency. However, CPU utilization is reduced even in latency tests.</simpara>
<section xml:id="optimizing-mtu_optimizing-networking">
<title>Optimizing the MTU for your network</title>
<simpara>There are two important maximum transmission units (MTUs): the network interface controller (NIC) MTU and the cluster network MTU.</simpara>
<simpara>The NIC MTU is only configured at the time of OpenShift Container Platform installation. The MTU must be less than or equal to the maximum supported value of the NIC of your network. If you are optimizing for throughput, choose the largest possible value. If you are optimizing for lowest latency, choose a lower value.</simpara>
<simpara>The OpenShift SDN network plugin overlay MTU must be less than the NIC MTU by 50 bytes at a minimum. This accounts for the SDN overlay header. So, on a normal ethernet network, this should be set to <literal>1450</literal>. On a jumbo frame ethernet network, this should be set to <literal>8950</literal>. These values should be set automatically by the Cluster Network Operator based on the NIC&#8217;s configured MTU. Therefore, cluster administrators do not typically update these values. Amazon Web Services (AWS) and bare-metal environments support jumbo frame ethernet networks. This setting will help throughput, especially with transmission control protocol (TCP).</simpara>
<simpara>For OVN and Geneve, the MTU must be less than the NIC MTU by 100 bytes at a minimum.</simpara>
<note>
<simpara>This 50 byte overlay header is relevant to the OpenShift SDN network plugin. Other SDN solutions might require the value to be more or less.</simpara>
</note>
</section>
<section xml:id="recommended-install-practices_optimizing-networking">
<title>Recommended practices for installing large scale clusters</title>
<simpara>When installing large clusters or scaling the cluster to larger node counts,
set the cluster network <literal>cidr</literal> accordingly in your <literal>install-config.yaml</literal>
file before you install the cluster:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">networking:
  clusterNetwork:
  - cidr: 10.128.0.0/14
    hostPrefix: 23
  machineNetwork:
  - cidr: 10.0.0.0/16
  networkType: OVNKubernetes
  serviceNetwork:
  - 172.30.0.0/16</programlisting>
<simpara>The default cluster network <literal>cidr</literal> <literal>10.128.0.0/14</literal> cannot be used if the cluster
size is more than 500 nodes. It must be set to <literal>10.128.0.0/12</literal> or
<literal>10.128.0.0/10</literal> to get to larger node counts beyond 500 nodes.</simpara>
</section>
<section xml:id="ipsec-impact_optimizing-networking">
<title>Impact of IPsec</title>
<simpara>Because encrypting and decrypting node hosts uses CPU power, performance is affected both in throughput and CPU usage on the nodes when encryption is enabled, regardless of the IP security system being used.</simpara>
<simpara>IPSec encrypts traffic at the IP payload level, before it hits the NIC, protecting fields that would otherwise be used for NIC offloading. This means that some NIC acceleration features might not be usable when IPSec is enabled and will lead to decreased throughput and increased CPU usage.</simpara>
</section>
<section xml:id="optimizing-networking-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#modifying-nwoperator-config-startup_installing-aws-network-customizations">Modifying advanced network configuration parameters</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-operator-configuration-parameters-for-ovn-sdn_cluster-network-operator">Configuration parameters for the OVN-Kubernetes network plugin</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-operator-configuration-parameters-for-openshift-sdn_cluster-network-operator">Configuration parameters for the OpenShift SDN network plugin</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="scaling-worker-latency-profiles">Improving cluster stability in high latency environments using worker latency profiles</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="optimizing-cpu-usage">
<title>Optimizing CPU usage with mount namespace encapsulation</title>
<simpara>You can optimize CPU usage in OpenShift Container Platform clusters by using mount namespace encapsulation to provide a private namespace for kubelet and CRI-O processes. This reduces the cluster CPU resources used by systemd with no difference in functionality.</simpara>
<important>
<simpara>Mount namespace encapsulation is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="optimizing-cpu-usage_optimizing-cpu-usage">
<title>Encapsulating mount namespaces</title>
<simpara>Mount namespaces are used to isolate mount points so that processes in different namespaces cannot view each others' files. Encapsulation is the process of moving Kubernetes mount namespaces to an alternative location where they will not be constantly scanned by the host operating system.</simpara>
<simpara>The host operating system uses systemd to constantly scan all mount namespaces: both the standard Linux mounts and the numerous mounts that Kubernetes uses to operate. The current implementation of kubelet and CRI-O both use the top-level namespace for all container runtime and kubelet mount points. However, encapsulating these container-specific mount points in a private namespace reduces systemd overhead with no difference in functionality. Using a separate mount namespace for both CRI-O and kubelet can encapsulate container-specific mounts from any systemd or other host operating system interaction.</simpara>
<simpara>This ability to potentially achieve major CPU optimization is now available to all OpenShift Container Platform administrators. Encapsulation can also improve security by storing Kubernetes-specific mount points in a location safe from inspection by unprivileged users.</simpara>
<simpara>The following diagrams illustrate a Kubernetes installation before and after encapsulation. Both scenarios show example containers which have mount propagation settings of bidirectional, host-to-container, and none.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/before-k8s-mount-propagation.png"/>
</imageobject>
<textobject><phrase>Before encapsulation</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Here we see systemd, host operating system processes, kubelet, and the container runtime sharing a single mount namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>systemd, host operating system processes, kubelet, and the container runtime each have access to and visibility of all mount points.</simpara>
</listitem>
<listitem>
<simpara>Container 1, configured with bidirectional mount propagation, can access systemd and host mounts, kubelet and CRI-O mounts. A mount originating in Container 1, such as <literal>/run/a</literal> is visible to systemd, host operating system processes, kubelet, container runtime, and other containers with host-to-container or bidirectional mount propagation configured (as in Container 2).</simpara>
</listitem>
<listitem>
<simpara>Container 2, configured with host-to-container mount propagation, can access systemd and host mounts, kubelet and CRI-O mounts. A mount originating in Container 2, such as <literal>/run/b</literal>, is not visible to any other context.</simpara>
</listitem>
<listitem>
<simpara>Container 3, configured with no mount propagation, has no visibility of external mount points. A mount originating in Container 3, such as <literal>/run/c</literal>, is not visible to any other context.</simpara>
</listitem>
</itemizedlist>
<simpara>The following diagram illustrates the system state after encapsulation.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/after-k8s-mount-propagation.png"/>
</imageobject>
<textobject><phrase>After encapsulation</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>The main systemd process is no longer devoted to unnecessary scanning of Kubernetes-specific mount points. It only monitors systemd-specific and host mount points.</simpara>
</listitem>
<listitem>
<simpara>The host operating system processes can access only the systemd and host mount points.</simpara>
</listitem>
<listitem>
<simpara>Using a separate mount namespace for both CRI-O and kubelet completely separates all container-specific mounts away from any systemd or other host operating system interaction whatsoever.</simpara>
</listitem>
<listitem>
<simpara>The behavior of Container 1 is unchanged, except a mount it creates such as <literal>/run/a</literal> is no longer visible to systemd or host operating system processes. It is still visible to kubelet, CRI-O, and other containers with host-to-container or bidirectional mount propagation configured (like Container 2).</simpara>
</listitem>
<listitem>
<simpara>The behavior of Container 2 and Container 3 is unchanged.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="enabling-encapsulation_optimizing-cpu-usage">
<title>Configuring mount namespace encapsulation</title>
<simpara>You can configure mount namespace encapsulation so that a cluster runs with less resource overhead.</simpara>
<note>
<simpara>Mount namespace encapsulation is a Technology Preview feature and it is disabled by default. To use it, you must enable the feature manually.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file called <literal>mount_namespace_config.yaml</literal> with the following YAML:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 99-kubens-master
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - enabled: true
        name: kubens.service
---
apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 99-kubens-worker
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - enabled: true
        name: kubens.service</programlisting>
</listitem>
<listitem>
<simpara>Apply the mount namespace <literal>MachineConfig</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f mount_namespace_config.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineconfig.machineconfiguration.openshift.io/99-kubens-master created
machineconfig.machineconfiguration.openshift.io/99-kubens-worker created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The <literal>MachineConfig</literal> CR can take up to 30 minutes to finish being applied in the cluster. You can check the status of the <literal>MachineConfig</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                             UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master   rendered-master-03d4bc4befb0f4ed3566a2c8f7636751   False     True       False      3              0                   0                     0                      45m
worker   rendered-worker-10577f6ab0117ed1825f8af2ac687ddf   False     True       False      3              1                   1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Wait for the <literal>MachineConfig</literal> CR to be applied successfully across all control plane and worker nodes after running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc wait --for=condition=Updated mcp --all --timeout=30m</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineconfigpool.machineconfiguration.openshift.io/master condition met
machineconfigpool.machineconfiguration.openshift.io/worker condition met</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify encapsulation for a cluster host, run the following commands:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a debug shell to the cluster host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Open a <literal>chroot</literal> session:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Check the systemd mount namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# readlink /proc/1/ns/mnt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">mnt:[4026531953]</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check kubelet mount namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# readlink /proc/$(pgrep kubelet)/ns/mnt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">mnt:[4026531840]</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the CRI-O mount namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# readlink /proc/$(pgrep crio)/ns/mnt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">mnt:[4026531840]</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>These commands return the mount namespaces associated with systemd, kubelet, and the container runtime. In OpenShift Container Platform, the container runtime is CRI-O.</simpara>
<simpara>Encapsulation is in effect if systemd is in a different mount namespace to kubelet and CRI-O as in the above example.
Encapsulation is not in effect if all three processes are in the same mount namespace.</simpara>
</section>
<section xml:id="supporting-encapsulation_optimizing-cpu-usage">
<title>Inspecting encapsulated namespaces</title>
<simpara>You can inspect Kubernetes-specific mount points in the cluster host operating system for debugging or auditing purposes by using the <literal>kubensenter</literal> script that is available in Red Hat Enterprise Linux CoreOS (RHCOS).</simpara>
<simpara>SSH shell sessions to the cluster host are in the default namespace.
To inspect Kubernetes-specific mount points in an SSH shell prompt, you need to run the <literal>kubensenter</literal> script as root.
The <literal>kubensenter</literal> script is aware of the state of the mount encapsulation, and is safe to run even if encapsulation is not enabled.</simpara>
<note>
<simpara><literal>oc debug</literal> remote shell sessions start inside the Kubernetes namespace by default.
You do not need to run <literal>kubensenter</literal> to inspect mount points when you use <literal>oc debug</literal>.</simpara>
</note>
<simpara>If the encapsulation feature is not enabled, the <literal>kubensenter findmnt</literal> and <literal>findmnt</literal> commands return the same output, regardless of whether they are run in an <literal>oc debug</literal> session or in an SSH shell prompt.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have configured SSH access to the cluster host.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open a remote SSH shell to the cluster host. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run commands using the provided <literal>kubensenter</literal> script as the root user.
To run a single command inside the Kubernetes namespace, provide the command and any arguments to the <literal>kubensenter</literal> script.
For example, to run the <literal>findmnt</literal> command inside the Kubernetes namespace, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">[core@control-plane-1 ~]$ sudo kubensenter findmnt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kubensenter: Autodetect: kubens.service namespace found at /run/kubens/mnt
TARGET                                SOURCE                 FSTYPE     OPTIONS
/                                     /dev/sda4[/ostree/deploy/rhcos/deploy/32074f0e8e5ec453e56f5a8a7bc9347eaa4172349ceab9c22b709d9d71a3f4b0.0]
|                                                            xfs        rw,relatime,seclabel,attr2,inode64,logbufs=8,logbsize=32k,prjquota
                                      shm                    tmpfs
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To start a new interactive shell inside the Kubernetes namespace, run the <literal>kubensenter</literal> script without any arguments:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">[core@control-plane-1 ~]$ sudo kubensenter</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kubensenter: Autodetect: kubens.service namespace found at /run/kubens/mnt</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="running-services-with-encapsulation_optimizing-cpu-usage">
<title>Running additional services in the encapsulated namespace</title>
<simpara>Any monitoring tool that relies on the ability to run in the host operating system and have visibility of mount points created by kubelet, CRI-O, or containers themselves, must enter the container mount namespace to see these mount points. The <literal>kubensenter</literal> script that is provided with OpenShift Container Platform executes another command inside the Kubernetes mount point and can be used to adapt any existing tools.</simpara>
<simpara>The <literal>kubensenter</literal> script is aware of the state of the mount encapsulation feature status, and is safe to run even if encapsulation is not enabled. In that case the script executes the provided command in the default mount namespace.</simpara>
<simpara>For example, if a systemd service needs to run inside the new Kubernetes mount namespace, edit the service file and use the <literal>ExecStart=</literal> command line with <literal>kubensenter</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">[Unit]
Description=Example service
[Service]
ExecStart=/usr/bin/kubensenter /path/to/original/command arg1 arg2</programlisting>
</section>
<section xml:id="optimizing-cpu-usage-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/monitoring_and_managing_system_status_and_performance/setting-limits-for-applications_monitoring-and-managing-system-status-and-performance#what-namespaces-are_setting-limits-for-applications">What are namespaces</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.redhat.com/sysadmin/container-namespaces-nsenter">Manage containers in namespaces by using nsenter</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/api_reference/#machineconfig-machineconfiguration.openshift.io/v1">MachineConfig</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="managing-bare-metal-hosts">
<title>Managing bare metal hosts</title>
<simpara>When you install OpenShift Container Platform on a bare metal cluster, you can provision and manage bare metal nodes using <literal>machine</literal> and <literal>machineset</literal> custom resources (CRs) for bare metal hosts that exist in the cluster.</simpara>
<section xml:id="about-bare-metal-hosts-and-nodes_managing-bare-metal-hosts">
<title>About bare metal hosts and nodes</title>
<simpara>To provision a Red Hat Enterprise Linux CoreOS (RHCOS) bare metal host as a node in your cluster, first create a <literal>MachineSet</literal> custom resource (CR) object that corresponds to the bare metal host hardware. Bare metal host compute machine sets describe infrastructure components specific to your configuration. You apply specific Kubernetes labels to these compute machine sets and then update the infrastructure components to run on only those machines.</simpara>
<simpara><literal>Machine</literal> CR&#8217;s are created automatically when you scale up the relevant <literal>MachineSet</literal> containing a <literal>metal3.io/autoscale-to-hosts</literal> annotation. OpenShift Container Platform uses <literal>Machine</literal> CR&#8217;s to provision the bare metal node that corresponds to the host as specified in the <literal>MachineSet</literal> CR.</simpara>
</section>
<section xml:id="maintaining-bare-metal-hosts_managing-bare-metal-hosts">
<title>Maintaining bare metal hosts</title>
<simpara>You can maintain the details of the bare metal hosts in your cluster from the OpenShift Container Platform web console. Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Bare Metal Hosts</emphasis>, and select a task from the <emphasis role="strong">Actions</emphasis> drop down menu. Here you can manage items such as BMC details, boot MAC address for the host, enable power management, and so on. You can also review the details of the network interfaces and drives for the host.</simpara>
<simpara>You can move a bare metal host into maintenance mode. When you move a host into maintenance mode, the scheduler moves all managed workloads off the corresponding bare metal node. No new workloads are scheduled while in maintenance mode.</simpara>
<simpara>You can deprovision a bare metal host in the web console. Deprovisioning a host does the following actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Annotates the bare metal host CR with <literal>cluster.k8s.io/delete-machine: true</literal></simpara>
</listitem>
<listitem>
<simpara>Scales down the related compute machine set</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Powering off the host without first moving the daemon set and unmanaged static pods to another node can cause service disruption and loss of data.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#adding-bare-metal-compute-user-infra">Adding compute machines to bare metal</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="adding-bare-metal-host-to-cluster-using-web-console_managing-bare-metal-hosts">
<title>Adding a bare metal host to the cluster using the web console</title>
<simpara>You can add bare metal hosts to the cluster in the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install an RHCOS cluster on bare metal.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Bare Metal Hosts</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Add Host</emphasis> &#8594; <emphasis role="strong">New with Dialog</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Specify a unique name for the new bare metal host.</simpara>
</listitem>
<listitem>
<simpara>Set the <emphasis role="strong">Boot MAC address</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Set the <emphasis role="strong">Baseboard Management Console (BMC) Address</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter the user credentials for the host&#8217;s baseboard management controller (BMC).</simpara>
</listitem>
<listitem>
<simpara>Select to power on the host after creation, and select <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Scale up the number of replicas to match the number of available bare metal hosts. Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineSets</emphasis>, and increase the number of machine replicas in the cluster by selecting <emphasis role="strong">Edit Machine count</emphasis> from the <emphasis role="strong">Actions</emphasis> drop-down menu.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>You can also manage the number of bare metal nodes using the <literal>oc scale</literal> command and the appropriate bare metal compute machine set.</simpara>
</note>
</section>
<section xml:id="adding-bare-metal-host-to-cluster-using-yaml_managing-bare-metal-hosts">
<title>Adding a bare metal host to the cluster using YAML in the web console</title>
<simpara>You can add bare metal hosts to the cluster in the web console using a YAML file that describes the bare metal host.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install a RHCOS compute machine on bare metal infrastructure for use in the cluster.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>Secret</literal> CR for the bare metal host.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Bare Metal Hosts</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Add Host</emphasis> &#8594; <emphasis role="strong">New from YAML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Copy and paste the below YAML, modifying the relevant fields with the details of your host:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: metal3.io/v1alpha1
kind: BareMetalHost
metadata:
  name: &lt;bare_metal_host_name&gt;
spec:
  online: true
  bmc:
    address: &lt;bmc_address&gt;
    credentialsName: &lt;secret_credentials_name&gt;  <co xml:id="CO20-1"/>
    disableCertificateVerification: True <co xml:id="CO20-2"/>
  bootMACAddress: &lt;host_boot_mac_address&gt;</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para><literal>credentialsName</literal> must reference a valid <literal>Secret</literal> CR. The <literal>baremetal-operator</literal> cannot manage the bare metal host without a valid <literal>Secret</literal> referenced in the <literal>credentialsName</literal>. For more information about secrets and how to create them, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-pods-secrets-about_nodes-pods-secrets">Understanding secrets</link>.</para>
</callout>
<callout arearefs="CO20-2">
<para>Setting <literal>disableCertificateVerification</literal> to <literal>true</literal> disables TLS host validation between the cluster and the baseboard management controller (BMC).</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis> to save the YAML and create the new bare metal host.</simpara>
</listitem>
<listitem>
<simpara>Scale up the number of replicas to match the number of available bare metal hosts. Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineSets</emphasis>, and increase the number of machines in the cluster by selecting <emphasis role="strong">Edit Machine count</emphasis> from the <emphasis role="strong">Actions</emphasis> drop-down menu.</simpara>
<note>
<simpara>You can also manage the number of bare metal nodes using the <literal>oc scale</literal> command and the appropriate bare metal compute machine set.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="automatically-scaling-machines-to-available-bare-metal-hosts_managing-bare-metal-hosts">
<title>Automatically scaling machines to the number of available bare metal hosts</title>
<simpara>To automatically create the number of <literal>Machine</literal> objects that matches the number of available <literal>BareMetalHost</literal> objects, add a <literal>metal3.io/autoscale-to-hosts</literal> annotation to the <literal>MachineSet</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install RHCOS bare metal compute machines for use in the cluster, and create corresponding <literal>BareMetalHost</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the compute machine set that you want to configure for automatic scaling by adding the <literal>metal3.io/autoscale-to-hosts</literal> annotation. Replace <literal>&lt;machineset&gt;</literal> with the name of the compute machine set.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate machineset &lt;machineset&gt; -n openshift-machine-api 'metal3.io/autoscale-to-hosts=&lt;any_value&gt;'</programlisting>
<simpara>Wait for the new scaled machines to start.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>When you use a <literal>BareMetalHost</literal> object to create a machine in the cluster and labels or selectors are subsequently changed on the <literal>BareMetalHost</literal>, the <literal>BareMetalHost</literal> object continues be counted against the <literal>MachineSet</literal> that the <literal>Machine</literal> object was created from.</simpara>
</note>
</section>
<section xml:id="removing-bare-metal-hosts-from-provisioner_managing-bare-metal-hosts">
<title>Removing bare metal hosts from the provisioner node</title>
<simpara>In certain circumstances, you might want to temporarily remove bare metal hosts from the provisioner node.
For example, during provisioning when a bare metal host reboot is triggered by using the OpenShift Container Platform administration console or as a result of a Machine Config Pool update, OpenShift Container Platform logs into the integrated Dell Remote Access Controller (iDrac) and issues a delete of the job queue.</simpara>
<simpara>To prevent the management of the number of <literal>Machine</literal> objects that matches the number of available <literal>BareMetalHost</literal> objects, add a <literal>baremetalhost.metal3.io/detached</literal> annotation to the <literal>MachineSet</literal> object.</simpara>
<note>
<simpara>This annotation has an effect for only <literal>BareMetalHost</literal> objects that are in either <literal>Provisioned</literal>, <literal>ExternallyProvisioned</literal> or <literal>Ready/Available</literal> state.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install RHCOS bare metal compute machines for use in the cluster and create corresponding <literal>BareMetalHost</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the compute machine set that you want to remove from the provisioner node by adding the <literal>baremetalhost.metal3.io/detached</literal> annotation.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate machineset &lt;machineset&gt; -n openshift-machine-api 'baremetalhost.metal3.io/detached'</programlisting>
<simpara>Wait for the new machines to start.</simpara>
<note>
<simpara>When you use a <literal>BareMetalHost</literal> object to create a machine in the cluster and labels or selectors are subsequently changed on the <literal>BareMetalHost</literal>, the <literal>BareMetalHost</literal> object continues be counted against the <literal>MachineSet</literal> that the <literal>Machine</literal> object was created from.</simpara>
</note>
</listitem>
<listitem>
<simpara>In the provisioning use case, remove the annotation after the reboot is complete by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate machineset &lt;machineset&gt; -n openshift-machine-api 'baremetalhost.metal3.io/detached-'</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#ipi-install-expanding-the-cluster">Expanding the cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#machine-health-checks-bare-metal_deploying-machine-health-checks">MachineHealthChecks on bare metal</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="using-rfhe">
<title>Monitoring bare-metal events with the Bare Metal Event Relay</title>
<important>
<simpara>Bare Metal Event Relay is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="about-using-redfish-hardware-events">
<title>About bare-metal events</title>
<simpara>Use the Bare Metal Event Relay to subscribe applications that run in your OpenShift Container Platform cluster to events that are generated on the underlying bare-metal host. The Redfish service publishes events on a node and transmits them on an advanced message queue to subscribed applications.</simpara>
<simpara>Bare-metal events are based on the open Redfish standard that is developed under the guidance of the Distributed Management Task Force (DMTF). Redfish provides a secure industry-standard protocol with a REST API. The protocol is used for the management of distributed, converged or software-defined resources and infrastructure.</simpara>
<simpara>Hardware-related events published through Redfish includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Breaches of temperature limits</simpara>
</listitem>
<listitem>
<simpara>Server status</simpara>
</listitem>
<listitem>
<simpara>Fan status</simpara>
</listitem>
</itemizedlist>
<simpara>Begin using bare-metal events by deploying the Bare Metal Event Relay Operator and subscribing your application to the service. The Bare Metal Event Relay Operator installs and manages the lifecycle of the Redfish bare-metal event service.</simpara>
<note>
<simpara>The Bare Metal Event Relay works only with Redfish-capable devices on single-node clusters provisioned on bare-metal infrastructure.</simpara>
</note>
</section>
<section xml:id="nw-rfhe-introduction_using-rfhe">
<title>How bare-metal events work</title>
<simpara>The Bare Metal Event Relay enables applications running on bare-metal clusters to respond quickly to Redfish hardware changes and failures such as breaches of temperature thresholds, fan failure, disk loss, power outages, and memory failure. These hardware events are delivered over a reliable low-latency transport channel based on Advanced Message Queuing Protocol (AMQP). The latency of the messaging service is between 10 to 20 milliseconds.</simpara>
<simpara>The Bare Metal Event Relay provides a publish-subscribe service for the hardware events. Applications can use a REST API to subscribe to the events. The Bare Metal Event Relay supports hardware that complies with Redfish OpenAPI v1.8 or later.</simpara>
<section xml:id="rfhe-elements_using-rfhe">
<title>Bare Metal Event Relay data flow</title>
<simpara>The following figure illustrates an example bare-metal events data flow:</simpara>
<figure>
<title>Bare Metal Event Relay data flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/319_OpenShift_redfish_bare-metal_OCP_nodes_0323.png"/>
</imageobject>
<textobject><phrase>Bare-metal events data flow</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="_operator-managed-pod">
<title>Operator-managed pod</title>
<simpara>The Operator uses custom resources to manage the pod containing the Bare Metal Event Relay and its components using the <literal>HardwareEvent</literal> CR.</simpara>
</section>
<section xml:id="_bare-metal-event-relay">
<title>Bare Metal Event Relay</title>
<simpara>At startup, the Bare Metal Event Relay queries the Redfish API and downloads all the message registries, including custom registries. The Bare Metal Event Relay then begins to receive subscribed events from the Redfish hardware.</simpara>
<simpara>The Bare Metal Event Relay enables applications running on bare-metal clusters to respond quickly to Redfish hardware changes and failures such as breaches of temperature thresholds, fan failure, disk loss, power outages, and memory failure. The events are reported using the <literal>HardwareEvent</literal> CR.</simpara>
</section>
<section xml:id="_cloud-native-event">
<title>Cloud native event</title>
<simpara>Cloud native events (CNE) is a REST API specification for defining the format of event data.</simpara>
</section>
<section xml:id="_cncf-cloudevents">
<title>CNCF CloudEvents</title>
<simpara><link xlink:href="https://cloudevents.io/">CloudEvents</link> is a vendor-neutral specification developed by the Cloud Native Computing Foundation (CNCF) for defining the format of event data.</simpara>
</section>
<section xml:id="_http-transport-or-amqp-dispatch-router">
<title>HTTP transport or AMQP dispatch router</title>
<simpara>The HTTP transport or AMQP dispatch router is responsible for the message delivery service between publisher and subscriber.</simpara>
<note>
<simpara>Use HTTP transport instead of AMQP for PTP and bare-metal events where possible.
AMQ Interconnect is EOL from 30 June 2024.
Extended life cycle support (ELS) for AMQ Interconnect ends 29 November 2029.
For more information see, <link xlink:href="https://access.redhat.com/support/policy/updates/jboss_notes#p_Interconnect">Red Hat AMQ Interconnect support status</link>.</simpara>
</note>
</section>
<section xml:id="_cloud-event-proxy-sidecar">
<title>Cloud event proxy sidecar</title>
<simpara>The cloud event proxy sidecar container image is based on the O-RAN API specification and provides a publish-subscribe event framework for hardware events.</simpara>
</section>
</section>
<section xml:id="rfhe-data-flow_using-rfhe">
<title>Redfish message parsing service</title>
<simpara>In addition to handling Redfish events, the Bare Metal Event Relay provides message parsing for events without a <literal>Message</literal> property. The proxy downloads all the Redfish message registries including vendor specific registries from the hardware when it starts. If an event does not contain a <literal>Message</literal> property, the proxy uses the Redfish message registries to construct the <literal>Message</literal> and <literal>Resolution</literal> properties and add them to the event before passing the event to the cloud events framework. This service allows Redfish events to have smaller message size and lower transmission latency.</simpara>
</section>
<section xml:id="nw-rfhe-installing-operator-cli_using-rfhe">
<title>Installing the Bare Metal Event Relay using the CLI</title>
<simpara>As a cluster administrator, you can install the Bare Metal Event Relay Operator by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A cluster that is installed on bare-metal hardware with nodes that have a RedFish-enabled Baseboard Management Controller (BMC).</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a namespace for the Bare Metal Event Relay.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>bare-metal-events-namespace.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: openshift-bare-metal-events
  labels:
    name: openshift-bare-metal-events
    openshift.io/cluster-monitoring: "true"</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f bare-metal-events-namespace.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an Operator group for the Bare Metal Event Relay Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>bare-metal-events-operatorgroup.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: bare-metal-event-relay-group
  namespace: openshift-bare-metal-events
spec:
  targetNamespaces:
  - openshift-bare-metal-events</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f bare-metal-events-operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Subscribe to the Bare Metal Event Relay.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>bare-metal-events-sub.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: bare-metal-event-relay-subscription
  namespace: openshift-bare-metal-events
spec:
  channel: "stable"
  name: bare-metal-event-relay
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f bare-metal-events-sub.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the Bare Metal Event Relay Operator is installed, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-bare-metal-events -o custom-columns=Name:.metadata.name,Phase:.status.phase</programlisting>
</section>
<section xml:id="nw-rfhe-installing-operator-web-console_using-rfhe">
<title>Installing the Bare Metal Event Relay using the web console</title>
<simpara>As a cluster administrator, you can install the Bare Metal Event Relay Operator using the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A cluster that is installed on bare-metal hardware with nodes that have a RedFish-enabled Baseboard Management Controller (BMC).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Bare Metal Event Relay using the OpenShift Container Platform web console:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose  <emphasis role="strong">Bare Metal Event Relay</emphasis> from the list of available Operators, and then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, select or create a <emphasis role="strong">Namespace</emphasis>, select <emphasis role="strong">openshift-bare-metal-events</emphasis>, and then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Optional: You can verify that the Operator installed successfully by performing the following check:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Switch to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Ensure that <emphasis role="strong">Bare Metal Event Relay</emphasis> is listed in the project with a <emphasis role="strong">Status</emphasis> of <emphasis role="strong">InstallSucceeded</emphasis>.</simpara>
<note>
<simpara>During installation an Operator might display a <emphasis role="strong">Failed</emphasis> status. If the installation later succeeds with an <emphasis role="strong">InstallSucceeded</emphasis> message, you can ignore the <emphasis role="strong">Failed</emphasis> message.</simpara>
</note>
</listitem>
</orderedlist>
<simpara>If the Operator does not appear as installed, to troubleshoot further:</simpara>
<itemizedlist>
<listitem>
<simpara>Go to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <emphasis role="strong">Operator Subscriptions</emphasis> and <emphasis role="strong">Install Plans</emphasis> tabs for any failure or errors under <emphasis role="strong">Status</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Go to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs for pods in the project namespace.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="hw-installing-amq-interconnect-messaging-bus_using-rfhe">
<title>Installing the AMQ messaging bus</title>
<simpara>To pass Redfish bare-metal event notifications between publisher and subscriber on a node, you can install and configure an AMQ messaging bus to run locally on the node. You do this by installing the AMQ Interconnect Operator for use in the cluster.</simpara>
<note>
<simpara>Use HTTP transport instead of AMQP for PTP and bare-metal events where possible.
AMQ Interconnect is EOL from 30 June 2024.
Extended life cycle support (ELS) for AMQ Interconnect ends 29 November 2029.
For more information see, <link xlink:href="https://access.redhat.com/support/policy/updates/jboss_notes#p_Interconnect">Red Hat AMQ Interconnect support status</link>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Install the AMQ Interconnect Operator to its own <literal>amq-interconnect</literal> namespace. See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_amq/2021.q1/html/deploying_amq_interconnect_on_openshift/adding-operator-router-ocp">Installing the AMQ Interconnect Operator</link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the AMQ Interconnect Operator is available and the required pods are running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n amq-interconnect</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS    RESTARTS   AGE
amq-interconnect-645db76c76-k8ghs       1/1     Running   0          23h
interconnect-operator-5cb5fc7cc-4v7qm   1/1     Running   0          23h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the required <literal>bare-metal-event-relay</literal> bare-metal event producer pod is running in the <literal>openshift-bare-metal-events</literal> namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-bare-metal-events</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                            READY   STATUS    RESTARTS   AGE
hw-event-proxy-operator-controller-manager-74d5649b7c-dzgtl     2/2     Running   0          25s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="subscribing-hw-events">
<title>Subscribing to Redfish BMC bare-metal events for a cluster node</title>
<simpara>You can subscribe to Redfish BMC events generated on a node in your cluster by creating a <literal>BMCEventSubscription</literal> custom resource (CR) for the node, creating a <literal>HardwareEvent</literal> CR for the event, and creating a <literal>Secret</literal> CR for the BMC.</simpara>
<section xml:id="nw-rfhe-creating-bmc-event-sub_using-rfhe">
<title>Subscribing to bare-metal events</title>
<simpara>You can configure the baseboard management controller (BMC) to send bare-metal events to subscribed applications running in an OpenShift Container Platform cluster. Example Redfish bare-metal events include an increase in device temperature, or removal of a device. You subscribe applications to bare-metal events using a REST API.</simpara>
<important>
<simpara>You can only create a <literal>BMCEventSubscription</literal> custom resource (CR) for physical hardware that supports Redfish and has a vendor interface set to <literal>redfish</literal> or <literal>idrac-redfish</literal>.</simpara>
</important>
<note>
<simpara>Use the <literal>BMCEventSubscription</literal> CR to subscribe to predefined Redfish events. The Redfish standard does not provide an option to create specific alerts and thresholds. For example, to receive an alert event when an enclosure&#8217;s temperature exceeds 40 Celsius, you must manually configure the event according to the vendor&#8217;s recommendations.</simpara>
</note>
<simpara>Perform the following procedure to subscribe to bare-metal events for the node using a <literal>BMCEventSubscription</literal> CR.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Get the user name and password for the BMC.</simpara>
</listitem>
<listitem>
<simpara>Deploy a bare-metal node with a Redfish-enabled Baseboard Management Controller (BMC) in your cluster, and enable Redfish events on the BMC.</simpara>
<note>
<simpara>Enabling Redfish events on specific hardware is outside the scope of this information. For more information about enabling Redfish events for your specific hardware, consult the BMC manufacturer documentation.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the node hardware has the Redfish <literal>EventService</literal> enabled by running the following <literal>curl</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl https://&lt;bmc_ip_address&gt;/redfish/v1/EventService --insecure -H 'Content-Type: application/json' -u "&lt;bmc_username&gt;:&lt;password&gt;"</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>bmc_ip_address</term>
<listitem>
<simpara>is the IP address of the BMC where the Redfish events are generated.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
   "@odata.context": "/redfish/v1/$metadata#EventService.EventService",
   "@odata.id": "/redfish/v1/EventService",
   "@odata.type": "#EventService.v1_0_2.EventService",
   "Actions": {
      "#EventService.SubmitTestEvent": {
         "EventType@Redfish.AllowableValues": ["StatusChange", "ResourceUpdated", "ResourceAdded", "ResourceRemoved", "Alert"],
         "target": "/redfish/v1/EventService/Actions/EventService.SubmitTestEvent"
      }
   },
   "DeliveryRetryAttempts": 3,
   "DeliveryRetryIntervalSeconds": 30,
   "Description": "Event Service represents the properties for the service",
   "EventTypesForSubscription": ["StatusChange", "ResourceUpdated", "ResourceAdded", "ResourceRemoved", "Alert"],
   "EventTypesForSubscription@odata.count": 5,
   "Id": "EventService",
   "Name": "Event Service",
   "ServiceEnabled": true,
   "Status": {
      "Health": "OK",
      "HealthRollup": "OK",
      "State": "Enabled"
   },
   "Subscriptions": {
      "@odata.id": "/redfish/v1/EventService/Subscriptions"
   }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the Bare Metal Event Relay service route for the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route -n openshift-bare-metal-events</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HOST/PORT   PATH                                                                    SERVICES                 PORT   TERMINATION   WILDCARD
hw-event-proxy              hw-event-proxy-openshift-bare-metal-events.apps.compute-1.example.com   hw-event-proxy-service   9087   edge          None</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>BMCEventSubscription</literal> resource to subscribe to the Redfish events:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>bmc_sub.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: metal3.io/v1alpha1
kind: BMCEventSubscription
metadata:
  name: sub-01
  namespace: openshift-machine-api
spec:
   hostName: &lt;hostname&gt; <co xml:id="CO21-1"/>
   destination: &lt;proxy_service_url&gt; <co xml:id="CO21-2"/>
   context: ''</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Specifies the name or UUID of the worker node where the Redfish events are generated.</para>
</callout>
<callout arearefs="CO21-2">
<para>Specifies the bare-metal event proxy service, for example, <literal><link xlink:href="https://hw-event-proxy-openshift-bare-metal-events.apps.compute-1.example.com/webhook">https://hw-event-proxy-openshift-bare-metal-events.apps.compute-1.example.com/webhook</link></literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>BMCEventSubscription</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f bmc_sub.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: To delete the BMC event subscription, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f bmc_sub.yaml</programlisting>
</listitem>
<listitem>
<simpara>Optional: To manually create a Redfish event subscription without creating a <literal>BMCEventSubscription</literal> CR, run the following <literal>curl</literal> command, specifying the BMC username and password.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -i -k -X POST -H "Content-Type: application/json"  -d '{"Destination": "https://&lt;proxy_service_url&gt;", "Protocol" : "Redfish", "EventTypes": ["Alert"], "Context": "root"}' -u &lt;bmc_username&gt;:&lt;password&gt; 'https://&lt;bmc_ip_address&gt;/redfish/v1/EventService/Subscriptions' v</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>proxy_service_url</term>
<listitem>
<simpara>is the bare-metal event proxy service, for example, <literal><link xlink:href="https://hw-event-proxy-openshift-bare-metal-events.apps.compute-1.example.com/webhook">https://hw-event-proxy-openshift-bare-metal-events.apps.compute-1.example.com/webhook</link></literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>bmc_ip_address</term>
<listitem>
<simpara>is the IP address of the BMC where the Redfish events are generated.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">HTTP/1.1 201 Created
Server: AMI MegaRAC Redfish Service
Location: /redfish/v1/EventService/Subscriptions/1
Allow: GET, POST
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: X-Auth-Token
Access-Control-Allow-Headers: X-Auth-Token
Access-Control-Allow-Credentials: true
Cache-Control: no-cache, must-revalidate
Link: &lt;http://redfish.dmtf.org/schemas/v1/EventDestination.v1_6_0.json&gt;; rel=describedby
Link: &lt;http://redfish.dmtf.org/schemas/v1/EventDestination.v1_6_0.json&gt;
Link: &lt;/redfish/v1/EventService/Subscriptions&gt;; path=
ETag: "1651135676"
Content-Type: application/json; charset=UTF-8
OData-Version: 4.0
Content-Length: 614
Date: Thu, 28 Apr 2022 08:47:57 GMT</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nw-rfhe-querying-redfish-hardware-event-subs_using-rfhe">
<title>Querying Redfish bare-metal event subscriptions with curl</title>
<simpara>Some hardware vendors limit the amount of Redfish hardware event subscriptions. You can query the number of Redfish event subscriptions by using <literal>curl</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Get the user name and password for the BMC.</simpara>
</listitem>
<listitem>
<simpara>Deploy a bare-metal node with a Redfish-enabled Baseboard Management Controller (BMC) in your cluster, and enable Redfish hardware events on the BMC.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the current subscriptions for the BMC by running the following <literal>curl</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --globoff -H "Content-Type: application/json" -k -X GET --user &lt;bmc_username&gt;:&lt;password&gt; https://&lt;bmc_ip_address&gt;/redfish/v1/EventService/Subscriptions</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>bmc_ip_address</term>
<listitem>
<simpara>is the IP address of the BMC where the Redfish events are generated.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">% Total % Received % Xferd Average Speed Time Time Time Current
Dload Upload Total Spent Left Speed
100 435 100 435 0 0 399 0 0:00:01 0:00:01 --:--:-- 399
{
  "@odata.context": "/redfish/v1/$metadata#EventDestinationCollection.EventDestinationCollection",
  "@odata.etag": ""
  1651137375 "",
  "@odata.id": "/redfish/v1/EventService/Subscriptions",
  "@odata.type": "#EventDestinationCollection.EventDestinationCollection",
  "Description": "Collection for Event Subscriptions",
  "Members": [
  {
    "@odata.id": "/redfish/v1/EventService/Subscriptions/1"
  }],
  "Members@odata.count": 1,
  "Name": "Event Subscriptions Collection"
}</programlisting>
</para>
</formalpara>
<simpara>In this example, a single subscription is configured: <literal>/redfish/v1/EventService/Subscriptions/1</literal>.</simpara>
</listitem>
<listitem>
<simpara>Optional: To remove the <literal>/redfish/v1/EventService/Subscriptions/1</literal> subscription with <literal>curl</literal>, run the following command, specifying the BMC username and password:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --globoff -L -w "%{http_code} %{url_effective}\n" -k -u &lt;bmc_username&gt;:&lt;password &gt;-H "Content-Type: application/json" -d '{}' -X DELETE https://&lt;bmc_ip_address&gt;/redfish/v1/EventService/Subscriptions/1</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>bmc_ip_address</term>
<listitem>
<simpara>is the IP address of the BMC where the Redfish events are generated.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
</section>
<section xml:id="nw-rfhe-creating-hardware-event_using-rfhe">
<title>Creating the bare-metal event and Secret CRs</title>
<simpara>To start using bare-metal events, create the <literal>HardwareEvent</literal> custom resource (CR) for the host where the Redfish hardware is present. Hardware events and faults are reported in the <literal>hw-event-proxy</literal> logs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Bare Metal Event Relay.</simpara>
</listitem>
<listitem>
<simpara>You have created a <literal>BMCEventSubscription</literal> CR for the BMC Redfish hardware.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>HardwareEvent</literal> custom resource (CR):</simpara>
<note>
<simpara>Multiple <literal>HardwareEvent</literal> resources are not permitted.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>hw-event.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "event.redhat-cne.org/v1alpha1"
kind: "HardwareEvent"
metadata:
  name: "hardware-event"
spec:
  nodeSelector:
    node-role.kubernetes.io/hw-event: "" <co xml:id="CO22-1"/>
  logLevel: "debug" <co xml:id="CO22-2"/>
  msgParserTimeout: "10" <co xml:id="CO22-3"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>Required. Use the <literal>nodeSelector</literal> field to target nodes with the specified label, for example, <literal>node-role.kubernetes.io/hw-event: ""</literal>.</para>
<note>
<simpara>In OpenShift Container Platform 4.13 or later, you do not need to set the <literal>spec.transportHost</literal> field in the <literal>HardwareEvent</literal> resource when you use HTTP transport for bare-metal events.
Set <literal>transportHost</literal> only when you use AMQP transport for bare-metal events.</simpara>
</note>
</callout>
<callout arearefs="CO22-2">
<para>Optional. The default value is <literal>debug</literal>. Sets the log level in <literal>hw-event-proxy</literal> logs. The following log levels are available: <literal>fatal</literal>, <literal>error</literal>, <literal>warning</literal>, <literal>info</literal>, <literal>debug</literal>, <literal>trace</literal>.</para>
</callout>
<callout arearefs="CO22-3">
<para>Optional. Sets the timeout value in milliseconds for the Message Parser. If a message parsing request is not responded to within the timeout duration, the original hardware event message is passed to the cloud native event framework. The default value is 10.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the <literal>HardwareEvent</literal> CR in the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hardware-event.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a BMC username and password <literal>Secret</literal> CR that enables the hardware events proxy to access the Redfish message registry for the bare-metal host.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>hw-event-bmc-secret.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: redfish-basic-auth
type: Opaque
stringData: <co xml:id="CO23-1"/>
  username: &lt;bmc_username&gt;
  password: &lt;bmc_password&gt;
  # BMC host DNS or IP address
  hostaddr: &lt;bmc_host_ip_address&gt;</programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Enter plain text values for the various items under <literal>stringData</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Secret</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hw-event-bmc-secret.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/storage/#persistent-storage-using-local-volume">Persistent storage using local volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cnf-rfhe-notifications-api-refererence_using-rfhe">
<title>Subscribing applications to bare-metal events REST API reference</title>
<simpara>Use the bare-metal events REST API to subscribe an application to the bare-metal events that are generated on the parent node.</simpara>
<simpara>Subscribe applications to Redfish events by using the resource address <literal>/cluster/node/&lt;node_name&gt;/redfish/event</literal>, where <literal>&lt;node_name&gt;</literal> is the cluster node running the application.</simpara>
<simpara>Deploy your <literal>cloud-event-consumer</literal> application container and <literal>cloud-event-proxy</literal> sidecar container in a separate application pod. The <literal>cloud-event-consumer</literal> application subscribes to the <literal>cloud-event-proxy</literal> container in the application pod.</simpara>
<simpara>Use the following API endpoints to subscribe the <literal>cloud-event-consumer</literal> application to Redfish events posted by the <literal>cloud-event-proxy</literal> container at <literal>http://localhost:8089/api/ocloudNotifications/v1/</literal> in the application pod:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/api/ocloudNotifications/v1/subscriptions</literal></simpara>
<itemizedlist>
<listitem>
<simpara><literal>POST</literal>: Creates a new subscription</simpara>
</listitem>
<listitem>
<simpara><literal>GET</literal>: Retrieves a list of subscriptions</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>/api/ocloudNotifications/v1/subscriptions/&lt;subscription_id&gt;</literal></simpara>
<itemizedlist>
<listitem>
<simpara><literal>PUT</literal>: Creates a new status ping request for the specified subscription ID</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>/api/ocloudNotifications/v1/health</literal></simpara>
<itemizedlist>
<listitem>
<simpara><literal>GET</literal>: Returns the health status of <literal>ocloudNotifications</literal> API</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara><literal>9089</literal> is the default port for the <literal>cloud-event-consumer</literal> container deployed in the application pod. You can configure a different port for your application as required.</simpara>
</note>
<bridgehead xml:id="_apiocloudnotificationsv1subscriptions" renderas="sect3">api/ocloudNotifications/v1/subscriptions</bridgehead>
<bridgehead xml:id="_http-method" renderas="sect4">HTTP method</bridgehead>
<simpara><literal>GET api/ocloudNotifications/v1/subscriptions</literal></simpara>
<bridgehead xml:id="_description" renderas="sect5">Description</bridgehead>
<simpara>Returns a list of subscriptions. If subscriptions exist, a <literal>200 OK</literal> status code is returned along with the list of subscriptions.</simpara>
<formalpara>
<title>Example API response</title>
<para>
<programlisting language="json" linenumbering="unnumbered">[
 {
  "id": "ca11ab76-86f9-428c-8d3a-666c24e34d32",
  "endpointUri": "http://localhost:9089/api/ocloudNotifications/v1/dummy",
  "uriLocation": "http://localhost:8089/api/ocloudNotifications/v1/subscriptions/ca11ab76-86f9-428c-8d3a-666c24e34d32",
  "resource": "/cluster/node/openshift-worker-0.openshift.example.com/redfish/event"
 }
]</programlisting>
</para>
</formalpara>
<bridgehead xml:id="_http-method-2" renderas="sect4">HTTP method</bridgehead>
<simpara><literal>POST api/ocloudNotifications/v1/subscriptions</literal></simpara>
<bridgehead xml:id="_description-2" renderas="sect5">Description</bridgehead>
<simpara>Creates a new subscription. If a subscription is successfully created, or if it already exists, a <literal>201 Created</literal> status code is returned.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Query parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>subscription</simpara></entry>
<entry align="left" valign="top"><simpara>data</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example payload</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "uriLocation": "http://localhost:8089/api/ocloudNotifications/v1/subscriptions",
  "resource": "/cluster/node/openshift-worker-0.openshift.example.com/redfish/event"
}</programlisting>
</para>
</formalpara>
<bridgehead xml:id="_apiocloudnotificationsv1subscriptionssubscription_id" renderas="sect3">api/ocloudNotifications/v1/subscriptions/&lt;subscription_id&gt;</bridgehead>
<bridgehead xml:id="_http-method-3" renderas="sect4">HTTP method</bridgehead>
<simpara><literal>GET api/ocloudNotifications/v1/subscriptions/&lt;subscription_id&gt;</literal></simpara>
<bridgehead xml:id="_description-3" renderas="sect5">Description</bridgehead>
<simpara>Returns details for the subscription with ID <literal>&lt;subscription_id&gt;</literal></simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Query parameters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;subscription_id&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example API response</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "id":"ca11ab76-86f9-428c-8d3a-666c24e34d32",
  "endpointUri":"http://localhost:9089/api/ocloudNotifications/v1/dummy",
  "uriLocation":"http://localhost:8089/api/ocloudNotifications/v1/subscriptions/ca11ab76-86f9-428c-8d3a-666c24e34d32",
  "resource":"/cluster/node/openshift-worker-0.openshift.example.com/redfish/event"
}</programlisting>
</para>
</formalpara>
<bridgehead xml:id="_apiocloudnotificationsv1health" renderas="sect3">api/ocloudNotifications/v1/health/</bridgehead>
<bridgehead xml:id="_http-method-4" renderas="sect4">HTTP method</bridgehead>
<simpara><literal>GET api/ocloudNotifications/v1/health/</literal></simpara>
<bridgehead xml:id="_description-4" renderas="sect5">Description</bridgehead>
<simpara>Returns the health status for the <literal>ocloudNotifications</literal> REST API.</simpara>
<formalpara>
<title>Example API response</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">OK</programlisting>
</para>
</formalpara>
</section>
<section xml:id="cnf-migrating-from-amqp-to-http-transport_using-rfhe">
<title>Migrating consumer applications to use HTTP transport for PTP or bare-metal events</title>
<simpara>If you have previously deployed PTP or bare-metal events consumer applications, you need to update the applications to use HTTP message transport.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have updated the PTP Operator or Bare Metal Event Relay to version 4.13+ which uses HTTP transport by default.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update your events consumer application to use HTTP transport.
Set the <literal>http-event-publishers</literal> variable for the cloud event sidecar deployment.</simpara>
<simpara>For example, in a cluster with PTP events configured, the following YAML snippet illustrates a cloud event sidecar deployment:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
  - name: cloud-event-sidecar
    image: cloud-event-sidecar
    args:
      - "--metrics-addr=127.0.0.1:9091"
      - "--store-path=/store"
      - "--transport-host=consumer-events-subscription-service.cloud-events.svc.cluster.local:9043"
      - "--http-event-publishers=ptp-event-publisher-service-NODE_NAME.openshift-ptp.svc.cluster.local:9043" <co xml:id="CO24-1"/>
      - "--api-port=8089"</programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>The PTP Operator automatically resolves <literal>NODE_NAME</literal> to the host that is generating the PTP events.
For example, <literal>compute-1.example.com</literal>.</para>
</callout>
</calloutlist>
<simpara>In a cluster with bare-metal events configured, set the <literal>http-event-publishers</literal> field to <literal>hw-event-publisher-service.openshift-bare-metal-events.svc.cluster.local:9043</literal> in the cloud event sidecar deployment CR.</simpara>
</listitem>
<listitem>
<simpara>Deploy the <literal>consumer-events-subscription-service</literal> service alongside the events consumer application.
For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/scrape: "true"
    service.alpha.openshift.io/serving-cert-secret-name: sidecar-consumer-secret
  name: consumer-events-subscription-service
  namespace: cloud-events
  labels:
    app: consumer-service
spec:
  ports:
    - name: sub-port
      port: 9043
  selector:
    app: consumer
  clusterIP: None
  sessionAffinity: None
  type: ClusterIP</programlisting>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="what-huge-pages-do-and-how-they-are-consumed">
<title>What huge pages do and how they are consumed by applications</title>
<section xml:id="what-huge-pages-do_huge-pages">
<title>What huge pages do</title>
<simpara>Memory is managed in blocks known as pages. On most systems, a page is 4Ki. 1Mi
of memory is equal to 256 pages; 1Gi of memory is 256,000 pages, and so on. CPUs
have a built-in memory management unit that manages a list of these pages in
hardware. The Translation Lookaside Buffer (TLB) is a small hardware cache of
virtual-to-physical page mappings. If the virtual address passed in a hardware
instruction can be found in the TLB, the mapping can be determined quickly. If
not, a TLB miss occurs, and the system falls back to slower, software-based
address translation, resulting in performance issues. Since the size of the TLB
is fixed, the only way to reduce the chance of a TLB miss is to increase the
page size.</simpara>
<simpara>A huge page is a memory page that is larger than 4Ki. On x86_64 architectures,
there are two common huge page sizes: 2Mi and 1Gi. Sizes vary on other
architectures. To use huge pages, code must be written so that
applications are aware of them. Transparent Huge Pages (THP) attempt to automate
the management of huge pages without application knowledge, but they have
limitations. In particular, they are limited to 2Mi page sizes. THP can lead to
performance degradation on nodes with high memory utilization or fragmentation
due to defragmenting efforts of THP, which can lock memory pages. For this
reason, some applications may be designed to (or recommend) usage of
pre-allocated huge pages instead of THP.</simpara>
<simpara>In OpenShift Container Platform, applications in a pod can allocate and consume pre-allocated
huge pages.</simpara>
</section>
<section xml:id="how-huge-pages-are-consumed-by-apps_huge-pages">
<title>How huge pages are consumed by apps</title>
<simpara>Nodes must pre-allocate huge pages in order for the node to report its huge page
capacity. A node can only pre-allocate huge pages for a single size.</simpara>
<simpara>Huge pages can be consumed through container-level resource requirements using the
resource name <literal>hugepages-&lt;size&gt;</literal>, where size is the most compact binary
notation using integer values supported on a particular node. For example, if a
node supports 2048KiB page sizes, it exposes a schedulable resource
<literal>hugepages-2Mi</literal>. Unlike CPU or memory, huge pages do not support over-commitment.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  generateName: hugepages-volume-
spec:
  containers:
  - securityContext:
      privileged: true
    image: rhel7:latest
    command:
    - sleep
    - inf
    name: example
    volumeMounts:
    - mountPath: /dev/hugepages
      name: hugepage
    resources:
      limits:
        hugepages-2Mi: 100Mi <co xml:id="CO25-1"/>
        memory: "1Gi"
        cpu: "1"
  volumes:
  - name: hugepage
    emptyDir:
      medium: HugePages</programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>Specify the amount of memory for <literal>hugepages</literal> as the exact amount to be
allocated. Do not specify this value as the amount of memory for <literal>hugepages</literal>
multiplied by the size of the page. For example, given a huge page size of 2MB,
if you want to use 100MB of huge-page-backed RAM for your application, then you
would allocate 50 huge pages. OpenShift Container Platform handles the math for you. As in
the above example, you can specify <literal>100MB</literal> directly.</para>
</callout>
</calloutlist>
<simpara><emphasis role="strong">Allocating huge pages of a specific size</emphasis></simpara>
<simpara>Some platforms support multiple huge page sizes. To allocate huge pages of a
specific size, precede the huge pages boot command parameters with a huge page
size selection parameter <literal>hugepagesz=&lt;size&gt;</literal>. The <literal>&lt;size&gt;</literal> value must be
specified in bytes with an optional scale suffix [<literal>kKmMgG</literal>]. The default huge
page size can be defined with the <literal>default_hugepagesz=&lt;size&gt;</literal> boot parameter.</simpara>
<simpara><emphasis role="strong">Huge page requirements</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Huge page requests must equal the limits. This is the default if limits are
specified, but requests are not.</simpara>
</listitem>
<listitem>
<simpara>Huge pages are isolated at a pod scope. Container isolation is planned in a
future iteration.</simpara>
</listitem>
<listitem>
<simpara><literal>EmptyDir</literal> volumes backed by huge pages must not consume more huge page memory
than the pod request.</simpara>
</listitem>
<listitem>
<simpara>Applications that consume huge pages via <literal>shmget()</literal> with <literal>SHM_HUGETLB</literal> must run
with a supplemental group that matches <emphasis role="strong"><emphasis>proc/sys/vm/hugetlb_shm_group</emphasis></emphasis>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="consuming-huge-pages-resource-using-the-downward-api_huge-pages">
<title>Consuming huge pages resources using the Downward API</title>
<simpara>You can use the Downward API to inject information about the huge pages resources that are consumed by a container.</simpara>
<simpara>You can inject the resource allocation as environment variables, a volume plugin, or both. Applications that you develop and run in the container can determine the resources that are available by reading the environment variables or files in the specified volumes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>hugepages-volume-pod.yaml</literal> file that is similar to the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  generateName: hugepages-volume-
  labels:
    app: hugepages-example
spec:
  containers:
  - securityContext:
      capabilities:
        add: [ "IPC_LOCK" ]
    image: rhel7:latest
    command:
    - sleep
    - inf
    name: example
    volumeMounts:
    - mountPath: /dev/hugepages
      name: hugepage
    - mountPath: /etc/podinfo
      name: podinfo
    resources:
      limits:
        hugepages-1Gi: 2Gi
        memory: "1Gi"
        cpu: "1"
      requests:
        hugepages-1Gi: 2Gi
    env:
    - name: REQUESTS_HUGEPAGES_1GI <co xml:id="CO26-1"/>
      valueFrom:
        resourceFieldRef:
          containerName: example
          resource: requests.hugepages-1Gi
  volumes:
  - name: hugepage
    emptyDir:
      medium: HugePages
  - name: podinfo
    downwardAPI:
      items:
        - path: "hugepages_1G_request" <co xml:id="CO26-2"/>
          resourceFieldRef:
            containerName: example
            resource: requests.hugepages-1Gi
            divisor: 1Gi</programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para>Specifies to read the resource use from <literal>requests.hugepages-1Gi</literal> and expose the value as the <literal>REQUESTS_HUGEPAGES_1GI</literal> environment variable.</para>
</callout>
<callout arearefs="CO26-2">
<para>Specifies to read the resource use from <literal>requests.hugepages-1Gi</literal> and expose the value as the file <literal>/etc/podinfo/hugepages_1G_request</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>hugepages-volume-pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hugepages-volume-pod.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the value of the <literal>REQUESTS_HUGEPAGES_1GI</literal> environment variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it $(oc get pods -l app=hugepages-example -o jsonpath='{.items[0].metadata.name}') \
     -- env | grep REQUESTS_HUGEPAGES_1GI</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">REQUESTS_HUGEPAGES_1GI=2147483648</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the value of the <literal>/etc/podinfo/hugepages_1G_request</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it $(oc get pods -l app=hugepages-example -o jsonpath='{.items[0].metadata.name}') \
     -- cat /etc/podinfo/hugepages_1G_request</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-containers-downward-api">Allowing containers to consume Downward API objects</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-huge-pages_huge-pages">
<title>Configuring huge pages at boot time</title>
<simpara>Nodes must pre-allocate huge pages used in an OpenShift Container Platform cluster. There are two ways of reserving huge pages: at boot time and at run time. Reserving at boot time increases the possibility of success because the memory has not yet been significantly fragmented. The Node Tuning Operator currently supports boot time allocation of huge pages on specific nodes.</simpara>
<formalpara>
<title>Procedure</title>
<para>To minimize node reboots, the order of the steps below needs to be followed:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Label all nodes that need the same huge pages setting by a label.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node_using_hugepages&gt; node-role.kubernetes.io/worker-hp=</programlisting>
</listitem>
<listitem>
<simpara>Create a file with the following content and name it <literal>hugepages-tuned-boottime.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: hugepages <co xml:id="CO27-1"/>
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile: <co xml:id="CO27-2"/>
  - data: |
      [main]
      summary=Boot time configuration for hugepages
      include=openshift-node
      [bootloader]
      cmdline_openshift_node_hugepages=hugepagesz=2M hugepages=50 <co xml:id="CO27-3"/>
    name: openshift-node-hugepages

  recommend:
  - machineConfigLabels: <co xml:id="CO27-4"/>
      machineconfiguration.openshift.io/role: "worker-hp"
    priority: 30
    profile: openshift-node-hugepages</programlisting>
<calloutlist>
<callout arearefs="CO27-1">
<para>Set the <literal>name</literal> of the Tuned resource to <literal>hugepages</literal>.</para>
</callout>
<callout arearefs="CO27-2">
<para>Set the <literal>profile</literal> section to allocate huge pages.</para>
</callout>
<callout arearefs="CO27-3">
<para>Note the order of parameters is important as some platforms support huge pages of various sizes.</para>
</callout>
<callout arearefs="CO27-4">
<para>Enable machine config pool based matching.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the Tuned <literal>hugepages</literal> object</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hugepages-tuned-boottime.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a file with the following content and name it <literal>hugepages-mcp.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: worker-hp
  labels:
    worker-hp: ""
spec:
  machineConfigSelector:
    matchExpressions:
      - {key: machineconfiguration.openshift.io/role, operator: In, values: [worker,worker-hp]}
  nodeSelector:
    matchLabels:
      node-role.kubernetes.io/worker-hp: ""</programlisting>
</listitem>
<listitem>
<simpara>Create the machine config pool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hugepages-mcp.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>Given enough non-fragmented memory, all the nodes in the <literal>worker-hp</literal> machine config pool should now have 50 2Mi huge pages allocated.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node &lt;node_using_hugepages&gt; -o jsonpath="{.status.allocatable.hugepages-2Mi}"
100Mi</programlisting>
<note>
<simpara>The TuneD bootloader plugin only supports Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes.</simpara>
</note>
</section>
<section xml:id="disable-thp_huge-pages">
<title>Disabling Transparent Huge Pages</title>
<simpara>Transparent Huge Pages (THP) attempt to automate most aspects of creating, managing, and using huge pages. Since THP automatically manages the huge pages, this is not always handled optimally for all types of workloads. THP can lead to performance regressions, since many applications handle huge pages on their own. Therefore, consider disabling THP. The following steps describe how to disable THP using the Node Tuning Operator (NTO).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file with the following content and name it <literal>thp-disable-tuned.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: thp-workers-profile
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Custom tuned profile for OpenShift to turn off THP on worker nodes
      include=openshift-node

      [vm]
      transparent_hugepages=never
    name: openshift-thp-never-worker

  recommend:
  - match:
    - label: node-role.kubernetes.io/worker
    priority: 25
    profile: openshift-thp-never-worker</programlisting>
</listitem>
<listitem>
<simpara>Create the Tuned object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f thp-disable-tuned.yaml</programlisting>
</listitem>
<listitem>
<simpara>Check the list of active profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get profile -n openshift-cluster-node-tuning-operator</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Log in to one of the nodes and do a regular THP check to verify if the nodes applied the profile successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /sys/kernel/mm/transparent_hugepage/enabled</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">always madvise [never]</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="cnf-low-latency-tuning">
<title>Low latency tuning</title>
<section xml:id="cnf-understanding-low-latency_cnf-master">
<title>Understanding low latency</title>
<simpara>The emergence of Edge computing in the area of Telco / 5G plays a key role in reducing latency and congestion problems and improving application performance.</simpara>
<simpara>Simply put, latency determines how fast data (packets) moves from the sender to receiver and returns to the sender after processing by the receiver. Maintaining a network architecture with the lowest possible delay of latency speeds is key for meeting the network performance requirements of 5G. Compared to 4G technology, with an average latency of 50 ms, 5G is targeted to reach latency numbers of 1 ms or less. This reduction in latency boosts wireless throughput by a factor of 10.</simpara>
<simpara>Many of the deployed applications in the Telco space require low latency that can only tolerate zero packet loss. Tuning for zero packet loss helps mitigate the inherent issues that degrade network performance. For more information, see <link xlink:href="https://www.redhat.com/en/blog/tuning-zero-packet-loss-red-hat-openstack-platform-part-1">Tuning for Zero Packet Loss in Red Hat OpenStack Platform (RHOSP)</link>.</simpara>
<simpara>The Edge computing initiative also comes in to play for reducing latency rates. Think of it as being on the edge of the cloud and closer to the user. This greatly reduces the distance between the user and distant data centers, resulting in reduced application response times and performance latency.</simpara>
<simpara>Administrators must be able to manage their many Edge sites and local services in a centralized way so that all of the deployments can run at the lowest possible management cost. They also need an easy way to deploy and configure certain nodes of their cluster for real-time low latency and high-performance purposes. Low latency nodes are useful for applications such as Cloud-native Network Functions (CNF) and Data Plane Development Kit (DPDK).</simpara>
<simpara>OpenShift Container Platform currently provides mechanisms to tune software on an OpenShift Container Platform cluster for real-time running and low latency (around &lt;20 microseconds reaction time). This includes tuning the kernel and OpenShift Container Platform set values, installing a kernel, and reconfiguring the machine. But this method requires setting up four different Operators and performing many configurations that, when done manually, is complex and could be prone to mistakes.</simpara>
<simpara>OpenShift Container Platform uses the Node Tuning Operator to implement automatic tuning to achieve low latency performance for OpenShift Container Platform applications. The cluster administrator uses this performance profile configuration that makes it easier to make these changes in a more reliable way. The administrator can specify whether to update the kernel to kernel-rt, reserve CPUs for cluster and operating system housekeeping duties, including pod infra containers, and isolate CPUs for application containers to run the workloads.</simpara>
<important>
<simpara>In OpenShift Container Platform 4.14, if you apply a performance profile to your cluster, all nodes in the cluster will reboot. This reboot includes control plane nodes and worker nodes that were not targeted by the performance profile. This is a known issue in OpenShift Container Platform 4.14 because this release uses Linux control group version 2 (cgroup v2) in alignment with RHEL 9. The low latency tuning features associated with the performance profile do not support cgroup v2, therefore the nodes reboot to switch back to the cgroup v1 configuration.</simpara>
<simpara>To revert all nodes in the cluster to the cgroups v2 configuration, you must edit the <literal>Node</literal> resource. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-16976"><emphasis role="strong">OCPBUGS-16976</emphasis></link>)</simpara>
</important>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<simpara>OpenShift Container Platform also supports workload hints for the Node Tuning Operator that can tune the <literal>PerformanceProfile</literal> to meet the demands of different industry environments. Workload hints are available for <literal>highPowerConsumption</literal> (very low latency at the cost of increased power consumption) and <literal>realTime</literal> (priority given to optimum latency). A combination of <literal>true/false</literal> settings for these hints can be used to deal with application-specific workload profiles and requirements.</simpara>
<simpara>Workload hints simplify the fine-tuning of performance to industry sector settings. Instead of a one size fits all approach, workload hints can cater to usage patterns such as placing priority on:</simpara>
<itemizedlist>
<listitem>
<simpara>Low latency</simpara>
</listitem>
<listitem>
<simpara>Real-time capability</simpara>
</listitem>
<listitem>
<simpara>Efficient use of power</simpara>
</listitem>
</itemizedlist>
<simpara>In an ideal world, all of those would be prioritized: in real life, some come at the expense of others. The Node Tuning Operator is now aware of the workload expectations and better able to meet the demands of the workload. The cluster admin can now specify into which use case that workload falls. The Node Tuning Operator uses the <literal>PerformanceProfile</literal> to fine tune the performance settings for the workload.</simpara>
<simpara>The environment in which an application is operating influences its behavior. For a typical data center with no strict latency requirements, only minimal default tuning is needed that enables CPU partitioning for some high performance workload pods. For data centers and workloads where latency is a higher priority, measures are still taken to optimize power consumption. The most complicated cases are clusters close to latency-sensitive equipment such as manufacturing machinery and software-defined radios. This last class of deployment is often referred to as Far edge. For Far edge deployments, ultra-low latency is the ultimate priority, and is achieved at the expense of power management.</simpara>
<section xml:id="about_hyperthreading_for_low_latency_and_real_time_applications_cnf-master">
<title>About hyperthreading for low latency and real-time applications</title>
<simpara>Hyperthreading is an Intel processor technology that allows a physical CPU processor core to function as two logical cores, executing two independent threads simultaneously. Hyperthreading allows for better system throughput for certain workload types where parallel processing is beneficial. The default OpenShift Container Platform configuration expects hyperthreading to be enabled by default.</simpara>
<simpara>For telecommunications applications, it is important to design your application infrastructure to minimize latency as much as possible. Hyperthreading can slow performance times and negatively affect throughput for compute intensive workloads that require low latency. Disabling hyperthreading ensures predictable performance and can decrease processing times for these workloads.</simpara>
<note>
<simpara>Hyperthreading implementation and configuration differs depending on the hardware you are running OpenShift Container Platform on. Consult the relevant host hardware tuning information for more details of the hyperthreading implementation specific to that hardware. Disabling hyperthreading can increase the cost per core of the cluster.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../scalability_and_performance/cnf-low-latency-tuning.xml#configuring_hyperthreading_for_a_cluster_cnf-master">Configuring hyperthreading for a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cnf-provisioning-real-time-and-low-latency-workloads_cnf-master">
<title>Provisioning real-time and low latency workloads</title>
<simpara>Many industries and organizations need extremely high performance computing and might require low and predictable latency, especially in the financial and telecommunications industries. For these industries, with their unique requirements, OpenShift Container Platform provides the Node Tuning Operator to implement automatic tuning to achieve low latency performance and consistent response time for OpenShift Container Platform applications.</simpara>
<simpara>The cluster administrator can use this performance profile configuration to make these changes in a more reliable way. The administrator can specify whether to update the kernel to kernel-rt (real-time), reserve CPUs for cluster and operating system housekeeping duties, including pod infra containers, isolate CPUs for application containers to run the workloads, and disable unused CPUs to reduce power consumption.</simpara>
<warning>
<simpara>The usage of execution probes in conjunction with applications that require guaranteed CPUs can cause latency spikes. It is recommended to use other probes, such as a properly configured set of network probes, as an alternative.</simpara>
</warning>
<note>
<simpara>In earlier versions of OpenShift Container Platform, the Performance Addon Operator was used to implement automatic tuning to achieve low latency performance for OpenShift applications. In OpenShift Container Platform 4.11 and later, these functions are part of the Node Tuning Operator.</simpara>
</note>
<section xml:id="node-tuning-operator-known-limitations-for-real-time_cnf-master">
<title>Known limitations for real-time</title>
<note>
<simpara>In most deployments, kernel-rt is supported only on worker nodes when you use a standard cluster with three control plane nodes and three worker nodes. There are exceptions for compact and single nodes on OpenShift Container Platform deployments. For installations on a single node, kernel-rt is supported on the single control plane node.</simpara>
</note>
<simpara>To fully utilize the real-time mode, the containers must run with elevated privileges.
See <link xlink:href="https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-capabilities-for-a-container">Set capabilities for a Container</link> for information on granting privileges.</simpara>
<simpara>OpenShift Container Platform restricts the allowed capabilities, so you might need to create a <literal>SecurityContext</literal> as well.</simpara>
<note>
<simpara>This procedure is fully supported with bare metal installations using Red Hat Enterprise Linux CoreOS (RHCOS) systems.</simpara>
</note>
<simpara>Establishing the right performance expectations refers to the fact that the real-time kernel is not a panacea. Its objective is consistent, low-latency determinism offering predictable response times. There is some additional kernel overhead associated with the real-time kernel. This is due primarily to handling hardware interruptions in separately scheduled threads. The increased overhead in some workloads results in some degradation in overall throughput. The exact amount of degradation is very workload dependent, ranging from 0% to 30%. However, it is the cost of determinism.</simpara>
</section>
<section xml:id="node-tuning-operator-provisioning-worker-with-real-time-capabilities_cnf-master">
<title>Provisioning a worker with real-time capabilities</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Optional: Add a node to the OpenShift Container Platform cluster.
See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html/optimizing_rhel_8_for_real_time_for_low_latency_operation/setting-bios-parameters-for-system-tuning_optimizing-rhel8-for-real-time-for-low-latency-operation">Setting BIOS parameters for system tuning</link>.</simpara>
</listitem>
<listitem>
<simpara>Add the label <literal>worker-rt</literal> to the worker nodes that require the real-time capability by using the <literal>oc</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Create a new machine config pool for real-time nodes:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: worker-rt
  labels:
    machineconfiguration.openshift.io/role: worker-rt
spec:
  machineConfigSelector:
    matchExpressions:
      - {
           key: machineconfiguration.openshift.io/role,
           operator: In,
           values: [worker, worker-rt],
        }
  paused: false
  nodeSelector:
    matchLabels:
      node-role.kubernetes.io/worker-rt: ""</programlisting>
<simpara>Note that a machine config pool worker-rt is created for group of nodes that have the label <literal>worker-rt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the node to the proper machine config pool by using node role labels.</simpara>
<note>
<simpara>You must decide which nodes are configured with real-time workloads. You could configure all of the nodes in the cluster, or a subset of the nodes. The Node Tuning Operator that expects all of the nodes are part of a dedicated machine config pool. If you use all of the nodes, you must point the Node Tuning Operator to the worker node role label. If you use a subset, you must group the nodes into a new machine config pool.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the <literal>PerformanceProfile</literal> with the proper set of housekeeping cores and <literal>realTimeKernel: enabled: true</literal>.</simpara>
</listitem>
<listitem>
<simpara>You must set <literal>machineConfigPoolSelector</literal> in <literal>PerformanceProfile</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: performance.openshift.io/v2
  kind: PerformanceProfile
  metadata:
   name: example-performanceprofile
  spec:
  ...
    realTimeKernel:
      enabled: true
    nodeSelector:
       node-role.kubernetes.io/worker-rt: ""
    machineConfigPoolSelector:
       machineconfiguration.openshift.io/role: worker-rt</programlisting>
</listitem>
<listitem>
<simpara>Verify that a matching machine config pool exists with a label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe mcp/worker-rt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">Name:         worker-rt
Namespace:
Labels:       machineconfiguration.openshift.io/role=worker-rt</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>OpenShift Container Platform will start configuring the nodes, which might involve multiple reboots. Wait for the nodes to settle. This can take a long time depending on the specific hardware you use, but 20 minutes per node is expected.</simpara>
</listitem>
<listitem>
<simpara>Verify everything is working as expected.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="node-tuning-operator-verifying-real-time-kernel-installation_cnf-master">
<title>Verifying the real-time kernel installation</title>
<simpara>Use this command to verify that the real-time kernel is installed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node -o wide</programlisting>
<simpara>Note the worker with the role <literal>worker-rt</literal> that contains the string <literal>4.18.0-305.30.1.rt7.102.el8_4.x86_64   cri-o://1.28.5-99.rhaos4.10.gitc3131de.el8</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                               	STATUS   ROLES           	AGE 	VERSION                  	INTERNAL-IP
EXTERNAL-IP   OS-IMAGE                                       	KERNEL-VERSION
CONTAINER-RUNTIME
rt-worker-0.example.com	          Ready	 worker,worker-rt   5d17h   v1.28.5
128.66.135.107   &lt;none&gt;    	        Red Hat Enterprise Linux CoreOS 46.82.202008252340-0 (Ootpa)
4.18.0-305.30.1.rt7.102.el8_4.x86_64   cri-o://1.28.5-99.rhaos4.10.gitc3131de.el8
[...]</programlisting>
</section>
<section xml:id="node-tuning-operator-creating-workload-that-works-in-real-time_cnf-master">
<title>Creating a workload that works in real-time</title>
<simpara>Use the following procedures for preparing a workload that will use real-time capabilities.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod with a QoS class of <literal>Guaranteed</literal>.</simpara>
</listitem>
<listitem>
<simpara>Optional: Disable CPU load balancing for DPDK.</simpara>
</listitem>
<listitem>
<simpara>Assign a proper node selector.</simpara>
</listitem>
</orderedlist>
<simpara>When writing your applications, follow the general recommendations described in
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index#chap-Application_Tuning_and_Deployment">Application tuning and deployment</link>.</simpara>
</section>
<section xml:id="node-tuning-operator-creating-pod-with-guaranteed-qos-class_cnf-master">
<title>Creating a pod with a QoS class of <literal>Guaranteed</literal></title>
<simpara>Keep the following in mind when you create a pod that is given a QoS class of <literal>Guaranteed</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Every container in the pod must have a memory limit and a memory request, and they must be the same.</simpara>
</listitem>
<listitem>
<simpara>Every container in the pod must have a CPU limit and a CPU request, and they must be the same.</simpara>
</listitem>
</itemizedlist>
<simpara>The following example shows the configuration file for a pod that has one container. The container has a memory limit and a memory request, both equal to 200 MiB. The container has a CPU limit and a CPU request, both equal to 1 CPU.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: qos-demo
  namespace: qos-example
spec:
  containers:
  - name: qos-demo-ctr
    image: &lt;image-pull-spec&gt;
    resources:
      limits:
        memory: "200Mi"
        cpu: "1"
      requests:
        memory: "200Mi"
        cpu: "1"</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc  apply -f qos-pod.yaml --namespace=qos-example</programlisting>
</listitem>
<listitem>
<simpara>View detailed information about the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod qos-demo --namespace=qos-example --output=yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers:
    ...
status:
  qosClass: Guaranteed</programlisting>
</para>
</formalpara>
<note>
<simpara>If a container specifies its own memory limit, but does not specify a memory request, OpenShift Container Platform automatically assigns a memory request that matches the limit. Similarly, if a container specifies its own CPU limit, but does not specify a CPU request, OpenShift Container Platform automatically assigns a CPU request that matches the limit.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="node-tuning-operator-disabling-cpu-load-balancing-for-dpdk_cnf-master">
<title>Optional: Disabling CPU load balancing for DPDK</title>
<simpara>Functionality to disable or enable CPU load balancing is implemented on the CRI-O level. The code under the CRI-O disables or enables CPU load balancing only when the following requirements are met.</simpara>
<itemizedlist>
<listitem>
<simpara>The pod must use the <literal>performance-&lt;profile-name&gt;</literal> runtime class. You can get the proper name by looking at the status of the performance profile, as shown here:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
...
status:
  ...
  runtimeClass: performance-manual</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>Currently, disabling CPU load balancing is not supported with cgroup v2.</simpara>
</note>
<simpara>The Node Tuning Operator is responsible for the creation of the high-performance runtime handler config snippet under relevant nodes and for creation of the high-performance runtime class under the cluster. It will have the same content as default runtime handler except it enables the CPU load balancing configuration functionality.</simpara>
<simpara>To disable the CPU load balancing for the pod, the <literal>Pod</literal> specification must include the following fields:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  ...
  annotations:
    ...
    cpu-load-balancing.crio.io: "disable"
    ...
  ...
spec:
  ...
  runtimeClassName: performance-&lt;profile_name&gt;
  ...</programlisting>
<note>
<simpara>Only disable CPU load balancing when the CPU manager static policy is enabled and for pods with guaranteed QoS that use whole CPUs. Otherwise, disabling CPU load balancing can affect the performance of other containers in the cluster.</simpara>
</note>
</section>
<section xml:id="node-tuning-operator-assigning-proper-node-selector_cnf-master">
<title>Assigning a proper node selector</title>
<simpara>The preferred way to assign a pod to nodes is to use the same node selector the performance profile used, as shown here:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: example
spec:
  # ...
  nodeSelector:
    node-role.kubernetes.io/worker-rt: ""</programlisting>
<simpara>For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.5/html-single/nodes/index#nodes-scheduler-node-selectors">Placing pods on specific nodes using node selectors</link>.</simpara>
</section>
<section xml:id="node-tuning-operator-scheduling-workload-onto-worker-with-real-time-capabilities_cnf-master">
<title>Scheduling a workload onto a worker with real-time capabilities</title>
<simpara>Use label selectors that match the nodes attached to the machine config pool that was configured for low latency by the Node Tuning Operator. For more information, see <link xlink:href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/">Assigning pods to nodes</link>.</simpara>
</section>
<section xml:id="node-tuning-operator-disabling-CPUs-for-power-consumption_cnf-master">
<title>Reducing power consumption by taking CPUs offline</title>
<simpara>You can generally anticipate telecommunication workloads. When not all of the CPU resources are required, the Node Tuning Operator allows you take unused CPUs offline to reduce power consumption by manually updating the performance profile.</simpara>
<simpara>To take unused CPUs offline, you must perform the following tasks:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Set the offline CPUs in the performance profile and save the contents of the YAML file:</simpara>
<formalpara>
<title>Example performance profile with offlined CPUs</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: performance
spec:
  additionalKernelArgs:
  - nmi_watchdog=0
  - audit=0
  - mce=off
  - processor.max_cstate=1
  - intel_idle.max_cstate=0
  - idle=poll
  cpu:
    isolated: "2-23,26-47"
    reserved: "0,1,24,25"
    offlined: 48-59 <co xml:id="CO28-1"/>
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""
  numa:
    topologyPolicy: single-numa-node
  realTimeKernel:
    enabled: true</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO28-1">
<para>Optional. You can list CPUs in the <literal>offlined</literal> field to take the specified CPUs offline.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the updated profile by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f my-performance-profile.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="node-tuning-operator-pod-power-saving-config_cnf-master">
<title>Optional: Power saving configurations</title>
<simpara>You can enable power savings for a node that has low priority workloads that are colocated with high priority workloads without impacting the latency or throughput of the high priority workloads. Power saving is possible without modifications to the workloads themselves.</simpara>
<important>
<simpara>The feature is supported on Intel Ice Lake and later generations of Intel CPUs. The capabilities of the processor might impact the latency and throughput of the high priority workloads.</simpara>
</important>
<simpara>When you configure a node with a power saving configuration, you must configure high priority workloads with performance configuration at the pod level, which means that the configuration applies to all the cores used by the pod.</simpara>
<simpara>By disabling P-states and C-states at the pod level, you can configure high priority workloads for best performance and lowest latency.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration for high priority workloads</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="50.0001*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Possible Values</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cpu-c-states.crio.io:</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>"enable"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"disable"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>"max_latency:microseconds"</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>This annotation allows you to enable or disable C-states for each CPU. Alternatively, you can also specify a maximum latency in microseconds for the C-states. For example, enable C-states with a maximum latency of 10 microseconds with the setting <literal>cpu-c-states.crio.io</literal>: <literal>"max_latency:10"</literal>. Set the value to <literal>"disable"</literal> to provide the best performance for a pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cpu-freq-governor.crio.io:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any supported <literal>cpufreq governor</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the <literal>cpufreq</literal> governor for each CPU. The <literal>"performance"</literal> governor is recommended for high priority workloads.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You enabled C-states and OS-controlled P-states in the BIOS</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Generate a <literal>PerformanceProfile</literal> with <literal>per-pod-power-management</literal> set to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --entrypoint performance-profile-creator -v \
/must-gather:/must-gather:z registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14 \
--mcp-name=worker-cnf --reserved-cpu-count=20 --rt-kernel=true \
--split-reserved-cpus-across-numa=false --topology-manager-policy=single-numa-node \
--must-gather-dir-path /must-gather -power-consumption-mode=low-latency \ <co xml:id="CO29-1"/>
--per-pod-power-management=true &gt; my-performance-profile.yaml</programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>The <literal>power-consumption-mode</literal> must be <literal>default</literal> or <literal>low-latency</literal> when the <literal>per-pod-power-management</literal> is set to <literal>true</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example <literal>PerformanceProfile</literal> with <literal>perPodPowerManagement</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
     name: performance
spec:
    [.....]
    workloadHints:
        realTime: true
        highPowerConsumption: false
        perPodPowerManagement: true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set the default <literal>cpufreq</literal> governor as an additional kernel argument in the <literal>PerformanceProfile</literal> custom resource (CR):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
     name: performance
spec:
    ...
    additionalKernelArgs:
    - cpufreq.default_governor=schedutil <co xml:id="CO30-1"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>Using the <literal>schedutil</literal> governor is recommended, however, you can use other governors such as the <literal>ondemand</literal> or <literal>powersave</literal> governors.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Set the maximum CPU frequency in the <literal>TunedPerformancePatch</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  profile:
  - data: |
      [sysfs]
      /sys/devices/system/cpu/intel_pstate/max_perf_pct = &lt;x&gt; <co xml:id="CO31-1"/></programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>The <literal>max_perf_pct</literal> controls the maximum frequency the <literal>cpufreq</literal> driver is allowed to set as a percentage of the maximum supported cpu frequency. This value applies to all CPUs. You can check the maximum supported frequency in <literal>/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq</literal>. As a starting point, you can use a percentage that caps all CPUs at the <literal>All Cores Turbo</literal> frequency. The <literal>All Cores Turbo</literal> frequency is the frequency that all cores will run at when the cores are all fully occupied.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the desired annotations to your high priority workload pods. The annotations override the <literal>default</literal> settings.</simpara>
<formalpara>
<title>Example high priority workload annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  ...
  annotations:
    ...
    cpu-c-states.crio.io: "disable"
    cpu-freq-governor.crio.io: "performance"
    ...
  ...
spec:
  ...
  runtimeClassName: performance-&lt;profile_name&gt;
  ...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Restart the pods.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about recommended firmware configuration, see <link linkend="ztp-du-firmware-config-reference_vdu-config-ref">Recommended firmware configuration for vDU cluster hosts</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="managing-device-interrupt-processing-for-guaranteed-pod-isolated-cpus_cnf-master">
<title>Managing device interrupt processing for guaranteed pod isolated CPUs</title>
<simpara>The Node Tuning Operator can manage host CPUs by dividing them into reserved CPUs for cluster and operating system housekeeping duties, including pod infra containers, and isolated CPUs for application containers to run the workloads. This allows you to set CPUs for low latency workloads as isolated.</simpara>
<simpara>Device interrupts are load balanced between all isolated and reserved CPUs to avoid CPUs being overloaded, with the exception of CPUs where there is a guaranteed pod running. Guaranteed pod CPUs are prevented from processing device interrupts when the relevant annotations are set for the pod.</simpara>
<simpara>In the performance profile, <literal>globallyDisableIrqLoadBalancing</literal> is used to manage whether device interrupts are processed or not. For certain workloads, the reserved CPUs are not always sufficient for dealing with device interrupts, and for this reason, device interrupts are not globally disabled on the isolated CPUs. By default, Node Tuning Operator does not disable device interrupts on isolated CPUs.</simpara>
<simpara>To achieve low latency for workloads, some (but not all) pods require the CPUs they are running on to not process device interrupts. A pod annotation, <literal>irq-load-balancing.crio.io</literal>, is used to define whether device interrupts are processed or not. When configured, CRI-O disables device interrupts only as long as the pod is running.</simpara>
<section xml:id="disabling-cpu-cfs-quota_cnf-master">
<title>Disabling CPU CFS quota</title>
<simpara>To reduce CPU throttling for individual guaranteed pods, create a pod specification with the annotation <literal>cpu-quota.crio.io: "disable"</literal>. This annotation disables the CPU completely fair scheduler (CFS) quota at the pod run time. The following pod specification contains this annotation:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  annotations:
      cpu-quota.crio.io: "disable"
spec:
    runtimeClassName: performance-&lt;profile_name&gt;
...</programlisting>
<note>
<simpara>Only disable CPU CFS quota when the CPU manager static policy is enabled and for pods with guaranteed QoS that use whole CPUs. Otherwise, disabling CPU CFS quota can affect the performance of other containers in the cluster.</simpara>
</note>
</section>
<section xml:id="configuring-global-device-interrupts-handling-for-isolated-cpus_cnf-master">
<title>Disabling global device interrupts handling in Node Tuning Operator</title>
<simpara>To configure Node Tuning Operator to disable global device interrupts for the isolated CPU set, set the <literal>globallyDisableIrqLoadBalancing</literal> field in the performance profile to <literal>true</literal>. When <literal>true</literal>, conflicting pod annotations are ignored. When <literal>false</literal>, IRQ loads are balanced across all CPUs.</simpara>
<simpara>A performance profile snippet illustrates this setting:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  globallyDisableIrqLoadBalancing: true
...</programlisting>
</section>
<section xml:id="disabling_interrupt_processing_for_individual_pods_cnf-master">
<title>Disabling interrupt processing for individual pods</title>
<simpara>To disable interrupt processing for individual pods, ensure that <literal>globallyDisableIrqLoadBalancing</literal> is set to <literal>false</literal> in the performance profile. Then, in the pod specification, set the <literal>irq-load-balancing.crio.io</literal> pod annotation to <literal>disable</literal>. The following pod specification contains this annotation:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: Pod
metadata:
  annotations:
      irq-load-balancing.crio.io: "disable"
spec:
    runtimeClassName: performance-&lt;profile_name&gt;
...</programlisting>
</section>
</section>
<section xml:id="use-device-interrupt-processing-for-isolated-cpus_cnf-master">
<title>Upgrading the performance profile to use device interrupt processing</title>
<simpara>When you upgrade the Node Tuning Operator performance profile custom resource definition (CRD) from v1 or v1alpha1 to v2, <literal>globallyDisableIrqLoadBalancing</literal> is set to <literal>true</literal> on existing profiles.</simpara>
<note>
<simpara><literal>globallyDisableIrqLoadBalancing</literal> toggles whether IRQ load balancing will be disabled for the Isolated CPU set. When the option is set to <literal>true</literal> it disables IRQ load balancing for the Isolated CPU set. Setting the option to <literal>false</literal> allows the IRQs to be balanced across all CPUs.</simpara>
</note>
<section xml:id="nto_supported_api_versions_cnf-master">
<title>Supported API Versions</title>
<simpara>The Node Tuning Operator supports <literal>v2</literal>, <literal>v1</literal>, and <literal>v1alpha1</literal> for the performance profile <literal>apiVersion</literal> field. The v1 and v1alpha1 APIs are identical. The v2 API includes an optional boolean field <literal>globallyDisableIrqLoadBalancing</literal> with a default value of <literal>false</literal>.</simpara>
<section xml:id="upgrading_nto_api_from_v1alpha1_to_v1_cnf-master">
<title>Upgrading Node Tuning Operator API from v1alpha1 to v1</title>
<simpara>When upgrading Node Tuning Operator API version from v1alpha1 to v1, the v1alpha1 performance profiles are converted on-the-fly using a "None" Conversion strategy and served to the Node Tuning Operator with API version v1.</simpara>
</section>
<section xml:id="upgrading_nto_api_from_v1alpha1_to_v1_or_v2_cnf-master">
<title>Upgrading Node Tuning Operator API from v1alpha1 or v1 to v2</title>
<simpara>When upgrading from an older Node Tuning Operator API version, the existing v1 and v1alpha1 performance profiles are converted using a conversion webhook that injects the <literal>globallyDisableIrqLoadBalancing</literal> field with a value of <literal>true</literal>.</simpara>
</section>
</section>
</section>
</section>
<section xml:id="cnf-tuning-nodes-for-low-latency-via-performanceprofile_cnf-master">
<title>Tuning nodes for low latency with the performance profile</title>
<simpara>The performance profile lets you control latency tuning aspects of nodes that belong to a certain machine config pool. After you specify your settings, the <literal>PerformanceProfile</literal> object is compiled into multiple objects that perform the actual node level tuning:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>MachineConfig</literal> file that manipulates the nodes.</simpara>
</listitem>
<listitem>
<simpara>A <literal>KubeletConfig</literal> file that configures the Topology Manager, the CPU Manager, and the OpenShift Container Platform nodes.</simpara>
</listitem>
<listitem>
<simpara>The Tuned profile that configures the Node Tuning Operator.</simpara>
</listitem>
</itemizedlist>
<simpara>You can use a performance profile to specify whether to update the kernel to kernel-rt, to allocate huge pages, and to partition the CPUs for performing housekeeping duties or running workloads.</simpara>
<important>
<simpara>In OpenShift Container Platform 4.14, if you apply a performance profile to your cluster, all nodes in the cluster will reboot. This reboot includes control plane nodes and worker nodes that were not targeted by the performance profile. This is a known issue in OpenShift Container Platform 4.14 because this release uses Linux control group version 2 (cgroup v2) in alignment with RHEL 9. The low latency tuning features associated with the performance profile do not support cgroup v2, therefore the nodes reboot to switch back to the cgroup v1 configuration.</simpara>
<simpara>To revert all nodes in the cluster to the cgroups v2 configuration, you must edit the <literal>Node</literal> resource. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-16976"><emphasis role="strong">OCPBUGS-16976</emphasis></link>)</simpara>
</important>
<note>
<simpara>You can manually create the <literal>PerformanceProfile</literal> object or use the Performance Profile Creator (PPC) to generate a performance profile. See the additional resources below for more information on the PPC.</simpara>
</note>
<formalpara>
<title>Sample performance profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
 name: performance
spec:
 cpu:
  isolated: "4-15" <co xml:id="CO32-1"/>
  reserved: "0-3" <co xml:id="CO32-2"/>
 hugepages:
  defaultHugepagesSize: "1G"
  pages:
  - size: "1G"
    count: 16
    node: 0
 realTimeKernel:
  enabled: true  <co xml:id="CO32-3"/>
 numa:  <co xml:id="CO32-4"/>
  topologyPolicy: "best-effort"
 nodeSelector:
  node-role.kubernetes.io/worker-cnf: "" <co xml:id="CO32-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO32-1">
<para>Use this field to isolate specific CPUs to use with application containers for workloads. Set an even number of isolated CPUs to enable the pods to run without errors when hyperthreading is enabled.</para>
</callout>
<callout arearefs="CO32-2">
<para>Use this field to reserve specific CPUs to use with infra containers for housekeeping.</para>
</callout>
<callout arearefs="CO32-3">
<para>Use this field to install the real-time kernel on the node. Valid values are <literal>true</literal> or <literal>false</literal>. Setting the <literal>true</literal> value installs the real-time kernel.</para>
</callout>
<callout arearefs="CO32-4">
<para>Use this field to configure the topology manager policy. Valid values are <literal>none</literal> (default), <literal>best-effort</literal>, <literal>restricted</literal>, and <literal>single-numa-node</literal>. For more information, see <link xlink:href="https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/#topology-manager-policies">Topology Manager Policies</link>.</para>
</callout>
<callout arearefs="CO32-5">
<para>Use this field to specify a node selector to apply the performance profile to specific nodes.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information on using the Performance Profile Creator (PPC) to generate a performance profile, see <link linkend="cnf-create-performance-profiles">Creating a performance profile</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cnf-configuring-huge-pages_cnf-master">
<title>Configuring huge pages</title>
<simpara>Nodes must pre-allocate huge pages used in an OpenShift Container Platform cluster. Use the Node Tuning Operator to allocate huge pages on a specific node.</simpara>
<simpara>OpenShift Container Platform provides a method for creating and allocating huge pages. Node Tuning Operator provides an easier method for doing  this using the performance profile.</simpara>
<simpara>For example, in the <literal>hugepages</literal> <literal>pages</literal> section of the performance profile, you can specify multiple blocks of <literal>size</literal>, <literal>count</literal>, and, optionally, <literal>node</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">hugepages:
   defaultHugepagesSize: "1G"
   pages:
   - size:  "1G"
     count:  4
     node:  0 <co xml:id="CO33-1"/></programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para><literal>node</literal> is the NUMA node in which the huge pages are allocated. If you omit <literal>node</literal>, the pages are evenly spread across all NUMA nodes.</para>
</callout>
</calloutlist>
<note>
<simpara>Wait for the relevant machine config pool status that indicates the update is finished.</simpara>
</note>
<simpara>These are the only configuration steps you need to do to allocate huge pages.</simpara>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify the configuration, see the <literal>/proc/meminfo</literal> file on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/ip-10-0-141-105.ec2.internal</programlisting>
<programlisting language="terminal" linenumbering="unnumbered"># grep -i huge /proc/meminfo</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">AnonHugePages:    ###### ##
ShmemHugePages:        0 kB
HugePages_Total:       2
HugePages_Free:        2
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       #### ##
Hugetlb:            #### ##</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use <literal>oc describe</literal> to report the new size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node worker-0.ocp4poc.example.com | grep -i huge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">                                   hugepages-1g=true
 hugepages-###:  ###
 hugepages-###:  ###</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-allocating-multiple-huge-page-sizes_cnf-master">
<title>Allocating multiple huge page sizes</title>
<simpara>You can request huge pages with different sizes under the same container. This allows you to define more complicated pods consisting of containers with different huge page size needs.</simpara>
<simpara>For example, you can define sizes <literal>1G</literal> and <literal>2M</literal> and the Node Tuning Operator will configure both sizes on the node, as shown here:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  hugepages:
    defaultHugepagesSize: 1G
    pages:
    - count: 1024
      node: 0
      size: 2M
    - count: 4
      node: 1
      size: 1G</programlisting>
</section>
<section xml:id="configuring_for_irq_dynamic_load_balancing_cnf-master">
<title>Configuring a node for IRQ dynamic load balancing</title>
<simpara>Configure a cluster node for IRQ dynamic load balancing to control which cores can receive device interrupt requests (IRQ).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>For core isolation, all server hardware components must support IRQ affinity. To check if the hardware components of your server support IRQ affinity, view the server&#8217;s hardware specifications or contact your hardware provider.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform cluster as a user with cluster-admin privileges.</simpara>
</listitem>
<listitem>
<simpara>Set the performance profile <literal>apiVersion</literal> to use <literal>performance.openshift.io/v2</literal>.</simpara>
</listitem>
<listitem>
<simpara>Remove the <literal>globallyDisableIrqLoadBalancing</literal> field or set it to <literal>false</literal>.</simpara>
</listitem>
<listitem>
<simpara>Set the appropriate isolated and reserved CPUs. The following snippet illustrates a profile that reserves 2 CPUs. IRQ load-balancing is enabled for pods running on the <literal>isolated</literal> CPU set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: dynamic-irq-profile
spec:
  cpu:
    isolated: 2-5
    reserved: 0-1
...</programlisting>
<note>
<simpara>When you configure reserved and isolated CPUs, the infra containers in pods use the reserved CPUs and the application containers use the isolated CPUs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the pod that uses exclusive CPUs, and set <literal>irq-load-balancing.crio.io</literal> and <literal>cpu-quota.crio.io</literal> annotations to <literal>disable</literal>. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dynamic-irq-pod
  annotations:
     irq-load-balancing.crio.io: "disable"
     cpu-quota.crio.io: "disable"
spec:
  containers:
  - name: dynamic-irq-pod
    image: "registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14"
    command: ["sleep", "10h"]
    resources:
      requests:
        cpu: 2
        memory: "200M"
      limits:
        cpu: 2
        memory: "200M"
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""
  runtimeClassName: performance-dynamic-irq-profile
...</programlisting>
</listitem>
<listitem>
<simpara>Enter the pod <literal>runtimeClassName</literal> in the form performance-&lt;profile_name&gt;, where &lt;profile_name&gt; is the <literal>name</literal> from the <literal>PerformanceProfile</literal> YAML, in this example, <literal>performance-dynamic-irq-profile</literal>.</simpara>
</listitem>
<listitem>
<simpara>Set the node selector to target a cnf-worker.</simpara>
</listitem>
<listitem>
<simpara>Ensure the pod is running correctly. Status should be <literal>running</literal>, and the correct cnf-worker node should be set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod -o wide</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              READY   STATUS    RESTARTS   AGE     IP             NODE          NOMINATED NODE   READINESS GATES
dynamic-irq-pod   1/1     Running   0          5h33m   &lt;ip-address&gt;   &lt;node-name&gt;   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the CPUs that the pod configured for IRQ dynamic load balancing runs on:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it dynamic-irq-pod -- /bin/bash -c "grep Cpus_allowed_list /proc/self/status | awk '{print $2}'"</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cpus_allowed_list:  2-3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Ensure the node configuration is applied correctly. Log in to the node to verify the configuration.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt;</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/&lt;node-name&gt;-debug ...
To use host binaries, run `chroot /host`

Pod IP: &lt;ip-address&gt;
If you don't see a command prompt, try pressing enter.

sh-4.4#</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that you can use the node file system:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4#</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Ensure the default system CPU affinity mask does not include the <literal>dynamic-irq-pod</literal> CPUs, for example, CPUs 2 and 3.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /proc/irq/default_smp_affinity</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">33</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Ensure the system IRQs are not configured to run on the <literal>dynamic-irq-pod</literal> CPUs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">find /proc/irq/ -name smp_affinity_list -exec sh -c 'i="$1"; mask=$(cat $i); file=$(echo $i); echo $file: $mask' _ {} \;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/proc/irq/0/smp_affinity_list: 0-5
/proc/irq/1/smp_affinity_list: 5
/proc/irq/2/smp_affinity_list: 0-5
/proc/irq/3/smp_affinity_list: 0-5
/proc/irq/4/smp_affinity_list: 0
/proc/irq/5/smp_affinity_list: 0-5
/proc/irq/6/smp_affinity_list: 0-5
/proc/irq/7/smp_affinity_list: 0-5
/proc/irq/8/smp_affinity_list: 4
/proc/irq/9/smp_affinity_list: 4
/proc/irq/10/smp_affinity_list: 0-5
/proc/irq/11/smp_affinity_list: 0
/proc/irq/12/smp_affinity_list: 1
/proc/irq/13/smp_affinity_list: 0-5
/proc/irq/14/smp_affinity_list: 1
/proc/irq/15/smp_affinity_list: 0
/proc/irq/24/smp_affinity_list: 1
/proc/irq/25/smp_affinity_list: 1
/proc/irq/26/smp_affinity_list: 1
/proc/irq/27/smp_affinity_list: 5
/proc/irq/28/smp_affinity_list: 1
/proc/irq/29/smp_affinity_list: 0
/proc/irq/30/smp_affinity_list: 0-5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="about_irq_affinity_setting_cnf-master">
<title>About support of IRQ affinity setting</title>
<simpara>Some IRQ controllers lack support for IRQ affinity setting and will always expose all online CPUs as the IRQ mask. These IRQ controllers effectively run on CPU 0.</simpara>
<simpara>The following are examples of drivers and hardware that Red Hat are aware lack support for IRQ affinity setting. The list is, by no means, exhaustive:</simpara>
<itemizedlist>
<listitem>
<simpara>Some RAID controller drivers, such as <literal>megaraid_sas</literal></simpara>
</listitem>
<listitem>
<simpara>Many non-volatile memory express (NVMe) drivers</simpara>
</listitem>
<listitem>
<simpara>Some LAN on motherboard (LOM) network controllers</simpara>
</listitem>
<listitem>
<simpara>The driver uses <literal>managed_irqs</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The reason they do not support IRQ affinity setting might be associated with factors such as the type of processor, the IRQ controller, or the circuitry connections in the motherboard.</simpara>
</note>
<simpara>If the effective affinity of any IRQ is set to an isolated CPU, it might be a sign of some hardware or driver not supporting IRQ affinity setting. To find the effective affinity, log in to the host and run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ find /proc/irq -name effective_affinity -printf "%p: " -exec cat {} \;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/proc/irq/0/effective_affinity: 1
/proc/irq/1/effective_affinity: 8
/proc/irq/2/effective_affinity: 0
/proc/irq/3/effective_affinity: 1
/proc/irq/4/effective_affinity: 2
/proc/irq/5/effective_affinity: 1
/proc/irq/6/effective_affinity: 1
/proc/irq/7/effective_affinity: 1
/proc/irq/8/effective_affinity: 1
/proc/irq/9/effective_affinity: 2
/proc/irq/10/effective_affinity: 1
/proc/irq/11/effective_affinity: 1
/proc/irq/12/effective_affinity: 4
/proc/irq/13/effective_affinity: 1
/proc/irq/14/effective_affinity: 1
/proc/irq/15/effective_affinity: 1
/proc/irq/24/effective_affinity: 2
/proc/irq/25/effective_affinity: 4
/proc/irq/26/effective_affinity: 2
/proc/irq/27/effective_affinity: 1
/proc/irq/28/effective_affinity: 8
/proc/irq/29/effective_affinity: 4
/proc/irq/30/effective_affinity: 4
/proc/irq/31/effective_affinity: 8
/proc/irq/32/effective_affinity: 8
/proc/irq/33/effective_affinity: 1
/proc/irq/34/effective_affinity: 2</programlisting>
</para>
</formalpara>
<simpara>Some drivers use <literal>managed_irqs</literal>, whose affinity is managed internally by the kernel and userspace cannot change the affinity. In some cases, these IRQs might be assigned to isolated CPUs. For more information about <literal>managed_irqs</literal>, see <link xlink:href="https://access.redhat.com/solutions/4819541">Affinity of managed interrupts cannot be changed even if they target isolated CPU</link>.</simpara>
</section>
<section xml:id="configuring_hyperthreading_for_a_cluster_cnf-master">
<title>Configuring hyperthreading for a cluster</title>
<simpara>To configure hyperthreading for an OpenShift Container Platform cluster, set the CPU threads in the performance profile to the same cores that are configured for the reserved or isolated CPU pools.</simpara>
<note>
<simpara>If you configure a performance profile, and subsequently change the hyperthreading configuration for the host, ensure that you update the CPU <literal>isolated</literal> and <literal>reserved</literal> fields in the <literal>PerformanceProfile</literal> YAML to match the new configuration.</simpara>
</note>
<warning>
<simpara>Disabling a previously enabled host hyperthreading configuration can cause the CPU core IDs listed in the <literal>PerformanceProfile</literal> YAML to be incorrect. This incorrect configuration can cause the node to become unavailable because the listed CPUs can no longer be found.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (oc).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Ascertain which threads are running on what CPUs for the host you want to configure.</simpara>
<simpara>You can view which threads are running on the host CPUs by logging in to the cluster and running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ lscpu --all --extended</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">CPU NODE SOCKET CORE L1d:L1i:L2:L3 ONLINE MAXMHZ    MINMHZ
0   0    0      0    0:0:0:0       yes    4800.0000 400.0000
1   0    0      1    1:1:1:0       yes    4800.0000 400.0000
2   0    0      2    2:2:2:0       yes    4800.0000 400.0000
3   0    0      3    3:3:3:0       yes    4800.0000 400.0000
4   0    0      0    0:0:0:0       yes    4800.0000 400.0000
5   0    0      1    1:1:1:0       yes    4800.0000 400.0000
6   0    0      2    2:2:2:0       yes    4800.0000 400.0000
7   0    0      3    3:3:3:0       yes    4800.0000 400.0000</programlisting>
</para>
</formalpara>
<simpara>In this example, there are eight logical CPU cores running on four physical CPU cores. CPU0 and CPU4 are running on physical Core0, CPU1 and CPU5 are running on physical Core 1, and so on.</simpara>
<simpara>Alternatively, to view the threads that are set for a particular physical CPU core (<literal>cpu0</literal> in the example below), open a command prompt and run the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /sys/devices/system/cpu/cpu0/topology/thread_siblings_list</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">0-4</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the isolated and reserved CPUs in the <literal>PerformanceProfile</literal> YAML. For example, you can set logical cores CPU0 and CPU4 as <literal>isolated</literal>, and logical cores CPU1 to CPU3 and CPU5 to CPU7 as <literal>reserved</literal>. When you configure reserved and isolated CPUs, the infra containers in pods use the reserved CPUs and the application containers use the isolated CPUs.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">...
  cpu:
    isolated: 0,4
    reserved: 1-3,5-7
...</programlisting>
<note>
<simpara>The reserved and isolated CPU pools must not overlap and together must span all available cores in the worker node.</simpara>
</note>
</listitem>
</orderedlist>
<important>
<simpara>Hyperthreading is enabled by default on most Intel processors. If you enable hyperthreading, all threads processed by a particular core must be isolated or processed on the same core.</simpara>
</important>
<section xml:id="disabling_hyperthreading_for_low_latency_applications_cnf-master">
<title>Disabling hyperthreading for low latency applications</title>
<simpara>When configuring clusters for low latency processing, consider whether you want to disable hyperthreading before you deploy the cluster. To disable hyperthreading, do the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a performance profile that is appropriate for your hardware and topology.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>nosmt</literal> as an additional kernel argument. The following example performance profile illustrates this setting:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: example-performanceprofile
spec:
  additionalKernelArgs:
    - nmi_watchdog=0
    - audit=0
    - mce=off
    - processor.max_cstate=1
    - idle=poll
    - intel_idle.max_cstate=0
    - nosmt
  cpu:
    isolated: 2-3
    reserved: 0-1
  hugepages:
    defaultHugepagesSize: 1G
    pages:
      - count: 2
        node: 0
        size: 1G
  nodeSelector:
    node-role.kubernetes.io/performance: ''
  realTimeKernel:
    enabled: true</programlisting>
<note>
<simpara>When you configure reserved and isolated CPUs, the infra containers in pods use the reserved CPUs and the application containers use the isolated CPUs.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cnf-understanding-workload-hints_cnf-master">
<title>Understanding workload hints</title>
<simpara>The following table describes how combinations of power consumption and real-time settings impact on latency.</simpara>
<note>
<simpara>The following workload hints can be configured manually. You can also work with workload hints using the Performance Profile Creator. For more information about the performance profile, see the "Creating a performance profile" section.
If the workload hint is configured manually and the <literal>realTime</literal> workload hint is not explicitly set then it defaults to <literal>true</literal>.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Performance Profile creator setting</entry>
<entry align="left" valign="top">Hint</entry>
<entry align="left" valign="top">Environment</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">workloadHints:
highPowerConsumption: false
realTime: false</programlisting></entry>
<entry align="left" valign="top"><simpara>High throughput cluster without latency requirements</simpara></entry>
<entry align="left" valign="top"><simpara>Performance achieved through CPU partitioning only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Low-latency</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">workloadHints:
highPowerConsumption: false
realTime: true</programlisting></entry>
<entry align="left" valign="top"><simpara>Regional datacenters</simpara></entry>
<entry align="left" valign="top"><simpara>Both energy savings and low-latency are desirable: compromise between power management, latency and throughput.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ultra-low-latency</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">workloadHints:
highPowerConsumption: true
realTime: true</programlisting></entry>
<entry align="left" valign="top"><simpara>Far edge clusters, latency critical workloads</simpara></entry>
<entry align="left" valign="top"><simpara>Optimized for absolute minimal latency and maximum determinism at the cost of increased power consumption.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Per-pod power management</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">workloadHints:
realTime: true
highPowerConsumption: false
perPodPowerManagement: true</programlisting></entry>
<entry align="left" valign="top"><simpara>Critical and non-critical workloads</simpara></entry>
<entry align="left" valign="top"><simpara>Allows for power management per pod.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about using the Performance Profile Creator (PPC) to generate a performance profile, see <link linkend="cnf-create-performance-profiles">Creating a performance profile</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-workload-hints_cnf-master">
<title>Configuring workload hints manually</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>PerformanceProfile</literal> appropriate for the environment&#8217;s hardware and topology as described in the table in "Understanding workload hints". Adjust the profile to match the expected workload. In this example, we tune for the lowest possible latency.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>highPowerConsumption</literal> and <literal>realTime</literal> workload hints. Both are set to <literal>true</literal> here.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: performance.openshift.io/v2
    kind: PerformanceProfile
    metadata:
      name: workload-hints
    spec:
      ...
      workloadHints:
        highPowerConsumption: true <co xml:id="CO34-1"/>
        realTime: true <co xml:id="CO34-2"/></programlisting>
<calloutlist>
<callout arearefs="CO34-1">
<para>If <literal>highPowerConsumption</literal> is <literal>true</literal>, the node is tuned for very low latency at the cost of increased power consumption.</para>
</callout>
<callout arearefs="CO34-2">
<para>Disables some debugging and monitoring features that can affect system latency.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<note>
<simpara>When the <literal>realTime</literal> workload hint flag is set to <literal>true</literal> in a performance profile, add the <literal>cpu-quota.crio.io: disable</literal> annotation to every guaranteed pod with pinned CPUs. This annotation is necessary to prevent the degradation of the process performance within the pod. If the <literal>realTime</literal> workload hint is not explicitly set then it defaults to <literal>true</literal>.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about reducing CPU throttling for individual guaranteed pods, see <link linkend="disabling-cpu-cfs-quota_cnf-master">Disabling CPU CFS quota</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-cpu-infra-container_cnf-master">
<title>Restricting CPUs for infra and application containers</title>
<simpara>Generic housekeeping and workload tasks use CPUs in a way that may impact latency-sensitive processes. By default, the container runtime uses all online CPUs to run all containers together, which can result in context switches and spikes in latency. Partitioning the CPUs prevents noisy processes from interfering with latency-sensitive processes by separating them from each other. The following table describes how processes run on a CPU after you have tuned the node using the Node Tuning Operator:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Process' CPU assignments</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Process type</entry>
<entry align="left" valign="top">Details</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Burstable</literal> and <literal>BestEffort</literal> pods</simpara></entry>
<entry align="left" valign="top"><simpara>Runs on any CPU except where low latency workload is running</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Infrastructure pods</simpara></entry>
<entry align="left" valign="top"><simpara>Runs on any CPU except where low latency workload is running</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Interrupts</simpara></entry>
<entry align="left" valign="top"><simpara>Redirects to reserved CPUs (optional in OpenShift Container Platform 4.7 and later)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kernel processes</simpara></entry>
<entry align="left" valign="top"><simpara>Pins to reserved CPUs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Latency-sensitive workload pods</simpara></entry>
<entry align="left" valign="top"><simpara>Pins to a specific set of exclusive CPUs from the isolated pool</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OS processes/systemd services</simpara></entry>
<entry align="left" valign="top"><simpara>Pins to reserved CPUs</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The allocatable capacity of cores on a node for pods of all QoS process types, <literal>Burstable</literal>,  <literal>BestEffort</literal>, or <literal>Guaranteed</literal>, is equal to the capacity of the isolated pool. The capacity of the reserved pool is removed from the node&#8217;s total core capacity for use by the cluster and operating system housekeeping duties.</simpara>
<formalpara>
<title>Example 1</title>
<para>A node features a capacity of 100 cores. Using a performance profile, the cluster administrator allocates 50 cores to the isolated pool and 50 cores to the reserved pool. The cluster administrator assigns 25 cores to QoS <literal>Guaranteed</literal> pods and 25 cores for <literal>BestEffort</literal> or <literal>Burstable</literal> pods. This matches the capacity of the isolated pool.</para>
</formalpara>
<formalpara>
<title>Example 2</title>
<para>A node features a capacity of 100 cores. Using a performance profile, the cluster administrator allocates 50 cores to the isolated pool and 50 cores to the reserved pool. The cluster administrator assigns 50 cores to QoS <literal>Guaranteed</literal> pods and one core for <literal>BestEffort</literal> or <literal>Burstable</literal> pods. This exceeds the capacity of the isolated pool by one core. Pod scheduling fails because of insufficient CPU capacity.</para>
</formalpara>
<simpara>The exact partitioning pattern to use depends on many factors like hardware, workload characteristics and the expected system load. Some sample use cases are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>If the latency-sensitive workload uses specific hardware, such as a network interface controller (NIC), ensure that the CPUs in the isolated pool are as close as possible to this hardware. At a minimum, you should place the workload in the same Non-Uniform Memory Access (NUMA) node.</simpara>
</listitem>
<listitem>
<simpara>The reserved pool is used for handling all interrupts. When depending on system networking, allocate a sufficiently-sized reserve pool to handle all the incoming packet interrupts. In 4.14 and later versions, workloads can optionally be labeled as sensitive.</simpara>
</listitem>
</itemizedlist>
<simpara>The decision regarding which specific CPUs should be used for reserved and isolated partitions requires detailed analysis and measurements. Factors like NUMA affinity of devices and memory play a role. The selection also depends on the workload architecture and the specific use case.</simpara>
<important>
<simpara>The reserved and isolated CPU pools must not overlap and together must span all available cores in the worker node.</simpara>
</important>
<simpara>To ensure that housekeeping tasks and workloads do not interfere with each other, specify two groups of CPUs in the <literal>spec</literal> section of the performance profile.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>isolated</literal> - Specifies the CPUs for the application container workloads. These CPUs have the lowest latency. Processes in this group have no interruptions and can, for example, reach much higher DPDK zero packet loss bandwidth.</simpara>
</listitem>
<listitem>
<simpara><literal>reserved</literal> - Specifies the CPUs for the cluster and operating system housekeeping duties. Threads in the <literal>reserved</literal> group are often busy. Do not run latency-sensitive applications in the <literal>reserved</literal> group. Latency-sensitive applications run in the <literal>isolated</literal> group.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a performance profile appropriate for the environment&#8217;s hardware and topology.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>reserved</literal> and <literal>isolated</literal> parameters with the CPUs you want reserved and isolated for the infra and application containers:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: infra-cpus
spec:
  cpu:
    reserved: "0-4,9" <co xml:id="CO35-1"/>
    isolated: "5-8" <co xml:id="CO35-2"/>
  nodeSelector: <co xml:id="CO35-3"/>
    node-role.kubernetes.io/worker: ""</programlisting>
<calloutlist>
<callout arearefs="CO35-1">
<para>Specify which CPUs are for infra containers to perform cluster and operating system housekeeping duties.</para>
</callout>
<callout arearefs="CO35-2">
<para>Specify which CPUs are for application containers to run workloads.</para>
</callout>
<callout arearefs="CO35-3">
<para>Optional: Specify a node selector to apply the performance profile to specific nodes.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../scalability_and_performance/cnf-low-latency-tuning.xml#managing-device-interrupt-processing-for-guaranteed-pod-isolated-cpus_cnf-master">Managing device interrupt processing for guaranteed pod isolated CPUs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/#create-a-pod-that-gets-assigned-a-qos-class-of-guaranteed">Create a pod that gets assigned a QoS class of Guaranteed</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="reducing-nic-queues-using-the-node-tuning-operator_cnf-master">
<title>Reducing NIC queues using the Node Tuning Operator</title>
<simpara>The Node Tuning Operator allows you to adjust the network interface controller (NIC) queue count for each network device by configuring the performance profile. Device network queues allows the distribution of packets among different physical queues and each queue gets a separate thread for packet processing.</simpara>
<simpara>In real-time or low latency systems, all the unnecessary interrupt request lines (IRQs) pinned to the isolated CPUs must be moved to reserved or housekeeping CPUs.</simpara>
<simpara>In deployments with applications that require system, OpenShift Container Platform networking or in mixed deployments with Data Plane Development Kit (DPDK) workloads, multiple queues are needed to achieve good throughput and the number of NIC queues should be adjusted or remain unchanged. For example, to achieve low latency the number of NIC queues for DPDK based workloads should be reduced to just the number of reserved or housekeeping CPUs.</simpara>
<simpara>Too many queues are created by default for each CPU and these do not fit into the interrupt tables for housekeeping CPUs when tuning for low latency. Reducing the number of queues makes proper tuning possible. Smaller number of queues means a smaller number of interrupts that then fit in the IRQ table.</simpara>
<note>
<simpara>In earlier versions of OpenShift Container Platform, the Performance Addon Operator provided automatic, low latency performance tuning for applications. In OpenShift Container Platform 4.11 and later, this functionality is part of the Node Tuning Operator.</simpara>
</note>
<section xml:id="adjusting-nic-queues-with-the-performance-profile_cnf-master">
<title>Adjusting the NIC queues with the performance profile</title>
<simpara>The performance profile lets you adjust the queue count for each network device.</simpara>
<simpara>Supported network devices:</simpara>
<itemizedlist>
<listitem>
<simpara>Non-virtual network devices</simpara>
</listitem>
<listitem>
<simpara>Network devices that support multiple queues (channels)</simpara>
</listitem>
</itemizedlist>
<simpara>Unsupported network devices:</simpara>
<itemizedlist>
<listitem>
<simpara>Pure software network interfaces</simpara>
</listitem>
<listitem>
<simpara>Block devices</simpara>
</listitem>
<listitem>
<simpara>Intel DPDK virtual functions</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform cluster running the Node Tuning Operator as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create and apply a performance profile appropriate for your hardware and topology. For guidance on creating a profile, see the "Creating a performance profile" section.</simpara>
</listitem>
<listitem>
<simpara>Edit this created performance profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -f &lt;your_profile_name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Populate the <literal>spec</literal> field with the <literal>net</literal> object. The object list can contain two fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>userLevelNetworking</literal> is a required field specified as a boolean flag. If <literal>userLevelNetworking</literal> is <literal>true</literal>, the queue count is set to the reserved CPU count for all supported devices. The default is <literal>false</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>devices</literal> is an optional field specifying a list of devices that will have the queues set to the reserved CPU count. If the device list is empty, the configuration applies to all network devices. The configuration is as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>interfaceName</literal>: This field specifies the interface name, and it supports shell-style wildcards, which can be positive or negative.</simpara>
<itemizedlist>
<listitem>
<simpara>Example wildcard syntax is as follows: <literal>&lt;string&gt; .*</literal></simpara>
</listitem>
<listitem>
<simpara>Negative rules are prefixed with an exclamation mark. To apply the net queue changes to all devices other than the excluded list, use  <literal>!&lt;device&gt;</literal>, for example, <literal>!eno1</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>vendorID</literal>: The network device vendor ID represented as a 16-bit hexadecimal number with a <literal>0x</literal> prefix.</simpara>
</listitem>
<listitem>
<simpara><literal>deviceID</literal>: The network device ID (model) represented as a 16-bit hexadecimal number with a <literal>0x</literal> prefix.</simpara>
<note>
<simpara>When a <literal>deviceID</literal> is specified, the <literal>vendorID</literal> must also be defined. A device that matches all of the device identifiers specified in a device entry <literal>interfaceName</literal>, <literal>vendorID</literal>, or a pair of <literal>vendorID</literal> plus <literal>deviceID</literal> qualifies as a network device. This network device then has its net queues count set to the reserved CPU count.</simpara>
<simpara>When two or more devices are specified, the net queues count is set to any net device that matches one of them.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Set the queue count to the reserved CPU count for all devices by using this example performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  cpu:
    isolated: 3-51,54-103
    reserved: 0-2,52-54
  net:
    userLevelNetworking: true
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""</programlisting>
</listitem>
<listitem>
<simpara>Set the queue count to the reserved CPU count for all devices matching any of the defined device identifiers by using this example performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  cpu:
    isolated: 3-51,54-103
    reserved: 0-2,52-54
  net:
    userLevelNetworking: true
    devices:
    - interfaceName: eth0
    - interfaceName: eth1
    - vendorID: 0x1af4
    - deviceID: 0x1000
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""</programlisting>
</listitem>
<listitem>
<simpara>Set the queue count to the reserved CPU count for all devices starting with the interface name <literal>eth</literal> by using this example performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  cpu:
    isolated: 3-51,54-103
    reserved: 0-2,52-54
  net:
    userLevelNetworking: true
    devices:
    - interfaceName: eth*
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""</programlisting>
</listitem>
<listitem>
<simpara>Set the queue count to the reserved CPU count for all devices with an interface named anything other than <literal>eno1</literal> by using this example performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  cpu:
    isolated: 3-51,54-103
    reserved: 0-2,52-54
  net:
    userLevelNetworking: true
    devices:
    - interfaceName: !eno1
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""</programlisting>
</listitem>
<listitem>
<simpara>Set the queue count to the reserved CPU count for all devices that have an interface name <literal>eth0</literal>, <literal>vendorID</literal> of <literal>0x1af4</literal>, and <literal>deviceID</literal> of <literal>0x1000</literal> by using this example performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: manual
spec:
  cpu:
    isolated: 3-51,54-103
    reserved: 0-2,52-54
  net:
    userLevelNetworking: true
    devices:
    - interfaceName: eth0
    - vendorID: 0x1af4
    - deviceID: 0x1000
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""</programlisting>
</listitem>
<listitem>
<simpara>Apply the updated performance profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;your_profile_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cnf-create-performance-profiles">Creating a performance profile</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="verifying-queue-status_cnf-master">
<title>Verifying the queue status</title>
<simpara>In this section, a number of examples illustrate different performance profiles and how to verify the changes are applied.</simpara>
<formalpara>
<title>Example 1</title>
<para>In this example, the net queue count is set to the reserved CPU count (2) for <emphasis>all</emphasis> supported devices.</para>
</formalpara>
<simpara>The relevant section from the performance profile is:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
metadata:
  name: performance
spec:
  kind: PerformanceProfile
  spec:
    cpu:
      reserved: 0-1  #total = 2
      isolated: 2-8
    net:
      userLevelNetworking: true
# ...</programlisting>
<itemizedlist>
<listitem>
<simpara>Display the status of the queues associated with a device using the following command:</simpara>
<note>
<simpara>Run this command on the node where the performance profile was applied.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l &lt;device&gt;</programlisting>
</listitem>
<listitem>
<simpara>Verify the queue status before the profile is applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l ens4</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Channel parameters for ens4:
Pre-set maximums:
RX:         0
TX:         0
Other:      0
Combined:   4
Current hardware settings:
RX:         0
TX:         0
Other:      0
Combined:   4</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify the queue status after the profile is applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l ens4</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Channel parameters for ens4:
Pre-set maximums:
RX:         0
TX:         0
Other:      0
Combined:   4
Current hardware settings:
RX:         0
TX:         0
Other:      0
Combined:   2 <co xml:id="CO36-1"/></programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<calloutlist>
<callout arearefs="CO36-1">
<para>The combined channel shows that the total count of reserved CPUs for <emphasis>all</emphasis> supported devices is 2. This matches what is configured in the performance profile.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example 2</title>
<para>In this example, the net queue count is set to the reserved CPU count (2) for <emphasis>all</emphasis> supported network devices with a specific <literal>vendorID</literal>.</para>
</formalpara>
<simpara>The relevant section from the performance profile is:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
metadata:
  name: performance
spec:
  kind: PerformanceProfile
  spec:
    cpu:
      reserved: 0-1  #total = 2
      isolated: 2-8
    net:
      userLevelNetworking: true
      devices:
      - vendorID = 0x1af4
# ...</programlisting>
<itemizedlist>
<listitem>
<simpara>Display the status of the queues associated with a device using the following command:</simpara>
<note>
<simpara>Run this command on the node where the performance profile was applied.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l &lt;device&gt;</programlisting>
</listitem>
<listitem>
<simpara>Verify the queue status after the profile is applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l ens4</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Channel parameters for ens4:
Pre-set maximums:
RX:         0
TX:         0
Other:      0
Combined:   4
Current hardware settings:
RX:         0
TX:         0
Other:      0
Combined:   2 <co xml:id="CO37-1"/></programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<calloutlist>
<callout arearefs="CO37-1">
<para>The total count of reserved CPUs for all supported devices with <literal>vendorID=0x1af4</literal> is 2.
For example, if there is another network device <literal>ens2</literal> with <literal>vendorID=0x1af4</literal> it will also have total net queues of 2. This matches what is configured in the performance profile.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example 3</title>
<para>In this example, the net queue count is set to the reserved CPU count (2) for <emphasis>all</emphasis> supported network devices that match any of the defined device identifiers.</para>
</formalpara>
<simpara>The command <literal>udevadm info</literal> provides a detailed report on a device. In this example the devices are:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># udevadm info -p /sys/class/net/ens4
...
E: ID_MODEL_ID=0x1000
E: ID_VENDOR_ID=0x1af4
E: INTERFACE=ens4
...</programlisting>
<programlisting language="terminal" linenumbering="unnumbered"># udevadm info -p /sys/class/net/eth0
...
E: ID_MODEL_ID=0x1002
E: ID_VENDOR_ID=0x1001
E: INTERFACE=eth0
...</programlisting>
<itemizedlist>
<listitem>
<simpara>Set the net queues to 2 for a device with <literal>interfaceName</literal> equal to <literal>eth0</literal> and any devices that have a <literal>vendorID=0x1af4</literal> with the following performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
metadata:
  name: performance
spec:
  kind: PerformanceProfile
    spec:
      cpu:
        reserved: 0-1  #total = 2
        isolated: 2-8
      net:
        userLevelNetworking: true
        devices:
        - interfaceName = eth0
        - vendorID = 0x1af4
...</programlisting>
</listitem>
<listitem>
<simpara>Verify the queue status after the profile is applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ethtool -l ens4</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Channel parameters for ens4:
Pre-set maximums:
RX:         0
TX:         0
Other:      0
Combined:   4
Current hardware settings:
RX:         0
TX:         0
Other:      0
Combined:   2 <co xml:id="CO38-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO38-1">
<para>The total count of reserved CPUs for all supported devices with <literal>vendorID=0x1af4</literal> is set to 2.
For example, if there is another network device <literal>ens2</literal> with <literal>vendorID=0x1af4</literal>, it will also have the total net queues set to 2. Similarly, a device with <literal>interfaceName</literal> equal to <literal>eth0</literal> will have total net queues set to 2.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="logging-associated-with-adjusting-nic-queues_cnf-master">
<title>Logging associated with adjusting NIC queues</title>
<simpara>Log messages detailing the assigned devices are recorded in the respective Tuned daemon logs. The following messages might be recorded to the <literal>/var/log/tuned/tuned.log</literal> file:</simpara>
<itemizedlist>
<listitem>
<simpara>An <literal>INFO</literal> message is recorded detailing the successfully assigned devices:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">INFO tuned.plugins.base: instance net_test (net): assigning devices ens1, ens2, ens3</programlisting>
</listitem>
<listitem>
<simpara>A <literal>WARNING</literal> message is recorded if none of the devices can be assigned:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">WARNING  tuned.plugins.base: instance net_test: no matching devices available</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cnf-debugging-low-latency-cnf-tuning-status_cnf-master">
<title>Debugging low latency CNF tuning status</title>
<simpara>The <literal>PerformanceProfile</literal> custom resource (CR) contains status fields for reporting tuning status and debugging latency degradation issues. These fields report on conditions that describe the state of the operator&#8217;s reconciliation functionality.</simpara>
<simpara>A typical issue can arise when the status of machine config pools that are attached to the performance profile are in a degraded state, causing the <literal>PerformanceProfile</literal> status to degrade. In this case, the machine config pool issues a failure message.</simpara>
<simpara>The Node Tuning Operator contains the <literal>performanceProfile.spec.status.Conditions</literal> status field:</simpara>
<programlisting language="bash" linenumbering="unnumbered">Status:
  Conditions:
    Last Heartbeat Time:   2020-06-02T10:01:24Z
    Last Transition Time:  2020-06-02T10:01:24Z
    Status:                True
    Type:                  Available
    Last Heartbeat Time:   2020-06-02T10:01:24Z
    Last Transition Time:  2020-06-02T10:01:24Z
    Status:                True
    Type:                  Upgradeable
    Last Heartbeat Time:   2020-06-02T10:01:24Z
    Last Transition Time:  2020-06-02T10:01:24Z
    Status:                False
    Type:                  Progressing
    Last Heartbeat Time:   2020-06-02T10:01:24Z
    Last Transition Time:  2020-06-02T10:01:24Z
    Status:                False
    Type:                  Degraded</programlisting>
<simpara>The <literal>Status</literal> field contains <literal>Conditions</literal> that specify <literal>Type</literal> values that indicate the status of the performance profile:</simpara>
<variablelist>
<varlistentry>
<term><literal>Available</literal></term>
<listitem>
<simpara>All machine configs and Tuned profiles have been created successfully and are available for cluster components are responsible to process them (NTO, MCO, Kubelet).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Upgradeable</literal></term>
<listitem>
<simpara>Indicates whether the resources maintained by the Operator are in a state that is safe to upgrade.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Progressing</literal></term>
<listitem>
<simpara>Indicates that the deployment process from the performance profile has started.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Degraded</literal></term>
<listitem>
<simpara>Indicates an error if:</simpara>
<itemizedlist>
<listitem>
<simpara>Validation of the performance profile has failed.</simpara>
</listitem>
<listitem>
<simpara>Creation of all relevant components did not complete successfully.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara>Each of these types contain the following fields:</simpara>
<variablelist>
<varlistentry>
<term><literal>Status</literal></term>
<listitem>
<simpara>The state for the specific type (<literal>true</literal> or <literal>false</literal>).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Timestamp</literal></term>
<listitem>
<simpara>The transaction timestamp.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Reason string</literal></term>
<listitem>
<simpara>The machine readable reason.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Message string</literal></term>
<listitem>
<simpara>The human readable reason describing the state and error details, if any.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="cnf-debugging-low-latency-cnf-tuning-status-machineconfigpools_cnf-master">
<title>Machine config pools</title>
<simpara>A performance profile and its created products are applied to a node according to an associated machine config pool (MCP). The MCP holds valuable information about the progress of applying the machine configurations created by performance profiles that encompass kernel args, kube config, huge pages allocation, and deployment of rt-kernel. The Performance Profile controller monitors changes in the MCP and updates the performance profile status accordingly.</simpara>
<simpara>The only conditions returned by the MCP to the performance profile status is when the MCP is <literal>Degraded</literal>, which leads to <literal>performanceProfile.status.condition.Degraded = true</literal>.</simpara>
<formalpara>
<title>Example</title>
<para>The following example is for a performance profile with an associated machine config pool (<literal>worker-cnf</literal>) that was created for it:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The associated machine config pool is in a degraded state:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         CONFIG                                                 UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master       rendered-master-2ee57a93fa6c9181b546ca46e1571d2d       True      False      False      3              3                   3                     0                      2d21h
worker       rendered-worker-d6b2bdc07d9f5a59a6b68950acf25e5f       True      False      False      2              2                   2                     0                      2d21h
worker-cnf   rendered-worker-cnf-6c838641b8a08fff08dbd8b02fb63f7c   False     True       True       2              1                   1                     1                      2d20h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The <literal>describe</literal> section of the MCP shows the reason:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc describe mcp worker-cnf</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  Message:               Node node-worker-cnf is reporting: "prepping update:
  machineconfig.machineconfiguration.openshift.io \"rendered-worker-cnf-40b9996919c08e335f3ff230ce1d170\" not
  found"
    Reason:                1 nodes are reporting degraded status on sync</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The degraded state should also appear under the performance profile <literal>status</literal> field marked as <literal>degraded = true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc describe performanceprofiles performance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Message: Machine config pool worker-cnf Degraded Reason: 1 nodes are reporting degraded status on sync.
Machine config pool worker-cnf Degraded Message: Node yquinn-q8s5v-w-b-z5lqn.c.openshift-gce-devel.internal is
reporting: "prepping update: machineconfig.machineconfiguration.openshift.io
\"rendered-worker-cnf-40b9996919c08e335f3ff230ce1d170\" not found".    Reason:  MCPDegraded
   Status:  True
   Type:    Degraded</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cnf-collecting-low-latency-tuning-debugging-data-for-red-hat-support_cnf-master">
<title>Collecting low latency tuning debugging data for Red Hat Support</title>
<simpara>When opening a support case, it is helpful to provide debugging information about your cluster to Red Hat Support.</simpara>
<simpara>The <literal>must-gather</literal> tool enables you to collect diagnostic information about your OpenShift Container Platform cluster, including node tuning, NUMA topology, and other information needed to debug issues with low latency setup.</simpara>
<simpara>For prompt support, supply diagnostic information for both OpenShift Container Platform and low latency tuning.</simpara>
<section xml:id="cnf-about-must-gather_cnf-master">
<title>About the must-gather tool</title>
<simpara>The <literal>oc adm must-gather</literal> CLI command collects the information from your cluster that is most likely needed for debugging issues, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>Resource definitions</simpara>
</listitem>
<listitem>
<simpara>Audit logs</simpara>
</listitem>
<listitem>
<simpara>Service logs</simpara>
</listitem>
</itemizedlist>
<simpara>You can specify one or more images when you run the command by including the <literal>--image</literal> argument. When you specify an image, the tool collects data related to that feature or product. When you run <literal>oc adm must-gather</literal>, a new pod is created on the cluster. The data is collected on that pod and saved in a new directory that starts with <literal>must-gather.local</literal>. This directory is created in your current working directory.</simpara>
</section>
<section xml:id="cnf-about-collecting-low-latency-data_cnf-master">
<title>Gathering low latency tuning data</title>
<simpara>Use the <literal>oc adm must-gather</literal> CLI command to collect information about your cluster, including features and objects associated with low latency tuning, including:</simpara>
<itemizedlist>
<listitem>
<simpara>The Node Tuning Operator namespaces and child objects.</simpara>
</listitem>
<listitem>
<simpara><literal>MachineConfigPool</literal> and associated <literal>MachineConfig</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>The Node Tuning Operator and associated Tuned objects.</simpara>
</listitem>
<listitem>
<simpara>Linux kernel command line options.</simpara>
</listitem>
<listitem>
<simpara>CPU and NUMA topology</simpara>
</listitem>
<listitem>
<simpara>Basic PCI device information and NUMA locality.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Container Platform CLI (oc) installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the directory where you want to store the <literal>must-gather</literal> data.</simpara>
</listitem>
<listitem>
<simpara>Collect debugging information by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[must-gather      ] OUT Using must-gather plug-in image: quay.io/openshift-release
When opening a support case, bugzilla, or issue please include the following summary data along with any other requested information:
ClusterID: 829er0fa-1ad8-4e59-a46e-2644921b7eb6
ClusterVersion: Stable at "&lt;cluster_version&gt;"
ClusterOperators:
	All healthy and stable


[must-gather      ] OUT namespace/openshift-must-gather-8fh4x created
[must-gather      ] OUT clusterrolebinding.rbac.authorization.k8s.io/must-gather-rhlgc created
[must-gather-5564g] POD 2023-07-17T10:17:37.610340849Z Gathering data for ns/openshift-cluster-version...
[must-gather-5564g] POD 2023-07-17T10:17:38.786591298Z Gathering data for ns/default...
[must-gather-5564g] POD 2023-07-17T10:17:39.117418660Z Gathering data for ns/openshift...
[must-gather-5564g] POD 2023-07-17T10:17:39.447592859Z Gathering data for ns/kube-system...
[must-gather-5564g] POD 2023-07-17T10:17:39.803381143Z Gathering data for ns/openshift-etcd...

...

Reprinting Cluster State:
When opening a support case, bugzilla, or issue please include the following summary data along with any other requested information:
ClusterID: 829er0fa-1ad8-4e59-a46e-2644921b7eb6
ClusterVersion: Stable at "&lt;cluster_version&gt;"
ClusterOperators:
	All healthy and stable</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a compressed file from the <literal>must-gather</literal> directory that was created in your working directory. For example, on a computer that uses a Linux operating system, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar cvaf must-gather.tar.gz must-gather-local.5421342344627712289<co xml:id="CO39-1"/></programlisting>
<calloutlist>
<callout arearefs="CO39-1">
<para>Replace <literal>must-gather-local.5421342344627712289//</literal> with the directory name created by the <literal>must-gather</literal> tool.</para>
</callout>
</calloutlist>
<note>
<simpara>Create a compressed file to attach the data to a support case or to use with the Performance Profile Creator wrapper script when you create a performance profile.</simpara>
</note>
</listitem>
<listitem>
<simpara>Attach the compressed file to your support case on the <link xlink:href="https://access.redhat.com/">Red Hat Customer Portal</link>.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about the <literal>must-gather</literal> tool, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/support/#gathering-cluster-data">Gathering data about your cluster</link></simpara>
</listitem>
<listitem>
<simpara>For more information about MachineConfig and KubeletConfig,
see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-nodes-managing">Managing nodes</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about the Node Tuning Operator,
see <link linkend="using-node-tuning-operator">Using the Node Tuning Operator</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about the PerformanceProfile,
see <link linkend="configuring-huge-pages_huge-pages">Configuring huge pages</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about consuming huge pages from your containers,
see <link linkend="how-huge-pages-are-consumed-by-apps_huge-pages">How huge pages are consumed by apps</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="cnf-performing-platform-verification-latency-tests">
<title>Performing latency tests for platform verification</title>
<simpara>You can use the Cloud-native Network Functions (CNF) tests image to run latency tests on a CNF-enabled OpenShift Container Platform cluster, where all the components required for running CNF workloads are installed. Run the latency tests to validate node tuning for your workload.</simpara>
<simpara>The <literal>cnf-tests</literal> container image is available at <literal>registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14</literal>.</simpara>
<section xml:id="cnf-latency-tests-prerequisites_cnf-latency-tests">
<title>Prerequisites for running latency tests</title>
<simpara>Your cluster must meet the following requirements before you can run the latency tests:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You have configured a performance profile with the Node Tuning Operator.</simpara>
</listitem>
<listitem>
<simpara>You have applied all the required CNF configurations in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have a pre-existing <literal>MachineConfigPool</literal> CR applied in the cluster. The default worker pool is <literal>worker-cnf</literal>.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about creating the cluster performance profile, see <link linkend="node-tuning-operator-provisioning-worker-with-real-time-capabilities_cnf-master">Provisioning a worker with real-time capabilities</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-measuring-latency_cnf-latency-tests">
<title>Measuring latency</title>
<simpara>The <literal>cnf-tests</literal> image uses three tools to measure the latency of the system:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>hwlatdetect</literal></simpara>
</listitem>
<listitem>
<simpara><literal>cyclictest</literal></simpara>
</listitem>
<listitem>
<simpara><literal>oslat</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Each tool has a specific use. Use the tools in sequence to achieve reliable test results.</simpara>
<variablelist>
<varlistentry>
<term>hwlatdetect</term>
<listitem>
<simpara>Measures the baseline that the bare-metal hardware can achieve. Before proceeding with the next latency test, ensure that the latency reported by <literal>hwlatdetect</literal> meets the required threshold because you cannot fix hardware latency spikes by operating system tuning.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>cyclictest</term>
<listitem>
<simpara>Verifies the real-time kernel scheduler latency after <literal>hwlatdetect</literal> passes validation. The <literal>cyclictest</literal> tool schedules a repeated timer and measures the difference between the desired and the actual trigger times. The difference can uncover basic issues with the tuning caused by interrupts or process priorities. The tool must run on a real-time kernel.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>oslat</term>
<listitem>
<simpara>Behaves similarly to a CPU-intensive DPDK application and measures all the interruptions and disruptions to the busy loop that simulates CPU heavy data processing.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The tests introduce the following environment variables:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Latency test environment variables</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Environment variables</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LATENCY_TEST_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the amount of time in seconds after which the test starts running. You can use the variable to allow the CPU manager reconcile loop to update the default CPU pool. The default value is 0.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LATENCY_TEST_CPUS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the number of CPUs that the pod running the latency tests uses. If you do not set the variable, the default configuration includes all isolated CPUs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LATENCY_TEST_RUNTIME</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the amount of time in seconds that the latency test must run. The default value is 300 seconds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HWLATDETECT_MAXIMUM_LATENCY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the maximum acceptable hardware latency in microseconds for the workload and operating system. If you do not set the value of <literal>HWLATDETECT_MAXIMUM_LATENCY</literal> or <literal>MAXIMUM_LATENCY</literal>, the tool compares the default expected threshold (20s) and the actual maximum latency in the tool itself. Then, the test fails or succeeds accordingly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CYCLICTEST_MAXIMUM_LATENCY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the maximum latency in microseconds that all threads expect before waking up during the <literal>cyclictest</literal> run. If you do not set the value of <literal>CYCLICTEST_MAXIMUM_LATENCY</literal> or <literal>MAXIMUM_LATENCY</literal>, the tool skips the comparison of the expected and the actual maximum latency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OSLAT_MAXIMUM_LATENCY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the maximum acceptable latency in microseconds for the <literal>oslat</literal> test results. If you do not set the value of <literal>OSLAT_MAXIMUM_LATENCY</literal> or <literal>MAXIMUM_LATENCY</literal>, the tool skips the comparison of the expected and the actual maximum latency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MAXIMUM_LATENCY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unified variable that specifies the maximum acceptable latency in microseconds. Applicable for all available latency tools.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Variables that are specific to a latency tool take precedence over unified variables. For example, if <literal>OSLAT_MAXIMUM_LATENCY</literal> is set to 30 microseconds and <literal>MAXIMUM_LATENCY</literal> is set to 10 microseconds, the <literal>oslat</literal> test will run with maximum acceptable latency of 30 microseconds.</simpara>
</note>
</section>
<section xml:id="cnf-performing-end-to-end-tests-running-the-tests_cnf-latency-tests">
<title>Running the latency tests</title>
<simpara>Run the cluster latency tests to validate node tuning for your Cloud-native Network Functions (CNF) workload.</simpara>
<note>
<simpara>When executing <literal>podman</literal> commands as a non-root or non-privileged user, mounting paths can fail with <literal>permission denied</literal> errors. To make the <literal>podman</literal> command work, append <literal>:Z</literal> to the volumes creation; for example, <literal>-v $(pwd)/:/kubeconfig:Z</literal>. This allows <literal>podman</literal> to do the proper SELinux relabeling.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open a shell prompt in the directory containing the <literal>kubeconfig</literal> file.</simpara>
<simpara>You provide the test image with a <literal>kubeconfig</literal> file in current directory and its related <literal>$KUBECONFIG</literal> environment variable, mounted through a volume. This allows the running container to use the <literal>kubeconfig</literal> file from inside the container.</simpara>
</listitem>
<listitem>
<simpara>Run the latency tests by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_RUNTIME=&lt;time_in_seconds&gt;\
-e MAXIMUM_LATENCY=&lt;time_in_microseconds&gt; \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 /usr/bin/test-run.sh \
--ginkgo.v</programlisting>
</listitem>
<listitem>
<simpara>Optional: Append <literal>--ginkgo.dryRun</literal> flag to run the latency tests in dry-run mode. This is useful for checking what commands the tests run.</simpara>
</listitem>
<listitem>
<simpara>Optional: Append <literal>--ginkgo.v</literal> flag to run the tests with increased verbosity.</simpara>
<important>
<simpara>The default runtime for each test is 300 seconds.
For valid latency test results, run the tests for at least 12 hours by updating the <literal>LATENCY_TEST_RUNTIME</literal> variable.</simpara>
</important>
</listitem>
</orderedlist>
<section xml:id="cnf-performing-end-to-end-tests-running-hwlatdetect_cnf-latency-tests">
<title>Running hwlatdetect</title>
<simpara>The <literal>hwlatdetect</literal> tool is available in the <literal>rt-kernel</literal> package with a regular subscription of Red Hat Enterprise Linux (RHEL) 9.x.</simpara>
<note>
<simpara>When executing <literal>podman</literal> commands as a non-root or non-privileged user, mounting paths can fail with <literal>permission denied</literal> errors. To make the <literal>podman</literal> command work, append <literal>:Z</literal> to the volumes creation; for example, <literal>-v $(pwd)/:/kubeconfig:Z</literal>. This allows <literal>podman</literal> to do the proper SELinux relabeling.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the real-time kernel in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have logged in to <literal>registry.redhat.io</literal> with your Customer Portal credentials.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To run the <literal>hwlatdetect</literal> tests, run the following command, substituting variable values as appropriate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_RUNTIME=600 -e MAXIMUM_LATENCY=20 \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --ginkgo.focus="hwlatdetect" --ginkgo.v</programlisting>
<simpara>The <literal>hwlatdetect</literal> test runs for 10 minutes (600 seconds). The test runs successfully when the maximum observed latency is lower than <literal>MAXIMUM_LATENCY</literal> (20 s).</simpara>
<simpara>If the results exceed the latency threshold, the test fails.</simpara>
<important>
<simpara>For valid results, the test should run for at least 12 hours.</simpara>
</important>
<formalpara>
<title>Example failure output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">running /usr/bin/cnftests -ginkgo.v -ginkgo.focus=hwlatdetect
I0908 15:25:20.023712      27 request.go:601] Waited for 1.046586367s due to client-side throttling, not priority and fairness, request: GET:https://api.hlxcl6.lab.eng.tlv2.redhat.com:6443/apis/imageregistry.operator.openshift.io/v1?timeout=32s
Running Suite: CNF Features e2e integration tests
=================================================
Random Seed: 1662650718
Will run 1 of 3 specs

[...]

 Failure [283.574 seconds]
[performance] Latency Test
/remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:62
  with the hwlatdetect image
  /remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:228
    should succeed [It]
    /remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:236

    Log file created at: 2022/09/08 15:25:27
    Running on machine: hwlatdetect-b6n4n
    Binary: Built with gc go1.17.12 for linux/amd64
    Log line format: [IWEF]mmdd hh:mm:ss.uuuuuu threadid file:line] msg
    I0908 15:25:27.160620       1 node.go:39] Environment information: /proc/cmdline: BOOT_IMAGE=(hd1,gpt3)/ostree/rhcos-c6491e1eedf6c1f12ef7b95e14ee720bf48359750ac900b7863c625769ef5fb9/vmlinuz-4.18.0-372.19.1.el8_6.x86_64 random.trust_cpu=on console=tty0 console=ttyS0,115200n8 ignition.platform.id=metal ostree=/ostree/boot.1/rhcos/c6491e1eedf6c1f12ef7b95e14ee720bf48359750ac900b7863c625769ef5fb9/0 ip=dhcp root=UUID=5f80c283-f6e6-4a27-9b47-a287157483b2 rw rootflags=prjquota boot=UUID=773bf59a-bafd-48fc-9a87-f62252d739d3 skew_tick=1 nohz=on rcu_nocbs=0-3 tuned.non_isolcpus=0000ffff,ffffffff,fffffff0 systemd.cpu_affinity=4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79 intel_iommu=on iommu=pt isolcpus=managed_irq,0-3 nohz_full=0-3 tsc=nowatchdog nosoftlockup nmi_watchdog=0 mce=off skew_tick=1 rcutree.kthread_prio=11 + +
    I0908 15:25:27.160830       1 node.go:46] Environment information: kernel version 4.18.0-372.19.1.el8_6.x86_64
    I0908 15:25:27.160857       1 main.go:50] running the hwlatdetect command with arguments [/usr/bin/hwlatdetect --threshold 1 --hardlimit 1 --duration 100 --window 10000000us --width 950000us]
    F0908 15:27:10.603523       1 main.go:53] failed to run hwlatdetect command; out: hwlatdetect:  test duration 100 seconds
       detector: tracer
       parameters:
            Latency threshold: 1us <co xml:id="CO40-1"/>
            Sample window:     10000000us
            Sample width:      950000us
         Non-sampling period:  9050000us
            Output File:       None

    Starting test
    test finished
    Max Latency: 326us <co xml:id="CO40-2"/>
    Samples recorded: 5
    Samples exceeding threshold: 5
    ts: 1662650739.017274507, inner:6, outer:6
    ts: 1662650749.257272414, inner:14, outer:326
    ts: 1662650779.977272835, inner:314, outer:12
    ts: 1662650800.457272384, inner:3, outer:9
    ts: 1662650810.697273520, inner:3, outer:2

[...]

JUnit report was created: /junit.xml/cnftests-junit.xml


Summarizing 1 Failure:

[Fail] [performance] Latency Test with the hwlatdetect image [It] should succeed
/remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:476

Ran 1 of 194 Specs in 365.797 seconds
FAIL! -- 0 Passed | 1 Failed | 0 Pending | 2 Skipped
--- FAIL: TestTest (366.08s)
FAIL</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO40-1">
<para>You can configure the latency threshold by using the <literal>MAXIMUM_LATENCY</literal> or the <literal>HWLATDETECT_MAXIMUM_LATENCY</literal> environment variables.</para>
</callout>
<callout arearefs="CO40-2">
<para>The maximum latency value measured during the test.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="cnf-performing-end-to-end-tests-example-results-hwlatdetect_cnf-latency-tests" renderas="sect4">Example hwlatdetect test results</bridgehead>
<simpara>You can capture the following types of results:</simpara>
<itemizedlist>
<listitem>
<simpara>Rough results that are gathered after each run to create a history of impact on any changes made throughout the test.</simpara>
</listitem>
<listitem>
<simpara>The combined set of the rough tests with the best results and configuration settings.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example of good results</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">hwlatdetect: test duration 3600 seconds
detector: tracer
parameters:
Latency threshold: 10us
Sample window: 1000000us
Sample width: 950000us
Non-sampling period: 50000us
Output File: None

Starting test
test finished
Max Latency: Below threshold
Samples recorded: 0</programlisting>
</para>
</formalpara>
<simpara>The <literal>hwlatdetect</literal> tool only provides output if the sample exceeds the specified threshold.</simpara>
<formalpara>
<title>Example of bad results</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">hwlatdetect: test duration 3600 seconds
detector: tracer
parameters:Latency threshold: 10usSample window: 1000000us
Sample width: 950000usNon-sampling period: 50000usOutput File: None

Starting tests:1610542421.275784439, inner:78, outer:81
ts: 1610542444.330561619, inner:27, outer:28
ts: 1610542445.332549975, inner:39, outer:38
ts: 1610542541.568546097, inner:47, outer:32
ts: 1610542590.681548531, inner:13, outer:17
ts: 1610543033.818801482, inner:29, outer:30
ts: 1610543080.938801990, inner:90, outer:76
ts: 1610543129.065549639, inner:28, outer:39
ts: 1610543474.859552115, inner:28, outer:35
ts: 1610543523.973856571, inner:52, outer:49
ts: 1610543572.089799738, inner:27, outer:30
ts: 1610543573.091550771, inner:34, outer:28
ts: 1610543574.093555202, inner:116, outer:63</programlisting>
</para>
</formalpara>
<simpara>The output of <literal>hwlatdetect</literal> shows that multiple samples exceed the threshold. However, the same output can indicate different results based on the following factors:</simpara>
<itemizedlist>
<listitem>
<simpara>The duration of the test</simpara>
</listitem>
<listitem>
<simpara>The number of CPU cores</simpara>
</listitem>
<listitem>
<simpara>The host firmware settings</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Before proceeding with the next latency test, ensure that the latency reported by <literal>hwlatdetect</literal> meets the required threshold. Fixing latencies introduced by hardware might require you to contact the system vendor support.</simpara>
<simpara>Not all latency spikes are hardware related. Ensure that you tune the host firmware to meet your workload requirements. For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/9/html-single/optimizing_rhel_9_for_real_time_for_low_latency_operation/index#setting-bios-parameters-for-system-tuning_optimizing-RHEL9-for-real-time-for-low-latency-operation">Setting firmware parameters for system tuning</link>.</simpara>
</warning>
</section>
<section xml:id="cnf-performing-end-to-end-tests-running-cyclictest_cnf-latency-tests">
<title>Running cyclictest</title>
<simpara>The <literal>cyclictest</literal> tool measures the real-time kernel scheduler latency on the specified CPUs.</simpara>
<note>
<simpara>When executing <literal>podman</literal> commands as a non-root or non-privileged user, mounting paths can fail with <literal>permission denied</literal> errors. To make the <literal>podman</literal> command work, append <literal>:Z</literal> to the volumes creation; for example, <literal>-v $(pwd)/:/kubeconfig:Z</literal>. This allows <literal>podman</literal> to do the proper SELinux relabeling.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have logged in to <literal>registry.redhat.io</literal> with your Customer Portal credentials.</simpara>
</listitem>
<listitem>
<simpara>You have installed the real-time kernel in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have applied a cluster performance profile by using Node Tuning Operator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To perform the <literal>cyclictest</literal>, run the following command, substituting variable values as appropriate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_CPUS=10 -e LATENCY_TEST_RUNTIME=600 -e MAXIMUM_LATENCY=20 \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --ginkgo.focus="cyclictest" --ginkgo.v</programlisting>
<simpara>The command runs the <literal>cyclictest</literal> tool for 10 minutes (600 seconds). The test runs successfully when the maximum observed latency is lower than <literal>MAXIMUM_LATENCY</literal> (in this example, 20 s). Latency spikes of 20 s and above are generally not acceptable for {rds} workloads.</simpara>
<simpara>If the results exceed the latency threshold, the test fails.</simpara>
<important>
<simpara>For valid results, the test should run for at least 12 hours.</simpara>
</important>
<formalpara>
<title>Example failure output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">running /usr/bin/cnftests -ginkgo.v -ginkgo.focus=cyclictest
I0908 13:01:59.193776      27 request.go:601] Waited for 1.046228824s due to client-side throttling, not priority and fairness, request: GET:https://api.compute-1.example.com:6443/apis/packages.operators.coreos.com/v1?timeout=32s
Running Suite: CNF Features e2e integration tests
=================================================
Random Seed: 1662642118
Will run 1 of 3 specs

[...]

Summarizing 1 Failure:

[Fail] [performance] Latency Test with the cyclictest image [It] should succeed
/remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:220

Ran 1 of 194 Specs in 161.151 seconds
FAIL! -- 0 Passed | 1 Failed | 0 Pending | 2 Skipped
--- FAIL: TestTest (161.48s)
FAIL</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="cnf-performing-end-to-end-tests-example-results-cyclictest_cnf-latency-tests" renderas="sect4">Example cyclictest results</bridgehead>
<simpara>The same output can indicate different results for different workloads. For example, spikes up to 18s are acceptable for 4G DU workloads, but not for 5G DU workloads.</simpara>
<formalpara>
<title>Example of good results</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">running cmd: cyclictest -q -D 10m -p 1 -t 16 -a 2,4,6,8,10,12,14,16,54,56,58,60,62,64,66,68 -h 30 -i 1000 -m
# Histogram
000000 000000   000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000
000001 000000   000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000
000002 579506   535967  418614  573648  532870  529897  489306  558076  582350  585188  583793  223781  532480  569130  472250  576043
More histogram entries ...
# Total: 000600000 000600000 000600000 000599999 000599999 000599999 000599998 000599998 000599998 000599997 000599997 000599996 000599996 000599995 000599995 000599995
# Min Latencies: 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002
# Avg Latencies: 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002
# Max Latencies: 00005 00005 00004 00005 00004 00004 00005 00005 00006 00005 00004 00005 00004 00004 00005 00004
# Histogram Overflows: 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000
# Histogram Overflow at cycle number:
# Thread 0:
# Thread 1:
# Thread 2:
# Thread 3:
# Thread 4:
# Thread 5:
# Thread 6:
# Thread 7:
# Thread 8:
# Thread 9:
# Thread 10:
# Thread 11:
# Thread 12:
# Thread 13:
# Thread 14:
# Thread 15:</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example of bad results</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">running cmd: cyclictest -q -D 10m -p 1 -t 16 -a 2,4,6,8,10,12,14,16,54,56,58,60,62,64,66,68 -h 30 -i 1000 -m
# Histogram
000000 000000   000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000
000001 000000   000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000  000000
000002 564632   579686  354911  563036  492543  521983  515884  378266  592621  463547  482764  591976  590409  588145  589556  353518
More histogram entries ...
# Total: 000599999 000599999 000599999 000599997 000599997 000599998 000599998 000599997 000599997 000599996 000599995 000599996 000599995 000599995 000599995 000599993
# Min Latencies: 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002
# Avg Latencies: 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002 00002
# Max Latencies: 00493 00387 00271 00619 00541 00513 00009 00389 00252 00215 00539 00498 00363 00204 00068 00520
# Histogram Overflows: 00001 00001 00001 00002 00002 00001 00000 00001 00001 00001 00002 00001 00001 00001 00001 00002
# Histogram Overflow at cycle number:
# Thread 0: 155922
# Thread 1: 110064
# Thread 2: 110064
# Thread 3: 110063 155921
# Thread 4: 110063 155921
# Thread 5: 155920
# Thread 6:
# Thread 7: 110062
# Thread 8: 110062
# Thread 9: 155919
# Thread 10: 110061 155919
# Thread 11: 155918
# Thread 12: 155918
# Thread 13: 110060
# Thread 14: 110060
# Thread 15: 110059 155917</programlisting>
</para>
</formalpara>
</section>
<section xml:id="cnf-performing-end-to-end-tests-running-oslat_cnf-latency-tests">
<title>Running oslat</title>
<simpara>The <literal>oslat</literal> test simulates a CPU-intensive DPDK application and measures all the interruptions and disruptions to test how the cluster handles CPU heavy data processing.</simpara>
<note>
<simpara>When executing <literal>podman</literal> commands as a non-root or non-privileged user, mounting paths can fail with <literal>permission denied</literal> errors. To make the <literal>podman</literal> command work, append <literal>:Z</literal> to the volumes creation; for example, <literal>-v $(pwd)/:/kubeconfig:Z</literal>. This allows <literal>podman</literal> to do the proper SELinux relabeling.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have logged in to <literal>registry.redhat.io</literal> with your Customer Portal credentials.</simpara>
</listitem>
<listitem>
<simpara>You have applied a cluster performance profile by using the Node Tuning Operator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To perform the <literal>oslat</literal> test, run the following command, substituting variable values as appropriate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_CPUS=10 -e LATENCY_TEST_RUNTIME=600 -e MAXIMUM_LATENCY=20 \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --ginkgo.focus="oslat" --ginkgo.v</programlisting>
<simpara><literal>LATENCY_TEST_CPUS</literal> specifies the number of CPUs to test with the <literal>oslat</literal> command.</simpara>
<simpara>The command runs the <literal>oslat</literal> tool for 10 minutes (600 seconds). The test runs successfully when the maximum observed latency is lower than <literal>MAXIMUM_LATENCY</literal> (20 s).</simpara>
<simpara>If the results exceed the latency threshold, the test fails.</simpara>
<important>
<simpara>For valid results, the test should run for at least 12 hours.</simpara>
</important>
<formalpara>
<title>Example failure output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">running /usr/bin/cnftests -ginkgo.v -ginkgo.focus=oslat
I0908 12:51:55.999393      27 request.go:601] Waited for 1.044848101s due to client-side throttling, not priority and fairness, request: GET:https://compute-1.example.com:6443/apis/machineconfiguration.openshift.io/v1?timeout=32s
Running Suite: CNF Features e2e integration tests
=================================================
Random Seed: 1662641514
Will run 1 of 3 specs

[...]

 Failure [77.833 seconds]
[performance] Latency Test
/remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:62
  with the oslat image
  /remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:128
    should succeed [It]
    /remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:153

    The current latency 304 is bigger than the expected one 1 : <co xml:id="CO41-1"/>

[...]

Summarizing 1 Failure:

[Fail] [performance] Latency Test with the oslat image [It] should succeed
/remote-source/app/vendor/github.com/openshift/cluster-node-tuning-operator/test/e2e/performanceprofile/functests/4_latency/latency.go:177

Ran 1 of 194 Specs in 161.091 seconds
FAIL! -- 0 Passed | 1 Failed | 0 Pending | 2 Skipped
--- FAIL: TestTest (161.42s)
FAIL</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO41-1">
<para>In this example, the measured latency is outside the maximum allowed value.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cnf-performing-end-to-end-tests-test-failure-report_cnf-latency-tests">
<title>Generating a latency test failure report</title>
<simpara>Use the following procedures to generate a JUnit latency test output and test failure report.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a test failure report with information about the cluster state and resources for troubleshooting by passing the <literal>--report</literal> parameter with the path to where the report is dumped:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -v $(pwd)/reportdest:&lt;report_folder_path&gt; \
-e KUBECONFIG=/kubeconfig/kubeconfig registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --report &lt;report_folder_path&gt; --ginkgo.v</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;report_folder_path&gt; </term>
<listitem>
<simpara>Is the path to the folder where the report is generated.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-performing-end-to-end-tests-junit-test-output_cnf-latency-tests">
<title>Generating a JUnit latency test report</title>
<simpara>Use the following procedures to generate a JUnit latency test output and test failure report.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a JUnit-compliant XML report by passing the <literal>--junit</literal> parameter together with the path to where the report is dumped:</simpara>
<note>
<simpara>You must create the <literal>junit</literal> folder before running this command.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -v $(pwd)/junit:/junit \
-e KUBECONFIG=/kubeconfig/kubeconfig registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --ginkgo.junit-report junit/&lt;file-name&gt;.xml --ginkgo.v</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>junit</literal> </term>
<listitem>
<simpara>Is the folder where the junit report is stored.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-performing-end-to-end-tests-running-in-single-node-cluster_cnf-latency-tests">
<title>Running latency tests on a single-node OpenShift cluster</title>
<simpara>You can run latency tests on single-node OpenShift clusters.</simpara>
<note>
<simpara>When executing <literal>podman</literal> commands as a non-root or non-privileged user, mounting paths can fail with <literal>permission denied</literal> errors. To make the <literal>podman</literal> command work, append <literal>:Z</literal> to the volumes creation; for example, <literal>-v $(pwd)/:/kubeconfig:Z</literal>. This allows <literal>podman</literal> to do the proper SELinux relabeling.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have applied a cluster performance profile by using the Node Tuning Operator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To run the latency tests on a single-node OpenShift cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_RUNTIME=&lt;time_in_seconds&gt; registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/test-run.sh --ginkgo.v</programlisting>
<note>
<simpara>The default runtime for each test is 300 seconds.
For valid latency test results, run the tests for at least 12 hours by updating the <literal>LATENCY_TEST_RUNTIME</literal> variable.
To run the buckets latency validation step, you must specify a maximum latency. For details on maximum latency variables, see the table in the "Measuring latency" section.</simpara>
</note>
<simpara>After running the test suite, all the dangling resources are cleaned up.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cnf-performing-end-to-end-tests-disconnected-mode_cnf-latency-tests">
<title>Running latency tests in a disconnected cluster</title>
<simpara>The CNF tests image can run tests in a disconnected cluster that is not able to reach external registries. This requires two steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mirroring the <literal>cnf-tests</literal> image to the custom disconnected registry.</simpara>
</listitem>
<listitem>
<simpara>Instructing the tests to consume the images from the custom disconnected registry.</simpara>
</listitem>
</orderedlist>
<bridgehead xml:id="cnf-performing-end-to-end-tests-mirroring-images-to-custom-registry_cnf-latency-tests" renderas="sect3">Mirroring the images to a custom registry accessible from the cluster</bridgehead>
<simpara>A <literal>mirror</literal> executable is shipped in the image to provide the input required by <literal>oc</literal> to mirror the test image to a local registry.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run this command from an intermediate machine that has access to the cluster and <link xlink:href="https://catalog.redhat.com/software/containers/explore">registry.redhat.io</link>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
/usr/bin/mirror -registry &lt;disconnected_registry&gt; | oc image mirror -f -</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;disconnected_registry&gt; </term>
<listitem>
<simpara>Is the disconnected mirror registry you have configured, for example, <literal>my.local.registry:5000/</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>When you have mirrored the <literal>cnf-tests</literal> image into the disconnected registry, you must override the original registry used to fetch the images when running the tests, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e IMAGE_REGISTRY="&lt;disconnected_registry&gt;" \
-e CNF_TESTS_IMAGE="cnf-tests-rhel8:v4.14" \
-e LATENCY_TEST_RUNTIME=&lt;time_in_seconds&gt; \
&lt;disconnected_registry&gt;/cnf-tests-rhel8:v4.14 /usr/bin/test-run.sh --ginkgo.v</programlisting>
</listitem>
</orderedlist>
<bridgehead xml:id="cnf-performing-end-to-end-tests-image-parameters_cnf-latency-tests" renderas="sect3">Configuring the tests to consume images from a custom registry</bridgehead>
<simpara>You can run the latency tests using a custom test image and image registry using <literal>CNF_TESTS_IMAGE</literal> and <literal>IMAGE_REGISTRY</literal> variables.</simpara>
<itemizedlist>
<listitem>
<simpara>To configure the latency tests to use a custom test image and image registry, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e IMAGE_REGISTRY="&lt;custom_image_registry&gt;" \
-e CNF_TESTS_IMAGE="&lt;custom_cnf-tests_image&gt;" \
-e LATENCY_TEST_RUNTIME=&lt;time_in_seconds&gt; \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 /usr/bin/test-run.sh --ginkgo.v</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;custom_image_registry&gt; </term>
<listitem>
<simpara>is the custom image registry, for example, <literal>custom.registry:5000/</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;custom_cnf-tests_image&gt; </term>
<listitem>
<simpara>is the custom cnf-tests image, for example, <literal>custom-cnf-tests-image:latest</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
<bridgehead xml:id="cnf-performing-end-to-end-tests-mirroring-to-cluster-internal-registry_cnf-latency-tests" renderas="sect3">Mirroring images to the cluster OpenShift image registry</bridgehead>
<simpara>OpenShift Container Platform provides a built-in container image registry, which runs as a standard workload on the cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Gain external access to the registry by exposing it with a route:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch configs.imageregistry.operator.openshift.io/cluster --patch '{"spec":{"defaultRoute":true}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Fetch the registry endpoint by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ REGISTRY=$(oc get route default-route -n openshift-image-registry --template='{{ .spec.host }}')</programlisting>
</listitem>
<listitem>
<simpara>Create a namespace for exposing the images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create ns cnftests</programlisting>
</listitem>
<listitem>
<simpara>Make the image stream available to all the namespaces used for tests. This is required to allow the tests namespaces to fetch the images from the <literal>cnf-tests</literal> image stream. Run the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user system:image-puller system:serviceaccount:cnf-features-testing:default --namespace=cnftests</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user system:image-puller system:serviceaccount:performance-addon-operators-testing:default --namespace=cnftests</programlisting>
</listitem>
<listitem>
<simpara>Retrieve the docker secret name and auth token by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ SECRET=$(oc -n cnftests get secret | grep builder-docker | awk {'print $1'}</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ TOKEN=$(oc -n cnftests get secret $SECRET -o jsonpath="{.data['\.dockercfg']}" | base64 --decode | jq '.["image-registry.openshift-image-registry.svc:5000"].auth')</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>dockerauth.json</literal> file, for example:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ echo "{\"auths\": { \"$REGISTRY\": { \"auth\": $TOKEN } }}" &gt; dockerauth.json</programlisting>
</listitem>
<listitem>
<simpara>Do the image mirroring:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
registry.redhat.io/openshift4/cnf-tests-rhel8:4.14 \
/usr/bin/mirror -registry $REGISTRY/cnftests |  oc image mirror --insecure=true \
-a=$(pwd)/dockerauth.json -f -</programlisting>
</listitem>
<listitem>
<simpara>Run the tests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
-e LATENCY_TEST_RUNTIME=&lt;time_in_seconds&gt; \
-e IMAGE_REGISTRY=image-registry.openshift-image-registry.svc:5000/cnftests cnf-tests-local:latest /usr/bin/test-run.sh --ginkgo.v</programlisting>
</listitem>
</orderedlist>
<bridgehead xml:id="mirroring-different-set-of-images_cnf-latency-tests" renderas="sect3">Mirroring a different set of test images</bridgehead>
<simpara>You can optionally change the default upstream images that are mirrored for the latency tests.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>The <literal>mirror</literal> command tries to mirror the upstream images by default. This can be overridden by passing a file with the following format to the image:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">[
    {
        "registry": "public.registry.io:5000",
        "image": "imageforcnftests:4.14"
    }
]</programlisting>
</listitem>
<listitem>
<simpara>Pass the file to the <literal>mirror</literal> command, for example saving it locally as <literal>images.json</literal>. With the following command, the local path is mounted in <literal>/kubeconfig</literal> inside the container and that can be passed to the mirror command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 /usr/bin/mirror \
--registry "my.local.registry:5000/" --images "/kubeconfig/images.json" \
|  oc image mirror -f -</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="cnf-performing-end-to-end-tests-troubleshooting_cnf-latency-tests">
<title>Troubleshooting errors with the cnf-tests container</title>
<simpara>To run latency tests, the cluster must be accessible from within the <literal>cnf-tests</literal> container.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Verify that the cluster is accessible from inside the <literal>cnf-tests</literal> container by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $(pwd)/:/kubeconfig:Z -e KUBECONFIG=/kubeconfig/kubeconfig \
registry.redhat.io/openshift4/cnf-tests-rhel8:v4.14 \
oc get nodes</programlisting>
<simpara>If this command does not work, an error related to spanning across DNS, MTU size, or firewall access might be occurring.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="scaling-worker-latency-profiles">
<title>Improving cluster stability in high latency environments using worker latency profiles</title>
<simpara>If the cluster administrator has performed latency tests for platform verification, they can discover the need to adjust the operation of the cluster to ensure stability in cases of high latency. The cluster administrator need change only one parameter, recorded in a file, which controls four parameters affecting how supervisory processes read status and interpret the health of the cluster. Changing only the one parameter provides cluster tuning in an easy, supportable manner.</simpara>
<simpara>The <literal>Kubelet</literal> process provides the starting point for monitoring cluster health. The <literal>Kubelet</literal> sets status values for all nodes in the OpenShift Container Platform cluster. The Kubernetes Controller Manager (<literal>kube controller</literal>) reads the status values every 10 seconds, by default.
If the <literal>kube controller</literal> cannot read a node status value, it loses contact with that node after a configured period. The default behavior is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The node controller on the control plane updates the node health to <literal>Unhealthy</literal> and marks the node <literal>Ready</literal> condition`Unknown`.</simpara>
</listitem>
<listitem>
<simpara>In response, the scheduler stops scheduling pods to that node.</simpara>
</listitem>
<listitem>
<simpara>The Node Lifecycle Controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to the node and schedules any pods on the node for eviction after five minutes, by default.</simpara>
</listitem>
</orderedlist>
<simpara>This behavior can cause problems if your network is prone to latency issues, especially if you have nodes at the network edge. In some cases, the Kubernetes Controller Manager might not receive an update from a healthy node due to network latency. The <literal>Kubelet</literal> evicts pods from the node even though the node is healthy.</simpara>
<simpara>To avoid this problem, you can use <emphasis>worker latency profiles</emphasis> to adjust the frequency that the <literal>Kubelet</literal> and the Kubernetes Controller Manager wait for status updates before taking action. These adjustments help to ensure that your cluster runs properly if network latency between the control plane and the worker nodes is not optimal.</simpara>
<simpara>These worker latency profiles contain three sets of parameters that are pre-defined with carefully tuned values to control the reaction of the cluster to increased latency. No need to experimentally find the best values manually.</simpara>
<simpara>You can configure worker latency profiles when installing a cluster or at any time you notice increased latency in your cluster network.</simpara>
<section xml:id="nodes-cluster-worker-latency-profiles-about_scaling-worker-latency-profiles">
<title>Understanding worker latency profiles</title>
<simpara>Worker latency profiles are four different categories of carefully-tuned parameters. The four parameters which implement these values are <literal>node-status-update-frequency</literal>, <literal>node-monitor-grace-period</literal>, <literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal>. These parameters can use values which allow you control the reaction of the cluster to latency issues without needing to determine the best values using manual methods.</simpara>
<important>
<simpara>Setting these parameters manually is not supported. Incorrect parameter settings adversely affect cluster stability.</simpara>
</important>
<simpara>All worker latency profiles configure the following parameters:</simpara>
<variablelist>
<varlistentry>
<term>node-status-update-frequency</term>
<listitem>
<simpara>Specifies how often the kubelet posts node status to the API server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>node-monitor-grace-period</term>
<listitem>
<simpara>Specifies the amount of time in seconds that the Kubernetes Controller Manager waits for an update from a kubelet before marking the node unhealthy and adding the <literal>node.kubernetes.io/not-ready</literal> or <literal>node.kubernetes.io/unreachable</literal> taint to the node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>default-not-ready-toleration-seconds</term>
<listitem>
<simpara>Specifies the amount of time in seconds after marking a node unhealthy that the Kube API Server Operator waits before evicting pods from that node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>default-unreachable-toleration-seconds</term>
<listitem>
<simpara>Specifies the amount of time in seconds after marking a node unreachable that the Kube API Server Operator waits before evicting pods from that node.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following Operators monitor the changes to the worker latency profiles and respond accordingly:</simpara>
<itemizedlist>
<listitem>
<simpara>The Machine Config Operator (MCO) updates the <literal>node-status-update-frequency</literal> parameter on the worker nodes.</simpara>
</listitem>
<listitem>
<simpara>The Kubernetes Controller Manager updates the <literal>node-monitor-grace-period</literal> parameter on the control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>The Kubernetes API Server Operator updates the <literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal> parameters on the control plane nodes.</simpara>
</listitem>
</itemizedlist>
<simpara>Although the default configuration works in most cases, OpenShift Container Platform offers two other worker latency profiles for situations where the network is experiencing higher latency than usual. The three worker latency profiles are described in the following sections:</simpara>
<variablelist>
<varlistentry>
<term>Default worker latency profile</term>
<listitem>
<simpara>With the <literal>Default</literal> profile, each <literal>Kubelet</literal> updates it&#8217;s status every 10 seconds (<literal>node-status-update-frequency</literal>). The <literal>Kube Controller Manager</literal> checks the statuses of <literal>Kubelet</literal> every 5 seconds (<literal>node-monitor-grace-period</literal>).</simpara>
<simpara>The Kubernetes Controller Manager waits 40 seconds for a status update from <literal>Kubelet</literal> before considering the <literal>Kubelet</literal> unhealthy. If no status is made available to the Kubernetes Controller Manager, it then marks the node with the <literal>node.kubernetes.io/not-ready</literal> or <literal>node.kubernetes.io/unreachable</literal> taint and evicts the pods on that node.</simpara>
<simpara>If a pod on that node has the <literal>NoExecute</literal> taint, the pod is run according to <literal>tolerationSeconds</literal>. If the pod has no taint, it will be evicted in 300 seconds (<literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal> settings of the <literal>Kube API Server</literal>).</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>10s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>40s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>300s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>300s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Medium worker latency profile</term>
<listitem>
<simpara>Use the <literal>MediumUpdateAverageReaction</literal> profile if the network latency is slightly higher than usual.</simpara>
<simpara>The <literal>MediumUpdateAverageReaction</literal> profile reduces the frequency of kubelet updates to 20 seconds and changes the period that the Kubernetes Controller Manager waits for those updates to 2 minutes. The pod eviction period for a pod on that node is reduced to 60 seconds. If the pod has the <literal>tolerationSeconds</literal> parameter, the eviction waits for the period specified by that parameter.</simpara>
<simpara>The Kubernetes Controller Manager waits for 2 minutes to consider a node unhealthy. In another minute, the eviction process starts.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>MediumUpdateAverageReaction</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>20s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>2m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Low worker latency profile</term>
<listitem>
<simpara>Use the <literal>LowUpdateSlowReaction</literal> profile if the network latency is extremely high.</simpara>
<simpara>The <literal>LowUpdateSlowReaction</literal> profile reduces the frequency of kubelet updates to 1 minute and changes the period that the Kubernetes Controller Manager waits for those updates to 5 minutes. The pod eviction period for a pod on that node is reduced to 60 seconds. If the pod has the <literal>tolerationSeconds</literal> parameter, the eviction waits for the period specified by that parameter.</simpara>
<simpara>The Kubernetes Controller Manager waits for 5 minutes to consider a node unhealthy. In another minute, the eviction process starts.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>LowUpdateSlowReaction</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>1m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>5m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-cluster-worker-latency-profiles-using-at-creation_scaling-worker-latency-profiles">
<title>Implementing worker latency profiles at cluster creation</title>
<important>
<simpara>To edit the configuration of the installer, you will first need to use the command <literal>openshift-install create manifests</literal> to create the default node manifest as well as other manifest YAML files. This file structure must exist before we can add workerLatencyProfile. The platform on which you are installing may have varying requirements. Refer to the Installing section of the documentation for your specific platform.</simpara>
</important>
<simpara>The <literal>workerLatencyProfile</literal> must be added to the manifest in the following sequence:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the manifest needed to build the cluster, using a folder name appropriate for your installation.</simpara>
</listitem>
<listitem>
<simpara>Create a YAML file to define <literal>config.node</literal>. The file must be in the <literal>manifests</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>When defining <literal>workerLatencyProfile</literal> in the manifest for the first time, specify any of the profiles at cluster creation time: <literal>Default</literal>, <literal>MediumUpdateAverageReaction</literal> or <literal>LowUpdateSlowReaction</literal>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Here is an example manifest creation showing the <literal>spec.workerLatencyProfile</literal> <literal>Default</literal> value in the manifest file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openshift-install create manifests --dir=&lt;cluster-install-dir&gt;</programlisting>
</listitem>
<listitem>
<simpara>Edit the manifest and add the value. In this example we use <literal>vi</literal> to show an example manifest file with the "Default" <literal>workerLatencyProfile</literal> value added:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ vi &lt;cluster-install-dir&gt;/manifests/config-node-default-profile.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Node
metadata:
name: cluster
spec:
workerLatencyProfile: "Default"</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cluster-worker-latency-profiles-using_scaling-worker-latency-profiles">
<title>Using and changing worker latency profiles</title>
<simpara>To change a worker latency profile to deal with network latency, edit the <literal>node.config</literal> object to add the name of the profile. You can change the profile at any time as latency increases or decreases.</simpara>
<simpara>You must move one worker latency profile at a time. For example, you cannot move directly from the <literal>Default</literal> profile to the <literal>LowUpdateSlowReaction</literal> worker latency profile. You must move from the <literal>Default</literal> worker latency profile to the <literal>MediumUpdateAverageReaction</literal> profile first, then to <literal>LowUpdateSlowReaction</literal>. Similarly, when returning to the <literal>Default</literal> profile, you must move from the low profile to the medium profile first, then to <literal>Default</literal>.</simpara>
<note>
<simpara>You can also configure worker latency profiles upon installing an OpenShift Container Platform cluster.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To move from the default worker latency profile:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Move to the medium worker latency profile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>node.config</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit nodes.config/cluster</programlisting>
</listitem>
<listitem>
<simpara>Add <literal>spec.workerLatencyProfile: MediumUpdateAverageReaction</literal>:</simpara>
<formalpara>
<title>Example <literal>node.config</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Node
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2022-07-08T16:02:51Z"
  generation: 1
  name: cluster
  ownerReferences:
  - apiVersion: config.openshift.io/v1
    kind: ClusterVersion
    name: version
    uid: 36282574-bf9f-409e-a6cd-3032939293eb
  resourceVersion: "1865"
  uid: 0c0f7a4c-4307-4187-b591-6155695ac85b
spec:
  workerLatencyProfile: MediumUpdateAverageReaction <co xml:id="CO42-1"/>

# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO42-1">
<para>Specifies the medium worker latency policy.</para>
</callout>
</calloutlist>
<simpara>Scheduling on each worker node is disabled as the change is being applied.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Move to the low worker latency profile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>node.config</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit nodes.config/cluster</programlisting>
</listitem>
<listitem>
<simpara>Change the <literal>spec.workerLatencyProfile</literal> value to <literal>LowUpdateSlowReaction</literal>:</simpara>
<formalpara>
<title>Example <literal>node.config</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Node
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2022-07-08T16:02:51Z"
  generation: 1
  name: cluster
  ownerReferences:
  - apiVersion: config.openshift.io/v1
    kind: ClusterVersion
    name: version
    uid: 36282574-bf9f-409e-a6cd-3032939293eb
  resourceVersion: "1865"
  uid: 0c0f7a4c-4307-4187-b591-6155695ac85b
spec:
  workerLatencyProfile: LowUpdateSlowReaction <co xml:id="CO43-1"/>

# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO43-1">
<para>Specifies use of the low worker latency policy.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>Scheduling on each worker node is disabled as the change is being applied.</simpara>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>When all nodes return to the <literal>Ready</literal> condition, you can use the following command to look in the Kubernetes Controller Manager to ensure it was applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get KubeControllerManager -o yaml | grep -i workerlatency -A 5 -B 5</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># ...
    - lastTransitionTime: "2022-07-11T19:47:10Z"
      reason: ProfileUpdated
      status: "False"
      type: WorkerLatencyProfileProgressing
    - lastTransitionTime: "2022-07-11T19:47:10Z" <co xml:id="CO44-1"/>
      message: all static pod revision(s) have updated latency profile
      reason: ProfileUpdated
      status: "True"
      type: WorkerLatencyProfileComplete
    - lastTransitionTime: "2022-07-11T19:20:11Z"
      reason: AsExpected
      status: "False"
      type: WorkerLatencyProfileDegraded
    - lastTransitionTime: "2022-07-11T19:20:36Z"
      status: "False"
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>Specifies that the profile is applied and active.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<simpara>To change the medium profile to default or change the default to medium, edit the <literal>node.config</literal> object and set the <literal>spec.workerLatencyProfile</literal> parameter to the appropriate value.</simpara>
</section>
<section xml:id="nodes-cluster-worker-latency-profiles-examining_scaling-worker-latency-profiles">
<title>Example steps for displaying resulting values of workerLatencyProfile</title>
<simpara>You can display the values in the <literal>workerLatencyProfile</literal> with the following commands.</simpara>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the <literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal> fields output by the Kube API Server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get KubeAPIServer -o yaml | grep -A 1 default-</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">default-not-ready-toleration-seconds:
- "300"
default-unreachable-toleration-seconds:
- "300"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the values of the <literal>node-monitor-grace-period</literal> field from the Kube Controller Manager:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get KubeControllerManager -o yaml | grep -A 1 node-monitor</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node-monitor-grace-period:
- 40s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>nodeStatusUpdateFrequency</literal> value from the Kubelet. Set the directory <literal>/host</literal> as the root directory within the debug shell. By changing the root directory to <literal>/host</literal>, you can run binaries contained in the hosts executable paths:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;worker-node-name&gt;
$ chroot /host
# cat /etc/kubernetes/kubelet.conf|grep nodeStatusUpdateFrequency</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  nodeStatusUpdateFrequency: 10s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>These outputs validate the set of timing variables for the Worker Latency Profile.</simpara>
</section>
</chapter>
<chapter xml:id="cnf-create-performance-profiles">
<title>Creating a performance profile</title>
<simpara>Learn about the Performance Profile Creator (PPC) and how you can use it to create a performance profile.</simpara>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<section xml:id="cnf-about-the-profile-creator-tool_cnf-create-performance-profiles">
<title>About the Performance Profile Creator</title>
<simpara>The Performance Profile Creator (PPC) is a command-line tool, delivered with the Node Tuning Operator, used to create the performance profile.
The tool consumes <literal>must-gather</literal> data from the cluster and several user-supplied profile arguments. The PPC generates a performance profile that is appropriate for your hardware and topology.</simpara>
<simpara>The tool is run by one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Invoking <literal>podman</literal></simpara>
</listitem>
<listitem>
<simpara>Calling a wrapper script</simpara>
</listitem>
</itemizedlist>
<section xml:id="gathering-data-about-your-cluster-using-must-gather_cnf-create-performance-profiles">
<title>Gathering data about your cluster using the must-gather command</title>
<simpara>The Performance Profile Creator (PPC) tool requires <literal>must-gather</literal> data. As a cluster administrator, run the <literal>must-gather</literal> command to capture information about your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Verify that a matching machine config pool exists with a label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe mcp/worker-rt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         worker-rt
Namespace:
Labels:       machineconfiguration.openshift.io/role=worker-rt</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If a matching label does not exist add a label for a machine config pool (MCP) that matches with the MCP name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label mcp &lt;mcp_name&gt; &lt;mcp_name&gt;=""</programlisting>
</listitem>
<listitem>
<simpara>Navigate to the directory where you want to store the <literal>must-gather</literal> data.</simpara>
</listitem>
<listitem>
<simpara>Collect cluster information by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather</programlisting>
</listitem>
<listitem>
<simpara>Optional: Create a compressed file from the <literal>must-gather</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar cvaf must-gather.tar.gz must-gather/</programlisting>
<note>
<simpara>Compressed output is required if you are running the Performance Profile Creator wrapper script.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="running-the-performance-profile-profile-cluster-using-podman_cnf-create-performance-profiles">
<title>Running the Performance Profile Creator using podman</title>
<simpara>As a cluster administrator, you can run <literal>podman</literal> and the Performance Profile Creator to create a performance profile.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>A cluster installed on bare-metal hardware.</simpara>
</listitem>
<listitem>
<simpara>A node with <literal>podman</literal> and OpenShift CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the Node Tuning Operator image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the machine config pool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         CONFIG                                                 UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master       rendered-master-acd1358917e9f98cbdb599aea622d78b       True      False      False      3              3                   3                     0                      22h
worker-cnf   rendered-worker-cnf-1d871ac76e1951d32b2fe92369879826   False     True       False      2              1                   1                     0                      22h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use Podman to authenticate to <literal>registry.redhat.io</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login registry.redhat.io</programlisting>
<programlisting language="bash" linenumbering="unnumbered">Username: &lt;username&gt;
Password: &lt;password&gt;</programlisting>
</listitem>
<listitem>
<simpara>Optional: Display help for the PPC tool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --rm --entrypoint performance-profile-creator registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14 -h</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">A tool that automates creation of Performance Profiles

Usage:
  performance-profile-creator [flags]

Flags:
      --disable-ht                        Disable Hyperthreading
  -h, --help                              help for performance-profile-creator
      --info string                       Show cluster information; requires --must-gather-dir-path, ignore the other arguments. [Valid values: log, json] (default "log")
      --mcp-name string                   MCP name corresponding to the target machines (required)
      --must-gather-dir-path string       Must gather directory path (default "must-gather")
      --offlined-cpu-count int            Number of offlined CPUs
      --per-pod-power-management          Enable Per Pod Power Management
      --power-consumption-mode string     The power consumption mode.  [Valid values: default, low-latency, ultra-low-latency] (default "default")
      --profile-name string               Name of the performance profile to be created (default "performance")
      --reserved-cpu-count int            Number of reserved CPUs (required)
      --rt-kernel                         Enable Real Time Kernel (required)
      --split-reserved-cpus-across-numa   Split the Reserved CPUs across NUMA nodes
      --topology-manager-policy string    Kubelet Topology Manager Policy of the performance profile to be created. [Valid values: single-numa-node, best-effort, restricted] (default "restricted")
      --user-level-networking             Run with User level Networking(DPDK) enabled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the Performance Profile Creator tool in discovery mode:</simpara>
<note>
<simpara>Discovery mode inspects your cluster using the output from <literal>must-gather</literal>. The output produced includes information on:</simpara>
<itemizedlist>
<listitem>
<simpara>The NUMA cell partitioning with the allocated CPU ids</simpara>
</listitem>
<listitem>
<simpara>Whether hyperthreading is enabled</simpara>
</listitem>
</itemizedlist>
<simpara>Using this information you can set appropriate values for some of the arguments supplied to the Performance Profile Creator tool.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --entrypoint performance-profile-creator -v &lt;path_to_must-gather&gt;/must-gather:/must-gather:z registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14 --info log --must-gather-dir-path /must-gather</programlisting>
<note>
<simpara>This command uses the performance profile creator as a new entry point to <literal>podman</literal>. It maps the <literal>must-gather</literal> data for the host into the container image and invokes the required user-supplied profile arguments to produce the <literal>my-performance-profile.yaml</literal> file.</simpara>
<simpara>The <literal>-v</literal> option can be the path to either:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>must-gather</literal> output directory</simpara>
</listitem>
<listitem>
<simpara>An existing directory containing the <literal>must-gather</literal> decompressed tarball</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>info</literal> option requires a value which specifies the output format. Possible values are log and JSON. The JSON format is reserved for debugging.</simpara>
</note>
</listitem>
<listitem>
<simpara>Run <literal>podman</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --entrypoint performance-profile-creator -v /must-gather:/must-gather:z registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14 --mcp-name=worker-cnf --reserved-cpu-count=4 --rt-kernel=true --split-reserved-cpus-across-numa=false --must-gather-dir-path /must-gather --power-consumption-mode=ultra-low-latency --offlined-cpu-count=6 &gt; my-performance-profile.yaml</programlisting>
<note>
<simpara>The Performance Profile Creator arguments are shown in the Performance Profile Creator arguments table. The following arguments are required:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>reserved-cpu-count</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mcp-name</literal></simpara>
</listitem>
<listitem>
<simpara><literal>rt-kernel</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>mcp-name</literal> argument in this example is set to <literal>worker-cnf</literal> based on the output of the command <literal>oc get mcp</literal>. For single-node OpenShift use <literal>--mcp-name=master</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the created YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat my-performance-profile.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: performance
spec:
  cpu:
    isolated: 2-39,48-79
    offlined: 42-47
    reserved: 0-1,40-41
  machineConfigPoolSelector:
    machineconfiguration.openshift.io/role: worker-cnf
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""
  numa:
    topologyPolicy: restricted
  realTimeKernel:
    enabled: true
  workloadHints:
    highPowerConsumption: true
    realTime: true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the generated profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f my-performance-profile.yaml</programlisting>
</listitem>
</orderedlist>
<section xml:id="how-to-run-podman-to-create-a-profile_cnf-create-performance-profiles">
<title>How to run <literal>podman</literal> to create a performance profile</title>
<simpara>The following example illustrates how to run <literal>podman</literal> to create a performance profile with 20 reserved CPUs that are to be split across the NUMA nodes.</simpara>
<simpara>Node hardware configuration:</simpara>
<itemizedlist>
<listitem>
<simpara>80 CPUs</simpara>
</listitem>
<listitem>
<simpara>Hyperthreading enabled</simpara>
</listitem>
<listitem>
<simpara>Two NUMA nodes</simpara>
</listitem>
<listitem>
<simpara>Even numbered CPUs run on NUMA node 0 and odd numbered CPUs run on NUMA node 1</simpara>
</listitem>
</itemizedlist>
<simpara>Run <literal>podman</literal> to create the performance profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --entrypoint performance-profile-creator -v /must-gather:/must-gather:z registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14 --mcp-name=worker-cnf --reserved-cpu-count=20 --rt-kernel=true --split-reserved-cpus-across-numa=true --must-gather-dir-path /must-gather &gt; my-performance-profile.yaml</programlisting>
<simpara>The created profile is described in the following YAML:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: performance.openshift.io/v2
  kind: PerformanceProfile
  metadata:
    name: performance
  spec:
    cpu:
      isolated: 10-39,50-79
      reserved: 0-9,40-49
    nodeSelector:
      node-role.kubernetes.io/worker-cnf: ""
    numa:
      topologyPolicy: restricted
    realTimeKernel:
      enabled: true</programlisting>
<note>
<simpara>In this case, 10 CPUs are reserved on NUMA node 0 and 10 are reserved on NUMA node 1.</simpara>
</note>
</section>
</section>
<section xml:id="running-the-performance-profile-creator-wrapper-script_cnf-create-performance-profiles">
<title>Running the Performance Profile Creator wrapper script</title>
<simpara>The performance profile wrapper script simplifies the running of the Performance Profile Creator (PPC) tool. It hides the complexities associated with running <literal>podman</literal> and specifying the mapping directories and it enables the creation of the performance profile.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the Node Tuning Operator image.</simpara>
</listitem>
<listitem>
<simpara>Access to the <literal>must-gather</literal> tarball.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file on your local machine named, for example, <literal>run-perf-profile-creator.sh</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ vi run-perf-profile-creator.sh</programlisting>
</listitem>
<listitem>
<simpara>Paste the following code into the file:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

readonly CONTAINER_RUNTIME=${CONTAINER_RUNTIME:-podman}
readonly CURRENT_SCRIPT=$(basename "$0")
readonly CMD="${CONTAINER_RUNTIME} run --entrypoint performance-profile-creator"
readonly IMG_EXISTS_CMD="${CONTAINER_RUNTIME} image exists"
readonly IMG_PULL_CMD="${CONTAINER_RUNTIME} image pull"
readonly MUST_GATHER_VOL="/must-gather"

NTO_IMG="registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14"
MG_TARBALL=""
DATA_DIR=""

usage() {
  print "Wrapper usage:"
  print "  ${CURRENT_SCRIPT} [-h] [-p image][-t path] -- [performance-profile-creator flags]"
  print ""
  print "Options:"
  print "   -h                 help for ${CURRENT_SCRIPT}"
  print "   -p                 Node Tuning Operator image"
  print "   -t                 path to a must-gather tarball"

  ${IMG_EXISTS_CMD} "${NTO_IMG}" &amp;&amp; ${CMD} "${NTO_IMG}" -h
}

function cleanup {
  [ -d "${DATA_DIR}" ] &amp;&amp; rm -rf "${DATA_DIR}"
}
trap cleanup EXIT

exit_error() {
  print "error: $*"
  usage
  exit 1
}

print() {
  echo  "$*" &gt;&amp;2
}

check_requirements() {
  ${IMG_EXISTS_CMD} "${NTO_IMG}" || ${IMG_PULL_CMD} "${NTO_IMG}" || \
      exit_error "Node Tuning Operator image not found"

  [ -n "${MG_TARBALL}" ] || exit_error "Must-gather tarball file path is mandatory"
  [ -f "${MG_TARBALL}" ] || exit_error "Must-gather tarball file not found"

  DATA_DIR=$(mktemp -d -t "${CURRENT_SCRIPT}XXXX") || exit_error "Cannot create the data directory"
  tar -zxf "${MG_TARBALL}" --directory "${DATA_DIR}" || exit_error "Cannot decompress the must-gather tarball"
  chmod a+rx "${DATA_DIR}"

  return 0
}

main() {
  while getopts ':hp:t:' OPT; do
    case "${OPT}" in
      h)
        usage
        exit 0
        ;;
      p)
        NTO_IMG="${OPTARG}"
        ;;
      t)
        MG_TARBALL="${OPTARG}"
        ;;
      ?)
        exit_error "invalid argument: ${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND - 1))

  check_requirements || exit 1

  ${CMD} -v "${DATA_DIR}:${MUST_GATHER_VOL}:z" "${NTO_IMG}" "$@" --must-gather-dir-path "${MUST_GATHER_VOL}"
  echo "" 1&gt;&amp;2
}

main "$@"</programlisting>
</listitem>
<listitem>
<simpara>Add execute permissions for everyone on this script:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod a+x run-perf-profile-creator.sh</programlisting>
</listitem>
<listitem>
<simpara>Optional: Display the <literal>run-perf-profile-creator.sh</literal> command usage:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ./run-perf-profile-creator.sh -h</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Wrapper usage:
  run-perf-profile-creator.sh [-h] [-p image][-t path] -- [performance-profile-creator flags]

Options:
   -h                 help for run-perf-profile-creator.sh
   -p                 Node Tuning Operator image <co xml:id="CO45-1"/>
   -t                 path to a must-gather tarball <co xml:id="CO45-2"/>
A tool that automates creation of Performance Profiles

Usage:
  performance-profile-creator [flags]

Flags:
      --disable-ht                        Disable Hyperthreading
  -h, --help                              help for performance-profile-creator
      --info string                       Show cluster information; requires --must-gather-dir-path, ignore the other arguments. [Valid values: log, json] (default "log")
      --mcp-name string                   MCP name corresponding to the target machines (required)
      --must-gather-dir-path string       Must gather directory path (default "must-gather")
      --offlined-cpu-count int            Number of offlined CPUs
      --per-pod-power-management          Enable Per Pod Power Management
      --power-consumption-mode string     The power consumption mode.  [Valid values: default, low-latency, ultra-low-latency] (default "default")
      --profile-name string               Name of the performance profile to be created (default "performance")
      --reserved-cpu-count int            Number of reserved CPUs (required)
      --rt-kernel                         Enable Real Time Kernel (required)
      --split-reserved-cpus-across-numa   Split the Reserved CPUs across NUMA nodes
      --topology-manager-policy string    Kubelet Topology Manager Policy of the performance profile to be created. [Valid values: single-numa-node, best-effort, restricted] (default "restricted")
      --user-level-networking             Run with User level Networking(DPDK) enabled</programlisting>
</para>
</formalpara>
<note>
<simpara>There two types of arguments:</simpara>
<itemizedlist>
<listitem>
<simpara>Wrapper arguments namely <literal>-h</literal>, <literal>-p</literal> and <literal>-t</literal></simpara>
</listitem>
<listitem>
<simpara>PPC arguments</simpara>
</listitem>
</itemizedlist>
</note>
<calloutlist>
<callout arearefs="CO45-1">
<para>Optional: Specify the Node Tuning Operator image. If not set, the default upstream image is used: <literal>registry.redhat.io/openshift4/ose-cluster-node-tuning-operator:v4.14</literal>.</para>
</callout>
<callout arearefs="CO45-2">
<para><literal>-t</literal> is a required wrapper script argument and specifies the path to a <literal>must-gather</literal> tarball.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the performance profile creator tool in discovery mode:</simpara>
<note>
<simpara>Discovery mode inspects your cluster using the output from <literal>must-gather</literal>. The output produced includes information on:</simpara>
<itemizedlist>
<listitem>
<simpara>The NUMA cell partitioning with the allocated CPU IDs</simpara>
</listitem>
<listitem>
<simpara>Whether hyperthreading is enabled</simpara>
</listitem>
</itemizedlist>
<simpara>Using this information you can set appropriate values for some of the arguments supplied to the Performance Profile Creator tool.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ ./run-perf-profile-creator.sh -t /must-gather/must-gather.tar.gz -- --info=log</programlisting>
<note>
<simpara>The <literal>info</literal> option requires a value which specifies the output format. Possible values are log and JSON. The JSON format is reserved for debugging.</simpara>
</note>
</listitem>
<listitem>
<simpara>Check the machine config pool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         CONFIG                                                 UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master       rendered-master-acd1358917e9f98cbdb599aea622d78b       True      False      False      3              3                   3                     0                      22h
worker-cnf   rendered-worker-cnf-1d871ac76e1951d32b2fe92369879826   False     True       False      2              1                   1                     0                      22h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a performance profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ./run-perf-profile-creator.sh -t /must-gather/must-gather.tar.gz -- --mcp-name=worker-cnf --reserved-cpu-count=2 --rt-kernel=true &gt; my-performance-profile.yaml</programlisting>
<note>
<simpara>The Performance Profile Creator arguments are shown in the Performance Profile Creator arguments table. The following arguments are required:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>reserved-cpu-count</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mcp-name</literal></simpara>
</listitem>
<listitem>
<simpara><literal>rt-kernel</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>mcp-name</literal> argument in this example is set to <literal>worker-cnf</literal> based on the output of the command <literal>oc get mcp</literal>. For single-node OpenShift use <literal>--mcp-name=master</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the created YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat my-performance-profile.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: performance
spec:
  cpu:
    isolated: 1-39,41-79
    reserved: 0,40
  nodeSelector:
    node-role.kubernetes.io/worker-cnf: ""
  numa:
    topologyPolicy: restricted
  realTimeKernel:
    enabled: false</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the generated profile:</simpara>
<note>
<simpara>Install the Node Tuning Operator before applying the profile.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f my-performance-profile.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="performance-profile-creator-arguments_cnf-create-performance-profiles">
<title>Performance Profile Creator arguments</title>
<table frame="all" rowsep="1" colsep="1">
<title>Performance Profile Creator arguments</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Argument</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>disable-ht</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable hyperthreading.</simpara>
<simpara>Possible values: <literal>true</literal> or <literal>false</literal>.</simpara>
<simpara>Default: <literal>false</literal>.</simpara>
<warning>
<simpara>If this argument is set to <literal>true</literal> you should not disable hyperthreading in the BIOS. Disabling hyperthreading is accomplished with a kernel command line argument.</simpara>
</warning></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>info</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This captures cluster information and is used in discovery mode only. Discovery mode also requires the <literal>must-gather-dir-path</literal> argument. If any other arguments are set they are ignored.</simpara>
<simpara>Possible values:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>log</literal></simpara>
</listitem>
<listitem>
<simpara><literal>JSON</literal></simpara>
<note>
<simpara>These options define the output format with the JSON format being reserved for debugging.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>Default: <literal>log</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcp-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>MCP name for example <literal>worker-cnf</literal> corresponding to the target machines. This parameter is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>must-gather-dir-path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must gather directory path. This parameter is required.</simpara><simpara>When the user runs the tool with the wrapper script <literal>must-gather</literal> is supplied by the script itself and the user must not specify it.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>offlined-cpu-count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of offlined CPUs.</simpara>
<note>
<simpara>This must be a natural number greater than 0. If not enough logical processors are offlined then error messages are logged. The messages are:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">Error: failed to compute the reserved and isolated CPUs: please ensure that reserved-cpu-count plus offlined-cpu-count should be in the range [0,1]</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">Error: failed to compute the reserved and isolated CPUs: please specify the offlined CPU count in the range [0,1]</programlisting>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>power-consumption-mode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The power consumption mode.</simpara>
<simpara>Possible values:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>default</literal>: CPU partitioning with enabled power management and basic low-latency.</simpara>
</listitem>
<listitem>
<simpara><literal>low-latency</literal>: Enhanced measures to improve latency figures.</simpara>
</listitem>
<listitem>
<simpara><literal>ultra-low-latency</literal>: Priority given to optimal latency, at the expense of power management.</simpara>
</listitem>
</itemizedlist>
<simpara>Default: <literal>default</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>per-pod-power-management</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable per pod power management. You cannot use this argument if you configured <literal>ultra-low-latency</literal> as the power consumption mode.</simpara>
<simpara>Possible values: <literal>true</literal> or <literal>false</literal>.</simpara>
<simpara>Default: <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>profile-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the performance profile to create.
Default: <literal>performance</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reserved-cpu-count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of reserved CPUs. This parameter is required.</simpara>
<note>
<simpara>This must be a natural number. A value of 0 is not allowed.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>rt-kernel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enable real-time kernel. This parameter is required.</simpara><simpara>Possible values: <literal>true</literal> or <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>split-reserved-cpus-across-numa</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Split the reserved CPUs across NUMA nodes.</simpara><simpara>Possible values: <literal>true</literal> or <literal>false</literal>.</simpara><simpara>Default: <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>topology-manager-policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubelet Topology Manager policy of the performance profile to be created.</simpara>
<simpara>Possible values:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>single-numa-node</literal></simpara>
</listitem>
<listitem>
<simpara><literal>best-effort</literal></simpara>
</listitem>
<listitem>
<simpara><literal>restricted</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Default: <literal>restricted</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>user-level-networking</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run with user level networking (DPDK) enabled.</simpara><simpara>Possible values: <literal>true</literal> or <literal>false</literal>.</simpara><simpara>Default: <literal>false</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="cnf-create-performance-profiles-reference">
<title>Reference performance profiles</title>
<section xml:id="installation-openstack-ovs-dpdk-performance-profile_cnf-create-performance-profiles">
<title>A performance profile template for clusters that use OVS-DPDK on OpenStack</title>
<simpara>To maximize machine performance in a cluster that uses Open vSwitch with the Data Plane Development Kit (OVS-DPDK) on Red Hat OpenStack Platform (RHOSP), you can use a performance profile.</simpara>
<simpara>You can use the following performance profile template to create a profile for your deployment.</simpara>
<formalpara>
<title>A performance profile template for clusters that use OVS-DPDK</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: cnf-performanceprofile
spec:
  additionalKernelArgs:
    - nmi_watchdog=0
    - audit=0
    - mce=off
    - processor.max_cstate=1
    - idle=poll
    - intel_idle.max_cstate=0
    - default_hugepagesz=1GB
    - hugepagesz=1G
    - intel_iommu=on
  cpu:
    isolated: &lt;CPU_ISOLATED&gt;
    reserved: &lt;CPU_RESERVED&gt;
  hugepages:
    defaultHugepagesSize: 1G
    pages:
      - count: &lt;HUGEPAGES_COUNT&gt;
        node: 0
        size: 1G
  nodeSelector:
    node-role.kubernetes.io/worker: ''
  realTimeKernel:
    enabled: false
    globallyDisableIrqLoadBalancing: true</programlisting>
</para>
</formalpara>
<simpara>Insert values that are appropriate for your configuration for the <literal>CPU_ISOLATED</literal>, <literal>CPU_RESERVED</literal>, and <literal>HUGEPAGES_COUNT</literal> keys.</simpara>
<simpara>To learn how to create and use performance profiles, see the "Creating a performance profile" page in the "Scalability and performance" section of the OpenShift Container Platform documentation.</simpara>
</section>
</section>
<section xml:id="cnf-create-performance-profiles-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>For more information about the <literal>must-gather</literal> tool,
see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/support/#nodes-nodes-managing">Gathering data about your cluster</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="enabling-workload-partitioning">
<title>Workload partitioning</title>
<simpara>In resource-constrained environments, you can use workload partitioning to isolate OpenShift Container Platform services, cluster management workloads, and infrastructure pods to run on a reserved set of CPUs.</simpara>
<simpara>The minimum number of reserved CPUs required for the cluster management is four CPU Hyper-Threads (HTs).
With workload partitioning, you annotate the set of cluster management pods and a set of typical add-on Operators for inclusion in the cluster management workload partition.
These pods operate normally within the minimum size CPU configuration.
Additional Operators or workloads outside of the set of minimum cluster management pods require additional CPUs to be added to the workload partition.</simpara>
<simpara>Workload partitioning isolates user workloads from platform workloads using standard Kubernetes scheduling capabilities.</simpara>
<simpara>The following changes are required for workload partitioning:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <literal>install-config.yaml</literal> file, add the additional field: <literal>cpuPartitioningMode</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
baseDomain: devcluster.openshift.com
cpuPartitioningMode: AllNodes <co xml:id="CO46-1"/>
compute:
  - architecture: amd64
    hyperthreading: Enabled
    name: worker
    platform: {}
    replicas: 3
controlPlane:
  architecture: amd64
  hyperthreading: Enabled
  name: master
  platform: {}
  replicas: 3</programlisting>
<calloutlist>
<callout arearefs="CO46-1">
<para>Sets up a cluster for CPU partitioning at install time. The default value is <literal>None</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>Workload partitioning can only be enabled during cluster installation. You cannot disable workload partitioning postinstallation.</simpara>
</note>
</listitem>
<listitem>
<simpara>In the performance profile, specify the <literal>isolated</literal> and <literal>reserved</literal> CPUs.</simpara>
<formalpara>
<title>Recommended performance profile configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  # if you change this name make sure the 'include' line in TunedPerformancePatch.yaml
  # matches this name: include=openshift-node-performance-${PerformanceProfile.metadata.name}
  # Also in file 'validatorCRs/informDuValidator.yaml': 
  # name: 50-performance-${PerformanceProfile.metadata.name}
  name: openshift-node-performance-profile
  annotations:
    ran.openshift.io/reference-configuration: "ran-du.redhat.com"
spec:
  additionalKernelArgs:
    - "rcupdate.rcu_normal_after_boot=0"
    - "efi=runtime"
    - "vfio_pci.enable_sriov=1"
    - "vfio_pci.disable_idle_d3=1"
    - "module_blacklist=irdma"
  cpu:
    isolated: $isolated
    reserved: $reserved
  hugepages:
    defaultHugepagesSize: $defaultHugepagesSize
    pages:
      - size: $size
        count: $count
        node: $node
  machineConfigPoolSelector:
    pools.operator.machineconfiguration.openshift.io/$mcp: ""
  nodeSelector:
    node-role.kubernetes.io/$mcp: ""
  numa:
    topologyPolicy: "restricted"
  # To use the standard (non-realtime) kernel, set enabled to false
  realTimeKernel:
    enabled: true
  workloadHints:
    # WorkloadHints defines the set of upper level flags for different type of workloads.
    # See https://github.com/openshift/cluster-node-tuning-operator/blob/master/docs/performanceprofile/performance_profile.md#workloadhints
    # for detailed descriptions of each item.
    # The configuration below is set for a low latency, performance mode.
    realTime: true
    highPowerConsumption: false
    perPodPowerManagement: false</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>PerformanceProfile CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">PerformanceProfile CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Ensure that <literal>name</literal> matches the following fields set in related GitOps ZTP custom resources (CRs):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>include=openshift-node-performance-${PerformanceProfile.metadata.name}</literal> in <literal>TunedPerformancePatch.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>name: 50-performance-${PerformanceProfile.metadata.name}</literal> in <literal>validatorCRs/informDuValidator.yaml</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.additionalKernelArgs</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>"efi=runtime"</literal> Configures UEFI secure boot for the cluster host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.cpu.isolated</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the isolated CPUs. Ensure all of the Hyper-Threading pairs match.</simpara>
<important>
<simpara>The reserved and isolated CPU pools must not overlap and together must span all available cores. CPU cores that are not accounted for cause an undefined behaviour in the system.</simpara>
</important></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.cpu.reserved</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the reserved CPUs. When workload partitioning is enabled, system processes, kernel threads, and system container threads are restricted to these CPUs. All CPUs that are not isolated should be reserved.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.hugepages.pages</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Set the number of huge pages (<literal>count</literal>)</simpara>
</listitem>
<listitem>
<simpara>Set the huge pages size (<literal>size</literal>).</simpara>
</listitem>
<listitem>
<simpara>Set <literal>node</literal> to the NUMA node where the <literal>hugepages</literal> are allocated (<literal>node</literal>)</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.realTimeKernel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set <literal>enabled</literal> to <literal>true</literal> to use the realtime kernel.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.workloadHints</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Use <literal>workloadHints</literal> to define the set of top level flags for different type of workloads.
The example configuration configures the cluster for low latency and high performance.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</listitem>
</orderedlist>
<simpara>Workload partitioning introduces an extended <literal>management.workload.openshift.io/cores</literal> resource type for platform pods.
kubelet advertises the resources and CPU requests by pods allocated to the pool within the corresponding resource.
When workload partitioning is enabled, the <literal>management.workload.openshift.io/cores</literal> resource allows the scheduler to correctly assign pods based on the <literal>cpushares</literal> capacity of the host, not just the default <literal>cpuset</literal>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For the recommended workload partitioning configuration for single-node OpenShift clusters, see <link linkend="ztp-sno-du-enabling-workload-partitioning_sno-configure-for-vdu">Workload partitioning</link>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="using-node-observability-operator">
<title>Using the Node Observability Operator</title>
<simpara>The Node Observability Operator collects and stores CRI-O and Kubelet profiling or metrics from scripts of compute nodes.</simpara>
<simpara>With the Node Observability Operator, you can query the profiling data, enabling analysis of performance trends in CRI-O and Kubelet. It supports debugging performance-related issues and executing embedded scripts for network metrics by using the <literal>run</literal> field in the custom resource definition. To enable CRI-O and Kubelet profiling or scripting, you can configure the <literal>type</literal> field in the custom resource definition.</simpara>
<important>
<simpara>The Node Observability Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="workflow-node-observability-operator_node-observability-operator">
<title>Workflow of the Node Observability Operator</title>
<simpara>The following workflow outlines on how to query the profiling data using the Node Observability Operator:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Node Observability Operator in the OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create a NodeObservability custom resource to enable the CRI-O profiling on the worker nodes of your choice.</simpara>
</listitem>
<listitem>
<simpara>Run the profiling query to generate the profiling data.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="install-node-observability-operator_node-observability-operator">
<title>Installing the Node Observability Operator</title>
<simpara>The Node Observability Operator is not installed in OpenShift Container Platform by default. You can install the Node Observability Operator by using the OpenShift Container Platform CLI or the web console.</simpara>
<section xml:id="install-node-observability-using-cli_node-observability-operator">
<title>Installing the Node Observability Operator using the CLI</title>
<simpara>You can install the Node Observability Operator by using the OpenShift CLI (oc).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (oc).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the Node Observability Operator is available by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests -n openshift-marketplace node-observability-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                            CATALOG                AGE
node-observability-operator     Red Hat Operators      9h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>node-observability-operator</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project node-observability-operator</programlisting>
</listitem>
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">cat &lt;&lt;EOF | oc apply -f -
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: node-observability-operator
  namespace: node-observability-operator
spec:
  targetNamespaces: []
EOF</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file to subscribe a namespace to an Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">cat &lt;&lt;EOF | oc apply -f -
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: node-observability-operator
  namespace: node-observability-operator
spec:
  channel: alpha
  name: node-observability-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
EOF</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the install plan name by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n node-observability-operator get sub node-observability-operator -o yaml | yq '.status.installplan.name'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">install-dt54w</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify the install plan status by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n node-observability-operator get ip &lt;install_plan_name&gt; -o yaml | yq '.status.phase'</programlisting>
<simpara><literal>&lt;install_plan_name&gt;</literal> is the install plan name that you obtained from the output of the previous command.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">COMPLETE</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the Node Observability Operator is up and running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n node-observability-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                            READY   UP-TO-DATE  AVAILABLE   AGE
node-observability-operator-controller-manager  1/1     1           1           40h</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="install-node-observability-using-web-console_node-observability-operator">
<title>Installing the Node Observability Operator using the web console</title>
<simpara>You can install the Node Observability Operator from the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>In the Administrator&#8217;s navigation panel, expand <emphasis role="strong">Operators</emphasis>  <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">All items</emphasis> field, enter <emphasis role="strong">Node Observability Operator</emphasis> and select the <emphasis role="strong">Node Observability Operator</emphasis> tile.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, configure the following settings:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Update channel</emphasis> area, click <emphasis role="strong">alpha</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Installation mode</emphasis> area, click <emphasis role="strong">A specific namespace on the cluster</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Installed Namespace</emphasis> list, select <emphasis role="strong">node-observability-operator</emphasis> from the list.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Update approval</emphasis> area, select <emphasis role="strong">Automatic</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>In the Administrator&#8217;s navigation panel, expand <emphasis role="strong">Operators</emphasis>  <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify that the Node Observability Operator is listed in the Operators list.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="requesting-crio-kubelet-profiling-using-noo_node-observability-operator">
<title>Requesting CRI-O and Kubelet profiling data using the Node Observability Operator</title>
<simpara>Creating a Node Observability custom resource to collect CRI-O and Kubelet profiling data.</simpara>
<section xml:id="creating-node-observability-custom-resource_node-observability-operator">
<title>Creating the Node Observability custom resource</title>
<simpara>You must create and run the <literal>NodeObservability</literal> custom resource (CR) before you run the profiling query. When you run the <literal>NodeObservability</literal> CR, it creates the necessary machine config and machine config pool CRs to enable the CRI-O profiling on the worker nodes matching the <literal>nodeSelector</literal>.</simpara>
<important>
<simpara>If CRI-O profiling is not enabled on the worker nodes, the <literal>NodeObservabilityMachineConfig</literal> resource gets created. Worker nodes matching the <literal>nodeSelector</literal> specified in <literal>NodeObservability</literal> CR restarts. This might take 10 or more minutes to complete.</simpara>
</important>
<note>
<simpara>Kubelet profiling is enabled by default.</simpara>
</note>
<simpara>The CRI-O unix socket of the node is mounted on the agent pod, which allows the agent to communicate with CRI-O to run the pprof request. Similarly, the <literal>kubelet-serving-ca</literal> certificate chain is mounted on the agent pod, which allows secure communication between the agent and node&#8217;s kubelet endpoint.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Node Observability Operator.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (oc).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u kubeadmin https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Switch back to the <literal>node-observability-operator</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project node-observability-operator</programlisting>
</listitem>
<listitem>
<simpara>Create a CR file named <literal>nodeobservability.yaml</literal> that contains the following text:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: nodeobservability.olm.openshift.io/v1alpha2
    kind: NodeObservability
    metadata:
      name: cluster <co xml:id="CO47-1"/>
    spec:
      nodeSelector:
        kubernetes.io/hostname: &lt;node_hostname&gt; <co xml:id="CO47-2"/>
      type: crio-kubelet</programlisting>
<calloutlist>
<callout arearefs="CO47-1">
<para>You must specify the name as <literal>cluster</literal> because there should be only one <literal>NodeObservability</literal> CR per cluster.</para>
</callout>
<callout arearefs="CO47-2">
<para>Specify the nodes on which the Node Observability agent must be deployed.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the <literal>NodeObservability</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc apply -f nodeobservability.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">nodeobservability.olm.openshift.io/cluster created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Review the status of the <literal>NodeObservability</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nob/cluster -o yaml | yq '.status.conditions'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">conditions:
  conditions:
  - lastTransitionTime: "2022-07-05T07:33:54Z"
    message: 'DaemonSet node-observability-ds ready: true NodeObservabilityMachineConfig
      ready: true'
    reason: Ready
    status: "True"
    type: Ready</programlisting>
</para>
</formalpara>
<simpara><literal>NodeObservability</literal> CR run is completed when the reason is <literal>Ready</literal> and the status is <literal>True</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="running-profiling-query_node-observability-operator">
<title>Running the profiling query</title>
<simpara>To run the profiling query, you must create a <literal>NodeObservabilityRun</literal> resource. The profiling query is a blocking operation that fetches CRI-O and Kubelet profiling data for a duration of 30 seconds. After the profiling query is complete, you must retrieve the profiling data inside the container file system <literal>/run/node-observability</literal> directory. The lifetime of data is bound to the agent pod through the <literal>emptyDir</literal> volume, so you can access the profiling data while the agent pod is in the <literal>running</literal> status.</simpara>
<important>
<simpara>You can request only one profiling query at any point of time.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Node Observability Operator.</simpara>
</listitem>
<listitem>
<simpara>You have created the <literal>NodeObservability</literal> custom resource (CR).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>NodeObservabilityRun</literal> resource file named <literal>nodeobservabilityrun.yaml</literal> that contains the following text:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodeobservability.olm.openshift.io/v1alpha2
kind: NodeObservabilityRun
metadata:
  name: nodeobservabilityrun
spec:
  nodeObservabilityRef:
    name: cluster</programlisting>
</listitem>
<listitem>
<simpara>Trigger the profiling query by running the <literal>NodeObservabilityRun</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f nodeobservabilityrun.yaml</programlisting>
</listitem>
<listitem>
<simpara>Review the status of the <literal>NodeObservabilityRun</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodeobservabilityrun nodeobservabilityrun -o yaml  | yq '.status.conditions'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">conditions:
- lastTransitionTime: "2022-07-07T14:57:34Z"
  message: Ready to start profiling
  reason: Ready
  status: "True"
  type: Ready
- lastTransitionTime: "2022-07-07T14:58:10Z"
  message: Profiling query done
  reason: Finished
  status: "True"
  type: Finished</programlisting>
</para>
</formalpara>
<simpara>The profiling query is complete once the status is <literal>True</literal> and type is <literal>Finished</literal>.</simpara>
</listitem>
<listitem>
<simpara>Retrieve the profiling data from the container&#8217;s <literal>/run/node-observability</literal> path by running the following bash script:</simpara>
<programlisting language="bash" linenumbering="unnumbered">for a in $(oc get nodeobservabilityrun nodeobservabilityrun -o yaml | yq .status.agents[].name); do
  echo "agent ${a}"
  mkdir -p "/tmp/${a}"
  for p in $(oc exec "${a}" -c node-observability-agent -- bash -c "ls /run/node-observability/*.pprof"); do
    f="$(basename ${p})"
    echo "copying ${f} to /tmp/${a}/${f}"
    oc exec "${a}" -c node-observability-agent -- cat "${p}" &gt; "/tmp/${a}/${f}"
  done
done</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="node-observability-operator-scripting_node-observability-operator">
<title>Node Observability Operator scripting</title>
<simpara>Scripting allows you to run pre-configured bash scripts, using the current Node Observability Operator and Node Observability Agent.</simpara>
<simpara>These scripts monitor key metrics like CPU load, memory pressure, and worker node issues. They also collect sar reports and custom performance metrics.</simpara>
<section xml:id="node-observability-scripting-cr_node-observability-operator">
<title>Creating the Node Observability custom resource for scripting</title>
<simpara>You must create and run the <literal>NodeObservability</literal> custom resource (CR) before you run the scripting. When you run the <literal>NodeObservability</literal> CR, it enables the agent in scripting mode on the compute nodes matching the <literal>nodeSelector</literal> label.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Node Observability Operator.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u kubeadmin https://&lt;host_name&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Switch to the <literal>node-observability-operator</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project node-observability-operator</programlisting>
</listitem>
<listitem>
<simpara>Create a file named <literal>nodeobservability.yaml</literal> that contains the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: nodeobservability.olm.openshift.io/v1alpha2
    kind: NodeObservability
    metadata:
      name: cluster <co xml:id="CO48-1"/>
    spec:
      nodeSelector:
        kubernetes.io/hostname: &lt;node_hostname&gt; <co xml:id="CO48-2"/>
      type: scripting <co xml:id="CO48-3"/></programlisting>
<calloutlist>
<callout arearefs="CO48-1">
<para>You must specify the name as <literal>cluster</literal> because there should be only one <literal>NodeObservability</literal> CR per cluster.</para>
</callout>
<callout arearefs="CO48-2">
<para>Specify the nodes on which the Node Observability agent must be deployed.</para>
</callout>
<callout arearefs="CO48-3">
<para>To deploy the agent in scripting mode, you must set the type to <literal>scripting</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>NodeObservability</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f nodeobservability.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">nodeobservability.olm.openshift.io/cluster created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Review the status of the <literal>NodeObservability</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nob/cluster -o yaml | yq '.status.conditions'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">conditions:
  conditions:
  - lastTransitionTime: "2022-07-05T07:33:54Z"
    message: 'DaemonSet node-observability-ds ready: true NodeObservabilityScripting
      ready: true'
    reason: Ready
    status: "True"
    type: Ready</programlisting>
</para>
</formalpara>
<simpara>The <literal>NodeObservability</literal> CR run is completed when the <literal>reason</literal> is <literal>Ready</literal> and <literal>status</literal> is <literal>"True"</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="node-observability-scripting_node-observability-operator">
<title>Configuring Node Observability Operator scripting</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Node Observability Operator.</simpara>
</listitem>
<listitem>
<simpara>You have created the <literal>NodeObservability</literal> custom resource (CR).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file named <literal>nodeobservabilityrun-script.yaml</literal> that contains the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: nodeobservability.olm.openshift.io/v1alpha2
kind: NodeObservabilityRun
metadata:
  name: nodeobservabilityrun-script
  namespace: node-observability-operator
spec:
  nodeObservabilityRef:
    name: cluster
    type: scripting</programlisting>
<important>
<simpara>You can request only the following scripts:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>metrics.sh</literal></simpara>
</listitem>
<listitem>
<simpara><literal>network-metrics.sh</literal> (uses <literal>monitor.sh</literal>)</simpara>
</listitem>
</itemizedlist>
</important>
</listitem>
<listitem>
<simpara>Trigger the scripting by creating the <literal>NodeObservabilityRun</literal> resource with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f nodeobservabilityrun-script.yaml</programlisting>
</listitem>
<listitem>
<simpara>Review the status of the <literal>NodeObservabilityRun</literal> scripting by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodeobservabilityrun nodeobservabilityrun-script -o yaml  | yq '.status.conditions'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Status:
  Agents:
    Ip:    10.128.2.252
    Name:  node-observability-agent-n2fpm
    Port:  8443
    Ip:    10.131.0.186
    Name:  node-observability-agent-wcc8p
    Port:  8443
  Conditions:
    Conditions:
      Last Transition Time:  2023-12-19T15:10:51Z
      Message:               Ready to start profiling
      Reason:                Ready
      Status:                True
      Type:                  Ready
      Last Transition Time:  2023-12-19T15:11:01Z
      Message:               Profiling query done
      Reason:                Finished
      Status:                True
      Type:                  Finished
  Finished Timestamp:        2023-12-19T15:11:01Z
  Start Timestamp:           2023-12-19T15:10:51Z</programlisting>
</para>
</formalpara>
<simpara>The scripting is complete once <literal>Status</literal> is <literal>True</literal> and <literal>Type</literal> is <literal>Finished</literal>.</simpara>
</listitem>
<listitem>
<simpara>Retrieve the scripting data from the root path of the container by running the following bash script:</simpara>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

RUN=$(oc get nodeobservabilityrun --no-headers | awk '{print $1}')

for a in $(oc get nodeobservabilityruns.nodeobservability.olm.openshift.io/${RUN} -o json | jq .status.agents[].name); do
  echo "agent ${a}"
  agent=$(echo ${a} | tr -d "\"\'\`")
  base_dir=$(oc exec "${agent}" -c node-observability-agent -- bash -c "ls -t | grep node-observability-agent" | head -1)
  echo "${base_dir}"
  mkdir -p "/tmp/${agent}"
  for p in $(oc exec "${agent}" -c node-observability-agent -- bash -c "ls ${base_dir}"); do
    f="/${base_dir}/${p}"
    echo "copying ${f} to /tmp/${agent}/${p}"
    oc exec "${agent}" -c node-observability-agent -- cat ${f} &gt; "/tmp/${agent}/${p}"
  done
done</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="additional-resources_node-observability-operator" role="_additional-resources">
<title>Additional resources</title>
<simpara>For more information on how to collect worker metrics, see <link xlink:href="https://access.redhat.com/solutions/5343671">Red Hat Knowledgebase article</link>.</simpara>
</section>
</chapter>
<chapter xml:id="_clusters-at-the-network-far-edge">
<title>Clusters at the network far edge</title>
<section xml:id="ztp-deploying-far-edge-clusters-at-scale">
<title>Challenges of the network far edge</title>
<simpara>Edge computing presents complex challenges when managing many sites in geographically displaced locations. Use GitOps Zero Touch Provisioning (ZTP) to provision and manage sites at the far edge of the network.</simpara>
<section xml:id="ztp-challenges-of-far-edge-deployments_ztp-deploying-far-edge-clusters-at-scale">
<title>Overcoming the challenges of the network far edge</title>
<simpara>Today, service providers want to deploy their infrastructure at the edge of the network. This presents significant challenges:</simpara>
<itemizedlist>
<listitem>
<simpara>How do you handle deployments of many edge sites in parallel?</simpara>
</listitem>
<listitem>
<simpara>What happens when you need to deploy sites in disconnected environments?</simpara>
</listitem>
<listitem>
<simpara>How do you manage the lifecycle of large fleets of clusters?</simpara>
</listitem>
</itemizedlist>
<simpara>GitOps Zero Touch Provisioning (ZTP) and <emphasis>GitOps</emphasis> meets these challenges by allowing you to provision remote edge sites at scale with declarative site definitions and configurations for bare-metal equipment. Template or overlay configurations install OpenShift Container Platform features that are required for CNF workloads. The full lifecycle of installation and upgrades is handled through the GitOps ZTP pipeline.</simpara>
<simpara>GitOps ZTP uses GitOps for infrastructure deployments. With GitOps, you use declarative YAML files and other defined patterns stored in Git repositories. Red Hat Advanced Cluster Management (RHACM) uses your Git repositories to drive the deployment of your infrastructure.</simpara>
<simpara>GitOps provides traceability, role-based access control (RBAC), and a single source of truth for the desired state of each site. Scalability issues are addressed by Git methodologies and event driven operations through webhooks.</simpara>
<simpara>You start the GitOps ZTP workflow by creating declarative site definition and configuration custom resources (CRs) that the GitOps ZTP pipeline delivers to the edge nodes.</simpara>
<simpara>The following diagram shows how GitOps ZTP works within the far edge framework.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/217_OpenShift_Zero_Touch_Provisioning_updates_1022_1.png"/>
</imageobject>
<textobject><phrase>GitOps ZTP at the network far edge</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="about-ztp_ztp-deploying-far-edge-clusters-at-scale">
<title>Using GitOps ZTP to provision clusters at the network far edge</title>
<simpara>Red Hat Advanced Cluster Management (RHACM) manages clusters in a hub-and-spoke architecture, where a single hub cluster manages many spoke clusters. Hub clusters running RHACM provision and deploy the managed clusters by using GitOps Zero Touch Provisioning (ZTP) and the assisted service that is deployed when you install RHACM.</simpara>
<simpara>The assisted service handles provisioning of OpenShift Container Platform on single node clusters, three-node clusters, or standard clusters running on bare metal.</simpara>
<simpara>A high-level overview of using GitOps ZTP to provision and maintain bare-metal hosts with OpenShift Container Platform is as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>A hub cluster running RHACM manages an OpenShift image registry that mirrors the OpenShift Container Platform release images. RHACM uses the OpenShift image registry to provision the managed clusters.</simpara>
</listitem>
<listitem>
<simpara>You manage the bare-metal hosts in a YAML format inventory file, versioned in a Git repository.</simpara>
</listitem>
<listitem>
<simpara>You make the hosts ready for provisioning as managed clusters, and use RHACM and the assisted service to install the bare-metal hosts on site.</simpara>
</listitem>
</itemizedlist>
<simpara>Installing and deploying the clusters is a two-stage process, involving an initial installation phase, and a subsequent configuration and deployment phase. The following diagram illustrates this workflow:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/474_OpenShift_OpenShift_RAN_RDS_arch_updates_1023.png"/>
</imageobject>
<textobject><phrase>Using GitOps and GitOps ZTP to install and deploy managed clusters</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="ztp-creating-ztp-crs-for-multiple-managed-clusters_ztp-deploying-far-edge-clusters-at-scale">
<title>Installing managed clusters with SiteConfig resources and RHACM</title>
<simpara>GitOps Zero Touch Provisioning (ZTP) uses <literal>SiteConfig</literal> custom resources (CRs) in a Git repository to manage the processes that install OpenShift Container Platform clusters. The <literal>SiteConfig</literal> CR contains cluster-specific parameters required for installation. It has options for applying select configuration CRs during installation including user defined extra manifests.</simpara>
<simpara>The GitOps ZTP plugin processes <literal>SiteConfig</literal> CRs to generate a collection of CRs on the hub cluster. This triggers the assisted service in Red Hat Advanced Cluster Management (RHACM) to install OpenShift Container Platform on the bare-metal host. You can find installation status and error messages in these CRs on the hub cluster.</simpara>
<simpara>You can provision single clusters manually or in batches with GitOps ZTP:</simpara>
<variablelist>
<varlistentry>
<term>Provisioning a single cluster</term>
<listitem>
<simpara>Create a single <literal>SiteConfig</literal> CR and related installation and configuration CRs for the cluster, and apply them in the hub cluster to begin cluster provisioning. This is a good way to test your CRs before deploying on a larger scale.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Provisioning many clusters</term>
<listitem>
<simpara>Install managed clusters in batches of up to 400 by defining <literal>SiteConfig</literal> and related CRs in a Git repository. ArgoCD uses the <literal>SiteConfig</literal> CRs to deploy the sites. The RHACM policy generator creates the manifests and applies them to the hub cluster. This starts the cluster provisioning process.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="ztp-configuring-cluster-policies_ztp-deploying-far-edge-clusters-at-scale">
<title>Configuring managed clusters with policies and PolicyGenTemplate resources</title>
<simpara>GitOps Zero Touch Provisioning (ZTP) uses Red Hat Advanced Cluster Management (RHACM) to configure clusters by using a policy-based governance approach to applying the configuration.</simpara>
<simpara>The policy generator or <literal>PolicyGen</literal> is a plugin for the GitOps Operator that enables the creation of RHACM policies from a concise template. The tool can combine multiple CRs into a single policy, and you can generate multiple policies that apply to various subsets of clusters in your fleet.</simpara>
<note>
<simpara>For scalability and to reduce the complexity of managing configurations across the fleet of clusters, use configuration CRs with as much commonality as possible.</simpara>
<itemizedlist>
<listitem>
<simpara>Where possible, apply configuration CRs using a fleet-wide common policy.</simpara>
</listitem>
<listitem>
<simpara>The next preference is to create logical groupings of clusters to manage as much of the remaining configurations as possible under a group policy.</simpara>
</listitem>
<listitem>
<simpara>When a configuration is unique to an individual site, use RHACM templating on the hub cluster to inject the site-specific data into a common or group policy. Alternatively, apply an individual site policy for the site.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>The following diagram shows how the policy generator interacts with GitOps and RHACM in the configuration phase of cluster deployment.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/217_OpenShift_Zero_Touch_Provisioning_updates_1022_3.png"/>
</imageobject>
<textobject><phrase>Policy generator</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For large fleets of clusters, it is typical for there to be a high-level of consistency in the configuration of those clusters.</simpara>
<simpara>The following recommended structuring of policies combines configuration CRs to meet several goals:</simpara>
<itemizedlist>
<listitem>
<simpara>Describe common configurations once and apply to the fleet.</simpara>
</listitem>
<listitem>
<simpara>Minimize the number of maintained and managed policies.</simpara>
</listitem>
<listitem>
<simpara>Support flexibility in common configurations for cluster variants.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Recommended PolicyGenTemplate policy categories</title>
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="70.833*"/>
<colspec colname="col_2" colwidth="354.1669*"/>
<thead>
<row>
<entry align="left" valign="top">Policy category</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Common</simpara></entry>
<entry align="left" valign="top"><simpara>A policy that exists in the common category is applied to all clusters in the fleet. Use common <literal>PolicyGenTemplate</literal> CRs to apply common installation settings across all cluster types.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Groups</simpara></entry>
<entry align="left" valign="top"><simpara>A policy that exists in the groups category is applied to a group of clusters in the fleet. Use group <literal>PolicyGenTemplate</literal> CRs to manage specific aspects of single-node, three-node, and standard cluster installations. Cluster groups can also follow geographic region, hardware variant, etc.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sites</simpara></entry>
<entry align="left" valign="top"><simpara>A policy that exists in the sites category is applied to a specific cluster site. Any cluster
can have its own specific policies maintained.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about extracting the reference <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs from the <literal>ztp-site-generate</literal> container image, see <link linkend="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">Preparing the ZTP Git repository</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-preparing-the-hub-cluster">
<title>Preparing the hub cluster for ZTP</title>
<simpara>To use RHACM in a disconnected environment, create a mirror registry that mirrors the OpenShift Container Platform release images and Operator Lifecycle Manager (OLM) catalog that contains the required Operator images. OLM manages, installs, and upgrades Operators and their dependencies in the cluster. You can also use a disconnected mirror host to serve the RHCOS ISO and RootFS disk images that are used to provision the bare-metal hosts.</simpara>
<section xml:id="ztp-telco-ran-software-versions_ztp-preparing-the-hub-cluster">
<title>Telco RAN DU 4.14 validated software components</title>
<simpara>The Red Hat telco RAN DU 4.14 solution has been validated using the following Red Hat software products for OpenShift Container Platform managed clusters and hub clusters.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Telco RAN DU managed cluster validated software components</title>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Software version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Managed cluster version</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster Logging Operator</simpara></entry>
<entry align="left" valign="top"><simpara>5.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local Storage Operator</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PTP Operator</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRIOV Operator</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Node Tuning Operator</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Logging Operator</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRIOV-FEC Operator</simpara></entry>
<entry align="left" valign="top"><simpara>2.7</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Hub cluster validated software components</title>
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Software version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Hub cluster version</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GitOps ZTP plugin</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Red Hat Advanced Cluster Management (RHACM)</simpara></entry>
<entry align="left" valign="top"><simpara>2.8, 2.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Red Hat OpenShift GitOps</simpara></entry>
<entry align="left" valign="top"><simpara>1.9, 1.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Topology Aware Lifecycle Manager (TALM)</simpara></entry>
<entry align="left" valign="top"><simpara>4.14</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ztp-gitops-ztp-max-spoke-clusters_ztp-preparing-the-hub-cluster">
<title>Recommended hub cluster specifications and managed cluster limits for GitOps ZTP</title>
<simpara>With GitOps Zero Touch Provisioning (ZTP), you can manage thousands of clusters in geographically dispersed regions and networks.
The Red Hat Performance and Scale lab successfully created and managed 3500 virtual single-node OpenShift clusters with a reduced DU profile from a single Red Hat Advanced Cluster Management (RHACM) hub cluster in a lab environment.</simpara>
<simpara>In real-world situations, the scaling limits for the number of clusters that you can manage will vary depending on various factors affecting the hub cluster.
For example:</simpara>
<variablelist>
<varlistentry>
<term>Hub cluster resources</term>
<listitem>
<simpara>Available hub cluster host resources (CPU, memory, storage) are an important factor in determining how many clusters the hub cluster can manage.
The more resources allocated to the hub cluster, the more managed clusters it can accommodate.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Hub cluster storage</term>
<listitem>
<simpara>The hub cluster host storage IOPS rating and whether the hub cluster hosts use NVMe storage can affect hub cluster performance and the number of clusters it can manage.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Network bandwidth and latency</term>
<listitem>
<simpara>Slow or high-latency network connections between the hub cluster and managed clusters can impact how the hub cluster manages multiple clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Managed cluster size and complexity</term>
<listitem>
<simpara>The size and complexity of the managed clusters also affects the capacity of the hub cluster.
Larger managed clusters with more nodes, namespaces, and resources require additional processing and management resources.
Similarly, clusters with complex configurations such as the RAN DU profile or diverse workloads can require more resources from the hub cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Number of managed policies</term>
<listitem>
<simpara>The number of policies managed by the hub cluster scaled over the number of managed clusters bound to those policies is an important factor that determines how many clusters can be managed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Monitoring and management workloads</term>
<listitem>
<simpara>RHACM continuously monitors and manages the managed clusters.
The number and complexity of monitoring and management workloads running on the hub cluster can affect its capacity.
Intensive monitoring or frequent reconciliation operations can require additional resources, potentially limiting the number of manageable clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RHACM version and configuration</term>
<listitem>
<simpara>Different versions of RHACM can have varying performance characteristics and resource requirements.
Additionally, the configuration settings of RHACM, such as the number of concurrent reconciliations or the frequency of health checks, can affect the managed cluster capacity of the hub cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Use the following representative configuration and network specifications to develop your own Hub cluster and network specifications.</simpara>
<important>
<simpara>The following guidelines are based on internal lab benchmark testing only and do not represent complete bare-metal host specifications.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Representative three-node hub cluster machine specifications</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">Requirement</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OpenShift Container Platform</simpara></entry>
<entry align="left" valign="top"><simpara>version 4.13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RHACM</simpara></entry>
<entry align="left" valign="top"><simpara>version 2.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Topology Aware Lifecycle Manager (TALM)</simpara></entry>
<entry align="left" valign="top"><simpara>version 4.13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Server hardware</simpara></entry>
<entry align="left" valign="top"><simpara>3 x Dell PowerEdge R650 rack servers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVMe hard disks</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>50 GB disk for <literal>/var/lib/etcd</literal></simpara>
</listitem>
<listitem>
<simpara>2.9 TB disk for <literal>/var/lib/containers</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SSD hard disks</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 SSD split into 15 200GB thin-provisioned logical volumes provisioned as <literal>PV</literal> CRs</simpara>
</listitem>
<listitem>
<simpara>1 SSD serving as an extra large <literal>PV</literal> resource</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Number of applied DU profile policies</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<important>
<simpara>The following network specifications are representative of a typical real-world RAN network and were applied to the scale lab environment during testing.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Simulated lab environment network specifications</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">Specification</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Round-trip time (RTT) latency</simpara></entry>
<entry align="left" valign="top"><simpara>50 ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Packet loss</simpara></entry>
<entry align="left" valign="top"><simpara>0.02% packet loss</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Network bandwidth limit</simpara></entry>
<entry align="left" valign="top"><simpara>20 Mbps</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.7/html/install/installing#single-node">Creating and managing single-node OpenShift clusters with RHACM</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installing-disconnected-rhacm_ztp-preparing-the-hub-cluster">
<title>Installing GitOps ZTP in a disconnected environment</title>
<simpara>Use Red Hat Advanced Cluster Management (RHACM), Red Hat OpenShift GitOps, and Topology Aware Lifecycle Manager (TALM) on the hub cluster in the disconnected environment to manage the deployment of multiple managed clusters.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift Container Platform CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have configured a disconnected mirror registry for use in the cluster.</simpara>
<note>
<simpara>The disconnected mirror registry that you create must contain a version of TALM backup and pre-cache images that matches the version of TALM running in the hub cluster. The spoke cluster must be able to resolve these images in the disconnected mirror registry.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Install RHACM in the hub cluster. See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/install/installing#install-on-disconnected-networks">Installing RHACM in a disconnected environment</link>.</simpara>
</listitem>
<listitem>
<simpara>Install GitOps and TALM in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/gitops/latest/installing_gitops/installing-openshift-gitops.html#installing-openshift-gitops">Installing OpenShift GitOps</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="installing-topology-aware-lifecycle-manager-using-cli_cnf-topology-aware-lifecycle-manager">Installing TALM</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/operators/#olm-mirror-catalog_olm-restricted-networks">Mirroring an Operator catalog</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-acm-adding-images-to-mirror-registry_ztp-preparing-the-hub-cluster">
<title>Adding RHCOS ISO and RootFS images to the disconnected mirror host</title>
<simpara>Before you begin installing clusters in the disconnected environment with Red Hat Advanced Cluster Management (RHACM), you must first host Red Hat Enterprise Linux CoreOS (RHCOS) images for it to use. Use a disconnected mirror to host the RHCOS images.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy and configure an HTTP server to host the RHCOS image resources on the network. You must be able to access the HTTP server from your computer, and from the machines that you create.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The RHCOS images might not change with every release of OpenShift Container Platform. You must download images with the highest version that is less than or equal to the version that you install. Use the image versions that match your OpenShift Container Platform version if they are available. You require ISO and RootFS images to install RHCOS on the hosts. RHCOS QCOW2 images are not supported for this installation type.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the mirror host.</simpara>
</listitem>
<listitem>
<simpara>Obtain the RHCOS ISO and RootFS images from <link xlink:href="https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/">mirror.openshift.com</link>, for example:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the required image names and OpenShift Container Platform version as environment variables:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export ISO_IMAGE_NAME=&lt;iso_image_name&gt; <co xml:id="CO49-1"/></programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ export ROOTFS_IMAGE_NAME=&lt;rootfs_image_name&gt; <co xml:id="CO49-2"/></programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ export OCP_VERSION=&lt;ocp_version&gt; <co xml:id="CO49-3"/></programlisting>
<calloutlist>
<callout arearefs="CO49-1">
<para>ISO image name, for example, <literal>rhcos-4.14.1-x86_64-live.x86_64.iso</literal></para>
</callout>
<callout arearefs="CO49-2">
<para>RootFS image name, for example, <literal>rhcos-4.14.1-x86_64-live-rootfs.x86_64.img</literal></para>
</callout>
<callout arearefs="CO49-3">
<para>OpenShift Container Platform version, for example, <literal>4.14.1</literal></para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Download the required images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo wget https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/4.14/${OCP_VERSION}/${ISO_IMAGE_NAME} -O /var/www/html/${ISO_IMAGE_NAME}</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo wget https://mirror.openshift.com/pub/openshift-v4/dependencies/rhcos/4.14/${OCP_VERSION}/${ROOTFS_IMAGE_NAME} -O /var/www/html/${ROOTFS_IMAGE_NAME}</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification steps</title>
<listitem>
<simpara>Verify that the images downloaded successfully and are being served on the disconnected mirror host, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ wget http://$(hostname)/${ISO_IMAGE_NAME}</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Saving to: rhcos-4.14.1-x86_64-live.x86_64.iso
rhcos-4.14.1-x86_64-live.x86_64.iso-  11%[====&gt;    ]  10.01M  4.71MB/s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-mirroring-creating-registry">Creating a mirror registry</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-mirroring-installation-images">Mirroring images for a disconnected installation</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="enabling-assisted-installer-service-on-bare-metal_ztp-preparing-the-hub-cluster">
<title>Enabling the assisted service</title>
<simpara>Red Hat Advanced Cluster Management (RHACM) uses the assisted service to deploy OpenShift Container Platform clusters. The assisted service is deployed automatically when you enable the MultiClusterHub Operator on Red Hat Advanced Cluster Management (RHACM). After that, you need to configure the <literal>Provisioning</literal> resource to watch all namespaces and to update the <literal>AgentServiceConfig</literal> custom resource (CR) with references to the ISO and RootFS images that are hosted on the mirror registry HTTP server.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have RHACM with MultiClusterHub enabled.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Enable the <literal>Provisioning</literal> resource to watch all namespaces and configure mirrors for disconnected environments. For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#enable-cim">Enabling the central infrastructure management service</link>.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>AgentServiceConfig</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit AgentServiceConfig</programlisting>
</listitem>
<listitem>
<simpara>Add the following entry to the <literal>items.spec.osImages</literal> field in the CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- cpuArchitecture: x86_64
    openshiftVersion: "4.14"
    rootFSUrl: https://&lt;host&gt;/&lt;path&gt;/rhcos-live-rootfs.x86_64.img
    url: https://&lt;mirror-registry&gt;/&lt;path&gt;/rhcos-live.x86_64.iso</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;host&gt; </term>
<listitem>
<simpara>Is the fully qualified domain name (FQDN) for the target mirror registry HTTP server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;path&gt; </term>
<listitem>
<simpara>Is the path to the image on the target mirror registry.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Save and quit the editor to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-configuring-the-cluster-for-a-disconnected-environment_ztp-preparing-the-hub-cluster">
<title>Configuring the hub cluster to use a disconnected mirror registry</title>
<simpara>You can configure the hub cluster to use a disconnected mirror registry for a disconnected environment.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a disconnected hub cluster installation with Red Hat Advanced Cluster Management (RHACM) 2.9 installed.</simpara>
</listitem>
<listitem>
<simpara>You have hosted the <literal>rootfs</literal> and <literal>iso</literal> images on an HTTP server.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>If you enable TLS for the HTTP server, you must confirm the root certificate is signed by an authority trusted by the client and verify the trusted certificate chain between your OpenShift Container Platform hub and managed clusters and the HTTP server. Using a server configured with an untrusted certificate prevents the images from being downloaded to the image creation service. Using untrusted HTTPS servers is not supported.</simpara>
</warning>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ConfigMap</literal> containing the mirror registry config:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: assisted-installer-config-map
  namespace: "&lt;infrastructure_operator_namespace&gt;" <co xml:id="CO50-1"/>
  labels:
    app: assisted-service
data:
  ca-bundle.crt: | <co xml:id="CO50-2"/>
    -----BEGIN CERTIFICATE-----
    &lt;certificate_contents&gt;
    -----END CERTIFICATE-----

  registries.conf: | <co xml:id="CO50-3"/>
    unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]

    [[registry]]
       prefix = ""
       location = "quay.io/example-repository" <co xml:id="CO50-4"/>
       mirror-by-digest-only = true

       [[registry.mirror]]
       location = "mirror1.registry.corp.com:5000/example-repository" <co xml:id="CO50-5"/></programlisting>
<calloutlist>
<callout arearefs="CO50-1">
<para>The <literal>ConfigMap</literal> namespace must be the same as the namespace of the Infrastructure Operator.</para>
</callout>
<callout arearefs="CO50-2">
<para>The mirror registrys certificate that is used when creating the mirror registry.</para>
</callout>
<callout arearefs="CO50-3">
<para>The configuration file for the mirror registry. The mirror registry configuration adds mirror information to the <literal>/etc/containers/registries.conf</literal> file in the discovery image. The mirror information is stored in the <literal>imageContentSources</literal> section of the <literal>install-config.yaml</literal> file when the information is passed to the installation program. The Assisted Service pod that runs on the hub cluster fetches the container images from the configured mirror registry.</para>
</callout>
<callout arearefs="CO50-4">
<para>The URL of the mirror registry. You must use the URL from the <literal>imageContentSources</literal> section by running the <literal>oc adm release mirror</literal> command when you configure the mirror registry. For more information, see the <emphasis>Mirroring the OpenShift Container Platform image repository</emphasis> section.</para>
</callout>
<callout arearefs="CO50-5">
<para>The registries defined in the <literal>registries.conf</literal> file must be scoped by repository, not by registry. In this example, both the <literal>quay.io/example-repository</literal> and the <literal>mirror1.registry.corp.com:5000/example-repository</literal> repositories are scoped by the <literal>example-repository</literal> repository.</para>
</callout>
</calloutlist>
<simpara>This updates <literal>mirrorRegistryRef</literal> in the <literal>AgentServiceConfig</literal> custom resource, as shown below:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: agent-install.openshift.io/v1beta1
kind: AgentServiceConfig
metadata:
  name: agent
spec:
  databaseStorage:
    volumeName: &lt;db_pv_name&gt;
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: &lt;db_storage_size&gt;
  filesystemStorage:
    volumeName: &lt;fs_pv_name&gt;
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: &lt;fs_storage_size&gt;
  mirrorRegistryRef:
    name: 'assisted-installer-mirror-config'
  osImages:
    - openshiftVersion: &lt;ocp_version&gt;
      url: &lt;iso_url&gt; <co xml:id="CO51-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO51-1">
<para>Must match the URL of the HTTPD server.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<important>
<simpara>A valid NTP server is required during cluster installation. Ensure that a suitable NTP server is available and can be reached from the installed clusters through the disconnected network.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-mirror-repository_installing-mirroring-installation-images">Mirroring the OpenShift Container Platform image repository</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-configuring-the-hub-cluster-to-use-unauthenticated-registries_ztp-preparing-the-hub-cluster">
<title>Configuring the hub cluster to use unauthenticated registries</title>
<simpara>You can configure the hub cluster to use unauthenticated registries.
Unauthenticated registries does not require authentication to access and download images.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed and configured a hub cluster and installed Red Hat Advanced Cluster Management (RHACM) on the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift Container Platform CLI (oc).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have configured an unauthenticated registry for use with the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>AgentServiceConfig</literal> custom resource (CR) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit AgentServiceConfig agent</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>unauthenticatedRegistries</literal> field in the CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: agent-install.openshift.io/v1beta1
kind: AgentServiceConfig
metadata:
  name: agent
spec:
  unauthenticatedRegistries:
  - example.registry.com
  - example.registry2.com
  ...</programlisting>
<simpara>Unauthenticated registries are listed under <literal>spec.unauthenticatedRegistries</literal> in the <literal>AgentServiceConfig</literal> resource.
Any registry on this list is not required to have an entry in the pull secret used for the spoke cluster installation.
<literal>assisted-service</literal> validates the pull secret by making sure it contains the authentication information for every image registry used for installation.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Mirror registries are automatically added to the ignore list and do not need to be added under <literal>spec.unauthenticatedRegistries</literal>.
Specifying the <literal>PUBLIC_CONTAINER_REGISTRIES</literal> environment variable in the <literal>ConfigMap</literal> overrides the default values with the specified value.
The <literal>PUBLIC_CONTAINER_REGISTRIES</literal> defaults are <link xlink:href="https://quay.io">quay.io</link> and <link xlink:href="https://registry.svc.ci.openshift.org">registry.svc.ci.openshift.org</link>.</simpara>
</note>
<formalpara>
<title>Verification</title>
<para>Verify that you can access the newly added registry from the hub cluster by running the following commands:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a debug shell prompt to the hub cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Test access to the unauthenticated registry by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# podman login -u kubeadmin -p $(oc whoami -t) &lt;unauthenticated_registry&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;unauthenticated_registry&gt;</term>
<listitem>
<simpara>Is the new registry, for example, <literal>unauthenticated-image-registry.openshift-image-registry.svc:5000</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Login Succeeded!</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-configuring-hub-cluster-with-argocd_ztp-preparing-the-hub-cluster">
<title>Configuring the hub cluster with ArgoCD</title>
<simpara>You can configure the hub cluster with a set of ArgoCD applications that generate the required installation and policy custom resources (CRs) for each site with GitOps Zero Touch Provisioning (ZTP).</simpara>
<note>
<simpara>Red Hat Advanced Cluster Management (RHACM) uses <literal>SiteConfig</literal> CRs to generate the Day 1 managed cluster installation CRs for ArgoCD. Each ArgoCD application can manage a maximum of 300 <literal>SiteConfig</literal> CRs.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a OpenShift Container Platform hub cluster with Red Hat Advanced Cluster Management (RHACM) and Red Hat OpenShift GitOps installed.</simpara>
</listitem>
<listitem>
<simpara>You have extracted the reference deployment from the GitOps ZTP plugin container as described in the "Preparing the GitOps ZTP site configuration repository" section. Extracting the reference deployment creates the <literal>out/argocd/deployment</literal> directory referenced in the following procedure.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Prepare the ArgoCD pipeline configuration:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a Git repository with the directory structure similar to the example directory. For more information, see "Preparing the GitOps ZTP site configuration repository".</simpara>
</listitem>
<listitem>
<simpara>Configure access to the repository using the ArgoCD UI. Under <emphasis role="strong">Settings</emphasis> configure the following:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Repositories</emphasis> - Add the connection information. The URL must end in <literal>.git</literal>, for example, <literal><link xlink:href="https://repo.example.com/repo.git">https://repo.example.com/repo.git</link></literal> and credentials.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Certificates</emphasis> - Add the public certificate for the repository, if needed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Modify the two ArgoCD applications, <literal>out/argocd/deployment/clusters-app.yaml</literal> and <literal>out/argocd/deployment/policies-app.yaml</literal>, based on your Git repository:</simpara>
<itemizedlist>
<listitem>
<simpara>Update the URL to point to the Git repository. The URL ends with <literal>.git</literal>, for example, <literal><link xlink:href="https://repo.example.com/repo.git">https://repo.example.com/repo.git</link></literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>targetRevision</literal> indicates which Git repository branch to monitor.</simpara>
</listitem>
<listitem>
<simpara><literal>path</literal> specifies the path to the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs, respectively.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To install the GitOps ZTP plugin you must patch the ArgoCD instance in the hub cluster by using the patch file previously extracted into the <literal>out/argocd/deployment/</literal> directory. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch argocd openshift-gitops \
-n openshift-gitops --type=merge \
--patch-file out/argocd/deployment/argocd-openshift-gitops-patch.json</programlisting>
</listitem>
<listitem>
<simpara>In RHACM 2.7 and later, the multicluster engine enables the <literal>cluster-proxy-addon</literal> feature by default.
To disable this feature, apply the following patch to disable and remove the relevant hub cluster and managed cluster pods that are responsible for this add-on.
Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch multiclusterengines.multicluster.openshift.io multiclusterengine --type=merge --patch-file out/argocd/deployment/disable-cluster-proxy-addon.json</programlisting>
</listitem>
<listitem>
<simpara>Apply the pipeline configuration to your hub cluster by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -k out/argocd/deployment</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">
<title>Preparing the GitOps ZTP site configuration repository</title>
<simpara>Before you can use the GitOps Zero Touch Provisioning (ZTP) pipeline, you need to prepare the Git repository to host the site configuration data.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured the hub cluster GitOps applications for generating the required installation and policy custom resources (CRs).</simpara>
</listitem>
<listitem>
<simpara>You have deployed the managed clusters using GitOps ZTP.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory structure with separate paths for the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs.</simpara>
<note>
<simpara>Keep <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs in separate directories.
Both the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> directories must contain a <literal>kustomization.yaml</literal> file that explicitly includes the files in that directory.</simpara>
</note>
</listitem>
<listitem>
<simpara>Export the <literal>argocd</literal> directory from the <literal>ztp-site-generate</literal> container image using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman pull registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./out</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --log-driver=none --rm registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 extract /home/ztp --tar | tar x -C ./out</programlisting>
</listitem>
<listitem>
<simpara>Check that the <literal>out</literal> directory contains the following subdirectories:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>out/extra-manifest</literal> contains the source CR files that <literal>SiteConfig</literal> uses to generate extra manifest <literal>configMap</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>out/source-crs</literal> contains the source CR files that <literal>PolicyGenTemplate</literal> uses to generate the Red Hat Advanced Cluster Management (RHACM) policies.</simpara>
</listitem>
<listitem>
<simpara><literal>out/argocd/deployment</literal> contains patches and YAML files to apply on the hub cluster for use in the next step of this procedure.</simpara>
</listitem>
<listitem>
<simpara><literal>out/argocd/example</literal> contains the examples for <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> files that represent the recommended configuration.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Copy the <literal>out/source-crs</literal> folder and contents to the <literal>PolicyGentemplate</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>The out/extra-manifests directory contains the reference manifests for a RAN DU cluster.
Copy the <literal>out/extra-manifests</literal> directory into the <literal>SiteConfig</literal> folder.
This directory should contain CRs from the <literal>ztp-site-generate</literal> container only.
Do not add user-provided CRs here.
If you want to work with user-provided CRs you must create another directory for that content.
For example:</simpara>
<programlisting language="text" linenumbering="unnumbered">example/
   policygentemplates
      kustomization.yaml
      source-crs/
   siteconfig
         extra-manifests
         kustomization.yaml</programlisting>
</listitem>
<listitem>
<simpara>Commit the directory structure and the <literal>kustomization.yaml</literal> files and push to your Git repository.
The initial push to Git should include the <literal>kustomization.yaml</literal> files.</simpara>
</listitem>
</orderedlist>
<simpara>You can use the directory structure under <literal>out/argocd/example</literal> as a reference for the structure and content of your Git repository.
That structure includes <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> reference CRs for single-node, three-node, and standard clusters.
Remove references to cluster types that you are not using.</simpara>
<simpara>For all cluster types, you must:</simpara>
<itemizedlist>
<listitem>
<simpara>Add the <literal>source-crs</literal> subdirectory to the <literal>policygentemplate</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>extra-manifests</literal> directory to the <literal>siteconfig</literal> directory.</simpara>
</listitem>
</itemizedlist>
<simpara>The following example describes a set of CRs for a network of single-node clusters:</simpara>
<programlisting language="text" linenumbering="unnumbered">example/
   policygentemplates
      common-ranGen.yaml
      example-sno-site.yaml
      group-du-sno-ranGen.yaml
      group-du-sno-validator-ranGen.yaml
      kustomization.yaml
      source-crs/
      ns.yaml
   siteconfig
         example-sno.yaml
         extra-manifests/ <co xml:id="CO52-1"/>
         custom-manifests/ <co xml:id="CO52-2"/>
         KlusterletAddonConfigOverride.yaml
         kustomization.yaml</programlisting>
<calloutlist>
<callout arearefs="CO52-1">
<para>Contains reference manifests from the <literal>ztp-container</literal>.</para>
</callout>
<callout arearefs="CO52-2">
<para>Contains custom manifests.</para>
</callout>
</calloutlist>
<section xml:id="ztp-preparing-the-ztp-git-repository-ver-ind_ztp-preparing-the-hub-cluster">
<title>Preparing the GitOps ZTP site configuration repository for version independence</title>
<simpara>You can use GitOps ZTP to manage source custom resources (CRs) for managed clusters that are running different versions of OpenShift Container Platform.
This means that the version of OpenShift Container Platform running on the hub cluster can be independent of the version running on the managed clusters.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory structure with separate paths for the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs.</simpara>
</listitem>
<listitem>
<simpara>Within the <literal>PolicyGenTemplate</literal> directory, create a directory for each OpenShift Container Platform version you want to make available.
For each version, create the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kustomization.yaml</literal> file that explicitly includes the files in that directory</simpara>
</listitem>
<listitem>
<simpara><literal>source-crs</literal> directory to contain reference CR configuration files from the <literal>ztp-site-generate</literal> container</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In the <literal>/siteconfig</literal> directory, create a subdirectory for each OpenShift Container Platform version you want to make available. For each version, create at least one directory for reference CRs to be copied from the container. There is no restriction on the naming of directories or on the number of reference directories. If you want to work with user-provided CRs, you must create a separate directory for those.</simpara>
<simpara>The following example describes a structure using user-provided CRs for different versions of OpenShift Container Platform:</simpara>
<programlisting language="text" linenumbering="unnumbered"> policygentemplates
    kustomization.yaml <co xml:id="CO53-1"/>
    version_4.13 <co xml:id="CO53-2"/>
       common-ranGen.yaml
       group-du-sno-ranGen.yaml
       group-du-sno-validator-ranGen.yaml
       helix56-v413.yaml
       kustomization.yaml <co xml:id="CO53-3"/>
       ns.yaml
       source-crs/  <co xml:id="CO53-4"/>
    version_4.14 <co xml:id="CO53-5"/>
        common-ranGen.yaml
        group-du-sno-ranGen.yaml
        group-du-sno-validator-ranGen.yaml
        helix56-v414.yaml
        kustomization.yaml <co xml:id="CO53-6"/>
        ns.yaml
        source-crs/ <co xml:id="CO53-7"/>
 siteconfig
     kustomization.yaml
     version_4.13
        helix56-v413.yaml
        kustomization.yaml
        extra-manifest/ <co xml:id="CO53-8"/>
        custom-manifest/ <co xml:id="CO53-9"/>
     version_4.14
         helix57-v414.yaml
         kustomization.yaml
         extra-manifest/ <co xml:id="CO53-10"/>
         custom-manifest/ <co xml:id="CO53-11"/></programlisting>
<calloutlist>
<callout arearefs="CO53-1">
<para>Create a top-level <literal>kustomization</literal> yaml file.</para>
</callout>
<callout arearefs="CO53-2 CO53-5">
<para>Create the version-specific directories within the custom <literal>/policygentemplates</literal> directory.</para>
</callout>
<callout arearefs="CO53-3 CO53-6">
<para>Create a <literal>kustomization.yaml</literal> file for each version.</para>
</callout>
<callout arearefs="CO53-4 CO53-7">
<para>Create a <literal>source-crs</literal> directory for each version to contain reference CRs from the <literal>ztp-site-generate</literal> container.</para>
</callout>
<callout arearefs="CO53-8 CO53-10">
<para>Create a directory within the custom <literal>/siteconfig</literal> directory to contain extra manifests from the <literal>ztp-site-generate</literal> container.</para>
</callout>
<callout arearefs="CO53-9 CO53-11">
<para>Create a folder to hold user-provided CRs.</para>
</callout>
</calloutlist>
<note>
<simpara>In the previous example, each version subdirectory in the custom <literal>/siteconfig</literal> directory contains two further subdirectories, one containing the reference manifests copied from the container, the other for custom manifests that you provide.
The names assigned to those directories are examples.
If you use user-provided CRs, the last directory listed under <literal>extraManifests.searchPaths</literal> in the <literal>SiteConfig</literal> CR must be the directory containing user-provided CRs.</simpara>
</note>
</listitem>
<listitem>
<simpara>Edit the <literal>SiteConfig</literal> CR to include the search paths of any directories you have created.
The first directory that is listed under <literal>extraManifests.searchPaths</literal> must be the directory containing the reference manifests.
Consider the order in which the directories are listed.
In cases where directories contain files with the same name, the file in the final directory takes precedence.</simpara>
<formalpara>
<title>Example SiteConfig CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">extraManifests:
    searchPaths:
    - extra-manifest/ <co xml:id="CO54-1"/>
    - custom-manifest/ <co xml:id="CO54-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>The directory containing the reference manifests must be listed first under <literal>extraManifests.searchPaths</literal>.</para>
</callout>
<callout arearefs="CO54-2">
<para>If you are using user-provided CRs, the last directory listed under <literal>extraManifests.searchPaths</literal> in the <literal>SiteConfig</literal> CR must be the directory containing those user-provided CRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit the top-level <literal>kustomization.yaml</literal> file to control which OpenShift Container Platform versions are active. The following is an example of a <literal>kustomization.yaml</literal> file at the top level:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">resources:
- version_4.13 <co xml:id="CO55-1"/>
#- version_4.14 <co xml:id="CO55-2"/></programlisting>
<calloutlist>
<callout arearefs="CO55-1">
<para>Activate version 4.13.</para>
</callout>
<callout arearefs="CO55-2">
<para>Use comments to deactivate a version.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ztp-deploying-far-edge-sites">
<title>Installing managed clusters with RHACM and SiteConfig resources</title>
<simpara>You can provision OpenShift Container Platform clusters at scale with Red Hat Advanced Cluster Management (RHACM) using the assisted service and the GitOps plugin policy generator with core-reduction technology enabled. The GitOps Zero Touch Provisioning (ZTP) pipeline performs the cluster installations. GitOps ZTP can be used in a disconnected environment.</simpara>
<section xml:id="ztp-talo-integration_ztp-deploying-far-edge-sites">
<title>GitOps ZTP and Topology Aware Lifecycle Manager</title>
<simpara>GitOps Zero Touch Provisioning (ZTP) generates installation and configuration CRs from manifests stored in Git. These artifacts are applied to a centralized hub cluster where Red Hat Advanced Cluster Management (RHACM), the assisted service, and the Topology Aware Lifecycle Manager (TALM) use the CRs to install and configure the managed cluster. The configuration phase of the GitOps ZTP pipeline uses the TALM to orchestrate the application of the configuration CRs to the cluster. There are several key integration points between GitOps ZTP and the TALM.</simpara>
<variablelist>
<varlistentry>
<term>Inform policies</term>
<listitem>
<simpara>By default, GitOps ZTP creates all policies with a remediation action of <literal>inform</literal>. These policies cause RHACM to report on compliance status of clusters relevant to the policies but does not apply the desired configuration. During the GitOps ZTP process, after OpenShift installation, the TALM steps through the created <literal>inform</literal> policies and enforces them on the target managed cluster(s). This applies the configuration to the managed cluster. Outside of the GitOps ZTP phase of the cluster lifecycle, this allows you to change policies without the risk of immediately rolling those changes out to affected managed clusters. You can control the timing and the set of remediated clusters by using TALM.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Automatic creation of ClusterGroupUpgrade CRs</term>
<listitem>
<simpara>To automate the initial configuration of newly deployed clusters, TALM monitors the state of all <literal>ManagedCluster</literal> CRs on the hub cluster. Any <literal>ManagedCluster</literal> CR that does not have a <literal>ztp-done</literal> label applied, including newly created <literal>ManagedCluster</literal> CRs, causes the TALM to automatically create a <literal>ClusterGroupUpgrade</literal> CR with the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>ClusterGroupUpgrade</literal> CR is created and enabled in the <literal>ztp-install</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara><literal>ClusterGroupUpgrade</literal> CR has the same name as the <literal>ManagedCluster</literal> CR.</simpara>
</listitem>
<listitem>
<simpara>The cluster selector includes only the cluster associated with that <literal>ManagedCluster</literal> CR.</simpara>
</listitem>
<listitem>
<simpara>The set of managed policies includes all policies that RHACM has bound to the cluster at the time the <literal>ClusterGroupUpgrade</literal> is created.</simpara>
</listitem>
<listitem>
<simpara>Pre-caching is disabled.</simpara>
</listitem>
<listitem>
<simpara>Timeout set to 4 hours (240 minutes).</simpara>
</listitem>
</itemizedlist>
<simpara>The automatic creation of an enabled <literal>ClusterGroupUpgrade</literal> ensures that initial zero-touch deployment of clusters proceeds without the need for user intervention. Additionally, the automatic creation of a <literal>ClusterGroupUpgrade</literal> CR for any <literal>ManagedCluster</literal> without the <literal>ztp-done</literal> label allows a failed GitOps ZTP installation to be restarted by simply deleting the <literal>ClusterGroupUpgrade</literal> CR for the cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Waves</term>
<listitem>
<simpara>Each policy generated from a <literal>PolicyGenTemplate</literal> CR includes a <literal>ztp-deploy-wave</literal> annotation. This annotation is based on the same annotation from each CR which is included in that policy. The wave annotation is used to order the policies in the auto-generated <literal>ClusterGroupUpgrade</literal> CR. The wave annotation is not used other than for the auto-generated <literal>ClusterGroupUpgrade</literal> CR.</simpara>
<note>
<simpara>All CRs in the same policy must have the same setting for the <literal>ztp-deploy-wave</literal> annotation. The default value of this annotation for each CR can be overridden in the <literal>PolicyGenTemplate</literal>. The wave annotation in the source CR is used for determining and setting the policy wave annotation. This annotation is removed from each built CR which is included in the generated policy at runtime.</simpara>
</note>
<simpara>The TALM applies the configuration policies in the order specified by the wave annotations. The TALM waits for each policy to be compliant before moving to the next policy. It is important to ensure that the wave annotation for each CR takes into account any prerequisites for those CRs to be applied to the cluster. For example, an Operator must be installed before or concurrently with the configuration for the Operator. Similarly, the <literal>CatalogSource</literal> for an Operator must be installed in a wave before or concurrently with the Operator Subscription. The default wave value for each CR takes these prerequisites into account.</simpara>
<simpara>Multiple CRs and policies can share the same wave number. Having fewer policies can result in faster deployments and lower CPU usage. It is a best practice to group many CRs into relatively few waves.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>To check the default wave value in each source CR, run the following command against the <literal>out/source-crs</literal> directory that is extracted from the <literal>ztp-site-generate</literal> container image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ grep -r "ztp-deploy-wave" out/source-crs</programlisting>
<variablelist>
<varlistentry>
<term>Phase labels</term>
<listitem>
<simpara>The <literal>ClusterGroupUpgrade</literal> CR is automatically created and includes directives to annotate the <literal>ManagedCluster</literal> CR with labels at the start and end of the GitOps ZTP process.</simpara>
<simpara>When GitOps ZTP configuration postinstallation commences, the <literal>ManagedCluster</literal> has the <literal>ztp-running</literal> label applied. When all policies are remediated to the cluster and are fully compliant, these directives cause the TALM to remove the <literal>ztp-running</literal> label and apply the <literal>ztp-done</literal> label.</simpara>
<simpara>For deployments that make use of the <literal>informDuValidator</literal> policy, the <literal>ztp-done</literal> label is applied when the cluster is fully ready for deployment of applications. This includes all reconciliation and resulting effects of the GitOps ZTP applied configuration CRs. The <literal>ztp-done</literal> label affects automatic <literal>ClusterGroupUpgrade</literal> CR creation by TALM. Do not manipulate this label after the initial GitOps ZTP installation of the cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Linked CRs</term>
<listitem>
<simpara>The automatically created <literal>ClusterGroupUpgrade</literal> CR has the owner reference set as the <literal>ManagedCluster</literal> from which it was derived. This reference ensures that deleting the <literal>ManagedCluster</literal> CR causes the instance of the <literal>ClusterGroupUpgrade</literal> to be deleted along with any supporting resources.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="ztp-ztp-building-blocks_ztp-deploying-far-edge-sites">
<title>Overview of deploying managed clusters with GitOps ZTP</title>
<simpara>Red Hat Advanced Cluster Management (RHACM) uses GitOps Zero Touch Provisioning (ZTP) to deploy single-node OpenShift Container Platform clusters, three-node clusters, and standard clusters. You manage site configuration data as OpenShift Container Platform custom resources (CRs) in a Git repository. GitOps ZTP uses a declarative GitOps approach for a develop once, deploy anywhere model to deploy the managed clusters.</simpara>
<simpara>The deployment of the clusters includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Installing the host operating system (RHCOS) on a blank server</simpara>
</listitem>
<listitem>
<simpara>Deploying OpenShift Container Platform</simpara>
</listitem>
<listitem>
<simpara>Creating cluster policies and site subscriptions</simpara>
</listitem>
<listitem>
<simpara>Making the necessary network configurations to the server operating system</simpara>
</listitem>
<listitem>
<simpara>Deploying profile Operators and performing any needed software-related configuration, such as performance profile, PTP, and SR-IOV</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="ztp-overview-managed-site-installation-process_ztp-deploying-far-edge-sites" renderas="sect4">Overview of the managed site installation process</bridgehead>
<simpara>After you apply the managed site custom resources (CRs) on the hub cluster, the following actions happen automatically:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A Discovery image ISO file is generated and booted on the target host.</simpara>
</listitem>
<listitem>
<simpara>When the ISO file successfully boots on the target host it reports the host hardware information to RHACM.</simpara>
</listitem>
<listitem>
<simpara>After all hosts are discovered, OpenShift Container Platform is installed.</simpara>
</listitem>
<listitem>
<simpara>When OpenShift Container Platform finishes installing, the hub installs the <literal>klusterlet</literal> service on the target cluster.</simpara>
</listitem>
<listitem>
<simpara>The requested add-on services are installed on the target cluster.</simpara>
</listitem>
</orderedlist>
<simpara>The Discovery image ISO process is complete when the <literal>Agent</literal> CR  for the managed cluster is created on the hub cluster.</simpara>
<important>
<simpara>The target bare-metal host must meet the networking, firmware, and hardware requirements listed in <link linkend="sno-configure-for-vdu">Recommended single-node OpenShift cluster configuration for vDU application workloads</link>.</simpara>
</important>
</section>
<section xml:id="ztp-creating-the-site-secrets_ztp-deploying-far-edge-sites">
<title>Creating the managed bare-metal host secrets</title>
<simpara>Add the required <literal>Secret</literal> custom resources (CRs) for the managed bare-metal host to the hub cluster. You need a secret for the GitOps Zero Touch Provisioning (ZTP) pipeline to access the Baseboard Management Controller (BMC) and a secret for the assisted installer service to pull cluster installation images from the registry.</simpara>
<note>
<simpara>The secrets are referenced from the <literal>SiteConfig</literal> CR by name. The namespace
must match the <literal>SiteConfig</literal> namespace.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML secret file containing credentials for the host Baseboard Management Controller (BMC) and a pull secret required for installing OpenShift and all add-on cluster Operators:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML as the file <literal>example-sno-secret.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: example-sno-bmc-secret
  namespace: example-sno <co xml:id="CO56-1"/>
data: <co xml:id="CO56-2"/>
  password: &lt;base64_password&gt;
  username: &lt;base64_username&gt;
type: Opaque
---
apiVersion: v1
kind: Secret
metadata:
  name: pull-secret
  namespace: example-sno  <co xml:id="CO56-3"/>
data:
  .dockerconfigjson: &lt;pull_secret&gt; <co xml:id="CO56-4"/>
type: kubernetes.io/dockerconfigjson</programlisting>
<calloutlist>
<callout arearefs="CO56-1">
<para>Must match the namespace configured in the related <literal>SiteConfig</literal> CR</para>
</callout>
<callout arearefs="CO56-2">
<para>Base64-encoded values for <literal>password</literal> and <literal>username</literal></para>
</callout>
<callout arearefs="CO56-3">
<para>Must match the namespace configured in the related <literal>SiteConfig</literal> CR</para>
</callout>
<callout arearefs="CO56-4">
<para>Base64-encoded pull secret</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add the relative path to <literal>example-sno-secret.yaml</literal> to the <literal>kustomization.yaml</literal> file that you use to install the cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="setting-managed-bare-metal-host-kernel-arguments_ztp-deploying-far-edge-sites">
<title>Configuring Discovery ISO kernel arguments for installations using GitOps ZTP</title>
<simpara>The GitOps Zero Touch Provisioning (ZTP) workflow uses the Discovery ISO as part of the OpenShift Container Platform installation process on managed bare-metal hosts. You can edit the <literal>InfraEnv</literal> resource to specify kernel arguments for the Discovery ISO. This is useful for cluster installations with specific environmental requirements. For example, configure the <literal>rd.net.timeout.carrier</literal> kernel argument for the Discovery ISO to facilitate static networking for the cluster or to receive a DHCP address before downloading the root file system during installation.</simpara>
<note>
<simpara>In OpenShift Container Platform 4.14, you can only add kernel arguments. You can not replace or delete kernel arguments.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (oc).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>InfraEnv</literal> CR and edit the <literal>spec.kernelArguments</literal> specification to configure kernel arguments.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in an <literal>InfraEnv-example.yaml</literal> file:</simpara>
<note>
<simpara>The <literal>InfraEnv</literal> CR in this example uses template syntax such as <literal>{{ .Cluster.ClusterName }}</literal> that is populated based on values in the <literal>SiteConfig</literal> CR. The <literal>SiteConfig</literal> CR automatically populates values for these templates during deployment. Do not edit the templates manually.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: agent-install.openshift.io/v1beta1
kind: InfraEnv
metadata:
  annotations:
    argocd.argoproj.io/sync-wave: "1"
  name: "{{ .Cluster.ClusterName }}"
  namespace: "{{ .Cluster.ClusterName }}"
spec:
  clusterRef:
    name: "{{ .Cluster.ClusterName }}"
    namespace: "{{ .Cluster.ClusterName }}"
  kernelArguments:
    - operation: append <co xml:id="CO57-1"/>
      value: audit=0 <co xml:id="CO57-2"/>
    - operation: append
      value: trace=1
  sshAuthorizedKey: "{{ .Site.SshPublicKey }}"
  proxy: "{{ .Cluster.ProxySettings }}"
  pullSecretRef:
    name: "{{ .Site.PullSecretRef.Name }}"
  ignitionConfigOverride: "{{ .Cluster.IgnitionConfigOverride }}"
  nmStateConfigLabelSelector:
    matchLabels:
      nmstate-label: "{{ .Cluster.ClusterName }}"
  additionalNTPSources: "{{ .Cluster.AdditionalNTPSources }}"</programlisting>
<calloutlist>
<callout arearefs="CO57-1">
<para>Specify the append operation to add a kernel argument.</para>
</callout>
<callout arearefs="CO57-2">
<para>Specify the kernel argument you want to configure. This example configures the audit kernel argument and the trace kernel argument.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Commit the <literal>InfraEnv-example.yaml</literal> CR to the same location in your Git repository that has the <literal>SiteConfig</literal> CR and push your changes. The following example shows a sample Git repository structure:</simpara>
<programlisting language="text" linenumbering="unnumbered">~/example-ztp/install
           site-install
                siteconfig-example.yaml
                InfraEnv-example.yaml
               ...</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>spec.clusters.crTemplates</literal> specification in the <literal>SiteConfig</literal> CR to reference the <literal>InfraEnv-example.yaml</literal> CR in your Git repository:</simpara>
<programlisting role="white-space-pre" language="yaml" linenumbering="unnumbered">clusters:
  crTemplates:
    InfraEnv: "InfraEnv-example.yaml"</programlisting>
<simpara>When you are ready to deploy your cluster by committing and pushing the <literal>SiteConfig</literal> CR, the build pipeline uses the custom <literal>InfraEnv-example</literal> CR in your Git repository to configure the infrastructure environment, including the custom kernel arguments.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the kernel arguments are applied, after the Discovery image verifies that OpenShift Container Platform is ready for installation, you can SSH to the target host before the installation process begins. At that point, you can view the kernel arguments for the Discovery ISO in the <literal>/proc/cmdline</literal> file.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Begin an SSH session with the target host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh -i /path/to/privatekey core@&lt;host_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>View the system&#8217;s kernel arguments by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /proc/cmdline</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-deploying-a-site_ztp-deploying-far-edge-sites">
<title>Deploying a managed cluster with SiteConfig and GitOps ZTP</title>
<simpara>Use the following procedure to create a <literal>SiteConfig</literal> custom resource (CR) and related files and initiate the GitOps Zero Touch Provisioning (ZTP) cluster deployment.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You configured the hub cluster for generating the required installation and policy CRs.</simpara>
</listitem>
<listitem>
<simpara>You created a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and you must configure it as a source repository for the ArgoCD application. See "Preparing the GitOps ZTP site configuration repository" for more information.</simpara>
<note>
<simpara>When you create the source repository, ensure that you patch the ArgoCD application with the <literal>argocd/deployment/argocd-openshift-gitops-patch.json</literal> patch-file that you extract from the <literal>ztp-site-generate</literal> container. See "Configuring the hub cluster with ArgoCD".</simpara>
</note>
</listitem>
<listitem>
<simpara>To be ready for provisioning managed clusters, you require the following for each bare-metal host:</simpara>
<variablelist>
<varlistentry>
<term>Network connectivity</term>
<listitem>
<simpara>Your network requires DNS. Managed cluster hosts should be reachable from the hub cluster. Ensure that Layer 3 connectivity exists between the hub cluster and the managed cluster host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Baseboard Management Controller (BMC) details</term>
<listitem>
<simpara>GitOps ZTP uses BMC username and password details to connect to the BMC during cluster installation. The GitOps ZTP plugin manages the <literal>ManagedCluster</literal> CRs on the hub cluster based on the <literal>SiteConfig</literal> CR in your site Git repo. You create individual <literal>BMCSecret</literal> CRs for each host manually.</simpara>
</listitem>
</varlistentry>
</variablelist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the required managed cluster secrets on the hub cluster. These resources must be in a namespace with a name matching the cluster name. For example, in <literal>out/argocd/example/siteconfig/example-sno.yaml</literal>, the cluster name and namespace is <literal>example-sno</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the cluster namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export CLUSTERNS=example-sno</programlisting>
</listitem>
<listitem>
<simpara>Create the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create namespace $CLUSTERNS</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create pull secret and BMC <literal>Secret</literal> CRs for the managed cluster. The pull secret must contain all the credentials necessary for installing OpenShift Container Platform and all required Operators. See "Creating the managed bare-metal host secrets" for more information.</simpara>
<note>
<simpara>The secrets are referenced from the <literal>SiteConfig</literal> custom resource (CR) by name. The namespace must match the <literal>SiteConfig</literal> namespace.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a <literal>SiteConfig</literal> CR for your cluster in your local clone of the Git repository:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose the appropriate example for your CR from the  <literal>out/argocd/example/siteconfig/</literal> folder.
The folder includes example files for single node, three-node, and standard clusters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>example-sno.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>example-3node.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>example-standard.yaml</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Change the cluster and host details in the example file to match the type of cluster you want. For example:</simpara>
<formalpara>
<title>Example single-node OpenShift SiteConfig CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># example-node1-bmh-secret &amp; assisted-deployment-pull-secret need to be created under same namespace example-sno
---
apiVersion: ran.openshift.io/v1
kind: SiteConfig
metadata:
  name: "example-sno"
  namespace: "example-sno"
spec:
  baseDomain: "example.com"
  pullSecretRef:
    name: "assisted-deployment-pull-secret"
  clusterImageSetNameRef: "openshift-4.10"
  sshPublicKey: "ssh-rsa AAAA..."
  clusters:
    - clusterName: "example-sno"
      networkType: "OVNKubernetes"
      # installConfigOverrides is a generic way of passing install-config
      # parameters through the siteConfig.  The 'capabilities' field configures
      # the composable openshift feature.  In this 'capabilities' setting, we
      # remove all but the marketplace component from the optional set of
      # components.
      # Notes:
      # - NodeTuning is needed for 4.13 and later, not for 4.12 and earlier
      installConfigOverrides: '{"capabilities":{"baselineCapabilitySet": "None", "additionalEnabledCapabilities": [ "marketplace", "NodeTuning" ] }}'
      # It is strongly recommended to include crun manifests as part of the additional install-time manifests for 4.13+.
      # The crun manifests can be obtained from source-crs/optional-extra-manifest/ and added to the git repo ie.sno-extra-manifest.
      # extraManifestPath: sno-extra-manifest
      clusterLabels:
        # These example cluster labels correspond to the bindingRules in the PolicyGenTemplate examples
        du-profile: "4.14"
        # These example cluster labels correspond to the bindingRules in the PolicyGenTemplate examples in ../policygentemplates:
        # ../policygentemplates/common-ranGen.yaml will apply to all clusters with 'common: true'
        common: true
        # ../policygentemplates/group-du-sno-ranGen.yaml will apply to all clusters with 'group-du-sno: ""'
        group-du-sno: ""
        # ../policygentemplates/example-sno-site.yaml will apply to all clusters with 'sites: "example-sno"'
        # Normally this should match or contain the cluster name so it only applies to a single cluster
        sites: "example-sno"
      clusterNetwork:
        - cidr: 1001:1::/48
          hostPrefix: 64
      machineNetwork:
        - cidr: 1111:2222:3333:4444::/64
      serviceNetwork:
        - 1001:2::/112
      additionalNTPSources:
        - 1111:2222:3333:4444::2
      # Initiates the cluster for workload partitioning. Setting specific reserved/isolated CPUSets is done via PolicyTemplate
      # please see Workload Partitioning Feature for a complete guide.
      cpuPartitioningMode: AllNodes
      # Optionally; This can be used to override the KlusterletAddonConfig that is created for this cluster:
      #crTemplates:
      #  KlusterletAddonConfig: "KlusterletAddonConfigOverride.yaml"
      nodes:
        - hostName: "example-node1.example.com"
          role: "master"
          # Optionally; This can be used to configure desired BIOS setting on a host:
          #biosConfigRef:
          #  filePath: "example-hw.profile"
          bmcAddress: "idrac-virtualmedia+https://[1111:2222:3333:4444::bbbb:1]/redfish/v1/Systems/System.Embedded.1"
          bmcCredentialsName:
            name: "example-node1-bmh-secret"
          bootMACAddress: "AA:BB:CC:DD:EE:11"
          # Use UEFISecureBoot to enable secure boot
          bootMode: "UEFI"
          rootDeviceHints:
            wwn: "0x11111000000asd123"
            # example of diskPartition below is used for image registry (check ImageRegistry.md for more details), but it's not limited to this use case
          #        diskPartition:
          #          - device: /dev/disk/by-id/wwn-0x11111000000asd123 # match rootDeviceHints
          #            partitions:
          #              - mount_point: /var/imageregistry
          #                size: 102500
          #                start: 344844

          nodeNetwork:
            interfaces:
              - name: eno1
                macAddress: "AA:BB:CC:DD:EE:11"
            config:
              interfaces:
                - name: eno1
                  type: ethernet
                  state: up
                  ipv4:
                    enabled: false
                  ipv6:
                    enabled: true
                    address:
                      # For SNO sites with static IP addresses, the node-specific,
                      # API and Ingress IPs should all be the same and configured on
                      # the interface
                      - ip: 1111:2222:3333:4444::aaaa:1
                        prefix-length: 64
              dns-resolver:
                config:
                  search:
                    - example.com
                  server:
                    - 1111:2222:3333:4444::2
              routes:
                config:
                  - destination: ::/0
                    next-hop-interface: eno1
                    next-hop-address: 1111:2222:3333:4444::1
                    table-id: 254</programlisting>
</para>
</formalpara>
<note>
<simpara>For more information about BMC addressing, see the "Additional resources" section.</simpara>
</note>
</listitem>
<listitem>
<simpara>You can inspect the default set of extra-manifest <literal>MachineConfig</literal> CRs in <literal>out/argocd/extra-manifest</literal>. It is automatically applied to the cluster when it is installed.</simpara>
</listitem>
<listitem>
<simpara>Optional: To provision additional install-time manifests on the provisioned cluster, create a directory in your Git repository, for example, <literal>sno-extra-manifest/</literal>, and add your custom manifest CRs to this directory. If your <literal>SiteConfig.yaml</literal> refers to this directory in the <literal>extraManifestPath</literal> field, any CRs in this referenced directory are appended to the default set of extra manifests.</simpara>
<important>
<title>Enabling the crun OCI container runtime</title>
<simpara>For optimal cluster performance, enable crun for master and worker nodes in single-node OpenShift, single-node OpenShift with additional worker nodes, three-node OpenShift, and standard clusters.</simpara>
<simpara>Enable crun in a <literal>ContainerRuntimeConfig</literal> CR as an additional Day 0 install-time manifest to avoid the cluster having to reboot.</simpara>
<simpara>The <literal>enable-crun-master.yaml</literal> and <literal>enable-crun-worker.yaml</literal> CR files are in the <literal>out/source-crs/optional-extra-manifest/</literal> folder that you can extract from the <literal>ztp-site-generate</literal> container.
For more information, see "Customizing extra installation manifests in the GitOps ZTP pipeline".</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add the <literal>SiteConfig</literal> CR to the <literal>kustomization.yaml</literal> file in the <literal>generators</literal> section, similar to the example shown in <literal>out/argocd/example/siteconfig/kustomization.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Commit the <literal>SiteConfig</literal> CR and associated <literal>kustomization.yaml</literal> changes in your Git repository and push the changes.</simpara>
<simpara>The ArgoCD pipeline detects the changes and begins the managed cluster deployment.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the custom roles and labels are applied after the node is deployed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node example-node.example.com</programlisting>
</listitem>
</itemizedlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:   example-node.example.com
Roles:  control-plane,example-label,master,worker
Labels: beta.kubernetes.io/arch=amd64
        beta.kubernetes.io/os=linux
        custom-label/parameter1=true
        kubernetes.io/arch=amd64
        kubernetes.io/hostname=cnfdf03.telco5gran.eng.rdu2.redhat.com
        kubernetes.io/os=linux
        node-role.kubernetes.io/control-plane=
        node-role.kubernetes.io/example-label= <co xml:id="CO58-1"/>
        node-role.kubernetes.io/master=
        node-role.kubernetes.io/worker=
        node.openshift.io/os_id=rhcos</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO58-1">
<para>The custom label is applied to the node.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-sno-siteconfig-config-reference_ztp-deploying-far-edge-sites">Single-node OpenShift SiteConfig CR installation reference</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-sno-siteconfig-config-reference_ztp-deploying-far-edge-sites">
<title>Single-node OpenShift SiteConfig CR installation reference</title>
<table frame="all" rowsep="1" colsep="1">
<title>SiteConfig CR installation options for single-node OpenShift clusters</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">SiteConfig CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.cpuPartitioningMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure workload partitioning by setting the value for <literal>cpuPartitioningMode</literal> to <literal>AllNodes</literal>.
To complete the configuration, specify the <literal>isolated</literal> and <literal>reserved</literal> CPUs in the <literal>PerformanceProfile</literal> CR.</simpara>
<note>
<simpara>Configuring workload partitioning by using the <literal>cpuPartitioningMode</literal> field in the <literal>SiteConfig</literal> CR is a Tech Preview feature in OpenShift Container Platform 4.13.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set <literal>name</literal> to <literal>assisted-deployment-pull-secret</literal> and create the <literal>assisted-deployment-pull-secret</literal> CR in the same namespace as the <literal>SiteConfig</literal> CR.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>clusterImageSetNameRef</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the image set available on the hub cluster.
To see the list of supported versions on your hub cluster, run <literal>oc get clusterimagesets</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>installConfigOverrides</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the <literal>installConfigOverrides</literal> field to enable or disable optional components prior to cluster installation.</simpara>
<important>
<simpara>Use the reference configuration as specified in the example <literal>SiteConfig</literal> CR.
Adding additional components back into the system might require additional reserved CPU capacity.</simpara>
</important></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.clusterLabels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure cluster labels to correspond to the <literal>bindingRules</literal> field in the <literal>PolicyGenTemplate</literal> CRs that you define.
For example, <literal>policygentemplates/common-ranGen.yaml</literal> applies to all clusters with <literal>common: true</literal> set, <literal>policygentemplates/group-du-sno-ranGen.yaml</literal> applies to all clusters with <literal>group-du-sno: ""</literal> set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.crTemplates.KlusterletAddonConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. Set <literal>KlusterletAddonConfig</literal> to <literal>KlusterletAddonConfigOverride.yaml to override the default `KlusterletAddonConfig</literal> that is created for the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.hostName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>For single-node deployments, define a single host.
For three-node deployments, define three hosts.
For standard deployments, define three hosts with <literal>role: master</literal> and two or more hosts defined with <literal>role: worker</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.nodeLabels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify custom roles for your nodes in your managed clusters. These are additional roles are not used by any OpenShift Container Platform components, only by the user. When you add a custom role, it can be associated with a custom machine config pool that references a specific configuration for that role. Adding custom labels or roles during installation makes the deployment process more effective and prevents the need for additional reboots after the installation is complete.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.automatedCleaningMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. Uncomment and set the value to <literal>metadata</literal> to enable the removal of the disk&#8217;s partitioning table only, without fully wiping the disk. The default value is <literal>disabled</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.bmcAddress</literal></simpara></entry>
<entry align="left" valign="top"><simpara>BMC address that you use to access the host. Applies to all cluster types. GitOps ZTP supports iPXE and virtual media booting by using Redfish or IPMI protocols. To use iPXE booting, you must use RHACM 2.8 or later. For more information about BMC addressing, see the "Additional resources" section.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.bmcAddress</literal></simpara></entry>
<entry align="left" valign="top"><simpara>BMC address that you use to access the host.
Applies to all cluster types.
GitOps ZTP supports iPXE and virtual media booting by using Redfish or IPMI protocols.
To use iPXE booting, you must use RHACM 2.8 or later.
For more information about BMC addressing, see the "Additional resources" section.</simpara>
<note>
<simpara>In far edge Telco use cases, only virtual media is supported for use with GitOps ZTP.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.bmcCredentialsName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the <literal>bmh-secret</literal> CR that you separately create with the host BMC credentials.
When creating the <literal>bmh-secret</literal> CR, use the same namespace as the <literal>SiteConfig</literal> CR that provisions the host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.bootMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the boot mode for the host to <literal>UEFI</literal>.
The default value is <literal>UEFI</literal>. Use <literal>UEFISecureBoot</literal> to enable secure boot on the host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.rootDeviceHints</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the device for deployment. Identifiers that are stable across reboots are recommended, for example, <literal>wwn: &lt;disk_wwn&gt;</literal> or <literal>deviceName: /dev/disk/by-path/&lt;device_path&gt;</literal>. For a detailed list of stable identifiers, see the "About root device hints section".</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.diskPartition</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The provided example <literal>diskPartition</literal> is used to configure additional disk partitions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.ignitionConfigOverride</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. Use this field to assign partitions for persistent storage.
Adjust disk ID and size to the specific hardware.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.cpuset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure <literal>cpuset</literal> to match value that you set in the cluster <literal>PerformanceProfile</literal> CR <literal>spec.cpu.reserved</literal> field for workload partitioning.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.nodeNetwork</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the network settings for the node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.clusters.nodes.nodeNetwork.config.interfaces.ipv6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the IPv6 address for the host.
For single-node OpenShift clusters with static IP addresses, the node-specific API and Ingress IPs should be the same.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-customizing-the-install-extra-manifests_ztp-advanced-install-ztp">Customizing extra installation manifests in the GitOps ZTP pipeline</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">Preparing the GitOps ZTP site configuration repository</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-configuring-hub-cluster-with-argocd_ztp-preparing-the-hub-cluster">Configuring the hub cluster with ArgoCD</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-creating-a-validator-inform-policy_ztp-advanced-policy-config">Signalling ZTP cluster deployment completion with validator inform policies</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-creating-the-site-secrets_ztp-manual-install">Creating the managed bare-metal host secrets</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#bmc-addressing_ipi-install-installation-workflow">BMC addressing</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#root-device-hints_preparing-to-install-with-agent-based-installer">About root device hints</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-monitoring-deployment-progress_ztp-deploying-far-edge-sites">
<title>Monitoring managed cluster installation progress</title>
<simpara>The ArgoCD pipeline uses the <literal>SiteConfig</literal> CR to generate the cluster configuration CRs and syncs it with the hub cluster. You can monitor the progress of the synchronization in the ArgoCD dashboard.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>When the synchronization is complete, the installation generally proceeds as follows:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The Assisted Service Operator installs OpenShift Container Platform on the cluster. You can monitor the progress of cluster installation from the RHACM dashboard or from the command line by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the cluster name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export CLUSTER=&lt;clusterName&gt;</programlisting>
</listitem>
<listitem>
<simpara>Query the <literal>AgentClusterInstall</literal> CR for the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get agentclusterinstall -n $CLUSTER $CLUSTER -o jsonpath='{.status.conditions[?(@.type=="Completed")]}' | jq</programlisting>
</listitem>
<listitem>
<simpara>Get the installation events for the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -sk $(oc get agentclusterinstall -n $CLUSTER $CLUSTER -o jsonpath='{.status.debugInfo.eventsURL}')  | jq '.[-2,-1]'</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-troubleshooting-ztp-gitops-installation-crs_ztp-deploying-far-edge-sites">
<title>Troubleshooting GitOps ZTP by validating the installation CRs</title>
<simpara>The ArgoCD pipeline uses the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> custom resources (CRs) to generate the cluster configuration CRs and Red Hat Advanced Cluster Management (RHACM) policies. Use the following steps to troubleshoot issues that might occur during this process.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check that the installation CRs were created by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get AgentClusterInstall -n &lt;cluster_name&gt;</programlisting>
<simpara>If no object is returned, use the following steps to troubleshoot the ArgoCD pipeline flow from <literal>SiteConfig</literal> files to the installation CRs.</simpara>
</listitem>
<listitem>
<simpara>Verify that the <literal>ManagedCluster</literal> CR was generated using the <literal>SiteConfig</literal> CR on the hub cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster</programlisting>
</listitem>
<listitem>
<simpara>If the <literal>ManagedCluster</literal> is missing, check if the <literal>clusters</literal> application failed to synchronize the files from the Git repository to the hub cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -n openshift-gitops application clusters</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check for the <literal>Status.Conditions</literal> field to view the error logs for the managed cluster. For example, setting an invalid value for <literal>extraManifestPath:</literal> in the <literal>SiteConfig</literal> CR raises the following error:</simpara>
<programlisting language="text" linenumbering="unnumbered">Status:
  Conditions:
    Last Transition Time:  2021-11-26T17:21:39Z
    Message:               rpc error: code = Unknown desc = `kustomize build /tmp/https___git.com/ran-sites/siteconfigs/ --enable-alpha-plugins` failed exit status 1: 2021/11/26 17:21:40 Error could not create extra-manifest ranSite1.extra-manifest3 stat extra-manifest3: no such file or directory 2021/11/26 17:21:40 Error: could not build the entire SiteConfig defined by /tmp/kust-plugin-config-913473579: stat extra-manifest3: no such file or directory Error: failure in plugin configured via /tmp/kust-plugin-config-913473579; exit status 1: exit status 1
    Type:  ComparisonError</programlisting>
</listitem>
<listitem>
<simpara>Check the <literal>Status.Sync</literal> field. If there are log errors, the <literal>Status.Sync</literal> field could indicate an <literal>Unknown</literal> error:</simpara>
<programlisting language="text" linenumbering="unnumbered">Status:
  Sync:
    Compared To:
      Destination:
        Namespace:  clusters-sub
        Server:     https://kubernetes.default.svc
      Source:
        Path:             sites-config
        Repo URL:         https://git.com/ran-sites/siteconfigs/.git
        Target Revision:  master
    Status:               Unknown</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-troubleshooting-ztp-gitops-supermicro-tls_ztp-deploying-far-edge-sites">
<title>Troubleshooting GitOps ZTP virtual media booting on Supermicro servers</title>
<simpara>SuperMicro X11 servers do not support virtual media installations when the image is served using the <literal>https</literal> protocol. As a result, single-node OpenShift deployments for this environment fail to boot on the target node. To avoid this issue, log in to the hub cluster and disable Transport Layer Security (TLS) in the <literal>Provisioning</literal> resource. This ensures the image is not served with TLS even though the image address uses the <literal>https</literal> scheme.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Disable TLS in the <literal>Provisioning</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch provisioning provisioning-configuration --type merge -p '{"spec":{"disableVirtualMediaTLS": true}}'</programlisting>
</listitem>
<listitem>
<simpara>Continue the steps to deploy your single-node OpenShift cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-site-cleanup_ztp-deploying-far-edge-sites">
<title>Removing a managed cluster site from the GitOps ZTP pipeline</title>
<simpara>You can remove a managed site and the associated installation and configuration policy CRs from the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Remove a site and the associated CRs by removing the associated <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> files from the <literal>kustomization.yaml</literal> file.</simpara>
<simpara>When you run the GitOps ZTP pipeline again, the generated CRs are removed.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you want to permanently remove a site, you should also remove the <literal>SiteConfig</literal> and site-specific <literal>PolicyGenTemplate</literal> files from the Git repository.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you want to remove a site temporarily, for example when redeploying a site, you can leave the <literal>SiteConfig</literal> and site-specific <literal>PolicyGenTemplate</literal> CRs in the Git repository.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>After removing the <literal>SiteConfig</literal> file from the Git repository, if the corresponding clusters get stuck in the detach process, check Red Hat Advanced Cluster Management (RHACM) on the hub cluster for information about cleaning up the detached cluster.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about removing a cluster, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#remove-managed-cluster">Removing a cluster from management</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-removing-obsolete-content_ztp-deploying-far-edge-sites">
<title>Removing obsolete content from the GitOps ZTP pipeline</title>
<simpara>If a change to the <literal>PolicyGenTemplate</literal> configuration results in obsolete policies, for example, if you rename policies, use the following procedure to remove the obsolete policies.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Remove the affected <literal>PolicyGenTemplate</literal> files from the Git repository, commit and push to the remote repository.</simpara>
</listitem>
<listitem>
<simpara>Wait for the changes to synchronize through the application and the affected policies to be removed from the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>Add the updated <literal>PolicyGenTemplate</literal> files back to the Git repository, and then commit and push to the remote repository.</simpara>
<note>
<simpara>Removing GitOps Zero Touch Provisioning (ZTP) policies from the Git repository, and as a result also removing them from the hub cluster, does not affect the configuration of the managed cluster. The policy and CRs managed by that policy remains in place on the managed cluster.</simpara>
</note>
</listitem>
<listitem>
<simpara>Optional: As an alternative, after making changes to <literal>PolicyGenTemplate</literal> CRs that result in obsolete policies, you can remove these policies from the hub cluster manually. You can delete policies from the RHACM console using the <emphasis role="strong">Governance</emphasis> tab or by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete policy -n &lt;namespace&gt; &lt;policy_name&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-tearing-down-the-pipeline_ztp-deploying-far-edge-sites">
<title>Tearing down the GitOps ZTP pipeline</title>
<simpara>You can remove the ArgoCD pipeline and all generated GitOps Zero Touch Provisioning (ZTP) artifacts.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Detach all clusters from Red Hat Advanced Cluster Management (RHACM) on the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>Delete the <literal>kustomization.yaml</literal> file in the <literal>deployment</literal> directory using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -k out/argocd/deployment</programlisting>
</listitem>
<listitem>
<simpara>Commit and push your changes to the site repository.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-configuring-managed-clusters-policies">
<title>Configuring managed clusters with policies and PolicyGenTemplate resources</title>
<simpara>Applied policy custom resources (CRs) configure the managed clusters that you provision. You can customize how Red Hat Advanced Cluster Management (RHACM) uses <literal>PolicyGenTemplate</literal> CRs to generate the applied policy CRs.</simpara>
<section xml:id="ztp-the-policygentemplate_ztp-configuring-managed-clusters-policies">
<title>About the PolicyGenTemplate CRD</title>
<simpara>The <literal>PolicyGenTemplate</literal> custom resource definition (CRD) tells the <literal>PolicyGen</literal> policy generator what custom resources (CRs) to include in the cluster configuration, how to combine the CRs into the generated policies, and what items in those CRs need to be updated with overlay content.</simpara>
<simpara>The following example shows a <literal>PolicyGenTemplate</literal> CR (<literal>common-du-ranGen.yaml</literal>) extracted from the <literal>ztp-site-generate</literal> reference container. The <literal>common-du-ranGen.yaml</literal> file defines two Red Hat Advanced Cluster Management (RHACM) policies. The polices manage a collection of configuration CRs, one for each unique value of <literal>policyName</literal> in the CR. <literal>common-du-ranGen.yaml</literal> creates a single placement binding and a placement rule to bind the policies to clusters based on the labels listed in the <literal>bindingRules</literal> section.</simpara>
<formalpara>
<title>Example PolicyGenTemplate CR - common-du-ranGen.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "common"
  namespace: "ztp-common"
spec:
  bindingRules:
    common: "true" <co xml:id="CO59-1"/>
  sourceFiles: <co xml:id="CO59-2"/>
    - fileName: SriovSubscription.yaml
      policyName: "subscriptions-policy"
    - fileName: SriovSubscriptionNS.yaml
      policyName: "subscriptions-policy"
    - fileName: SriovSubscriptionOperGroup.yaml
      policyName: "subscriptions-policy"
    - fileName: SriovOperatorStatus.yaml
      policyName: "subscriptions-policy"
    - fileName: PtpSubscription.yaml
      policyName: "subscriptions-policy"
    - fileName: PtpSubscriptionNS.yaml
      policyName: "subscriptions-policy"
    - fileName: PtpSubscriptionOperGroup.yaml
      policyName: "subscriptions-policy"
    - fileName: PtpOperatorStatus.yaml
      policyName: "subscriptions-policy"
    - fileName: ClusterLogNS.yaml
      policyName: "subscriptions-policy"
    - fileName: ClusterLogOperGroup.yaml
      policyName: "subscriptions-policy"
    - fileName: ClusterLogSubscription.yaml
      policyName: "subscriptions-policy"
    - fileName: ClusterLogOperatorStatus.yaml
      policyName: "subscriptions-policy"
    - fileName: StorageNS.yaml
      policyName: "subscriptions-policy"
    - fileName: StorageOperGroup.yaml
      policyName: "subscriptions-policy"
    - fileName: StorageSubscription.yaml
      policyName: "subscriptions-policy"
    - fileName: StorageOperatorStatus.yaml
      policyName: "subscriptions-policy"
    - fileName: ReduceMonitoringFootprint.yaml
      policyName: "config-policy"
    - fileName: OperatorHub.yaml <co xml:id="CO59-3"/>
      policyName: "config-policy"
    - fileName: DefaultCatsrc.yaml <co xml:id="CO59-4"/>
      policyName: "config-policy" <co xml:id="CO59-5"/>
      metadata:
        name: redhat-operators
      spec:
        displayName: disconnected-redhat-operators
        image: registry.example.com:5000/disconnected-redhat-operators/disconnected-redhat-operator-index:v4.9
    - fileName: DisconnectedICSP.yaml
      policyName: "config-policy"
      spec:
        repositoryDigestMirrors:
        - mirrors:
          - registry.example.com:5000
          source: registry.redhat.io</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO59-1">
<para><literal>common: "true"</literal> applies the policies to all clusters with this label.</para>
</callout>
<callout arearefs="CO59-2">
<para>Files listed under <literal>sourceFiles</literal> create the Operator policies for installed clusters.</para>
</callout>
<callout arearefs="CO59-3">
<para><literal>OperatorHub.yaml</literal> configures the OperatorHub for the disconnected registry.</para>
</callout>
<callout arearefs="CO59-4">
<para><literal>DefaultCatsrc.yaml</literal> configures the catalog source for the disconnected registry.</para>
</callout>
<callout arearefs="CO59-5">
<para><literal>policyName: "config-policy"</literal> configures Operator subscriptions. The <literal>OperatorHub</literal> CR disables the default and this CR replaces <literal>redhat-operators</literal> with a <literal>CatalogSource</literal> CR that points to the disconnected registry.</para>
</callout>
</calloutlist>
<simpara>A <literal>PolicyGenTemplate</literal> CR can be constructed with any number of included CRs. Apply the following example CR in the hub cluster to generate a policy containing a single CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "group-du-sno"
  namespace: "ztp-group"
spec:
  bindingRules:
    group-du-sno: ""
  mcp: "master"
  sourceFiles:
    - fileName: PtpConfigSlave.yaml
      policyName: "config-policy"
      metadata:
        name: "du-ptp-slave"
      spec:
        profile:
        - name: "slave"
          interface: "ens5f0"
          ptp4lOpts: "-2 -s --summary_interval -4"
          phc2sysOpts: "-a -r -n 24"</programlisting>
<simpara>Using the source file <literal>PtpConfigSlave.yaml</literal> as an example, the file defines a <literal>PtpConfig</literal> CR. The generated policy for the <literal>PtpConfigSlave</literal> example is named <literal>group-du-sno-config-policy</literal>. The <literal>PtpConfig</literal> CR defined in the generated <literal>group-du-sno-config-policy</literal> is named <literal>du-ptp-slave</literal>. The <literal>spec</literal> defined in <literal>PtpConfigSlave.yaml</literal> is placed under <literal>du-ptp-slave</literal> along with the other <literal>spec</literal> items defined under the source file.</simpara>
<simpara>The following example shows the <literal>group-du-sno-config-policy</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: group-du-ptp-config-policy
  namespace: groups-sub
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
spec:
    remediationAction: inform
    disabled: false
    policy-templates:
        - objectDefinition:
            apiVersion: policy.open-cluster-management.io/v1
            kind: ConfigurationPolicy
            metadata:
                name: group-du-ptp-config-policy-config
            spec:
                remediationAction: inform
                severity: low
                namespaceselector:
                    exclude:
                        - kube-*
                    include:
                        - '*'
                object-templates:
                    - complianceType: musthave
                      objectDefinition:
                        apiVersion: ptp.openshift.io/v1
                        kind: PtpConfig
                        metadata:
                            name: du-ptp-slave
                            namespace: openshift-ptp
                        spec:
                            recommend:
                                - match:
                                - nodeLabel: node-role.kubernetes.io/worker-du
                                  priority: 4
                                  profile: slave
                            profile:
                                - interface: ens5f0
                                  name: slave
                                  phc2sysOpts: -a -r -n 24
                                  ptp4lConf: |
                                    [global]
                                    #
                                    # Default Data Set
                                    #
                                    twoStepFlag 1
                                    slaveOnly 0
                                    priority1 128
                                    priority2 128
                                    domainNumber 24
                                    .....</programlisting>
</section>
<section xml:id="ztp-pgt-config-best-practices_ztp-configuring-managed-clusters-policies">
<title>Recommendations when customizing PolicyGenTemplate CRs</title>
<simpara>Consider the following best practices when customizing site configuration <literal>PolicyGenTemplate</literal> custom resources (CRs):</simpara>
<itemizedlist>
<listitem>
<simpara>Use as few policies as are necessary. Using fewer policies requires less resources. Each additional policy creates overhead for the hub cluster and the deployed managed cluster. CRs are combined into policies based on the <literal>policyName</literal> field in the <literal>PolicyGenTemplate</literal> CR. CRs in the same <literal>PolicyGenTemplate</literal> which have the same value for <literal>policyName</literal> are managed under a single policy.</simpara>
</listitem>
<listitem>
<simpara>In disconnected environments, use a single catalog source for all Operators by configuring the registry as a single index containing all Operators. Each additional <literal>CatalogSource</literal> CR on the managed clusters increases CPU usage.</simpara>
</listitem>
<listitem>
<simpara><literal>MachineConfig</literal> CRs should be included as <literal>extraManifests</literal> in the <literal>SiteConfig</literal> CR so that they are applied during installation. This can reduce the overall time taken until the cluster is ready to deploy applications.</simpara>
</listitem>
<listitem>
<simpara><literal>PolicyGenTemplates</literal> should override the channel field to explicitly identify the desired version. This ensures that changes in the source CR during upgrades does not update the generated subscription.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For recommendations about scaling clusters with RHACM, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html/install/installing#performance-and-scalability">Performance and scalability</link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>When managing large numbers of spoke clusters on the hub cluster, minimize the number of policies to reduce resource consumption.</simpara>
<simpara>Grouping multiple configuration CRs into a single or limited number of policies is one way to reduce the overall number of policies on the hub cluster. When using the common, group, and site hierarchy of policies for managing site configuration, it is especially important to combine site-specific configuration into a single policy.</simpara>
</note>
</section>
<section xml:id="ztp-policygentemplates-for-ran_ztp-configuring-managed-clusters-policies">
<title>PolicyGenTemplate CRs for RAN deployments</title>
<simpara>Use <literal>PolicyGenTemplate</literal> (PGT) custom resources (CRs) to customize the configuration applied to the cluster by using the GitOps Zero Touch Provisioning (ZTP) pipeline. The PGT CR allows you to generate one or more policies to manage the set of configuration CRs on your fleet of clusters. The PGT identifies the set of managed CRs, bundles them into policies, builds the policy wrapping around those CRs, and associates the policies with clusters by using label binding rules.</simpara>
<simpara>The reference configuration, obtained from the GitOps ZTP container, is designed to provide a set of critical features and node tuning settings that ensure the cluster can support the stringent performance and resource utilization constraints typical of RAN (Radio Access Network) Distributed Unit (DU) applications. Changes or omissions from the baseline configuration can affect feature availability, performance, and resource utilization. Use the reference <literal>PolicyGenTemplate</literal> CRs as the basis to create a hierarchy of configuration files tailored to your specific site requirements.</simpara>
<simpara>The baseline <literal>PolicyGenTemplate</literal> CRs that are defined for RAN DU cluster configuration can be extracted from the GitOps ZTP <literal>ztp-site-generate</literal> container. See "Preparing the GitOps ZTP site configuration repository" for further details.</simpara>
<simpara>The <literal>PolicyGenTemplate</literal> CRs can be found in the <literal>./out/argocd/example/policygentemplates</literal> folder. The reference architecture has common, group, and site-specific configuration CRs. Each <literal>PolicyGenTemplate</literal> CR refers to other CRs that can be found in the <literal>./out/source-crs</literal> folder.</simpara>
<simpara>The <literal>PolicyGenTemplate</literal> CRs relevant to RAN cluster configuration are described below. Variants are provided for the group <literal>PolicyGenTemplate</literal> CRs to account for differences in single-node, three-node compact, and standard cluster configurations. Similarly, site-specific configuration variants are provided for single-node clusters and multi-node (compact or standard) clusters. Use the group and site-specific configuration variants that are relevant for your deployment.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>PolicyGenTemplate CRs for RAN deployments</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">PolicyGenTemplate CR</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>example-multinode-site.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains a set of CRs that get applied to multi-node clusters. These CRs configure SR-IOV features typical for RAN installations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>example-sno-site.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains a set of CRs that get applied to single-node OpenShift clusters. These CRs configure SR-IOV features typical for RAN installations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>common-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains a set of common RAN CRs that get applied to all clusters. These CRs subscribe to a set of operators providing cluster features typical for RAN as well as baseline cluster tuning.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-3node-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the RAN policies for three-node clusters only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-sno-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the RAN policies for single-node clusters only.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-standard-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the RAN policies for standard three control-plane clusters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-3node-validator-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PolicyGenTemplate</literal> CR used to generate the various policies required for three-node clusters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-standard-validator-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PolicyGenTemplate</literal> CR used to generate the various policies required for standard clusters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>group-du-sno-validator-ranGen.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PolicyGenTemplate</literal> CR used to generate the various policies required for single-node OpenShift clusters.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">Preparing the GitOps ZTP site configuration repository</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-customizing-a-managed-site-using-pgt_ztp-configuring-managed-clusters-policies">
<title>Customizing a managed cluster with PolicyGenTemplate CRs</title>
<simpara>Use the following procedure to customize the policies that get applied to the managed cluster that you provision using the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You configured the hub cluster for generating the required installation and policy CRs.</simpara>
</listitem>
<listitem>
<simpara>You created a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for the Argo CD application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>PolicyGenTemplate</literal> CR for site-specific configuration CRs.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose the appropriate example for your CR from the <literal>out/argocd/example/policygentemplates</literal> folder, for example, <literal>example-sno-site.yaml</literal> or <literal>example-multinode-site.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change the <literal>bindingRules</literal> field in the example file to match the site-specific label included in the <literal>SiteConfig</literal> CR. In the example <literal>SiteConfig</literal> file, the site-specific label is <literal>sites: example-sno</literal>.</simpara>
<note>
<simpara>Ensure that the labels defined in your <literal>PolicyGenTemplate</literal> <literal>bindingRules</literal> field correspond to the labels that are defined in the related managed clusters <literal>SiteConfig</literal> CR.</simpara>
</note>
</listitem>
<listitem>
<simpara>Change the content in the example file to match the desired configuration.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a <literal>PolicyGenTemplate</literal> CR for any common configuration CRs that apply to the entire fleet of clusters.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the appropriate example for your CR from the <literal>out/argocd/example/policygentemplates</literal> folder, for example, <literal>common-ranGen.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change the content in the example file to match the desired configuration.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a <literal>PolicyGenTemplate</literal> CR for any group configuration CRs that apply to the certain groups of clusters in the fleet.</simpara>
<simpara>Ensure that the content of the overlaid spec files matches your desired end state. As a reference, the out/source-crs directory contains the full list of source-crs available to be included and overlaid by your PolicyGenTemplate templates.</simpara>
<note>
<simpara>Depending on the specific requirements of your clusters, you might need more than a single group policy per cluster type, especially considering that the example group policies each have a single PerformancePolicy.yaml file that can only be shared across a set of clusters if those clusters consist of identical hardware configurations.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the appropriate example for your CR from the <literal>out/argocd/example/policygentemplates</literal> folder, for example, <literal>group-du-sno-ranGen.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change the content in the example file to match the desired configuration.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional. Create a validator inform policy <literal>PolicyGenTemplate</literal> CR to signal when the GitOps ZTP installation and configuration of the deployed cluster is complete. For more information, see "Creating a validator inform policy".</simpara>
</listitem>
<listitem>
<simpara>Define all the policy namespaces in a YAML file similar to the example <literal>out/argocd/example/policygentemplates/ns.yaml</literal> file.</simpara>
<important>
<simpara>Do not include the <literal>Namespace</literal> CR in the same file with the <literal>PolicyGenTemplate</literal> CR.</simpara>
</important>
</listitem>
<listitem>
<simpara>Add the <literal>PolicyGenTemplate</literal> CRs and <literal>Namespace</literal> CR to the <literal>kustomization.yaml</literal> file in the generators section, similar to the example shown in <literal>out/argocd/example/policygentemplates/kustomization.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> CRs, <literal>Namespace</literal> CR, and associated <literal>kustomization.yaml</literal> file in your Git repository and push the changes.</simpara>
<simpara>The ArgoCD pipeline detects the changes and begins the managed cluster deployment. You can push the changes to the <literal>SiteConfig</literal> CR and the <literal>PolicyGenTemplate</literal> CR simultaneously.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-creating-a-validator-inform-policy_ztp-advanced-policy-config">Signalling ZTP cluster deployment completion with validator inform policies</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-monitoring-policy-deployment-progress_ztp-configuring-managed-clusters-policies">
<title>Monitoring managed cluster policy deployment progress</title>
<simpara>The ArgoCD pipeline uses <literal>PolicyGenTemplate</literal> CRs in Git to generate the RHACM policies and then sync them to the hub cluster. You can monitor the progress of the managed cluster policy synchronization after the assisted service installs OpenShift Container Platform on the managed cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>The Topology Aware Lifecycle Manager (TALM) applies the configuration policies that are bound to the cluster.</simpara>
<simpara>After the cluster installation is complete and the cluster becomes <literal>Ready</literal>, a <literal>ClusterGroupUpgrade</literal> CR corresponding to this cluster, with a list of ordered policies defined by the <literal>ran.openshift.io/ztp-deploy-wave annotations</literal>, is automatically created by the TALM. The cluster&#8217;s policies are applied in the order listed in <literal>ClusterGroupUpgrade</literal> CR.</simpara>
<simpara>You can monitor the high-level progress of configuration policy reconciliation by using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export CLUSTER=&lt;clusterName&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clustergroupupgrades -n ztp-install $CLUSTER -o jsonpath='{.status.conditions[-1:]}' | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "lastTransitionTime": "2022-11-09T07:28:09Z",
  "message": "The ClusterGroupUpgrade CR has upgrade policies that are still non compliant",
  "reason": "InProgress",
  "status": "True",
  "type": "Progressing"
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can monitor the detailed cluster policy compliance status by using the RHACM dashboard or the command line.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To check policy compliance by using <literal>oc</literal>, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies -n $CLUSTER</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                     REMEDIATION ACTION   COMPLIANCE STATE   AGE
ztp-common.common-config-policy                          inform               Compliant          3h42m
ztp-common.common-subscriptions-policy                   inform               NonCompliant       3h42m
ztp-group.group-du-sno-config-policy                     inform               NonCompliant       3h42m
ztp-group.group-du-sno-validator-du-policy               inform               NonCompliant       3h42m
ztp-install.example1-common-config-policy-pjz9s          enforce              Compliant          167m
ztp-install.example1-common-subscriptions-policy-zzd9k   enforce              NonCompliant       164m
ztp-site.example1-config-policy                          inform               NonCompliant       3h42m
ztp-site.example1-perf-policy                            inform               NonCompliant       3h42m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To check policy status from the RHACM web console, perform the following actions:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Click <emphasis role="strong">Governance</emphasis> &#8594; <emphasis role="strong">Find policies</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click on a cluster policy to check it&#8217;s status.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>When all of the cluster policies become compliant, GitOps ZTP installation and configuration for the cluster is complete. The <literal>ztp-done</literal> label is added to the cluster.</simpara>
<simpara>In the reference configuration, the final policy that becomes compliant is the one defined in the <literal>*-du-validator-policy</literal> policy. This policy, when compliant on a cluster, ensures that all cluster configuration, Operator installation, and Operator configuration is complete.</simpara>
</section>
<section xml:id="ztp-validating-the-generation-of-configuration-policy-crs_ztp-configuring-managed-clusters-policies">
<title>Validating the generation of configuration policy CRs</title>
<simpara>Policy custom resources (CRs) are generated in the same namespace as the <literal>PolicyGenTemplate</literal> from which they are created. The same troubleshooting flow applies to all policy CRs generated from a <literal>PolicyGenTemplate</literal> regardless of whether they are <literal>ztp-common</literal>, <literal>ztp-group</literal>, or <literal>ztp-site</literal> based, as shown using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export NS=&lt;namespace&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policy -n $NS</programlisting>
<simpara>The expected set of policy-wrapped CRs should be displayed.</simpara>
<simpara>If the policies failed synchronization, use the following troubleshooting steps.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To display detailed information about the policies, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -n openshift-gitops application policies</programlisting>
</listitem>
<listitem>
<simpara>Check for <literal>Status: Conditions:</literal> to show the error logs. For example, setting an invalid <literal>sourceFilefileName:</literal> generates the error shown below:</simpara>
<programlisting language="text" linenumbering="unnumbered">Status:
  Conditions:
    Last Transition Time:  2021-11-26T17:21:39Z
    Message:               rpc error: code = Unknown desc = `kustomize build /tmp/https___git.com/ran-sites/policies/ --enable-alpha-plugins` failed exit status 1: 2021/11/26 17:21:40 Error could not find test.yaml under source-crs/: no such file or directory Error: failure in plugin configured via /tmp/kust-plugin-config-52463179; exit status 1: exit status 1
    Type:  ComparisonError</programlisting>
</listitem>
<listitem>
<simpara>Check for <literal>Status: Sync:</literal>. If there are log errors at <literal>Status: Conditions:</literal>, the <literal>Status: Sync:</literal> shows <literal>Unknown</literal> or <literal>Error</literal>:</simpara>
<programlisting language="text" linenumbering="unnumbered">Status:
  Sync:
    Compared To:
      Destination:
        Namespace:  policies-sub
        Server:     https://kubernetes.default.svc
      Source:
        Path:             policies
        Repo URL:         https://git.com/ran-sites/policies/.git
        Target Revision:  master
    Status:               Error</programlisting>
</listitem>
<listitem>
<simpara>When Red Hat Advanced Cluster Management (RHACM) recognizes that policies apply to a <literal>ManagedCluster</literal> object, the policy CR objects are applied to the cluster namespace. Check to see if the policies were copied to the cluster namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policy -n $CLUSTER</programlisting>
<formalpara>
<title>Example output:</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         REMEDIATION ACTION   COMPLIANCE STATE   AGE
ztp-common.common-config-policy              inform               Compliant          13d
ztp-common.common-subscriptions-policy       inform               Compliant          13d
ztp-group.group-du-sno-config-policy         inform               Compliant          13d
Ztp-group.group-du-sno-validator-du-policy   inform               Compliant          13d
ztp-site.example-sno-config-policy           inform               Compliant          13d</programlisting>
</para>
</formalpara>
<simpara>RHACM copies all applicable policies into the cluster namespace. The copied policy names have the format: <literal>&lt;policyGenTemplate.Namespace&gt;.&lt;policyGenTemplate.Name&gt;-&lt;policyName&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>Check the placement rule for any policies not copied to the cluster namespace. The <literal>matchSelector</literal> in the <literal>PlacementRule</literal> for those policies should match labels on the <literal>ManagedCluster</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get placementrule -n $NS</programlisting>
</listitem>
<listitem>
<simpara>Note the <literal>PlacementRule</literal> name appropriate for the missing policy, common, group, or site, using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get placementrule -n $NS &lt;placementRuleName&gt; -o yaml</programlisting>
<itemizedlist>
<listitem>
<simpara>The status-decisions should include your cluster name.</simpara>
</listitem>
<listitem>
<simpara>The key-value pair of the <literal>matchSelector</literal> in the spec must match the labels on your managed cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Check the labels on the <literal>ManagedCluster</literal> object using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ManagedCluster $CLUSTER -o jsonpath='{.metadata.labels}' | jq</programlisting>
</listitem>
<listitem>
<simpara>Check to see which policies are compliant using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policy -n $CLUSTER</programlisting>
<simpara>If the <literal>Namespace</literal>, <literal>OperatorGroup</literal>, and <literal>Subscription</literal> policies are compliant but the Operator configuration policies are not, it is likely that the Operators did not install on the managed cluster. This causes the Operator configuration policies to fail to apply because the CRD is not yet applied to the spoke.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-restarting-policies-reconciliation_ztp-configuring-managed-clusters-policies">
<title>Restarting policy reconciliation</title>
<simpara>You can restart policy reconciliation when unexpected compliance issues occur, for example, when the <literal>ClusterGroupUpgrade</literal> custom resource (CR) has timed out.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>A <literal>ClusterGroupUpgrade</literal> CR is generated in the namespace <literal>ztp-install</literal> by the Topology Aware Lifecycle Manager after the managed cluster becomes <literal>Ready</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export CLUSTER=&lt;clusterName&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clustergroupupgrades -n ztp-install $CLUSTER</programlisting>
</listitem>
<listitem>
<simpara>If there are unexpected issues and the policies fail to become complaint within the configured timeout (the default is 4 hours), the status of the <literal>ClusterGroupUpgrade</literal> CR shows <literal>UpgradeTimedOut</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clustergroupupgrades -n ztp-install $CLUSTER -o jsonpath='{.status.conditions[?(@.type=="Ready")]}'</programlisting>
</listitem>
<listitem>
<simpara>A <literal>ClusterGroupUpgrade</literal> CR in the <literal>UpgradeTimedOut</literal> state automatically restarts its policy reconciliation every hour. If you have changed your policies, you can start a retry immediately by deleting the existing <literal>ClusterGroupUpgrade</literal> CR. This triggers the automatic creation of a new <literal>ClusterGroupUpgrade</literal> CR that begins reconciling the policies immediately:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clustergroupupgrades -n ztp-install $CLUSTER</programlisting>
</listitem>
</orderedlist>
<simpara>Note that when the <literal>ClusterGroupUpgrade</literal> CR completes with status <literal>UpgradeCompleted</literal> and the managed cluster has the label <literal>ztp-done</literal> applied, you can make additional configuration changes using <literal>PolicyGenTemplate</literal>. Deleting the existing <literal>ClusterGroupUpgrade</literal> CR will not make the TALM generate a new CR.</simpara>
<simpara>At this point, GitOps ZTP has completed its interaction with the cluster and any further interactions should be treated as an update and a new <literal>ClusterGroupUpgrade</literal> CR created for remediation of the policies.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about using Topology Aware Lifecycle Manager (TALM) to construct your own <literal>ClusterGroupUpgrade</literal> CR, see <link linkend="talo-about-cgu-crs_cnf-topology-aware-lifecycle-manager">About the ClusterGroupUpgrade CR</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-removing-content-from-managed-clusters_ztp-configuring-managed-clusters-policies">
<title>Changing applied managed cluster CRs using policies</title>
<simpara>You can remove content from a custom resource (CR) that is deployed in a managed cluster through a policy.</simpara>
<simpara>By default, all <literal>Policy</literal> CRs created from a <literal>PolicyGenTemplate</literal> CR have the <literal>complianceType</literal> field set to <literal>musthave</literal>.
A <literal>musthave</literal> policy without the removed content is still compliant because the CR on the managed cluster has all the specified content.
With this configuration, when you remove content from a CR, TALM removes the content from the policy but the content is not removed from the CR on the managed cluster.</simpara>
<simpara>With the <literal>complianceType</literal> field to <literal>mustonlyhave</literal>, the policy ensures that the CR on the cluster is an exact match of what is specified in the policy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have deployed a managed cluster from a hub cluster running RHACM.</simpara>
</listitem>
<listitem>
<simpara>You have installed Topology Aware Lifecycle Manager on the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Remove the content that you no longer need from the affected CRs. In this example, the <literal>disableDrain: false</literal> line was removed from the <literal>SriovOperatorConfig</literal> CR.</simpara>
<formalpara>
<title>Example CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: sriovnetwork.openshift.io/v1
kind: SriovOperatorConfig
metadata:
  name: default
  namespace: openshift-sriov-network-operator
spec:
  configDaemonNodeSelector:
    "node-role.kubernetes.io/$mcp": ""
  disableDrain: true
  enableInjector: true
  enableOperatorWebhook: true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Change the <literal>complianceType</literal> of the affected policies to <literal>mustonlyhave</literal> in the <literal>group-du-sno-ranGen.yaml</literal> file.</simpara>
<formalpara>
<title>Example YAML</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># ...
- fileName: SriovOperatorConfig.yaml
  policyName: "config-policy"
  complianceType: mustonlyhave
# ...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>ClusterGroupUpdates</literal> CR and specify the clusters that must receive the CR changes::</simpara>
<formalpara>
<title>Example ClusterGroupUpdates CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-remove
  namespace: default
spec:
  managedPolicies:
    - ztp-group.group-du-sno-config-policy
  enable: false
  clusters:
  - spoke1
  - spoke2
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240
  batchTimeoutAction:</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cgu-remove.yaml</programlisting>
</listitem>
<listitem>
<simpara>When you are ready to apply the changes, for example, during an appropriate maintenance window, change the value of the <literal>spec.enable</literal> field to <literal>true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-remove \
--patch '{"spec":{"enable":true}}' --type=merge</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the status of the policies by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt; &lt;changed_cr_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE   NAME                                                   REMEDIATION ACTION   COMPLIANCE STATE   AGE
default     cgu-ztp-group.group-du-sno-config-policy               enforce                                 17m
default     ztp-group.group-du-sno-config-policy                   inform               NonCompliant       15h</programlisting>
</para>
</formalpara>
<simpara>When the <literal>COMPLIANCE STATE</literal> of the policy is <literal>Compliant</literal>, it means that the CR is updated and the unwanted content is removed.</simpara>
</listitem>
<listitem>
<simpara>Check that the policies are removed from the targeted clusters by running the following command on the managed clusters:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt; &lt;changed_cr_name&gt;</programlisting>
<simpara>If there are no results, the CR is removed from the managed cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-definition-of-done-for-ztp-installations_ztp-configuring-managed-clusters-policies">
<title>Indication of done for GitOps ZTP installations</title>
<simpara>GitOps Zero Touch Provisioning (ZTP) simplifies the process of checking the GitOps ZTP installation status for a cluster. The GitOps ZTP status moves through three phases: cluster installation, cluster configuration, and GitOps ZTP done.</simpara>
<variablelist>
<varlistentry>
<term>Cluster installation phase</term>
<listitem>
<simpara>The cluster installation phase is shown by the <literal>ManagedClusterJoined</literal> and  <literal>ManagedClusterAvailable</literal> conditions in the <literal>ManagedCluster</literal> CR . If the <literal>ManagedCluster</literal> CR does not have these conditions, or the condition is set to <literal>False</literal>, the cluster is still in the installation phase. Additional details about installation are available from the <literal>AgentClusterInstall</literal> and <literal>ClusterDeployment</literal> CRs. For more information, see "Troubleshooting GitOps ZTP".</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cluster configuration phase</term>
<listitem>
<simpara>The cluster configuration phase is shown by a <literal>ztp-running</literal> label applied the <literal>ManagedCluster</literal> CR for the cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GitOps ZTP done</term>
<listitem>
<simpara>Cluster installation and configuration is complete in the GitOps ZTP done phase. This is shown by the removal of the <literal>ztp-running</literal> label and addition of the <literal>ztp-done</literal> label to the <literal>ManagedCluster</literal> CR. The <literal>ztp-done</literal> label shows that the configuration has been applied and the baseline DU configuration has completed cluster tuning.</simpara>
<simpara>The transition to the GitOps ZTP done state is conditional on the compliant state of a Red Hat Advanced Cluster Management (RHACM) validator inform policy. This policy captures the existing criteria for a completed installation and validates that it moves to a compliant state only when GitOps ZTP provisioning of the managed cluster is complete.</simpara>
<simpara>The validator inform policy ensures the configuration of the cluster is fully applied and Operators have completed their initialization. The policy validates the following:</simpara>
<itemizedlist>
<listitem>
<simpara>The target <literal>MachineConfigPool</literal> contains the expected entries and has finished updating. All nodes are available and not degraded.</simpara>
</listitem>
<listitem>
<simpara>The SR-IOV Operator has completed initialization as indicated by at least one <literal>SriovNetworkNodeState</literal> with <literal>syncStatus: Succeeded</literal>.</simpara>
</listitem>
<listitem>
<simpara>The PTP Operator daemon set exists.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="ztp-manual-install">
<title>Manually installing a single-node OpenShift cluster with ZTP</title>
<simpara>You can deploy a managed single-node OpenShift cluster by using Red Hat Advanced Cluster Management (RHACM) and the assisted service.</simpara>
<note>
<simpara>If you are creating multiple managed clusters, use the <literal>SiteConfig</literal> method described in <link linkend="ztp-deploying-far-edge-sites">Deploying far edge sites with ZTP</link>.</simpara>
</note>
<important>
<simpara>The target bare-metal host must meet the networking, firmware, and hardware requirements listed in <link linkend="sno-configure-for-vdu">Recommended cluster configuration for vDU application workloads</link>.</simpara>
</important>
<section xml:id="ztp-generating-install-and-config-crs-manually_ztp-manual-install">
<title>Generating GitOps ZTP installation and configuration CRs manually</title>
<simpara>Use the <literal>generator</literal> entrypoint for the <literal>ztp-site-generate</literal> container to generate the site installation and configuration custom resource (CRs) for a cluster based on <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an output folder by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./out</programlisting>
</listitem>
<listitem>
<simpara>Export the <literal>argocd</literal> directory from the <literal>ztp-site-generate</literal> container image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --log-driver=none --rm registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 extract /home/ztp --tar | tar x -C ./out</programlisting>
<simpara>The <literal>./out</literal> directory has the reference <literal>PolicyGenTemplate</literal> and <literal>SiteConfig</literal> CRs in the <literal>out/argocd/example/</literal> folder.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">out
  argocd
       example
            policygentemplates
                 common-ranGen.yaml
                 example-sno-site.yaml
                 group-du-sno-ranGen.yaml
                 group-du-sno-validator-ranGen.yaml
                 kustomization.yaml
                 ns.yaml
            siteconfig
                   example-sno.yaml
                   KlusterletAddonConfigOverride.yaml
                   kustomization.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create an output folder for the site installation CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./site-install</programlisting>
</listitem>
<listitem>
<simpara>Modify the example <literal>SiteConfig</literal> CR for the cluster type that you want to install. Copy <literal>example-sno.yaml</literal> to <literal>site-1-sno.yaml</literal> and modify the CR to match the details of the site and bare-metal host that you want to install, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># example-node1-bmh-secret &amp; assisted-deployment-pull-secret need to be created under same namespace example-sno
---
apiVersion: ran.openshift.io/v1
kind: SiteConfig
metadata:
  name: "example-sno"
  namespace: "example-sno"
spec:
  baseDomain: "example.com"
  pullSecretRef:
    name: "assisted-deployment-pull-secret"
  clusterImageSetNameRef: "openshift-4.10"
  sshPublicKey: "ssh-rsa AAAA..."
  clusters:
    - clusterName: "example-sno"
      networkType: "OVNKubernetes"
      # installConfigOverrides is a generic way of passing install-config
      # parameters through the siteConfig.  The 'capabilities' field configures
      # the composable openshift feature.  In this 'capabilities' setting, we
      # remove all but the marketplace component from the optional set of
      # components.
      # Notes:
      # - NodeTuning is needed for 4.13 and later, not for 4.12 and earlier
      installConfigOverrides: '{"capabilities":{"baselineCapabilitySet": "None", "additionalEnabledCapabilities": [ "marketplace", "NodeTuning" ] }}'
      # It is strongly recommended to include crun manifests as part of the additional install-time manifests for 4.13+.
      # The crun manifests can be obtained from source-crs/optional-extra-manifest/ and added to the git repo ie.sno-extra-manifest.
      # extraManifestPath: sno-extra-manifest
      clusterLabels:
        # These example cluster labels correspond to the bindingRules in the PolicyGenTemplate examples
        du-profile: "4.14"
        # These example cluster labels correspond to the bindingRules in the PolicyGenTemplate examples in ../policygentemplates:
        # ../policygentemplates/common-ranGen.yaml will apply to all clusters with 'common: true'
        common: true
        # ../policygentemplates/group-du-sno-ranGen.yaml will apply to all clusters with 'group-du-sno: ""'
        group-du-sno: ""
        # ../policygentemplates/example-sno-site.yaml will apply to all clusters with 'sites: "example-sno"'
        # Normally this should match or contain the cluster name so it only applies to a single cluster
        sites: "example-sno"
      clusterNetwork:
        - cidr: 1001:1::/48
          hostPrefix: 64
      machineNetwork:
        - cidr: 1111:2222:3333:4444::/64
      serviceNetwork:
        - 1001:2::/112
      additionalNTPSources:
        - 1111:2222:3333:4444::2
      # Initiates the cluster for workload partitioning. Setting specific reserved/isolated CPUSets is done via PolicyTemplate
      # please see Workload Partitioning Feature for a complete guide.
      cpuPartitioningMode: AllNodes
      # Optionally; This can be used to override the KlusterletAddonConfig that is created for this cluster:
      #crTemplates:
      #  KlusterletAddonConfig: "KlusterletAddonConfigOverride.yaml"
      nodes:
        - hostName: "example-node1.example.com"
          role: "master"
          # Optionally; This can be used to configure desired BIOS setting on a host:
          #biosConfigRef:
          #  filePath: "example-hw.profile"
          bmcAddress: "idrac-virtualmedia+https://[1111:2222:3333:4444::bbbb:1]/redfish/v1/Systems/System.Embedded.1"
          bmcCredentialsName:
            name: "example-node1-bmh-secret"
          bootMACAddress: "AA:BB:CC:DD:EE:11"
          # Use UEFISecureBoot to enable secure boot
          bootMode: "UEFI"
          rootDeviceHints:
            wwn: "0x11111000000asd123"
            # example of diskPartition below is used for image registry (check ImageRegistry.md for more details), but it's not limited to this use case
          #        diskPartition:
          #          - device: /dev/disk/by-id/wwn-0x11111000000asd123 # match rootDeviceHints
          #            partitions:
          #              - mount_point: /var/imageregistry
          #                size: 102500
          #                start: 344844

          nodeNetwork:
            interfaces:
              - name: eno1
                macAddress: "AA:BB:CC:DD:EE:11"
            config:
              interfaces:
                - name: eno1
                  type: ethernet
                  state: up
                  ipv4:
                    enabled: false
                  ipv6:
                    enabled: true
                    address:
                      # For SNO sites with static IP addresses, the node-specific,
                      # API and Ingress IPs should all be the same and configured on
                      # the interface
                      - ip: 1111:2222:3333:4444::aaaa:1
                        prefix-length: 64
              dns-resolver:
                config:
                  search:
                    - example.com
                  server:
                    - 1111:2222:3333:4444::2
              routes:
                config:
                  - destination: ::/0
                    next-hop-interface: eno1
                    next-hop-address: 1111:2222:3333:4444::1
                    table-id: 254</programlisting>
<note>
<simpara>Once you have extracted reference CR configuration files from the <literal>out/extra-manifest</literal> directory of the <literal>ztp-site-generate</literal> container, you can use <literal>extraManifests.searchPaths</literal> to include the path to the git directory containing those files.
This allows the GitOps ZTP pipeline to apply those CR files during cluster installation.
If you configure a <literal>searchPaths</literal> directory, the GitOps ZTP pipeline does not fetch manifests from the <literal>ztp-site-generate</literal> container during site installation.</simpara>
</note>
</listitem>
<listitem>
<simpara>Generate the Day 0 installation CRs by processing the modified <literal>SiteConfig</literal> CR <literal>site-1-sno.yaml</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -it --rm -v `pwd`/out/argocd/example/siteconfig:/resources:Z -v `pwd`/site-install:/output:Z,U registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 generator install site-1-sno.yaml /output</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">site-install
 site-1-sno
     site-1_agentclusterinstall_example-sno.yaml
     site-1-sno_baremetalhost_example-node1.example.com.yaml
     site-1-sno_clusterdeployment_example-sno.yaml
     site-1-sno_configmap_example-sno.yaml
     site-1-sno_infraenv_example-sno.yaml
     site-1-sno_klusterletaddonconfig_example-sno.yaml
     site-1-sno_machineconfig_02-master-workload-partitioning.yaml
     site-1-sno_machineconfig_predefined-extra-manifests-master.yaml
     site-1-sno_machineconfig_predefined-extra-manifests-worker.yaml
     site-1-sno_managedcluster_example-sno.yaml
     site-1-sno_namespace_example-sno.yaml
     site-1-sno_nmstateconfig_example-node1.example.com.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Generate just the Day 0 <literal>MachineConfig</literal> installation CRs for a particular cluster type by processing the reference <literal>SiteConfig</literal> CR with the <literal>-E</literal> option. For example, run the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an output folder for the <literal>MachineConfig</literal> CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./site-machineconfig</programlisting>
</listitem>
<listitem>
<simpara>Generate the <literal>MachineConfig</literal> installation CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -it --rm -v `pwd`/out/argocd/example/siteconfig:/resources:Z -v `pwd`/site-machineconfig:/output:Z,U registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 generator install -E site-1-sno.yaml /output</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">site-machineconfig
 site-1-sno
     site-1-sno_machineconfig_02-master-workload-partitioning.yaml
     site-1-sno_machineconfig_predefined-extra-manifests-master.yaml
     site-1-sno_machineconfig_predefined-extra-manifests-worker.yaml</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Generate and export the Day 2 configuration CRs using the reference <literal>PolicyGenTemplate</literal> CRs from the previous step. Run the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an output folder for the Day 2 CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./ref</programlisting>
</listitem>
<listitem>
<simpara>Generate and export the Day 2 configuration CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -it --rm -v `pwd`/out/argocd/example/policygentemplates:/resources:Z -v `pwd`/ref:/output:Z,U registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 generator config -N . /output</programlisting>
<simpara>The command generates example group and site-specific <literal>PolicyGenTemplate</literal> CRs for single-node OpenShift, three-node clusters, and standard clusters in the <literal>./ref</literal> folder.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ref
  customResource
       common
       example-multinode-site
       example-sno
       group-du-3node
       group-du-3node-validator
           Multiple-validatorCRs
       group-du-sno
       group-du-sno-validator
       group-du-standard
       group-du-standard-validator
            Multiple-validatorCRs</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Use the generated CRs as the basis for the CRs that you use to install the cluster. You apply the installation CRs to the hub cluster as described in "Installing a single managed cluster". The configuration CRs can be applied to the cluster after cluster installation is complete.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the custom roles and labels are applied after the node is deployed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node example-node.example.com</programlisting>
</listitem>
</itemizedlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:   example-node.example.com
Roles:  control-plane,example-label,master,worker
Labels: beta.kubernetes.io/arch=amd64
        beta.kubernetes.io/os=linux
        custom-label/parameter1=true
        kubernetes.io/arch=amd64
        kubernetes.io/hostname=cnfdf03.telco5gran.eng.rdu2.redhat.com
        kubernetes.io/os=linux
        node-role.kubernetes.io/control-plane=
        node-role.kubernetes.io/example-label= <co xml:id="CO60-1"/>
        node-role.kubernetes.io/master=
        node-role.kubernetes.io/worker=
        node.openshift.io/os_id=rhcos</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO60-1">
<para>The custom label is applied to the node.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-sno-du-enabling-workload-partitioning_sno-configure-for-vdu">Workload partitioning</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#bmc-addressing_ipi-install-installation-workflow">BMC addressing</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#root-device-hints_preparing-to-install-with-agent-based-installer">About root device hints</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-sno-siteconfig-config-reference_ztp-deploying-far-edge-sites">Single-node OpenShift SiteConfig CR installation reference</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-creating-the-site-secrets_ztp-manual-install">
<title>Creating the managed bare-metal host secrets</title>
<simpara>Add the required <literal>Secret</literal> custom resources (CRs) for the managed bare-metal host to the hub cluster. You need a secret for the GitOps Zero Touch Provisioning (ZTP) pipeline to access the Baseboard Management Controller (BMC) and a secret for the assisted installer service to pull cluster installation images from the registry.</simpara>
<note>
<simpara>The secrets are referenced from the <literal>SiteConfig</literal> CR by name. The namespace
must match the <literal>SiteConfig</literal> namespace.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML secret file containing credentials for the host Baseboard Management Controller (BMC) and a pull secret required for installing OpenShift and all add-on cluster Operators:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML as the file <literal>example-sno-secret.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: example-sno-bmc-secret
  namespace: example-sno <co xml:id="CO61-1"/>
data: <co xml:id="CO61-2"/>
  password: &lt;base64_password&gt;
  username: &lt;base64_username&gt;
type: Opaque
---
apiVersion: v1
kind: Secret
metadata:
  name: pull-secret
  namespace: example-sno  <co xml:id="CO61-3"/>
data:
  .dockerconfigjson: &lt;pull_secret&gt; <co xml:id="CO61-4"/>
type: kubernetes.io/dockerconfigjson</programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>Must match the namespace configured in the related <literal>SiteConfig</literal> CR</para>
</callout>
<callout arearefs="CO61-2">
<para>Base64-encoded values for <literal>password</literal> and <literal>username</literal></para>
</callout>
<callout arearefs="CO61-3">
<para>Must match the namespace configured in the related <literal>SiteConfig</literal> CR</para>
</callout>
<callout arearefs="CO61-4">
<para>Base64-encoded pull secret</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add the relative path to <literal>example-sno-secret.yaml</literal> to the <literal>kustomization.yaml</literal> file that you use to install the cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="setting-managed-bare-metal-host-kernel-arguments_ztp-manual-install">
<title>Configuring Discovery ISO kernel arguments for manual installations using GitOps ZTP</title>
<simpara>The GitOps Zero Touch Provisioning (ZTP) workflow uses the Discovery ISO as part of the OpenShift Container Platform installation process on managed bare-metal hosts. You can edit the <literal>InfraEnv</literal> resource to specify kernel arguments for the Discovery ISO. This is useful for cluster installations with specific environmental requirements. For example, configure the <literal>rd.net.timeout.carrier</literal> kernel argument for the Discovery ISO to facilitate static networking for the cluster or to receive a DHCP address before downloading the root file system during installation.</simpara>
<note>
<simpara>In OpenShift Container Platform 4.14, you can only add kernel arguments. You can not replace or delete kernel arguments.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (oc).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with cluster-admin privileges.</simpara>
</listitem>
<listitem>
<simpara>You have manually generated the installation and configuration custom resources (CRs).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>spec.kernelArguments</literal> specification in the <literal>InfraEnv</literal> CR to configure kernel arguments:</simpara>
</listitem>
</orderedlist>
<programlisting role="white-space-pre" language="yaml" linenumbering="unnumbered">apiVersion: agent-install.openshift.io/v1beta1
kind: InfraEnv
metadata:
  name: &lt;cluster_name&gt;
  namespace: &lt;cluster_name&gt;
spec:
  kernelArguments:
    - operation: append <co xml:id="CO62-1"/>
      value: audit=0 <co xml:id="CO62-2"/>
    - operation: append
      value: trace=1
  clusterRef:
    name: &lt;cluster_name&gt;
    namespace: &lt;cluster_name&gt;
  pullSecretRef:
    name: pull-secret</programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para>Specify the append operation to add a kernel argument.</para>
</callout>
<callout arearefs="CO62-2">
<para>Specify the kernel argument you want to configure. This example configures the audit kernel argument and the trace kernel argument.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>SiteConfig</literal> CR generates the <literal>InfraEnv</literal> resource as part of the day-0 installation CRs.</simpara>
</note>
<formalpara>
<title>Verification</title>
<para>To verify that the kernel arguments are applied, after the Discovery image verifies that OpenShift Container Platform is ready for installation, you can SSH to the target host before the installation process begins. At that point, you can view the kernel arguments for the Discovery ISO in the <literal>/proc/cmdline</literal> file.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Begin an SSH session with the target host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh -i /path/to/privatekey core@&lt;host_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>View the system&#8217;s kernel arguments by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /proc/cmdline</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-manually-install-a-single-managed-cluster_ztp-manual-install">
<title>Installing a single managed cluster</title>
<simpara>You can manually deploy a single managed cluster using the assisted service and Red Hat Advanced Cluster Management (RHACM).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created the baseboard management controller (BMC) <literal>Secret</literal> and the image pull-secret <literal>Secret</literal> custom resources (CRs). See "Creating the managed bare-metal host secrets" for details.</simpara>
</listitem>
<listitem>
<simpara>Your target bare-metal host meets the networking and hardware requirements for managed clusters.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ClusterImageSet</literal> for each specific cluster version to be deployed, for example <literal>clusterImageSet-4.14.yaml</literal>. A <literal>ClusterImageSet</literal> has the following format:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: hive.openshift.io/v1
kind: ClusterImageSet
metadata:
  name: openshift-4.14.0 <co xml:id="CO63-1"/>
spec:
   releaseImage: quay.io/openshift-release-dev/ocp-release:4.14.0-x86_64 <co xml:id="CO63-2"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>The descriptive version that you want to deploy.</para>
</callout>
<callout arearefs="CO63-2">
<para>Specifies the <literal>releaseImage</literal> to deploy and determines the operating system image version. The discovery ISO is based on the image version as set by <literal>releaseImage</literal>, or the latest version if the exact version is unavailable.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the <literal>clusterImageSet</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f clusterImageSet-4.14.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> CR in the <literal>cluster-namespace.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
     name: &lt;cluster_name&gt; <co xml:id="CO64-1"/>
     labels:
        name: &lt;cluster_name&gt; <co xml:id="CO64-2"/></programlisting>
<calloutlist>
<callout arearefs="CO64-1 CO64-2">
<para>The name of the managed cluster to provision.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the <literal>Namespace</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cluster-namespace.yaml</programlisting>
</listitem>
<listitem>
<simpara>Apply the generated day-0 CRs that you extracted from the <literal>ztp-site-generate</literal> container and customized to meet your requirements:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -R ./site-install/site-sno-1</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-managed-cluster-network-prereqs_sno-configure-for-vdu">Connectivity prerequisites for managed cluster networks</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/storage/#lvms-preface-sno-ran_logical-volume-manager-storage">Deploying LVM Storage on single-node OpenShift clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-provisioning-lvm-storage_ztp-advanced-policy-config">Configuring LVM Storage using PolicyGenTemplate CRs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-checking-the-managed-cluster-status_ztp-manual-install">
<title>Monitoring the managed cluster installation status</title>
<simpara>Ensure that cluster provisioning was successful by checking the cluster status.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All of the custom resources have been configured and provisioned, and the <literal>Agent</literal>
custom resource is created on the hub for the managed cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the status of the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster</programlisting>
<simpara><literal>True</literal> indicates the managed cluster is ready.</simpara>
</listitem>
<listitem>
<simpara>Check the agent status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get agent -n &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>describe</literal> command to provide an in-depth description of the agents condition. Statuses to be aware of include <literal>BackendError</literal>, <literal>InputError</literal>, <literal>ValidationsFailing</literal>, <literal>InstallationFailed</literal>, and <literal>AgentIsConnected</literal>. These statuses are relevant to the <literal>Agent</literal> and <literal>AgentClusterInstall</literal> custom resources.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe agent -n &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check the cluster provisioning status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get agentclusterinstall -n &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>describe</literal> command to provide an in-depth description of the cluster provisioning status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe agentclusterinstall -n &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check the status of the managed clusters add-on services:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedclusteraddon -n &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Retrieve the authentication information of the <literal>kubeconfig</literal> file for the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret -n &lt;cluster_name&gt; &lt;cluster_name&gt;-admin-kubeconfig -o jsonpath={.data.kubeconfig} | base64 -d &gt; &lt;directory&gt;/&lt;cluster_name&gt;-kubeconfig</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-troubleshooting-the-managed-cluster_ztp-manual-install">
<title>Troubleshooting the managed cluster</title>
<simpara>Use this procedure to diagnose any installation issues that might occur with the managed cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the status of the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HUB ACCEPTED   MANAGED CLUSTER URLS   JOINED   AVAILABLE   AGE
SNO-cluster     true                                   True     True      2d19h</programlisting>
</para>
</formalpara>
<simpara>If the status in the <literal>AVAILABLE</literal> column is <literal>True</literal>, the managed cluster is being managed by the hub.</simpara>
<simpara>If the status in the <literal>AVAILABLE</literal> column is <literal>Unknown</literal>, the managed cluster is not being managed by the hub.
Use the following steps to continue checking to get more information.</simpara>
</listitem>
<listitem>
<simpara>Check the <literal>AgentClusterInstall</literal> install status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterdeployment -n &lt;cluster_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        PLATFORM            REGION   CLUSTERTYPE   INSTALLED    INFRAID    VERSION  POWERSTATE AGE
Sno0026    agent-baremetal                               false                          Initialized
2d14h</programlisting>
</para>
</formalpara>
<simpara>If the status in the <literal>INSTALLED</literal> column is <literal>false</literal>, the installation was unsuccessful.</simpara>
</listitem>
<listitem>
<simpara>If the installation failed, enter the following command to review the status of the <literal>AgentClusterInstall</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe agentclusterinstall -n &lt;cluster_name&gt; &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Resolve the errors and reset the cluster:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Remove the clusters managed cluster resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete managedcluster &lt;cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Remove the clusters namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete namespace &lt;cluster_name&gt;</programlisting>
<simpara>This deletes all of the namespace-scoped custom resources created for this cluster. You must wait for the <literal>ManagedCluster</literal> CR deletion to complete before proceeding.</simpara>
</listitem>
<listitem>
<simpara>Recreate the custom resources for the managed cluster.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-installation-crs_ztp-manual-install">
<title>RHACM generated cluster installation CRs reference</title>
<simpara>Red Hat Advanced Cluster Management (RHACM) supports deploying OpenShift Container Platform on single-node clusters, three-node clusters, and standard clusters with a specific set of installation custom resources (CRs) that you generate using <literal>SiteConfig</literal> CRs for each site.</simpara>
<note>
<simpara>Every managed cluster has its own namespace, and all of the installation CRs except for <literal>ManagedCluster</literal> and <literal>ClusterImageSet</literal> are under that namespace. <literal>ManagedCluster</literal> and <literal>ClusterImageSet</literal> are cluster-scoped, not namespace-scoped. The namespace and the CR names match the cluster name.</simpara>
</note>
<simpara>The following table lists the installation CRs that are automatically applied by the RHACM assisted service when it installs clusters using the <literal>SiteConfig</literal> CRs that you configure.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Cluster installation CRs generated by RHACM</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="14.2857*"/>
<colspec colname="col_2" colwidth="42.8571*"/>
<colspec colname="col_3" colwidth="42.8572*"/>
<thead>
<row>
<entry align="left" valign="top">CR</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>BareMetalHost</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the connection information for the Baseboard Management Controller (BMC) of the target bare-metal host.</simpara></entry>
<entry align="left" valign="top"><simpara>Provides access to the BMC to load and start the discovery image on the target server by using the Redfish protocol.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InfraEnv</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains information for installing OpenShift Container Platform on the target bare-metal host.</simpara></entry>
<entry align="left" valign="top"><simpara>Used with <literal>ClusterDeployment</literal> to generate the discovery ISO for the managed cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AgentClusterInstall</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies details of the managed cluster configuration such as networking and the number of control plane nodes. Displays the cluster <literal>kubeconfig</literal> and credentials when the installation is complete.</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the managed cluster configuration information and provides status during the installation of the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterDeployment</literal></simpara></entry>
<entry align="left" valign="top"><simpara>References the <literal>AgentClusterInstall</literal> CR to use.</simpara></entry>
<entry align="left" valign="top"><simpara>Used with <literal>InfraEnv</literal> to generate the discovery ISO for the managed cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NMStateConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides network configuration information such as <literal>MAC</literal> address to <literal>IP</literal> mapping, DNS server, default route, and other network settings.</simpara></entry>
<entry align="left" valign="top"><simpara>Sets up a static IP address for the managed clusters Kube API server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Agent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains hardware information about the target bare-metal host.</simpara></entry>
<entry align="left" valign="top"><simpara>Created automatically on the hub when the target machine&#8217;s discovery image boots.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ManagedCluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When a cluster is managed by the hub, it must be imported and known. This Kubernetes object provides that interface.</simpara></entry>
<entry align="left" valign="top"><simpara>The hub uses this resource to manage and show the status of managed clusters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KlusterletAddonConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the list of services provided by the hub to be deployed to the <literal>ManagedCluster</literal> resource.</simpara></entry>
<entry align="left" valign="top"><simpara>Tells the hub which addon services to deploy to the <literal>ManagedCluster</literal> resource.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logical space for <literal>ManagedCluster</literal> resources existing on the hub. Unique per site.</simpara></entry>
<entry align="left" valign="top"><simpara>Propagates resources to the <literal>ManagedCluster</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Secret</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Two CRs are created: <literal>BMC Secret</literal> and <literal>Image Pull Secret</literal>.</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>BMC Secret</literal> authenticates into the target bare-metal host using its username and password.</simpara>
</listitem>
<listitem>
<simpara><literal>Image Pull Secret</literal> contains authentication information for the OpenShift Container Platform image installed on the target bare-metal host.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterImageSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains OpenShift Container Platform image information such as the repository and image name.</simpara></entry>
<entry align="left" valign="top"><simpara>Passed into resources to provide OpenShift Container Platform images.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="sno-configure-for-vdu">
<title>Recommended single-node OpenShift cluster configuration for vDU application workloads</title>
<simpara>Use the following reference information to understand the single-node OpenShift configurations required to deploy virtual distributed unit (vDU) applications in the cluster. Configurations include cluster optimizations for high performance workloads, enabling workload partitioning, and minimizing the number of reboots required postinstallation.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>To deploy a single cluster by hand, see <link linkend="ztp-manual-install">Manually installing a single-node OpenShift cluster with GitOps ZTP</link>.</simpara>
</listitem>
<listitem>
<simpara>To deploy a fleet of clusters using GitOps Zero Touch Provisioning (ZTP), see <link linkend="ztp-deploying-far-edge-sites">Deploying far edge sites with GitOps ZTP</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-low-latency_sno-configure-for-vdu">
<title>Running low latency applications on OpenShift Container Platform</title>
<simpara>OpenShift Container Platform enables low latency processing for applications running on commercial off-the-shelf (COTS) hardware by using several technologies and specialized hardware devices:</simpara>
<variablelist>
<varlistentry>
<term>Real-time kernel for RHCOS</term>
<listitem>
<simpara>Ensures workloads are handled with a high degree of process determinism.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CPU isolation</term>
<listitem>
<simpara>Avoids CPU scheduling delays and ensures CPU capacity is available consistently.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NUMA-aware topology management</term>
<listitem>
<simpara>Aligns memory and huge pages with CPU and PCI devices to pin guaranteed container memory and huge pages to the non-uniform memory access (NUMA) node. Pod resources for all Quality of Service (QoS) classes stay on the same NUMA node. This decreases latency and improves performance of the node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Huge pages memory management</term>
<listitem>
<simpara>Using huge page sizes improves system performance by reducing the amount of system resources required to access page tables.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Precision timing synchronization using PTP</term>
<listitem>
<simpara>Allows synchronization between nodes in the network with sub-microsecond accuracy.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="ztp-install-sno-hardware-reqs_sno-configure-for-vdu">
<title>Recommended cluster host requirements for vDU application workloads</title>
<simpara>Running vDU application workloads requires a bare-metal host with sufficient resources to run OpenShift Container Platform services and production workloads.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Minimum resource requirements</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">vCPU</entry>
<entry align="left" valign="top">Memory</entry>
<entry align="left" valign="top">Storage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Minimum</simpara></entry>
<entry align="left" valign="top"><simpara>4 to 8 vCPU cores</simpara></entry>
<entry align="left" valign="top"><simpara>32GB of RAM</simpara></entry>
<entry align="left" valign="top"><simpara>120GB</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>One vCPU is equivalent to one physical core when simultaneous multithreading (SMT), or Hyper-Threading, is not enabled. When enabled, use the following formula to calculate the corresponding ratio:</simpara>
<itemizedlist>
<listitem>
<simpara>(threads per core  cores)  sockets = vCPUs</simpara>
</listitem>
</itemizedlist>
</note>
<important>
<simpara>The server must have a Baseboard Management Controller (BMC) when booting with virtual media.</simpara>
</important>
</section>
<section xml:id="ztp-du-configuring-host-firmware-requirements_sno-configure-for-vdu">
<title>Configuring host firmware for low latency and high performance</title>
<simpara>Bare-metal hosts require the firmware to be configured before the host can be provisioned. The firmware configuration is dependent on the specific hardware and the particular requirements of your installation.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the <emphasis role="strong">UEFI/BIOS Boot Mode</emphasis> to <literal>UEFI</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the host boot sequence order, set <emphasis role="strong">Hard drive first</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Apply the specific firmware configuration for your hardware. The following table describes a representative firmware configuration for an Intel Xeon Skylake or Intel Cascade Lake server, based on the Intel FlexRAN 4G and 5G baseband PHY reference design.</simpara>
<important>
<simpara>The exact firmware configuration depends on your specific hardware and network requirements. The following sample configuration is for illustrative purposes only.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Sample firmware configuration for an Intel Xeon Skylake or Cascade Lake server</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">Firmware setting</entry>
<entry align="left" valign="top">Configuration</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CPU Power and Performance Policy</simpara></entry>
<entry align="left" valign="top"><simpara>Performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Uncore Frequency Scaling</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Performance P-limit</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enhanced Intel SpeedStep &#174; Tech</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Intel Configurable TDP</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Configurable TDP Level</simpara></entry>
<entry align="left" valign="top"><simpara>Level 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Intel&#174; Turbo Boost Technology</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Energy Efficient Turbo</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hardware P-States</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Package C-State</simpara></entry>
<entry align="left" valign="top"><simpara>C0/C1 state</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C1E</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Processor C6</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</listitem>
</orderedlist>
<note>
<simpara>Enable global SR-IOV and VT-d settings in the firmware for the host. These settings are relevant to bare-metal environments.</simpara>
</note>
</section>
<section xml:id="ztp-managed-cluster-network-prereqs_sno-configure-for-vdu">
<title>Connectivity prerequisites for managed cluster networks</title>
<simpara>Before you can install and provision a managed cluster with the GitOps Zero Touch Provisioning (ZTP) pipeline, the managed cluster host must meet the following networking prerequisites:</simpara>
<itemizedlist>
<listitem>
<simpara>There must be bi-directional connectivity between the GitOps ZTP container in the hub cluster and the Baseboard Management Controller (BMC) of the target bare-metal host.</simpara>
</listitem>
<listitem>
<simpara>The managed cluster must be able to resolve and reach the API hostname of the hub hostname and <literal>*.apps</literal> hostname. Here is an example of the API hostname of the hub and <literal>*.apps</literal> hostname:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>api.hub-cluster.internal.domain.com</literal></simpara>
</listitem>
<listitem>
<simpara><literal>console-openshift-console.apps.hub-cluster.internal.domain.com</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The hub cluster must be able to resolve and reach the API and <literal>*.apps</literal> hostname of the managed cluster. Here is an example of the API hostname of the managed cluster and <literal>*.apps</literal> hostname:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>api.sno-managed-cluster-1.internal.domain.com</literal></simpara>
</listitem>
<listitem>
<simpara><literal>console-openshift-console.apps.sno-managed-cluster-1.internal.domain.com</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-workload-partitioning-sno_sno-configure-for-vdu">
<title>Workload partitioning in single-node OpenShift with GitOps ZTP</title>
<simpara>Workload partitioning configures OpenShift Container Platform services, cluster management workloads, and infrastructure pods to run on a reserved number of host CPUs.</simpara>
<simpara>To configure workload partitioning with GitOps Zero Touch Provisioning (ZTP), you configure a <literal>cpuPartitioningMode</literal> field in the <literal>SiteConfig</literal> custom resource (CR) that you use to install the cluster and you apply a <literal>PerformanceProfile</literal> CR that configures the <literal>isolated</literal> and <literal>reserved</literal> CPUs on the host.</simpara>
<simpara>Configuring the <literal>SiteConfig</literal> CR enables workload partitioning at cluster installation time and applying the <literal>PerformanceProfile</literal> CR configures the specific allocation of CPUs to reserved and isolated sets.
Both of these steps happen at different points during cluster provisioning.</simpara>
<note>
<simpara>Configuring workload partitioning by using the <literal>cpuPartitioningMode</literal> field in the <literal>SiteConfig</literal> CR is a Tech Preview feature in OpenShift Container Platform 4.13.</simpara>
<simpara>Alternatively, you can specify cluster management CPU resources with the <literal>cpuset</literal> field of the <literal>SiteConfig</literal> custom resource (CR) and the <literal>reserved</literal> field of the group <literal>PolicyGenTemplate</literal> CR.
The GitOps ZTP pipeline uses these values to populate the required fields in the workload partitioning <literal>MachineConfig</literal> CR (<literal>cpuset</literal>) and the <literal>PerformanceProfile</literal> CR (<literal>reserved</literal>) that configure the single-node OpenShift cluster.
This method is a General Availability feature in OpenShift Container Platform 4.14.</simpara>
</note>
<simpara>The workload partitioning configuration pins the OpenShift Container Platform infrastructure pods to the <literal>reserved</literal> CPU set.
Platform services such as systemd, CRI-O, and kubelet run on the <literal>reserved</literal> CPU set.
The <literal>isolated</literal> CPU sets are exclusively allocated to your container workloads.
Isolating CPUs ensures that the workload has guaranteed access to the specified CPUs without contention from other applications running on the same node.
All CPUs that are not isolated should be reserved.</simpara>
<important>
<simpara>Ensure that <literal>reserved</literal> and <literal>isolated</literal> CPU sets do not overlap with each other.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For the recommended single-node OpenShift workload partitioning configuration, see <link linkend="ztp-sno-du-enabling-workload-partitioning_sno-configure-for-vdu">Workload partitioning</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-sno-install-time-cluster-config">
<title>Recommended cluster install manifests</title>
<simpara>The ZTP pipeline applies the following custom resources (CRs) during cluster installation. These configuration CRs ensure that the cluster meets the feature and performance requirements necessary for running a vDU application.</simpara>
<note>
<simpara>When using the GitOps ZTP plugin and <literal>SiteConfig</literal> CRs for cluster deployment, the following <literal>MachineConfig</literal> CRs are included by default.</simpara>
</note>
<simpara>Use the <literal>SiteConfig</literal> <literal>extraManifests</literal> filter to alter the CRs that are included by default. For more information, see <link linkend="ztp-advanced-install-ztp">Advanced managed cluster configuration with SiteConfig CRs</link>.</simpara>
<section xml:id="ztp-sno-du-enabling-workload-partitioning_sno-configure-for-vdu">
<title>Workload partitioning</title>
<simpara>Single-node OpenShift clusters that run DU workloads require workload partitioning. This limits the cores allowed to run platform services, maximizing the CPU core for application payloads.</simpara>
<note>
<simpara>Workload partitioning can be enabled during cluster installation only.
You cannot disable workload partitioning postinstallation.
You can however change the set of CPUs assigned to the isolated and reserved sets through the <literal>PerformanceProfile</literal> CR.
Changes to CPU settings cause the node to reboot.</simpara>
</note>
<note>
<title>Upgrading from OpenShift Container Platform 4.12 to 4.13+</title>
<simpara>When transitioning to using <literal>cpuPartitioningMode</literal> for enabling workload partitioning, remove the workload partitioning <literal>MachineConfig</literal> CRs from the <literal>/extra-manifest</literal> folder that you use to provision the cluster.</simpara>
</note>
<formalpara>
<title>Recommended <literal>SiteConfig</literal> CR configuration for workload partitioning</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: SiteConfig
metadata:
  name: "&lt;site_name&gt;"
  namespace: "&lt;site_name&gt;"
spec:
  baseDomain: "example.com"
  cpuPartitioningMode: AllNodes <co xml:id="CO65-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO65-1">
<para>Set the <literal>cpuPartitioningMode</literal> field to <literal>AllNodes</literal> to configure workload partitioning for all nodes in the cluster.</para>
</callout>
</calloutlist>
<formalpara>
<title>Verification</title>
<para>Check that the applications and cluster system CPU pinning is correct. Run the following commands:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a remote shell prompt to the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/example-sno-1</programlisting>
</listitem>
<listitem>
<simpara>Check that the OpenShift infrastructure applications CPU pinning is correct:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# pgrep ovn | while read i; do taskset -cp $i; done</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">pid 8481's current affinity list: 0-1,52-53
pid 8726's current affinity list: 0-1,52-53
pid 9088's current affinity list: 0-1,52-53
pid 9945's current affinity list: 0-1,52-53
pid 10387's current affinity list: 0-1,52-53
pid 12123's current affinity list: 0-1,52-53
pid 13313's current affinity list: 0-1,52-53</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the system applications CPU pinning is correct:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# pgrep systemd | while read i; do taskset -cp $i; done</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">pid 1's current affinity list: 0-1,52-53
pid 938's current affinity list: 0-1,52-53
pid 962's current affinity list: 0-1,52-53
pid 1197's current affinity list: 0-1,52-53</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-sno-du-configuring-the-container-mountspace_sno-configure-for-vdu">
<title>Reduced platform management footprint</title>
<simpara>To reduce the overall management footprint of the platform, a <literal>MachineConfig</literal> custom resource (CR) is required that places all Kubernetes-specific mount points in a new namespace separate from the host operating system.
The following base64-encoded example <literal>MachineConfig</literal> CR illustrates this configuration.</simpara>
<formalpara>
<title>Recommended container mount namespace configuration (<literal>01-container-mount-ns-and-kubelet-conf-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: container-mount-namespace-and-kubelet-conf-master
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKCmRlYnVnKCkgewogIGVjaG8gJEAgPiYyCn0KCnVzYWdlKCkgewogIGVjaG8gVXNhZ2U6ICQoYmFzZW5hbWUgJDApIFVOSVQgW2VudmZpbGUgW3Zhcm5hbWVdXQogIGVjaG8KICBlY2hvIEV4dHJhY3QgdGhlIGNvbnRlbnRzIG9mIHRoZSBmaXJzdCBFeGVjU3RhcnQgc3RhbnphIGZyb20gdGhlIGdpdmVuIHN5c3RlbWQgdW5pdCBhbmQgcmV0dXJuIGl0IHRvIHN0ZG91dAogIGVjaG8KICBlY2hvICJJZiAnZW52ZmlsZScgaXMgcHJvdmlkZWQsIHB1dCBpdCBpbiB0aGVyZSBpbnN0ZWFkLCBhcyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lZCAndmFybmFtZSciCiAgZWNobyAiRGVmYXVsdCAndmFybmFtZScgaXMgRVhFQ1NUQVJUIGlmIG5vdCBzcGVjaWZpZWQiCiAgZXhpdCAxCn0KClVOSVQ9JDEKRU5WRklMRT0kMgpWQVJOQU1FPSQzCmlmIFtbIC16ICRVTklUIHx8ICRVTklUID09ICItLWhlbHAiIHx8ICRVTklUID09ICItaCIgXV07IHRoZW4KICB1c2FnZQpmaQpkZWJ1ZyAiRXh0cmFjdGluZyBFeGVjU3RhcnQgZnJvbSAkVU5JVCIKRklMRT0kKHN5c3RlbWN0bCBjYXQgJFVOSVQgfCBoZWFkIC1uIDEpCkZJTEU9JHtGSUxFI1wjIH0KaWYgW1sgISAtZiAkRklMRSBdXTsgdGhlbgogIGRlYnVnICJGYWlsZWQgdG8gZmluZCByb290IGZpbGUgZm9yIHVuaXQgJFVOSVQgKCRGSUxFKSIKICBleGl0CmZpCmRlYnVnICJTZXJ2aWNlIGRlZmluaXRpb24gaXMgaW4gJEZJTEUiCkVYRUNTVEFSVD0kKHNlZCAtbiAtZSAnL15FeGVjU3RhcnQ9LipcXCQvLC9bXlxcXSQvIHsgcy9eRXhlY1N0YXJ0PS8vOyBwIH0nIC1lICcvXkV4ZWNTdGFydD0uKlteXFxdJC8geyBzL15FeGVjU3RhcnQ9Ly87IHAgfScgJEZJTEUpCgppZiBbWyAkRU5WRklMRSBdXTsgdGhlbgogIFZBUk5BTUU9JHtWQVJOQU1FOi1FWEVDU1RBUlR9CiAgZWNobyAiJHtWQVJOQU1FfT0ke0VYRUNTVEFSVH0iID4gJEVOVkZJTEUKZWxzZQogIGVjaG8gJEVYRUNTVEFSVApmaQo=
          mode: 493
          path: /usr/local/bin/extractExecStart
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKbnNlbnRlciAtLW1vdW50PS9ydW4vY29udGFpbmVyLW1vdW50LW5hbWVzcGFjZS9tbnQgIiRAIgo=
          mode: 493
          path: /usr/local/bin/nsenterCmns
    systemd:
      units:
        - contents: |
            [Unit]
            Description=Manages a mount namespace that both kubelet and crio can use to share their container-specific mounts

            [Service]
            Type=oneshot
            RemainAfterExit=yes
            RuntimeDirectory=container-mount-namespace
            Environment=RUNTIME_DIRECTORY=%t/container-mount-namespace
            Environment=BIND_POINT=%t/container-mount-namespace/mnt
            ExecStartPre=bash -c "findmnt ${RUNTIME_DIRECTORY} || mount --make-unbindable --bind ${RUNTIME_DIRECTORY} ${RUNTIME_DIRECTORY}"
            ExecStartPre=touch ${BIND_POINT}
            ExecStart=unshare --mount=${BIND_POINT} --propagation slave mount --make-rshared /
            ExecStop=umount -R ${RUNTIME_DIRECTORY}
          name: container-mount-namespace.service
        - dropins:
            - contents: |
                [Unit]
                Wants=container-mount-namespace.service
                After=container-mount-namespace.service

                [Service]
                ExecStartPre=/usr/local/bin/extractExecStart %n /%t/%N-execstart.env ORIG_EXECSTART
                EnvironmentFile=-/%t/%N-execstart.env
                ExecStart=
                ExecStart=bash -c "nsenter --mount=%t/container-mount-namespace/mnt \
                    ${ORIG_EXECSTART}"
              name: 90-container-mount-namespace.conf
          name: crio.service
        - dropins:
            - contents: |
                [Unit]
                Wants=container-mount-namespace.service
                After=container-mount-namespace.service

                [Service]
                ExecStartPre=/usr/local/bin/extractExecStart %n /%t/%N-execstart.env ORIG_EXECSTART
                EnvironmentFile=-/%t/%N-execstart.env
                ExecStart=
                ExecStart=bash -c "nsenter --mount=%t/container-mount-namespace/mnt \
                    ${ORIG_EXECSTART} --housekeeping-interval=30s"
              name: 90-container-mount-namespace.conf
            - contents: |
                [Service]
                Environment="OPENSHIFT_MAX_HOUSEKEEPING_INTERVAL_DURATION=60s"
                Environment="OPENSHIFT_EVICTION_MONITORING_PERIOD_DURATION=30s"
              name: 30-kubelet-interval-tuning.conf
          name: kubelet.service</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-enabling-sctp_sno-configure-for-vdu">
<title>SCTP</title>
<simpara>Stream Control Transmission Protocol (SCTP) is a key protocol used in RAN applications. This <literal>MachineConfig</literal> object adds the SCTP kernel module to the node to enable this protocol.</simpara>
<formalpara>
<title>Recommended control plane node SCTP configuration (<literal>03-sctp-machine-config-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: load-sctp-module-master
spec:
  config:
    ignition:
      version: 2.2.0
    storage:
      files:
        - contents:
            source: data:,
            verification: {}
          filesystem: root
          mode: 420
          path: /etc/modprobe.d/sctp-blacklist.conf
        - contents:
            source: data:text/plain;charset=utf-8,sctp
          filesystem: root
          mode: 420
          path: /etc/modules-load.d/sctp-load.conf</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended worker node SCTP configuration (<literal>03-sctp-machine-config-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: load-sctp-module-worker
spec:
  config:
    ignition:
      version: 2.2.0
    storage:
      files:
        - contents:
            source: data:,
            verification: {}
          filesystem: root
          mode: 420
          path: /etc/modprobe.d/sctp-blacklist.conf
        - contents:
            source: data:text/plain;charset=utf-8,sctp
          filesystem: root
          mode: 420
          path: /etc/modules-load.d/sctp-load.conf</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-accelerating-container-startup_sno-configure-for-vdu">
<title>Accelerated container startup</title>
<simpara>The following <literal>MachineConfig</literal> CR configures core OpenShift processes and containers to use all available CPU cores during system startup and shutdown. This accelerates the system recovery during initial boot and reboots.</simpara>
<formalpara>
<title>Recommended accelerated container startup configuration (<literal>04-accelerated-container-startup-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 04-accelerated-container-startup-master
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKIwojIFRlbXBvcmFyaWx5IHJlc2V0IHRoZSBjb3JlIHN5c3RlbSBwcm9jZXNzZXMncyBDUFUgYWZmaW5pdHkgdG8gYmUgdW5yZXN0cmljdGVkIHRvIGFjY2VsZXJhdGUgc3RhcnR1cCBhbmQgc2h1dGRvd24KIwojIFRoZSBkZWZhdWx0cyBiZWxvdyBjYW4gYmUgb3ZlcnJpZGRlbiB2aWEgZW52aXJvbm1lbnQgdmFyaWFibGVzCiMKCiMgVGhlIGRlZmF1bHQgc2V0IG9mIGNyaXRpY2FsIHByb2Nlc3NlcyB3aG9zZSBhZmZpbml0eSBzaG91bGQgYmUgdGVtcG9yYXJpbHkgdW5ib3VuZDoKQ1JJVElDQUxfUFJPQ0VTU0VTPSR7Q1JJVElDQUxfUFJPQ0VTU0VTOi0iY3JpbyBrdWJlbGV0IE5ldHdvcmtNYW5hZ2VyIGNvbm1vbiBkYnVzIn0KCiMgRGVmYXVsdCB3YWl0IHRpbWUgaXMgNjAwcyA9IDEwbToKTUFYSU1VTV9XQUlUX1RJTUU9JHtNQVhJTVVNX1dBSVRfVElNRTotNjAwfQoKIyBEZWZhdWx0IHN0ZWFkeS1zdGF0ZSB0aHJlc2hvbGQgPSAyJQojIEFsbG93ZWQgdmFsdWVzOgojICA0ICAtIGFic29sdXRlIHBvZCBjb3VudCAoKy8tKQojICA0JSAtIHBlcmNlbnQgY2hhbmdlICgrLy0pCiMgIC0xIC0gZGlzYWJsZSB0aGUgc3RlYWR5LXN0YXRlIGNoZWNrClNURUFEWV9TVEFURV9USFJFU0hPTEQ9JHtTVEVBRFlfU1RBVEVfVEhSRVNIT0xEOi0yJX0KCiMgRGVmYXVsdCBzdGVhZHktc3RhdGUgd2luZG93ID0gNjBzCiMgSWYgdGhlIHJ1bm5pbmcgcG9kIGNvdW50IHN0YXlzIHdpdGhpbiB0aGUgZ2l2ZW4gdGhyZXNob2xkIGZvciB0aGlzIHRpbWUKIyBwZXJpb2QsIHJldHVybiBDUFUgdXRpbGl6YXRpb24gdG8gbm9ybWFsIGJlZm9yZSB0aGUgbWF4aW11bSB3YWl0IHRpbWUgaGFzCiMgZXhwaXJlcwpTVEVBRFlfU1RBVEVfV0lORE9XPSR7U1RFQURZX1NUQVRFX1dJTkRPVzotNjB9CgojIERlZmF1bHQgc3RlYWR5LXN0YXRlIGFsbG93cyBhbnkgcG9kIGNvdW50IHRvIGJlICJzdGVhZHkgc3RhdGUiCiMgSW5jcmVhc2luZyB0aGlzIHdpbGwgc2tpcCBhbnkgc3RlYWR5LXN0YXRlIGNoZWNrcyB1bnRpbCB0aGUgY291bnQgcmlzZXMgYWJvdmUKIyB0aGlzIG51bWJlciB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMgaWYgdGhlcmUgYXJlIHNvbWUgcGVyaW9kcyB3aGVyZSB0aGUKIyBjb3VudCBkb2Vzbid0IGluY3JlYXNlIGJ1dCB3ZSBrbm93IHdlIGNhbid0IGJlIGF0IHN0ZWFkeS1zdGF0ZSB5ZXQuClNURUFEWV9TVEFURV9NSU5JTVVNPSR7U1RFQURZX1NUQVRFX01JTklNVU06LTB9CgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpLVUJFTEVUX0NQVV9TVEFURT0vdmFyL2xpYi9rdWJlbGV0L2NwdV9tYW5hZ2VyX3N0YXRlCkZVTExfQ1BVX1NUQVRFPS9zeXMvZnMvY2dyb3VwL2NwdXNldC9jcHVzZXQuY3B1cwpLVUJFTEVUX0NPTkY9L2V0Yy9rdWJlcm5ldGVzL2t1YmVsZXQuY29uZgp1bnJlc3RyaWN0ZWRDcHVzZXQoKSB7CiAgbG9jYWwgY3B1cwogIGlmIFtbIC1lICRLVUJFTEVUX0NQVV9TVEFURSBdXTsgdGhlbgogICAgY3B1cz0kKGpxIC1yICcuZGVmYXVsdENwdVNldCcgPCRLVUJFTEVUX0NQVV9TVEFURSkKICAgIGlmIFtbIC1uICIke2NwdXN9IiAmJiAtZSAke0tVQkVMRVRfQ09ORn0gXV07IHRoZW4KICAgICAgcmVzZXJ2ZWRfY3B1cz0kKGpxIC1yICcucmVzZXJ2ZWRTeXN0ZW1DUFVzJyA8L2V0Yy9rdWJlcm5ldGVzL2t1YmVsZXQuY29uZikKICAgICAgaWYgW1sgLW4gIiR7cmVzZXJ2ZWRfY3B1c30iIF1dOyB0aGVuCiAgICAgICAgIyBVc2UgdGFza3NldCB0byBtZXJnZSB0aGUgdHdvIGNwdXNldHMKICAgICAgICBjcHVzPSQodGFza3NldCAtYyAiJHtyZXNlcnZlZF9jcHVzfSwke2NwdXN9IiBncmVwIC1pIENwdXNfYWxsb3dlZF9saXN0IC9wcm9jL3NlbGYvc3RhdHVzIHwgYXdrICd7cHJpbnQgJDJ9JykKICAgICAgZmkKICAgIGZpCiAgZmkKICBpZiBbWyAteiAkY3B1cyBdXTsgdGhlbgogICAgIyBmYWxsIGJhY2sgdG8gdXNpbmcgYWxsIGNwdXMgaWYgdGhlIGt1YmVsZXQgc3RhdGUgaXMgbm90IGNvbmZpZ3VyZWQgeWV0CiAgICBbWyAtZSAkRlVMTF9DUFVfU1RBVEUgXV0gfHwgcmV0dXJuIDEKICAgIGNwdXM9JCg8JEZVTExfQ1BVX1NUQVRFKQogIGZpCiAgZWNobyAkY3B1cwp9CgpyZXN0cmljdGVkQ3B1c2V0KCkgewogIGZvciBhcmcgaW4gJCg8L3Byb2MvY21kbGluZSk7IGRvCiAgICBpZiBbWyAkYXJnID1+IF5zeXN0ZW1kLmNwdV9hZmZpbml0eT0gXV07IHRoZW4KICAgICAgZWNobyAke2FyZyMqPX0KICAgICAgcmV0dXJuIDAKICAgIGZpCiAgZG9uZQogIHJldHVybiAxCn0KCnJlc2V0QWZmaW5pdHkoKSB7CiAgbG9jYWwgY3B1c2V0PSIkMSIKICBsb2NhbCBmYWlsY291bnQ9MAogIGxvY2FsIHN1Y2Nlc3Njb3VudD0wCiAgbG9nZ2VyICJSZWNvdmVyeTogU2V0dGluZyBDUFUgYWZmaW5pdHkgZm9yIGNyaXRpY2FsIHByb2Nlc3NlcyBcIiRDUklUSUNBTF9QUk9DRVNTRVNcIiB0byAkY3B1c2V0IgogIGZvciBwcm9jIGluICRDUklUSUNBTF9QUk9DRVNTRVM7IGRvCiAgICBsb2NhbCBwaWRzPSIkKHBncmVwICRwcm9jKSIKICAgIGZvciBwaWQgaW4gJHBpZHM7IGRvCiAgICAgIGxvY2FsIHRhc2tzZXRPdXRwdXQKICAgICAgdGFza3NldE91dHB1dD0iJCh0YXNrc2V0IC1hcGMgIiRjcHVzZXQiICRwaWQgMj4mMSkiCiAgICAgIGlmIFtbICQ/IC1uZSAwIF1dOyB0aGVuCiAgICAgICAgZWNobyAiRVJST1I6ICR0YXNrc2V0T3V0cHV0IgogICAgICAgICgoZmFpbGNvdW50KyspKQogICAgICBlbHNlCiAgICAgICAgKChzdWNjZXNzY291bnQrKykpCiAgICAgIGZpCiAgICBkb25lCiAgZG9uZQoKICBsb2dnZXIgIlJlY292ZXJ5OiBSZS1hZmZpbmVkICRzdWNjZXNzY291bnQgcGlkcyBzdWNjZXNzZnVsbHkiCiAgaWYgW1sgJGZhaWxjb3VudCAtZ3QgMCBdXTsgdGhlbgogICAgbG9nZ2VyICJSZWNvdmVyeTogRmFpbGVkIHRvIHJlLWFmZmluZSAkZmFpbGNvdW50IHByb2Nlc3NlcyIKICAgIHJldHVybiAxCiAgZmkKfQoKc2V0VW5yZXN0cmljdGVkKCkgewogIGxvZ2dlciAiUmVjb3Zlcnk6IFNldHRpbmcgY3JpdGljYWwgc3lzdGVtIHByb2Nlc3NlcyB0byBoYXZlIHVucmVzdHJpY3RlZCBDUFUgYWNjZXNzIgogIHJlc2V0QWZmaW5pdHkgIiQodW5yZXN0cmljdGVkQ3B1c2V0KSIKfQoKc2V0UmVzdHJpY3RlZCgpIHsKICBsb2dnZXIgIlJlY292ZXJ5OiBSZXNldHRpbmcgY3JpdGljYWwgc3lzdGVtIHByb2Nlc3NlcyBiYWNrIHRvIG5vcm1hbGx5IHJlc3RyaWN0ZWQgYWNjZXNzIgogIHJlc2V0QWZmaW5pdHkgIiQocmVzdHJpY3RlZENwdXNldCkiCn0KCmN1cnJlbnRBZmZpbml0eSgpIHsKICBsb2NhbCBwaWQ9IiQxIgogIHRhc2tzZXQgLXBjICRwaWQgfCBhd2sgLUYnOiAnICd7cHJpbnQgJDJ9Jwp9Cgp3aXRoaW4oKSB7CiAgbG9jYWwgbGFzdD0kMSBjdXJyZW50PSQyIHRocmVzaG9sZD0kMwogIGxvY2FsIGRlbHRhPTAgcGNoYW5nZQogIGRlbHRhPSQoKCBjdXJyZW50IC0gbGFzdCApKQogIGlmIFtbICRjdXJyZW50IC1lcSAkbGFzdCBdXTsgdGhlbgogICAgcGNoYW5nZT0wCiAgZWxpZiBbWyAkbGFzdCAtZXEgMCBdXTsgdGhlbgogICAgcGNoYW5nZT0xMDAwMDAwCiAgZWxzZQogICAgcGNoYW5nZT0kKCggKCAkZGVsdGEgKiAxMDApIC8gbGFzdCApKQogIGZpCiAgZWNobyAtbiAibGFzdDokbGFzdCBjdXJyZW50OiRjdXJyZW50IGRlbHRhOiRkZWx0YSBwY2hhbmdlOiR7cGNoYW5nZX0lOiAiCiAgbG9jYWwgYWJzb2x1dGUgbGltaXQKICBjYXNlICR0aHJlc2hvbGQgaW4KICAgIColKQogICAgICBhYnNvbHV0ZT0ke3BjaGFuZ2UjIy19ICMgYWJzb2x1dGUgdmFsdWUKICAgICAgbGltaXQ9JHt0aHJlc2hvbGQlJSV9CiAgICAgIDs7CiAgICAqKQogICAgICBhYnNvbHV0ZT0ke2RlbHRhIyMtfSAjIGFic29sdXRlIHZhbHVlCiAgICAgIGxpbWl0PSR0aHJlc2hvbGQKICAgICAgOzsKICBlc2FjCiAgaWYgW1sgJGFic29sdXRlIC1sZSAkbGltaXQgXV07IHRoZW4KICAgIGVjaG8gIndpdGhpbiAoKy8tKSR0aHJlc2hvbGQiCiAgICByZXR1cm4gMAogIGVsc2UKICAgIGVjaG8gIm91dHNpZGUgKCsvLSkkdGhyZXNob2xkIgogICAgcmV0dXJuIDEKICBmaQp9CgpzdGVhZHlzdGF0ZSgpIHsKICBsb2NhbCBsYXN0PSQxIGN1cnJlbnQ9JDIKICBpZiBbWyAkbGFzdCAtbHQgJFNURUFEWV9TVEFURV9NSU5JTVVNIF1dOyB0aGVuCiAgICBlY2hvICJsYXN0OiRsYXN0IGN1cnJlbnQ6JGN1cnJlbnQgV2FpdGluZyB0byByZWFjaCAkU1RFQURZX1NUQVRFX01JTklNVU0gYmVmb3JlIGNoZWNraW5nIGZvciBzdGVhZHktc3RhdGUiCiAgICByZXR1cm4gMQogIGZpCiAgd2l0aGluICRsYXN0ICRjdXJyZW50ICRTVEVBRFlfU1RBVEVfVEhSRVNIT0xECn0KCndhaXRGb3JSZWFkeSgpIHsKICBsb2dnZXIgIlJlY292ZXJ5OiBXYWl0aW5nICR7TUFYSU1VTV9XQUlUX1RJTUV9cyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlIgogIGxvY2FsIGxhc3RTeXN0ZW1kQ3B1c2V0PSIkKGN1cnJlbnRBZmZpbml0eSAxKSIKICBsb2NhbCBsYXN0RGVzaXJlZENwdXNldD0iJCh1bnJlc3RyaWN0ZWRDcHVzZXQpIgogIGxvY2FsIHQ9MCBzPTEwCiAgbG9jYWwgbGFzdENjb3VudD0wIGNjb3VudD0wIHN0ZWFkeVN0YXRlVGltZT0wCiAgd2hpbGUgW1sgJHQgLWx0ICRNQVhJTVVNX1dBSVRfVElNRSBdXTsgZG8KICAgIHNsZWVwICRzCiAgICAoKHQgKz0gcykpCiAgICAjIFJlLWNoZWNrIHRoZSBjdXJyZW50IGFmZmluaXR5IG9mIHN5c3RlbWQsIGluIGNhc2Ugc29tZSBvdGhlciBwcm9jZXNzIGhhcyBjaGFuZ2VkIGl0CiAgICBsb2NhbCBzeXN0ZW1kQ3B1c2V0PSIkKGN1cnJlbnRBZmZpbml0eSAxKSIKICAgICMgUmUtY2hlY2sgdGhlIHVucmVzdHJpY3RlZCBDcHVzZXQsIGFzIHRoZSBhbGxvd2VkIHNldCBvZiB1bnJlc2VydmVkIGNvcmVzIG1heSBjaGFuZ2UgYXMgcG9kcyBhcmUgYXNzaWduZWQgdG8gY29yZXMKICAgIGxvY2FsIGRlc2lyZWRDcHVzZXQ9IiQodW5yZXN0cmljdGVkQ3B1c2V0KSIKICAgIGlmIFtbICRzeXN0ZW1kQ3B1c2V0ICE9ICRsYXN0U3lzdGVtZENwdXNldCB8fCAkbGFzdERlc2lyZWRDcHVzZXQgIT0gJGRlc2lyZWRDcHVzZXQgXV07IHRoZW4KICAgICAgcmVzZXRBZmZpbml0eSAiJGRlc2lyZWRDcHVzZXQiCiAgICAgIGxhc3RTeXN0ZW1kQ3B1c2V0PSIkKGN1cnJlbnRBZmZpbml0eSAxKSIKICAgICAgbGFzdERlc2lyZWRDcHVzZXQ9IiRkZXNpcmVkQ3B1c2V0IgogICAgZmkKCiAgICAjIERldGVjdCBzdGVhZHktc3RhdGUgcG9kIGNvdW50CiAgICBjY291bnQ9JChjcmljdGwgcHMgfCB3YyAtbCkKICAgIGlmIHN0ZWFkeXN0YXRlICRsYXN0Q2NvdW50ICRjY291bnQ7IHRoZW4KICAgICAgKChzdGVhZHlTdGF0ZVRpbWUgKz0gcykpCiAgICAgIGVjaG8gIlN0ZWFkeS1zdGF0ZSBmb3IgJHtzdGVhZHlTdGF0ZVRpbWV9cy8ke1NURUFEWV9TVEFURV9XSU5ET1d9cyIKICAgICAgaWYgW1sgJHN0ZWFkeVN0YXRlVGltZSAtZ2UgJFNURUFEWV9TVEFURV9XSU5ET1cgXV07IHRoZW4KICAgICAgICBsb2dnZXIgIlJlY292ZXJ5OiBTdGVhZHktc3RhdGUgKCsvLSAkU1RFQURZX1NUQVRFX1RIUkVTSE9MRCkgZm9yICR7U1RFQURZX1NUQVRFX1dJTkRPV31zOiBEb25lIgogICAgICAgIHJldHVybiAwCiAgICAgIGZpCiAgICBlbHNlCiAgICAgIGlmIFtbICRzdGVhZHlTdGF0ZVRpbWUgLWd0IDAgXV07IHRoZW4KICAgICAgICBlY2hvICJSZXNldHRpbmcgc3RlYWR5LXN0YXRlIHRpbWVyIgogICAgICAgIHN0ZWFkeVN0YXRlVGltZT0wCiAgICAgIGZpCiAgICBmaQogICAgbGFzdENjb3VudD0kY2NvdW50CiAgZG9uZQogIGxvZ2dlciAiUmVjb3Zlcnk6IFJlY292ZXJ5IENvbXBsZXRlIFRpbWVvdXQiCn0KCm1haW4oKSB7CiAgaWYgISB1bnJlc3RyaWN0ZWRDcHVzZXQgPiYvZGV2L251bGw7IHRoZW4KICAgIGxvZ2dlciAiUmVjb3Zlcnk6IE5vIHVucmVzdHJpY3RlZCBDcHVzZXQgY291bGQgYmUgZGV0ZWN0ZWQiCiAgICByZXR1cm4gMQogIGZpCgogIGlmICEgcmVzdHJpY3RlZENwdXNldCA+Ji9kZXYvbnVsbDsgdGhlbgogICAgbG9nZ2VyICJSZWNvdmVyeTogTm8gcmVzdHJpY3RlZCBDcHVzZXQgaGFzIGJlZW4gY29uZmlndXJlZC4gIFdlIGFyZSBhbHJlYWR5IHJ1bm5pbmcgdW5yZXN0cmljdGVkLiIKICAgIHJldHVybiAwCiAgZmkKCiAgIyBFbnN1cmUgd2UgcmVzZXQgdGhlIENQVSBhZmZpbml0eSB3aGVuIHdlIGV4aXQgdGhpcyBzY3JpcHQgZm9yIGFueSByZWFzb24KICAjIFRoaXMgd2F5IGVpdGhlciBhZnRlciB0aGUgdGltZXIgZXhwaXJlcyBvciBhZnRlciB0aGUgcHJvY2VzcyBpcyBpbnRlcnJ1cHRlZAogICMgdmlhIF5DIG9yIFNJR1RFUk0sIHdlIHJldHVybiB0aGluZ3MgYmFjayB0byB0aGUgd2F5IHRoZXkgc2hvdWxkIGJlLgogIHRyYXAgc2V0UmVzdHJpY3RlZCBFWElUCgogIGxvZ2dlciAiUmVjb3Zlcnk6IFJlY292ZXJ5IE1vZGUgU3RhcnRpbmciCiAgc2V0VW5yZXN0cmljdGVkCiAgd2FpdEZvclJlYWR5Cn0KCmlmIFtbICIke0JBU0hfU09VUkNFWzBdfSIgPSAiJHswfSIgXV07IHRoZW4KICBtYWluICIke0B9IgogIGV4aXQgJD8KZmkK
          mode: 493
          path: /usr/local/bin/accelerated-container-startup.sh
    systemd:
      units:
        - contents: |
            [Unit]
            Description=Unlocks more CPUs for critical system processes during container startup

            [Service]
            Type=simple
            ExecStart=/usr/local/bin/accelerated-container-startup.sh

            # Maximum wait time is 600s = 10m:
            Environment=MAXIMUM_WAIT_TIME=600

            # Steady-state threshold = 2%
            # Allowed values:
            #  4  - absolute pod count (+/-)
            #  4% - percent change (+/-)
            #  -1 - disable the steady-state check
            # Note: '%' must be escaped as '%%' in systemd unit files
            Environment=STEADY_STATE_THRESHOLD=2%%

            # Steady-state window = 120s
            # If the running pod count stays within the given threshold for this time
            # period, return CPU utilization to normal before the maximum wait time has
            # expires
            Environment=STEADY_STATE_WINDOW=120

            # Steady-state minimum = 40
            # Increasing this will skip any steady-state checks until the count rises above
            # this number to avoid false positives if there are some periods where the
            # count doesn't increase but we know we can't be at steady-state yet.
            Environment=STEADY_STATE_MINIMUM=40

            [Install]
            WantedBy=multi-user.target
          enabled: true
          name: accelerated-container-startup.service
        - contents: |
            [Unit]
            Description=Unlocks more CPUs for critical system processes during container shutdown
            DefaultDependencies=no

            [Service]
            Type=simple
            ExecStart=/usr/local/bin/accelerated-container-startup.sh

            # Maximum wait time is 600s = 10m:
            Environment=MAXIMUM_WAIT_TIME=600

            # Steady-state threshold
            # Allowed values:
            #  4  - absolute pod count (+/-)
            #  4% - percent change (+/-)
            #  -1 - disable the steady-state check
            # Note: '%' must be escaped as '%%' in systemd unit files
            Environment=STEADY_STATE_THRESHOLD=-1

            # Steady-state window = 60s
            # If the running pod count stays within the given threshold for this time
            # period, return CPU utilization to normal before the maximum wait time has
            # expires
            Environment=STEADY_STATE_WINDOW=60

            [Install]
            WantedBy=shutdown.target reboot.target halt.target
          enabled: true
          name: accelerated-container-shutdown.service</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-setting-rcu-normal_sno-configure-for-vdu">
<title>Setting rcu_normal</title>
<simpara>The following <literal>MachineConfig</literal> CR configures the system to set <literal>rcu_normal</literal> to 1 after the system has finished startup. This improves kernel latency for vDU applications.</simpara>
<formalpara>
<title>Recommended configuration for disabling <literal>rcu_expedited</literal> after the node has finished startup (<literal>08-set-rcu-normal-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 08-set-rcu-normal-master
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvYmluL2Jhc2gKIwojIERpc2FibGUgcmN1X2V4cGVkaXRlZCBhZnRlciBub2RlIGhhcyBmaW5pc2hlZCBib290aW5nCiMKIyBUaGUgZGVmYXVsdHMgYmVsb3cgY2FuIGJlIG92ZXJyaWRkZW4gdmlhIGVudmlyb25tZW50IHZhcmlhYmxlcwojCgojIERlZmF1bHQgd2FpdCB0aW1lIGlzIDYwMHMgPSAxMG06Ck1BWElNVU1fV0FJVF9USU1FPSR7TUFYSU1VTV9XQUlUX1RJTUU6LTYwMH0KCiMgRGVmYXVsdCBzdGVhZHktc3RhdGUgdGhyZXNob2xkID0gMiUKIyBBbGxvd2VkIHZhbHVlczoKIyAgNCAgLSBhYnNvbHV0ZSBwb2QgY291bnQgKCsvLSkKIyAgNCUgLSBwZXJjZW50IGNoYW5nZSAoKy8tKQojICAtMSAtIGRpc2FibGUgdGhlIHN0ZWFkeS1zdGF0ZSBjaGVjawpTVEVBRFlfU1RBVEVfVEhSRVNIT0xEPSR7U1RFQURZX1NUQVRFX1RIUkVTSE9MRDotMiV9CgojIERlZmF1bHQgc3RlYWR5LXN0YXRlIHdpbmRvdyA9IDYwcwojIElmIHRoZSBydW5uaW5nIHBvZCBjb3VudCBzdGF5cyB3aXRoaW4gdGhlIGdpdmVuIHRocmVzaG9sZCBmb3IgdGhpcyB0aW1lCiMgcGVyaW9kLCByZXR1cm4gQ1BVIHV0aWxpemF0aW9uIHRvIG5vcm1hbCBiZWZvcmUgdGhlIG1heGltdW0gd2FpdCB0aW1lIGhhcwojIGV4cGlyZXMKU1RFQURZX1NUQVRFX1dJTkRPVz0ke1NURUFEWV9TVEFURV9XSU5ET1c6LTYwfQoKIyBEZWZhdWx0IHN0ZWFkeS1zdGF0ZSBhbGxvd3MgYW55IHBvZCBjb3VudCB0byBiZSAic3RlYWR5IHN0YXRlIgojIEluY3JlYXNpbmcgdGhpcyB3aWxsIHNraXAgYW55IHN0ZWFkeS1zdGF0ZSBjaGVja3MgdW50aWwgdGhlIGNvdW50IHJpc2VzIGFib3ZlCiMgdGhpcyBudW1iZXIgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGlmIHRoZXJlIGFyZSBzb21lIHBlcmlvZHMgd2hlcmUgdGhlCiMgY291bnQgZG9lc24ndCBpbmNyZWFzZSBidXQgd2Uga25vdyB3ZSBjYW4ndCBiZSBhdCBzdGVhZHktc3RhdGUgeWV0LgpTVEVBRFlfU1RBVEVfTUlOSU1VTT0ke1NURUFEWV9TVEFURV9NSU5JTVVNOi0wfQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKd2l0aGluKCkgewogIGxvY2FsIGxhc3Q9JDEgY3VycmVudD0kMiB0aHJlc2hvbGQ9JDMKICBsb2NhbCBkZWx0YT0wIHBjaGFuZ2UKICBkZWx0YT0kKCggY3VycmVudCAtIGxhc3QgKSkKICBpZiBbWyAkY3VycmVudCAtZXEgJGxhc3QgXV07IHRoZW4KICAgIHBjaGFuZ2U9MAogIGVsaWYgW1sgJGxhc3QgLWVxIDAgXV07IHRoZW4KICAgIHBjaGFuZ2U9MTAwMDAwMAogIGVsc2UKICAgIHBjaGFuZ2U9JCgoICggIiRkZWx0YSIgKiAxMDApIC8gbGFzdCApKQogIGZpCiAgZWNobyAtbiAibGFzdDokbGFzdCBjdXJyZW50OiRjdXJyZW50IGRlbHRhOiRkZWx0YSBwY2hhbmdlOiR7cGNoYW5nZX0lOiAiCiAgbG9jYWwgYWJzb2x1dGUgbGltaXQKICBjYXNlICR0aHJlc2hvbGQgaW4KICAgIColKQogICAgICBhYnNvbHV0ZT0ke3BjaGFuZ2UjIy19ICMgYWJzb2x1dGUgdmFsdWUKICAgICAgbGltaXQ9JHt0aHJlc2hvbGQlJSV9CiAgICAgIDs7CiAgICAqKQogICAgICBhYnNvbHV0ZT0ke2RlbHRhIyMtfSAjIGFic29sdXRlIHZhbHVlCiAgICAgIGxpbWl0PSR0aHJlc2hvbGQKICAgICAgOzsKICBlc2FjCiAgaWYgW1sgJGFic29sdXRlIC1sZSAkbGltaXQgXV07IHRoZW4KICAgIGVjaG8gIndpdGhpbiAoKy8tKSR0aHJlc2hvbGQiCiAgICByZXR1cm4gMAogIGVsc2UKICAgIGVjaG8gIm91dHNpZGUgKCsvLSkkdGhyZXNob2xkIgogICAgcmV0dXJuIDEKICBmaQp9CgpzdGVhZHlzdGF0ZSgpIHsKICBsb2NhbCBsYXN0PSQxIGN1cnJlbnQ9JDIKICBpZiBbWyAkbGFzdCAtbHQgJFNURUFEWV9TVEFURV9NSU5JTVVNIF1dOyB0aGVuCiAgICBlY2hvICJsYXN0OiRsYXN0IGN1cnJlbnQ6JGN1cnJlbnQgV2FpdGluZyB0byByZWFjaCAkU1RFQURZX1NUQVRFX01JTklNVU0gYmVmb3JlIGNoZWNraW5nIGZvciBzdGVhZHktc3RhdGUiCiAgICByZXR1cm4gMQogIGZpCiAgd2l0aGluICIkbGFzdCIgIiRjdXJyZW50IiAiJFNURUFEWV9TVEFURV9USFJFU0hPTEQiCn0KCndhaXRGb3JSZWFkeSgpIHsKICBsb2dnZXIgIlJlY292ZXJ5OiBXYWl0aW5nICR7TUFYSU1VTV9XQUlUX1RJTUV9cyBmb3IgdGhlIGluaXRpYWxpemF0aW9uIHRvIGNvbXBsZXRlIgogIGxvY2FsIHQ9MCBzPTEwCiAgbG9jYWwgbGFzdENjb3VudD0wIGNjb3VudD0wIHN0ZWFkeVN0YXRlVGltZT0wCiAgd2hpbGUgW1sgJHQgLWx0ICRNQVhJTVVNX1dBSVRfVElNRSBdXTsgZG8KICAgIHNsZWVwICRzCiAgICAoKHQgKz0gcykpCiAgICAjIERldGVjdCBzdGVhZHktc3RhdGUgcG9kIGNvdW50CiAgICBjY291bnQ9JChjcmljdGwgcHMgMj4vZGV2L251bGwgfCB3YyAtbCkKICAgIGlmIFtbICRjY291bnQgLWd0IDAgXV0gJiYgc3RlYWR5c3RhdGUgIiRsYXN0Q2NvdW50IiAiJGNjb3VudCI7IHRoZW4KICAgICAgKChzdGVhZHlTdGF0ZVRpbWUgKz0gcykpCiAgICAgIGVjaG8gIlN0ZWFkeS1zdGF0ZSBmb3IgJHtzdGVhZHlTdGF0ZVRpbWV9cy8ke1NURUFEWV9TVEFURV9XSU5ET1d9cyIKICAgICAgaWYgW1sgJHN0ZWFkeVN0YXRlVGltZSAtZ2UgJFNURUFEWV9TVEFURV9XSU5ET1cgXV07IHRoZW4KICAgICAgICBsb2dnZXIgIlJlY292ZXJ5OiBTdGVhZHktc3RhdGUgKCsvLSAkU1RFQURZX1NUQVRFX1RIUkVTSE9MRCkgZm9yICR7U1RFQURZX1NUQVRFX1dJTkRPV31zOiBEb25lIgogICAgICAgIHJldHVybiAwCiAgICAgIGZpCiAgICBlbHNlCiAgICAgIGlmIFtbICRzdGVhZHlTdGF0ZVRpbWUgLWd0IDAgXV07IHRoZW4KICAgICAgICBlY2hvICJSZXNldHRpbmcgc3RlYWR5LXN0YXRlIHRpbWVyIgogICAgICAgIHN0ZWFkeVN0YXRlVGltZT0wCiAgICAgIGZpCiAgICBmaQogICAgbGFzdENjb3VudD0kY2NvdW50CiAgZG9uZQogIGxvZ2dlciAiUmVjb3Zlcnk6IFJlY292ZXJ5IENvbXBsZXRlIFRpbWVvdXQiCn0KCnNldFJjdU5vcm1hbCgpIHsKICBlY2hvICJTZXR0aW5nIHJjdV9ub3JtYWwgdG8gMSIKICBlY2hvIDEgPiAvc3lzL2tlcm5lbC9yY3Vfbm9ybWFsCn0KCm1haW4oKSB7CiAgd2FpdEZvclJlYWR5CiAgZWNobyAiV2FpdGluZyBmb3Igc3RlYWR5IHN0YXRlIHRvb2s6ICQoYXdrICd7cHJpbnQgaW50KCQxLzM2MDApImgiLCBpbnQoKCQxJTM2MDApLzYwKSJtIiwgaW50KCQxJTYwKSJzIn0nIC9wcm9jL3VwdGltZSkiCiAgc2V0UmN1Tm9ybWFsCn0KCmlmIFtbICIke0JBU0hfU09VUkNFWzBdfSIgPSAiJHswfSIgXV07IHRoZW4KICBtYWluICIke0B9IgogIGV4aXQgJD8KZmkK
          mode: 493
          path: /usr/local/bin/set-rcu-normal.sh
    systemd:
      units:
        - contents: |
            [Unit]
            Description=Disable rcu_expedited after node has finished booting by setting rcu_normal to 1

            [Service]
            Type=simple
            ExecStart=/usr/local/bin/set-rcu-normal.sh

            # Maximum wait time is 600s = 10m:
            Environment=MAXIMUM_WAIT_TIME=600

            # Steady-state threshold = 2%
            # Allowed values:
            #  4  - absolute pod count (+/-)
            #  4% - percent change (+/-)
            #  -1 - disable the steady-state check
            # Note: '%' must be escaped as '%%' in systemd unit files
            Environment=STEADY_STATE_THRESHOLD=2%%

            # Steady-state window = 120s
            # If the running pod count stays within the given threshold for this time
            # period, return CPU utilization to normal before the maximum wait time has
            # expires
            Environment=STEADY_STATE_WINDOW=120

            # Steady-state minimum = 40
            # Increasing this will skip any steady-state checks until the count rises above
            # this number to avoid false positives if there are some periods where the
            # count doesn't increase but we know we can't be at steady-state yet.
            Environment=STEADY_STATE_MINIMUM=40

            [Install]
            WantedBy=multi-user.target
          enabled: true
          name: set-rcu-normal.service</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-enabling-kdump_sno-configure-for-vdu">
<title>Automatic kernel crash dumps with kdump</title>
<simpara><literal>kdump</literal> is a Linux kernel feature that creates a kernel crash dump when the kernel crashes. <literal>kdump</literal> is enabled with the following <literal>MachineConfig</literal> CRs.</simpara>
<formalpara>
<title>Recommended <literal>MachineConfig</literal> CR to remove ice driver from control plane kdump logs (<literal>05-kdump-config-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 05-kdump-config-master
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - enabled: true
          name: kdump-remove-ice-module.service
          contents: |
            [Unit]
            Description=Remove ice module when doing kdump
            Before=kdump.service
            [Service]
            Type=oneshot
            RemainAfterExit=true
            ExecStart=/usr/local/bin/kdump-remove-ice-module.sh
            [Install]
            WantedBy=multi-user.target
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvdXNyL2Jpbi9lbnYgYmFzaAoKIyBUaGlzIHNjcmlwdCByZW1vdmVzIHRoZSBpY2UgbW9kdWxlIGZyb20ga2R1bXAgdG8gcHJldmVudCBrZHVtcCBmYWlsdXJlcyBvbiBjZXJ0YWluIHNlcnZlcnMuCiMgVGhpcyBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBSSEVMUExBTi0xMzgyMzYgYW5kIGNhbiBiZSByZW1vdmVkIHdoZW4gdGhhdCBpc3N1ZSBpcwojIGZpeGVkLgoKc2V0IC14CgpTRUQ9Ii91c3IvYmluL3NlZCIKR1JFUD0iL3Vzci9iaW4vZ3JlcCIKCiMgb3ZlcnJpZGUgZm9yIHRlc3RpbmcgcHVycG9zZXMKS0RVTVBfQ09ORj0iJHsxOi0vZXRjL3N5c2NvbmZpZy9rZHVtcH0iClJFTU9WRV9JQ0VfU1RSPSJtb2R1bGVfYmxhY2tsaXN0PWljZSIKCiMgZXhpdCBpZiBmaWxlIGRvZXNuJ3QgZXhpc3QKWyAhIC1mICR7S0RVTVBfQ09ORn0gXSAmJiBleGl0IDAKCiMgZXhpdCBpZiBmaWxlIGFscmVhZHkgdXBkYXRlZAoke0dSRVB9IC1GcSAke1JFTU9WRV9JQ0VfU1RSfSAke0tEVU1QX0NPTkZ9ICYmIGV4aXQgMAoKIyBUYXJnZXQgbGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOgojIEtEVU1QX0NPTU1BTkRMSU5FX0FQUEVORD0iaXJxcG9sbCBucl9jcHVzPTEgLi4uIGhlc3RfZGlzYWJsZSIKIyBVc2Ugc2VkIHRvIG1hdGNoIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgcXVvdGVzIGFuZCBhcHBlbmQgdGhlIFJFTU9WRV9JQ0VfU1RSIHRvIGl0CiR7U0VEfSAtaSAncy9eS0RVTVBfQ09NTUFORExJTkVfQVBQRU5EPSJbXiJdKi8mICcke1JFTU9WRV9JQ0VfU1RSfScvJyAke0tEVU1QX0NPTkZ9IHx8IGV4aXQgMAo=
          mode: 448
          path: /usr/local/bin/kdump-remove-ice-module.sh</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended control plane node kdump configuration (<literal>06-kdump-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 06-kdump-enable-master
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - enabled: true
          name: kdump.service
  kernelArguments:
    - crashkernel=512M</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>MachineConfig</literal> CR to remove ice driver from worker node kdump logs (<literal>05-kdump-config-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 05-kdump-config-worker
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - enabled: true
          name: kdump-remove-ice-module.service
          contents: |
            [Unit]
            Description=Remove ice module when doing kdump
            Before=kdump.service
            [Service]
            Type=oneshot
            RemainAfterExit=true
            ExecStart=/usr/local/bin/kdump-remove-ice-module.sh
            [Install]
            WantedBy=multi-user.target
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,IyEvdXNyL2Jpbi9lbnYgYmFzaAoKIyBUaGlzIHNjcmlwdCByZW1vdmVzIHRoZSBpY2UgbW9kdWxlIGZyb20ga2R1bXAgdG8gcHJldmVudCBrZHVtcCBmYWlsdXJlcyBvbiBjZXJ0YWluIHNlcnZlcnMuCiMgVGhpcyBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIGZvciBSSEVMUExBTi0xMzgyMzYgYW5kIGNhbiBiZSByZW1vdmVkIHdoZW4gdGhhdCBpc3N1ZSBpcwojIGZpeGVkLgoKc2V0IC14CgpTRUQ9Ii91c3IvYmluL3NlZCIKR1JFUD0iL3Vzci9iaW4vZ3JlcCIKCiMgb3ZlcnJpZGUgZm9yIHRlc3RpbmcgcHVycG9zZXMKS0RVTVBfQ09ORj0iJHsxOi0vZXRjL3N5c2NvbmZpZy9rZHVtcH0iClJFTU9WRV9JQ0VfU1RSPSJtb2R1bGVfYmxhY2tsaXN0PWljZSIKCiMgZXhpdCBpZiBmaWxlIGRvZXNuJ3QgZXhpc3QKWyAhIC1mICR7S0RVTVBfQ09ORn0gXSAmJiBleGl0IDAKCiMgZXhpdCBpZiBmaWxlIGFscmVhZHkgdXBkYXRlZAoke0dSRVB9IC1GcSAke1JFTU9WRV9JQ0VfU1RSfSAke0tEVU1QX0NPTkZ9ICYmIGV4aXQgMAoKIyBUYXJnZXQgbGluZSBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOgojIEtEVU1QX0NPTU1BTkRMSU5FX0FQUEVORD0iaXJxcG9sbCBucl9jcHVzPTEgLi4uIGhlc3RfZGlzYWJsZSIKIyBVc2Ugc2VkIHRvIG1hdGNoIGV2ZXJ5dGhpbmcgYmV0d2VlbiB0aGUgcXVvdGVzIGFuZCBhcHBlbmQgdGhlIFJFTU9WRV9JQ0VfU1RSIHRvIGl0CiR7U0VEfSAtaSAncy9eS0RVTVBfQ09NTUFORExJTkVfQVBQRU5EPSJbXiJdKi8mICcke1JFTU9WRV9JQ0VfU1RSfScvJyAke0tEVU1QX0NPTkZ9IHx8IGV4aXQgMAo=
          mode: 448
          path: /usr/local/bin/kdump-remove-ice-module.sh</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended kdump worker node configuration (<literal>06-kdump-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 06-kdump-enable-worker
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - enabled: true
          name: kdump.service
  kernelArguments:
    - crashkernel=512M</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-disabling-crio-wipe_sno-configure-for-vdu">
<title>Disable automatic CRI-O cache wipe</title>
<simpara>After an uncontrolled host shutdown or cluster reboot, CRI-O automatically deletes the entire CRI-O cache, causing all images to be pulled from the registry when the node reboots.
This can result in unacceptably slow recovery times or recovery failures.
To prevent this from happening in single-node OpenShift clusters that you install with GitOps ZTP, disable the CRI-O delete cache feature during cluster installation.</simpara>
<formalpara>
<title>Recommended <literal>MachineConfig</literal> CR to disable CRI-O cache wipe on control plane nodes (<literal>99-crio-disable-wipe-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 99-crio-disable-wipe-master
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,W2NyaW9dCmNsZWFuX3NodXRkb3duX2ZpbGUgPSAiIgo=
          mode: 420
          path: /etc/crio/crio.conf.d/99-crio-disable-wipe.toml</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>MachineConfig</literal> CR to disable CRI-O cache wipe on worker nodes (<literal>99-crio-disable-wipe-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 99-crio-disable-wipe-worker
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
        - contents:
            source: data:text/plain;charset=utf-8;base64,W2NyaW9dCmNsZWFuX3NodXRkb3duX2ZpbGUgPSAiIgo=
          mode: 420
          path: /etc/crio/crio.conf.d/99-crio-disable-wipe.toml</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-configuring-crun-container-runtime_sno-configure-for-vdu">
<title>Configuring crun as the default container runtime</title>
<simpara>The following <literal>ContainerRuntimeConfig</literal> custom resources (CRs) configure crun as the default OCI container runtime for control plane and worker nodes.
The crun container runtime is fast and lightweight and has a low memory footprint.</simpara>
<important>
<simpara>For optimal performance, enable crun for control plane and worker nodes in single-node OpenShift, three-node OpenShift, and standard clusters.
To avoid the cluster rebooting when the CR is applied, apply the change as a GitOps ZTP additional Day 0 install-time manifest.</simpara>
</important>
<formalpara>
<title>Recommended <literal>ContainerRuntimeConfig</literal> CR for control plane nodes (<literal>enable-crun-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: ContainerRuntimeConfig
metadata:
  name: enable-crun-master
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/master: ""
  containerRuntimeConfig:
    defaultRuntime: crun</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>ContainerRuntimeConfig</literal> CR for worker nodes (<literal>enable-crun-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: ContainerRuntimeConfig
metadata:
  name: enable-crun-worker
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: ""
  containerRuntimeConfig:
    defaultRuntime: crun</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="ztp-sno-post-install-time-cluster-config">
<title>Recommended postinstallation cluster configurations</title>
<simpara>When the cluster installation is complete, the ZTP pipeline applies the following custom resources (CRs) that are required to run DU workloads.</simpara>
<note>
<simpara>In GitOps ZTP v4.10 and earlier, you configure UEFI secure boot with a <literal>MachineConfig</literal> CR. This is no longer required in GitOps ZTP v4.11 and later. In v4.11, you configure UEFI secure boot for single-node OpenShift clusters by updating the <literal>spec.clusters.nodes.bootMode</literal> field in the <literal>SiteConfig</literal> CR that you use to install the cluster. For more information, see <link linkend="ztp-deploying-a-site_ztp-deploying-far-edge-sites">Deploying a managed cluster with SiteConfig and GitOps ZTP</link>.</simpara>
</note>
<section xml:id="ztp-sno-du-configuring-the-operators_sno-configure-for-vdu">
<title>Operators</title>
<simpara>Single-node OpenShift clusters that run DU workloads require the following Operators to be installed:</simpara>
<itemizedlist>
<listitem>
<simpara>Local Storage Operator</simpara>
</listitem>
<listitem>
<simpara>Logging Operator</simpara>
</listitem>
<listitem>
<simpara>PTP Operator</simpara>
</listitem>
<listitem>
<simpara>SR-IOV Network Operator</simpara>
</listitem>
</itemizedlist>
<simpara>You also need to configure a custom <literal>CatalogSource</literal> CR, disable the default <literal>OperatorHub</literal> configuration, and configure an <literal>ImageContentSourcePolicy</literal> mirror registry that is accessible from the clusters that you install.</simpara>
<formalpara>
<title>Recommended Storage Operator namespace and Operator group configuration (<literal>StorageNS.yaml</literal>, <literal>StorageOperGroup.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: v1
kind: Namespace
metadata:
  name: openshift-local-storage
  annotations:
    workload.openshift.io/allowed: management
---
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: openshift-local-storage
  namespace: openshift-local-storage
  annotations: {}
spec:
  targetNamespaces:
    - openshift-local-storage</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended Cluster Logging Operator namespace and Operator group configuration (<literal>ClusterLogNS.yaml</literal>, <literal>ClusterLogOperGroup.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: v1
kind: Namespace
metadata:
  name: openshift-logging
  annotations:
    workload.openshift.io/allowed: management
---
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: cluster-logging
  namespace: openshift-logging
  annotations: {}
spec:
  targetNamespaces:
    - openshift-logging</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended PTP Operator namespace and Operator group configuration (<literal>PtpSubscriptionNS.yaml</literal>, <literal>PtpSubscriptionOperGroup.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: v1
kind: Namespace
metadata:
  name: openshift-ptp
  annotations:
    workload.openshift.io/allowed: management
  labels:
    openshift.io/cluster-monitoring: "true"
---
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: ptp-operators
  namespace: openshift-ptp
  annotations: {}
spec:
  targetNamespaces:
    - openshift-ptp</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended SR-IOV Operator namespace and Operator group configuration (<literal>SriovSubscriptionNS.yaml</literal>, <literal>SriovSubscriptionOperGroup.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: v1
kind: Namespace
metadata:
  name: openshift-sriov-network-operator
  annotations:
    workload.openshift.io/allowed: management
---
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: sriov-network-operators
  namespace: openshift-sriov-network-operator
  annotations: {}
spec:
  targetNamespaces:
    - openshift-sriov-network-operator</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>CatalogSource</literal> configuration (<literal>DefaultCatsrc.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: default-cat-source
  namespace: openshift-marketplace
  annotations:
    target.workload.openshift.io/management: '{"effect": "PreferredDuringScheduling"}'
spec:
  displayName: default-cat-source
  image: $imageUrl
  publisher: Red Hat
  sourceType: grpc
  updateStrategy:
    registryPoll:
      interval: 1h
status:
  connectionState:
    lastObservedState: READY</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>ImageContentSourcePolicy</literal> configuration (<literal>DisconnectedICSP.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: disconnected-internal-icsp
  annotations: {}
spec:
  repositoryDigestMirrors:
    - $mirrors</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended <literal>OperatorHub</literal> configuration (<literal>OperatorHub.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OperatorHub
metadata:
  name: cluster
  annotations: {}
spec:
  disableAllDefaultSources: true</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-subscribing-to-the-operators-needed-for-platform-configuration_sno-configure-for-vdu">
<title>Operator subscriptions</title>
<simpara>Single-node OpenShift clusters that run DU workloads require the following <literal>Subscription</literal> CRs. The subscription provides the location to download the following Operators:</simpara>
<itemizedlist>
<listitem>
<simpara>Local Storage Operator</simpara>
</listitem>
<listitem>
<simpara>Logging Operator</simpara>
</listitem>
<listitem>
<simpara>PTP Operator</simpara>
</listitem>
<listitem>
<simpara>SR-IOV Network Operator</simpara>
</listitem>
<listitem>
<simpara>SRIOV-FEC Operator</simpara>
</listitem>
</itemizedlist>
<simpara>For each Operator subscription, specify the channel to get the Operator from. The recommended channel is <literal>stable</literal>.</simpara>
<simpara>You can specify <literal>Manual</literal> or <literal>Automatic</literal> updates.
In <literal>Automatic</literal> mode, the Operator automatically updates to the latest versions in the channel as they become available in the registry.
In <literal>Manual</literal> mode, new Operator versions are installed only when they are explicitly approved.</simpara>
<tip>
<simpara>Use <literal>Manual</literal> mode for subscriptions. This allows you to control the timing of Operator updates to fit within scheduled maintenance windows.</simpara>
</tip>
<formalpara>
<title>Recommended Local Storage Operator subscription (<literal>StorageSubscription.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: local-storage-operator
  namespace: openshift-local-storage
  annotations: {}
spec:
  channel: "stable"
  name: local-storage-operator
  source: redhat-operators-disconnected
  sourceNamespace: openshift-marketplace
  installPlanApproval: Manual
status:
  state: AtLatestKnown</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended SR-IOV Operator subscription (<literal>SriovSubscription.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: sriov-network-operator-subscription
  namespace: openshift-sriov-network-operator
  annotations: {}
spec:
  channel: "stable"
  name: sriov-network-operator
  source: redhat-operators-disconnected
  sourceNamespace: openshift-marketplace
  installPlanApproval: Manual
status:
  state: AtLatestKnown</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended PTP Operator subscription (<literal>PtpSubscription.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: ptp-operator-subscription
  namespace: openshift-ptp
  annotations: {}
spec:
  channel: "stable"
  name: ptp-operator
  source: redhat-operators-disconnected
  sourceNamespace: openshift-marketplace
  installPlanApproval: Manual
status:
  state: AtLatestKnown</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended Cluster Logging Operator subscription (<literal>ClusterLogSubscription.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: cluster-logging
  namespace: openshift-logging
  annotations: {}
spec:
  channel: "stable"
  name: cluster-logging
  source: redhat-operators-disconnected
  sourceNamespace: openshift-marketplace
  installPlanApproval: Manual
status:
  state: AtLatestKnown</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-configuring-logging-locally-and-forwarding_sno-configure-for-vdu">
<title>Cluster logging and log forwarding</title>
<simpara>Single-node OpenShift clusters that run DU workloads require logging and log forwarding for debugging. The following <literal>ClusterLogging</literal> and <literal>ClusterLogForwarder</literal> custom resources (CRs) are required.</simpara>
<formalpara>
<title>Recommended cluster logging configuration (<literal>ClusterLogging.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: ClusterLogging
metadata:
  name: instance
  namespace: openshift-logging
  annotations: {}
spec:
  managementState: "Managed"
  collection:
    logs:
      type: "vector"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended log forwarding configuration (<literal>ClusterLogForwarder.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "logging.openshift.io/v1"
kind: ClusterLogForwarder
metadata:
  name: instance
  namespace: openshift-logging
  annotations: {}
spec:
  outputs: $outputs
  pipelines: $pipelines</programlisting>
</para>
</formalpara>
<simpara>Set the <literal>spec.outputs.url</literal> field to the URL of the Kafka server where the logs are forwarded to.</simpara>
</section>
<section xml:id="ztp-sno-du-configuring-performance-addons_sno-configure-for-vdu">
<title>Performance profile</title>
<simpara>Single-node OpenShift clusters that run DU workloads require a Node Tuning Operator performance profile to use real-time host capabilities and services.</simpara>
<note>
<simpara>In earlier versions of OpenShift Container Platform, the Performance Addon Operator was used to implement automatic tuning to achieve low latency performance for OpenShift applications. In OpenShift Container Platform 4.11 and later, this functionality is part of the Node Tuning Operator.</simpara>
</note>
<simpara>The following example <literal>PerformanceProfile</literal> CR illustrates the required single-node OpenShift cluster configuration.</simpara>
<formalpara>
<title>Recommended performance profile configuration (<literal>PerformanceProfile.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  # if you change this name make sure the 'include' line in TunedPerformancePatch.yaml
  # matches this name: include=openshift-node-performance-${PerformanceProfile.metadata.name}
  # Also in file 'validatorCRs/informDuValidator.yaml': 
  # name: 50-performance-${PerformanceProfile.metadata.name}
  name: openshift-node-performance-profile
  annotations:
    ran.openshift.io/reference-configuration: "ran-du.redhat.com"
spec:
  additionalKernelArgs:
    - "rcupdate.rcu_normal_after_boot=0"
    - "efi=runtime"
    - "vfio_pci.enable_sriov=1"
    - "vfio_pci.disable_idle_d3=1"
    - "module_blacklist=irdma"
  cpu:
    isolated: $isolated
    reserved: $reserved
  hugepages:
    defaultHugepagesSize: $defaultHugepagesSize
    pages:
      - size: $size
        count: $count
        node: $node
  machineConfigPoolSelector:
    pools.operator.machineconfiguration.openshift.io/$mcp: ""
  nodeSelector:
    node-role.kubernetes.io/$mcp: ""
  numa:
    topologyPolicy: "restricted"
  # To use the standard (non-realtime) kernel, set enabled to false
  realTimeKernel:
    enabled: true
  workloadHints:
    # WorkloadHints defines the set of upper level flags for different type of workloads.
    # See https://github.com/openshift/cluster-node-tuning-operator/blob/master/docs/performanceprofile/performance_profile.md#workloadhints
    # for detailed descriptions of each item.
    # The configuration below is set for a low latency, performance mode.
    realTime: true
    highPowerConsumption: false
    perPodPowerManagement: false</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>PerformanceProfile CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">PerformanceProfile CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Ensure that <literal>name</literal> matches the following fields set in related GitOps ZTP custom resources (CRs):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>include=openshift-node-performance-${PerformanceProfile.metadata.name}</literal> in <literal>TunedPerformancePatch.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>name: 50-performance-${PerformanceProfile.metadata.name}</literal> in <literal>validatorCRs/informDuValidator.yaml</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.additionalKernelArgs</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>"efi=runtime"</literal> Configures UEFI secure boot for the cluster host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.cpu.isolated</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the isolated CPUs. Ensure all of the Hyper-Threading pairs match.</simpara>
<important>
<simpara>The reserved and isolated CPU pools must not overlap and together must span all available cores. CPU cores that are not accounted for cause an undefined behaviour in the system.</simpara>
</important></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.cpu.reserved</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the reserved CPUs. When workload partitioning is enabled, system processes, kernel threads, and system container threads are restricted to these CPUs. All CPUs that are not isolated should be reserved.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.hugepages.pages</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Set the number of huge pages (<literal>count</literal>)</simpara>
</listitem>
<listitem>
<simpara>Set the huge pages size (<literal>size</literal>).</simpara>
</listitem>
<listitem>
<simpara>Set <literal>node</literal> to the NUMA node where the <literal>hugepages</literal> are allocated (<literal>node</literal>)</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.realTimeKernel</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set <literal>enabled</literal> to <literal>true</literal> to use the realtime kernel.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.workloadHints</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Use <literal>workloadHints</literal> to define the set of top level flags for different type of workloads.
The example configuration configures the cluster for low latency and high performance.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ztp-sno-du-configuring-time-sync_sno-configure-for-vdu">
<title>Configuring cluster time synchronization</title>
<simpara>Run a one-time system time synchronization job for control plane or worker nodes.</simpara>
<formalpara>
<title>Recommended one time time-sync for control plane nodes (<literal>99-sync-time-once-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 99-sync-time-once-master
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - contents: |
            [Unit]
            Description=Sync time once
            After=network.service
            [Service]
            Type=oneshot
            TimeoutStartSec=300
            ExecStart=/usr/sbin/chronyd -n -f /etc/chrony.conf -q
            RemainAfterExit=yes
            [Install]
            WantedBy=multi-user.target
          enabled: true
          name: sync-time-once.service</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended one time time-sync for worker nodes (<literal>99-sync-time-once-worker.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 99-sync-time-once-worker
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
        - contents: |
            [Unit]
            Description=Sync time once
            After=network.service
            [Service]
            Type=oneshot
            TimeoutStartSec=300
            ExecStart=/usr/sbin/chronyd -n -f /etc/chrony.conf -q
            RemainAfterExit=yes
            [Install]
            WantedBy=multi-user.target
          enabled: true
          name: sync-time-once.service</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-configuring-ptp_sno-configure-for-vdu">
<title>PTP</title>
<simpara>Single-node OpenShift clusters use Precision Time Protocol (PTP) for network time synchronization.
The following example <literal>PtpConfig</literal> CRs illustrate the required PTP configurations for ordinary clocks, boundary clocks, and grandmaster clocks.
The exact configuration you apply will depend on the node hardware and specific use case.</simpara>
<formalpara>
<title>Recommended PTP ordinary clock configuration (<literal>PtpConfigSlave.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ptp.openshift.io/v1
kind: PtpConfig
metadata:
  name: slave
  namespace: openshift-ptp
  annotations: {}
spec:
  profile:
    - name: "slave"
      # The interface name is hardware-specific
      interface: $interface
      ptp4lOpts: "-2 -s"
      phc2sysOpts: "-a -r -n 24"
      ptpSchedulingPolicy: SCHED_FIFO
      ptpSchedulingPriority: 10
      ptpSettings:
        logReduce: "true"
      ptp4lConf: |
        [global]
        #
        # Default Data Set
        #
        twoStepFlag 1
        slaveOnly 1
        priority1 128
        priority2 128
        domainNumber 24
        #utc_offset 37
        clockClass 255
        clockAccuracy 0xFE
        offsetScaledLogVariance 0xFFFF
        free_running 0
        freq_est_interval 1
        dscp_event 0
        dscp_general 0
        dataset_comparison G.8275.x
        G.8275.defaultDS.localPriority 128
        #
        # Port Data Set
        #
        logAnnounceInterval -3
        logSyncInterval -4
        logMinDelayReqInterval -4
        logMinPdelayReqInterval -4
        announceReceiptTimeout 3
        syncReceiptTimeout 0
        delayAsymmetry 0
        fault_reset_interval -4
        neighborPropDelayThresh 20000000
        masterOnly 0
        G.8275.portDS.localPriority 128
        #
        # Run time options
        #
        assume_two_step 0
        logging_level 6
        path_trace_enabled 0
        follow_up_info 0
        hybrid_e2e 0
        inhibit_multicast_service 0
        net_sync_monitor 0
        tc_spanning_tree 0
        tx_timestamp_timeout 50
        unicast_listen 0
        unicast_master_table 0
        unicast_req_duration 3600
        use_syslog 1
        verbose 0
        summary_interval 0
        kernel_leap 1
        check_fup_sync 0
        clock_class_threshold 7
        #
        # Servo Options
        #
        pi_proportional_const 0.0
        pi_integral_const 0.0
        pi_proportional_scale 0.0
        pi_proportional_exponent -0.3
        pi_proportional_norm_max 0.7
        pi_integral_scale 0.0
        pi_integral_exponent 0.4
        pi_integral_norm_max 0.3
        step_threshold 2.0
        first_step_threshold 0.00002
        max_frequency 900000000
        clock_servo pi
        sanity_freq_limit 200000000
        ntpshm_segment 0
        #
        # Transport options
        #
        transportSpecific 0x0
        ptp_dst_mac 01:1B:19:00:00:00
        p2p_dst_mac 01:80:C2:00:00:0E
        udp_ttl 1
        udp6_scope 0x0E
        uds_address /var/run/ptp4l
        #
        # Default interface options
        #
        clock_type OC
        network_transport L2
        delay_mechanism E2E
        time_stamping hardware
        tsproc_mode filter
        delay_filter moving_median
        delay_filter_length 10
        egressLatency 0
        ingressLatency 0
        boundary_clock_jbod 0
        #
        # Clock description
        #
        productDescription ;;
        revisionData ;;
        manufacturerIdentity 00:00:00
        userDescription ;
        timeSource 0xA0
  recommend:
    - profile: "slave"
      priority: 4
      match:
        - nodeLabel: "node-role.kubernetes.io/$mcp"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended boundary clock configuration (<literal>PtpConfigBoundary.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ptp.openshift.io/v1
kind: PtpConfig
metadata:
  name: boundary
  namespace: openshift-ptp
  annotations: {}
spec:
  profile:
    - name: "boundary"
      ptp4lOpts: "-2"
      phc2sysOpts: "-a -r -n 24"
      ptpSchedulingPolicy: SCHED_FIFO
      ptpSchedulingPriority: 10
      ptpSettings:
        logReduce: "true"
      ptp4lConf: |
        # The interface name is hardware-specific
        [$iface_slave]
        masterOnly 0
        [$iface_master_1]
        masterOnly 1
        [$iface_master_2]
        masterOnly 1
        [$iface_master_3]
        masterOnly 1
        [global]
        #
        # Default Data Set
        #
        twoStepFlag 1
        slaveOnly 0
        priority1 128
        priority2 128
        domainNumber 24
        #utc_offset 37
        clockClass 248
        clockAccuracy 0xFE
        offsetScaledLogVariance 0xFFFF
        free_running 0
        freq_est_interval 1
        dscp_event 0
        dscp_general 0
        dataset_comparison G.8275.x
        G.8275.defaultDS.localPriority 128
        #
        # Port Data Set
        #
        logAnnounceInterval -3
        logSyncInterval -4
        logMinDelayReqInterval -4
        logMinPdelayReqInterval -4
        announceReceiptTimeout 3
        syncReceiptTimeout 0
        delayAsymmetry 0
        fault_reset_interval -4
        neighborPropDelayThresh 20000000
        masterOnly 0
        G.8275.portDS.localPriority 128
        #
        # Run time options
        #
        assume_two_step 0
        logging_level 6
        path_trace_enabled 0
        follow_up_info 0
        hybrid_e2e 0
        inhibit_multicast_service 0
        net_sync_monitor 0
        tc_spanning_tree 0
        tx_timestamp_timeout 50
        unicast_listen 0
        unicast_master_table 0
        unicast_req_duration 3600
        use_syslog 1
        verbose 0
        summary_interval 0
        kernel_leap 1
        check_fup_sync 0
        clock_class_threshold 135
        #
        # Servo Options
        #
        pi_proportional_const 0.0
        pi_integral_const 0.0
        pi_proportional_scale 0.0
        pi_proportional_exponent -0.3
        pi_proportional_norm_max 0.7
        pi_integral_scale 0.0
        pi_integral_exponent 0.4
        pi_integral_norm_max 0.3
        step_threshold 2.0
        first_step_threshold 0.00002
        max_frequency 900000000
        clock_servo pi
        sanity_freq_limit 200000000
        ntpshm_segment 0
        #
        # Transport options
        #
        transportSpecific 0x0
        ptp_dst_mac 01:1B:19:00:00:00
        p2p_dst_mac 01:80:C2:00:00:0E
        udp_ttl 1
        udp6_scope 0x0E
        uds_address /var/run/ptp4l
        #
        # Default interface options
        #
        clock_type BC
        network_transport L2
        delay_mechanism E2E
        time_stamping hardware
        tsproc_mode filter
        delay_filter moving_median
        delay_filter_length 10
        egressLatency 0
        ingressLatency 0
        boundary_clock_jbod 0
        #
        # Clock description
        #
        productDescription ;;
        revisionData ;;
        manufacturerIdentity 00:00:00
        userDescription ;
        timeSource 0xA0
  recommend:
    - profile: "boundary"
      priority: 4
      match:
        - nodeLabel: "node-role.kubernetes.io/$mcp"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Recommended PTP Westport Channel e810 grandmaster clock configuration (<literal>PtpConfigGmWpc.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ptp.openshift.io/v1
kind: PtpConfig
metadata:
  name: grandmaster
  namespace: openshift-ptp
  annotations: {}
spec:
  profile:
    - name: "grandmaster"
      ptp4lOpts: "-2 --summary_interval -4"
      phc2sysOpts: -r -u 0 -m -O -37 -N 8 -R 16 -s $iface_master -n 24
      ptpSchedulingPolicy: SCHED_FIFO
      ptpSchedulingPriority: 10
      ptpSettings:
        logReduce: "true"
      plugins:
        e810:
          enableDefaultConfig: false
          settings:
            LocalMaxHoldoverOffSet: 1500
            LocalHoldoverTimeout: 14400
            MaxInSpecOffset: 100
          pins: $e810_pins
          #  "$iface_master":
          #    "U.FL2": "0 2"
          #    "U.FL1": "0 1"
          #    "SMA2": "0 2"
          #    "SMA1": "0 1"
          ublxCmds:
            - args: #ubxtool -P 29.20 -z CFG-HW-ANT_CFG_VOLTCTRL,1
                - "-P"
                - "29.20"
                - "-z"
                - "CFG-HW-ANT_CFG_VOLTCTRL,1"
              reportOutput: false
            - args: #ubxtool -P 29.20 -e GPS
                - "-P"
                - "29.20"
                - "-e"
                - "GPS"
              reportOutput: false
            - args: #ubxtool -P 29.20 -d Galileo
                - "-P"
                - "29.20"
                - "-d"
                - "Galileo"
              reportOutput: false
            - args: #ubxtool -P 29.20 -d GLONASS
                - "-P"
                - "29.20"
                - "-d"
                - "GLONASS"
              reportOutput: false
            - args: #ubxtool -P 29.20 -d BeiDou
                - "-P"
                - "29.20"
                - "-d"
                - "BeiDou"
              reportOutput: false
            - args: #ubxtool -P 29.20 -d SBAS
                - "-P"
                - "29.20"
                - "-d"
                - "SBAS"
              reportOutput: false
            - args: #ubxtool -P 29.20 -t -w 5 -v 1 -e SURVEYIN,600,50000
                - "-P"
                - "29.20"
                - "-t"
                - "-w"
                - "5"
                - "-v"
                - "1"
                - "-e"
                - "SURVEYIN,600,50000"
              reportOutput: true
            - args: #ubxtool -P 29.20 -p MON-HW
                - "-P"
                - "29.20"
                - "-p"
                - "MON-HW"
              reportOutput: true
      ts2phcOpts: " "
      ts2phcConf: |
        [nmea]
        ts2phc.master 1
        [global]
        use_syslog  0
        verbose 1
        logging_level 7
        ts2phc.pulsewidth 100000000
        #GNSS module s /dev/ttyGNSS* -al use _0
        #cat /dev/ttyGNSS_1700_0 to find available serial port
        #example value of gnss_serialport is /dev/ttyGNSS_1700_0
        ts2phc.nmea_serialport $gnss_serialport
        leapfile  /usr/share/zoneinfo/leap-seconds.list
        [$iface_master]
        ts2phc.extts_polarity rising
        ts2phc.extts_correction 0
      ptp4lConf: |
        [$iface_master]
        masterOnly 1
        [$iface_master_1]
        masterOnly 1
        [$iface_master_2]
        masterOnly 1
        [$iface_master_3]
        masterOnly 1
        [global]
        #
        # Default Data Set
        #
        twoStepFlag 1
        priority1 128
        priority2 128
        domainNumber 24
        #utc_offset 37
        clockClass 6
        clockAccuracy 0x27
        offsetScaledLogVariance 0xFFFF
        free_running 0
        freq_est_interval 1
        dscp_event 0
        dscp_general 0
        dataset_comparison G.8275.x
        G.8275.defaultDS.localPriority 128
        #
        # Port Data Set
        #
        logAnnounceInterval -3
        logSyncInterval -4
        logMinDelayReqInterval -4
        logMinPdelayReqInterval 0
        announceReceiptTimeout 3
        syncReceiptTimeout 0
        delayAsymmetry 0
        fault_reset_interval -4
        neighborPropDelayThresh 20000000
        masterOnly 0
        G.8275.portDS.localPriority 128
        #
        # Run time options
        #
        assume_two_step 0
        logging_level 6
        path_trace_enabled 0
        follow_up_info 0
        hybrid_e2e 0
        inhibit_multicast_service 0
        net_sync_monitor 0
        tc_spanning_tree 0
        tx_timestamp_timeout 50
        unicast_listen 0
        unicast_master_table 0
        unicast_req_duration 3600
        use_syslog 1
        verbose 0
        summary_interval -4
        kernel_leap 1
        check_fup_sync 0
        clock_class_threshold 7
        #
        # Servo Options
        #
        pi_proportional_const 0.0
        pi_integral_const 0.0
        pi_proportional_scale 0.0
        pi_proportional_exponent -0.3
        pi_proportional_norm_max 0.7
        pi_integral_scale 0.0
        pi_integral_exponent 0.4
        pi_integral_norm_max 0.3
        step_threshold 2.0
        first_step_threshold 0.00002
        clock_servo pi
        sanity_freq_limit  200000000
        ntpshm_segment 0
        #
        # Transport options
        #
        transportSpecific 0x0
        ptp_dst_mac 01:1B:19:00:00:00
        p2p_dst_mac 01:80:C2:00:00:0E
        udp_ttl 1
        udp6_scope 0x0E
        uds_address /var/run/ptp4l
        #
        # Default interface options
        #
        clock_type BC
        network_transport L2
        delay_mechanism E2E
        time_stamping hardware
        tsproc_mode filter
        delay_filter moving_median
        delay_filter_length 10
        egressLatency 0
        ingressLatency 0
        boundary_clock_jbod 0
        #
        # Clock description
        #
        productDescription ;;
        revisionData ;;
        manufacturerIdentity 00:00:00
        userDescription ;
        timeSource 0x20
  recommend:
    - profile: "grandmaster"
      priority: 4
      match:
        - nodeLabel: "node-role.kubernetes.io/$mcp"</programlisting>
</para>
</formalpara>
<simpara>The following optional <literal>PtpOperatorConfig</literal> CR configures PTP events reporting for the node.</simpara>
<formalpara>
<title>Recommended PTP events configuration (<literal>PtpOperatorConfigForEvent.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ptp.openshift.io/v1
kind: PtpOperatorConfig
metadata:
  name: default
  namespace: openshift-ptp
  annotations: {}
spec:
  daemonNodeSelector:
    node-role.kubernetes.io/$mcp: ""
  ptpEventConfig:
    enableEventPublisher: true
    transportHost: "http://ptp-event-publisher-service-NODE_NAME.openshift-ptp.svc.cluster.local:9043"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-tuning-the-performance-patch_sno-configure-for-vdu">
<title>Extended Tuned profile</title>
<simpara>Single-node OpenShift clusters that run DU workloads require additional performance tuning configurations necessary for high-performance workloads. The following example <literal>Tuned</literal> CR extends the <literal>Tuned</literal> profile:</simpara>
<formalpara>
<title>Recommended extended <literal>Tuned</literal> profile configuration (<literal>TunedPerformancePatch.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: performance-patch
  namespace: openshift-cluster-node-tuning-operator
  annotations: {}
spec:
  profile:
    - name: performance-patch
      # Please note:
      # - The 'include' line must match the associated PerformanceProfile name, following below pattern
      #   include=openshift-node-performance-${PerformanceProfile.metadata.name}
      # - When using the standard (non-realtime) kernel, remove the kernel.timer_migration override from
      #   the [sysctl] section and remove the entire section if it is empty.
      data: |
        [main]
        summary=Configuration changes profile inherited from performance created tuned
        include=openshift-node-performance-openshift-node-performance-profile
        [sysctl]
        kernel.timer_migration=1
        [scheduler]
        group.ice-ptp=0:f:10:*:ice-ptp.*
        group.ice-gnss=0:f:10:*:ice-gnss.*
        [service]
        service.stalld=start,enable
        service.chronyd=stop,disable
  recommend:
    - machineConfigLabels:
        machineconfiguration.openshift.io/role: "$mcp"
      priority: 19
      profile: performance-patch</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>Tuned</literal> CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">Tuned CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.profile.data</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>The <literal>include</literal> line that you set in <literal>spec.profile.data</literal> must match the associated <literal>PerformanceProfile</literal> CR name.
For example, <literal>include=openshift-node-performance-${PerformanceProfile.metadata.name}</literal>.</simpara>
</listitem>
<listitem>
<simpara>When using the non-realtime kernel, remove the <literal>timer_migration override</literal> line from the <literal>[sysctl]</literal> section.</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ztp-sno-du-configuring-sriov_sno-configure-for-vdu">
<title>SR-IOV</title>
<simpara>Single root I/O virtualization (SR-IOV) is commonly used to enable fronthaul and midhaul networks. The following YAML example configures SR-IOV for a single-node OpenShift cluster.</simpara>
<note>
<simpara>The configuration of the <literal>SriovNetwork</literal> CR will vary depending on your specific network and infrastructure requirements.</simpara>
</note>
<formalpara>
<title>Recommended <literal>SriovOperatorConfig</literal> CR configuration (<literal>SriovOperatorConfig.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: sriovnetwork.openshift.io/v1
kind: SriovOperatorConfig
metadata:
  name: default
  namespace: openshift-sriov-network-operator
  annotations: {}
spec:
  configDaemonNodeSelector:
    "node-role.kubernetes.io/$mcp": ""
  # Injector and OperatorWebhook pods can be disabled (set to "false") below
  # to reduce the number of management pods. It is recommended to start with the 
  # webhook and injector pods enabled, and only disable them after verifying the
  # correctness of user manifests.
  #   If the injector is disabled, containers using sr-iov resources must explicitly assign
  #   them in the  "requests"/"limits" section of the container spec, for example:
  #    containers:
  #    - name: my-sriov-workload-container
  #      resources:
  #        limits:
  #          openshift.io/&lt;resource_name&gt;:  "1"
  #        requests:
  #          openshift.io/&lt;resource_name&gt;:  "1"
  enableInjector: true
  enableOperatorWebhook: true
  logLevel: 0</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>SriovOperatorConfig</literal> CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">SriovOperatorConfig CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.enableInjector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable <literal>Injector</literal> pods to reduce the number of management pods.
Start with the <literal>Injector</literal> pods enabled, and only disable them after verifying the user manifests.
If the injector is disabled, containers that use SR-IOV resources must explicitly assign them in the <literal>requests</literal> and <literal>limits</literal> section of the container spec.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
- name: my-sriov-workload-container
  resources:
    limits:
      openshift.io/&lt;resource_name&gt;:  "1"
    requests:
      openshift.io/&lt;resource_name&gt;:  "1"</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.enableOperatorWebhook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable <literal>OperatorWebhook</literal> pods to reduce the number of management pods. Start with the <literal>OperatorWebhook</literal> pods enabled, and only disable them after verifying the user manifests.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Recommended <literal>SriovNetwork</literal> configuration (<literal>SriovNetwork.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: sriovnetwork.openshift.io/v1
kind: SriovNetwork
metadata:
  name: ""
  namespace: openshift-sriov-network-operator
  annotations: {}
spec:
  #  resourceName: ""
  networkNamespace: openshift-sriov-network-operator
#  vlan: ""
#  spoofChk: ""
#  ipam: ""
#  linkState: ""
#  maxTxRate: ""
#  minTxRate: ""
#  vlanQoS: ""
#  trust: ""
#  capabilities: ""</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>SriovNetwork</literal> CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">SriovNetwork CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.vlan</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure <literal>vlan</literal> with the VLAN for the midhaul network.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Recommended <literal>SriovNetworkNodePolicy</literal> CR configuration (<literal>SriovNetworkNodePolicy.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: sriovnetwork.openshift.io/v1
kind: SriovNetworkNodePolicy
metadata:
  name: $name
  namespace: openshift-sriov-network-operator
  annotations: {}
spec:
  # The attributes for Mellanox/Intel based NICs as below.
  #     deviceType: netdevice/vfio-pci
  #     isRdma: true/false
  deviceType: $deviceType
  isRdma: $isRdma
  nicSelector:
    # The exact physical function name must match the hardware used
    pfNames: [$pfNames]
  nodeSelector:
    node-role.kubernetes.io/$mcp: ""
  numVfs: $numVfs
  priority: $priority
  resourceName: $resourceName</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>SriovNetworkPolicy</literal> CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">SriovNetworkNodePolicy CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.deviceType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure <literal>deviceType</literal> as <literal>vfio-pci</literal> or <literal>netdevice</literal>.
For Mellanox NICs, set <literal>deviceType: netdevice</literal>, and <literal>isRdma: true</literal>.
For Intel based NICs, set <literal>deviceType: vfio-pci</literal> and <literal>isRdma: false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.nicSelector.pfNames</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the interface connected to the fronthaul network.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.numVfs</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the number of VFs for the fronthaul network.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.nicSelector.pfNames</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The exact name of physical function must match the hardware.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Recommended SR-IOV kernel configurations (<literal>07-sriov-related-kernel-args-master.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: master
  name: 07-sriov-related-kernel-args-master
spec:
  config:
    ignition:
      version: 3.2.0
  kernelArguments:
    - intel_iommu=on
    - iommu=pt</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-removing-the-console-operator_sno-configure-for-vdu">
<title>Console Operator</title>
<simpara>Use the cluster capabilities feature to prevent the Console Operator from being installed.
When the node is centrally managed it is not needed.
Removing the Operator provides additional space and capacity for application workloads.</simpara>
<simpara>To disable the Console Operator during the installation of the managed cluster, set the following in the <literal>spec.clusters.0.installConfigOverrides</literal> field of the <literal>SiteConfig</literal> custom resource (CR):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">installConfigOverrides:  "{\"capabilities\":{\"baselineCapabilitySet\": \"None\" }}"</programlisting>
</section>
<section xml:id="ztp-sno-du-reducing-resource-usage-with-cluster-monitoring_sno-configure-for-vdu">
<title>Alertmanager</title>
<simpara>Single-node OpenShift clusters that run DU workloads require reduced CPU resources consumed by the OpenShift Container Platform monitoring components. The following <literal>ConfigMap</literal> custom resource (CR) disables Alertmanager.</simpara>
<formalpara>
<title>Recommended cluster monitoring configuration (<literal>ReduceMonitoringFootprint.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-monitoring-config
  namespace: openshift-monitoring
  annotations: {}
data:
  config.yaml: |
    grafana:
      enabled: false
    alertmanagerMain:
      enabled: false
    telemeterClient:
      enabled: false
    prometheusK8s:
       retention: 24h</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-sno-du-reducing-resource-usage-with-olm-pprof_sno-configure-for-vdu">
<title>Operator Lifecycle Manager</title>
<simpara>Single-node OpenShift clusters that run distributed unit workloads require consistent access to CPU resources. Operator Lifecycle Manager (OLM) collects performance data from Operators at regular intervals, resulting in an increase in CPU utilisation. The following <literal>ConfigMap</literal> custom resource (CR) disables the collection of Operator performance data by OLM.</simpara>
<formalpara>
<title>Recommended cluster OLM configuration (<literal>ReduceOLMFootprint.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: collect-profiles-config
  namespace: openshift-operator-lifecycle-manager
data:
  pprof-config.yaml: |
    disabled: True</programlisting>
</para>
</formalpara>
</section>
<section xml:id="lvms-configuring-lvms-on-sno_sno-configure-for-vdu">
<title>LVM Storage</title>
<simpara>You can dynamically provision local storage on single-node OpenShift clusters with Logical volume manager storage (LVM Storage).</simpara>
<note>
<simpara>The recommended storage solution for single-node OpenShift is the Local Storage Operator. Alternatively, you can use LVM Storage but it requires additional CPU resources to be allocated.</simpara>
</note>
<simpara>The following YAML example configures the storage of the node to be available to OpenShift Container Platform applications.</simpara>
<formalpara>
<title>Recommended <literal>LVMCluster</literal> configuration (<literal>StorageLVMCluster.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: odf-lvmcluster
  namespace: openshift-storage
spec:
  storage:
    deviceClasses:
    - name: vg1
      deviceSelector:
        paths:
        - /usr/disk/by-path/pci-0000:11:00.0-nvme-1
      thinPoolConfig:
        name: thin-pool-1
        overprovisionRatio: 10
        sizePercent: 90</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>LVMCluster</literal> CR options for single-node OpenShift clusters</title>
<?dbhtml table-width="90%"?>
<?dbfo table-width="90%"?>
<?dblatex table-width="90%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="191.25*"/>
<colspec colname="col_2" colwidth="191.25*"/>
<thead>
<row>
<entry align="left" valign="top">LVMCluster CR field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>deviceSelector.paths</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the disks used for LVM storage. If no disks are specified, the LVM Storage uses all the unused disks in the specified thin pool.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ztp-sno-du-disabling-network-diagnostics_sno-configure-for-vdu">
<title>Network diagnostics</title>
<simpara>Single-node OpenShift clusters that run DU workloads require less inter-pod network connectivity checks to reduce the additional load created by these pods. The following custom resource (CR) disables these checks.</simpara>
<formalpara>
<title>Recommended network diagnostics configuration (<literal>DisableSnoNetworkDiag.yaml</literal>)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: Network
metadata:
  name: cluster
  annotations: {}
spec:
  disableNetworkDiagnostics: true</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-deploying-far-edge-sites">Deploying far edge sites using ZTP</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ztp-vdu-configuration-reference">
<title>Validating single-node OpenShift cluster tuning for vDU application workloads</title>
<simpara>Before you can deploy virtual distributed unit (vDU) applications, you need to tune and configure the cluster host firmware and various other cluster configuration settings. Use the following information to validate the cluster configuration to support vDU workloads.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about single-node OpenShift clusters tuned for vDU application deployments, see <link linkend="sno-configure-for-vdu">Reference configuration for deploying vDUs on single-node OpenShift</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-du-firmware-config-reference_vdu-config-ref">
<title>Recommended firmware configuration for vDU cluster hosts</title>
<simpara>Use the following table as the basis to configure the cluster host firmware for vDU applications running on OpenShift Container Platform 4.14.</simpara>
<note>
<simpara>The following table is a general recommendation for vDU cluster host firmware configuration. Exact firmware settings will depend on your requirements and specific hardware platform. Automatic setting of firmware is not handled by the zero touch provisioning pipeline.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>Recommended cluster host firmware settings</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">Firmware setting</entry>
<entry align="left" valign="top">Configuration</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>HyperTransport (HT)</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>HyperTransport (HT) bus is a bus technology developed by AMD. HT provides a high-speed link between the components in the host memory and other system peripherals.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UEFI</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enable booting from UEFI for the vDU host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CPU Power and Performance Policy</simpara></entry>
<entry align="left" valign="top"><simpara>Performance</simpara></entry>
<entry align="left" valign="top"><simpara>Set CPU Power and Performance Policy to optimize the system for performance over energy efficiency.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Uncore Frequency Scaling</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disable Uncore Frequency Scaling to prevent the voltage and frequency of non-core parts of the CPU from being set independently.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Uncore Frequency</simpara></entry>
<entry align="left" valign="top"><simpara>Maximum</simpara></entry>
<entry align="left" valign="top"><simpara>Sets the non-core parts of the CPU such as cache and memory controller to their maximum possible frequency of operation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Performance P-limit</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disable Performance P-limit to prevent the Uncore frequency coordination of processors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enhanced Intel&#174; SpeedStep Tech</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Enhanced Intel SpeedStep to allow the system to dynamically adjust processor voltage and core frequency that decreases power consumption and heat production in the host.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Intel&#174; Turbo Boost Technology</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Turbo Boost Technology for Intel-based CPUs to automatically allow processor cores to run faster than the rated operating frequency if they are operating below power, current, and temperature specification limits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Intel Configurable TDP</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enables Thermal Design Power (TDP) for the CPU.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Configurable TDP Level</simpara></entry>
<entry align="left" valign="top"><simpara>Level 2</simpara></entry>
<entry align="left" valign="top"><simpara>TDP level sets the CPU power consumption required for a particular performance rating. TDP level 2 sets the CPU to the most stable performance level at the cost of power consumption.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Energy Efficient Turbo</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disable Energy Efficient Turbo to prevent the processor from using an energy-efficiency based policy.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hardware P-States</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled or Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enable OS-controlled P-States to allow power saving configurations. Disable <literal>P-states</literal> (performance states) to optimize the operating system and CPU for performance over power consumption.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Package C-State</simpara></entry>
<entry align="left" valign="top"><simpara>C0/C1 state</simpara></entry>
<entry align="left" valign="top"><simpara>Use C0 or C1 states to set the processor to a fully active state (C0) or to stop CPU internal clocks running in software (C1).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C1E</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>CPU Enhanced Halt (C1E) is a power saving feature in Intel chips. Disabling C1E prevents the operating system from sending a halt command to the CPU when inactive.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Processor C6</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>C6 power-saving is a CPU feature that automatically disables idle CPU cores and cache. Disabling C6 improves system performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sub-NUMA Clustering</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Sub-NUMA clustering divides the processor cores, cache, and memory into multiple NUMA domains. Disabling this option can increase performance for latency-sensitive workloads.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Enable global SR-IOV and VT-d settings in the firmware for the host. These settings are relevant to bare-metal environments.</simpara>
</note>
<note>
<simpara>Enable both <literal>C-states</literal> and OS-controlled <literal>P-States</literal> to allow per pod power management.</simpara>
</note>
</section>
<section xml:id="ztp-du-cluster-config-reference_vdu-config-ref">
<title>Recommended cluster configurations to run vDU applications</title>
<simpara>Clusters running virtualized distributed unit (vDU) applications require a highly tuned and optimized configuration. The following information describes the various elements that you require to support vDU workloads in OpenShift Container Platform 4.14 clusters.</simpara>
<section xml:id="ztp-recommended-cluster-mc-crs_vdu-config-ref">
<title>Recommended cluster MachineConfig CRs for single-node OpenShift clusters</title>
<simpara>Check that the <literal>MachineConfig</literal> custom resources (CRs) that you extract from the <literal>ztp-site-generate</literal> container are applied in the cluster. The CRs can be found in the extracted <literal>out/source-crs/extra-manifest/</literal> folder.</simpara>
<simpara>The following <literal>MachineConfig</literal> CRs from the <literal>ztp-site-generate</literal> container configure the cluster host:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Recommended GitOps ZTP MachineConfig CRs</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">MachineConfig CR</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>01-container-mount-ns-and-kubelet-conf-master.yaml</literal></simpara>
<simpara><literal>01-container-mount-ns-and-kubelet-conf-worker.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures the container mount namespace and kubelet configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>02-workload-partitioning.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures workload partitioning for the cluster. Apply this <literal>MachineConfig</literal> CR when you install the cluster.</simpara>
<note>
<simpara>If you use the <literal>cpuPartitioningMode</literal> field in the <literal>SiteConfig</literal> CR to configure workload partitioning, you do not need to use the <literal>02-workload-partitioning.yaml</literal> CR.
Using the <literal>cpuPartitioningMode</literal> field is a Technology Preview feature in OpenShift Container Platform 4.13.
For more information, see "Workload partitioning in single-node OpenShift with GitOps ZTP".</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>03-sctp-machine-config-master.yaml</literal></simpara>
<simpara><literal>03-sctp-machine-config-worker.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Loads the SCTP kernel module. These <literal>MachineConfig</literal> CRs are optional and can be omitted if you do not require this kernel module.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>04-accelerated-container-startup-master.yaml</literal></simpara>
<simpara><literal>04-accelerated-container-startup-worker.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures accelerated startup for the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>05-kdump-config-master.yaml</literal></simpara>
<simpara><literal>05-kdump-config-worker.yaml</literal></simpara>
<simpara><literal>06-kdump-master.yaml</literal></simpara>
<simpara><literal>06-kdump-worker.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures kdump crash reporting for the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>99-crio-disable-wipe-master.yaml</literal></simpara>
<simpara><literal>99-crio-disable-wipe-worker.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disables the automatic CRI-O cache wipe following cluster reboot.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">Extracting source CRs from the ztp-site-generate container</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-recommended-cluster-operators_vdu-config-ref">
<title>Recommended cluster Operators</title>
<simpara>The following Operators are required for clusters running virtualized distributed unit (vDU) applications and are a part of the baseline reference configuration:</simpara>
<itemizedlist>
<listitem>
<simpara>Node Tuning Operator (NTO). NTO packages functionality that was previously delivered with the Performance Addon Operator, which is now a part of NTO.</simpara>
</listitem>
<listitem>
<simpara>PTP Operator</simpara>
</listitem>
<listitem>
<simpara>SR-IOV Network Operator</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Logging Operator</simpara>
</listitem>
<listitem>
<simpara>Local Storage Operator</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-recommended-cluster-kernel-config_vdu-config-ref">
<title>Recommended cluster kernel configuration</title>
<simpara>Always use the latest supported real-time kernel version in your cluster. Ensure that you apply the following configurations in the cluster:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Ensure that the following <literal>additionalKernelArgs</literal> are set in the cluster performance profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  additionalKernelArgs:
  - "rcupdate.rcu_normal_after_boot=0"
  - "efi=runtime"
  - "module_blacklist=irdma"</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the <literal>performance-patch</literal> profile in the <literal>Tuned</literal> CR configures the correct CPU isolation set that matches the <literal>isolated</literal> CPU set in the related <literal>PerformanceProfile</literal> CR, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  profile:
    - name: performance-patch
      # The 'include' line must match the associated PerformanceProfile name, for example:
      # include=openshift-node-performance-${PerformanceProfile.metadata.name}
      # When using the standard (non-realtime) kernel, remove the kernel.timer_migration override from the [sysctl] section
      data: |
        [main]
        summary=Configuration changes profile inherited from performance created tuned
        include=openshift-node-performance-openshift-node-performance-profile
        [sysctl]
        kernel.timer_migration=1
        [scheduler]
        group.ice-ptp=0:f:10:*:ice-ptp.*
        group.ice-gnss=0:f:10:*:ice-gnss.*
        [service]
        service.stalld=start,enable
        service.chronyd=stop,disable</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-checking-kernel-rt-in-cluster_vdu-config-ref">
<title>Checking the realtime kernel version</title>
<simpara>Always use the latest version of the realtime kernel in your OpenShift Container Platform clusters. If you are unsure about the kernel version that is in use in the cluster, you can compare the current realtime kernel version to the release version with the following procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed <literal>podman</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to get the cluster version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ OCP_VERSION=$(oc get clusterversion version -o jsonpath='{.status.desired.version}{"\n"}')</programlisting>
</listitem>
<listitem>
<simpara>Get the release image SHA number:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ DTK_IMAGE=$(oc adm release info --image-for=driver-toolkit quay.io/openshift-release-dev/ocp-release:$OCP_VERSION-x86_64)</programlisting>
</listitem>
<listitem>
<simpara>Run the release image container and extract the kernel version that is packaged with cluster&#8217;s current release:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --rm $DTK_IMAGE rpm -qa | grep 'kernel-rt-core-' | sed 's#kernel-rt-core-##'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">4.18.0-305.49.1.rt7.121.el8_4.x86_64</programlisting>
</para>
</formalpara>
<simpara>This is the default realtime kernel version that ships with the release.</simpara>
<note>
<simpara>The realtime kernel is denoted by the string <literal>.rt</literal> in the kernel version.</simpara>
</note>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Check that the kernel version listed for the cluster&#8217;s current release matches actual realtime kernel that is running in the cluster. Run the following commands to check the running realtime kernel version:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Open a remote shell connection to the cluster node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check the realtime kernel version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# uname -r</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">4.18.0-305.49.1.rt7.121.el8_4.x86_64</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-checking-du-cluster-config_vdu-config-ref">
<title>Checking that the recommended cluster configurations are applied</title>
<simpara>You can check that clusters are running the correct configuration. The following procedure describes how to check the various configurations that you require to deploy a DU application in OpenShift Container Platform 4.14 clusters.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have deployed a cluster and tuned it for vDU workloads.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check that the default OperatorHub sources are disabled. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operatorhub cluster -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
    disableAllDefaultSources: true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that all required <literal>CatalogSource</literal> resources are annotated for workload partitioning (<literal>PreferredDuringScheduling</literal>) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsource -A -o jsonpath='{range .items[*]}{.metadata.name}{" -- "}{.metadata.annotations.target\.workload\.openshift\.io/management}{"\n"}{end}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">certified-operators -- {"effect": "PreferredDuringScheduling"}
community-operators -- {"effect": "PreferredDuringScheduling"}
ran-operators <co xml:id="CO66-1"/>
redhat-marketplace -- {"effect": "PreferredDuringScheduling"}
redhat-operators -- {"effect": "PreferredDuringScheduling"}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1">
<para><literal>CatalogSource</literal> resources that are not annotated are also returned. In this example, the <literal>ran-operators</literal> <literal>CatalogSource</literal> resource is not annotated and does not have the <literal>PreferredDuringScheduling</literal> annotation.</para>
</callout>
</calloutlist>
<note>
<simpara>In a properly configured vDU cluster, only a single annotated catalog source is listed.</simpara>
</note>
</listitem>
<listitem>
<simpara>Check that all applicable OpenShift Container Platform Operator namespaces are annotated for workload partitioning. This includes all Operators installed with core OpenShift Container Platform and the set of additional Operators included in the reference DU tuning configuration. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get namespaces -A -o jsonpath='{range .items[*]}{.metadata.name}{" -- "}{.metadata.annotations.workload\.openshift\.io/allowed}{"\n"}{end}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">default --
openshift-apiserver -- management
openshift-apiserver-operator -- management
openshift-authentication -- management
openshift-authentication-operator -- management</programlisting>
</para>
</formalpara>
<important>
<simpara>Additional Operators must not be annotated for workload partitioning. In the output from the previous command, additional Operators should be listed without any value on the right side of the <literal>--</literal> separator.</simpara>
</important>
</listitem>
<listitem>
<simpara>Check that the <literal>ClusterLogging</literal> configuration is correct. Run the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Validate that the appropriate input and output logs are configured:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-logging ClusterLogForwarder instance -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: ClusterLogForwarder
metadata:
  creationTimestamp: "2022-07-19T21:51:41Z"
  generation: 1
  name: instance
  namespace: openshift-logging
  resourceVersion: "1030342"
  uid: 8c1a842d-80c5-447a-9150-40350bdf40f0
spec:
  inputs:
  - infrastructure: {}
    name: infra-logs
  outputs:
  - name: kafka-open
    type: kafka
    url: tcp://10.46.55.190:9092/test
  pipelines:
  - inputRefs:
    - audit
    name: audit-logs
    outputRefs:
    - kafka-open
  - inputRefs:
    - infrastructure
    name: infrastructure-logs
    outputRefs:
    - kafka-open
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the curation schedule is appropriate for your application:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-logging clusterloggings.logging.openshift.io instance -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: ClusterLogging
metadata:
  creationTimestamp: "2022-07-07T18:22:56Z"
  generation: 1
  name: instance
  namespace: openshift-logging
  resourceVersion: "235796"
  uid: ef67b9b8-0e65-4a10-88ff-ec06922ea796
spec:
  collection:
    logs:
      fluentd: {}
      type: fluentd
  curation:
    curator:
      schedule: 30 3 * * *
    type: curator
  managementState: Managed
...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the web console is disabled (<literal>managementState: Removed</literal>) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get consoles.operator.openshift.io cluster -o jsonpath="{ .spec.managementState }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Removed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that <literal>chronyd</literal> is disabled on the cluster node by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
<simpara>Check the status of <literal>chronyd</literal> on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# systemctl status chronyd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"> chronyd.service - NTP client/server
    Loaded: loaded (/usr/lib/systemd/system/chronyd.service; disabled; vendor preset: enabled)
    Active: inactive (dead)
      Docs: man:chronyd(8)
            man:chrony.conf(5)</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the PTP interface is successfully synchronized to the primary clock using a remote shell connection to the <literal>linuxptp-daemon</literal> container and the PTP Management Client (<literal>pmc</literal>) tool:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the <literal>$PTP_POD_NAME</literal> variable with the name of the <literal>linuxptp-daemon</literal> pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ PTP_POD_NAME=$(oc get pods -n openshift-ptp -l app=linuxptp-daemon -o name)</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to check the sync status of the PTP device:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-ptp rsh -c linuxptp-daemon-container ${PTP_POD_NAME} pmc -u -f /var/run/ptp4l.0.config -b 0 'GET PORT_DATA_SET'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">sending: GET PORT_DATA_SET
  3cecef.fffe.7a7020-1 seq 0 RESPONSE MANAGEMENT PORT_DATA_SET
    portIdentity            3cecef.fffe.7a7020-1
    portState               SLAVE
    logMinDelayReqInterval  -4
    peerMeanPathDelay       0
    logAnnounceInterval     1
    announceReceiptTimeout  3
    logSyncInterval         0
    delayMechanism          1
    logMinPdelayReqInterval 0
    versionNumber           2
  3cecef.fffe.7a7020-2 seq 0 RESPONSE MANAGEMENT PORT_DATA_SET
    portIdentity            3cecef.fffe.7a7020-2
    portState               LISTENING
    logMinDelayReqInterval  0
    peerMeanPathDelay       0
    logAnnounceInterval     1
    announceReceiptTimeout  3
    logSyncInterval         0
    delayMechanism          1
    logMinPdelayReqInterval 0
    versionNumber           2</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following <literal>pmc</literal> command to check the PTP clock status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-ptp rsh -c linuxptp-daemon-container ${PTP_POD_NAME} pmc -u -f /var/run/ptp4l.0.config -b 0 'GET TIME_STATUS_NP'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">sending: GET TIME_STATUS_NP
  3cecef.fffe.7a7020-0 seq 0 RESPONSE MANAGEMENT TIME_STATUS_NP
    master_offset              10 <co xml:id="CO67-1"/>
    ingress_time               1657275432697400530
    cumulativeScaledRateOffset +0.000000000
    scaledLastGmPhaseChange    0
    gmTimeBaseIndicator        0
    lastGmPhaseChange          0x0000'0000000000000000.0000
    gmPresent                  true <co xml:id="CO67-2"/>
    gmIdentity                 3c2c30.ffff.670e00</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO67-1">
<para><literal>master_offset</literal> should be between -100 and 100 ns.</para>
</callout>
<callout arearefs="CO67-2">
<para>Indicates that the PTP clock is synchronized to a master, and the local clock is not the grandmaster clock.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check that the expected <literal>master offset</literal> value corresponding to the value in <literal>/var/run/ptp4l.0.config</literal> is found in the <literal>linuxptp-daemon-container</literal> log:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs $PTP_POD_NAME -n openshift-ptp -c linuxptp-daemon-container</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">phc2sys[56020.341]: [ptp4l.1.config] CLOCK_REALTIME phc offset  -1731092 s2 freq -1546242 delay    497
ptp4l[56020.390]: [ptp4l.1.config] master offset         -2 s2 freq   -5863 path delay       541
ptp4l[56020.390]: [ptp4l.0.config] master offset         -8 s2 freq  -10699 path delay       533</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the SR-IOV configuration is correct by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check that the <literal>disableDrain</literal> value in the <literal>SriovOperatorConfig</literal> resource is set to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sriovoperatorconfig -n openshift-sriov-network-operator default -o jsonpath="{.spec.disableDrain}{'\n'}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the <literal>SriovNetworkNodeState</literal> sync status is <literal>Succeeded</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get SriovNetworkNodeStates -n openshift-sriov-network-operator -o jsonpath="{.items[*].status.syncStatus}{'\n'}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the expected number and configuration of virtual functions (<literal>Vfs</literal>) under each interface configured for SR-IOV is present and correct in the <literal>.status.interfaces</literal> field. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get SriovNetworkNodeStates -n openshift-sriov-network-operator -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
items:
- apiVersion: sriovnetwork.openshift.io/v1
  kind: SriovNetworkNodeState
...
  status:
    interfaces:
    ...
    - Vfs:
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.0
        vendor: "8086"
        vfID: 0
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.1
        vendor: "8086"
        vfID: 1
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.2
        vendor: "8086"
        vfID: 2
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.3
        vendor: "8086"
        vfID: 3
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.4
        vendor: "8086"
        vfID: 4
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.5
        vendor: "8086"
        vfID: 5
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.6
        vendor: "8086"
        vfID: 6
      - deviceID: 154c
        driver: vfio-pci
        pciAddress: 0000:3b:0a.7
        vendor: "8086"
        vfID: 7</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the cluster performance profile is correct. The <literal>cpu</literal> and <literal>hugepages</literal> sections will vary depending on your hardware configuration. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get PerformanceProfile openshift-node-performance-profile -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  creationTimestamp: "2022-07-19T21:51:31Z"
  finalizers:
  - foreground-deletion
  generation: 1
  name: openshift-node-performance-profile
  resourceVersion: "33558"
  uid: 217958c0-9122-4c62-9d4d-fdc27c31118c
spec:
  additionalKernelArgs:
  - idle=poll
  - rcupdate.rcu_normal_after_boot=0
  - efi=runtime
  cpu:
    isolated: 2-51,54-103
    reserved: 0-1,52-53
  hugepages:
    defaultHugepagesSize: 1G
    pages:
    - count: 32
      size: 1G
  machineConfigPoolSelector:
    pools.operator.machineconfiguration.openshift.io/master: ""
  net:
    userLevelNetworking: true
  nodeSelector:
    node-role.kubernetes.io/master: ""
  numa:
    topologyPolicy: restricted
  realTimeKernel:
    enabled: true
status:
  conditions:
  - lastHeartbeatTime: "2022-07-19T21:51:31Z"
    lastTransitionTime: "2022-07-19T21:51:31Z"
    status: "True"
    type: Available
  - lastHeartbeatTime: "2022-07-19T21:51:31Z"
    lastTransitionTime: "2022-07-19T21:51:31Z"
    status: "True"
    type: Upgradeable
  - lastHeartbeatTime: "2022-07-19T21:51:31Z"
    lastTransitionTime: "2022-07-19T21:51:31Z"
    status: "False"
    type: Progressing
  - lastHeartbeatTime: "2022-07-19T21:51:31Z"
    lastTransitionTime: "2022-07-19T21:51:31Z"
    status: "False"
    type: Degraded
  runtimeClass: performance-openshift-node-performance-profile
  tuned: openshift-cluster-node-tuning-operator/openshift-node-performance-openshift-node-performance-profile</programlisting>
</para>
</formalpara>
<note>
<simpara>CPU settings are dependent on the number of cores available on the server and should align with workload partitioning settings. <literal>hugepages</literal> configuration is server and application dependent.</simpara>
</note>
</listitem>
<listitem>
<simpara>Check that the <literal>PerformanceProfile</literal> was successfully applied to the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get performanceprofile openshift-node-performance-profile -o jsonpath="{range .status.conditions[*]}{ @.type }{' -- '}{@.status}{'\n'}{end}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Available -- True
Upgradeable -- True
Progressing -- False
Degraded -- False</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>Tuned</literal> performance patch settings by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get tuneds.tuned.openshift.io -n openshift-cluster-node-tuning-operator performance-patch -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  creationTimestamp: "2022-07-18T10:33:52Z"
  generation: 1
  name: performance-patch
  namespace: openshift-cluster-node-tuning-operator
  resourceVersion: "34024"
  uid: f9799811-f744-4179-bf00-32d4436c08fd
spec:
  profile:
  - data: |
      [main]
      summary=Configuration changes profile inherited from performance created tuned
      include=openshift-node-performance-openshift-node-performance-profile
      [bootloader]
      cmdline_crash=nohz_full=2-23,26-47 <co xml:id="CO68-1"/>
      [sysctl]
      kernel.timer_migration=1
      [scheduler]
      group.ice-ptp=0:f:10:*:ice-ptp.*
      [service]
      service.stalld=start,enable
      service.chronyd=stop,disable
    name: performance-patch
  recommend:
  - machineConfigLabels:
      machineconfiguration.openshift.io/role: master
    priority: 19
    profile: performance-patch</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO68-1">
<para>The cpu list in <literal>cmdline=nohz_full=</literal> will vary based on your hardware configuration.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check that cluster networking diagnostics are disabled by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get networks.operator.openshift.io cluster -o jsonpath='{.spec.disableNetworkDiagnostics}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the <literal>Kubelet</literal> housekeeping interval is tuned to slower rate. This is set in the <literal>containerMountNS</literal> machine config. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfig container-mount-namespace-and-kubelet-conf-master | grep OPENSHIFT_MAX_HOUSEKEEPING_INTERVAL_DURATION</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Environment="OPENSHIFT_MAX_HOUSEKEEPING_INTERVAL_DURATION=60s"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that Grafana and <literal>alertManagerMain</literal> are disabled and that the Prometheus retention period is set to 24h by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmap cluster-monitoring-config -n openshift-monitoring -o jsonpath="{ .data.config\.yaml }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">grafana:
  enabled: false
alertmanagerMain:
  enabled: false
prometheusK8s:
   retention: 24h</programlisting>
</para>
</formalpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Use the following commands to verify that Grafana and <literal>alertManagerMain</literal> routes are not found in the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route -n openshift-monitoring alertmanager-main</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route -n openshift-monitoring grafana</programlisting>
<simpara>Both queries should return <literal>Error from server (NotFound)</literal> messages.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that there is a minimum of 4 CPUs allocated as <literal>reserved</literal> for each of the <literal>PerformanceProfile</literal>, <literal>Tuned</literal> performance-patch, workload partitioning, and kernel command line arguments by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get performanceprofile -o jsonpath="{ .items[0].spec.cpu.reserved }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">0-3</programlisting>
</para>
</formalpara>
<note>
<simpara>Depending on your workload requirements, you might require additional reserved CPUs to be allocated.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-advanced-install-ztp">
<title>Advanced managed cluster configuration with SiteConfig resources</title>
<simpara>You can use <literal>SiteConfig</literal> custom resources (CRs) to deploy custom functionality and configurations in your managed clusters at installation time.</simpara>
<section xml:id="ztp-customizing-the-install-extra-manifests_ztp-advanced-install-ztp">
<title>Customizing extra installation manifests in the GitOps ZTP pipeline</title>
<simpara>You can define a set of extra manifests for inclusion in the installation phase of the GitOps Zero Touch Provisioning (ZTP) pipeline. These manifests are linked to the <literal>SiteConfig</literal> custom resources (CRs) and are applied to the cluster during installation. Including <literal>MachineConfig</literal> CRs at install time makes the installation process more efficient.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for the Argo CD application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a set of extra manifest CRs that the GitOps ZTP pipeline uses to customize the cluster installs.</simpara>
</listitem>
<listitem>
<simpara>In your custom <literal>/siteconfig</literal> directory, create a subdirectory <literal>/custom-manifest</literal> for your extra manifests. The following example illustrates a sample <literal>/siteconfig</literal> with <literal>/custom-manifest</literal> folder:</simpara>
<programlisting language="text" linenumbering="unnumbered">siteconfig
 site1-sno-du.yaml
 site2-standard-du.yaml
 extra-manifest/
 custom-manifest
     01-example-machine-config.yaml</programlisting>
<note>
<simpara>The subdirectory names <literal>/custom-manifest</literal> and <literal>/extra-manifest</literal> used throughout are example names only. There is no requirement to use these names and no restriction on how you name these subdirectories.
In this example <literal>/extra-manifest</literal> refers to the Git subdirectory that stores the contents of <literal>/extra-manifest</literal> from the <literal>ztp-site-generate</literal> container.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add your custom extra manifest CRs to the <literal>siteconfig/custom-manifest</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>In your <literal>SiteConfig</literal> CR, enter the directory name in the <literal>extraManifests.searchPaths</literal> field, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">clusters:
- clusterName: "example-sno"
  networkType: "OVNKubernetes"
  extraManifests:
    searchPaths:
      - extra-manifest/ <co xml:id="CO69-1"/>
      - custom-manifest/ <co xml:id="CO69-2"/></programlisting>
<calloutlist>
<callout arearefs="CO69-1">
<para>Folder for manifests copied from the <literal>ztp-site-generate</literal> container.</para>
</callout>
<callout arearefs="CO69-2">
<para>Folder for custom manifests.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the <literal>SiteConfig</literal>, <literal>/extra-manifest</literal>, and <literal>/custom-manifest</literal> CRs, and push them to the site configuration repo.</simpara>
</listitem>
</orderedlist>
<simpara>During cluster provisioning, the GitOps ZTP pipeline appends the CRs in the <literal>/custom-manifest</literal> directory to the default set of extra manifests stored in <literal>extra-manifest/</literal>.</simpara>
<note>
<simpara>As of version 4.14 <literal>extraManifestPath</literal> is subject to a deprecation warning.</simpara>
<simpara>While <literal>extraManifestPath</literal> is still supported, we recommend that you use <literal>extraManifests.searchPaths</literal>.
If you define <literal>extraManifests.searchPaths</literal> in the <literal>SiteConfig</literal> file, the GitOps ZTP pipeline does not fetch manifests from the <literal>ztp-site-generate</literal> container during site installation.</simpara>
<simpara>If you define both <literal>extraManifestPath</literal> and <literal>extraManifests.searchPaths</literal> in the <literal>Siteconfig</literal> CR, the setting defined for <literal>extraManifests.searchPaths</literal> takes precedence.</simpara>
<simpara>It is strongly recommended that you extract the contents of <literal>/extra-manifest</literal> from the <literal>ztp-site-generate</literal> container and push it to the GIT repository.</simpara>
</note>
</section>
<section xml:id="ztp-filtering-ai-crs-using-siteconfig_ztp-advanced-install-ztp">
<title>Filtering custom resources using SiteConfig filters</title>
<simpara>By using filters, you can easily customize <literal>SiteConfig</literal> custom resources (CRs) to include or exclude other CRs for use in the installation phase of the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<simpara>You can specify an <literal>inclusionDefault</literal> value of <literal>include</literal> or <literal>exclude</literal> for the <literal>SiteConfig</literal> CR, along with a list of the specific <literal>extraManifest</literal> RAN CRs that you want to include or exclude. Setting <literal>inclusionDefault</literal> to <literal>include</literal> makes the GitOps ZTP pipeline apply all the files in <literal>/source-crs/extra-manifest</literal> during installation. Setting <literal>inclusionDefault</literal> to <literal>exclude</literal> does the opposite.</simpara>
<simpara>You can exclude individual CRs from the <literal>/source-crs/extra-manifest</literal> folder that are otherwise included by default. The following example configures a custom single-node OpenShift <literal>SiteConfig</literal> CR to exclude the <literal>/source-crs/extra-manifest/03-sctp-machine-config-worker.yaml</literal> CR at installation time.</simpara>
<simpara>Some additional optional filtering scenarios are also described.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You configured the hub cluster for generating the required installation and policy CRs.</simpara>
</listitem>
<listitem>
<simpara>You created a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for the Argo CD application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To prevent the GitOps ZTP pipeline from applying the <literal>03-sctp-machine-config-worker.yaml</literal> CR file, apply the following YAML in the <literal>SiteConfig</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: SiteConfig
metadata:
  name: "site1-sno-du"
  namespace: "site1-sno-du"
spec:
  baseDomain: "example.com"
  pullSecretRef:
    name: "assisted-deployment-pull-secret"
  clusterImageSetNameRef: "openshift-4.14"
  sshPublicKey: "&lt;ssh_public_key&gt;"
  clusters:
- clusterName: "site1-sno-du"
  extraManifests:
    filter:
      exclude:
        - 03-sctp-machine-config-worker.yaml</programlisting>
<simpara>The GitOps ZTP pipeline skips the <literal>03-sctp-machine-config-worker.yaml</literal> CR during installation. All other CRs in <literal>/source-crs/extra-manifest</literal> are applied.</simpara>
</listitem>
<listitem>
<simpara>Save the <literal>SiteConfig</literal> CR and push the changes to the site configuration repository.</simpara>
<simpara>The GitOps ZTP pipeline monitors and adjusts what CRs it applies based on the <literal>SiteConfig</literal> filter instructions.</simpara>
</listitem>
<listitem>
<simpara>Optional: To prevent the GitOps ZTP pipeline from applying all the <literal>/source-crs/extra-manifest</literal> CRs during cluster installation, apply the following YAML in the <literal>SiteConfig</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- clusterName: "site1-sno-du"
  extraManifests:
    filter:
      inclusionDefault: exclude</programlisting>
</listitem>
<listitem>
<simpara>Optional: To exclude all the <literal>/source-crs/extra-manifest</literal> RAN CRs and instead include a custom CR file during installation, edit the custom <literal>SiteConfig</literal> CR to set the custom manifests folder and the <literal>include</literal> file, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">clusters:
- clusterName: "site1-sno-du"
  extraManifestPath: "&lt;custom_manifest_folder&gt;" <co xml:id="CO70-1"/>
  extraManifests:
    filter:
      inclusionDefault: exclude  <co xml:id="CO70-2"/>
      include:
        - custom-sctp-machine-config-worker.yaml</programlisting>
<calloutlist>
<callout arearefs="CO70-1">
<para>Replace <literal>&lt;custom_manifest_folder&gt;</literal> with the name of the folder that contains the custom installation CRs, for example, <literal>user-custom-manifest/</literal>.</para>
</callout>
<callout arearefs="CO70-2">
<para>Set <literal>inclusionDefault</literal> to <literal>exclude</literal> to prevent the GitOps ZTP pipeline from applying the files in <literal>/source-crs/extra-manifest</literal> during installation.</para>
</callout>
</calloutlist>
<simpara>The following example illustrates the custom folder structure:</simpara>
<programlisting language="text" linenumbering="unnumbered">siteconfig
   site1-sno-du.yaml
   user-custom-manifest
         custom-sctp-machine-config-worker.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-advanced-policy-config">
<title>Advanced managed cluster configuration with PolicyGenTemplate resources</title>
<simpara>You can use <literal>PolicyGenTemplate</literal> CRs to deploy custom functionality in your managed clusters.</simpara>
<section xml:id="ztp-deploying-additional-changes-to-clusters_ztp-advanced-policy-config">
<title>Deploying additional changes to clusters</title>
<simpara>If you require cluster configuration changes outside of the base GitOps Zero Touch Provisioning (ZTP) pipeline configuration, there are three options:</simpara>
<variablelist>
<varlistentry>
<term>Apply the additional configuration after the GitOps ZTP pipeline is complete</term>
<listitem>
<simpara>When the GitOps ZTP pipeline deployment is complete, the deployed cluster is ready for application workloads. At this point, you can install additional Operators and apply configurations specific to your requirements. Ensure that additional configurations do not negatively affect the performance of the platform or allocated CPU budget.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Add content to the GitOps ZTP library</term>
<listitem>
<simpara>The base source custom resources (CRs) that you deploy with the GitOps ZTP pipeline can be augmented with custom content as required.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Create extra manifests for the cluster installation</term>
<listitem>
<simpara>Extra manifests are applied during installation and make the installation process more efficient.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>Providing additional source CRs or modifying existing source CRs can significantly impact the performance or CPU profile of OpenShift Container Platform.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-customizing-the-install-extra-manifests_ztp-advanced-install-ztp">Customizing extra installation manifests in the GitOps ZTP pipeline</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-using-pgt-to-update-source-crs_ztp-advanced-policy-config">
<title>Using PolicyGenTemplate CRs to override source CRs content</title>
<simpara><literal>PolicyGenTemplate</literal> custom resources (CRs) allow you to overlay additional configuration details on top of the base source CRs provided with the GitOps plugin in the <literal>ztp-site-generate</literal> container. You can think of <literal>PolicyGenTemplate</literal> CRs as a logical merge or patch to the base CR. Use <literal>PolicyGenTemplate</literal> CRs to update a single field of the base CR, or overlay the entire contents of the base CR. You can update values and insert fields that are not in the base CR.</simpara>
<simpara>The following example procedure describes how to update fields in the generated <literal>PerformanceProfile</literal> CR for the reference configuration based on the <literal>PolicyGenTemplate</literal> CR in the <literal>group-du-sno-ranGen.yaml</literal> file. Use the procedure as a basis for modifying other parts of the <literal>PolicyGenTemplate</literal> based on your requirements.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for Argo CD.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Review the baseline source CR for existing content. You can review the source CRs listed in the reference <literal>PolicyGenTemplate</literal> CRs by extracting them from the GitOps Zero Touch Provisioning (ZTP) container.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>/out</literal> folder:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./out</programlisting>
</listitem>
<listitem>
<simpara>Extract the source CRs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --log-driver=none --rm registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14.1 extract /home/ztp --tar | tar x -C ./out</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Review the baseline <literal>PerformanceProfile</literal> CR in <literal>./out/source-crs/PerformanceProfile.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
  name: $name
  annotations:
    ran.openshift.io/ztp-deploy-wave: "10"
spec:
  additionalKernelArgs:
  - "idle=poll"
  - "rcupdate.rcu_normal_after_boot=0"
  cpu:
    isolated: $isolated
    reserved: $reserved
  hugepages:
    defaultHugepagesSize: $defaultHugepagesSize
    pages:
      - size: $size
        count: $count
        node: $node
  machineConfigPoolSelector:
    pools.operator.machineconfiguration.openshift.io/$mcp: ""
  net:
    userLevelNetworking: true
  nodeSelector:
    node-role.kubernetes.io/$mcp: ''
  numa:
    topologyPolicy: "restricted"
  realTimeKernel:
    enabled: true</programlisting>
<note>
<simpara>Any fields in the source CR which contain <literal>$&#8230;&#8203;</literal> are removed from the generated CR if they are not provided in the <literal>PolicyGenTemplate</literal> CR.</simpara>
</note>
</listitem>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> entry for <literal>PerformanceProfile</literal> in the <literal>group-du-sno-ranGen.yaml</literal> reference file. The following example <literal>PolicyGenTemplate</literal> CR stanza supplies appropriate CPU specifications, sets the <literal>hugepages</literal> configuration, and adds a new field that sets <literal>globallyDisableIrqLoadBalancing</literal> to false.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PerformanceProfile.yaml
  policyName: "config-policy"
  metadata:
    name: openshift-node-performance-profile
  spec:
    cpu:
      # These must be tailored for the specific hardware platform
      isolated: "2-19,22-39"
      reserved: "0-1,20-21"
    hugepages:
      defaultHugepagesSize: 1G
      pages:
        - size: 1G
          count: 10
    globallyDisableIrqLoadBalancing: false</programlisting>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP argo CD application.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Example output</title>
<para>The GitOps ZTP application generates an RHACM policy that contains the generated <literal>PerformanceProfile</literal> CR. The contents of that CR are derived by merging the <literal>metadata</literal> and <literal>spec</literal> contents from the <literal>PerformanceProfile</literal> entry in the <literal>PolicyGenTemplate</literal> onto the source CR. The resulting CR has the following content:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: performance.openshift.io/v2
kind: PerformanceProfile
metadata:
    name: openshift-node-performance-profile
spec:
    additionalKernelArgs:
        - idle=poll
        - rcupdate.rcu_normal_after_boot=0
    cpu:
        isolated: 2-19,22-39
        reserved: 0-1,20-21
    globallyDisableIrqLoadBalancing: false
    hugepages:
        defaultHugepagesSize: 1G
        pages:
            - count: 10
              size: 1G
    machineConfigPoolSelector:
        pools.operator.machineconfiguration.openshift.io/master: ""
    net:
        userLevelNetworking: true
    nodeSelector:
        node-role.kubernetes.io/master: ""
    numa:
        topologyPolicy: restricted
    realTimeKernel:
        enabled: true</programlisting>
<note>
<simpara>In the <literal>/source-crs</literal> folder that you extract from the <literal>ztp-site-generate</literal> container,  the <literal>$</literal> syntax is not used for template substitution as implied by the syntax. Rather, if the <literal>policyGen</literal> tool sees the <literal>$</literal> prefix for a string and you do not specify a value for that field in the related <literal>PolicyGenTemplate</literal> CR, the field is omitted from the output CR entirely.</simpara>
<simpara>An exception to this is the <literal>$mcp</literal> variable in <literal>/source-crs</literal> YAML files that is substituted with the specified value for <literal>mcp</literal> from the <literal>PolicyGenTemplate</literal> CR. For example, in <literal>example/policygentemplates/group-du-standard-ranGen.yaml</literal>, the value for <literal>mcp</literal> is <literal>worker</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  bindingRules:
    group-du-standard: ""
  mcp: "worker"</programlisting>
<simpara>The <literal>policyGen</literal> tool replace instances of <literal>$mcp</literal> with <literal>worker</literal> in the output CRs.</simpara>
</note>
</section>
<section xml:id="ztp-adding-new-content-to-gitops-ztp_ztp-advanced-policy-config">
<title>Adding custom content to the GitOps ZTP pipeline</title>
<simpara>Perform the following procedure to add new content to the GitOps ZTP pipeline.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a subdirectory named <literal>source-crs</literal> in the directory that contains the <literal>kustomization.yaml</literal> file for the <literal>PolicyGenTemplate</literal> custom resource (CR).</simpara>
</listitem>
<listitem>
<simpara>Add your user-provided CRs to the <literal>source-crs</literal> subdirectory, as shown in the following example:</simpara>
<programlisting language="text" linenumbering="unnumbered">example
 policygentemplates
     dev.yaml
     kustomization.yaml
     mec-edge-sno1.yaml
     sno.yaml
     source-crs <co xml:id="CO71-1"/>
         PaoCatalogSource.yaml
         PaoSubscription.yaml
         custom-crs
        |    apiserver-config.yaml
        |    disable-nic-lldp.yaml
         elasticsearch
             ElasticsearchNS.yaml
             ElasticsearchOperatorGroup.yaml</programlisting>
<calloutlist>
<callout arearefs="CO71-1">
<para>The <literal>source-crs</literal> subdirectory must be in the same directory as the <literal>kustomization.yaml</literal> file.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the required <literal>PolicyGenTemplate</literal> CRs to include references to the content you added in the <literal>source-crs/custom-crs</literal> and <literal>source-crs/elasticsearch</literal> directories. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "group-dev"
  namespace: "ztp-clusters"
spec:
  bindingRules:
    dev: "true"
  mcp: "master"
  sourceFiles:
    # These policies/CRs come from the internal container Image
    #Cluster Logging
    - fileName: ClusterLogNS.yaml
      remediationAction: inform
      policyName: "group-dev-cluster-log-ns"
    - fileName: ClusterLogOperGroup.yaml
      remediationAction: inform
      policyName: "group-dev-cluster-log-operator-group"
    - fileName: ClusterLogSubscription.yaml
      remediationAction: inform
      policyName: "group-dev-cluster-log-sub"
    #Local Storage Operator
    - fileName: StorageNS.yaml
      remediationAction: inform
      policyName: "group-dev-lso-ns"
    - fileName: StorageOperGroup.yaml
      remediationAction: inform
      policyName: "group-dev-lso-operator-group"
    - fileName: StorageSubscription.yaml
      remediationAction: inform
      policyName: "group-dev-lso-sub"
    #These are custom local polices that come from the source-crs directory in the git repo
    # Performance Addon Operator
    - fileName: PaoSubscriptionNS.yaml
      remediationAction: inform
      policyName: "group-dev-pao-ns"
    - fileName: PaoSubscriptionCatalogSource.yaml
      remediationAction: inform
      policyName: "group-dev-pao-cat-source"
      spec:
        image: &lt;image_URL_here&gt;
    - fileName: PaoSubscription.yaml
      remediationAction: inform
      policyName: "group-dev-pao-sub"
    #Elasticsearch Operator
    - fileName: elasticsearch/ElasticsearchNS.yaml <co xml:id="CO72-1"/>
      remediationAction: inform
      policyName: "group-dev-elasticsearch-ns"
    - fileName: elasticsearch/ElasticsearchOperatorGroup.yaml
      remediationAction: inform
      policyName: "group-dev-elasticsearch-operator-group"
    #Custom Resources
    - fileName: custom-crs/apiserver-config.yaml <co xml:id="CO72-2"/>
      remediationAction: inform
      policyName: "group-dev-apiserver-config"
    - fileName: custom-crs/disable-nic-lldp.yaml
      remediationAction: inform
      policyName: "group-dev-disable-nic-lldp"</programlisting>
<calloutlist>
<callout arearefs="CO72-1 CO72-2">
<para>Set <literal>fileName</literal> to include the relative path to the file from the <literal>/source-crs</literal> parent directory.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository that is monitored by the GitOps ZTP Argo CD policies application.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>ClusterGroupUpgrade</literal> CR to include the changed <literal>PolicyGenTemplate</literal> and save it as <literal>cgu-test.yaml</literal>. The following example shows a generated <literal>cgu-test.yaml</literal> file.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: custom-source-cr
  namespace: ztp-clusters
spec:
  managedPolicies:
    - group-dev-config-policy
  enable: true
  clusters:
  - cluster1
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240</programlisting>
</listitem>
<listitem>
<simpara>Apply the updated <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-test.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the updates have succeeded by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -A</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE     NAME               AGE   STATE        DETAILS
ztp-clusters  custom-source-cr   6s    InProgress   Remediating non-compliant policies
ztp-install   cluster1           19h   Completed    All clusters are compliant with all the managed policies</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-configuring-pgt-compliance-eval-timeouts_ztp-advanced-policy-config">
<title>Configuring policy compliance evaluation timeouts for PolicyGenTemplate CRs</title>
<simpara>Use Red Hat Advanced Cluster Management (RHACM) installed on a hub cluster to monitor and report on whether your managed clusters are compliant with applied policies. RHACM uses policy templates to apply predefined policy controllers and policies. Policy controllers are Kubernetes custom resource definition (CRD) instances.</simpara>
<simpara>You can override the default policy evaluation intervals with <literal>PolicyGenTemplate</literal> custom resources (CRs). You configure duration settings that define how long a <literal>ConfigurationPolicy</literal> CR can be in a state of policy compliance or non-compliance before RHACM re-evaluates the applied cluster policies.</simpara>
<simpara>The GitOps Zero Touch Provisioning (ZTP) policy generator generates <literal>ConfigurationPolicy</literal> CR policies with pre-defined policy evaluation intervals. The default value for the <literal>noncompliant</literal> state is 10 seconds. The default value for the <literal>compliant</literal> state is 10 minutes. To disable the evaluation interval, set the value to <literal>never</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure the evaluation interval for all policies in a <literal>PolicyGenTemplate</literal> CR, add <literal>evaluationInterval</literal> to the <literal>spec</literal> field, and then set the appropriate <literal>compliant</literal> and <literal>noncompliant</literal> values. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  evaluationInterval:
    compliant: 30m
    noncompliant: 20s</programlisting>
</listitem>
<listitem>
<simpara>To configure the evaluation interval for the <literal>spec.sourceFiles</literal> object in a <literal>PolicyGenTemplate</literal> CR, add <literal>evaluationInterval</literal> to the <literal>sourceFiles</literal> field, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  sourceFiles:
   - fileName: SriovSubscription.yaml
     policyName: "sriov-sub-policy"
     evaluationInterval:
       compliant: never
       noncompliant: 10s</programlisting>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> CRs files in the Git repository and push your changes.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Check that the managed spoke cluster policies are monitored at the expected intervals.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges on the managed cluster.</simpara>
</listitem>
<listitem>
<simpara>Get the pods that are running in the <literal>open-cluster-management-agent-addon</literal> namespace. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n open-cluster-management-agent-addon</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         READY   STATUS    RESTARTS        AGE
config-policy-controller-858b894c68-v4xdb    1/1     Running   22 (5d8h ago)   10d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the applied policies are being evaluated at the expected interval in the logs for the <literal>config-policy-controller</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n open-cluster-management-agent-addon config-policy-controller-858b894c68-v4xdb</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2022-05-10T15:10:25.280Z       info   configuration-policy-controller controllers/configurationpolicy_controller.go:166      Skipping the policy evaluation due to the policy not reaching the evaluation interval  {"policy": "compute-1-config-policy-config"}
2022-05-10T15:10:25.280Z       info   configuration-policy-controller controllers/configurationpolicy_controller.go:166      Skipping the policy evaluation due to the policy not reaching the evaluation interval  {"policy": "compute-1-common-compute-1-catalog-policy-config"}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-creating-a-validator-inform-policy_ztp-advanced-policy-config">
<title>Signalling GitOps ZTP cluster deployment completion with validator inform policies</title>
<simpara>Create a validator inform policy that signals when the GitOps Zero Touch Provisioning (ZTP) installation and configuration of the deployed cluster is complete. This policy can be used for deployments of single-node OpenShift clusters, three-node clusters, and standard clusters.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a standalone <literal>PolicyGenTemplate</literal> custom resource (CR) that contains the source file
<literal>validatorCRs/informDuValidator.yaml</literal>. You only need one standalone <literal>PolicyGenTemplate</literal> CR for each cluster type. For example, this CR applies a validator inform policy for single-node OpenShift clusters:</simpara>
<formalpara>
<title>Example single-node cluster validator inform policy CR (group-du-sno-validator-ranGen.yaml)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "group-du-sno-validator" <co xml:id="CO73-1"/>
  namespace: "ztp-group" <co xml:id="CO73-2"/>
spec:
  bindingRules:
    group-du-sno: "" <co xml:id="CO73-3"/>
  bindingExcludedRules:
    ztp-done: "" <co xml:id="CO73-4"/>
  mcp: "master" <co xml:id="CO73-5"/>
  sourceFiles:
    - fileName: validatorCRs/informDuValidator.yaml
      remediationAction: inform <co xml:id="CO73-6"/>
      policyName: "du-policy" <co xml:id="CO73-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO73-1">
<para>The name of <literal>PolicyGenTemplates</literal> object. This name is also used as part of the names
for the <literal>placementBinding</literal>, <literal>placementRule</literal>, and <literal>policy</literal> that are created in the requested <literal>namespace</literal>.</para>
</callout>
<callout arearefs="CO73-2">
<para>This value should match the <literal>namespace</literal> used in the group <literal>PolicyGenTemplates</literal>.</para>
</callout>
<callout arearefs="CO73-3">
<para>The <literal>group-du-*</literal> label defined in <literal>bindingRules</literal> must exist in the <literal>SiteConfig</literal> files.</para>
</callout>
<callout arearefs="CO73-4">
<para>The label defined in <literal>bindingExcludedRules</literal> must be`ztp-done:`. The <literal>ztp-done</literal> label is used in coordination with the Topology Aware Lifecycle Manager.</para>
</callout>
<callout arearefs="CO73-5">
<para><literal>mcp</literal> defines the <literal>MachineConfigPool</literal> object that is used in the source file <literal>validatorCRs/informDuValidator.yaml</literal>. It should be <literal>master</literal> for single node and three-node cluster deployments and <literal>worker</literal> for standard cluster deployments.</para>
</callout>
<callout arearefs="CO73-6">
<para>Optional. The default value is <literal>inform</literal>.</para>
</callout>
<callout arearefs="CO73-7">
<para>This value is used as part of the name for the generated RHACM policy. The generated validator policy for the single node example is <literal>group-du-sno-validator-du-policy</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> CR file in your Git repository and push the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-updating-gitops">Upgrading GitOps ZTP</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-using-pgt-to-configure-power-saving-states_ztp-advanced-policy-config">
<title>Configuring power states using PolicyGenTemplates CRs</title>
<simpara>For low latency and high-performance edge deployments, it is necessary to disable or limit C-states and P-states.
With this configuration, the CPU runs at a constant frequency, which is typically the maximum turbo frequency. This ensures that the CPU is always running at its maximum speed, which results in high performance and low latency.
This leads to the best latency for workloads.
However, this also leads to the highest power consumption, which might not be necessary for all workloads.</simpara>
<simpara>Workloads can be classified as critical or non-critical, with critical workloads requiring disabled C-state and P-state settings for high performance and low latency, while non-critical workloads use C-state and P-state settings for power savings at the expense of some latency and performance. You can configure the following three power states using GitOps Zero Touch Provisioning (ZTP):</simpara>
<itemizedlist>
<listitem>
<simpara>High-performance mode provides ultra low latency at the highest power consumption.</simpara>
</listitem>
<listitem>
<simpara>Performance mode provides low latency at a relatively high power consumption.</simpara>
</listitem>
<listitem>
<simpara>Power saving balances reduced power consumption with increased latency.</simpara>
</listitem>
</itemizedlist>
<simpara>The default configuration is for a low latency, performance mode.</simpara>
<simpara><literal>PolicyGenTemplate</literal> custom resources (CRs) allow you to overlay additional configuration details onto the base source CRs provided with the GitOps plugin in the <literal>ztp-site-generate</literal> container.</simpara>
<simpara>Configure the power states by updating the <literal>workloadHints</literal> fields in the generated <literal>PerformanceProfile</literal> CR for the reference configuration, based on the <literal>PolicyGenTemplate</literal> CR in the <literal>group-du-sno-ranGen.yaml</literal>.</simpara>
<simpara>The following common prerequisites apply to configuring all three power states.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for Argo CD.</simpara>
</listitem>
<listitem>
<simpara>You have followed the procedure described in "Preparing the GitOps ZTP site configuration repository".</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cnf-understanding-workload-hints_cnf-master">Understanding workload hints</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="configuring-workload-hints_cnf-master">Configuring workload hints manually</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-using-pgt-to-configure-performance-mode_ztp-advanced-policy-config">
<title>Configuring performance mode using PolicyGenTemplate CRs</title>
<simpara>Follow this example to set performance mode by updating the <literal>workloadHints</literal> fields in the generated <literal>PerformanceProfile</literal> CR for the reference configuration, based on the <literal>PolicyGenTemplate</literal> CR in the <literal>group-du-sno-ranGen.yaml</literal>.</simpara>
<simpara>Performance mode provides low latency at a relatively high power consumption.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured the BIOS with performance related settings by following the guidance in "Configuring host firmware for low latency and high performance".</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> entry for <literal>PerformanceProfile</literal> in the <literal>group-du-sno-ranGen.yaml</literal> reference file in <literal>out/argocd/example/policygentemplates</literal> as follows to set performance mode.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PerformanceProfile.yaml
  policyName: "config-policy"
  metadata:
    [...]
  spec:
    [...]
    workloadHints:
         realTime: true
         highPowerConsumption: false
         perPodPowerManagement: false</programlisting>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP Argo CD application.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-using-pgt-to-configure-high-performance-mode_ztp-advanced-policy-config">
<title>Configuring high-performance mode using PolicyGenTemplate CRs</title>
<simpara>Follow this example to set high performance mode by updating the <literal>workloadHints</literal> fields in the generated <literal>PerformanceProfile</literal> CR for the reference configuration, based on the <literal>PolicyGenTemplate</literal> CR in the <literal>group-du-sno-ranGen.yaml</literal>.</simpara>
<simpara>High performance mode provides ultra low latency at the highest power consumption.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured the BIOS with performance related settings by following the guidance in "Configuring host firmware for low latency and high performance".</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> entry for <literal>PerformanceProfile</literal> in the <literal>group-du-sno-ranGen.yaml</literal> reference file in <literal>out/argocd/example/policygentemplates</literal> as follows to set high-performance mode.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PerformanceProfile.yaml
  policyName: "config-policy"
  metadata:
    [...]
  spec:
    [...]
    workloadHints:
         realTime: true
         highPowerConsumption: true
         perPodPowerManagement: false</programlisting>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP Argo CD application.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-using-pgt-to-configure-power-saving-mode_ztp-advanced-policy-config">
<title>Configuring power saving mode using PolicyGenTemplate CRs</title>
<simpara>Follow this example to set power saving mode by updating the <literal>workloadHints</literal> fields in the generated <literal>PerformanceProfile</literal> CR for the reference configuration, based on the <literal>PolicyGenTemplate</literal> CR in the <literal>group-du-sno-ranGen.yaml</literal>.</simpara>
<simpara>The power saving mode balances reduced power consumption with increased latency.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You enabled C-states and OS-controlled P-states in the BIOS.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> entry for <literal>PerformanceProfile</literal> in the <literal>group-du-sno-ranGen.yaml</literal> reference file in <literal>out/argocd/example/policygentemplates</literal> as follows to configure power saving mode. It is recommended to configure the CPU governor for the power saving mode through the additional kernel arguments object.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PerformanceProfile.yaml
  policyName: "config-policy"
  metadata:
    [...]
  spec:
    [...]
    workloadHints:
         realTime: true
         highPowerConsumption: false
         perPodPowerManagement: true
    [...]
    additionalKernelArgs:
       - [...]
       - "cpufreq.default_governor=schedutil" <co xml:id="CO74-1"/></programlisting>
<calloutlist>
<callout arearefs="CO74-1">
<para>The <literal>schedutil</literal> governor is recommended, however, other governors that can be used include <literal>ondemand</literal> and <literal>powersave</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP Argo CD application.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Select a worker node in your deployed cluster from the list of nodes identified by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
</listitem>
<listitem>
<simpara>Log in to the node by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt;</programlisting>
<simpara>Replace <literal>&lt;node-name&gt;</literal> with the name of the node you want to verify the power state on.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell. The debug pod mounts the hosts root file system in <literal>/host</literal> within the pod. By changing the root directory to <literal>/host</literal>, you can run binaries contained in the hosts executable paths as shown in the following example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify the applied power state:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cat /proc/cmdline</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Expected output</title>
<listitem>
<simpara>For power saving mode the <literal>intel_pstate=passive</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="node-tuning-operator-pod-power-saving-config_cnf-master">Enabling critical workloads for power saving configurations</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-du-configuring-host-firmware-requirements_sno-configure-for-vdu">Configuring host firmware for low latency and high performance</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ztp-preparing-the-ztp-git-repository_ztp-preparing-the-hub-cluster">Preparing the GitOps ZTP site configuration repository</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-using-pgt-to-maximize-power-savings-mode_ztp-advanced-policy-config">
<title>Maximizing power savings</title>
<simpara>Limiting the maximum CPU frequency is recommended to achieve maximum power savings.
Enabling C-states on the non-critical workload CPUs without restricting the maximum CPU frequency negates much of the power savings by boosting the frequency of the critical CPUs.</simpara>
<simpara>Maximize power savings by updating the <literal>sysfs</literal> plugin fields, setting an appropriate value for <literal>max_perf_pct</literal> in the <literal>TunedPerformancePatch</literal> CR for the reference configuration. This example based on the <literal>group-du-sno-ranGen.yaml</literal> describes the procedure to follow to restrict the maximum CPU frequency.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured power savings mode as described in "Using PolicyGenTemplate CRs to configure power savings mode".</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> entry for <literal>TunedPerformancePatch</literal> in the <literal>group-du-sno-ranGen.yaml</literal> reference file in <literal>out/argocd/example/policygentemplates</literal>. To maximize power savings, add <literal>max_perf_pct</literal> as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: TunedPerformancePatch.yaml
      policyName: "config-policy"
      spec:
        profile:
          - name: performance-patch
            data: |
              [...]
              [sysfs]
              /sys/devices/system/cpu/intel_pstate/max_perf_pct=&lt;x&gt; <co xml:id="CO75-1"/></programlisting>
<calloutlist>
<callout arearefs="CO75-1">
<para>The <literal>max_perf_pct</literal> controls the maximum frequency the <literal>cpufreq</literal> driver is allowed to set as a percentage of the maximum supported CPU frequency. This value applies to all CPUs. You can check the maximum supported frequency in <literal>/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq</literal>. As a starting point, you can use a percentage that caps all CPUs at the <literal>All Cores Turbo</literal> frequency. The <literal>All Cores Turbo</literal> frequency is the frequency that all cores will run at when the cores are all fully occupied.</para>
</callout>
</calloutlist>
<note>
<simpara>To maximize power savings, set a lower value. Setting a lower value for <literal>max_perf_pct</literal> limits the maximum CPU frequency, thereby reducing power consumption, but also potentially impacting performance. Experiment with different values and monitor the system&#8217;s performance and power consumption to find the optimal setting for your use-case.</simpara>
</note>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP Argo CD application.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-provisioning-lvm-storage_ztp-advanced-policy-config">
<title>Configuring LVM Storage using PolicyGenTemplate CRs</title>
<simpara>You can configure Logical volume manager storage (LVM Storage) for managed clusters that you deploy with GitOps Zero Touch Provisioning (ZTP).</simpara>
<note>
<simpara>You use LVM Storage to persist event subscriptions when you use PTP events or bare-metal hardware events with HTTP transport.</simpara>
<simpara>Use the Local Storage Operator for persistent storage that uses local volumes in distributed units.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure LVM Storage for new managed clusters, add the following YAML to <literal>spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: StorageLVMOSubscriptionNS.yaml
  policyName: subscription-policies
- fileName: StorageLVMOSubscriptionOperGroup.yaml
  policyName: subscription-policies
- fileName: StorageLVMOSubscription.yaml
  spec:
    name: lvms-operator
    channel: stable-4.14
  policyName: subscription-policies</programlisting>
<note>
<simpara>The Storage LVMO subscription is deprecated. In future releases of OpenShift Container Platform, the storage LVMO subscription will not be available. Instead, you must use the Storage LVMS subscription.</simpara>
<simpara>In OpenShift Container Platform 4.14, you can use the Storage LVMS subscription instead of the LVMO subscription. The LVMS subscription does not require manual overrides in the <literal>common-ranGen.yaml</literal> file. Add the following YAML to <literal>spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file to use the Storage LVMS subscription:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: StorageLVMSubscriptionNS.yaml
  policyName: subscription-policies
- fileName: StorageLVMSubscriptionOperGroup.yaml
  policyName: subscription-policies
- fileName: StorageLVMSubscription.yaml
  policyName: subscription-policies</programlisting>
</note>
</listitem>
<listitem>
<simpara>Add the <literal>LVMCluster</literal> CR to <literal>spec.sourceFiles</literal> in your specific group or individual site configuration file. For example, in the <literal>group-du-sno-ranGen.yaml</literal> file, add the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: StorageLVMCluster.yaml
  policyName: "lvms-config" <co xml:id="CO76-1"/>
  spec:
    storage:
      deviceClasses:
      - name: vg1
        thinPoolConfig:
          name: thin-pool-1
          sizePercent: 90
          overprovisionRatio: 10</programlisting>
<calloutlist>
<callout arearefs="CO76-1">
<para>This example configuration creates a volume group (<literal>vg1</literal>) with all the available devices, except the disk where OpenShift Container Platform is installed.
A thin-pool logical volume is also created.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Merge any other required changes and files with your custom site repository.</simpara>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> changes in Git, and then push the changes to your site configuration repository to deploy LVM Storage to new sites using GitOps ZTP.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-advanced-policy-config-ptp_ztp-advanced-policy-config">
<title>Configuring PTP events with PolicyGenTemplate CRs</title>
<simpara>You can use the GitOps ZTP pipeline to configure PTP events that use HTTP or AMQP transport.</simpara>
<note>
<simpara>Use HTTP transport instead of AMQP for PTP and bare-metal events where possible.
AMQ Interconnect is EOL from 30 June 2024.
Extended life cycle support (ELS) for AMQ Interconnect ends 29 November 2029.
For more information see, <link xlink:href="https://access.redhat.com/support/policy/updates/jboss_notes#p_Interconnect">Red Hat AMQ Interconnect support status</link>.</simpara>
</note>
<section xml:id="ztp-configuring-ptp-fast-events_ztp-advanced-policy-config">
<title>Configuring PTP events that use HTTP transport</title>
<simpara>You can configure PTP events that use HTTP transport on managed clusters that you deploy with the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the following <literal>PolicyGenTemplate</literal> changes to <literal>group-du-3node-ranGen.yaml</literal>, <literal>group-du-sno-ranGen.yaml</literal>, or <literal>group-du-standard-ranGen.yaml</literal> files according to your requirements:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In <literal>.sourceFiles</literal>, add the <literal>PtpOperatorConfig</literal> CR file that configures the transport host:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PtpOperatorConfigForEvent.yaml
  policyName: "config-policy"
  spec:
    daemonNodeSelector: {}
    ptpEventConfig:
      enableEventPublisher: true
      transportHost: http://ptp-event-publisher-service-NODE_NAME.openshift-ptp.svc.cluster.local:9043</programlisting>
<note>
<simpara>In OpenShift Container Platform 4.13 or later, you do not need to set the <literal>transportHost</literal> field in the <literal>PtpOperatorConfig</literal> resource when you use HTTP transport with PTP events.</simpara>
</note>
</listitem>
<listitem>
<simpara>Configure the <literal>linuxptp</literal> and <literal>phc2sys</literal> for the PTP clock type and interface. For example, add the following stanza into <literal>.sourceFiles</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PtpConfigSlave.yaml <co xml:id="CO77-1"/>
  policyName: "config-policy"
  metadata:
    name: "du-ptp-slave"
  spec:
    profile:
    - name: "slave"
      interface: "ens5f1" <co xml:id="CO77-2"/>
      ptp4lOpts: "-2 -s --summary_interval -4" <co xml:id="CO77-3"/>
      phc2sysOpts: "-a -r -m -n 24 -N 8 -R 16" <co xml:id="CO77-4"/>
    ptpClockThreshold: <co xml:id="CO77-5"/>
      holdOverTimeout: 30 #secs
      maxOffsetThreshold: 100  #nano secs
      minOffsetThreshold: -100 #nano secs</programlisting>
<calloutlist>
<callout arearefs="CO77-1">
<para>Can be one of <literal>PtpConfigMaster.yaml</literal>, <literal>PtpConfigSlave.yaml</literal>, or <literal>PtpConfigSlaveCvl.yaml</literal> depending on your requirements. <literal>PtpConfigSlaveCvl.yaml</literal> configures <literal>linuxptp</literal> services for an Intel E810 Columbiaville NIC. For configurations based on <literal>group-du-sno-ranGen.yaml</literal> or <literal>group-du-3node-ranGen.yaml</literal>, use <literal>PtpConfigSlave.yaml</literal>.</para>
</callout>
<callout arearefs="CO77-2">
<para>Device specific interface name.</para>
</callout>
<callout arearefs="CO77-3">
<para>You must append the <literal>--summary_interval -4</literal> value to <literal>ptp4lOpts</literal> in <literal>.spec.sourceFiles.spec.profile</literal> to enable PTP fast events.</para>
</callout>
<callout arearefs="CO77-4">
<para>Required <literal>phc2sysOpts</literal> values. <literal>-m</literal> prints messages to <literal>stdout</literal>. The <literal>linuxptp-daemon</literal> <literal>DaemonSet</literal> parses the logs and generates Prometheus metrics.</para>
</callout>
<callout arearefs="CO77-5">
<para>Optional. If the <literal>ptpClockThreshold</literal> stanza is not present, default values are used for the <literal>ptpClockThreshold</literal> fields. The stanza shows default <literal>ptpClockThreshold</literal> values. The <literal>ptpClockThreshold</literal> values configure how long after the PTP master clock is disconnected before PTP events are triggered. <literal>holdOverTimeout</literal> is the time value in seconds before the PTP clock event state changes to <literal>FREERUN</literal> when the PTP master clock is disconnected. The <literal>maxOffsetThreshold</literal> and <literal>minOffsetThreshold</literal> settings configure offset values in nanoseconds that compare against the values for <literal>CLOCK_REALTIME</literal> (<literal>phc2sys</literal>) or master offset (<literal>ptp4l</literal>). When the <literal>ptp4l</literal> or <literal>phc2sys</literal> offset value is outside this range, the PTP clock state is set to <literal>FREERUN</literal>. When the offset value is within this range, the PTP clock state is set to <literal>LOCKED</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Merge any other required changes and files with your custom site repository.</simpara>
</listitem>
<listitem>
<simpara>Push the changes to your site configuration repository to deploy PTP fast events to new sites using GitOps ZTP.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="ztp-using-pgt-to-update-source-crs_ztp-advanced-policy-config">Using PolicyGenTemplate CRs to override source CRs content</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-configuring-ptp-fast-events-amqp_ztp-advanced-policy-config">
<title>Configuring PTP events that use AMQP transport</title>
<simpara>You can configure PTP events that use AMQP transport on managed clusters that you deploy with the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<note>
<simpara>Use HTTP transport instead of AMQP for PTP and bare-metal events where possible.
AMQ Interconnect is EOL from 30 June 2024.
Extended life cycle support (ELS) for AMQ Interconnect ends 29 November 2029.
For more information see, <link xlink:href="https://access.redhat.com/support/policy/updates/jboss_notes#p_Interconnect">Red Hat AMQ Interconnect support status</link>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the following YAML into <literal>.spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file to configure the AMQP Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">#AMQ interconnect operator for fast events
- fileName: AmqSubscriptionNS.yaml
  policyName: "subscriptions-policy"
- fileName: AmqSubscriptionOperGroup.yaml
  policyName: "subscriptions-policy"
- fileName: AmqSubscription.yaml
  policyName: "subscriptions-policy"</programlisting>
</listitem>
<listitem>
<simpara>Apply the following <literal>PolicyGenTemplate</literal> changes to <literal>group-du-3node-ranGen.yaml</literal>, <literal>group-du-sno-ranGen.yaml</literal>, or <literal>group-du-standard-ranGen.yaml</literal> files according to your requirements:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In <literal>.sourceFiles</literal>, add the <literal>PtpOperatorConfig</literal> CR file that configures the AMQ transport host to the <literal>config-policy</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PtpOperatorConfigForEvent.yaml
  policyName: "config-policy"
  spec:
    daemonNodeSelector: {}
    ptpEventConfig:
      enableEventPublisher: true
      transportHost: "amqp://amq-router.amq-router.svc.cluster.local"</programlisting>
</listitem>
<listitem>
<simpara>Configure the <literal>linuxptp</literal> and <literal>phc2sys</literal> for the PTP clock type and interface. For example, add the following stanza into <literal>.sourceFiles</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: PtpConfigSlave.yaml <co xml:id="CO78-1"/>
  policyName: "config-policy"
  metadata:
    name: "du-ptp-slave"
  spec:
    profile:
    - name: "slave"
      interface: "ens5f1" <co xml:id="CO78-2"/>
      ptp4lOpts: "-2 -s --summary_interval -4" <co xml:id="CO78-3"/>
      phc2sysOpts: "-a -r -m -n 24 -N 8 -R 16" <co xml:id="CO78-4"/>
    ptpClockThreshold: <co xml:id="CO78-5"/>
      holdOverTimeout: 30 #secs
      maxOffsetThreshold: 100  #nano secs
      minOffsetThreshold: -100 #nano secs</programlisting>
<calloutlist>
<callout arearefs="CO78-1">
<para>Can be one <literal>PtpConfigMaster.yaml</literal>, <literal>PtpConfigSlave.yaml</literal>, or <literal>PtpConfigSlaveCvl.yaml</literal> depending on your requirements. <literal>PtpConfigSlaveCvl.yaml</literal> configures <literal>linuxptp</literal> services for an Intel E810 Columbiaville NIC. For configurations based on <literal>group-du-sno-ranGen.yaml</literal> or <literal>group-du-3node-ranGen.yaml</literal>, use <literal>PtpConfigSlave.yaml</literal>.</para>
</callout>
<callout arearefs="CO78-2">
<para>Device specific interface name.</para>
</callout>
<callout arearefs="CO78-3">
<para>You must append the <literal>--summary_interval -4</literal> value to <literal>ptp4lOpts</literal> in <literal>.spec.sourceFiles.spec.profile</literal> to enable PTP fast events.</para>
</callout>
<callout arearefs="CO78-4">
<para>Required <literal>phc2sysOpts</literal> values. <literal>-m</literal> prints messages to <literal>stdout</literal>. The <literal>linuxptp-daemon</literal> <literal>DaemonSet</literal> parses the logs and generates Prometheus metrics.</para>
</callout>
<callout arearefs="CO78-5">
<para>Optional. If the <literal>ptpClockThreshold</literal> stanza is not present, default values are used for the <literal>ptpClockThreshold</literal> fields. The stanza shows default <literal>ptpClockThreshold</literal> values. The <literal>ptpClockThreshold</literal> values configure how long after the PTP master clock is disconnected before PTP events are triggered. <literal>holdOverTimeout</literal> is the time value in seconds before the PTP clock event state changes to <literal>FREERUN</literal> when the PTP master clock is disconnected. The <literal>maxOffsetThreshold</literal> and <literal>minOffsetThreshold</literal> settings configure offset values in nanoseconds that compare against the values for <literal>CLOCK_REALTIME</literal> (<literal>phc2sys</literal>) or master offset (<literal>ptp4l</literal>). When the <literal>ptp4l</literal> or <literal>phc2sys</literal> offset value is outside this range, the PTP clock state is set to <literal>FREERUN</literal>. When the offset value is within this range, the PTP clock state is set to <literal>LOCKED</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Apply the following <literal>PolicyGenTemplate</literal> changes to your specific site YAML files, for example, <literal>example-sno-site.yaml</literal>:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In <literal>.sourceFiles</literal>, add the <literal>Interconnect</literal> CR file that configures the AMQ router to the <literal>config-policy</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: AmqInstance.yaml
  policyName: "config-policy"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Merge any other required changes and files with your custom site repository.</simpara>
</listitem>
<listitem>
<simpara>Push the changes to your site configuration repository to deploy PTP fast events to new sites using GitOps ZTP.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#cnf-installing-amq-interconnect-messaging-bus_using-ptp-events">Installing the AMQ messaging bus</link></simpara>
</listitem>
<listitem>
<simpara>For more information about container image registries, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/registry/#registry-overview">OpenShift image registry overview</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-advanced-policy-config-bare-metal_ztp-advanced-policy-config">
<title>Configuring bare-metal events with PolicyGenTemplate CRs</title>
<simpara>You can use the GitOps ZTP pipeline to configure bare-metal events that use HTTP or AMQP transport.</simpara>
<note>
<simpara>Use HTTP transport instead of AMQP for PTP and bare-metal events where possible.
AMQ Interconnect is EOL from 30 June 2024.
Extended life cycle support (ELS) for AMQ Interconnect ends 29 November 2029.
For more information see, <link xlink:href="https://access.redhat.com/support/policy/updates/jboss_notes#p_Interconnect">Red Hat AMQ Interconnect support status</link>.</simpara>
</note>
<section xml:id="ztp-creating-hwevents_ztp-advanced-policy-config">
<title>Configuring bare-metal events that use HTTP transport</title>
<simpara>You can configure bare-metal events that use HTTP transport on managed clusters that you deploy with the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure the Bare Metal Event Relay Operator by adding the following YAML to <literal>spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># Bare Metal Event Relay operator
- fileName: BareMetalEventRelaySubscriptionNS.yaml
  policyName: "subscriptions-policy"
- fileName: BareMetalEventRelaySubscriptionOperGroup.yaml
  policyName: "subscriptions-policy"
- fileName: BareMetalEventRelaySubscription.yaml
  policyName: "subscriptions-policy"</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>HardwareEvent</literal> CR to <literal>spec.sourceFiles</literal> in your specific group configuration file, for example, in the <literal>group-du-sno-ranGen.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: HardwareEvent.yaml <co xml:id="CO79-1"/>
  policyName: "config-policy"
  spec:
    nodeSelector: {}
    transportHost: "http://hw-event-publisher-service.openshift-bare-metal-events.svc.cluster.local:9043"
    logLevel: "info"</programlisting>
<calloutlist>
<callout arearefs="CO79-1">
<para>Each baseboard management controller (BMC) requires a single <literal>HardwareEvent</literal> CR only.</para>
</callout>
</calloutlist>
<note>
<simpara>In OpenShift Container Platform 4.13 or later, you do not need to set the <literal>transportHost</literal> field in the <literal>HardwareEvent</literal> custom resource (CR) when you use HTTP transport with bare-metal events.</simpara>
</note>
</listitem>
<listitem>
<simpara>Merge any other required changes and files with your custom site repository.</simpara>
</listitem>
<listitem>
<simpara>Push the changes to your site configuration repository to deploy bare-metal events to new sites with GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Create the Redfish Secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-bare-metal-events create secret generic redfish-basic-auth \
--from-literal=username=&lt;bmc_username&gt; --from-literal=password=&lt;bmc_password&gt; \
--from-literal=hostaddr="&lt;bmc_host_ip_addr&gt;"</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="nw-rfhe-installing-operator-cli_using-rfhe">Installing the Bare Metal Event Relay using the CLI</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="nw-rfhe-creating-hardware-event_using-rfhe">Creating the bare-metal event and Secret CRs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-creating-hwevents-amqp_ztp-advanced-policy-config">
<title>Configuring bare-metal events that use AMQP transport</title>
<simpara>You can configure bare-metal events that use AMQP transport on managed clusters that you deploy with the GitOps Zero Touch Provisioning (ZTP) pipeline.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure the AMQ Interconnect Operator and the Bare Metal Event Relay Operator, add the following YAML to <literal>spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># AMQ interconnect operator for fast events
- fileName: AmqSubscriptionNS.yaml
  policyName: "subscriptions-policy"
- fileName: AmqSubscriptionOperGroup.yaml
  policyName: "subscriptions-policy"
- fileName: AmqSubscription.yaml
  policyName: "subscriptions-policy"
# Bare Metal Event Rely operator
- fileName: BareMetalEventRelaySubscriptionNS.yaml
  policyName: "subscriptions-policy"
- fileName: BareMetalEventRelaySubscriptionOperGroup.yaml
  policyName: "subscriptions-policy"
- fileName: BareMetalEventRelaySubscription.yaml
  policyName: "subscriptions-policy"</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>Interconnect</literal> CR to <literal>.spec.sourceFiles</literal> in the site configuration file, for example, the <literal>example-sno-site.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: AmqInstance.yaml
  policyName: "config-policy"</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>HardwareEvent</literal> CR to <literal>spec.sourceFiles</literal> in your specific group configuration file, for example, in the <literal>group-du-sno-ranGen.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: HardwareEvent.yaml
  policyName: "config-policy"
  spec:
    nodeSelector: {}
    transportHost: "amqp://&lt;amq_interconnect_name&gt;.&lt;amq_interconnect_namespace&gt;.svc.cluster.local" <co xml:id="CO80-1"/>
    logLevel: "info"</programlisting>
<calloutlist>
<callout arearefs="CO80-1">
<para>The <literal>transportHost</literal> URL is composed of the existing AMQ Interconnect CR <literal>name</literal> and <literal>namespace</literal>. For example, in <literal>transportHost: "amqp://amq-router.amq-router.svc.cluster.local"</literal>, the AMQ Interconnect <literal>name</literal> and <literal>namespace</literal> are both set to <literal>amq-router</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>Each baseboard management controller (BMC) requires a single <literal>HardwareEvent</literal> resource only.</simpara>
</note>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push the changes to your site configuration repository to deploy bare-metal events monitoring to new sites using GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Create the Redfish Secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-bare-metal-events create secret generic redfish-basic-auth \
--from-literal=username=&lt;bmc_username&gt; --from-literal=password=&lt;bmc_password&gt; \
--from-literal=hostaddr="&lt;bmc_host_ip_addr&gt;"</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ztp-add-local-reg-for-sno-duprofile_ztp-advanced-policy-config">
<title>Configuring the Image Registry Operator for local caching of images</title>
<simpara>OpenShift Container Platform manages image caching using a local registry. In edge computing use cases, clusters are often subject to bandwidth restrictions when communicating with centralized image registries, which might result in long image download times.</simpara>
<simpara>Long download times are unavoidable during initial deployment. Over time, there is a risk that CRI-O will erase the <literal>/var/lib/containers/storage</literal> directory in the case of an unexpected shutdown.
To address long image download times, you can create a local image registry on remote managed clusters using GitOps Zero Touch Provisioning (ZTP). This is useful in Edge computing scenarios where clusters are deployed at the far edge of the network.</simpara>
<simpara>Before you can set up the local image registry with GitOps ZTP, you need to configure disk partitioning in the <literal>SiteConfig</literal> CR that you use to install the remote managed cluster. After installation, you configure the local image registry using a <literal>PolicyGenTemplate</literal> CR. Then, the GitOps ZTP pipeline creates Persistent Volume (PV) and Persistent Volume Claim (PVC) CRs and patches the <literal>imageregistry</literal> configuration.</simpara>
<note>
<simpara>The local image registry can only be used for user application images and cannot be used for the OpenShift Container Platform or Operator Lifecycle Manager operator images.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/registry/#registry-overview">OpenShift Container Platform registry overview</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-configuring-disk-partitioning_ztp-advanced-policy-config">
<title>Configuring disk partitioning with SiteConfig</title>
<simpara>Configure disk partitioning for a managed cluster using a <literal>SiteConfig</literal> CR and GitOps Zero Touch Provisioning (ZTP). The  disk partition details in the <literal>SiteConfig</literal> CR must match the underlying disk.</simpara>
<note>
<simpara>Use persistent naming for devices to avoid device names such as <literal>/dev/sda</literal> and <literal>/dev/sdb</literal> being switched at every reboot. You can use <literal>rootDeviceHints</literal> to choose the bootable device and then use same device for further partitioning.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data for use with GitOps Zero Touch Provisioning (ZTP).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the following YAML that describes the host disk partitioning to the <literal>SiteConfig</literal> CR that you use to install the managed cluster:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">nodes:
    rootDeviceHints:
      wwn: "0x62cea7f05c98c2002708a0a22ff480ea"
    diskPartition:
      - device: /dev/disk/by-id/wwn-0x62cea7f05c98c2002708a0a22ff480ea <co xml:id="CO81-1"/>
        partitions:
          - mount_point: /var/imageregistry
            size: 102500 <co xml:id="CO81-2"/>
            start: 344844 <co xml:id="CO81-3"/></programlisting>
<calloutlist>
<callout arearefs="CO81-1">
<para>This setting depends on the hardware. The setting can be a serial number or device name. The value must match the value set for <literal>rootDeviceHints</literal>.</para>
</callout>
<callout arearefs="CO81-2">
<para>The minimum value for <literal>size</literal> is 102500 MiB.</para>
</callout>
<callout arearefs="CO81-3">
<para>The minimum value for <literal>start</literal> is 25000 MiB. The total value of <literal>size</literal> and <literal>start</literal> must not exceed the disk size, or the installation will fail.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the <literal>SiteConfig</literal> CR and push it to the site configuration repo.</simpara>
</listitem>
</orderedlist>
<simpara>The GitOps ZTP pipeline provisions the cluster using the <literal>SiteConfig</literal> CR and configures the disk partition.</simpara>
</section>
<section xml:id="ztp-configuring-pgt-image-registry_ztp-advanced-policy-config">
<title>Configuring the image registry using PolicyGenTemplate CRs</title>
<simpara>Use <literal>PolicyGenTemplate</literal> (PGT) CRs to apply the CRs required to configure the image registry and patch the <literal>imageregistry</literal> configuration.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured a disk partition in the managed cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data for use with GitOps Zero Touch Provisioning (ZTP).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure the storage class, persistent volume claim, persistent volume, and image registry configuration in the appropriate <literal>PolicyGenTemplate</literal> CR. For example, to configure an individual site, add the following YAML to the file <literal>example-sno-site.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">sourceFiles:
  # storage class
  - fileName: StorageClass.yaml
    policyName: "sc-for-image-registry"
    metadata:
      name: image-registry-sc
      annotations:
        ran.openshift.io/ztp-deploy-wave: "100" <co xml:id="CO82-1"/>
  # persistent volume claim
  - fileName: StoragePVC.yaml
    policyName: "pvc-for-image-registry"
    metadata:
      name: image-registry-pvc
      namespace: openshift-image-registry
      annotations:
        ran.openshift.io/ztp-deploy-wave: "100"
    spec:
      accessModes:
        - ReadWriteMany
      resources:
        requests:
          storage: 100Gi
      storageClassName: image-registry-sc
      volumeMode: Filesystem
  # persistent volume
  - fileName: ImageRegistryPV.yaml <co xml:id="CO82-2"/>
    policyName: "pv-for-image-registry"
    metadata:
      annotations:
        ran.openshift.io/ztp-deploy-wave: "100"
  - fileName: ImageRegistryConfig.yaml
    policyName: "config-for-image-registry"
    complianceType: musthave
    metadata:
      annotations:
        ran.openshift.io/ztp-deploy-wave: "100"
    spec:
      storage:
        pvc:
          claim: "image-registry-pvc"</programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>Set the appropriate value for <literal>ztp-deploy-wave</literal> depending on whether you are configuring image registries at the site, common, or group level. <literal>ztp-deploy-wave: "100"</literal> is suitable for development or testing because it allows you to group the referenced source files together.</para>
</callout>
<callout arearefs="CO82-2">
<para>In <literal>ImageRegistryPV.yaml</literal>, ensure that the <literal>spec.local.path</literal> field is set to <literal>/var/imageregistry</literal> to match the value set for the <literal>mount_point</literal> field in the <literal>SiteConfig</literal> CR.</para>
</callout>
</calloutlist>
<important>
<simpara>Do not set <literal>complianceType: mustonlyhave</literal> for the <literal>- fileName: ImageRegistryConfig.yaml</literal> configuration. This can cause the registry pod deployment to fail.</simpara>
</important>
</listitem>
<listitem>
<simpara>Commit the <literal>PolicyGenTemplate</literal> change in Git, and then push to the Git repository being monitored by the GitOps ZTP ArgoCD application.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Use the following steps to troubleshoot errors with the local image registry on the managed clusters:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Verify successful login to the registry while logged in to the managed cluster. Run the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the managed cluster name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cluster=&lt;managed_cluster_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Get the managed cluster <literal>kubeconfig</literal> details:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret -n $cluster $cluster-admin-password -o jsonpath='{.data.password}' | base64 -d &gt; kubeadmin-password-$cluster</programlisting>
</listitem>
<listitem>
<simpara>Download and export the cluster <literal>kubeconfig</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret -n $cluster $cluster-admin-kubeconfig -o jsonpath='{.data.kubeconfig}' | base64 -d &gt; kubeconfig-$cluster &amp;&amp; export KUBECONFIG=./kubeconfig-$cluster</programlisting>
</listitem>
<listitem>
<simpara>Verify access to the image registry from the managed cluster. See "Accessing the registry".</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the <literal>Config</literal> CRD in the <literal>imageregistry.operator.openshift.io</literal> group instance is not reporting errors. Run the following command while logged in to the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get image.config.openshift.io cluster -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2021-10-08T19:02:39Z"
  generation: 5
  name: cluster
  resourceVersion: "688678648"
  uid: 0406521b-39c0-4cda-ba75-873697da75a4
spec:
  additionalTrustedCA:
    name: acm-ice</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the <literal>PersistentVolumeClaim</literal> on the managed cluster is populated with data. Run the following command while logged in to the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv image-registry-sc</programlisting>
</listitem>
<listitem>
<simpara>Check that the <literal>registry*</literal> pod is running and is located under the <literal>openshift-image-registry</literal> namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-image-registry | grep registry*</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">cluster-image-registry-operator-68f5c9c589-42cfg   1/1     Running     0          8d
image-registry-5f8987879-6nx6h                     1/1     Running     0          8d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the disk partition on the managed cluster is correct:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Open a debug shell to the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/sno-1.example.com</programlisting>
</listitem>
<listitem>
<simpara>Run <literal>lsblk</literal> to check the host disk partitions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 446.6G  0 disk
  |-sda1   8:1    0     1M  0 part
  |-sda2   8:2    0   127M  0 part
  |-sda3   8:3    0   384M  0 part /boot
  |-sda4   8:4    0 336.3G  0 part /sysroot
  `-sda5   8:5    0 100.1G  0 part /var/imageregistry <co xml:id="CO83-1"/>
sdb      8:16   0 446.6G  0 disk
sr0     11:0    1   104M  0 rom</programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para><literal>/var/imageregistry</literal> indicates that the disk is correctly partitioned.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/registry/#accessing-the-registry">Accessing the registry</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-using-hub-cluster-templates_ztp-advanced-policy-config">
<title>Using hub templates in PolicyGenTemplate CRs</title>
<simpara>Topology Aware Lifecycle Manager supports partial Red Hat Advanced Cluster Management (RHACM) hub cluster template functions in configuration policies used with GitOps Zero Touch Provisioning (ZTP).</simpara>
<simpara>Hub-side cluster templates allow you to define configuration policies that can be dynamically customized to the target clusters.
This reduces the need to create separate policies for many clusters with similiar configurations but with different values.</simpara>
<important>
<simpara>Policy templates are restricted to the same namespace as the namespace where the policy is defined.
This means that you must create the objects referenced in the hub template in the same namespace where the policy is created.</simpara>
</important>
<simpara>The following supported hub template functions are available for use in GitOps ZTP with TALM:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#fromConfigmap-func"><literal>fromConfigmap</literal></link> returns the value of the provided data key in the named <literal>ConfigMap</literal> resource.</simpara>
<note>
<simpara>There is a <link xlink:href="https://kubernetes.io/docs/concepts/configuration/configmap/#motivation">1 MiB size limit</link> for <literal>ConfigMap</literal> CRs.
The effective size for <literal>ConfigMap</literal> CRs is further limited by the <literal>last-applied-configuration</literal> annotation.
To avoid the <literal>last-applied-configuration</literal> limitation, add the following annotation to the template <literal>ConfigMap</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">argocd.argoproj.io/sync-options: Replace=true</programlisting>
</note>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#base64enc-func"><literal>base64enc</literal></link> returns the base64-encoded value of the input string</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#base64dec-func"><literal>base64dec</literal></link> returns the decoded value of the base64-encoded input string</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#indent-function"><literal>indent</literal></link> returns the input string with added indent spaces</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#autoindent-function"><literal>autoindent</literal></link> returns the input string with added indent spaces based on the spacing used in the parent template</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#toInt-function"><literal>toInt</literal></link> casts and returns the integer value of the input value</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#toBool-function"><literal>toBool</literal></link> converts the input string into a boolean value, and returns the boolean</simpara>
</listitem>
</itemizedlist>
<simpara>Various <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#open-source-community-functions">Open source community functions</link> are also available for use with GitOps ZTP.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html-single/governance/index#hub-templates">RHACM support for hub cluster templates in configuration policies</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-example-hub-template-functions_ztp-advanced-policy-config">
<title>Example hub templates</title>
<simpara>The following code examples are valid hub templates. Each of these templates return values from the <literal>ConfigMap</literal> CR with the name <literal>test-config</literal> in the <literal>default</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>Returns the value with the key <literal>common-key</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">{{hub fromConfigMap "default" "test-config" "common-key" hub}}</programlisting>
</listitem>
<listitem>
<simpara>Returns a string by using the concatenated value of the <literal>.ManagedClusterName</literal> field and the string <literal>-name</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">{{hub fromConfigMap "default" "test-config" (printf "%s-name" .ManagedClusterName) hub}}</programlisting>
</listitem>
<listitem>
<simpara>Casts and returns a boolean value from the concatenated value of the <literal>.ManagedClusterName</literal> field and the string <literal>-name</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">{{hub fromConfigMap "default" "test-config" (printf "%s-name" .ManagedClusterName) | toBool hub}}</programlisting>
</listitem>
<listitem>
<simpara>Casts and returns an integer value from the concatenated value of the <literal>.ManagedClusterName</literal> field and the string <literal>-name</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">{{hub (printf "%s-name" .ManagedClusterName) | fromConfigMap "default" "test-config" | toInt hub}}</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-specifying-nics-in-pgt-crs-with-hub-cluster-templates_ztp-advanced-policy-config">
<title>Specifying group and site configuration in group PolicyGenTemplate CRs with hub templates</title>
<simpara>You can manage the configuration of fleets of clusters with <literal>ConfigMap</literal> CRs by using hub templates to populate the group and site values in the generated policies that get applied to the managed clusters.
Using hub templates in site <literal>PolicyGenTemplate</literal> (PGT) CRs means that you do not need to create a <literal>PolicyGenTemplate</literal> CR for each site.</simpara>
<simpara>You can group the clusters in a fleet in various categories, depending on the use case, for example hardware type or region.
Each cluster should have a label corresponding to the group or groups that the cluster is in.
If you manage the configuration values for each group in different <literal>ConfigMap</literal> CRs, then you require only one group <literal>PolicyGenTemplate</literal> CR to apply the changes to all the clusters in the group by using hub templates.</simpara>
<simpara>The following example shows you how to use three <literal>ConfigMap</literal> CRs and one group <literal>PolicyGenTemplate</literal> CR to apply both site and group configuration to clusters grouped by hardware type and region.</simpara>
<note>
<simpara>When you use the <literal>fromConfigmap</literal> function, the <literal>printf</literal> variable is only available for the template resource <literal>data</literal> key fields. You cannot use it with <literal>name</literal> and <literal>namespace</literal> fields.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a Git repository where you manage your custom site configuration data.
The repository must be accessible from the hub cluster and be defined as a source repository for the GitOps ZTP ArgoCD application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create three <literal>ConfigMap</literal> CRs that contain the group and site configuration:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create  a <literal>ConfigMap</literal> CR named <literal>group-hardware-types-configmap</literal> to hold the hardware-specific configuration. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: group-hardware-types-configmap
  namespace: ztp-group
  annotations:
    argocd.argoproj.io/sync-options: Replace=true <co xml:id="CO84-1"/>
data:
  # SriovNetworkNodePolicy.yaml
  hardware-type-1-sriov-node-policy-pfNames-1: "[\"ens5f0\"]"
  hardware-type-1-sriov-node-policy-pfNames-2: "[\"ens7f0\"]"
  # PerformanceProfile.yaml
  hardware-type-1-cpu-isolated: "2-31,34-63"
  hardware-type-1-cpu-reserved: "0-1,32-33"
  hardware-type-1-hugepages-default: "1G"
  hardware-type-1-hugepages-size: "1G"
  hardware-type-1-hugepages-count: "32"</programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para>The <literal>argocd.argoproj.io/sync-options</literal> annotation is required only if the <literal>ConfigMap</literal> is larger than 1 MiB in size.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create  a <literal>ConfigMap</literal> CR named <literal>group-zones-configmap</literal> to hold the regional configuration. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: group-zones-configmap
  namespace: ztp-group
data:
  # ClusterLogForwarder.yaml
  zone-1-cluster-log-fwd-outputs: "[{\"type\":\"kafka\", \"name\":\"kafka-open\", \"url\":\"tcp://10.46.55.190:9092/test\"}]"
  zone-1-cluster-log-fwd-pipelines: "[{\"inputRefs\":[\"audit\", \"infrastructure\"], \"labels\": {\"label1\": \"test1\", \"label2\": \"test2\", \"label3\": \"test3\", \"label4\": \"test4\"}, \"name\": \"all-to-default\", \"outputRefs\": [\"kafka-open\"]}]"</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ConfigMap</literal> CR named <literal>site-data-configmap</literal> to hold the site-specific configuration. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: site-data-configmap
  namespace: ztp-group
data:
  # SriovNetwork.yaml
  du-sno-1-zone-1-sriov-network-vlan-1: "140"
  du-sno-1-zone-1-sriov-network-vlan-2: "150"</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>Each <literal>ConfigMap</literal> CR must be in the same namespace as the policy to be generated from the group <literal>PolicyGenTemplate</literal> CR.</simpara>
</note>
</listitem>
<listitem>
<simpara>Commit the <literal>ConfigMap</literal> CRs in Git, and then push to the Git repository being monitored by the Argo CD application.</simpara>
</listitem>
<listitem>
<simpara>Apply the hardware type and region labels to the clusters.
The following command applies to a single cluster named <literal>du-sno-1-zone-1</literal> and the labels chosen are <literal>"hardware-type": "hardware-type-1"</literal> and <literal>"group-du-sno-zone": "zone-1"</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch managedclusters.cluster.open-cluster-management.io/du-sno-1-zone-1 --type merge -p '{"metadata":{"labels":{"hardware-type": "hardware-type-1", "group-du-sno-zone": "zone-1"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Create a group <literal>PolicyGenTemplate</literal> CR that uses hub templates to obtain the required data from the <literal>ConfigMap</literal> objects.
This example <literal>PolicyGenTemplate</literal> CR configures logging, VLAN IDs, NICs and Performance Profile for the clusters that match the labels listed under <literal>spec.bindingRules</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: group-du-sno-pgt
  namespace: ztp-group
spec:
  bindingRules:
    # These policies will correspond to all clusters with these labels
    group-du-sno-zone: "zone-1"
    hardware-type: "hardware-type-1"
  mcp: "master"
  sourceFiles:
    - fileName: ClusterLogForwarder.yaml # wave 10
      policyName: "group-du-sno-cfg-policy"
      spec:
        outputs: '{{hub fromConfigMap "" "group-zones-configmap" (printf "%s-cluster-log-fwd-outputs" (index .ManagedClusterLabels "group-du-sno-zone")) | toLiteral hub}}'
        pipelines: '{{hub fromConfigMap "" "group-zones-configmap" (printf "%s-cluster-log-fwd-pipelines" (index .ManagedClusterLabels "group-du-sno-zone")) | toLiteral hub}}'

    - fileName: PerformanceProfile.yaml # wave 10
      policyName: "group-du-sno-cfg-policy"
      metadata:
        name: openshift-node-performance-profile
      spec:
        additionalKernelArgs:
        - rcupdate.rcu_normal_after_boot=0
        - vfio_pci.enable_sriov=1
        - vfio_pci.disable_idle_d3=1
        - efi=runtime
        cpu:
          isolated: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-cpu-isolated" (index .ManagedClusterLabels "hardware-type")) hub}}'
          reserved: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-cpu-reserved" (index .ManagedClusterLabels "hardware-type")) hub}}'
        hugepages:
          defaultHugepagesSize: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-hugepages-default" (index .ManagedClusterLabels "hardware-type")) hub}}'
          pages:
            - size: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-hugepages-size" (index .ManagedClusterLabels "hardware-type")) hub}}'
              count: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-hugepages-count" (index .ManagedClusterLabels "hardware-type")) | toInt hub}}'
        realTimeKernel:
          enabled: true

    - fileName: SriovNetwork.yaml # wave 100
      policyName: "group-du-sno-sriov-policy"
      metadata:
        name: sriov-nw-du-fh
      spec:
        resourceName: du_fh
        vlan: '{{hub fromConfigMap "" "site-data-configmap" (printf "%s-sriov-network-vlan-1" .ManagedClusterName) | toInt hub}}'

    - fileName: SriovNetworkNodePolicy.yaml # wave 100
      policyName: "group-du-sno-sriov-policy"
      metadata:
        name: sriov-nnp-du-fh
      spec:
        deviceType: netdevice
        isRdma: false
        nicSelector:
          pfNames: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-sriov-node-policy-pfNames-1" (index .ManagedClusterLabels "hardware-type")) | toLiteral hub}}'
        numVfs: 8
        priority: 10
        resourceName: du_fh

    - fileName: SriovNetwork.yaml # wave 100
      policyName: "group-du-sno-sriov-policy"
      metadata:
        name: sriov-nw-du-mh
      spec:
        resourceName: du_mh
        vlan: '{{hub fromConfigMap "" "site-data-configmap" (printf "%s-sriov-network-vlan-2" .ManagedClusterName) | toInt hub}}'

    - fileName: SriovNetworkNodePolicy.yaml # wave 100
      policyName: "group-du-sno-sriov-policy"
      metadata:
        name: sriov-nw-du-fh
      spec:
        deviceType: netdevice
        isRdma: false
        nicSelector:
          pfNames: '{{hub fromConfigMap "" "group-hardware-types-configmap" (printf "%s-sriov-node-policy-pfNames-2" (index .ManagedClusterLabels "hardware-type")) | toLiteral hub}}'
        numVfs: 8
        priority: 10
        resourceName: du_fh</programlisting>
<note>
<simpara>To retrieve site-specific configuration values, use the <literal>.ManagedClusterName</literal> field.
This is a template context value set to the name of the target managed cluster.</simpara>
<simpara>To retrieve group-specific configuration, use the <literal>.ManagedClusterLabels</literal> field.
This is a template context value set to the value of the managed cluster&#8217;s labels.</simpara>
</note>
</listitem>
<listitem>
<simpara>Commit the site <literal>PolicyGenTemplate</literal> CR in Git and push to the Git repository that is monitored by the ArgoCD application.</simpara>
<note>
<simpara>Subsequent changes to the referenced <literal>ConfigMap</literal> CR are not automatically synced to the applied policies.
You need to manually sync the new <literal>ConfigMap</literal> changes to update existing <literal>PolicyGenTemplate</literal> CRs. See "Syncing new ConfigMap changes to existing PolicyGenTemplate CRs".</simpara>
<simpara>You can use the same <literal>PolicyGenTemplate</literal> CR for multiple clusters.
If there is a configuration change, then the only modifications you need to make are to the <literal>ConfigMap</literal> objects that hold the configuration for each cluster and the labels of the managed clusters.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-syncing-new-configmap-changes-to-existing-pgt-crs_ztp-advanced-policy-config">
<title>Syncing new ConfigMap changes to existing PolicyGenTemplate CRs</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in to the hub cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a <literal>PolicyGenTemplate</literal> CR that pulls information from a <literal>ConfigMap</literal> CR using hub cluster templates.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the contents of your <literal>ConfigMap</literal> CR, and apply the changes in the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>To sync the contents of the updated <literal>ConfigMap</literal> CR to the deployed policy, do either of the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Option 1: Delete the existing policy. ArgoCD uses the <literal>PolicyGenTemplate</literal> CR to immediately recreate the deleted policy. For example, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete policy &lt;policy_name&gt; -n &lt;policy_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Option 2: Apply a special annotation <literal>policy.open-cluster-management.io/trigger-update</literal> to the policy with a different value every time when you update the <literal>ConfigMap</literal>. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate policy &lt;policy_name&gt; -n &lt;policy_namespace&gt; policy.open-cluster-management.io/trigger-update="1"</programlisting>
<note>
<simpara>You must apply the updated policy for the changes to take effect. For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/governance/index#special-annotation-processing">Special annotation for reprocessing</link>.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: If it exists, delete the <literal>ClusterGroupUpdate</literal> CR that contains the policy. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clustergroupupgrade &lt;cgu_name&gt; -n &lt;cgu_namespace&gt;</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a new <literal>ClusterGroupUpdate</literal> CR that includes the policy to apply with the updated <literal>ConfigMap</literal> changes. For example, add the following YAML to the file <literal>cgr-example.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: &lt;cgr_name&gt;
  namespace: &lt;policy_namespace&gt;
spec:
  managedPolicies:
    - &lt;managed_policy&gt;
  enable: true
  clusters:
  - &lt;managed_cluster_1&gt;
  - &lt;managed_cluster_2&gt;
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240</programlisting>
</listitem>
<listitem>
<simpara>Apply the updated policy:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgr-example.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="cnf-talm-for-cluster-updates">
<title>Updating managed clusters with the Topology Aware Lifecycle Manager</title>
<simpara>You can use the Topology Aware Lifecycle Manager (TALM) to manage the software lifecycle of multiple clusters. TALM uses Red Hat Advanced Cluster Management (RHACM) policies to perform changes on the target clusters.</simpara>
<section xml:id="cnf-about-topology-aware-lifecycle-manager-config_cnf-topology-aware-lifecycle-manager">
<title>About the Topology Aware Lifecycle Manager configuration</title>
<simpara>The Topology Aware Lifecycle Manager (TALM) manages the deployment of Red Hat Advanced Cluster Management (RHACM) policies for one or more OpenShift Container Platform clusters. Using TALM in a large network of clusters allows the phased rollout of policies to the clusters in limited batches. This helps to minimize possible service disruptions when updating. With TALM, you can control the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>The timing of the update</simpara>
</listitem>
<listitem>
<simpara>The number of RHACM-managed clusters</simpara>
</listitem>
<listitem>
<simpara>The subset of managed clusters to apply the policies to</simpara>
</listitem>
<listitem>
<simpara>The update order of the clusters</simpara>
</listitem>
<listitem>
<simpara>The set of policies remediated to the cluster</simpara>
</listitem>
<listitem>
<simpara>The order of policies remediated to the cluster</simpara>
</listitem>
<listitem>
<simpara>The assignment of a canary cluster</simpara>
</listitem>
</itemizedlist>
<simpara>For single-node OpenShift, the Topology Aware Lifecycle Manager (TALM) offers the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a backup of a deployment before an upgrade</simpara>
</listitem>
<listitem>
<simpara>Pre-caching images for clusters with limited bandwidth</simpara>
</listitem>
</itemizedlist>
<simpara>TALM supports the orchestration of the OpenShift Container Platform y-stream and z-stream updates, and day-two operations on y-streams and z-streams.</simpara>
</section>
<section xml:id="cnf-about-topology-aware-lifecycle-manager-about-policies_cnf-topology-aware-lifecycle-manager">
<title>About managed policies used with Topology Aware Lifecycle Manager</title>
<simpara>The Topology Aware Lifecycle Manager (TALM) uses RHACM policies for cluster updates.</simpara>
<simpara>TALM can be used to manage the rollout of any policy CR where the <literal>remediationAction</literal> field is set to <literal>inform</literal>.
Supported use cases include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Manual user creation of policy CRs</simpara>
</listitem>
<listitem>
<simpara>Automatically generated policies from the <literal>PolicyGenTemplate</literal> custom resource definition (CRD)</simpara>
</listitem>
</itemizedlist>
<simpara>For policies that update an Operator subscription with manual approval, TALM provides additional functionality that approves the installation of the updated Operator.</simpara>
<simpara>For more information about managed policies, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html-single/governance/index#policy-overview">Policy Overview</link> in the RHACM documentation.</simpara>
<simpara>For more information about the <literal>PolicyGenTemplate</literal> CRD, see the "About the PolicyGenTemplate CRD" section in "Configuring managed clusters with policies and PolicyGenTemplate resources".</simpara>
</section>
<section xml:id="installing-topology-aware-lifecycle-manager-using-web-console_cnf-topology-aware-lifecycle-manager">
<title>Installing the Topology Aware Lifecycle Manager by using the web console</title>
<simpara>You can use the OpenShift Container Platform web console to install the Topology Aware Lifecycle Manager.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the latest version of the RHACM Operator.</simpara>
</listitem>
<listitem>
<simpara>Set up a hub cluster with disconnected regitry.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Search for the <emphasis role="strong">Topology Aware Lifecycle Manager</emphasis> from the list of available Operators, and then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Keep the default selection of <emphasis role="strong">Installation mode</emphasis> ["All namespaces on the cluster (default)"] and <emphasis role="strong">Installed Namespace</emphasis> ("openshift-operators") to ensure that the Operator is installed properly.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To confirm that the installation is successful:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Check that the Operator is installed in the <literal>All Namespaces</literal> namespace and its status is <literal>Succeeded</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If the Operator is not installed successfully:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <literal>Status</literal> column for any errors or failures.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs in any containers in the <literal>cluster-group-upgrades-controller-manager</literal> pod that are reporting issues.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="installing-topology-aware-lifecycle-manager-using-cli_cnf-topology-aware-lifecycle-manager">
<title>Installing the Topology Aware Lifecycle Manager by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to install the Topology Aware Lifecycle Manager (TALM).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Install the latest version of the RHACM Operator.</simpara>
</listitem>
<listitem>
<simpara>Set up a hub cluster with disconnected registry.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Subscription</literal> CR:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define the <literal>Subscription</literal> CR and save the YAML file, for example, <literal>talm-subscription.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-topology-aware-lifecycle-manager-subscription
  namespace: openshift-operators
spec:
  channel: "stable"
  name: topology-aware-lifecycle-manager
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f talm-subscription.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the installation succeeded by inspecting the CSV resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-operators</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                   DISPLAY                            VERSION               REPLACES                           PHASE
topology-aware-lifecycle-manager.4.14.x   Topology Aware Lifecycle Manager   4.14.x                                      Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the TALM is up and running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n openshift-operators</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE                                          NAME                                             READY   UP-TO-DATE   AVAILABLE   AGE
openshift-operators                                cluster-group-upgrades-controller-manager        1/1     1            1           14s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="talo-about-cgu-crs_cnf-topology-aware-lifecycle-manager">
<title>About the ClusterGroupUpgrade CR</title>
<simpara>The Topology Aware Lifecycle Manager (TALM) builds the remediation plan from the <literal>ClusterGroupUpgrade</literal> CR for a group of clusters. You can define the following specifications in a <literal>ClusterGroupUpgrade</literal> CR:</simpara>
<itemizedlist>
<listitem>
<simpara>Clusters in the group</simpara>
</listitem>
<listitem>
<simpara>Blocking <literal>ClusterGroupUpgrade</literal> CRs</simpara>
</listitem>
<listitem>
<simpara>Applicable list of managed policies</simpara>
</listitem>
<listitem>
<simpara>Number of concurrent updates</simpara>
</listitem>
<listitem>
<simpara>Applicable canary updates</simpara>
</listitem>
<listitem>
<simpara>Actions to perform before and after the update</simpara>
</listitem>
<listitem>
<simpara>Update timing</simpara>
</listitem>
</itemizedlist>
<simpara>You can control the start time of an update using the <literal>enable</literal> field in the <literal>ClusterGroupUpgrade</literal> CR.
For example, if you have a scheduled maintenance window of four hours, you can prepare a <literal>ClusterGroupUpgrade</literal> CR with the <literal>enable</literal> field set to <literal>false</literal>.</simpara>
<simpara>You can set the timeout by configuring the <literal>spec.remediationStrategy.timeout</literal> setting as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec
  remediationStrategy:
          maxConcurrency: 1
          timeout: 240</programlisting>
<simpara>You can use the <literal>batchTimeoutAction</literal> to determine what happens if an update fails for a cluster.
You can specify <literal>continue</literal> to skip the failing cluster and continue to upgrade other clusters, or <literal>abort</literal> to stop policy remediation for all clusters.
Once the timeout elapses, TALM removes all <literal>enforce</literal> policies to ensure that no further updates are made to clusters.</simpara>
<simpara>To apply the changes, you set the <literal>enabled</literal> field to <literal>true</literal>.</simpara>
<simpara>For more information see the "Applying update policies to managed clusters" section.</simpara>
<simpara>As TALM works through remediation of the policies to the specified clusters, the <literal>ClusterGroupUpgrade</literal> CR can report true or false statuses for a number of conditions.</simpara>
<note>
<simpara>After TALM completes a cluster update, the cluster does not update again under the control of the same <literal>ClusterGroupUpgrade</literal> CR. You must create a new <literal>ClusterGroupUpgrade</literal> CR in the following cases:</simpara>
<itemizedlist>
<listitem>
<simpara>When you need to update the cluster again</simpara>
</listitem>
<listitem>
<simpara>When the cluster changes to non-compliant with the <literal>inform</literal> policy after being updated</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="selecting_clusters_cnf-topology-aware-lifecycle-manager">
<title>Selecting clusters</title>
<simpara>TALM builds a remediation plan and selects clusters based on the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>clusterLabelSelector</literal> field specifies the labels of the clusters that you want to update. This consists of a list of the standard label selectors from <literal>k8s.io/apimachinery/pkg/apis/meta/v1</literal>. Each selector in the list uses either label value pairs or label expressions. Matches from each selector are added to the final list of clusters along with the matches from the <literal>clusterSelector</literal> field and the <literal>cluster</literal> field.</simpara>
</listitem>
<listitem>
<simpara>The <literal>clusters</literal> field specifies a list of clusters to update.</simpara>
</listitem>
<listitem>
<simpara>The <literal>canaries</literal> field specifies the clusters for canary updates.</simpara>
</listitem>
<listitem>
<simpara>The <literal>maxConcurrency</literal> field specifies the number of clusters to update in a batch.</simpara>
</listitem>
<listitem>
<simpara>The <literal>actions</literal> field specifies <literal>beforeEnable</literal> actions that TALM takes as it begins the update process, and <literal>afterCompletion</literal> actions that TALM takes as it completes policy remediation for each cluster.</simpara>
</listitem>
</itemizedlist>
<simpara>You can use the <literal>clusters</literal>, <literal>clusterLabelSelector</literal>, and <literal>clusterSelector</literal> fields together to create a combined list of clusters.</simpara>
<simpara>The remediation plan starts with the clusters listed in the <literal>canaries</literal> field. Each canary cluster forms a single-cluster batch.</simpara>
<formalpara>
<title>Sample <literal>ClusterGroupUpgrade</literal> CR with the enabled <literal>field</literal> set to <literal>false</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  creationTimestamp: '2022-11-18T16:27:15Z'
  finalizers:
    - ran.openshift.io/cleanup-finalizer
  generation: 1
  name: talm-cgu
  namespace: talm-namespace
  resourceVersion: '40451823'
  uid: cca245a5-4bca-45fa-89c0-aa6af81a596c
Spec:
  actions:
    afterCompletion: <co xml:id="CO85-1"/>
      addClusterLabels:
        upgrade-done: ""
      deleteClusterLabels:
        upgrade-running: ""
      deleteObjects: true
    beforeEnable: <co xml:id="CO85-2"/>
      addClusterLabels:
        upgrade-running: ""
  backup: false
  clusters: <co xml:id="CO85-3"/>
    - spoke1
  enable: false <co xml:id="CO85-4"/>
  managedPolicies: <co xml:id="CO85-5"/>
    - talm-policy
  preCaching: false
  remediationStrategy: <co xml:id="CO85-6"/>
    canaries: <co xml:id="CO85-7"/>
        - spoke1
    maxConcurrency: 2 <co xml:id="CO85-8"/>
    timeout: 240
  clusterLabelSelectors: <co xml:id="CO85-9"/>
    - matchExpressions:
      - key: label1
      operator: In
      values:
        - value1a
        - value1b
  batchTimeoutAction: <co xml:id="CO85-10"/>
status: <co xml:id="CO85-11"/>
    computedMaxConcurrency: 2
    conditions:
      - lastTransitionTime: '2022-11-18T16:27:15Z'
        message: All selected clusters are valid
        reason: ClusterSelectionCompleted
        status: 'True'
        type: ClustersSelected <co xml:id="CO85-12"/>
      - lastTransitionTime: '2022-11-18T16:27:15Z'
        message: Completed validation
        reason: ValidationCompleted
        status: 'True'
        type: Validated <co xml:id="CO85-13"/>
      - lastTransitionTime: '2022-11-18T16:37:16Z'
        message: Not enabled
        reason: NotEnabled
        status: 'False'
        type: Progressing
    managedPoliciesForUpgrade:
      - name: talm-policy
        namespace: talm-namespace
    managedPoliciesNs:
      talm-policy: talm-namespace
    remediationPlan:
      - - spoke1
      - - spoke2
        - spoke3
    status:</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO85-1">
<para>Specifies the action that TALM takes when it completes policy remediation for each cluster.</para>
</callout>
<callout arearefs="CO85-2">
<para>Specifies the action that TALM takes as it begins the update process.</para>
</callout>
<callout arearefs="CO85-3">
<para>Defines the list of clusters to update.</para>
</callout>
<callout arearefs="CO85-4">
<para>The <literal>enable</literal> field is set to <literal>false</literal>.</para>
</callout>
<callout arearefs="CO85-5">
<para>Lists the user-defined set of policies to remediate.</para>
</callout>
<callout arearefs="CO85-6">
<para>Defines the specifics of the cluster updates.</para>
</callout>
<callout arearefs="CO85-7">
<para>Defines the clusters for canary updates.</para>
</callout>
<callout arearefs="CO85-8">
<para>Defines the maximum number of concurrent updates in a batch. The number of remediation batches is the number of canary clusters, plus the number of clusters, except the canary clusters, divided by the <literal>maxConcurrency</literal> value. The clusters that are already compliant with all the managed policies are excluded from the remediation plan.</para>
</callout>
<callout arearefs="CO85-9">
<para>Displays the parameters for selecting clusters.</para>
</callout>
<callout arearefs="CO85-10">
<para>Controls what happens if a batch times out. Possible values are <literal>abort</literal> or <literal>continue</literal>. If unspecified, the default is <literal>continue</literal>.</para>
</callout>
<callout arearefs="CO85-11">
<para>Displays information about the status of the updates.</para>
</callout>
<callout arearefs="CO85-12">
<para>The <literal>ClustersSelected</literal> condition shows that all selected clusters are valid.</para>
</callout>
<callout arearefs="CO85-13">
<para>The <literal>Validated</literal> condition shows that all selected clusters have been validated.</para>
</callout>
</calloutlist>
<note>
<simpara>Any failures during the update of a canary cluster stops the update process.</simpara>
</note>
<simpara>When the remediation plan is successfully created, you can you set the <literal>enable</literal> field to <literal>true</literal> and TALM starts to update the non-compliant clusters with the specified managed policies.</simpara>
<note>
<simpara>You can only make changes to the <literal>spec</literal> fields if the <literal>enable</literal> field of the <literal>ClusterGroupUpgrade</literal> CR is set to <literal>false</literal>.</simpara>
</note>
</section>
<section xml:id="validating_cnf-topology-aware-lifecycle-manager">
<title>Validating</title>
<simpara>TALM checks that all specified managed policies are available and correct, and uses the <literal>Validated</literal> condition to report the status and reasons as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>Validation is completed.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Policies are missing or invalid, or an invalid platform image has been specified.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="precaching_cnf-topology-aware-lifecycle-manager">
<title>Pre-caching</title>
<simpara>Clusters might have limited bandwidth to access the container image registry, which can cause a timeout before the updates are completed. On single-node OpenShift clusters, you can use pre-caching to avoid this. The container image pre-caching starts when you create a <literal>ClusterGroupUpgrade</literal> CR with the <literal>preCaching</literal> field set to <literal>true</literal>.
TALM compares the available disk space with the estimated OpenShift Container Platform image size to ensure that there is enough space. If a cluster has insufficient space, TALM cancels pre-caching for that cluster and does not remediate policies on it.</simpara>
<simpara>TALM uses the <literal>PrecacheSpecValid</literal> condition to report status information as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>The pre-caching spec is valid and consistent.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>The pre-caching spec is incomplete.</simpara>
</listitem>
</itemizedlist>
<simpara>TALM uses the <literal>PrecachingSucceeded</literal> condition to report status information as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>TALM has concluded the pre-caching process. If pre-caching fails for any cluster, the update fails for that cluster but proceeds for all other clusters. A message informs you if pre-caching has failed for any clusters.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Pre-caching is still in progress for one or more clusters or has failed for all clusters.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information see the "Using the container image pre-cache feature" section.</simpara>
</section>
<section xml:id="creating_backup_cnf-topology-aware-lifecycle-manager">
<title>Creating a backup</title>
<simpara>For single-node OpenShift, TALM can create a backup of a deployment before an update. If the update fails, you can recover the previous version and restore a cluster to a working state without requiring a reprovision of applications. To use the backup feature you first create a <literal>ClusterGroupUpgrade</literal> CR with the <literal>backup</literal> field set to <literal>true</literal>. To ensure that the contents of the backup are up to date, the backup is not taken until you set the <literal>enable</literal> field in the <literal>ClusterGroupUpgrade</literal> CR to <literal>true</literal>.</simpara>
<simpara>TALM uses the <literal>BackupSucceeded</literal> condition to report the status and reasons as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>Backup is completed for all clusters or the backup run has completed but failed for one or more clusters. If backup fails for any cluster, the update fails for that cluster but proceeds for all other clusters.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Backup is still in progress for one or more clusters or has failed for all clusters.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see the "Creating a backup of cluster resources before upgrade" section.</simpara>
</section>
<section xml:id="updating_clusters_cnf-topology-aware-lifecycle-manager">
<title>Updating clusters</title>
<simpara>TALM enforces the policies following the remediation plan.
Enforcing the policies for subsequent batches starts immediately after all the clusters of the current batch are compliant with all the managed policies. If the batch times out, TALM moves on to the next batch. The timeout value of a batch is the <literal>spec.timeout</literal> field divided by the number of batches in the remediation plan.</simpara>
<simpara>TALM uses the <literal>Progressing</literal> condition to report the status and reasons as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>TALM is remediating non-compliant policies.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>The update is not in progress. Possible reasons for this are:</simpara>
<itemizedlist>
<listitem>
<simpara>All clusters are compliant with all the managed policies.</simpara>
</listitem>
<listitem>
<simpara>The update has timed out as policy remediation took too long.</simpara>
</listitem>
<listitem>
<simpara>Blocking CRs are missing from the system or have not yet completed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ClusterGroupUpgrade</literal> CR is not enabled.</simpara>
</listitem>
<listitem>
<simpara>Backup is still in progress.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>The managed policies apply in the order that they are listed in the <literal>managedPolicies</literal> field in the <literal>ClusterGroupUpgrade</literal> CR. One managed policy is applied to the specified clusters at a time. When a cluster complies with the current policy, the next managed policy is applied to it.</simpara>
</note>
<formalpara>
<title>Sample <literal>ClusterGroupUpgrade</literal> CR in the <literal>Progressing</literal> state</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  creationTimestamp: '2022-11-18T16:27:15Z'
  finalizers:
    - ran.openshift.io/cleanup-finalizer
  generation: 1
  name: talm-cgu
  namespace: talm-namespace
  resourceVersion: '40451823'
  uid: cca245a5-4bca-45fa-89c0-aa6af81a596c
Spec:
  actions:
    afterCompletion:
      deleteObjects: true
    beforeEnable: {}
  backup: false
  clusters:
    - spoke1
  enable: true
  managedPolicies:
    - talm-policy
  preCaching: true
  remediationStrategy:
    canaries:
        - spoke1
    maxConcurrency: 2
    timeout: 240
  clusterLabelSelectors:
    - matchExpressions:
      - key: label1
      operator: In
      values:
        - value1a
        - value1b
  batchTimeoutAction:
status:
    clusters:
      - name: spoke1
        state: complete
    computedMaxConcurrency: 2
    conditions:
      - lastTransitionTime: '2022-11-18T16:27:15Z'
        message: All selected clusters are valid
        reason: ClusterSelectionCompleted
        status: 'True'
        type: ClustersSelected
      - lastTransitionTime: '2022-11-18T16:27:15Z'
        message: Completed validation
        reason: ValidationCompleted
        status: 'True'
        type: Validated
      - lastTransitionTime: '2022-11-18T16:37:16Z'
        message: Remediating non-compliant policies
        reason: InProgress
        status: 'True'
        type: Progressing <co xml:id="CO86-1"/>
    managedPoliciesForUpgrade:
      - name: talm-policy
        namespace: talm-namespace
    managedPoliciesNs:
      talm-policy: talm-namespace
    remediationPlan:
      - - spoke1
      - - spoke2
        - spoke3
    status:
      currentBatch: 2
      currentBatchRemediationProgress:
        spoke2:
          state: Completed
        spoke3:
          policyIndex: 0
          state: InProgress
      currentBatchStartedAt: '2022-11-18T16:27:16Z'
      startedAt: '2022-11-18T16:27:15Z'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO86-1">
<para>The <literal>Progressing</literal> fields show that TALM is in the process of remediating policies.</para>
</callout>
</calloutlist>
</section>
<section xml:id="update_status_cnf-topology-aware-lifecycle-manager">
<title>Update status</title>
<simpara>TALM uses the <literal>Succeeded</literal> condition to report the status and reasons as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>All clusters are compliant with the specified managed policies.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Policy remediation failed as there were no clusters available for remediation, or because policy remediation took too long for one of the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>The current batch contains canary updates and the cluster in the batch does not comply with all the managed policies within the batch timeout.</simpara>
</listitem>
<listitem>
<simpara>Clusters did not comply with the managed policies within the <literal>timeout</literal> value specified in the <literal>remediationStrategy</literal> field.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<formalpara>
<title>Sample <literal>ClusterGroupUpgrade</literal> CR in the <literal>Succeeded</literal> state</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: ran.openshift.io/v1alpha1
    kind: ClusterGroupUpgrade
    metadata:
      name: cgu-upgrade-complete
      namespace: default
    spec:
      clusters:
      - spoke1
      - spoke4
      enable: true
      managedPolicies:
      - policy1-common-cluster-version-policy
      - policy2-common-pao-sub-policy
      remediationStrategy:
        maxConcurrency: 1
        timeout: 240
    status: <co xml:id="CO87-1"/>
      clusters:
        - name: spoke1
          state: complete
        - name: spoke4
          state: complete
      conditions:
      - message: All selected clusters are valid
        reason: ClusterSelectionCompleted
        status: "True"
        type: ClustersSelected
      - message: Completed validation
        reason: ValidationCompleted
        status: "True"
        type: Validated
      - message: All clusters are compliant with all the managed policies
        reason: Completed
        status: "False"
        type: Progressing <co xml:id="CO87-2"/>
      - message: All clusters are compliant with all the managed policies
        reason: Completed
        status: "True"
        type: Succeeded <co xml:id="CO87-3"/>
      managedPoliciesForUpgrade:
      - name: policy1-common-cluster-version-policy
        namespace: default
      - name: policy2-common-pao-sub-policy
        namespace: default
      remediationPlan:
      - - spoke1
      - - spoke4
      status:
        completedAt: '2022-11-18T16:27:16Z'
        startedAt: '2022-11-18T16:27:15Z'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO87-2">
<para>In the <literal>Progressing</literal> fields, the status is <literal>false</literal> as the update has completed; clusters are compliant with all the managed policies.</para>
</callout>
<callout arearefs="CO87-3">
<para>The <literal>Succeeded</literal> fields show that the validations completed successfully.</para>
</callout>
<callout arearefs="CO87-1">
<para>The <literal>status</literal> field includes a list of clusters and their respective statuses. The status of a cluster can be <literal>complete</literal> or <literal>timedout</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Sample <literal>ClusterGroupUpgrade</literal> CR in the <literal>timedout</literal> state</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  creationTimestamp: '2022-11-18T16:27:15Z'
  finalizers:
    - ran.openshift.io/cleanup-finalizer
  generation: 1
  name: talm-cgu
  namespace: talm-namespace
  resourceVersion: '40451823'
  uid: cca245a5-4bca-45fa-89c0-aa6af81a596c
spec:
  actions:
    afterCompletion:
      deleteObjects: true
    beforeEnable: {}
  backup: false
  clusters:
    - spoke1
    - spoke2
  enable: true
  managedPolicies:
    - talm-policy
  preCaching: false
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240
status:
  clusters:
    - name: spoke1
      state: complete
    - currentPolicy: <co xml:id="CO88-1"/>
        name: talm-policy
        status: NonCompliant
      name: spoke2
      state: timedout
  computedMaxConcurrency: 2
  conditions:
    - lastTransitionTime: '2022-11-18T16:27:15Z'
      message: All selected clusters are valid
      reason: ClusterSelectionCompleted
      status: 'True'
      type: ClustersSelected
    - lastTransitionTime: '2022-11-18T16:27:15Z'
      message: Completed validation
      reason: ValidationCompleted
      status: 'True'
      type: Validated
    - lastTransitionTime: '2022-11-18T16:37:16Z'
      message: Policy remediation took too long
      reason: TimedOut
      status: 'False'
      type: Progressing
    - lastTransitionTime: '2022-11-18T16:37:16Z'
      message: Policy remediation took too long
      reason: TimedOut
      status: 'False'
      type: Succeeded <co xml:id="CO88-2"/>
  managedPoliciesForUpgrade:
    - name: talm-policy
      namespace: talm-namespace
  managedPoliciesNs:
    talm-policy: talm-namespace
  remediationPlan:
    - - spoke1
      - spoke2
  status:
        startedAt: '2022-11-18T16:27:15Z'
        completedAt: '2022-11-18T20:27:15Z'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO88-1">
<para>If a clusters state is <literal>timedout</literal>, the <literal>currentPolicy</literal> field shows the name of the policy and the policy status.</para>
</callout>
<callout arearefs="CO88-2">
<para>The status for <literal>succeeded</literal> is <literal>false</literal> and the message indicates that policy remediation took too long.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cnf-about-topology-aware-lifecycle-manager-blocking-crs_cnf-topology-aware-lifecycle-manager">
<title>Blocking ClusterGroupUpgrade CRs</title>
<simpara>You can create multiple <literal>ClusterGroupUpgrade</literal> CRs and control their order of application.</simpara>
<simpara>For example, if you create <literal>ClusterGroupUpgrade</literal> CR C that blocks the start of <literal>ClusterGroupUpgrade</literal> CR A, then <literal>ClusterGroupUpgrade</literal> CR A cannot start until the status of <literal>ClusterGroupUpgrade</literal> CR C becomes <literal>UpgradeComplete</literal>.</simpara>
<simpara>One <literal>ClusterGroupUpgrade</literal> CR can have multiple blocking CRs. In this case, all the blocking CRs must complete before the upgrade for the current CR can start.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create RHACM policies in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Save the content of the <literal>ClusterGroupUpgrade</literal> CRs in the <literal>cgu-a.yaml</literal>, <literal>cgu-b.yaml</literal>, and <literal>cgu-c.yaml</literal> files.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-a
  namespace: default
spec:
  blockingCRs: <co xml:id="CO89-1"/>
  - name: cgu-c
    namespace: default
  clusters:
  - spoke1
  - spoke2
  - spoke3
  enable: false
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  remediationStrategy:
    canaries:
    - spoke1
    maxConcurrency: 2
    timeout: 240
status:
  conditions:
  - message: The ClusterGroupUpgrade CR is not enabled
    reason: UpgradeNotStarted
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy2-common-pao-sub-policy
    namespace: default
  - name: policy3-common-ptp-sub-policy
    namespace: default
  placementBindings:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  placementRules:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  remediationPlan:
  - - spoke1
  - - spoke2</programlisting>
<calloutlist>
<callout arearefs="CO89-1">
<para>Defines the blocking CRs. The <literal>cgu-a</literal> update cannot start until <literal>cgu-c</literal> is complete.</para>
</callout>
</calloutlist>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-b
  namespace: default
spec:
  blockingCRs: <co xml:id="CO90-1"/>
  - name: cgu-a
    namespace: default
  clusters:
  - spoke4
  - spoke5
  enable: false
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  - policy4-common-sriov-sub-policy
  remediationStrategy:
    maxConcurrency: 1
    timeout: 240
status:
  conditions:
  - message: The ClusterGroupUpgrade CR is not enabled
    reason: UpgradeNotStarted
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy2-common-pao-sub-policy
    namespace: default
  - name: policy3-common-ptp-sub-policy
    namespace: default
  - name: policy4-common-sriov-sub-policy
    namespace: default
  placementBindings:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  placementRules:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  remediationPlan:
  - - spoke4
  - - spoke5
  status: {}</programlisting>
<calloutlist>
<callout arearefs="CO90-1">
<para>The <literal>cgu-b</literal> update cannot start until <literal>cgu-a</literal> is complete.</para>
</callout>
</calloutlist>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-c
  namespace: default
spec: <co xml:id="CO91-1"/>
  clusters:
  - spoke6
  enable: false
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  - policy4-common-sriov-sub-policy
  remediationStrategy:
    maxConcurrency: 1
    timeout: 240
status:
  conditions:
  - message: The ClusterGroupUpgrade CR is not enabled
    reason: UpgradeNotStarted
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  managedPoliciesCompliantBeforeUpgrade:
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy4-common-sriov-sub-policy
    namespace: default
  placementBindings:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  placementRules:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  remediationPlan:
  - - spoke6
  status: {}</programlisting>
<calloutlist>
<callout arearefs="CO91-1">
<para>The <literal>cgu-c</literal> update does not have any blocking CRs. TALM starts the <literal>cgu-c</literal> update when the <literal>enable</literal> field is set to <literal>true</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpgrade</literal> CRs by running the following command for each relevant CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Start the update process by running the following command for each relevant CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/&lt;name&gt; \
--type merge -p '{"spec":{"enable":true}}'</programlisting>
<simpara>The following examples show <literal>ClusterGroupUpgrade</literal> CRs where the <literal>enable</literal> field is set to <literal>true</literal>:</simpara>
<formalpara>
<title>Example for <literal>cgu-a</literal> with blocking CRs</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-a
  namespace: default
spec:
  blockingCRs:
  - name: cgu-c
    namespace: default
  clusters:
  - spoke1
  - spoke2
  - spoke3
  enable: true
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  remediationStrategy:
    canaries:
    - spoke1
    maxConcurrency: 2
    timeout: 240
status:
  conditions:
  - message: 'The ClusterGroupUpgrade CR is blocked by other CRs that have not yet
      completed: [cgu-c]' <co xml:id="CO92-1"/>
    reason: UpgradeCannotStart
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy2-common-pao-sub-policy
    namespace: default
  - name: policy3-common-ptp-sub-policy
    namespace: default
  placementBindings:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  placementRules:
  - cgu-a-policy1-common-cluster-version-policy
  - cgu-a-policy2-common-pao-sub-policy
  - cgu-a-policy3-common-ptp-sub-policy
  remediationPlan:
  - - spoke1
  - - spoke2
  status: {}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO92-1">
<para>Shows the list of blocking CRs.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example for <literal>cgu-b</literal> with blocking CRs</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-b
  namespace: default
spec:
  blockingCRs:
  - name: cgu-a
    namespace: default
  clusters:
  - spoke4
  - spoke5
  enable: true
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  - policy4-common-sriov-sub-policy
  remediationStrategy:
    maxConcurrency: 1
    timeout: 240
status:
  conditions:
  - message: 'The ClusterGroupUpgrade CR is blocked by other CRs that have not yet
      completed: [cgu-a]' <co xml:id="CO93-1"/>
    reason: UpgradeCannotStart
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy2-common-pao-sub-policy
    namespace: default
  - name: policy3-common-ptp-sub-policy
    namespace: default
  - name: policy4-common-sriov-sub-policy
    namespace: default
  placementBindings:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  placementRules:
  - cgu-b-policy1-common-cluster-version-policy
  - cgu-b-policy2-common-pao-sub-policy
  - cgu-b-policy3-common-ptp-sub-policy
  - cgu-b-policy4-common-sriov-sub-policy
  remediationPlan:
  - - spoke4
  - - spoke5
  status: {}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO93-1">
<para>Shows the list of blocking CRs.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example for <literal>cgu-c</literal> with blocking CRs</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-c
  namespace: default
spec:
  clusters:
  - spoke6
  enable: true
  managedPolicies:
  - policy1-common-cluster-version-policy
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  - policy4-common-sriov-sub-policy
  remediationStrategy:
    maxConcurrency: 1
    timeout: 240
status:
  conditions:
  - message: The ClusterGroupUpgrade CR has upgrade policies that are still non compliant <co xml:id="CO94-1"/>
    reason: UpgradeNotCompleted
    status: "False"
    type: Ready
  copiedPolicies:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  managedPoliciesCompliantBeforeUpgrade:
  - policy2-common-pao-sub-policy
  - policy3-common-ptp-sub-policy
  managedPoliciesForUpgrade:
  - name: policy1-common-cluster-version-policy
    namespace: default
  - name: policy4-common-sriov-sub-policy
    namespace: default
  placementBindings:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  placementRules:
  - cgu-c-policy1-common-cluster-version-policy
  - cgu-c-policy4-common-sriov-sub-policy
  remediationPlan:
  - - spoke6
  status:
    currentBatch: 1
    remediationPlanForBatch:
      spoke6: 0</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO94-1">
<para>The <literal>cgu-c</literal> update does not have any blocking CRs.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="talo-policies-concept_cnf-topology-aware-lifecycle-manager">
<title>Update policies on managed clusters</title>
<simpara>The Topology Aware Lifecycle Manager (TALM) remediates a set of <literal>inform</literal> policies for the clusters specified in the <literal>ClusterGroupUpgrade</literal> CR. TALM remediates <literal>inform</literal> policies by making <literal>enforce</literal> copies of the managed RHACM policies. Each copied policy has its own corresponding RHACM placement rule and RHACM placement binding.</simpara>
<simpara>One by one, TALM adds each cluster from the current batch to the placement rule that corresponds with the applicable managed policy. If a cluster is already compliant with a policy, TALM skips applying that policy on the compliant cluster. TALM then moves on to applying the next policy to the non-compliant cluster. After TALM completes the updates in a batch, all clusters are removed from the placement rules associated with the copied policies. Then, the update of the next batch starts.</simpara>
<simpara>If a spoke cluster does not report any compliant state to RHACM, the managed policies on the hub cluster can be missing status information that TALM needs. TALM handles these cases in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>If a policy&#8217;s <literal>status.compliant</literal> field is missing, TALM ignores the policy and adds a log entry. Then, TALM continues looking at the policy&#8217;s <literal>status.status</literal> field.</simpara>
</listitem>
<listitem>
<simpara>If a policy&#8217;s <literal>status.status</literal> is missing, TALM produces an error.</simpara>
</listitem>
<listitem>
<simpara>If a cluster&#8217;s compliance status is missing in the policy&#8217;s <literal>status.status</literal> field, TALM considers that cluster to be non-compliant with that policy.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>ClusterGroupUpgrade</literal> CR&#8217;s <literal>batchTimeoutAction</literal> determines what happens if an upgrade fails for a cluster. You can specify <literal>continue</literal> to skip the failing cluster and continue to upgrade other clusters, or specify <literal>abort</literal> to stop the policy remediation for all clusters. Once the timeout elapses, TALM removes all enforce policies to ensure that no further updates are made to clusters.</simpara>
<formalpara>
<title>Example upgrade policy</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: ocp-4.9.4
  namespace: platform-upgrade
spec:
  disabled: false
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: upgrade
      spec:
        namespaceselector:
          exclude:
          - kube-*
          include:
          - '*'
        object-templates:
        - complianceType: musthave
          objectDefinition:
            apiVersion: config.openshift.io/v1
            kind: ClusterVersion
            metadata:
              name: version
            spec:
              channel: stable-4.9
              desiredUpdate:
                version: 4.9.4
              upstream: https://api.openshift.com/api/upgrades_info/v1/graph
            status:
              history:
                - state: Completed
                  version: 4.9.4
        remediationAction: inform
        severity: low
  remediationAction: inform</programlisting>
</para>
</formalpara>
<simpara>For more information about RHACM policies, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html-single/governance/index#policy-overview">Policy overview</link>.</simpara>
<formalpara role="_additional-resources">
<title>Additional resources</title>
<para>For more information about the <literal>PolicyGenTemplate</literal> CRD, see <link linkend="ztp-the-policygentemplate_ztp-configuring-managed-clusters-policies">About the PolicyGenTemplate CRD</link>.</para>
</formalpara>
<section xml:id="talo-about-subscription-crs_cnf-topology-aware-lifecycle-manager">
<title>Configuring Operator subscriptions for managed clusters that you install with TALM</title>
<simpara>Topology Aware Lifecycle Manager (TALM) can only approve the install plan for an Operator if the <literal>Subscription</literal> custom resource (CR) of the Operator contains the <literal>status.state.AtLatestKnown</literal> field.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>status.state.AtLatestKnown</literal> field to the <literal>Subscription</literal> CR of the Operator:</simpara>
<formalpara>
<title>Example Subscription CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: cluster-logging
  namespace: openshift-logging
  annotations:
    ran.openshift.io/ztp-deploy-wave: "2"
spec:
  channel: "stable"
  name: cluster-logging
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  installPlanApproval: Manual
status:
  state: AtLatestKnown <co xml:id="CO95-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO95-1">
<para>The <literal>status.state: AtLatestKnown</literal> field is used for the latest Operator version available from the Operator catalog.</para>
</callout>
</calloutlist>
<note>
<simpara>When a new version of the Operator is available in the registry, the associated policy becomes non-compliant.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply the changed <literal>Subscription</literal> policy to your managed clusters with a <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="talo-apply-policies_cnf-topology-aware-lifecycle-manager">
<title>Applying update policies to managed clusters</title>
<simpara>You can update your managed clusters by applying your policies.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create RHACM policies in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Save the contents of the <literal>ClusterGroupUpgrade</literal> CR in the <literal>cgu-1.yaml</literal> file.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-1
  namespace: default
spec:
  managedPolicies: <co xml:id="CO96-1"/>
    - policy1-common-cluster-version-policy
    - policy2-common-nto-sub-policy
    - policy3-common-ptp-sub-policy
    - policy4-common-sriov-sub-policy
  enable: false
  clusters: <co xml:id="CO96-2"/>
  - spoke1
  - spoke2
  - spoke5
  - spoke6
  remediationStrategy:
    maxConcurrency: 2 <co xml:id="CO96-3"/>
    timeout: 240 <co xml:id="CO96-4"/>
  batchTimeoutAction: <co xml:id="CO96-5"/></programlisting>
<calloutlist>
<callout arearefs="CO96-1">
<para>The name of the policies to apply.</para>
</callout>
<callout arearefs="CO96-2">
<para>The list of clusters to update.</para>
</callout>
<callout arearefs="CO96-3">
<para>The <literal>maxConcurrency</literal> field signifies the number of clusters updated at the same time.</para>
</callout>
<callout arearefs="CO96-4">
<para>The update timeout in minutes.</para>
</callout>
<callout arearefs="CO96-5">
<para>Controls what happens if a batch times out. Possible values are <literal>abort</literal> or <literal>continue</literal>. If unspecified, the default is <literal>continue</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cgu-1.yaml</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check if the <literal>ClusterGroupUpgrade</literal> CR was created in the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu --all-namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE   NAME  AGE  STATE      DETAILS
default     cgu-1 8m55 NotEnabled Not Enabled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of the update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n default cgu-1 -ojsonpath='{.status}' | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "computedMaxConcurrency": 2,
  "conditions": [
    {
      "lastTransitionTime": "2022-02-25T15:34:07Z",
      "message": "Not enabled", <co xml:id="CO97-1"/>
      "reason": "NotEnabled",
      "status": "False",
      "type": "Progressing"
    }
  ],
  "copiedPolicies": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "managedPoliciesContent": {
    "policy1-common-cluster-version-policy": "null",
    "policy2-common-nto-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"node-tuning-operator\",\"namespace\":\"openshift-cluster-node-tuning-operator\"}]",
    "policy3-common-ptp-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"ptp-operator-subscription\",\"namespace\":\"openshift-ptp\"}]",
    "policy4-common-sriov-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"sriov-network-operator-subscription\",\"namespace\":\"openshift-sriov-network-operator\"}]"
  },
  "managedPoliciesForUpgrade": [
    {
      "name": "policy1-common-cluster-version-policy",
      "namespace": "default"
    },
    {
      "name": "policy2-common-nto-sub-policy",
      "namespace": "default"
    },
    {
      "name": "policy3-common-ptp-sub-policy",
      "namespace": "default"
    },
    {
      "name": "policy4-common-sriov-sub-policy",
      "namespace": "default"
    }
  ],
  "managedPoliciesNs": {
    "policy1-common-cluster-version-policy": "default",
    "policy2-common-nto-sub-policy": "default",
    "policy3-common-ptp-sub-policy": "default",
    "policy4-common-sriov-sub-policy": "default"
  },
  "placementBindings": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "placementRules": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "precaching": {
    "spec": {}
  },
  "remediationPlan": [
    [
      "spoke1",
      "spoke2"
    ],
    [
      "spoke5",
      "spoke6"
    ]
  ],
  "status": {}
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO97-1">
<para>The <literal>spec.enable</literal> field in the <literal>ClusterGroupUpgrade</literal> CR is set to <literal>false</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the status of the policies by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies -A</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE   NAME                                                 REMEDIATION ACTION   COMPLIANCE STATE   AGE
default     cgu-policy1-common-cluster-version-policy            enforce                                 17m <co xml:id="CO98-1"/>
default     cgu-policy2-common-nto-sub-policy                    enforce                                 17m
default     cgu-policy3-common-ptp-sub-policy                    enforce                                 17m
default     cgu-policy4-common-sriov-sub-policy                  enforce                                 17m
default     policy1-common-cluster-version-policy                inform               NonCompliant       15h
default     policy2-common-nto-sub-policy                        inform               NonCompliant       15h
default     policy3-common-ptp-sub-policy                        inform               NonCompliant       18m
default     policy4-common-sriov-sub-policy                      inform               NonCompliant       18m</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO98-1">
<para>The <literal>spec.remediationAction</literal> field of policies currently applied on the clusters is set to <literal>enforce</literal>. The managed policies in <literal>inform</literal> mode from the <literal>ClusterGroupUpgrade</literal> CR remain in <literal>inform</literal> mode during the update.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Change the value of the <literal>spec.enable</literal> field to <literal>true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-1 \
--patch '{"spec":{"enable":true}}' --type=merge</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the status of the update again by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n default cgu-1 -ojsonpath='{.status}' | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "computedMaxConcurrency": 2,
  "conditions": [ <co xml:id="CO99-1"/>
    {
      "lastTransitionTime": "2022-02-25T15:33:07Z",
      "message": "All selected clusters are valid",
      "reason": "ClusterSelectionCompleted",
      "status": "True",
      "type": "ClustersSelected",
      "lastTransitionTime": "2022-02-25T15:33:07Z",
      "message": "Completed validation",
      "reason": "ValidationCompleted",
      "status": "True",
      "type": "Validated",
      "lastTransitionTime": "2022-02-25T15:34:07Z",
      "message": "Remediating non-compliant policies",
      "reason": "InProgress",
      "status": "True",
      "type": "Progressing"
    }
  ],
  "copiedPolicies": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "managedPoliciesContent": {
    "policy1-common-cluster-version-policy": "null",
    "policy2-common-nto-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"node-tuning-operator\",\"namespace\":\"openshift-cluster-node-tuning-operator\"}]",
    "policy3-common-ptp-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"ptp-operator-subscription\",\"namespace\":\"openshift-ptp\"}]",
    "policy4-common-sriov-sub-policy": "[{\"kind\":\"Subscription\",\"name\":\"sriov-network-operator-subscription\",\"namespace\":\"openshift-sriov-network-operator\"}]"
  },
  "managedPoliciesForUpgrade": [
    {
      "name": "policy1-common-cluster-version-policy",
      "namespace": "default"
    },
    {
      "name": "policy2-common-nto-sub-policy",
      "namespace": "default"
    },
    {
      "name": "policy3-common-ptp-sub-policy",
      "namespace": "default"
    },
    {
      "name": "policy4-common-sriov-sub-policy",
      "namespace": "default"
    }
  ],
  "managedPoliciesNs": {
    "policy1-common-cluster-version-policy": "default",
    "policy2-common-nto-sub-policy": "default",
    "policy3-common-ptp-sub-policy": "default",
    "policy4-common-sriov-sub-policy": "default"
  },
  "placementBindings": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "placementRules": [
    "cgu-policy1-common-cluster-version-policy",
    "cgu-policy2-common-nto-sub-policy",
    "cgu-policy3-common-ptp-sub-policy",
    "cgu-policy4-common-sriov-sub-policy"
  ],
  "precaching": {
    "spec": {}
  },
  "remediationPlan": [
    [
      "spoke1",
      "spoke2"
    ],
    [
      "spoke5",
      "spoke6"
    ]
  ],
  "status": {
    "currentBatch": 1,
    "currentBatchStartedAt": "2022-02-25T15:54:16Z",
    "remediationPlanForBatch": {
      "spoke1": 0,
      "spoke2": 1
    },
    "startedAt": "2022-02-25T15:54:16Z"
  }
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO99-1">
<para>Reflects the update progress of the current batch. Run this command again to receive updated information about the progress.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If the policies include Operator subscriptions, you can check the installation progress directly on the single-node cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the <literal>KUBECONFIG</literal> file of the single-node cluster you want to check the installation progress for by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export KUBECONFIG=&lt;cluster_kubeconfig_absolute_path&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check all the subscriptions present on the single-node cluster and look for the one in the policy you are trying to install through the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subs -A | grep -i &lt;subscription_name&gt;</programlisting>
<formalpara>
<title>Example output for <literal>cluster-logging</literal> policy</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE                              NAME                         PACKAGE                      SOURCE             CHANNEL
openshift-logging                      cluster-logging              cluster-logging              redhat-operators   stable</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If one of the managed policies includes a <literal>ClusterVersion</literal> CR, check the status of platform updates in the current batch by running the following command against the spoke cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      VERSION   AVAILABLE   PROGRESSING   SINCE   STATUS
version   4.9.5     True        True          43s     Working towards 4.9.7: 71 of 735 done (9% complete)</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the Operator subscription by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subs -n &lt;operator-namespace&gt; &lt;operator-subscription&gt; -ojsonpath="{.status}"</programlisting>
</listitem>
<listitem>
<simpara>Check the install plans present on the single-node cluster that is associated with the desired subscription by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get installplan -n &lt;subscription_namespace&gt;</programlisting>
<formalpara>
<title>Example output for <literal>cluster-logging</literal> Operator</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE                              NAME            CSV                                 APPROVAL   APPROVED
openshift-logging                      install-6khtw   cluster-logging.5.3.3-4             Manual     true <co xml:id="CO100-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO100-1">
<para>The install plans have their <literal>Approval</literal> field set to <literal>Manual</literal> and their <literal>Approved</literal> field changes from <literal>false</literal> to <literal>true</literal> after TALM approves the install plan.</para>
</callout>
</calloutlist>
<note>
<simpara>When TALM is remediating a policy containing a subscription, it automatically approves any install plans attached to that subscription.
Where multiple install plans are needed to get the operator to the latest known version, TALM might approve multiple install plans, upgrading through one or more intermediate versions to get to the final version.</simpara>
</note>
</listitem>
<listitem>
<simpara>Check if the cluster service version for the Operator of the policy that the <literal>ClusterGroupUpgrade</literal> is installing reached the <literal>Succeeded</literal> phase by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n &lt;operator_namespace&gt;</programlisting>
<formalpara>
<title>Example output for OpenShift Logging Operator</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    DISPLAY                     VERSION   REPLACES   PHASE
cluster-logging.5.4.2   Red Hat OpenShift Logging   5.4.2                Succeeded</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="talo-backup-feature-concept_cnf-topology-aware-lifecycle-manager">
<title>Creating a backup of cluster resources before upgrade</title>
<simpara>For single-node OpenShift, the Topology Aware Lifecycle Manager (TALM) can create a backup of a deployment before an upgrade. If the upgrade fails, you can recover the previous version and restore a cluster to a working state without requiring a reprovision of applications.</simpara>
<simpara>To use the backup feature you first create a <literal>ClusterGroupUpgrade</literal> CR with the <literal>backup</literal> field set to <literal>true</literal>. To ensure that the contents of the backup are up to date, the backup is not taken until you set the <literal>enable</literal> field in the <literal>ClusterGroupUpgrade</literal> CR to <literal>true</literal>.</simpara>
<simpara>TALM uses the <literal>BackupSucceeded</literal> condition to report the status and reasons as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>Backup is completed for all clusters or the backup run has completed but failed for one or more clusters. If backup fails for any cluster, the update does not proceed for that cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Backup is still in progress for one or more clusters or has failed for all clusters. The backup process running in the spoke clusters can have the following statuses:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>PreparingToStart</literal></simpara>
<simpara>The first reconciliation pass is in progress. The TALM deletes any spoke backup namespace and hub view resources that have been created in a failed upgrade attempt.</simpara>
</listitem>
<listitem>
<simpara><literal>Starting</literal></simpara>
<simpara>The backup prerequisites and backup job are being created.</simpara>
</listitem>
<listitem>
<simpara><literal>Active</literal></simpara>
<simpara>The backup is in progress.</simpara>
</listitem>
<listitem>
<simpara><literal>Succeeded</literal></simpara>
<simpara>The backup succeeded.</simpara>
</listitem>
<listitem>
<simpara><literal>BackupTimeout</literal></simpara>
<simpara>Artifact backup is partially done.</simpara>
</listitem>
<listitem>
<simpara><literal>UnrecoverableError</literal></simpara>
<simpara>The backup has ended with a non-zero exit code.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>If the backup of a cluster fails and enters the <literal>BackupTimeout</literal> or <literal>UnrecoverableError</literal> state, the cluster update does not proceed for that cluster. Updates to other clusters are not affected and continue.</simpara>
</note>
<section xml:id="talo-backup-start_and_update_cnf-topology-aware-lifecycle-manager">
<title>Creating a ClusterGroupUpgrade CR with backup</title>
<simpara>You can create a backup of a deployment before an upgrade on single-node OpenShift clusters. If the upgrade fails you can use the <literal>upgrade-recovery.sh</literal> script generated by Topology Aware Lifecycle Manager (TALM) to return the system to its preupgrade state.
The backup consists of the following items:</simpara>
<variablelist>
<varlistentry>
<term>Cluster backup</term>
<listitem>
<simpara>A snapshot of <literal>etcd</literal> and static pod manifests.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Content backup</term>
<listitem>
<simpara>Backups of folders, for example, <literal>/etc</literal>, <literal>/usr/local</literal>, <literal>/var/lib/kubelet</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Changed files backup</term>
<listitem>
<simpara>Any files managed by <literal>machine-config</literal> that have been changed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deployment</term>
<listitem>
<simpara>A pinned <literal>ostree</literal> deployment.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Images (Optional)</term>
<listitem>
<simpara>Any container images that are in use.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Install Red Hat Advanced Cluster Management (RHACM).</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It is highly recommended that you create a recovery partition.
The following is an example <literal>SiteConfig</literal> custom resource (CR) for a recovery partition of 50 GB:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">nodes:
    - hostName: "node-1.example.com"
    role: "master"
    rootDeviceHints:
        hctl: "0:2:0:0"
        deviceName: /dev/disk/by-id/scsi-3600508b400105e210000900000490000
...
    #Disk /dev/disk/by-id/scsi-3600508b400105e210000900000490000:
    #893.3 GiB, 959119884288 bytes, 1873281024 sectors
    diskPartition:
        - device: /dev/disk/by-id/scsi-3600508b400105e210000900000490000
        partitions:
        - mount_point: /var/recovery
            size: 51200
            start: 800000</programlisting>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Save the contents of the <literal>ClusterGroupUpgrade</literal> CR with the <literal>backup</literal> and <literal>enable</literal> fields set to <literal>true</literal> in the <literal>clustergroupupgrades-group-du.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: du-upgrade-4918
  namespace: ztp-group-du-sno
spec:
  preCaching: true
  backup: true
  clusters:
  - cnfdb1
  - cnfdb2
  enable: true
  managedPolicies:
  - du-upgrade-platform-upgrade
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240</programlisting>
</listitem>
<listitem>
<simpara>To start the update, apply the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f clustergroupupgrades-group-du.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the status of the upgrade in the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n ztp-group-du-sno du-upgrade-4918 -o jsonpath='{.status}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "backup": {
        "clusters": [
            "cnfdb2",
            "cnfdb1"
    ],
    "status": {
        "cnfdb1": "Succeeded",
        "cnfdb2": "Failed" <co xml:id="CO101-1"/>
    }
},
"computedMaxConcurrency": 1,
"conditions": [
    {
        "lastTransitionTime": "2022-04-05T10:37:19Z",
        "message": "Backup failed for 1 cluster", <co xml:id="CO101-2"/>
        "reason": "PartiallyDone", <co xml:id="CO101-3"/>
        "status": "True", <co xml:id="CO101-4"/>
        "type": "Succeeded"
    }
],
"precaching": {
    "spec": {}
},
"status": {}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO101-1">
<para>Backup has failed for one cluster.</para>
</callout>
<callout arearefs="CO101-2">
<para>The message confirms that the backup failed for one cluster.</para>
</callout>
<callout arearefs="CO101-3">
<para>The backup was partially successful.</para>
</callout>
<callout arearefs="CO101-4">
<para>The backup process has finished.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="talo-backup-recovery_cnf-topology-aware-lifecycle-manager">
<title>Recovering a cluster after a failed upgrade</title>
<simpara>If an upgrade of a cluster fails, you can manually log in to the cluster and use the backup to return the cluster to its preupgrade state. There are two stages:</simpara>
<variablelist>
<varlistentry>
<term>Rollback</term>
<listitem>
<simpara>If the attempted upgrade included a change to the platform OS deployment, you must roll back to the previous version before running the recovery script.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>A rollback is only applicable to upgrades from TALM and single-node OpenShift. This process does not apply to rollbacks from any other upgrade type.</simpara>
</important>
<variablelist>
<varlistentry>
<term>Recovery</term>
<listitem>
<simpara>The recovery shuts down containers and uses files from the backup partition to relaunch containers and restore clusters.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters.</simpara>
</listitem>
<listitem>
<simpara>Install Red Hat Advanced Cluster Management (RHACM).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Run an upgrade that is configured for backup.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Delete the previously created <literal>ClusterGroupUpgrade</literal> custom resource (CR) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete cgu/du-upgrade-4918 -n ztp-group-du-sno</programlisting>
</listitem>
<listitem>
<simpara>Log in to the cluster that you want to recover.</simpara>
</listitem>
<listitem>
<simpara>Check the status of the platform OS deployment by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ostree admin status</programlisting>
<formalpara>
<title>Example outputs</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[root@lab-test-spoke2-node-0 core]# ostree admin status
* rhcos c038a8f08458bbed83a77ece033ad3c55597e3f64edad66ea12fda18cbdceaf9.0
    Version: 49.84.202202230006-0
    Pinned: yes <co xml:id="CO102-1"/>
    origin refspec: c038a8f08458bbed83a77ece033ad3c55597e3f64edad66ea12fda18cbdceaf9</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO102-1">
<para>The current deployment is pinned. A platform OS deployment rollback is not necessary.</para>
</callout>
</calloutlist>
<programlisting language="terminal" linenumbering="unnumbered">[root@lab-test-spoke2-node-0 core]# ostree admin status
* rhcos f750ff26f2d5550930ccbe17af61af47daafc8018cd9944f2a3a6269af26b0fa.0
    Version: 410.84.202204050541-0
    origin refspec: f750ff26f2d5550930ccbe17af61af47daafc8018cd9944f2a3a6269af26b0fa
rhcos ad8f159f9dc4ea7e773fd9604c9a16be0fe9b266ae800ac8470f63abc39b52ca.0 (rollback) <co xml:id="CO103-1"/>
    Version: 410.84.202203290245-0
    Pinned: yes <co xml:id="CO103-2"/>
    origin refspec: ad8f159f9dc4ea7e773fd9604c9a16be0fe9b266ae800ac8470f63abc39b52ca</programlisting>
<calloutlist>
<callout arearefs="CO103-1">
<para>This platform OS deployment is marked for rollback.</para>
</callout>
<callout arearefs="CO103-2">
<para>The previous deployment is pinned and can be rolled back.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To trigger a rollback of the platform OS deployment, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rpm-ostree rollback -r</programlisting>
</listitem>
<listitem>
<simpara>The first phase of the recovery shuts down containers and restores files from the backup partition to the targeted directories. To begin the recovery, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ /var/recovery/upgrade-recovery.sh</programlisting>
</listitem>
<listitem>
<simpara>When prompted, reboot the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ systemctl reboot</programlisting>
</listitem>
<listitem>
<simpara>After the reboot, restart the recovery by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ /var/recovery/upgrade-recovery.sh  --resume</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>If the recovery utility fails, you can retry with the <literal>--restart</literal> option:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ /var/recovery/upgrade-recovery.sh --restart</programlisting>
</note>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To check the status of the recovery run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion,nodes,clusteroperator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         VERSION   AVAILABLE   PROGRESSING   SINCE   STATUS
clusterversion.config.openshift.io/version   4.9.23    True        False         86d     Cluster version is 4.9.23 <co xml:id="CO104-1"/>


NAME                          STATUS   ROLES           AGE   VERSION
node/lab-test-spoke1-node-0   Ready    master,worker   86d   v1.22.3+b93fd35 <co xml:id="CO104-2"/>

NAME                                                                           VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE   MESSAGE
clusteroperator.config.openshift.io/authentication                             4.9.23    True        False         False      2d7h    <co xml:id="CO104-3"/>
clusteroperator.config.openshift.io/baremetal                                  4.9.23    True        False         False      86d


..............</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO104-1">
<para>The cluster version is available and has the correct version.</para>
</callout>
<callout arearefs="CO104-2">
<para>The node status is <literal>Ready</literal>.</para>
</callout>
<callout arearefs="CO104-3">
<para>The <literal>ClusterOperator</literal> object&#8217;s availability is <literal>True</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="talo-precache-feature-concept_cnf-topology-aware-lifecycle-manager">
<title>Using the container image pre-cache feature</title>
<simpara>Single-node OpenShift clusters might have limited bandwidth to access the container image registry, which can cause a timeout before the updates are completed.</simpara>
<note>
<simpara>The time of the update is not set by TALM. You can apply the <literal>ClusterGroupUpgrade</literal> CR at the beginning of the update by manual application or by external automation.</simpara>
</note>
<simpara>The container image pre-caching starts when the <literal>preCaching</literal> field is set to <literal>true</literal> in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
<simpara>TALM uses the <literal>PrecacheSpecValid</literal> condition to report status information as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>The pre-caching spec is valid and consistent.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>The pre-caching spec is incomplete.</simpara>
</listitem>
</itemizedlist>
<simpara>TALM uses the <literal>PrecachingSucceeded</literal> condition to report status information as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>true</literal></simpara>
<simpara>TALM has concluded the pre-caching process. If pre-caching fails for any cluster, the update fails for that cluster but proceeds for all other clusters. A message informs you if pre-caching has failed for any clusters.</simpara>
</listitem>
<listitem>
<simpara><literal>false</literal></simpara>
<simpara>Pre-caching is still in progress for one or more clusters or has failed for all clusters.</simpara>
</listitem>
</itemizedlist>
<simpara>After a successful pre-caching process, you can start remediating policies. The remediation actions start when the <literal>enable</literal> field is set to <literal>true</literal>. If there is a pre-caching failure on a cluster, the upgrade fails for that cluster. The upgrade process continues for all other clusters that have a successful pre-cache.</simpara>
<simpara>The pre-caching process can be in the following statuses:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NotStarted</literal></simpara>
<simpara>This is the initial state all clusters are automatically assigned to on the first reconciliation pass of the <literal>ClusterGroupUpgrade</literal> CR. In this state, TALM deletes any pre-caching namespace and hub view resources of spoke clusters that remain from previous incomplete updates. TALM then creates a new <literal>ManagedClusterView</literal> resource for the spoke pre-caching namespace to verify its deletion in the <literal>PrecachePreparing</literal> state.</simpara>
</listitem>
<listitem>
<simpara><literal>PreparingToStart</literal></simpara>
<simpara>Cleaning up any remaining resources from previous incomplete updates is in progress.</simpara>
</listitem>
<listitem>
<simpara><literal>Starting</literal></simpara>
<simpara>Pre-caching job prerequisites and the job are created.</simpara>
</listitem>
<listitem>
<simpara><literal>Active</literal></simpara>
<simpara>The job is in "Active" state.</simpara>
</listitem>
<listitem>
<simpara><literal>Succeeded</literal></simpara>
<simpara>The pre-cache job succeeded.</simpara>
</listitem>
<listitem>
<simpara><literal>PrecacheTimeout</literal></simpara>
<simpara>The artifact pre-caching is partially done.</simpara>
</listitem>
<listitem>
<simpara><literal>UnrecoverableError</literal></simpara>
<simpara>The job ends with a non-zero exit code.</simpara>
</listitem>
</itemizedlist>
<section xml:id="talo-precache-feature-image-filter_cnf-topology-aware-lifecycle-manager">
<title>Using the container image pre-cache filter</title>
<simpara>The pre-cache feature typically downloads more images than a cluster needs for an update. You can control which pre-cache images are downloaded to a cluster. This decreases download time, and saves bandwidth and storage.</simpara>
<simpara>You can see a list of all images to be downloaded using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release info &lt;ocp-version&gt;</programlisting>
<simpara>The following <literal>ConfigMap</literal> example shows how you can exclude images using the <literal>excludePrecachePatterns</literal> field.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-group-upgrade-overrides
data:
  excludePrecachePatterns: |
    azure <co xml:id="CO105-1"/>
    aws
    vsphere
    alibaba</programlisting>
<calloutlist>
<callout arearefs="CO105-1">
<para>TALM excludes all images with names that include any of the patterns listed here.</para>
</callout>
</calloutlist>
</section>
<section xml:id="talo-precache-start_and_update_cnf-topology-aware-lifecycle-manager">
<title>Creating a ClusterGroupUpgrade CR with pre-caching</title>
<simpara>For single-node OpenShift, the pre-cache feature allows the required container images to be present on the spoke cluster before the update starts.</simpara>
<note>
<simpara>For pre-caching, TALM uses the <literal>spec.remediationStrategy.timeout</literal> value from the <literal>ClusterGroupUpgrade</literal> CR. You must set a <literal>timeout</literal> value that allows sufficient time for the pre-caching job to complete. When you enable the <literal>ClusterGroupUpgrade</literal> CR after pre-caching has completed, you can change the <literal>timeout</literal> value to a duration that is appropriate for the update.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Save the contents of the <literal>ClusterGroupUpgrade</literal> CR with the <literal>preCaching</literal> field set to <literal>true</literal> in the <literal>clustergroupupgrades-group-du.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: du-upgrade-4918
  namespace: ztp-group-du-sno
spec:
  preCaching: true <co xml:id="CO106-1"/>
  clusters:
  - cnfdb1
  - cnfdb2
  enable: false
  managedPolicies:
  - du-upgrade-platform-upgrade
  remediationStrategy:
    maxConcurrency: 2
    timeout: 240</programlisting>
<calloutlist>
<callout arearefs="CO106-1">
<para>The <literal>preCaching</literal> field is set to <literal>true</literal>, which enables TALM to pull the container images before starting the update.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>When you want to start pre-caching, apply the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f clustergroupupgrades-group-du.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check if the <literal>ClusterGroupUpgrade</literal> CR exists in the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -A</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE          NAME              AGE   STATE        DETAILS
ztp-group-du-sno   du-upgrade-4918   10s   InProgress   Precaching is required and not done <co xml:id="CO107-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO107-1">
<para>The CR is created.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the status of the pre-caching task by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n ztp-group-du-sno du-upgrade-4918 -o jsonpath='{.status}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "conditions": [
    {
      "lastTransitionTime": "2022-01-27T19:07:24Z",
      "message": "Precaching is required and not done",
      "reason": "InProgress",
      "status": "False",
      "type": "PrecachingSucceeded"
    },
    {
      "lastTransitionTime": "2022-01-27T19:07:34Z",
      "message": "Pre-caching spec is valid and consistent",
      "reason": "PrecacheSpecIsWellFormed",
      "status": "True",
      "type": "PrecacheSpecValid"
    }
  ],
  "precaching": {
    "clusters": [
      "cnfdb1" <co xml:id="CO108-1"/>
      "cnfdb2"
    ],
    "spec": {
      "platformImage": "image.example.io"},
    "status": {
      "cnfdb1": "Active"
      "cnfdb2": "Succeeded"}
    }
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO108-1">
<para>Displays the list of identified clusters.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the status of the pre-caching job by running the following command on the spoke cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jobs,pods -n openshift-talo-pre-cache</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                  COMPLETIONS   DURATION   AGE
job.batch/pre-cache   0/1           3m10s      3m10s

NAME                     READY   STATUS    RESTARTS   AGE
pod/pre-cache--1-9bmlr   1/1     Running   0          3m10s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n ztp-group-du-sno du-upgrade-4918 -o jsonpath='{.status}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">"conditions": [
    {
      "lastTransitionTime": "2022-01-27T19:30:41Z",
      "message": "The ClusterGroupUpgrade CR has all clusters compliant with all the managed policies",
      "reason": "UpgradeCompleted",
      "status": "True",
      "type": "Ready"
    },
    {
      "lastTransitionTime": "2022-01-27T19:28:57Z",
      "message": "Precaching is completed",
      "reason": "PrecachingCompleted",
      "status": "True",
      "type": "PrecachingSucceeded" <co xml:id="CO109-1"/>
    }</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO109-1">
<para>The pre-cache tasks are done.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="talo-troubleshooting_cnf-topology-aware-lifecycle-manager">
<title>Troubleshooting the Topology Aware Lifecycle Manager</title>
<simpara>The Topology Aware Lifecycle Manager (TALM) is an OpenShift Container Platform Operator that remediates RHACM policies. When issues occur, use the <literal>oc adm must-gather</literal> command to gather details and logs and to take steps in debugging the issues.</simpara>
<simpara>For more information about related topics, see the following documentation:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/articles/6218901">Red Hat Advanced Cluster Management for Kubernetes 2.4 Support Matrix</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.0/html/troubleshooting/troubleshooting">Red Hat Advanced Cluster Management Troubleshooting</link></simpara>
</listitem>
<listitem>
<simpara>The "Troubleshooting Operator issues" section</simpara>
</listitem>
</itemizedlist>
<section xml:id="talo-general-troubleshooting_cnf-topology-aware-lifecycle-manager">
<title>General troubleshooting</title>
<simpara>You can determine the cause of the problem by reviewing the following questions:</simpara>
<itemizedlist>
<listitem>
<simpara>Is the configuration that you are applying supported?</simpara>
<itemizedlist>
<listitem>
<simpara>Are the RHACM and the OpenShift Container Platform versions compatible?</simpara>
</listitem>
<listitem>
<simpara>Are the TALM and RHACM versions compatible?</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Which of the following components is causing the problem?</simpara>
<itemizedlist>
<listitem>
<simpara><xref linkend="talo-troubleshooting-managed-policies_cnf-topology-aware-lifecycle-manager"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="talo-troubleshooting-clusters_cnf-topology-aware-lifecycle-manager"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="talo-troubleshooting-remediation-strategy_cnf-topology-aware-lifecycle-manager"/></simpara>
</listitem>
<listitem>
<simpara><xref linkend="talo-troubleshooting-remediation-talo_cnf-topology-aware-lifecycle-manager"/></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>To ensure that the <literal>ClusterGroupUpgrade</literal> configuration is functional, you can do the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the <literal>ClusterGroupUpgrade</literal> CR with the <literal>spec.enable</literal> field set to <literal>false</literal>.</simpara>
</listitem>
<listitem>
<simpara>Wait for the status to be updated and go through the troubleshooting questions.</simpara>
</listitem>
<listitem>
<simpara>If everything looks as expected, set the <literal>spec.enable</literal> field to <literal>true</literal> in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</orderedlist>
<warning>
<simpara>After you set the <literal>spec.enable</literal> field to <literal>true</literal> in the <literal>ClusterUpgradeGroup</literal> CR, the update procedure starts and you cannot edit the CR&#8217;s <literal>spec</literal> fields anymore.</simpara>
</warning>
</section>
<section xml:id="talo-troubleshooting-modify-cgu_cnf-topology-aware-lifecycle-manager">
<title>Cannot modify the ClusterUpgradeGroup CR</title>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You cannot edit the <literal>ClusterUpgradeGroup</literal> CR after enabling the update.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Restart the procedure by performing the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Remove the old <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete cgu -n &lt;ClusterGroupUpgradeCR_namespace&gt; &lt;ClusterGroupUpgradeCR_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check and fix the existing issues with the managed clusters and policies.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure that all the clusters are managed clusters and available.</simpara>
</listitem>
<listitem>
<simpara>Ensure that all the policies exist and have the <literal>spec.remediationAction</literal> field set to <literal>inform</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a new <literal>ClusterGroupUpgrade</literal> CR with the correct configurations.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;ClusterGroupUpgradeCR_YAML&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="talo-troubleshooting-managed-policies_cnf-topology-aware-lifecycle-manager">
<title>Managed policies</title>
<bridgehead xml:id="_checking-managed-policies-on-the-system" renderas="sect4">Checking managed policies on the system</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if you have the correct managed policies on the system.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.spec.managedPolicies}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">["group-du-sno-validator-du-validator-policy", "policy2-common-nto-sub-policy", "policy3-common-ptp-sub-policy"]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-remediationaction-mode" renderas="sect4">Checking remediationAction mode</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the <literal>remediationAction</literal> field is set to <literal>inform</literal> in the <literal>spec</literal> of the managed policies.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE   NAME                                                 REMEDIATION ACTION   COMPLIANCE STATE   AGE
default     policy1-common-cluster-version-policy                inform               NonCompliant       5d21h
default     policy2-common-nto-sub-policy                        inform               Compliant          5d21h
default     policy3-common-ptp-sub-policy                        inform               NonCompliant       5d21h
default     policy4-common-sriov-sub-policy                      inform               NonCompliant       5d21h</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-policy-compliance-state" renderas="sect4">Checking policy compliance state</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check the compliance state of policies.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE   NAME                                                 REMEDIATION ACTION   COMPLIANCE STATE   AGE
default     policy1-common-cluster-version-policy                inform               NonCompliant       5d21h
default     policy2-common-nto-sub-policy                        inform               Compliant          5d21h
default     policy3-common-ptp-sub-policy                        inform               NonCompliant       5d21h
default     policy4-common-sriov-sub-policy                      inform               NonCompliant       5d21h</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="talo-troubleshooting-clusters_cnf-topology-aware-lifecycle-manager">
<title>Clusters</title>
<bridgehead xml:id="_checking-if-managed-clusters-are-present" renderas="sect5">Checking if managed clusters are present</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the clusters in the <literal>ClusterGroupUpgrade</literal> CR are managed clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedclusters</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HUB ACCEPTED   MANAGED CLUSTER URLS                    JOINED   AVAILABLE   AGE
local-cluster   true           https://api.hub.example.com:6443        True     Unknown     13d
spoke1          true           https://api.spoke1.example.com:6443     True     True        13d
spoke3          true           https://api.spoke3.example.com:6443     True     True        27h</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Alternatively, check the TALM manager logs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get the name of the TALM manager by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod -n openshift-operators</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                         READY   STATUS    RESTARTS   AGE
cluster-group-upgrades-controller-manager-75bcc7484d-8k8xp   2/2     Running   0          45m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the TALM manager logs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-operators \
cluster-group-upgrades-controller-manager-75bcc7484d-8k8xp -c manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ERROR	controller-runtime.manager.controller.clustergroupupgrade	Reconciler error	{"reconciler group": "ran.openshift.io", "reconciler kind": "ClusterGroupUpgrade", "name": "lab-upgrade", "namespace": "default", "error": "Cluster spoke5555 is not a ManagedCluster"} <co xml:id="CO110-1"/>
sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).processNextWorkItem</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO110-1">
<para>The error message shows that the cluster is not a managed cluster.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-if-managed-clusters-are-available" renderas="sect5">Checking if managed clusters are available</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the managed clusters specified in the <literal>ClusterGroupUpgrade</literal> CR are available.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedclusters</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HUB ACCEPTED   MANAGED CLUSTER URLS                    JOINED   AVAILABLE   AGE
local-cluster   true           https://api.hub.testlab.com:6443        True     Unknown     13d
spoke1          true           https://api.spoke1.testlab.com:6443     True     True        13d <co xml:id="CO111-1"/>
spoke3          true           https://api.spoke3.testlab.com:6443     True     True        27h <co xml:id="CO111-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO111-1 CO111-2">
<para>The value of the <literal>AVAILABLE</literal> field is <literal>True</literal> for the managed clusters.</para>
</callout>
</calloutlist>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-clusterlabelselector" renderas="sect5">Checking clusterLabelSelector</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the <literal>clusterLabelSelector</literal> field specified in the <literal>ClusterGroupUpgrade</literal> CR matches at least one of the managed clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster --selector=upgrade=true <co xml:id="CO112-1"/></programlisting>
<calloutlist>
<callout arearefs="CO112-1">
<para>The label for the clusters you want to update is <literal>upgrade:true</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HUB ACCEPTED   MANAGED CLUSTER URLS                     JOINED    AVAILABLE   AGE
spoke1          true           https://api.spoke1.testlab.com:6443      True     True        13d
spoke3          true           https://api.spoke3.testlab.com:6443      True     True        27h</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-if-canary-clusters-are-present" renderas="sect5">Checking if canary clusters are present</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the canary clusters are present in the list of clusters.</simpara>
<formalpara>
<title>Example <literal>ClusterGroupUpgrade</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
    remediationStrategy:
        canaries:
        - spoke3
        maxConcurrency: 2
        timeout: 240
    clusterLabelSelectors:
      - matchLabels:
          upgrade: true</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.spec.clusters}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">["spoke1", "spoke3"]</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check if the canary clusters are present in the list of clusters that match <literal>clusterLabelSelector</literal> labels by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster --selector=upgrade=true</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            HUB ACCEPTED   MANAGED CLUSTER URLS   JOINED    AVAILABLE   AGE
spoke1          true           https://api.spoke1.testlab.com:6443   True     True        13d
spoke3          true           https://api.spoke3.testlab.com:6443   True     True        27h</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>A cluster can be present in <literal>spec.clusters</literal> and also be matched by the <literal>spec.clusterLabelSelector</literal> label.</simpara>
</note>
<bridgehead xml:id="_checking-the-pre-caching-status-on-spoke-clusters" renderas="sect5">Checking the pre-caching status on spoke clusters</bridgehead>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check the status of pre-caching by running the following command on the spoke cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jobs,pods -n openshift-talo-pre-cache</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="talo-troubleshooting-remediation-strategy_cnf-topology-aware-lifecycle-manager">
<title>Remediation Strategy</title>
<bridgehead xml:id="_checking-if-remediationstrategy-is-present-in-the-clustergroupupgrade-cr" renderas="sect5">Checking if remediationStrategy is present in the ClusterGroupUpgrade CR</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the <literal>remediationStrategy</literal> is present in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.spec.remediationStrategy}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"maxConcurrency":2, "timeout":240}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-if-maxconcurrency-is-specified-in-the-clustergroupupgrade-cr" renderas="sect5">Checking if maxConcurrency is specified in the ClusterGroupUpgrade CR</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if the <literal>maxConcurrency</literal> is specified in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.spec.remediationStrategy.maxConcurrency}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="talo-troubleshooting-remediation-talo_cnf-topology-aware-lifecycle-manager">
<title>Topology Aware Lifecycle Manager</title>
<bridgehead xml:id="_checking-condition-message-and-status-in-the-clustergroupupgrade-cr" renderas="sect5">Checking condition message and status in the ClusterGroupUpgrade CR</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check the value of the <literal>status.conditions</literal> field in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.status.conditions}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"lastTransitionTime":"2022-02-17T22:25:28Z", "message":"Missing managed policies:[policyList]", "reason":"NotAllManagedPoliciesExist", "status":"False", "type":"Validated"}</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-corresponding-copied-policies" renderas="sect5">Checking corresponding copied policies</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if every policy from <literal>status.managedPoliciesForUpgrade</literal> has a corresponding policy in <literal>status.copiedPolicies</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -oyaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">status:
  
  copiedPolicies:
  - lab-upgrade-policy3-common-ptp-sub-policy
  managedPoliciesForUpgrade:
  - name: policy3-common-ptp-sub-policy
    namespace: default</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_checking-if-status-remediationplan-was-computed" renderas="sect5">Checking if status.remediationPlan was computed</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check if <literal>status.remediationPlan</literal> is computed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu lab-upgrade -ojsonpath='{.status.remediationPlan}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">[["spoke2", "spoke3"]]</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_errors-in-the-talm-manager-container" renderas="sect5">Errors in the TALM manager container</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check the logs of the manager container of TALM.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-operators \
cluster-group-upgrades-controller-manager-75bcc7484d-8k8xp -c manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ERROR	controller-runtime.manager.controller.clustergroupupgrade	Reconciler error	{"reconciler group": "ran.openshift.io", "reconciler kind": "ClusterGroupUpgrade", "name": "lab-upgrade", "namespace": "default", "error": "Cluster spoke5555 is not a ManagedCluster"} <co xml:id="CO113-1"/>
sigs.k8s.io/controller-runtime/pkg/internal/controller.(*Controller).processNextWorkItem</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO113-1">
<para>Displays the error.</para>
</callout>
</calloutlist>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="_clusters-are-not-compliant-to-some-policies-after-a-clustergroupupgrade-cr-has-completed" renderas="sect5">Clusters are not compliant to some policies after a <literal>ClusterGroupUpgrade</literal> CR has completed</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>The policy compliance status that TALM uses to decide if remediation is needed has not yet fully updated for all clusters.
This may be because:</simpara>
<itemizedlist>
<listitem>
<simpara>The CGU was run too soon after a policy was created or updated.</simpara>
</listitem>
<listitem>
<simpara>The remediation of a policy affects the compliance of subsequent policies in the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Create and apply a new <literal>ClusterGroupUpdate</literal> CR with the same specification.</simpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="talo-troubleshooting-auto-create-policies_cnf-topology-aware-lifecycle-manager" renderas="sect5">Auto-created <literal>ClusterGroupUpgrade</literal> CR in the GitOps ZTP workflow has no managed policies</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>If there are no policies for the managed cluster when the cluster becomes <literal>Ready</literal>, a <literal>ClusterGroupUpgrade</literal> CR with no policies is auto-created.
Upon completion of the <literal>ClusterGroupUpgrade</literal> CR, the managed cluster is labeled as <literal>ztp-done</literal>.
If the <literal>PolicyGenTemplate</literal> CRs were not pushed to the Git repository within the required time after <literal>SiteConfig</literal> resources were pushed, this might result in no policies being available for the target cluster when the cluster became <literal>Ready</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Verify that the policies you want to apply are available on the hub cluster, then create a <literal>ClusterGroupUpgrade</literal> CR with the required policies.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>You can either manually create the <literal>ClusterGroupUpgrade</literal> CR or trigger auto-creation again. To trigger auto-creation of the <literal>ClusterGroupUpgrade</literal> CR, remove the <literal>ztp-done</literal> label from the cluster and delete the empty <literal>ClusterGroupUpgrade</literal> CR that was previously created in the <literal>zip-install</literal> namespace.</simpara>
<bridgehead xml:id="talo-troubleshooting-pre-cache-failed_cnf-topology-aware-lifecycle-manager" renderas="sect5">Pre-caching has failed</bridgehead>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>Pre-caching might fail for one of the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>There is not enough free space on the node.</simpara>
</listitem>
<listitem>
<simpara>For a disconnected environment, the pre-cache image has not been properly mirrored.</simpara>
</listitem>
<listitem>
<simpara>There was an issue when creating the pod.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<orderedlist numeration="arabic">
<listitem>
<simpara>To check if pre-caching has failed due to insufficient space, check the log of the pre-caching pod in the node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the name of the pod using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-talo-pre-cache</programlisting>
</listitem>
<listitem>
<simpara>Check the logs to see if the error is related to insufficient space using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-talo-pre-cache &lt;pod name&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If there is no log, check the pod status using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod -n openshift-talo-pre-cache &lt;pod name&gt;</programlisting>
</listitem>
<listitem>
<simpara>If the pod does not exist, check the job status to see why it could not create a pod using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe job -n openshift-talo-pre-cache pre-cache</programlisting>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about troubleshooting, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/support/#troubleshooting-operator-issues-1">OpenShift Container Platform Troubleshooting Operator Issues</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about using Topology Aware Lifecycle Manager in the ZTP workflow, see <link linkend="ztp-topology-aware-lifecycle-manager">Updating managed policies with Topology Aware Lifecycle Manager</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about the <literal>PolicyGenTemplate</literal> CRD, see <link linkend="ztp-the-policygentemplate_ztp-configuring-managed-clusters-policies">About the PolicyGenTemplate CRD</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ztp-topology-aware-lifecycle-manager">
<title>Updating managed clusters in a disconnected environment with the Topology Aware Lifecycle Manager</title>
<simpara>You can use the Topology Aware Lifecycle Manager (TALM) to manage the software lifecycle of OpenShift Container Platform managed clusters. TALM uses Red Hat Advanced Cluster Management (RHACM) policies to perform changes on the target clusters.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about the Topology Aware Lifecycle Manager, see <link linkend="cnf-about-topology-aware-lifecycle-manager-config_cnf-topology-aware-lifecycle-manager">About the Topology Aware Lifecycle Manager</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="talo-platform-prepare-end-to-end_ztp-talm">
<title>Updating clusters in a disconnected environment</title>
<simpara>You can upgrade managed clusters and Operators for managed clusters that you have deployed using GitOps Zero Touch Provisioning (ZTP) and Topology Aware Lifecycle Manager (TALM).</simpara>
<section xml:id="talo-platform-prepare-for-update-env-setup_ztp-talm">
<title>Setting up the environment</title>
<simpara>TALM can perform both platform and Operator updates.</simpara>
<simpara>You must mirror both the platform image and Operator images that you want to update to in your mirror registry before you can use TALM to update your disconnected clusters. Complete the following steps to mirror the images:</simpara>
<itemizedlist>
<listitem>
<simpara>For platform updates, you must perform the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mirror the desired OpenShift Container Platform image repository. Ensure that the desired platform image is mirrored by following the "Mirroring the OpenShift Container Platform image repository" procedure linked in the Additional Resources. Save the contents of the <literal>imageContentSources</literal> section in the <literal>imageContentSources.yaml</literal> file:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">imageContentSources:
 - mirrors:
   - mirror-ocp-registry.ibmcloud.io.cpak:5000/openshift-release-dev/openshift4
   source: quay.io/openshift-release-dev/ocp-release
 - mirrors:
   - mirror-ocp-registry.ibmcloud.io.cpak:5000/openshift-release-dev/openshift4
   source: quay.io/openshift-release-dev/ocp-v4.0-art-dev</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Save the image signature of the desired platform image that was mirrored. You must add the image signature to the <literal>PolicyGenTemplate</literal> CR for platform updates. To get the image signature, perform the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Specify the desired OpenShift Container Platform tag by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ OCP_RELEASE_NUMBER=&lt;release_version&gt;</programlisting>
</listitem>
<listitem>
<simpara>Specify the architecture of the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ARCHITECTURE=&lt;cluster_architecture&gt; <co xml:id="CO114-1"/></programlisting>
<calloutlist>
<callout arearefs="CO114-1">
<para>Specify the architecture of the cluster, such as <literal>x86_64</literal>, <literal>aarch64</literal>, <literal>s390x</literal>, or <literal>ppc64le</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Get the release image digest from Quay by running the following command</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ DIGEST="$(oc adm release info quay.io/openshift-release-dev/ocp-release:${OCP_RELEASE_NUMBER}-${ARCHITECTURE} | sed -n 's/Pull From: .*@//p')"</programlisting>
</listitem>
<listitem>
<simpara>Set the digest algorithm by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ DIGEST_ALGO="${DIGEST%%:*}"</programlisting>
</listitem>
<listitem>
<simpara>Set the digest signature by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ DIGEST_ENCODED="${DIGEST#*:}"</programlisting>
</listitem>
<listitem>
<simpara>Get the image signature from the <link xlink:href="https://mirror.openshift.com/pub/openshift-v4/signatures/openshift/release/">mirror.openshift.com</link> website by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ SIGNATURE_BASE64=$(curl -s "https://mirror.openshift.com/pub/openshift-v4/signatures/openshift/release/${DIGEST_ALGO}=${DIGEST_ENCODED}/signature-1" | base64 -w0 &amp;&amp; echo)</programlisting>
</listitem>
<listitem>
<simpara>Save the image signature to the <literal>checksum-&lt;OCP_RELEASE_NUMBER&gt;.yaml</literal> file by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &gt;checksum-${OCP_RELEASE_NUMBER}.yaml &lt;&lt;EOF
${DIGEST_ALGO}-${DIGEST_ENCODED}: ${SIGNATURE_BASE64}
EOF</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Prepare the update graph. You have two options to prepare the update graph:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Use the OpenShift Update Service.</simpara>
<simpara>For more information about how to set up the graph on the hub cluster, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.4/html/clusters/managing-your-clusters#deploy-the-operator-for-cincinnati">Deploy the operator for OpenShift Update Service</link> and <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.4/html/clusters/managing-your-clusters#build-the-graph-data-init-container">Build the graph data init container</link>.</simpara>
</listitem>
<listitem>
<simpara>Make a local copy of the upstream graph. Host the update graph on an <literal>http</literal> or <literal>https</literal> server in the disconnected environment that has access to the managed cluster. To download the update graph, use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s https://api.openshift.com/api/upgrades_info/v1/graph?channel=stable-4.14 -o ~/upgrade-graph_stable-4.14</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>For Operator updates, you must perform the following task:</simpara>
<itemizedlist>
<listitem>
<simpara>Mirror the Operator catalogs. Ensure that the desired operator images are mirrored by following the procedure in the "Mirroring Operator catalogs for use with disconnected clusters" section.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about how to update GitOps Zero Touch Provisioning (ZTP), see <link linkend="ztp-updating-gitops">Upgrading GitOps ZTP</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about how to mirror an OpenShift Container Platform image repository, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-mirror-repository_installing-mirroring-installation-images">Mirroring the OpenShift Container Platform image repository</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about how to mirror Operator catalogs for disconnected clusters, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#olm-mirror-catalog_installing-mirroring-installation-images">Mirroring Operator catalogs for use with disconnected clusters</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about how to prepare the disconnected environment and mirroring the desired image repository, see <link linkend="ztp-preparing-the-hub-cluster">Preparing the disconnected environment</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about update channels and releases, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/updating_clusters/#understanding-update-channels-releases">Understanding update channels and releases</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="talo-platform-update_ztp-talm">
<title>Performing a platform update</title>
<simpara>You can perform a platform update with the TALM.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Update GitOps Zero Touch Provisioning (ZTP) to the latest version.</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters with GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Mirror the desired image repository.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create RHACM policies in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>PolicyGenTemplate</literal> CR for the platform update:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following contents of the <literal>PolicyGenTemplate</literal> CR in the <literal>du-upgrade.yaml</literal> file.</simpara>
<formalpara>
<title>Example of <literal>PolicyGenTemplate</literal> for platform update</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "du-upgrade"
  namespace: "ztp-group-du-sno"
spec:
  bindingRules:
    group-du-sno: ""
  mcp: "master"
  remediationAction: inform
  sourceFiles:
    - fileName: ImageSignature.yaml <co xml:id="CO115-1"/>
      policyName: "platform-upgrade-prep"
      binaryData:
        ${DIGEST_ALGO}-${DIGEST_ENCODED}: ${SIGNATURE_BASE64} <co xml:id="CO115-2"/>
    - fileName: DisconnectedICSP.yaml
      policyName: "platform-upgrade-prep"
      metadata:
        name: disconnected-internal-icsp-for-ocp
      spec:
        repositoryDigestMirrors: <co xml:id="CO115-3"/>
          - mirrors:
            - quay-intern.example.com/ocp4/openshift-release-dev
            source: quay.io/openshift-release-dev/ocp-release
          - mirrors:
            - quay-intern.example.com/ocp4/openshift-release-dev
            source: quay.io/openshift-release-dev/ocp-v4.0-art-dev
    - fileName: ClusterVersion.yaml <co xml:id="CO115-4"/>
      policyName: "platform-upgrade"
      metadata:
        name: version
      spec:
        channel: "stable-4.14"
        upstream: http://upgrade.example.com/images/upgrade-graph_stable-4.14
        desiredUpdate:
          version: 4.14.4
      status:
        history:
          - version: 4.14.4
            state: "Completed"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO115-1">
<para>The <literal>ConfigMap</literal> CR contains the signature of the desired release image to update to.</para>
</callout>
<callout arearefs="CO115-2">
<para>Shows the image signature of the desired OpenShift Container Platform release. Get the signature from the <literal>checksum-${OCP_RELEASE_NUMBER}.yaml</literal> file you saved when following the procedures in the "Setting up the environment" section.</para>
</callout>
<callout arearefs="CO115-3">
<para>Shows the mirror repository that contains the desired OpenShift Container Platform image. Get the mirrors from the <literal>imageContentSources.yaml</literal> file that you saved when following the procedures in the "Setting up the environment" section.</para>
</callout>
<callout arearefs="CO115-4">
<para>Shows the <literal>ClusterVersion</literal> CR to trigger the update. The <literal>channel</literal>, <literal>upstream</literal>, and <literal>desiredVersion</literal> fields are all required for image pre-caching.</para>
</callout>
</calloutlist>
<simpara>The <literal>PolicyGenTemplate</literal> CR generates two policies:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>du-upgrade-platform-upgrade-prep</literal> policy does the preparation work for the platform update. It creates the <literal>ConfigMap</literal> CR for the desired release image signature, creates the image content source of the mirrored release image repository, and updates the cluster version with the desired update channel and the update graph reachable by the managed cluster in the disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>The <literal>du-upgrade-platform-upgrade</literal> policy is used to perform platform upgrade.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Add the <literal>du-upgrade.yaml</literal> file contents to the <literal>kustomization.yaml</literal> file located in the GitOps ZTP Git repository for the <literal>PolicyGenTemplate</literal> CRs and push the changes to the Git repository.</simpara>
<simpara>ArgoCD pulls the changes from the Git repository and generates the policies on the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>Check the created policies by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies -A | grep platform-upgrade</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpdate</literal> CR for the platform update with the <literal>spec.enable</literal> field set to <literal>false</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the content of the platform update <literal>ClusterGroupUpdate</literal> CR with the <literal>du-upgrade-platform-upgrade-prep</literal> and the <literal>du-upgrade-platform-upgrade</literal> policies and the target clusters to the <literal>cgu-platform-upgrade.yml</literal> file, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-platform-upgrade
  namespace: default
spec:
  managedPolicies:
  - du-upgrade-platform-upgrade-prep
  - du-upgrade-platform-upgrade
  preCaching: false
  clusters:
  - spoke1
  remediationStrategy:
    maxConcurrency: 1
  enable: false</programlisting>
</listitem>
<listitem>
<simpara>Apply the <literal>ClusterGroupUpdate</literal> CR to the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-platform-upgrade.yml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Pre-cache the images for the platform update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enable pre-caching in the <literal>ClusterGroupUpdate</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-platform-upgrade \
--patch '{"spec":{"preCaching": true}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the update process and wait for the pre-caching to complete. Check the status of pre-caching by running the following command on the hub cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu cgu-platform-upgrade -o jsonpath='{.status.precaching.status}'</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Start the platform update:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enable the <literal>cgu-platform-upgrade</literal> policy and disable pre-caching by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-platform-upgrade \
--patch '{"spec":{"enable":true, "preCaching": false}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the process. Upon completion, ensure that the policy is compliant by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about mirroring the images in a disconnected environment, see <link linkend="ztp-acm-adding-images-to-mirror-registry_ztp-preparing-the-hub-cluster">Preparing the disconnected environment</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="talo-operator-update_ztp-talm">
<title>Performing an Operator update</title>
<simpara>You can perform an Operator update with the TALM.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Update GitOps Zero Touch Provisioning (ZTP) to the latest version.</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters with GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Mirror the desired index image, bundle images, and all Operator images referenced in the bundle images.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create RHACM policies in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>PolicyGenTemplate</literal> CR for the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the <literal>du-upgrade</literal> <literal>PolicyGenTemplate</literal> CR with the following additional contents in the <literal>du-upgrade.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "du-upgrade"
  namespace: "ztp-group-du-sno"
spec:
  bindingRules:
    group-du-sno: ""
  mcp: "master"
  remediationAction: inform
  sourceFiles:
    - fileName: DefaultCatsrc.yaml
      remediationAction: inform
      policyName: "operator-catsrc-policy"
      metadata:
        name: redhat-operators
      spec:
        displayName: Red Hat Operators Catalog
        image: registry.example.com:5000/olm/redhat-operators:v4.14 <co xml:id="CO116-1"/>
        updateStrategy: <co xml:id="CO116-2"/>
          registryPoll:
            interval: 1h
      status:
        connectionState:
            lastObservedState: READY <co xml:id="CO116-3"/></programlisting>
<calloutlist>
<callout arearefs="CO116-1">
<para>The index image URL contains the desired Operator images. If the index images are always pushed to the same image name and tag, this change is not needed.</para>
</callout>
<callout arearefs="CO116-2">
<para>Set how frequently the Operator Lifecycle Manager (OLM) polls the index image for new Operator versions with the <literal>registryPoll.interval</literal> field. This change is not needed if a new index image tag is always pushed for y-stream and z-stream Operator updates. The <literal>registryPoll.interval</literal> field can be set to a shorter interval to expedite the update, however shorter intervals increase computational load. To counteract this, you can restore <literal>registryPoll.interval</literal> to the default value once the update is complete.</para>
</callout>
<callout arearefs="CO116-3">
<para>Last observed state of the catalog connection. The <literal>READY</literal> value ensures that the <literal>CatalogSource</literal> policy is ready, indicating that the index pod is pulled and is running. This way, TALM upgrades the Operators based on up-to-date policy compliance states.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>This update generates one policy, <literal>du-upgrade-operator-catsrc-policy</literal>, to update the <literal>redhat-operators</literal> catalog source with the new index images that contain the desired Operators images.</simpara>
<note>
<simpara>If you want to use the image pre-caching for Operators and there are Operators from a different catalog source other than <literal>redhat-operators</literal>,  you must perform the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Prepare a separate catalog source policy with the new index image or registry poll interval update for the different catalog source.</simpara>
</listitem>
<listitem>
<simpara>Prepare a separate subscription policy for the desired Operators that are from the different catalog source.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>For example, the desired SRIOV-FEC Operator is available in the <literal>certified-operators</literal> catalog source. To update the catalog source and the Operator subscription, add the following contents to generate two policies, <literal>du-upgrade-fec-catsrc-policy</literal> and <literal>du-upgrade-subscriptions-fec-policy</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "du-upgrade"
  namespace: "ztp-group-du-sno"
spec:
  bindingRules:
    group-du-sno: ""
  mcp: "master"
  remediationAction: inform
  sourceFiles:
       
    - fileName: DefaultCatsrc.yaml
      remediationAction: inform
      policyName: "fec-catsrc-policy"
      metadata:
        name: certified-operators
      spec:
        displayName: Intel SRIOV-FEC Operator
        image: registry.example.com:5000/olm/far-edge-sriov-fec:v4.10
        updateStrategy:
          registryPoll:
            interval: 10m
    - fileName: AcceleratorsSubscription.yaml
      policyName: "subscriptions-fec-policy"
      spec:
        channel: "stable"
        source: certified-operators</programlisting>
</listitem>
<listitem>
<simpara>Remove the specified subscriptions channels in the common <literal>PolicyGenTemplate</literal> CR, if they exist. The default subscriptions channels from the GitOps ZTP image are used for the update.</simpara>
<note>
<simpara>The default channel for the Operators applied through GitOps ZTP 4.14 is <literal>stable</literal>, except for the <literal>performance-addon-operator</literal>. As of OpenShift Container Platform 4.11, the <literal>performance-addon-operator</literal> functionality was moved to the <literal>node-tuning-operator</literal>. For the 4.10 release, the default channel for PAO is <literal>v4.10</literal>. You can also specify the default channels in the common <literal>PolicyGenTemplate</literal> CR.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the <literal>PolicyGenTemplate</literal> CRs updates to the GitOps ZTP Git repository.</simpara>
<simpara>ArgoCD pulls the changes from the Git repository and generates the policies on the hub cluster.</simpara>
</listitem>
<listitem>
<simpara>Check the created policies by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies -A | grep -E "catsrc-policy|subscription"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Apply the required catalog source updates before starting the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the content of the <literal>ClusterGroupUpgrade</literal> CR named <literal>operator-upgrade-prep</literal> with the catalog source policies and the target managed clusters to the <literal>cgu-operator-upgrade-prep.yml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-operator-upgrade-prep
  namespace: default
spec:
  clusters:
  - spoke1
  enable: true
  managedPolicies:
  - du-upgrade-operator-catsrc-policy
  remediationStrategy:
    maxConcurrency: 1</programlisting>
</listitem>
<listitem>
<simpara>Apply the policy to the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-operator-upgrade-prep.yml</programlisting>
</listitem>
<listitem>
<simpara>Monitor the update process. Upon completion, ensure that the policy is compliant by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies -A | grep -E "catsrc-policy"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpgrade</literal> CR for the Operator update with the <literal>spec.enable</literal> field set to <literal>false</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the content of the Operator update <literal>ClusterGroupUpgrade</literal> CR with the <literal>du-upgrade-operator-catsrc-policy</literal> policy and the subscription policies created from the common <literal>PolicyGenTemplate</literal> and the target clusters to the <literal>cgu-operator-upgrade.yml</literal> file, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-operator-upgrade
  namespace: default
spec:
  managedPolicies:
  - du-upgrade-operator-catsrc-policy <co xml:id="CO117-1"/>
  - common-subscriptions-policy <co xml:id="CO117-2"/>
  preCaching: false
  clusters:
  - spoke1
  remediationStrategy:
    maxConcurrency: 1
  enable: false</programlisting>
<calloutlist>
<callout arearefs="CO117-1">
<para>The policy is needed by the image pre-caching feature to retrieve the operator images from the catalog source.</para>
</callout>
<callout arearefs="CO117-2">
<para>The policy contains Operator subscriptions. If you have followed the structure and content of the reference <literal>PolicyGenTemplates</literal>, all Operator subscriptions are grouped into the <literal>common-subscriptions-policy</literal> policy.</para>
</callout>
</calloutlist>
<note>
<simpara>One <literal>ClusterGroupUpgrade</literal> CR can only pre-cache the images of the desired Operators defined in the subscription policy from one catalog source included in the <literal>ClusterGroupUpgrade</literal> CR. If the desired Operators are from different catalog sources, such as in the example of the SRIOV-FEC Operator, another <literal>ClusterGroupUpgrade</literal> CR must be created with <literal>du-upgrade-fec-catsrc-policy</literal> and <literal>du-upgrade-subscriptions-fec-policy</literal> policies for the SRIOV-FEC Operator images pre-caching and update.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply the <literal>ClusterGroupUpgrade</literal> CR to the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-operator-upgrade.yml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Pre-cache the images for the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Before starting image pre-caching, verify the subscription policy is <literal>NonCompliant</literal> at this point by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policy common-subscriptions-policy -n &lt;policy_namespace&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          REMEDIATION ACTION   COMPLIANCE STATE     AGE
common-subscriptions-policy   inform               NonCompliant         27d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Enable pre-caching in the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-operator-upgrade \
--patch '{"spec":{"preCaching": true}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the process and wait for the pre-caching to complete. Check the status of pre-caching by running the following command on the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu cgu-operator-upgrade -o jsonpath='{.status.precaching.status}'</programlisting>
</listitem>
<listitem>
<simpara>Check if the pre-caching is completed before starting the update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu -n default cgu-operator-upgrade -ojsonpath='{.status.conditions}' | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">[
    {
      "lastTransitionTime": "2022-03-08T20:49:08.000Z",
      "message": "The ClusterGroupUpgrade CR is not enabled",
      "reason": "UpgradeNotStarted",
      "status": "False",
      "type": "Ready"
    },
    {
      "lastTransitionTime": "2022-03-08T20:55:30.000Z",
      "message": "Precaching is completed",
      "reason": "PrecachingCompleted",
      "status": "True",
      "type": "PrecachingDone"
    }
]</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Start the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enable the <literal>cgu-operator-upgrade</literal> <literal>ClusterGroupUpgrade</literal> CR and disable pre-caching to start the Operator update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-operator-upgrade \
--patch '{"spec":{"enable":true, "preCaching": false}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the process. Upon completion, ensure that the policy is compliant by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about updating GitOps ZTP, see <link linkend="ztp-updating-gitops">Upgrading GitOps ZTP</link>.</simpara>
</listitem>
<listitem>
<simpara><link linkend="cnf-topology-aware-lifecycle-manager-operator-troubleshooting_ztp-talm">Troubleshooting missed Operator updates due to out-of-date policy compliance states</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cnf-topology-aware-lifecycle-manager-operator-troubleshooting_ztp-talm">
<title>Troubleshooting missed Operator updates due to out-of-date policy compliance states</title>
<simpara>In some scenarios, Topology Aware Lifecycle Manager (TALM) might miss Operator updates due to an out-of-date policy compliance state.</simpara>
<simpara>After a catalog source update, it takes time for the Operator Lifecycle Manager (OLM) to update the subscription status. The status of the subscription policy might continue to show as compliant while TALM decides whether remediation is needed. As a result, the Operator specified in the subscription policy does not get upgraded.</simpara>
<simpara>To avoid this scenario, add another catalog source configuration to the <literal>PolicyGenTemplate</literal> and specify this configuration in the subscription for any Operators that require an update.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a catalog source configuration in the <literal>PolicyGenTemplate</literal> resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- fileName: DefaultCatsrc.yaml
      remediationAction: inform
      policyName: "operator-catsrc-policy"
      metadata:
        name: redhat-operators
      spec:
        displayName: Red Hat Operators Catalog
        image: registry.example.com:5000/olm/redhat-operators:v{product-version}
        updateStrategy:
          registryPoll:
            interval: 1h
      status:
        connectionState:
            lastObservedState: READY
- fileName: DefaultCatsrc.yaml
      remediationAction: inform
      policyName: "operator-catsrc-policy"
      metadata:
        name: redhat-operators-v2 <co xml:id="CO118-1"/>
      spec:
        displayName: Red Hat Operators Catalog v2 <co xml:id="CO118-2"/>
        image: registry.example.com:5000/olredhat-operators:&lt;version&gt; <co xml:id="CO118-3"/>
        updateStrategy:
          registryPoll:
            interval: 1h
      status:
        connectionState:
            lastObservedState: READY</programlisting>
<calloutlist>
<callout arearefs="CO118-1">
<para>Update the name for the new configuration.</para>
</callout>
<callout arearefs="CO118-2">
<para>Update the display name for the new configuration.</para>
</callout>
<callout arearefs="CO118-3">
<para>Update the index image URL. This <literal>fileName.spec.image</literal> field overrides any configuration in the <literal>DefaultCatsrc.yaml</literal> file.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the <literal>Subscription</literal> resource to point to the new configuration for Operators that require an update:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: operator-subscription
  namespace: operator-namspace
# ...
spec:
  source: redhat-operators-v2 <co xml:id="CO119-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO119-1">
<para>Enter the name of the additional catalog source configuration that you defined in the <literal>PolicyGenTemplate</literal> resource.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="talo-operator-and-platform-update_ztp-talm">
<title>Performing a platform and an Operator update together</title>
<simpara>You can perform a platform and an Operator update at the same time.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the Topology Aware Lifecycle Manager (TALM).</simpara>
</listitem>
<listitem>
<simpara>Update GitOps Zero Touch Provisioning (ZTP) to the latest version.</simpara>
</listitem>
<listitem>
<simpara>Provision one or more managed clusters with GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Create RHACM policies in the hub cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>PolicyGenTemplate</literal> CR for the updates by following the steps described in the "Performing a platform update" and "Performing an Operator update" sections.</simpara>
</listitem>
<listitem>
<simpara>Apply the prep work for the platform and the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the content of the <literal>ClusterGroupUpgrade</literal> CR with the policies for platform update preparation work, catalog source updates, and target clusters to the <literal>cgu-platform-operator-upgrade-prep.yml</literal> file, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-platform-operator-upgrade-prep
  namespace: default
spec:
  managedPolicies:
  - du-upgrade-platform-upgrade-prep
  - du-upgrade-operator-catsrc-policy
  clusterSelector:
  - group-du-sno
  remediationStrategy:
    maxConcurrency: 10
  enable: true</programlisting>
</listitem>
<listitem>
<simpara>Apply the <literal>cgu-platform-operator-upgrade-prep.yml</literal> file to the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-platform-operator-upgrade-prep.yml</programlisting>
</listitem>
<listitem>
<simpara>Monitor the process. Upon completion, ensure that the policy is compliant by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterGroupUpdate</literal> CR for the platform and the Operator update with the <literal>spec.enable</literal> field set to <literal>false</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the contents of the platform and Operator update <literal>ClusterGroupUpdate</literal> CR with the policies and the target clusters to the <literal>cgu-platform-operator-upgrade.yml</literal> file, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu-du-upgrade
  namespace: default
spec:
  managedPolicies:
  - du-upgrade-platform-upgrade <co xml:id="CO120-1"/>
  - du-upgrade-operator-catsrc-policy <co xml:id="CO120-2"/>
  - common-subscriptions-policy <co xml:id="CO120-3"/>
  preCaching: true
  clusterSelector:
  - group-du-sno
  remediationStrategy:
    maxConcurrency: 1
  enable: false</programlisting>
<calloutlist>
<callout arearefs="CO120-1">
<para>This is the platform update policy.</para>
</callout>
<callout arearefs="CO120-2">
<para>This is the policy containing the catalog source information for the Operators to be updated. It is needed for the pre-caching feature to determine which Operator images to download to the managed cluster.</para>
</callout>
<callout arearefs="CO120-3">
<para>This is the policy to update the Operators.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the <literal>cgu-platform-operator-upgrade.yml</literal> file to the hub cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu-platform-operator-upgrade.yml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Pre-cache the images for the platform and the Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enable pre-caching in the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-du-upgrade \
--patch '{"spec":{"preCaching": true}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the update process and wait for the pre-caching to complete. Check the status of pre-caching by running the following command on the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jobs,pods -n openshift-talm-pre-cache</programlisting>
</listitem>
<listitem>
<simpara>Check if the pre-caching is completed before starting the update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu cgu-du-upgrade -ojsonpath='{.status.conditions}'</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Start the platform and Operator update.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enable the <literal>cgu-du-upgrade</literal> <literal>ClusterGroupUpgrade</literal> CR to start the platform and the Operator update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace=default patch clustergroupupgrade.ran.openshift.io/cgu-du-upgrade \
--patch '{"spec":{"enable":true, "preCaching": false}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Monitor the process. Upon completion, ensure that the policy is compliant by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policies --all-namespaces</programlisting>
<note>
<simpara>The CRs for the platform and Operator updates can be created from the beginning by configuring the setting to <literal>spec.enable: true</literal>. In this case, the update starts immediately after pre-caching completes and there is no need to manually enable the CR.</simpara>
<simpara>Both pre-caching and the update create extra resources, such as policies, placement bindings, placement rules, managed cluster actions, and managed cluster view, to help complete the procedures. Setting the <literal>afterCompletion.deleteObjects</literal> field to <literal>true</literal> deletes all these resources after the updates complete.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="talm-pao-update_ztp-talm">
<title>Removing Performance Addon Operator subscriptions from deployed clusters</title>
<simpara>In earlier versions of OpenShift Container Platform, the Performance Addon Operator provided automatic, low latency performance tuning for applications. In OpenShift Container Platform 4.11 or later, these functions are part of the Node Tuning Operator.</simpara>
<simpara>Do not install the Performance Addon Operator on clusters running OpenShift Container Platform 4.11 or later. If you upgrade to OpenShift Container Platform 4.11 or later, the Node Tuning Operator automatically removes the Performance Addon Operator.</simpara>
<note>
<simpara>You need to remove any policies that create Performance Addon Operator subscriptions to prevent a re-installation of the Operator.</simpara>
</note>
<simpara>The reference DU profile includes the Performance Addon Operator in the <literal>PolicyGenTemplate</literal> CR <literal>common-ranGen.yaml</literal>. To remove the subscription from deployed managed clusters, you must update <literal>common-ranGen.yaml</literal>.</simpara>
<note>
<simpara>If you install Performance Addon Operator 4.10.3-5 or later on OpenShift Container Platform 4.11 or later, the Performance Addon Operator detects the cluster version and automatically hibernates to avoid interfering with the Node Tuning Operator functions. However, to ensure best performance, remove the Performance Addon Operator from your OpenShift Container Platform 4.11 clusters.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a Git repository where you manage your custom site configuration data. The repository must be accessible from the hub cluster and be defined as a source repository for ArgoCD.</simpara>
</listitem>
<listitem>
<simpara>Update to OpenShift Container Platform 4.11 or later.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change the <literal>complianceType</literal> to <literal>mustnothave</literal> for the Performance Addon Operator namespace, Operator group, and subscription in the <literal>common-ranGen.yaml</literal> file.</simpara>
<programlisting language="yaml" linenumbering="unnumbered"> -  fileName: PaoSubscriptionNS.yaml
    policyName: "subscriptions-policy"
    complianceType: mustnothave
 -  fileName: PaoSubscriptionOperGroup.yaml
    policyName: "subscriptions-policy"
    complianceType: mustnothave
 -  fileName: PaoSubscription.yaml
    policyName: "subscriptions-policy"
    complianceType: mustnothave</programlisting>
</listitem>
<listitem>
<simpara>Merge the changes with your custom site repository and wait for the ArgoCD application to synchronize the change to the hub cluster. The status of the <literal>common-subscriptions-policy</literal> policy changes to <literal>Non-Compliant</literal>.</simpara>
</listitem>
<listitem>
<simpara>Apply the change to your target clusters by using the Topology Aware Lifecycle Manager. For more information about rolling out configuration changes, see the "Additional resources" section.</simpara>
</listitem>
<listitem>
<simpara>Monitor the process. When the status of the <literal>common-subscriptions-policy</literal> policy for a target cluster  is <literal>Compliant</literal>, the Performance Addon Operator has been removed from the cluster. Get the status of the <literal>common-subscriptions-policy</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get policy -n ztp-common common-subscriptions-policy</programlisting>
</listitem>
<listitem>
<simpara>Delete the Performance Addon Operator namespace, Operator group and subscription CRs from <literal>.spec.sourceFiles</literal> in the <literal>common-ranGen.yaml</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Merge the changes with your custom site repository and wait for the ArgoCD application to synchronize the change to the hub cluster. The policy remains compliant.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="talm-prechache-user-specified-images-concept_ztp-talm">
<title>Pre-caching user-specified images with TALM on single-node OpenShift clusters</title>
<simpara>You can pre-cache application-specific workload images on single-node OpenShift clusters before upgrading your applications.</simpara>
<simpara>You can specify the configuration options for the pre-caching jobs using the following custom resources (CR):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>PreCachingConfig</literal> CR</simpara>
</listitem>
<listitem>
<simpara><literal>ClusterGroupUpgrade</literal> CR</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>All fields in the <literal>PreCachingConfig</literal> CR are optional.</simpara>
</note>
<formalpara>
<title>Example PreCachingConfig CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: PreCachingConfig
metadata:
  name: exampleconfig
  namespace: exampleconfig-ns
spec:
  overrides: <co xml:id="CO121-1"/>
    platformImage: quay.io/openshift-release-dev/ocp-release@sha256:3d5800990dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47e2e1ef
    operatorsIndexes:
      - registry.example.com:5000/custom-redhat-operators:1.0.0
    operatorsPackagesAndChannels:
      - local-storage-operator: stable
      - ptp-operator: stable
      - sriov-network-operator: stable
  spaceRequired: 30 Gi <co xml:id="CO121-2"/>
  excludePrecachePatterns: <co xml:id="CO121-3"/>
    - aws
    - vsphere
  additionalImages: <co xml:id="CO121-4"/>
    - quay.io/exampleconfig/application1@sha256:3d5800990dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47e2e1ef
    - quay.io/exampleconfig/application2@sha256:3d5800123dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47adfaef
    - quay.io/exampleconfig/applicationN@sha256:4fe1334adfafadsf987123adfffdaf1243340adfafdedga0991234afdadfsa09</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO121-1">
<para>By default, TALM automatically populates the <literal>platformImage</literal>, <literal>operatorsIndexes</literal>, and the <literal>operatorsPackagesAndChannels</literal> fields from the policies of the managed clusters. You can specify values to override the default TALM-derived values for these fields.</para>
</callout>
<callout arearefs="CO121-2">
<para>Specifies the minimum required disk space on the cluster. If unspecified, TALM defines a default value for OpenShift Container Platform images. The disk space field must include an integer value and the storage unit. For example: <literal>40 GiB</literal>, <literal>200 MB</literal>, <literal>1 TiB</literal>.</para>
</callout>
<callout arearefs="CO121-3">
<para>Specifies the images to exclude from pre-caching based on image name matching.</para>
</callout>
<callout arearefs="CO121-4">
<para>Specifies the list of additional images to pre-cache.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example ClusterGroupUpgrade CR with PreCachingConfig CR reference</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu
spec:
  preCaching: true <co xml:id="CO122-1"/>
  preCachingConfigRef:
    name: exampleconfig <co xml:id="CO122-2"/>
    namespace: exampleconfig-ns <co xml:id="CO122-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO122-1">
<para>The <literal>preCaching</literal> field set to <literal>true</literal> enables the pre-caching job.</para>
</callout>
<callout arearefs="CO122-2">
<para>The <literal>preCachingConfigRef.name</literal> field specifies the <literal>PreCachingConfig</literal> CR that you want to use.</para>
</callout>
<callout arearefs="CO122-3">
<para>The <literal>preCachingConfigRef.namespace</literal> specifies the namespace of the <literal>PreCachingConfig</literal> CR that you want to use.</para>
</callout>
</calloutlist>
<section xml:id="talm-prechache-user-specified-images-preparing-crs_ztp-talm">
<title>Creating the custom resources for pre-caching</title>
<simpara>You must create the <literal>PreCachingConfig</literal> CR before or concurrently with the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the <literal>PreCachingConfig</literal> CR with the list of additional images you want to pre-cache.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: PreCachingConfig
metadata:
  name: exampleconfig
  namespace: default <co xml:id="CO123-1"/>
spec:
[...]
  spaceRequired: 30Gi <co xml:id="CO123-2"/>
  additionalImages:
    - quay.io/exampleconfig/application1@sha256:3d5800990dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47e2e1ef
    - quay.io/exampleconfig/application2@sha256:3d5800123dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47adfaef
    - quay.io/exampleconfig/applicationN@sha256:4fe1334adfafadsf987123adfffdaf1243340adfafdedga0991234afdadfsa09</programlisting>
<calloutlist>
<callout arearefs="CO123-1">
<para>The <literal>namespace</literal> must be accessible to the hub cluster.</para>
</callout>
<callout arearefs="CO123-2">
<para>It is recommended to set the minimum disk space required field to ensure that there is sufficient storage space for the pre-cached images.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>ClusterGroupUpgrade</literal> CR with the <literal>preCaching</literal> field set to <literal>true</literal> and specify the <literal>PreCachingConfig</literal> CR created in the previous step:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: cgu
  namespace: default
spec:
  clusters:
  - sno1
  - sno2
  preCaching: true
  preCachingConfigRef:
  - name: exampleconfig
    namespace: default
  managedPolicies:
    - du-upgrade-platform-upgrade
    - du-upgrade-operator-catsrc-policy
    - common-subscriptions-policy
  remediationStrategy:
    timeout: 240</programlisting>
<warning>
<simpara>Once you install the images on the cluster, you cannot change or delete them.</simpara>
</warning>
</listitem>
<listitem>
<simpara>When you want to start pre-caching the images, apply the <literal>ClusterGroupUpgrade</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cgu.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>TALM verifies the <literal>ClusterGroupUpgrade</literal> CR.</simpara>
<simpara>From this point, you can continue with the TALM pre-caching workflow.</simpara>
<note>
<simpara>All sites are pre-cached concurrently.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the pre-caching status on the hub cluster where the <literal>ClusterUpgradeGroup</literal> CR is applied by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cgu &lt;cgu_name&gt; -n &lt;cgu_namespace&gt; -oyaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  precaching:
    spec:
      platformImage: quay.io/openshift-release-dev/ocp-release@sha256:3d5800990dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47e2e1ef
      operatorsIndexes:
        - registry.example.com:5000/custom-redhat-operators:1.0.0
      operatorsPackagesAndChannels:
        - local-storage-operator: stable
        - ptp-operator: stable
        - sriov-network-operator: stable
      excludePrecachePatterns:
        - aws
        - vsphere
      additionalImages:
        - quay.io/exampleconfig/application1@sha256:3d5800990dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47e2e1ef
        - quay.io/exampleconfig/application2@sha256:3d5800123dee7cd4727d3fe238a97e2d2976d3808fc925ada29c559a47adfaef
        - quay.io/exampleconfig/applicationN@sha256:4fe1334adfafadsf987123adfffdaf1243340adfafdedga0991234afdadfsa09
      spaceRequired: "30"
    status:
      sno1: Starting
      sno2: Starting</programlisting>
</para>
</formalpara>
<simpara>The pre-caching configurations are validated by checking if the managed policies exist.
Valid configurations of the <literal>ClusterGroupUpgrade</literal> and the <literal>PreCachingConfig</literal> CRs result in the following statuses:</simpara>
<formalpara>
<title>Example output of valid CRs</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">- lastTransitionTime: "2023-01-01T00:00:01Z"
  message: All selected clusters are valid
  reason: ClusterSelectionCompleted
  status: "True"
  type: ClusterSelected
- lastTransitionTime: "2023-01-01T00:00:02Z"
  message: Completed validation
  reason: ValidationCompleted
  status: "True"
  type: Validated
- lastTransitionTime: "2023-01-01T00:00:03Z"
  message: Precaching spec is valid and consistent
  reason: PrecacheSpecIsWellFormed
  status: "True"
  type: PrecacheSpecValid
- lastTransitionTime: "2023-01-01T00:00:04Z"
  message: Precaching in progress for 1 clusters
  reason: InProgress
  status: "False"
  type: PrecachingSucceeded</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example of an invalid PreCachingConfig CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">Type:    "PrecacheSpecValid"
Status:  False,
Reason:  "PrecacheSpecIncomplete"
Message: "Precaching spec is incomplete: failed to get PreCachingConfig resource due to PreCachingConfig.ran.openshift.io "&lt;pre-caching_cr_name&gt;" not found"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can find the pre-caching job by running the following command on the managed cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jobs -n openshift-talo-pre-cache</programlisting>
<formalpara>
<title>Example of pre-caching job in progress</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        COMPLETIONS       DURATION      AGE
pre-cache   0/1               1s            1s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can check the status of the pod created for the pre-caching job by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod pre-cache -n openshift-talo-pre-cache</programlisting>
<formalpara>
<title>Example of pre-caching job in progress</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Type        Reason              Age    From              Message
Normal      SuccesfulCreate     19s    job-controller    Created pod: pre-cache-abcd1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can get live updates on the status of the job by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -f pre-cache-abcd1 -n openshift-talo-pre-cache</programlisting>
</listitem>
<listitem>
<simpara>To verify the pre-cache job is successfully completed, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod pre-cache -n openshift-talo-pre-cache</programlisting>
<formalpara>
<title>Example of completed pre-cache job</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Type        Reason              Age    From              Message
Normal      SuccesfulCreate     5m19s  job-controller    Created pod: pre-cache-abcd1
Normal      Completed           19s    job-controller    Job completed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To verify that the images are successfully pre-cached on the single-node OpenShift, do the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter into the node in debug mode:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/cnfdf00.example.lab</programlisting>
</listitem>
<listitem>
<simpara>Change root to <literal>host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chroot /host/</programlisting>
</listitem>
<listitem>
<simpara>Search for the desired images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo podman images | grep &lt;operator_name&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about the TALM pre-caching workflow, see <link linkend="talo-precache-feature-concept_cnf-topology-aware-lifecycle-manager">Using the container image pre-cache feature</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="talo-precache-autocreated-cgu-for-ztp_ztp-talm">
<title>About the auto-created ClusterGroupUpgrade CR for GitOps ZTP</title>
<simpara>TALM has a controller called <literal>ManagedClusterForCGU</literal> that monitors the <literal>Ready</literal> state of the <literal>ManagedCluster</literal> CRs on the hub cluster and creates the <literal>ClusterGroupUpgrade</literal> CRs for GitOps Zero Touch Provisioning (ZTP).</simpara>
<simpara>For any managed cluster in the <literal>Ready</literal> state without a <literal>ztp-done</literal> label applied, the <literal>ManagedClusterForCGU</literal> controller automatically creates a <literal>ClusterGroupUpgrade</literal> CR in the <literal>ztp-install</literal> namespace with its associated RHACM policies that are created during the GitOps ZTP process. TALM then remediates the set of configuration policies that are listed in the auto-created <literal>ClusterGroupUpgrade</literal> CR to push the configuration CRs to the managed cluster.</simpara>
<simpara>If there are no policies for the managed cluster at the time when the cluster becomes <literal>Ready</literal>, a <literal>ClusterGroupUpgrade</literal> CR with no policies is created. Upon completion of the <literal>ClusterGroupUpgrade</literal> the managed cluster is labeled as <literal>ztp-done</literal>. If there are policies that you want to apply for that managed cluster, manually create a <literal>ClusterGroupUpgrade</literal> as a day-2 operation.</simpara>
<formalpara>
<title>Example of an auto-created <literal>ClusterGroupUpgrade</literal> CR for GitOps ZTP</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  generation: 1
  name: spoke1
  namespace: ztp-install
  ownerReferences:
  - apiVersion: cluster.open-cluster-management.io/v1
    blockOwnerDeletion: true
    controller: true
    kind: ManagedCluster
    name: spoke1
    uid: 98fdb9b2-51ee-4ee7-8f57-a84f7f35b9d5
  resourceVersion: "46666836"
  uid: b8be9cd2-764f-4a62-87d6-6b767852c7da
spec:
  actions:
    afterCompletion:
      addClusterLabels:
        ztp-done: "" <co xml:id="CO124-1"/>
      deleteClusterLabels:
        ztp-running: ""
      deleteObjects: true
    beforeEnable:
      addClusterLabels:
        ztp-running: "" <co xml:id="CO124-2"/>
  clusters:
  - spoke1
  enable: true
  managedPolicies:
  - common-spoke1-config-policy
  - common-spoke1-subscriptions-policy
  - group-spoke1-config-policy
  - spoke1-config-policy
  - group-spoke1-validator-du-policy
  preCaching: false
  remediationStrategy:
    maxConcurrency: 1
    timeout: 240</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO124-1">
<para>Applied to the managed cluster when TALM completes the cluster configuration.</para>
</callout>
<callout arearefs="CO124-2">
<para>Applied to the managed cluster when TALM starts deploying the configuration policies.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="ztp-updating-gitops">
<title>Updating GitOps ZTP</title>
<simpara>You can update the GitOps Zero Touch Provisioning (ZTP) infrastructure independently from the hub cluster, Red Hat Advanced Cluster Management (RHACM), and the managed OpenShift Container Platform clusters.</simpara>
<note>
<simpara>You can update the Red Hat OpenShift GitOps Operator when new versions become available. When updating the GitOps ZTP plugin, review the updated files in the reference configuration and ensure that the changes meet your requirements.</simpara>
</note>
<section xml:id="ztp-updating-gitops-ztp_ztp-updating-gitops">
<title>Overview of the GitOps ZTP update process</title>
<simpara>You can update GitOps Zero Touch Provisioning (ZTP) for a fully operational hub cluster running an earlier version of the GitOps ZTP infrastructure. The update process avoids impact on managed clusters.</simpara>
<note>
<simpara>Any changes to policy settings, including adding recommended content, results in updated polices that must be rolled out to the managed clusters and reconciled.</simpara>
</note>
<simpara>At a high level, the strategy for updating the GitOps ZTP infrastructure is as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Label all existing clusters with the <literal>ztp-done</literal> label.</simpara>
</listitem>
<listitem>
<simpara>Stop the ArgoCD applications.</simpara>
</listitem>
<listitem>
<simpara>Install the new GitOps ZTP tools.</simpara>
</listitem>
<listitem>
<simpara>Update required content and optional changes in the Git repository.</simpara>
</listitem>
<listitem>
<simpara>Update and restart the application configuration.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-preparing-for-the-gitops-ztp-upgrade_ztp-updating-gitops">
<title>Preparing for the upgrade</title>
<simpara>Use the following procedure to prepare your site for the GitOps Zero Touch Provisioning (ZTP) upgrade.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the latest version of the GitOps ZTP container that has the custom resources (CRs) used to configure Red Hat OpenShift GitOps for use with GitOps ZTP.</simpara>
</listitem>
<listitem>
<simpara>Extract the <literal>argocd/deployment</literal> directory by using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p ./update</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --log-driver=none --rm registry.redhat.io/openshift4/ztp-site-generate-rhel8:v4.14 extract /home/ztp --tar | tar x -C ./update</programlisting>
<simpara>The <literal>/update</literal> directory contains the following subdirectories:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>update/extra-manifest</literal>: contains the source CR files that the <literal>SiteConfig</literal> CR uses to generate the extra manifest <literal>configMap</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>update/source-crs</literal>: contains the source CR files that the <literal>PolicyGenTemplate</literal> CR uses to generate the Red Hat Advanced Cluster Management (RHACM) policies.</simpara>
</listitem>
<listitem>
<simpara><literal>update/argocd/deployment</literal>: contains patches and YAML files to apply on the hub cluster for use in the next step of this procedure.</simpara>
</listitem>
<listitem>
<simpara><literal>update/argocd/example</literal>: contains example <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> files that represent the recommended configuration.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Update the <literal>clusters-app.yaml</literal> and <literal>policies-app.yaml</literal> files to reflect the name of your applications and the URL, branch, and path for your Git repository.</simpara>
<simpara>If the upgrade includes changes that results in obsolete policies, the obsolete policies should be removed prior to performing the upgrade.</simpara>
</listitem>
<listitem>
<simpara>Diff the changes between the configuration and deployment source CRs in the <literal>/update</literal> folder and Git repo where you manage your fleet site CRs. Apply and push the required changes to your site repository.</simpara>
<important>
<simpara>When you update GitOps ZTP to the latest version, you must apply the changes from the <literal>update/argocd/deployment</literal> directory to your site repository. Do not use older versions of the <literal>argocd/deployment/</literal> files.</simpara>
</important>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-labeling-the-existing-clusters_ztp-updating-gitops">
<title>Labeling the existing clusters</title>
<simpara>To ensure that existing clusters remain untouched by the tool updates, label all existing managed clusters with the <literal>ztp-done</literal> label.</simpara>
<note>
<simpara>This procedure only applies when updating clusters that were not provisioned with Topology Aware Lifecycle Manager (TALM). Clusters that you provision with TALM are automatically labeled with <literal>ztp-done</literal>.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Find a label selector that lists the managed clusters that were deployed with GitOps Zero Touch Provisioning (ZTP), such as <literal>local-cluster!=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedcluster -l 'local-cluster!=true'</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the resulting list contains all the managed clusters that were deployed with GitOps ZTP, and then use that selector to add the <literal>ztp-done</literal> label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label managedcluster -l 'local-cluster!=true' ztp-done=</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-stopping-the-existing-gitops-ztp-applications_ztp-updating-gitops">
<title>Stopping the existing GitOps ZTP applications</title>
<simpara>Removing the existing applications ensures that any changes to existing content in the Git repository are not rolled out until the new version of the tools is available.</simpara>
<simpara>Use the application files from the <literal>deployment</literal> directory. If you used custom names for the applications, update the names in these files first.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Perform a non-cascaded delete on the <literal>clusters</literal> application to leave all generated resources in place:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f update/argocd/deployment/clusters-app.yaml</programlisting>
</listitem>
<listitem>
<simpara>Perform a cascaded delete on the <literal>policies</literal> application to remove all previous policies:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch -f policies-app.yaml -p '{"metadata": {"finalizers": ["resources-finalizer.argocd.argoproj.io"]}}' --type merge</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f update/argocd/deployment/policies-app.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-required-changes-to-the-git-repository_ztp-updating-gitops">
<title>Required changes to the Git repository</title>
<simpara>When upgrading the <literal>ztp-site-generate</literal> container from an earlier release of GitOps Zero Touch Provisioning (ZTP) to 4.10 or later, there are additional requirements for the contents of the Git repository. Existing content in the repository must be updated to reflect these changes.</simpara>
<itemizedlist>
<listitem>
<simpara>Make required changes to <literal>PolicyGenTemplate</literal> files:</simpara>
<simpara>All <literal>PolicyGenTemplate</literal> files must be created in a <literal>Namespace</literal> prefixed with <literal>ztp</literal>. This ensures that the GitOps ZTP application is able to manage the policy CRs generated by GitOps ZTP without conflicting with the way Red Hat Advanced Cluster Management (RHACM) manages the policies internally.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>kustomization.yaml</literal> file to the repository:</simpara>
<simpara>All <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs must be included in a <literal>kustomization.yaml</literal> file under their respective directory trees. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"> policygentemplates
    site1-ns.yaml
    site1.yaml
    site2-ns.yaml
    site2.yaml
    common-ns.yaml
    common-ranGen.yaml
    group-du-sno-ranGen-ns.yaml
    group-du-sno-ranGen.yaml
    kustomization.yaml
 siteconfig
     site1.yaml
     site2.yaml
     kustomization.yaml</programlisting>
<note>
<simpara>The files listed in the <literal>generator</literal> sections must contain either <literal>SiteConfig</literal> or <literal>PolicyGenTemplate</literal> CRs only. If your existing YAML files contain other CRs, for example, <literal>Namespace</literal>, these other CRs must be pulled out into separate files and listed in the <literal>resources</literal> section.</simpara>
</note>
<simpara>The <literal>PolicyGenTemplate</literal> kustomization file must contain all <literal>PolicyGenTemplate</literal> YAML files in the <literal>generator</literal> section and <literal>Namespace</literal> CRs in the <literal>resources</literal> section. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

generators:
- common-ranGen.yaml
- group-du-sno-ranGen.yaml
- site1.yaml
- site2.yaml

resources:
- common-ns.yaml
- group-du-sno-ranGen-ns.yaml
- site1-ns.yaml
- site2-ns.yaml</programlisting>
<simpara>The <literal>SiteConfig</literal> kustomization file must contain all <literal>SiteConfig</literal> YAML files in the <literal>generator</literal> section and any other CRs in the resources:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

generators:
- site1.yaml
- site2.yaml</programlisting>
</listitem>
<listitem>
<simpara>Remove the <literal>pre-sync.yaml</literal> and <literal>post-sync.yaml</literal> files.</simpara>
<simpara>In OpenShift Container Platform 4.10 and later, the <literal>pre-sync.yaml</literal> and <literal>post-sync.yaml</literal> files are no longer required. The <literal>update/deployment/kustomization.yaml</literal> CR manages the policies deployment on the hub cluster.</simpara>
<note>
<simpara>There is a set of <literal>pre-sync.yaml</literal> and <literal>post-sync.yaml</literal> files under both the <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> trees.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review and incorporate recommended changes</simpara>
<simpara>Each release may include additional recommended changes to the configuration applied to deployed clusters. Typically these changes result in lower CPU use by the OpenShift platform, additional features, or improved tuning of the platform.</simpara>
<simpara>Review the reference <literal>SiteConfig</literal> and <literal>PolicyGenTemplate</literal> CRs applicable to the types of cluster in your network. These examples can be found in the <literal>argocd/example</literal> directory extracted from the GitOps ZTP container.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-installing-the-new-gitops-ztp-applications_ztp-updating-gitops">
<title>Installing the new GitOps ZTP applications</title>
<simpara>Using the extracted <literal>argocd/deployment</literal> directory, and after ensuring that the applications point to your site Git repository, apply the full contents of the deployment directory. Applying the full contents of the directory ensures that all necessary resources for the applications are correctly configured.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To patch the ArgoCD instance in the hub cluster by using the patch file that you previously extracted into the <literal>update/argocd/deployment/</literal> directory, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch argocd openshift-gitops \
-n openshift-gitops --type=merge \
--patch-file update/argocd/deployment/argocd-openshift-gitops-patch.json</programlisting>
</listitem>
<listitem>
<simpara>To apply the contents of the <literal>argocd/deployment</literal> directory, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -k update/argocd/deployment</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-roll-out-the-configuration-changes_ztp-updating-gitops">
<title>Rolling out the GitOps ZTP configuration changes</title>
<simpara>If any configuration changes were included in the upgrade due to implementing recommended changes, the upgrade process results in a set of policy CRs on the hub cluster in the <literal>Non-Compliant</literal> state. With the GitOps Zero Touch Provisioning (ZTP) version 4.10 and later <literal>ztp-site-generate</literal> container, these policies are set to <literal>inform</literal> mode and are not pushed to the managed clusters without an additional step by the user. This ensures that potentially disruptive changes to the clusters can be managed in terms of when the changes are made, for example, during a maintenance window, and how many clusters are updated concurrently.</simpara>
<simpara>To roll out the changes, create one or more <literal>ClusterGroupUpgrade</literal> CRs as detailed in the TALM documentation. The CR must contain the list of <literal>Non-Compliant</literal> policies that you want to push out to the managed clusters as well as a list or selector of which clusters should be included in the update.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about the Topology Aware Lifecycle Manager (TALM), see <link linkend="cnf-about-topology-aware-lifecycle-manager-config_cnf-topology-aware-lifecycle-manager">About the Topology Aware Lifecycle Manager configuration</link>.</simpara>
</listitem>
<listitem>
<simpara>For information about creating <literal>ClusterGroupUpgrade</literal> CRs, see <link linkend="talo-precache-autocreated-cgu-for-ztp_ztp-talm">About the auto-created ClusterGroupUpgrade CR for ZTP</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-sno-additional-worker-node">
<title>Expanding single-node OpenShift clusters with GitOps ZTP</title>
<simpara>You can expand single-node OpenShift clusters with GitOps Zero Touch Provisioning (ZTP). When you add worker nodes to single-node OpenShift clusters, the original single-node OpenShift cluster retains the control plane node role. Adding worker nodes does not require any downtime for the existing single-node OpenShift cluster.</simpara>
<note>
<simpara>Although there is no specified limit on the number of worker nodes that you can add to a single-node OpenShift cluster, you must revaluate the reserved CPU allocation on the control plane node for the additional worker nodes.</simpara>
</note>
<simpara>If you require workload partitioning on the worker node, you must deploy and remediate the managed cluster policies on the hub cluster before installing the node. This way, the workload partitioning <literal>MachineConfig</literal> objects are rendered and associated with the <literal>worker</literal> machine config pool before the GitOps ZTP workflow applies the <literal>MachineConfig</literal> ignition file to the worker node.</simpara>
<simpara>It is recommended that you first remediate the policies, and then install the worker node.
If you create the workload partitioning manifests after installing the worker node, you must drain the node manually and delete all the pods managed by daemon sets. When the managing daemon sets create the new pods, the new pods undergo the workload partitioning process.</simpara>
<important>
<simpara>Adding worker nodes to single-node OpenShift clusters with GitOps ZTP is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about single-node OpenShift clusters tuned for vDU application deployments, see <link linkend="sno-configure-for-vdu">Reference configuration for deploying vDUs on single-node OpenShift</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about worker nodes, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#adding-worker-nodes-to-single-node-openshift-clusters">Adding worker nodes to single-node OpenShift clusters</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ztp-additional-worker-apply-du-profile_sno-additional-worker">
<title>Applying profiles to the worker node</title>
<simpara>You can configure the additional worker node with a DU profile.</simpara>
<simpara>You can apply a RAN distributed unit (DU) profile to the worker node cluster using the GitOps Zero Touch Provisioning (ZTP) common, group, and site-specific <literal>PolicyGenTemplate</literal> resources. The GitOps ZTP pipeline that is linked to the ArgoCD <literal>policies</literal> application includes the following CRs that you can find in the <literal>out/argocd/example/policygentemplates</literal> folder when you extract the <literal>ztp-site-generate</literal> container:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>common-ranGen.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>group-du-sno-ranGen.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>example-sno-site.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ns.yaml</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kustomization.yaml</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Configuring the DU profile on the worker node is considered an upgrade. To initiate the upgrade flow, you must update the existing policies or create additional ones. Then, you must create a <literal>ClusterGroupUpgrade</literal> CR to reconcile the policies in the group of clusters.</simpara>
</section>
<section xml:id="ztp-additional-worker-daemon-selector-comp_sno-additional-worker">
<title>(Optional) Ensuring PTP and SR-IOV daemon selector compatibility</title>
<simpara>If the DU profile was deployed using the GitOps Zero Touch Provisioning (ZTP) plugin version 4.11 or earlier, the PTP and SR-IOV Operators might be configured to place the daemons only on nodes labelled as <literal>master</literal>. This configuration prevents the PTP and SR-IOV daemons from operating on the worker node. If the PTP and SR-IOV daemon node selectors are incorrectly configured on your system, you must change the daemons before proceeding with the worker DU profile configuration.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the daemon node selector settings of the PTP Operator on one of the spoke clusters:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ptpoperatorconfig/default -n openshift-ptp -ojsonpath='{.spec}' | jq</programlisting>
<formalpara>
<title>Example output for PTP Operator</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"daemonNodeSelector":{"node-role.kubernetes.io/master":""}} <co xml:id="CO125-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO125-1">
<para>If the node selector is set to <literal>master</literal>, the spoke was deployed with the version of the GitOps ZTP plugin that requires changes.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the daemon node selector settings of the SR-IOV Operator on one of the spoke clusters:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc get sriovoperatorconfig/default -n \
openshift-sriov-network-operator -ojsonpath='{.spec}' | jq</programlisting>
<formalpara>
<title>Example output for SR-IOV Operator</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{"configDaemonNodeSelector":{"node-role.kubernetes.io/worker":""},"disableDrain":false,"enableInjector":true,"enableOperatorWebhook":true} <co xml:id="CO126-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO126-1">
<para>If the node selector is set to <literal>master</literal>, the spoke was deployed with the version of the GitOps ZTP plugin that requires changes.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>In the group policy, add the following <literal>complianceType</literal> and <literal>spec</literal> entries:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
    - fileName: PtpOperatorConfig.yaml
      policyName: "config-policy"
      complianceType: mustonlyhave
      spec:
        daemonNodeSelector:
          node-role.kubernetes.io/worker: ""
    - fileName: SriovOperatorConfig.yaml
      policyName: "config-policy"
      complianceType: mustonlyhave
      spec:
        configDaemonNodeSelector:
          node-role.kubernetes.io/worker: ""</programlisting>
<important>
<simpara>Changing the <literal>daemonNodeSelector</literal> field causes temporary PTP synchronization loss and SR-IOV connectivity loss.</simpara>
</important>
</listitem>
<listitem>
<simpara>Commit the changes in Git, and then push to the Git repository being monitored by the GitOps ZTP ArgoCD application.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-additional-worker-node-selector-comp_sno-additional-worker">
<title>PTP and SR-IOV node selector compatibility</title>
<simpara>The PTP configuration resources and SR-IOV network node policies use <literal>node-role.kubernetes.io/master: ""</literal> as the node selector. If the additional worker nodes have the same NIC configuration as the control plane node, the policies used to configure the control plane node can be reused for the worker nodes. However, the node selector must be changed to select both node types, for example with the <literal>"node-role.kubernetes.io/worker"</literal> label.</simpara>
</section>
<section xml:id="ztp-additional-worker-policies_sno-additional-worker">
<title>Using PolicyGenTemplate CRs to apply worker node policies to worker nodes</title>
<simpara>You can create policies for worker nodes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the following policy template:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: PolicyGenTemplate
metadata:
  name: "example-sno-workers"
  namespace: "example-sno"
spec:
  bindingRules:
    sites: "example-sno" <co xml:id="CO127-1"/>
  mcp: "worker" <co xml:id="CO127-2"/>
  sourceFiles:
    - fileName: MachineConfigGeneric.yaml <co xml:id="CO127-3"/>
      policyName: "config-policy"
      metadata:
        labels:
          machineconfiguration.openshift.io/role: worker
        name: enable-workload-partitioning
      spec:
        config:
          storage:
            files:
            - contents:
                source: data:text/plain;charset=utf-8;base64,W2NyaW8ucnVudGltZS53b3JrbG9hZHMubWFuYWdlbWVudF0KYWN0aXZhdGlvbl9hbm5vdGF0aW9uID0gInRhcmdldC53b3JrbG9hZC5vcGVuc2hpZnQuaW8vbWFuYWdlbWVudCIKYW5ub3RhdGlvbl9wcmVmaXggPSAicmVzb3VyY2VzLndvcmtsb2FkLm9wZW5zaGlmdC5pbyIKcmVzb3VyY2VzID0geyAiY3B1c2hhcmVzIiA9IDAsICJjcHVzZXQiID0gIjAtMyIgfQo=
              mode: 420
              overwrite: true
              path: /etc/crio/crio.conf.d/01-workload-partitioning
              user:
                name: root
            - contents:
                source: data:text/plain;charset=utf-8;base64,ewogICJtYW5hZ2VtZW50IjogewogICAgImNwdXNldCI6ICIwLTMiCiAgfQp9Cg==
              mode: 420
              overwrite: true
              path: /etc/kubernetes/openshift-workload-pinning
              user:
                name: root
    - fileName: PerformanceProfile.yaml
      policyName: "config-policy"
      metadata:
        name: openshift-worker-node-performance-profile
      spec:
        cpu: <co xml:id="CO127-4"/>
          isolated: "4-47"
          reserved: "0-3"
        hugepages:
          defaultHugepagesSize: 1G
          pages:
            - size: 1G
              count: 32
        realTimeKernel:
          enabled: true
    - fileName: TunedPerformancePatch.yaml
      policyName: "config-policy"
      metadata:
        name: performance-patch-worker
      spec:
        profile:
          - name: performance-patch-worker
            data: |
              [main]
              summary=Configuration changes profile inherited from performance created tuned
              include=openshift-node-performance-openshift-worker-node-performance-profile
              [bootloader]
              cmdline_crash=nohz_full=4-47 <co xml:id="CO127-5"/>
              [sysctl]
              kernel.timer_migration=1
              [scheduler]
              group.ice-ptp=0:f:10:*:ice-ptp.*
              [service]
              service.stalld=start,enable
              service.chronyd=stop,disable
        recommend:
        - profile: performance-patch-worker</programlisting>
<calloutlist>
<callout arearefs="CO127-1">
<para>The policies are applied to all clusters with this label.</para>
</callout>
<callout arearefs="CO127-2">
<para>The <literal>MCP</literal> field must be set to <literal>worker</literal>.</para>
</callout>
<callout arearefs="CO127-3">
<para>This generic <literal>MachineConfig</literal> CR is used to configure workload partitioning on the worker node.</para>
</callout>
<callout arearefs="CO127-4">
<para>The <literal>cpu.isolated</literal> and <literal>cpu.reserved</literal> fields must be configured for each particular hardware platform.</para>
</callout>
<callout arearefs="CO127-5">
<para>The <literal>cmdline_crash</literal> CPU set must match the <literal>cpu.isolated</literal> set in the <literal>PerformanceProfile</literal> section.</para>
</callout>
</calloutlist>
<simpara>A generic <literal>MachineConfig</literal> CR is used to configure workload partitioning on the worker node. You can generate the content of <literal>crio</literal> and <literal>kubelet</literal> configuration files.</simpara>
</listitem>
<listitem>
<simpara>Add the created policy template to the Git repository monitored by the ArgoCD <literal>policies</literal> application.</simpara>
</listitem>
<listitem>
<simpara>Add the policy in the <literal>kustomization.yaml</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Commit the changes in Git, and then push to the Git repository being monitored by the GitOps ZTP ArgoCD application.</simpara>
</listitem>
<listitem>
<simpara>To remediate the new policies to your spoke cluster, create a TALM custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc apply -f -
apiVersion: ran.openshift.io/v1alpha1
kind: ClusterGroupUpgrade
metadata:
  name: example-sno-worker-policies
  namespace: default
spec:
  backup: false
  clusters:
  - example-sno
  enable: true
  managedPolicies:
  - group-du-sno-config-policy
  - example-sno-workers-config-policy
  - example-sno-config-policy
  preCaching: false
  remediationStrategy:
    maxConcurrency: 1
EOF</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ztp-additional-worker-sno-proc_sno-additional-worker">
<title>Adding worker nodes to single-node OpenShift clusters with GitOps ZTP</title>
<simpara>You can add one or more worker nodes to existing single-node OpenShift clusters to increase available CPU resources in the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install and configure RHACM 2.6 or later in an OpenShift Container Platform 4.11 or later bare-metal hub cluster</simpara>
</listitem>
<listitem>
<simpara>Install Topology Aware Lifecycle Manager in the hub cluster</simpara>
</listitem>
<listitem>
<simpara>Install Red Hat OpenShift GitOps in the hub cluster</simpara>
</listitem>
<listitem>
<simpara>Use the GitOps ZTP <literal>ztp-site-generate</literal> container image version 4.12 or later</simpara>
</listitem>
<listitem>
<simpara>Deploy a managed single-node OpenShift cluster with GitOps ZTP</simpara>
</listitem>
<listitem>
<simpara>Configure the Central Infrastructure Management as described in the RHACM documentation</simpara>
</listitem>
<listitem>
<simpara>Configure the DNS serving the cluster to resolve the internal API endpoint <literal>api-int.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal></simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If you deployed your cluster by using the <literal>example-sno.yaml</literal> <literal>SiteConfig</literal> manifest, add your new worker node to the <literal>spec.clusters['example-sno'].nodes</literal> list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">nodes:
- hostName: "example-node2.example.com"
  role: "worker"
  bmcAddress: "idrac-virtualmedia+https://[1111:2222:3333:4444::bbbb:1]/redfish/v1/Systems/System.Embedded.1"
  bmcCredentialsName:
    name: "example-node2-bmh-secret"
  bootMACAddress: "AA:BB:CC:DD:EE:11"
  bootMode: "UEFI"
  nodeNetwork:
    interfaces:
      - name: eno1
        macAddress: "AA:BB:CC:DD:EE:11"
    config:
      interfaces:
        - name: eno1
          type: ethernet
          state: up
          macAddress: "AA:BB:CC:DD:EE:11"
          ipv4:
            enabled: false
          ipv6:
            enabled: true
            address:
            - ip: 1111:2222:3333:4444::1
              prefix-length: 64
      dns-resolver:
        config:
          search:
          - example.com
          server:
          - 1111:2222:3333:4444::2
      routes:
        config:
        - destination: ::/0
          next-hop-interface: eno1
          next-hop-address: 1111:2222:3333:4444::1
          table-id: 254</programlisting>
</listitem>
<listitem>
<simpara>Create a BMC authentication secret for the new host, as referenced by the <literal>bmcCredentialsName</literal> field in the <literal>spec.nodes</literal> section of your <literal>SiteConfig</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  password: "password"
  username: "username"
kind: Secret
metadata:
  name: "example-node2-bmh-secret"
  namespace: example-sno
type: Opaque</programlisting>
</listitem>
<listitem>
<simpara>Commit the changes in Git, and then push to the Git repository that is being monitored by the GitOps ZTP ArgoCD application.</simpara>
<simpara>When the ArgoCD <literal>cluster</literal> application synchronizes, two new manifests appear on the hub cluster generated by the GitOps ZTP plugin:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>BareMetalHost</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NMStateConfig</literal></simpara>
<important>
<simpara>The <literal>cpuset</literal> field should not be configured for the worker node. Workload partitioning for worker nodes is added through management policies after the node installation is complete.</simpara>
</important>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You can monitor the installation process in several ways.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Check if the preprovisioning images are created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ppimg -n example-sno</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE       NAME            READY   REASON
example-sno     example-sno     True    ImageCreated
example-sno     example-node2   True    ImageCreated</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the state of the bare-metal hosts:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get bmh -n example-sno</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            STATE          CONSUMER   ONLINE   ERROR   AGE
example-sno     provisioned               true             69m
example-node2   provisioning              true             4m50s <co xml:id="CO128-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO128-1">
<para>The <literal>provisioning</literal> state indicates that node booting from the installation media is in progress.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Continuously monitor the installation process:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Watch the agent install process by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get agent -n example-sno --watch</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   CLUSTER   APPROVED   ROLE     STAGE
671bc05d-5358-8940-ec12-d9ad22804faa   example-sno   true       master   Done
[...]
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Starting installation
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Installing
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Writing image to disk
[...]
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Waiting for control plane
[...]
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Rebooting
14fd821b-a35d-9cba-7978-00ddf535ff37   example-sno   true       worker   Done</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>When the worker node installation is finished, the worker node certificates are approved automatically. At this point, the worker appears in the <literal>ManagedClusterInfo</literal> status. Run the following command to see the status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get managedclusterinfo/example-sno -n example-sno -o \
jsonpath='{range .status.nodeList[*]}{.name}{"\t"}{.conditions}{"\t"}{.labels}{"\n"}{end}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">example-sno	[{"status":"True","type":"Ready"}]	{"node-role.kubernetes.io/master":"","node-role.kubernetes.io/worker":""}
example-node2	[{"status":"True","type":"Ready"}]	{"node-role.kubernetes.io/worker":""}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-pre-staging-tool">
<title>Pre-caching images for single-node OpenShift deployments</title>
<simpara>In environments with limited bandwidth where you use the GitOps Zero Touch Provisioning (ZTP) solution to deploy a large number of clusters, you want to avoid downloading all the images that are required for bootstrapping and installing OpenShift Container Platform.
The limited bandwidth at remote single-node OpenShift sites can cause long deployment times.
The factory-precaching-cli tool allows you to pre-stage servers before shipping them to the remote site for ZTP provisioning.</simpara>
<simpara>The factory-precaching-cli tool does the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Downloads the RHCOS rootfs image that is required by the minimal ISO to boot.</simpara>
</listitem>
<listitem>
<simpara>Creates a partition from the installation disk labelled as <literal>data</literal>.</simpara>
</listitem>
<listitem>
<simpara>Formats the disk in xfs.</simpara>
</listitem>
<listitem>
<simpara>Creates a GUID Partition Table (GPT) data partition at the end of the disk, where the size of the partition is configurable by the tool.</simpara>
</listitem>
<listitem>
<simpara>Copies the container images required to install OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Copies the container images required by ZTP to install OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Optional: Copies Day-2 Operators to the partition.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The factory-precaching-cli tool is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="ztp-getting-tool_pre-caching">
<title>Getting the factory-precaching-cli tool</title>
<simpara>The factory-precaching-cli tool Go binary is publicly available in <link xlink:href="https://quay.io/openshift-kni/telco-ran-tools:latest">the {rds-first} tools container image</link>.
The factory-precaching-cli tool Go binary in the container image is executed on the server running an RHCOS live image using <literal>podman</literal>.
If you are working in a disconnected environment or have a private registry, you need to copy the image there so you can download the image to the server.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Pull the factory-precaching-cli tool image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman pull quay.io/openshift-kni/telco-ran-tools:latest</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To check that the tool is available, query the current version of the factory-precaching-cli tool Go binary:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run quay.io/openshift-kni/telco-ran-tools:latest -- factory-precaching-cli -v</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">factory-precaching-cli version 20221018.120852+main.feecf17</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-booting-from-live-os_pre-caching">
<title>Booting from a live operating system image</title>
<simpara>You can use the factory-precaching-cli tool with to boot servers where only one disk is available and external disk drive cannot be attached to the server.</simpara>
<warning>
<simpara>RHCOS requires the disk to not be in use when the disk is about to be written with an RHCOS image.</simpara>
</warning>
<simpara>Depending on the server hardware, you can mount the RHCOS live ISO on the blank server using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Using the Dell RACADM tool on a Dell server.</simpara>
</listitem>
<listitem>
<simpara>Using the HPONCFG tool on a HP server.</simpara>
</listitem>
<listitem>
<simpara>Using the Redfish BMC API.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It is recommended to automate the mounting procedure. To automate the procedure, you need to pull the required images and host them on a local HTTP server.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You powered up the host.</simpara>
</listitem>
<listitem>
<simpara>You have network connectivity to the host.</simpara>
</listitem>
</itemizedlist>
<note>
<title>Procedure</title>
<simpara>This example procedure uses the Redfish BMC API to mount the RHCOS live ISO.</simpara>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mount the RHCOS live ISO:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check virtual media status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --globoff -H "Content-Type: application/json" -H \
"Accept: application/json" -k -X GET --user ${username_password} \
https://$BMC_ADDRESS/redfish/v1/Managers/Self/VirtualMedia/1 | python -m json.tool</programlisting>
</listitem>
<listitem>
<simpara>Mount the ISO file as a virtual media:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --globoff -L -w "%{http_code} %{url_effective}\\n" -ku ${username_password} -H "Content-Type: application/json" -H "Accept: application/json" -d '{"Image": "http://[$HTTPd_IP]/RHCOS-live.iso"}' -X POST https://$BMC_ADDRESS/redfish/v1/Managers/Self/VirtualMedia/1/Actions/VirtualMedia.InsertMedia</programlisting>
</listitem>
<listitem>
<simpara>Set the boot order to boot from the virtual media once:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --globoff  -L -w "%{http_code} %{url_effective}\\n"  -ku ${username_password}  -H "Content-Type: application/json" -H "Accept: application/json" -d '{"Boot":{ "BootSourceOverrideEnabled": "Once", "BootSourceOverrideTarget": "Cd", "BootSourceOverrideMode": "UEFI"}}' -X PATCH https://$BMC_ADDRESS/redfish/v1/Systems/Self</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Reboot and ensure that the server is booting from virtual media.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about the <literal>butane</literal> utility, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-special-config-butane-about_installing-customizing">About Butane</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about creating a custom live RHCOS ISO, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#create-custom-live-rhcos-iso_install-sno-installing-sno-with-the-assisted-installer">Creating a custom live RHCOS ISO for remote server access</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about using the Dell RACADM tool, see <link xlink:href="https://www.dell.com/support/manuals/en-ie/poweredge-r440/idrac9_6.xx_racadm_pub/supported-racadm-interfaces?guid=guid-a5747353-fc88-4438-b617-c50ca260448e&amp;lang=en-us">Integrated Dell Remote Access Controller 9 RACADM CLI Guide</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about using the HP HPONCFG tool, see <link xlink:href="https://support.hpe.com/hpesc/public/docDisplay?docId=emr_na-a00007610en_us">Using HPONCFG</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about using the Redfish BMC API, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#install-booting-from-an-iso-over-http-redfish_install-sno-installing-sno-with-the-assisted-installer">Booting from an HTTP-hosted ISO image using the Redfish API</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-partitioning_pre-caching">
<title>Partitioning the disk</title>
<simpara>To run the full pre-caching process, you have to boot from a live ISO and use the factory-precaching-cli tool from a container image to partition and pre-cache all the artifacts required.</simpara>
<simpara>A live ISO or RHCOS live ISO is required because the disk must not be in use when the operating system (RHCOS) is written to the device during the provisioning.
Single-disk servers can also be enabled with this procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a disk that is not partitioned.</simpara>
</listitem>
<listitem>
<simpara>You have access to the <literal>quay.io/openshift-kni/telco-ran-tools:latest</literal> image.</simpara>
</listitem>
<listitem>
<simpara>You have enough storage to install OpenShift Container Platform and pre-cache the required images.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Verify that the disk is cleared:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># lsblk</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME    MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
loop0     7:0    0  93.8G  0 loop /run/ephemeral
loop1     7:1    0 897.3M  1 loop /sysroot
sr0      11:0    1   999M  0 rom  /run/media/iso
nvme0n1 259:1    0   1.5T  0 disk</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Erase any file system, RAID or partition table signatures from the device:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># wipefs -a /dev/nvme0n1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/dev/nvme0n1: 8 bytes were erased at offset 0x00000200 (gpt): 45 46 49 20 50 41 52 54
/dev/nvme0n1: 8 bytes were erased at offset 0x1749a955e00 (gpt): 45 46 49 20 50 41 52 54
/dev/nvme0n1: 2 bytes were erased at offset 0x000001fe (PMBR): 55 aa</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<important>
<simpara>The tool fails if the disk is not empty because it uses partition number 1 of the device for pre-caching the artifacts.</simpara>
</important>
<section xml:id="ztp-create-partition_pre-caching">
<title>Creating the partition</title>
<simpara>Once the device is ready, you create a single partition and a GPT partition table.
The partition is automatically labelled as <literal>data</literal> and created at the end of the device.
Otherwise, the partition will be overridden by the <literal>coreos-installer</literal>.</simpara>
<important>
<simpara>The <literal>coreos-installer</literal> requires the partition to be created at the end of the device and to be labelled as <literal>data</literal>. Both requirements are necessary to save the partition when writing the RHCOS image to the disk.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The container must run as <literal>privileged</literal> due to formatting host devices.</simpara>
</listitem>
<listitem>
<simpara>You have to mount the <literal>/dev</literal> folder so that the process can be executed inside the container.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>In the following example, the size of the partition is 250 GiB due to allow pre-caching the DU profile for Day 2 Operators.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the container as <literal>privileged</literal> and partition the disk:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /dev:/dev --privileged \
--rm quay.io/openshift-kni/telco-ran-tools:latest -- \
factory-precaching-cli partition \ <co xml:id="CO129-1"/>
-d /dev/nvme0n1 \ <co xml:id="CO129-2"/>
-s 250 <co xml:id="CO129-3"/></programlisting>
<calloutlist>
<callout arearefs="CO129-1">
<para>Specifies the partitioning function of the factory-precaching-cli tool.</para>
</callout>
<callout arearefs="CO129-2">
<para>Defines the root directory on the disk.</para>
</callout>
<callout arearefs="CO129-3">
<para>Defines the size of the disk in GB.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the storage information:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># lsblk</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
loop0         7:0    0  93.8G  0 loop /run/ephemeral
loop1         7:1    0 897.3M  1 loop /sysroot
sr0          11:0    1   999M  0 rom  /run/media/iso
nvme0n1     259:1    0   1.5T  0 disk
nvme0n1p1 259:3    0   250G  0 part</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You must verify that the following requirements are met:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>The device has a GPT partition table</simpara>
</listitem>
<listitem>
<simpara>The partition uses the latest sectors of the device.</simpara>
</listitem>
<listitem>
<simpara>The partition is correctly labeled as <literal>data</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>Query the disk status to verify that the disk is partitioned as expected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># gdisk -l /dev/nvme0n1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">GPT fdisk (gdisk) version 1.0.3

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.
Disk /dev/nvme0n1: 3125627568 sectors, 1.5 TiB
Model: Dell Express Flash PM1725b 1.6TB SFF
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): CB5A9D44-9B3C-4174-A5C1-C64957910B61
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 3125627534
Partitions will be aligned on 2048-sector boundaries
Total free space is 2601338846 sectors (1.2 TiB)

Number  Start (sector)    End (sector)  Size       Code  Name
   1      2601338880      3125627534   250.0 GiB   8300  data</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ztp-mount-partition_pre-caching">
<title>Mounting the partition</title>
<simpara>After verifying that the disk is partitioned correctly, you can mount the device into <literal>/mnt</literal>.</simpara>
<important>
<simpara>It is recommended to mount the device into <literal>/mnt</literal> because that mounting point is used during GitOps ZTP preparation.</simpara>
</important>
<orderedlist numeration="arabic">
<listitem>
<simpara>Verify that the partition is formatted as <literal>xfs</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># lsblk -f /dev/nvme0n1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        FSTYPE LABEL UUID                                 MOUNTPOINT
nvme0n1
nvme0n1p1 xfs          1bee8ea4-d6cf-4339-b690-a76594794071</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Mount the partition:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># mount /dev/nvme0n1p1 /mnt/</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the partition is mounted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># lsblk</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
loop0         7:0    0  93.8G  0 loop /run/ephemeral
loop1         7:1    0 897.3M  1 loop /sysroot
sr0          11:0    1   999M  0 rom  /run/media/iso
nvme0n1     259:1    0   1.5T  0 disk
nvme0n1p1 259:2    0   250G  0 part /var/mnt <co xml:id="CO130-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO130-1">
<para>The mount point is <literal>/var/mnt</literal> because the <literal>/mnt</literal> folder in RHCOS is a link to <literal>/var/mnt</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-downloading-images_pre-caching">
<title>Downloading the images</title>
<simpara>The factory-precaching-cli tool allows you to download the following images to your partitioned server:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform images</simpara>
</listitem>
<listitem>
<simpara>Operator images that are included in the distributed unit (DU) profile for 5G RAN sites</simpara>
</listitem>
<listitem>
<simpara>Operator images from disconnected registries</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The list of available Operator images can vary in different OpenShift Container Platform releases.</simpara>
</note>
<section xml:id="ztp-downloading-images-parallel-workers_pre-caching">
<title>Downloading with parallel workers</title>
<simpara>The factory-precaching-cli tool uses parallel workers to download multiple images simultaneously.
You can configure the number of workers with the <literal>--parallel</literal> or <literal>-p</literal> option.
The default number is set to 80% of the available CPUs to the server.</simpara>
<note>
<simpara>Your login shell may be restricted to a subset of CPUs, which reduces the CPUs available to the container.
To remove this restriction, you can precede your commands with <literal>taskset 0xffffffff</literal>, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># taskset 0xffffffff podman run --rm quay.io/openshift-kni/telco-ran-tools:latest factory-precaching-cli download --help</programlisting>
</note>
</section>
<section xml:id="ztp-preparing-ocp-images_pre-caching">
<title>Preparing to download the OpenShift Container Platform images</title>
<simpara>To download OpenShift Container Platform container images, you need to know the multicluster engine (MCE) version. When you use the <literal>--du-profile</literal> flag, you also need to specify the Red Hat Advanced Cluster Management (RHACM) version running in the hub cluster that is going to provision the single-node OpenShift.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have RHACM and MCE installed.</simpara>
</listitem>
<listitem>
<simpara>You partitioned the storage device.</simpara>
</listitem>
<listitem>
<simpara>You have enough space for the images on the partitioned device.</simpara>
</listitem>
<listitem>
<simpara>You connected the bare-metal server to the Internet.</simpara>
</listitem>
<listitem>
<simpara>You have a valid pull secret.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check the RHACM and MCE version by running the following commands in the hub cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -A | grep -i advanced-cluster-management</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">open-cluster-management                            advanced-cluster-management.v2.6.3           Advanced Cluster Management for Kubernetes   2.6.3                 advanced-cluster-management.v2.6.3                Succeeded</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -A | grep -i multicluster-engine</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">multicluster-engine                                cluster-group-upgrades-operator.v0.0.3       cluster-group-upgrades-operator              0.0.3                                                                   Pending
multicluster-engine                                multicluster-engine.v2.1.4                   multicluster engine for Kubernetes           2.1.4                 multicluster-engine.v2.0.3                        Succeeded
multicluster-engine                                openshift-gitops-operator.v1.5.7             Red Hat OpenShift GitOps                     1.5.7                 openshift-gitops-operator.v1.5.6-0.1664915551.p   Succeeded
multicluster-engine                                openshift-pipelines-operator-rh.v1.6.4       Red Hat OpenShift Pipelines                  1.6.4                 openshift-pipelines-operator-rh.v1.6.3            Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To access the container registry, copy a valid pull secret on the server to be installed:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create the <literal>.docker</literal> folder:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir /root/.docker</programlisting>
</listitem>
<listitem>
<simpara>Copy the valid pull in the <literal>config.json</literal> file to the previously created <literal>.docker/</literal> folder:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cp config.json /root/.docker/config.json <co xml:id="CO131-1"/></programlisting>
<calloutlist>
<callout arearefs="CO131-1">
<para><literal>/root/.docker/config.json</literal> is the default path where <literal>podman</literal> checks for the login credentials for the registry.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>If you use a different registry to pull the required artifacts, you need to copy the proper pull secret.
If the local registry uses TLS, you need to include the certificates from the registry as well.</simpara>
</note>
</section>
<section xml:id="ztp-downloading-ocp-images_pre-caching">
<title>Downloading the OpenShift Container Platform images</title>
<simpara>The factory-precaching-cli tool allows you to pre-cache all the container images required to provision a specific OpenShift Container Platform release.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Pre-cache the release by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker --privileged --rm quay.io/openshift-kni/telco-ran-tools -- \
   factory-precaching-cli download \ <co xml:id="CO132-1"/>
   -r 4.12.0 \ <co xml:id="CO132-2"/>
   --acm-version 2.6.3 \ <co xml:id="CO132-3"/>
   --mce-version 2.1.4 \ <co xml:id="CO132-4"/>
   -f /mnt \ <co xml:id="CO132-5"/>
   --img quay.io/custom/repository <co xml:id="CO132-6"/></programlisting>
<calloutlist>
<callout arearefs="CO132-1">
<para>Specifies the downloading function of the factory-precaching-cli tool.</para>
</callout>
<callout arearefs="CO132-2">
<para>Defines the OpenShift Container Platform release version.</para>
</callout>
<callout arearefs="CO132-3">
<para>Defines the RHACM version.</para>
</callout>
<callout arearefs="CO132-4">
<para>Defines the MCE version.</para>
</callout>
<callout arearefs="CO132-5">
<para>Defines the folder where you want to download the images on the disk.</para>
</callout>
<callout arearefs="CO132-6">
<para>Optional. Defines the repository where you store your additional images. These images are downloaded and pre-cached on the disk.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Generated /mnt/imageset.yaml
Generating list of pre-cached artifacts...
Processing artifact [1/176]: ocp-v4.0-art-dev@sha256_6ac2b96bf4899c01a87366fd0feae9f57b1b61878e3b5823da0c3f34f707fbf5
Processing artifact [2/176]: ocp-v4.0-art-dev@sha256_f48b68d5960ba903a0d018a10544ae08db5802e21c2fa5615a14fc58b1c1657c
Processing artifact [3/176]: ocp-v4.0-art-dev@sha256_a480390e91b1c07e10091c3da2257180654f6b2a735a4ad4c3b69dbdb77bbc06
Processing artifact [4/176]: ocp-v4.0-art-dev@sha256_ecc5d8dbd77e326dba6594ff8c2d091eefbc4d90c963a9a85b0b2f0e6155f995
Processing artifact [5/176]: ocp-v4.0-art-dev@sha256_274b6d561558a2f54db08ea96df9892315bb773fc203b1dbcea418d20f4c7ad1
Processing artifact [6/176]: ocp-v4.0-art-dev@sha256_e142bf5020f5ca0d1bdda0026bf97f89b72d21a97c9cc2dc71bf85050e822bbf
...
Processing artifact [175/176]: ocp-v4.0-art-dev@sha256_16cd7eda26f0fb0fc965a589e1e96ff8577e560fcd14f06b5fda1643036ed6c8
Processing artifact [176/176]: ocp-v4.0-art-dev@sha256_cf4d862b4a4170d4f611b39d06c31c97658e309724f9788e155999ae51e7188f
...
Summary:

Release:                            4.12.0
Hub Version:                        2.6.3
ACM Version:                        2.6.3
MCE Version:                        2.1.4
Include DU Profile:                 No
Workers:                            83</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that all the images are compressed in the target folder of server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls -l /mnt <co xml:id="CO133-1"/></programlisting>
<calloutlist>
<callout arearefs="CO133-1">
<para>It is recommended that you pre-cache the images in the <literal>/mnt</literal> folder.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">-rw-r--r--. 1 root root  136352323 Oct 31 15:19 ocp-v4.0-art-dev@sha256_edec37e7cd8b1611d0031d45e7958361c65e2005f145b471a8108f1b54316c07.tgz
-rw-r--r--. 1 root root  156092894 Oct 31 15:33 ocp-v4.0-art-dev@sha256_ee51b062b9c3c9f4fe77bd5b3cc9a3b12355d040119a1434425a824f137c61a9.tgz
-rw-r--r--. 1 root root  172297800 Oct 31 15:29 ocp-v4.0-art-dev@sha256_ef23d9057c367a36e4a5c4877d23ee097a731e1186ed28a26c8d21501cd82718.tgz
-rw-r--r--. 1 root root  171539614 Oct 31 15:23 ocp-v4.0-art-dev@sha256_f0497bb63ef6834a619d4208be9da459510df697596b891c0c633da144dbb025.tgz
-rw-r--r--. 1 root root  160399150 Oct 31 15:20 ocp-v4.0-art-dev@sha256_f0c339da117cde44c9aae8d0bd054bceb6f19fdb191928f6912a703182330ac2.tgz
-rw-r--r--. 1 root root  175962005 Oct 31 15:17 ocp-v4.0-art-dev@sha256_f19dd2e80fb41ef31d62bb8c08b339c50d193fdb10fc39cc15b353cbbfeb9b24.tgz
-rw-r--r--. 1 root root  174942008 Oct 31 15:33 ocp-v4.0-art-dev@sha256_f1dbb81fa1aa724e96dd2b296b855ff52a565fbef003d08030d63590ae6454df.tgz
-rw-r--r--. 1 root root  246693315 Oct 31 15:31 ocp-v4.0-art-dev@sha256_f44dcf2c94e4fd843cbbf9b11128df2ba856cd813786e42e3da1fdfb0f6ddd01.tgz
-rw-r--r--. 1 root root  170148293 Oct 31 15:00 ocp-v4.0-art-dev@sha256_f48b68d5960ba903a0d018a10544ae08db5802e21c2fa5615a14fc58b1c1657c.tgz
-rw-r--r--. 1 root root  168899617 Oct 31 15:16 ocp-v4.0-art-dev@sha256_f5099b0989120a8d08a963601214b5c5cb23417a707a8624b7eb52ab788a7f75.tgz
-rw-r--r--. 1 root root  176592362 Oct 31 15:05 ocp-v4.0-art-dev@sha256_f68c0e6f5e17b0b0f7ab2d4c39559ea89f900751e64b97cb42311a478338d9c3.tgz
-rw-r--r--. 1 root root  157937478 Oct 31 15:37 ocp-v4.0-art-dev@sha256_f7ba33a6a9db9cfc4b0ab0f368569e19b9fa08f4c01a0d5f6a243d61ab781bd8.tgz
-rw-r--r--. 1 root root  145535253 Oct 31 15:26 ocp-v4.0-art-dev@sha256_f8f098911d670287826e9499806553f7a1dd3e2b5332abbec740008c36e84de5.tgz
-rw-r--r--. 1 root root  158048761 Oct 31 15:40 ocp-v4.0-art-dev@sha256_f914228ddbb99120986262168a705903a9f49724ffa958bb4bf12b2ec1d7fb47.tgz
-rw-r--r--. 1 root root  167914526 Oct 31 15:37 ocp-v4.0-art-dev@sha256_fa3ca9401c7a9efda0502240aeb8d3ae2d239d38890454f17fe5158b62305010.tgz
-rw-r--r--. 1 root root  164432422 Oct 31 15:24 ocp-v4.0-art-dev@sha256_fc4783b446c70df30b3120685254b40ce13ba6a2b0bf8fb1645f116cf6a392f1.tgz
-rw-r--r--. 1 root root  306643814 Oct 31 15:11 troubleshoot@sha256_b86b8aea29a818a9c22944fd18243fa0347c7a2bf1ad8864113ff2bb2d8e0726.tgz</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-downloading-operator-images_pre-caching">
<title>Downloading the Operator images</title>
<simpara>You can also pre-cache Day-2 Operators used in the 5G Radio Access Network (RAN) Distributed Unit (DU) cluster configuration. The Day-2 Operators depend on the installed OpenShift Container Platform version.</simpara>
<important>
<simpara>You need to include the RHACM hub and MCE Operator versions by using the <literal>--acm-version</literal> and <literal>--mce-version</literal> flags so the factory-precaching-cli tool can pre-cache the appropriate containers images for the RHACM and MCE Operators.</simpara>
</important>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Pre-cache the Operator images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker --privileged --rm quay.io/openshift-kni/telco-ran-tools:latest -- factory-precaching-cli download \ <co xml:id="CO134-1"/>
   -r 4.12.0 \ <co xml:id="CO134-2"/>
   --acm-version 2.6.3 \ <co xml:id="CO134-3"/>
   --mce-version 2.1.4 \ <co xml:id="CO134-4"/>
   -f /mnt \ <co xml:id="CO134-5"/>
   --img quay.io/custom/repository <co xml:id="CO134-6"/>
   --du-profile -s <co xml:id="CO134-7"/></programlisting>
<calloutlist>
<callout arearefs="CO134-1">
<para>Specifies the downloading function of the factory-precaching-cli tool.</para>
</callout>
<callout arearefs="CO134-2">
<para>Defines the OpenShift Container Platform release version.</para>
</callout>
<callout arearefs="CO134-3">
<para>Defines the RHACM version.</para>
</callout>
<callout arearefs="CO134-4">
<para>Defines the MCE version.</para>
</callout>
<callout arearefs="CO134-5">
<para>Defines the folder where you want to download the images on the disk.</para>
</callout>
<callout arearefs="CO134-6">
<para>Optional. Defines the repository where you store your additional images. These images are downloaded and pre-cached on the disk.</para>
</callout>
<callout arearefs="CO134-7">
<para>Specifies pre-caching the Operators included in the DU configuration.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Generated /mnt/imageset.yaml
Generating list of pre-cached artifacts...
Processing artifact [1/379]: ocp-v4.0-art-dev@sha256_7753a8d9dd5974be8c90649aadd7c914a3d8a1f1e016774c7ac7c9422e9f9958
Processing artifact [2/379]: ose-kube-rbac-proxy@sha256_c27a7c01e5968aff16b6bb6670423f992d1a1de1a16e7e260d12908d3322431c
Processing artifact [3/379]: ocp-v4.0-art-dev@sha256_370e47a14c798ca3f8707a38b28cfc28114f492bb35fe1112e55d1eb51022c99
...
Processing artifact [378/379]: ose-local-storage-operator@sha256_0c81c2b79f79307305e51ce9d3837657cf9ba5866194e464b4d1b299f85034d0
Processing artifact [379/379]: multicluster-operators-channel-rhel8@sha256_c10f6bbb84fe36e05816e873a72188018856ad6aac6cc16271a1b3966f73ceb3
...
Summary:

Release:                            4.12.0
Hub Version:                        2.6.3
ACM Version:                        2.6.3
MCE Version:                        2.1.4
Include DU Profile:                 Yes
Workers:                            83</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ztp-custom-pre-caching-in-disconnected-environment_pre-caching">
<title>Pre-caching custom images in disconnected environments</title>
<simpara>The <literal>--generate-imageset</literal> argument stops the factory-precaching-cli tool after the <literal>ImageSetConfiguration</literal> custom resource (CR) is generated.
This allows you to customize the <literal>ImageSetConfiguration</literal> CR before downloading any images.
After you customized the CR, you can use the <literal>--skip-imageset</literal> argument to download the images that you specified in the <literal>ImageSetConfiguration</literal> CR.</simpara>
<simpara>You can customize the <literal>ImageSetConfiguration</literal> CR in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Add Operators and additional images</simpara>
</listitem>
<listitem>
<simpara>Remove Operators and additional images</simpara>
</listitem>
<listitem>
<simpara>Change Operator and catalog sources to local or disconnected registries</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Pre-cache the images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker --privileged --rm quay.io/openshift-kni/telco-ran-tools:latest -- factory-precaching-cli download \ <co xml:id="CO135-1"/>
   -r 4.12.0 \ <co xml:id="CO135-2"/>
   --acm-version 2.6.3 \ <co xml:id="CO135-3"/>
   --mce-version 2.1.4 \ <co xml:id="CO135-4"/>
   -f /mnt \ <co xml:id="CO135-5"/>
   --img quay.io/custom/repository <co xml:id="CO135-6"/>
   --du-profile -s \ <co xml:id="CO135-7"/>
   --generate-imageset <co xml:id="CO135-8"/></programlisting>
<calloutlist>
<callout arearefs="CO135-1">
<para>Specifies the downloading function of the factory-precaching-cli tool.</para>
</callout>
<callout arearefs="CO135-2">
<para>Defines the OpenShift Container Platform release version.</para>
</callout>
<callout arearefs="CO135-3">
<para>Defines the RHACM version.</para>
</callout>
<callout arearefs="CO135-4">
<para>Defines the MCE version.</para>
</callout>
<callout arearefs="CO135-5">
<para>Defines the folder where you want to download the images on the disk.</para>
</callout>
<callout arearefs="CO135-6">
<para>Optional. Defines the repository where you store your additional images. These images are downloaded and pre-cached on the disk.</para>
</callout>
<callout arearefs="CO135-7">
<para>Specifies pre-caching the Operators included in the DU configuration.</para>
</callout>
<callout arearefs="CO135-8">
<para>The <literal>--generate-imageset</literal> argument generates the <literal>ImageSetConfiguration</literal> CR only, which allows you to customize the CR.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Generated /mnt/imageset.yaml</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example ImageSetConfiguration CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
mirror:
  platform:
    channels:
    - name: stable-4.12
      minVersion: 4.12.0 <co xml:id="CO136-1"/>
      maxVersion: 4.12.0
  additionalImages:
    - name: quay.io/custom/repository
  operators:
    - catalog: registry.redhat.io/redhat/redhat-operator-index:v4.12
      packages:
        - name: advanced-cluster-management <co xml:id="CO136-2"/>
          channels:
             - name: 'release-2.6'
               minVersion: 2.6.3
               maxVersion: 2.6.3
        - name: multicluster-engine <co xml:id="CO136-3"/>
          channels:
             - name: 'stable-2.1'
               minVersion: 2.1.4
               maxVersion: 2.1.4
        - name: local-storage-operator <co xml:id="CO136-4"/>
          channels:
            - name: 'stable'
        - name: ptp-operator <co xml:id="CO136-5"/>
          channels:
            - name: 'stable'
        - name: sriov-network-operator <co xml:id="CO136-6"/>
          channels:
            - name: 'stable'
        - name: cluster-logging <co xml:id="CO136-7"/>
          channels:
            - name: 'stable'
        - name: lvms-operator <co xml:id="CO136-8"/>
          channels:
            - name: 'stable-4.12'
        - name: amq7-interconnect-operator <co xml:id="CO136-9"/>
          channels:
            - name: '1.10.x'
        - name: bare-metal-event-relay <co xml:id="CO136-10"/>
          channels:
            - name: 'stable'
    - catalog: registry.redhat.io/redhat/certified-operator-index:v4.12
      packages:
        - name: sriov-fec <co xml:id="CO136-11"/>
          channels:
            - name: 'stable'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO136-1">
<para>The platform versions match the versions passed to the tool.</para>
</callout>
<callout arearefs="CO136-2 CO136-3">
<para>The versions of RHACM and MCE Operators match the versions passed to the tool.</para>
</callout>
<callout arearefs="CO136-4 CO136-5 CO136-6 CO136-7 CO136-8 CO136-9 CO136-10 CO136-11">
<para>The CR contains all the specified DU Operators.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Customize the catalog resource in the CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
mirror:
  platform:
[...]
  operators:
    - catalog: eko4.cloud.lab.eng.bos.redhat.com:8443/redhat/certified-operator-index:v4.12
      packages:
        - name: sriov-fec
          channels:
            - name: 'stable'</programlisting>
<simpara>When you download images by using a local or disconnected registry, you have to first add certificates for the registries that you want to pull the content from.</simpara>
</listitem>
<listitem>
<simpara>To avoid any errors, copy the registry certificate into your server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cp /tmp/eko4-ca.crt /etc/pki/ca-trust/source/anchors/.</programlisting>
</listitem>
<listitem>
<simpara>Then, update the certificates trust store:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># update-ca-trust</programlisting>
</listitem>
<listitem>
<simpara>Mount the host <literal>/etc/pki</literal> folder into the factory-cli image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker -v /etc/pki:/etc/pki --privileged --rm quay.io/openshift-kni/telco-ran-tools:latest -- \
factory-precaching-cli download \ <co xml:id="CO137-1"/>
   -r 4.12.0 \ <co xml:id="CO137-2"/>
   --acm-version 2.6.3 \ <co xml:id="CO137-3"/>
   --mce-version 2.1.4 \ <co xml:id="CO137-4"/>
   -f /mnt \ <co xml:id="CO137-5"/>
   --img quay.io/custom/repository <co xml:id="CO137-6"/>
   --du-profile -s \ <co xml:id="CO137-7"/>
   --skip-imageset <co xml:id="CO137-8"/></programlisting>
<calloutlist>
<callout arearefs="CO137-1">
<para>Specifies the downloading function of the factory-precaching-cli tool.</para>
</callout>
<callout arearefs="CO137-2">
<para>Defines the OpenShift Container Platform release version.</para>
</callout>
<callout arearefs="CO137-3">
<para>Defines the RHACM version.</para>
</callout>
<callout arearefs="CO137-4">
<para>Defines the MCE version.</para>
</callout>
<callout arearefs="CO137-5">
<para>Defines the folder where you want to download the images on the disk.</para>
</callout>
<callout arearefs="CO137-6">
<para>Optional. Defines the repository where you store your additional images. These images are downloaded and pre-cached on the disk.</para>
</callout>
<callout arearefs="CO137-7">
<para>Specifies pre-caching the Operators included in the DU configuration.</para>
</callout>
<callout arearefs="CO137-8">
<para>The <literal>--skip-imageset</literal> argument allows you to download the images that you specified in your customized <literal>ImageSetConfiguration</literal> CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Download the images without generating a new <literal>imageSetConfiguration</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker --privileged --rm quay.io/openshift-kni/telco-ran-tools:latest -- factory-precaching-cli download -r 4.12.0 \
--acm-version 2.6.3 --mce-version 2.1.4 -f /mnt \
--img quay.io/custom/repository \
--du-profile -s \
--skip-imageset</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>To access the online Red Hat registries, see <link xlink:href="https://console.redhat.com/openshift/downloads#tool-pull-secret">OpenShift installation customization tools</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information about using the multicluster engine, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#mce-intro">About cluster lifecycle with the multicluster engine operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ztp-pre-caching-config-con_pre-caching">
<title>Pre-caching images in GitOps ZTP</title>
<simpara>The <literal>SiteConfig</literal> manifest defines how an OpenShift cluster is to be installed and configured.
In the GitOps Zero Touch Provisioning (ZTP) provisioning workflow, the factory-precaching-cli tool requires the following additional fields in the <literal>SiteConfig</literal> manifest:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>clusters.ignitionConfigOverride</literal></simpara>
</listitem>
<listitem>
<simpara><literal>nodes.installerArgs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>nodes.ignitionConfigOverride</literal></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example SiteConfig with additional fields</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: ran.openshift.io/v1
kind: SiteConfig
metadata:
  name: "example-5g-lab"
  namespace: "example-5g-lab"
spec:
  baseDomain: "example.domain.redhat.com"
  pullSecretRef:
    name: "assisted-deployment-pull-secret"
  clusterImageSetNameRef: "img4.9.10-x86-64-appsub"
  sshPublicKey: "ssh-rsa ..."
  clusters:
  - clusterName: "sno-worker-0"
    clusterImageSetNameRef: "eko4-img4.11.5-x86-64-appsub"
    clusterLabels:
      group-du-sno: ""
      common-411: true
      sites : "example-5g-lab"
      vendor: "OpenShift"
    clusterNetwork:
      - cidr: 10.128.0.0/14
        hostPrefix: 23
    machineNetwork:
      - cidr: 10.19.32.192/26
    serviceNetwork:
      - 172.30.0.0/16
    networkType: "OVNKubernetes"
    additionalNTPSources:
      - clock.corp.redhat.com
    ignitionConfigOverride: '{"ignition":{"version":"3.1.0"},"systemd":{"units":[{"name":"var-mnt.mount","enabled":true,"contents":"[Unit]\nDescription=Mount partition with artifacts\nBefore=precache-images.service\nBindsTo=precache-images.service\nStopWhenUnneeded=true\n\n[Mount]\nWhat=/dev/disk/by-partlabel/data\nWhere=/var/mnt\nType=xfs\nTimeoutSec=30\n\n[Install]\nRequiredBy=precache-images.service"},{"name":"precache-images.service","enabled":true,"contents":"[Unit]\nDescription=Extracts the precached images in discovery stage\nAfter=var-mnt.mount\nBefore=agent.service\n\n[Service]\nType=oneshot\nUser=root\nWorkingDirectory=/var/mnt\nExecStart=bash /usr/local/bin/extract-ai.sh\n#TimeoutStopSec=30\n\n[Install]\nWantedBy=multi-user.target default.target\nWantedBy=agent.service"}]},"storage":{"files":[{"overwrite":true,"path":"/usr/local/bin/extract-ai.sh","mode":755,"user":{"name":"root"},"contents":{"source":"data:,%23%21%2Fbin%2Fbash%0A%0AFOLDER%3D%22%24%7BFOLDER%3A-%24%28pwd%29%7D%22%0AOCP_RELEASE_LIST%3D%22%24%7BOCP_RELEASE_LIST%3A-ai-images.txt%7D%22%0ABINARY_FOLDER%3D%2Fvar%2Fmnt%0A%0Apushd%20%24FOLDER%0A%0Atotal_copies%3D%24%28sort%20-u%20%24BINARY_FOLDER%2F%24OCP_RELEASE_LIST%20%7C%20wc%20-l%29%20%20%23%20Required%20to%20keep%20track%20of%20the%20pull%20task%20vs%20total%0Acurrent_copy%3D1%0A%0Awhile%20read%20-r%20line%3B%0Ado%0A%20%20uri%3D%24%28echo%20%22%24line%22%20%7C%20awk%20%27%7Bprint%241%7D%27%29%0A%20%20%23tar%3D%24%28echo%20%22%24line%22%20%7C%20awk%20%27%7Bprint%242%7D%27%29%0A%20%20podman%20image%20exists%20%24uri%0A%20%20if%20%5B%5B%20%24%3F%20-eq%200%20%5D%5D%3B%20then%0A%20%20%20%20%20%20echo%20%22Skipping%20existing%20image%20%24tar%22%0A%20%20%20%20%20%20echo%20%22Copying%20%24%7Buri%7D%20%5B%24%7Bcurrent_copy%7D%2F%24%7Btotal_copies%7D%5D%22%0A%20%20%20%20%20%20current_copy%3D%24%28%28current_copy%20%2B%201%29%29%0A%20%20%20%20%20%20continue%0A%20%20fi%0A%20%20tar%3D%24%28echo%20%22%24uri%22%20%7C%20%20rev%20%7C%20cut%20-d%20%22%2F%22%20-f1%20%7C%20rev%20%7C%20tr%20%22%3A%22%20%22_%22%29%0A%20%20tar%20zxvf%20%24%7Btar%7D.tgz%0A%20%20if%20%5B%20%24%3F%20-eq%200%20%5D%3B%20then%20rm%20-f%20%24%7Btar%7D.gz%3B%20fi%0A%20%20echo%20%22Copying%20%24%7Buri%7D%20%5B%24%7Bcurrent_copy%7D%2F%24%7Btotal_copies%7D%5D%22%0A%20%20skopeo%20copy%20dir%3A%2F%2F%24%28pwd%29%2F%24%7Btar%7D%20containers-storage%3A%24%7Buri%7D%0A%20%20if%20%5B%20%24%3F%20-eq%200%20%5D%3B%20then%20rm%20-rf%20%24%7Btar%7D%3B%20current_copy%3D%24%28%28current_copy%20%2B%201%29%29%3B%20fi%0Adone%20%3C%20%24%7BBINARY_FOLDER%7D%2F%24%7BOCP_RELEASE_LIST%7D%0A%0A%23%20workaround%20while%20https%3A%2F%2Fgithub.com%2Fopenshift%2Fassisted-service%2Fpull%2F3546%0A%23cp%20%2Fvar%2Fmnt%2Fmodified-rhcos-4.10.3-x86_64-metal.x86_64.raw.gz%20%2Fvar%2Ftmp%2F.%0A%0Aexit%200"}},{"overwrite":true,"path":"/usr/local/bin/agent-fix-bz1964591","mode":755,"user":{"name":"root"},"contents":{"source":"data:,%23%21%2Fusr%2Fbin%2Fsh%0A%0A%23%20This%20script%20is%20a%20workaround%20for%20bugzilla%201964591%20where%20symlinks%20inside%20%2Fvar%2Flib%2Fcontainers%2F%20get%0A%23%20corrupted%20under%20some%20circumstances.%0A%23%0A%23%20In%20order%20to%20let%20agent.service%20start%20correctly%20we%20are%20checking%20here%20whether%20the%20requested%0A%23%20container%20image%20exists%20and%20in%20case%20%22podman%20images%22%20returns%20an%20error%20we%20try%20removing%20the%20faulty%0A%23%20image.%0A%23%0A%23%20In%20such%20a%20scenario%20agent.service%20will%20detect%20the%20image%20is%20not%20present%20and%20pull%20it%20again.%20In%20case%0A%23%20the%20image%20is%20present%20and%20can%20be%20detected%20correctly%2C%20no%20any%20action%20is%20required.%0A%0AIMAGE%3D%24%28echo%20%241%20%7C%20sed%20%27s%2F%3A.%2A%2F%2F%27%29%0Apodman%20image%20exists%20%24IMAGE%20%7C%7C%20echo%20%22already%20loaded%22%20%7C%7C%20echo%20%22need%20to%20be%20pulled%22%0A%23podman%20images%20%7C%20grep%20%24IMAGE%20%7C%7C%20podman%20rmi%20--force%20%241%20%7C%7C%20true"}}]}}'
    nodes:
      - hostName: "snonode.sno-worker-0.example.domain.redhat.com"
        role: "master"
        bmcAddress: "idrac-virtualmedia+https://10.19.28.53/redfish/v1/Systems/System.Embedded.1"
        bmcCredentialsName:
          name: "worker0-bmh-secret"
        bootMACAddress: "e4:43:4b:bd:90:46"
        bootMode: "UEFI"
        rootDeviceHints:
          deviceName: /dev/nvme0n1
        cpuset: "0-1,40-41"
        installerArgs: '["--save-partlabel", "data"]'
        ignitionConfigOverride: '{"ignition":{"version":"3.1.0"},"systemd":{"units":[{"name":"var-mnt.mount","enabled":true,"contents":"[Unit]\nDescription=Mount partition with artifacts\nBefore=precache-ocp-images.service\nBindsTo=precache-ocp-images.service\nStopWhenUnneeded=true\n\n[Mount]\nWhat=/dev/disk/by-partlabel/data\nWhere=/var/mnt\nType=xfs\nTimeoutSec=30\n\n[Install]\nRequiredBy=precache-ocp-images.service"},{"name":"precache-ocp-images.service","enabled":true,"contents":"[Unit]\nDescription=Extracts the precached OCP images into containers storage\nAfter=var-mnt.mount\nBefore=machine-config-daemon-pull.service nodeip-configuration.service\n\n[Service]\nType=oneshot\nUser=root\nWorkingDirectory=/var/mnt\nExecStart=bash /usr/local/bin/extract-ocp.sh\nTimeoutStopSec=60\n\n[Install]\nWantedBy=multi-user.target"}]},"storage":{"files":[{"overwrite":true,"path":"/usr/local/bin/extract-ocp.sh","mode":755,"user":{"name":"root"},"contents":{"source":"data:,%23%21%2Fbin%2Fbash%0A%0AFOLDER%3D%22%24%7BFOLDER%3A-%24%28pwd%29%7D%22%0AOCP_RELEASE_LIST%3D%22%24%7BOCP_RELEASE_LIST%3A-ocp-images.txt%7D%22%0ABINARY_FOLDER%3D%2Fvar%2Fmnt%0A%0Apushd%20%24FOLDER%0A%0Atotal_copies%3D%24%28sort%20-u%20%24BINARY_FOLDER%2F%24OCP_RELEASE_LIST%20%7C%20wc%20-l%29%20%20%23%20Required%20to%20keep%20track%20of%20the%20pull%20task%20vs%20total%0Acurrent_copy%3D1%0A%0Awhile%20read%20-r%20line%3B%0Ado%0A%20%20uri%3D%24%28echo%20%22%24line%22%20%7C%20awk%20%27%7Bprint%241%7D%27%29%0A%20%20%23tar%3D%24%28echo%20%22%24line%22%20%7C%20awk%20%27%7Bprint%242%7D%27%29%0A%20%20podman%20image%20exists%20%24uri%0A%20%20if%20%5B%5B%20%24%3F%20-eq%200%20%5D%5D%3B%20then%0A%20%20%20%20%20%20echo%20%22Skipping%20existing%20image%20%24tar%22%0A%20%20%20%20%20%20echo%20%22Copying%20%24%7Buri%7D%20%5B%24%7Bcurrent_copy%7D%2F%24%7Btotal_copies%7D%5D%22%0A%20%20%20%20%20%20current_copy%3D%24%28%28current_copy%20%2B%201%29%29%0A%20%20%20%20%20%20continue%0A%20%20fi%0A%20%20tar%3D%24%28echo%20%22%24uri%22%20%7C%20%20rev%20%7C%20cut%20-d%20%22%2F%22%20-f1%20%7C%20rev%20%7C%20tr%20%22%3A%22%20%22_%22%29%0A%20%20tar%20zxvf%20%24%7Btar%7D.tgz%0A%20%20if%20%5B%20%24%3F%20-eq%200%20%5D%3B%20then%20rm%20-f%20%24%7Btar%7D.gz%3B%20fi%0A%20%20echo%20%22Copying%20%24%7Buri%7D%20%5B%24%7Bcurrent_copy%7D%2F%24%7Btotal_copies%7D%5D%22%0A%20%20skopeo%20copy%20dir%3A%2F%2F%24%28pwd%29%2F%24%7Btar%7D%20containers-storage%3A%24%7Buri%7D%0A%20%20if%20%5B%20%24%3F%20-eq%200%20%5D%3B%20then%20rm%20-rf%20%24%7Btar%7D%3B%20current_copy%3D%24%28%28current_copy%20%2B%201%29%29%3B%20fi%0Adone%20%3C%20%24%7BBINARY_FOLDER%7D%2F%24%7BOCP_RELEASE_LIST%7D%0A%0Aexit%200"}}]}}'
        nodeNetwork:
          config:
            interfaces:
              - name: ens1f0
                type: ethernet
                state: up
                macAddress: "AA:BB:CC:11:22:33"
                ipv4:
                  enabled: true
                  dhcp: true
                ipv6:
                  enabled: false
          interfaces:
            - name: "ens1f0"
              macAddress: "AA:BB:CC:11:22:33"</programlisting>
</para>
</formalpara>
<section xml:id="ztp-pre-caching-config-clusters-ignitionconfigoverride_pre-caching">
<title>Understanding the clusters.ignitionConfigOverride field</title>
<simpara>The <literal>clusters.ignitionConfigOverride</literal> field adds a configuration in Ignition format during the GitOps ZTP discovery stage.
The configuration includes <literal>systemd</literal> services in the ISO mounted in virtual media. This way, the scripts are part of the discovery RHCOS live ISO and they can be used to load the Assisted Installer (AI) images.</simpara>
<variablelist>
<varlistentry>
<term><literal>systemd</literal> services</term>
<listitem>
<simpara>The <literal>systemd</literal> services are <literal>var-mnt.mount</literal> and <literal>precache-images.services</literal>. The <literal>precache-images.service</literal> depends on the disk partition to be mounted in <literal>/var/mnt</literal> by the <literal>var-mnt.mount</literal> unit.
The service calls a script called <literal>extract-ai.sh</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>extract-ai.sh</literal></term>
<listitem>
<simpara>The <literal>extract-ai.sh</literal> script extracts and loads the required images from the disk partition to the local container storage.
When the script finishes successfully, you can use the images locally.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>agent-fix-bz1964591</literal></term>
<listitem>
<simpara>The <literal>agent-fix-bz1964591</literal> script is a workaround for an AI issue.
To prevent AI from removing the images, which can force the <literal>agent.service</literal> to pull the images again from the registry, the <literal>agent-fix-bz1964591</literal> script checks if the requested container images exist.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="ztp-pre-caching-config-nodes-installerargs_pre-caching">
<title>Understanding the nodes.installerArgs field</title>
<simpara>The <literal>nodes.installerArgs</literal> field allows you to configure how the <literal>coreos-installer</literal> utility writes the RHCOS live ISO to disk. You need to indicate to save the disk partition labeled as <literal>data</literal> because the artifacts saved in the <literal>data</literal> partition are needed during the OpenShift Container Platform installation stage.</simpara>
<simpara>The extra parameters are passed directly to the <literal>coreos-installer</literal> utility that writes the live RHCOS to disk.
On the next reboot, the operating system starts from the disk.</simpara>
<simpara>You can pass several options to the <literal>coreos-installer</literal> utility:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">OPTIONS:
...
    -u, --image-url &lt;URL&gt;
            Manually specify the image URL

    -f, --image-file &lt;path&gt;
            Manually specify a local image file

    -i, --ignition-file &lt;path&gt;
            Embed an Ignition config from a file

    -I, --ignition-url &lt;URL&gt;
            Embed an Ignition config from a URL
...
        --save-partlabel &lt;lx&gt;...
            Save partitions with this label glob

        --save-partindex &lt;id&gt;...
            Save partitions with this number or range
...
        --insecure-ignition
            Allow Ignition URL without HTTPS or hash</programlisting>
</section>
<section xml:id="ztp-pre-caching-config-nodes-ignitionconfigoverride_pre-caching">
<title>Understanding the nodes.ignitionConfigOverride field</title>
<simpara>Similarly to <literal>clusters.ignitionConfigOverride</literal>, the <literal>nodes.ignitionConfigOverride</literal> field allows the addtion of configurations in Ignition format to the <literal>coreos-installer</literal> utility, but at the OpenShift Container Platform installation stage.
When the RHCOS is written to disk, the extra configuration included in the GitOps ZTP discovery ISO is no longer available. During the discovery stage, the extra configuration is stored in the memory of the live OS.</simpara>
<note>
<simpara>At this stage, the number of container images extracted and loaded is bigger than in the discovery stage. Depending on the OpenShift Container Platform release and whether you install the Day-2 Operators, the installation time can vary.</simpara>
</note>
<simpara>At the installation stage, the <literal>var-mnt.mount</literal> and <literal>precache-ocp.services</literal> <literal>systemd</literal> services are used.</simpara>
<variablelist>
<varlistentry>
<term><literal>precache-ocp.service</literal></term>
<listitem>
<simpara>The <literal>precache-ocp.service</literal> depends on the disk partition to be mounted in <literal>/var/mnt</literal> by the <literal>var-mnt.mount</literal> unit.
The <literal>precache-ocp.service</literal> service calls a script called <literal>extract-ocp.sh</literal>.</simpara>
<important>
<simpara>To extract all the images before the OpenShift Container Platform installation, you must execute <literal>precache-ocp.service</literal> before executing the <literal>machine-config-daemon-pull.service</literal> and <literal>nodeip-configuration.service</literal> services.</simpara>
</important>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>extract-ocp.sh</literal></term>
<listitem>
<simpara>The <literal>extract-ocp.sh</literal> script extracts and loads the required images from the disk partition to the local container storage.
When the script finishes successfully, you can use the images locally.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When you upload the <literal>SiteConfig</literal> and the optional <literal>PolicyGenTemplates</literal> custom resources (CRs) to the Git repo, which Argo CD is monitoring, you can start the GitOps ZTP workflow by syncing the CRs with the hub cluster.</simpara>
</section>
</section>
<section xml:id="ztp-pre-staging-troubleshooting_pre-caching">
<title>Troubleshooting</title>
<section xml:id="_rendered-catalog-is-invalid">
<title>Rendered catalog is invalid</title>
<simpara>When you download images by using a local or disconnected registry, you might see the <literal>The rendered catalog is invalid</literal> error. This means that you are missing certificates of the new registry you want to pull content from.</simpara>
<note>
<simpara>The factory-precaching-cli tool image is built on a UBI RHEL image. Certificate paths and locations are the same on RHCOS.</simpara>
</note>
<formalpara>
<title>Example error</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Generating list of pre-cached artifacts...
error: unable to run command oc-mirror -c /mnt/imageset.yaml file:///tmp/fp-cli-3218002584/mirror --ignore-history --dry-run: Creating directory: /tmp/fp-cli-3218002584/mirror/oc-mirror-workspace/src/publish
Creating directory: /tmp/fp-cli-3218002584/mirror/oc-mirror-workspace/src/v2
Creating directory: /tmp/fp-cli-3218002584/mirror/oc-mirror-workspace/src/charts
Creating directory: /tmp/fp-cli-3218002584/mirror/oc-mirror-workspace/src/release-signatures
backend is not configured in /mnt/imageset.yaml, using stateless mode
backend is not configured in /mnt/imageset.yaml, using stateless mode
No metadata detected, creating new workspace
level=info msg=trying next host error=failed to do request: Head "https://eko4.cloud.lab.eng.bos.redhat.com:8443/v2/redhat/redhat-operator-index/manifests/v4.11": x509: certificate signed by unknown authority host=eko4.cloud.lab.eng.bos.redhat.com:8443

The rendered catalog is invalid.

Run "oc-mirror list operators --catalog CATALOG-NAME --package PACKAGE-NAME" for more information.

error: error rendering new refs: render reference "eko4.cloud.lab.eng.bos.redhat.com:8443/redhat/redhat-operator-index:v4.11": error resolving name : failed to do request: Head "https://eko4.cloud.lab.eng.bos.redhat.com:8443/v2/redhat/redhat-operator-index/manifests/v4.11": x509: certificate signed by unknown authority</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Copy the registry certificate into your server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cp /tmp/eko4-ca.crt /etc/pki/ca-trust/source/anchors/.</programlisting>
</listitem>
<listitem>
<simpara>Update the certificates truststore:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># update-ca-trust</programlisting>
</listitem>
<listitem>
<simpara>Mount the host <literal>/etc/pki</literal> folder into the factory-cli image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># podman run -v /mnt:/mnt -v /root/.docker:/root/.docker -v /etc/pki:/etc/pki --privileged -it --rm quay.io/openshift-kni/telco-ran-tools:latest -- \
factory-precaching-cli download -r 4.11.5 --acm-version 2.5.4 \
   --mce-version 2.0.4 -f /mnt \--img quay.io/custom/repository
   --du-profile -s --skip-imageset</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
</book>
