<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>CI/CD</title>
<date>2024-02-20</date>
</info>
<chapter xml:id="ci-cd-overview">
<title>OpenShift Container Platform CI/CD overview</title>

<simpara>OpenShift Container Platform is an enterprise-ready Kubernetes platform for developers, which enables organizations to automate the application delivery process through DevOps practices, such as continuous integration (CI) and continuous delivery (CD). To meet your organizational needs, the OpenShift Container Platform provides the following CI/CD solutions:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Builds</simpara>
</listitem>
<listitem>
<simpara>OpenShift Pipelines</simpara>
</listitem>
<listitem>
<simpara>OpenShift GitOps</simpara>
</listitem>
</itemizedlist>
<section xml:id="openshift-builds">
<title>OpenShift Builds</title>
<simpara>OpenShift Builds provides you the following options to configure and run a build:</simpara>
<itemizedlist>
<listitem>
<simpara>Builds using Shipwright is an extensible build framework based on the Shipwright project. You can use it to build container images on an OpenShift Container Platform cluster. You can build container images from source code and Dockerfile by using image build tools, such as Source-to-Image (S2I) and Buildah.</simpara>
<simpara>For more information, see <link xlink:href="https://docs.openshift.com/builds/latest/about/overview-openshift-builds.html">Overview of Builds</link>.</simpara>
</listitem>
<listitem>
<simpara>Builds using <literal>BuildConfig</literal> objects is a declarative build process to create cloud-native apps. You can define the build process in a YAML file that you use to create a <literal>BuildConfig</literal> object. This definition includes attributes such as build triggers, input parameters, and source code. When deployed, the <literal>BuildConfig</literal> object builds a runnable image and pushes the image to a container image registry. With the <literal>BuildConfig</literal> object, you can create a Docker, Source-to-image (S2I), or custom build.</simpara>
<simpara>For more information, see <link xlink:href="../cicd/builds/understanding-image-builds.xml#understanding-image-builds">Understanding image builds</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-pipelines">
<title>OpenShift Pipelines</title>
<simpara>OpenShift Pipelines provides a Kubernetes-native CI/CD framework to design and run each step of the CI/CD pipeline in its own container. It can scale independently to meet the on-demand pipelines with predictable outcomes.</simpara>
<simpara>For more information, see <link xlink:href="https://docs.openshift.com/pipelines/latest/about/understanding-openshift-pipelines.html">Understanding OpenShift Pipelines</link>.</simpara>
</section>
<section xml:id="openshift-gitops">
<title>OpenShift GitOps</title>
<simpara>OpenShift GitOps is an Operator that uses Argo CD as the declarative GitOps engine. It enables GitOps workflows across multicluster OpenShift and Kubernetes infrastructure. Using OpenShift GitOps, administrators can consistently configure and deploy Kubernetes-based infrastructure and applications across clusters and development lifecycles.</simpara>
<simpara>For more information, see <link xlink:href="../cicd/gitops/about-redhat-openshift-gitops.xml#about-redhat-openshift-gitops">About Red Hat OpenShift GitOps</link>.</simpara>
</section>
<section xml:id="jenkins-ci-cd">
<title>Jenkins</title>
<simpara>Jenkins automates the process of building, testing, and deploying applications and projects. OpenShift Developer Tools provides a Jenkins image that integrates directly with the OpenShift Container Platform. Jenkins can be deployed on OpenShift by using the Samples Operator templates or certified Helm chart.</simpara>
</section>
</chapter>
<chapter xml:id="_builds_using_shipwright">
<title>Builds using Shipwright</title>
<section xml:id="overview-openshift-builds">
<title>Overview of Builds</title>

<simpara>Builds is an extensible build framework based on the <link xlink:href="https://shipwright.io/">Shipwright project</link>, which you can use to build container images on an OpenShift Container Platform cluster. You can build container images from source code and Dockerfiles by using image build tools, such as Source-to-Image (S2I) and Buildah. You can create and apply build resources, view logs of build runs, and manage builds in your OpenShift Container Platform namespaces.</simpara>
<simpara>Builds includes the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Standard Kubernetes-native API for building container images from source code and Dockerfiles</simpara>
</listitem>
<listitem>
<simpara>Support for Source-to-Image (S2I) and Buildah build strategies</simpara>
</listitem>
<listitem>
<simpara>Extensibility with your own custom build strategies</simpara>
</listitem>
<listitem>
<simpara>Execution of builds from source code in a local directory</simpara>
</listitem>
<listitem>
<simpara>Shipwright CLI for creating and viewing logs, and managing builds on the cluster</simpara>
</listitem>
<listitem>
<simpara>Integrated user experience with the <emphasis role="strong">Developer</emphasis> perspective of the OpenShift Container Platform web console</simpara>
</listitem>
</itemizedlist>
<simpara>Builds consists of the following custom resources (CRs):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Build</literal></simpara>
</listitem>
<listitem>
<simpara><literal>BuildStrategy</literal> and <literal>ClusterBuildStrategy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>BuildRun</literal></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_builds_using_buildconfig">
<title>Builds using BuildConfig</title>
<section xml:id="understanding-image-builds">
<title>Understanding image builds</title>

<section xml:id="builds-about_understanding-image-builds">
<title>Builds</title>
<simpara>A build is the process of transforming input parameters into a resulting object. Most often, the process is used to transform input parameters or source code into a runnable image. A <literal>BuildConfig</literal> object is the definition of the entire build process.</simpara>
<simpara>OpenShift Container Platform uses Kubernetes by creating containers from build images and pushing them to a container image registry.</simpara>
<simpara>Build objects share common characteristics including inputs for a build, the requirement to complete a build process, logging the build process, publishing resources from successful builds, and publishing the final status of the build. Builds take advantage of resource restrictions, specifying limitations on resources such as CPU usage, memory usage, and build or pod execution time.</simpara>
<simpara>The OpenShift Container Platform build system provides extensible support for build strategies that are based on selectable types specified in the build API. There are three primary build strategies available:</simpara>
<itemizedlist>
<listitem>
<simpara>Docker build</simpara>
</listitem>
<listitem>
<simpara>Source-to-image (S2I) build</simpara>
</listitem>
<listitem>
<simpara>Custom build</simpara>
</listitem>
</itemizedlist>
<simpara>By default, docker builds and S2I builds are supported.</simpara>
<simpara>The resulting object of a build depends on the builder used to create it. For docker and S2I builds, the resulting objects are runnable images. For custom builds, the resulting objects are whatever the builder image author has specified.</simpara>
<simpara>Additionally, the pipeline build strategy can be used to implement sophisticated
workflows:</simpara>
<itemizedlist>
<listitem>
<simpara>Continuous integration</simpara>
</listitem>
<listitem>
<simpara>Continuous deployment</simpara>
</listitem>
</itemizedlist>
<section xml:id="builds-strategy-docker-build_understanding-image-builds">
<title>Docker build</title>
<simpara>OpenShift Container Platform uses Buildah to build a container image from a Dockerfile. For more information on building container images with Dockerfiles, see <link xlink:href="https://docs.docker.com/engine/reference/builder/">the Dockerfile reference documentation</link>.</simpara>
<tip>
<simpara>If you set Docker build arguments by using the <literal>buildArgs</literal> array, see <link xlink:href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact">Understand how ARG and FROM interact</link> in the Dockerfile reference documentation.</simpara>
</tip>
</section>
<section xml:id="builds-strategy-s2i-build_understanding-image-builds">
<title>Source-to-image build</title>
<simpara>Source-to-image (S2I) is a tool for building reproducible container images. It produces ready-to-run images by injecting application source into a container image and assembling a new image. The new image incorporates the base image, the builder, and built source and is ready to use with the <literal>buildah run</literal> command. S2I supports incremental builds, which re-use previously downloaded dependencies, previously built artifacts, and so on.</simpara>
</section>
<section xml:id="builds-strategy-custom-build_understanding-image-builds">
<title>Custom build</title>
<simpara>The custom build strategy allows developers to define a specific builder image responsible for the entire build process. Using your own builder image allows you to customize your build process.</simpara>
<simpara>A custom builder image is a plain container image embedded with build process logic, for example for building RPMs or base images.</simpara>
<simpara>Custom builds run with a high level of privilege and are not available to users by default. Only users who can be trusted with cluster administration permissions should be granted access to run custom builds.</simpara>
</section>
<section xml:id="builds-strategy-pipeline-build_understanding-image-builds">
<title>Pipeline build</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>The Pipeline build strategy allows developers to define a Jenkins pipeline for use by the Jenkins pipeline plugin. The build can be started, monitored, and managed by OpenShift Container Platform in the same way as any other build type.</simpara>
<simpara>Pipeline workflows are defined in a <literal>jenkinsfile</literal>, either embedded directly in the build configuration, or supplied in a Git repository and referenced by the build configuration.</simpara>
</section>
</section>
</section>
<section xml:id="understanding-buildconfigs">
<title>Understanding build configurations</title>

<simpara>The following sections define the concept of a build, build configuration, and outline the primary build strategies available.</simpara>
<section xml:id="builds-buildconfig_understanding-builds">
<title>BuildConfigs</title>
<simpara>A build configuration describes a single build definition and a set of triggers for when a new build is created. Build configurations are defined by a <literal>BuildConfig</literal>, which is a REST object that can be used in a POST to the API server to create a new instance.</simpara>
<simpara>A build configuration, or <literal>BuildConfig</literal>, is characterized by a build strategy
and one or more sources. The strategy determines the process, while the sources provide its input.</simpara>
<simpara>Depending on how you choose to create your application using OpenShift Container Platform, a <literal>BuildConfig</literal> is typically generated automatically for you if you use the web console or CLI, and it can be edited at any time. Understanding the parts that make up a <literal>BuildConfig</literal> and their available options can help if you choose to manually change your configuration later.</simpara>
<simpara>The following example <literal>BuildConfig</literal> results in a new build every time a container image tag or the source code changes:</simpara>
<formalpara>
<title><literal>BuildConfig</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: BuildConfig
apiVersion: build.openshift.io/v1
metadata:
  name: "ruby-sample-build" <co xml:id="CO1-1"/>
spec:
  runPolicy: "Serial" <co xml:id="CO1-2"/>
  triggers: <co xml:id="CO1-3"/>
    -
      type: "GitHub"
      github:
        secret: "secret101"
    - type: "Generic"
      generic:
        secret: "secret101"
    -
      type: "ImageChange"
  source: <co xml:id="CO1-4"/>
    git:
      uri: "https://github.com/openshift/ruby-hello-world"
  strategy: <co xml:id="CO1-5"/>
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "ruby-20-centos7:latest"
  output: <co xml:id="CO1-6"/>
    to:
      kind: "ImageStreamTag"
      name: "origin-ruby-sample:latest"
  postCommit: <co xml:id="CO1-7"/>
      script: "bundle exec rake test"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>This specification creates a new <literal>BuildConfig</literal> named <literal>ruby-sample-build</literal>.</para>
</callout>
<callout arearefs="CO1-2">
<para>The <literal>runPolicy</literal> field controls whether builds created from this build configuration can be run simultaneously. The default value is <literal>Serial</literal>, which means new builds run sequentially, not simultaneously.</para>
</callout>
<callout arearefs="CO1-3">
<para>You can specify a list of triggers, which cause a new build to be created.</para>
</callout>
<callout arearefs="CO1-4">
<para>The <literal>source</literal> section defines the source of the build. The source type determines the primary source of input, and can be either <literal>Git</literal>, to point to a code repository location,
<literal>Dockerfile</literal>, to build from an inline Dockerfile,
or <literal>Binary</literal>, to accept binary payloads. It is possible to have multiple sources at once. For more information about each source type, see "Creating build inputs".</para>
</callout>
<callout arearefs="CO1-5">
<para>The <literal>strategy</literal> section describes the build strategy used to execute the build. You can specify a <literal>Source</literal>
, <literal>Docker</literal>, or <literal>Custom</literal>
strategy here. This example uses the <literal>ruby-20-centos7</literal> container image that Source-to-image (S2I) uses for the application build.</para>
</callout>
<callout arearefs="CO1-6">
<para>After the container image is successfully built, it is pushed into the repository described in the <literal>output</literal> section.</para>
</callout>
<callout arearefs="CO1-7">
<para>The <literal>postCommit</literal> section defines an optional build hook.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="creating-build-inputs">
<title>Creating build inputs</title>

<simpara>Use the following sections for an overview of build inputs, instructions on how
to use inputs to provide source content for builds to operate on, and how to use
build environments and create secrets.</simpara>
<section xml:id="builds-define-build-inputs_creating-build-inputs">
<title>Build inputs</title>
<simpara>A build input provides source content for builds to operate on. You can use the following build inputs to provide sources in OpenShift Container Platform, listed in order of precedence:</simpara>
<itemizedlist>
<listitem>
<simpara>Inline Dockerfile definitions</simpara>
</listitem>
<listitem>
<simpara>Content extracted from existing images</simpara>
</listitem>
<listitem>
<simpara>Git repositories</simpara>
</listitem>
<listitem>
<simpara>Binary (Local) inputs</simpara>
</listitem>
<listitem>
<simpara>Input secrets</simpara>
</listitem>
<listitem>
<simpara>External artifacts</simpara>
</listitem>
</itemizedlist>
<simpara>You can combine multiple inputs in a single build.
However, as the inline Dockerfile takes precedence, it can overwrite any other file named Dockerfile provided by another input.
Binary (local) input and Git repositories are mutually exclusive inputs.</simpara>
<simpara>You can use input secrets when you do not want certain resources or credentials used during a build to be available in the final application image produced by the build, or want to consume a value that is defined in a secret resource. External artifacts can be used to pull in additional files that are not available as one of the other build input types.</simpara>
<simpara>When you run a build:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A working directory is constructed and all input content is placed in the working directory. For example, the input Git repository is cloned into the working directory, and files specified from input images are copied into the working directory using the target path.</simpara>
</listitem>
<listitem>
<simpara>The build process changes directories into the <literal>contextDir</literal>, if one is defined.</simpara>
</listitem>
<listitem>
<simpara>The inline Dockerfile, if any, is written to the current directory.</simpara>
</listitem>
<listitem>
<simpara>The content from the current directory is provided to the build process
for reference by the
Dockerfile, custom builder logic, or
<literal>assemble</literal> script. This means any input content that resides outside the <literal>contextDir</literal> is ignored by the build.</simpara>
</listitem>
</orderedlist>
<simpara>The following example of a source definition includes multiple input types and an explanation of how they are combined. For more details on how each input type is defined, see the specific sections for each input type.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: https://github.com/openshift/ruby-hello-world.git <co xml:id="CO2-1"/>
    ref: "master"
  images:
  - from:
      kind: ImageStreamTag
      name: myinputimage:latest
      namespace: mynamespace
    paths:
    - destinationDir: app/dir/injected/dir <co xml:id="CO2-2"/>
      sourcePath: /usr/lib/somefile.jar
  contextDir: "app/dir" <co xml:id="CO2-3"/>
  dockerfile: "FROM centos:7\nRUN yum install -y httpd" <co xml:id="CO2-4"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>The repository to be cloned into the working directory for the build.</para>
</callout>
<callout arearefs="CO2-2">
<para><literal>/usr/lib/somefile.jar</literal> from <literal>myinputimage</literal> is stored in <literal>&lt;workingdir&gt;/app/dir/injected/dir</literal>.</para>
</callout>
<callout arearefs="CO2-3">
<para>The working directory for the build becomes <literal>&lt;original_workingdir&gt;/app/dir</literal>.</para>
</callout>
<callout arearefs="CO2-4">
<para>A Dockerfile with this content is created in <literal>&lt;original_workingdir&gt;/app/dir</literal>, overwriting any existing file with that name.</para>
</callout>
</calloutlist>
</section>
<section xml:id="builds-dockerfile-source_creating-build-inputs">
<title>Dockerfile source</title>
<simpara>When you supply a <literal>dockerfile</literal> value, the content of this field is written to disk as a file named <literal>dockerfile</literal>. This is done after other input sources are processed, so if the input source repository contains a Dockerfile in the root directory, it is overwritten with this content.</simpara>
<simpara>The source definition is part of the <literal>spec</literal> section in the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  dockerfile: "FROM centos:7\nRUN yum install -y httpd" <co xml:id="CO3-1"/></programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>The <literal>dockerfile</literal> field contains an inline Dockerfile that is built.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>The typical use for this field is to provide a Dockerfile to a docker strategy build.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-image-source_creating-build-inputs">
<title>Image source</title>
<simpara>You can add additional files to the build process with images. Input images are referenced in the same way the <literal>From</literal> and <literal>To</literal> image targets are defined. This means both container images and image stream tags can be referenced. In conjunction with the image, you must provide one or more path pairs to indicate the path of the files or directories to copy the image and the destination to place them in the build context.</simpara>
<simpara>The source path can be any absolute path within the image specified. The destination must be a relative directory path. At build time, the image is loaded and the indicated files and directories are copied into the context directory of the build process. This is the same directory into which the source repository content is cloned. If the source path ends in <literal>/.</literal> then the content of the directory is copied, but the directory itself is not created at the destination.</simpara>
<simpara>Image inputs are specified in the <literal>source</literal> definition of the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: https://github.com/openshift/ruby-hello-world.git
    ref: "master"
  images: <co xml:id="CO4-1"/>
  - from: <co xml:id="CO4-2"/>
      kind: ImageStreamTag
      name: myinputimage:latest
      namespace: mynamespace
    paths: <co xml:id="CO4-3"/>
    - destinationDir: injected/dir <co xml:id="CO4-4"/>
      sourcePath: /usr/lib/somefile.jar <co xml:id="CO4-5"/>
  - from:
      kind: ImageStreamTag
      name: myotherinputimage:latest
      namespace: myothernamespace
    pullSecret: mysecret <co xml:id="CO4-6"/>
    paths:
    - destinationDir: injected/dir
      sourcePath: /usr/lib/somefile.jar</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>An array of one or more input images and files.</para>
</callout>
<callout arearefs="CO4-2">
<para>A reference to the image containing the files to be copied.</para>
</callout>
<callout arearefs="CO4-3">
<para>An array of source/destination paths.</para>
</callout>
<callout arearefs="CO4-4">
<para>The directory relative to the build root where the build process can access the file.</para>
</callout>
<callout arearefs="CO4-5">
<para>The location of the file to be copied out of the referenced image.</para>
</callout>
<callout arearefs="CO4-6">
<para>An optional secret provided if credentials are needed to access the input image.</para>
</callout>
</calloutlist>
<note>
<simpara>If your cluster uses an <literal>ImageDigestMirrorSet</literal>, <literal>ImageTagMirrorSet</literal>, or <literal>ImageContentSourcePolicy</literal> object to configure repository mirroring, you can use only global pull secrets for mirrored registries. You cannot add a pull secret to a project.</simpara>
</note>
<formalpara>
<title>Images that require pull secrets</title>
<para>When using an input image that requires a pull secret, you can link the pull secret to the service account used by the build. By default, builds use the <literal>builder</literal> service account. The pull secret is automatically added to the build if the secret contains a credential that matches the repository hosting the input image. To link a pull secret to the service account used by the build, run:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link builder dockerhub</programlisting>
<note>
<simpara>This feature is not supported for builds using the custom strategy.</simpara>
</note>
<formalpara>
<title>Images on mirrored registries that require pull secrets</title>
<para>When using an input image from a mirrored registry, if you get a <literal>build error: failed to pull image</literal> message, you can resolve the error by using either of the following methods:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Create an input secret that contains the authentication credentials for the builder imageâ€™s repository and all known mirrors. In this case, create a pull secret for credentials to the image registry and its mirrors.</simpara>
</listitem>
<listitem>
<simpara>Use the input secret as the pull secret on the <literal>BuildConfig</literal> object.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-code_creating-build-inputs">
<title>Git source</title>
<simpara>When specified, source code is fetched from the supplied location.</simpara>
<simpara>If you supply an inline Dockerfile, it overwrites the Dockerfile in the <literal>contextDir</literal> of the Git repository.</simpara>
<simpara>The source definition is part of the <literal>spec</literal> section in the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git: <co xml:id="CO5-1"/>
    uri: "https://github.com/openshift/ruby-hello-world"
    ref: "master"
  contextDir: "app/dir" <co xml:id="CO5-2"/>
  dockerfile: "FROM openshift/ruby-22-centos7\nUSER example" <co xml:id="CO5-3"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>The <literal>git</literal> field contains the Uniform Resource Identifier (URI) to the remote Git repository of the source code. You must specify the value of the <literal>ref</literal> field to check out a specific Git reference. A valid <literal>ref</literal> can be a SHA1 tag or a branch name. The default value of the <literal>ref</literal> field is <literal>master</literal>.</para>
</callout>
<callout arearefs="CO5-2">
<para>The <literal>contextDir</literal> field allows you to override the default location inside the source code repository where the build looks for the application source code. If your application exists inside a sub-directory, you can override the default location (the root folder) using this field.</para>
</callout>
<callout arearefs="CO5-3">
<para>If the optional <literal>dockerfile</literal> field is provided, it should be a string containing a Dockerfile that overwrites any Dockerfile that may exist in the source repository.</para>
</callout>
</calloutlist>
<simpara>If the <literal>ref</literal> field denotes a pull request, the system uses a <literal>git fetch</literal> operation and then checkout <literal>FETCH_HEAD</literal>.</simpara>
<simpara>When no <literal>ref</literal> value is provided, OpenShift Container Platform performs a shallow clone (<literal>--depth=1</literal>). In this case, only the files associated with the most recent commit on the default branch (typically <literal>master</literal>) are downloaded. This results in repositories downloading faster, but without the full commit history. To perform a full <literal>git clone</literal> of the default branch of a specified repository, set <literal>ref</literal> to the name of the default branch (for example <literal>main</literal>).</simpara>
<warning>
<simpara>Git clone operations that go through a proxy that is performing man in the middle (MITM) TLS hijacking or reencrypting of the proxied connection do not work.</simpara>
</warning>
<section xml:id="builds-using-proxy-git-cloning_creating-build-inputs">
<title>Using a proxy</title>
<simpara>If your Git repository can only be accessed using a proxy, you can define the proxy to use in the <literal>source</literal> section of the build configuration. You can configure both an HTTP and HTTPS proxy to use. Both fields are optional. Domains for which no proxying should be performed can also be specified in the <literal>NoProxy</literal> field.</simpara>
<note>
<simpara>Your source URI must use the HTTP or HTTPS protocol for this to work.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: "https://github.com/openshift/ruby-hello-world"
    ref: "master"
    httpProxy: http://proxy.example.com
    httpsProxy: https://proxy.example.com
    noProxy: somedomain.com, otherdomain.com</programlisting>
<note>
<simpara>For Pipeline strategy builds, given the current restrictions with the Git plugin for Jenkins, any Git operations through the Git plugin do not leverage the HTTP or HTTPS proxy defined in the <literal>BuildConfig</literal>. The Git plugin only uses the proxy configured in the Jenkins UI at the Plugin Manager panel. This proxy is then used for all git interactions within Jenkins, across all jobs.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>You can find instructions on how to configure proxies through the Jenkins UI at <link xlink:href="https://wiki.jenkins-ci.org/display/JENKINS/JenkinsBehindProxy">JenkinsBehindProxy</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-adding-source-clone-secrets_creating-build-inputs">
<title>Source Clone Secrets</title>
<simpara>Builder pods require access to any Git repositories defined as source for a build. Source clone secrets are used to provide the builder pod with access it would not normally have access to, such as private repositories or repositories with self-signed or untrusted SSL certificates.</simpara>
<simpara>The following source clone secret configurations are supported:</simpara>
<itemizedlist>
<listitem>
<simpara>.gitconfig File</simpara>
</listitem>
<listitem>
<simpara>Basic Authentication</simpara>
</listitem>
<listitem>
<simpara>SSH Key Authentication</simpara>
</listitem>
<listitem>
<simpara>Trusted Certificate Authorities</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can also use combinations of these configurations to meet your specific needs.</simpara>
</note>
<section xml:id="builds-automatically-add-source-clone-secrets_creating-build-inputs">
<title>Automatically adding a source clone secret to a build configuration</title>
<simpara>When a <literal>BuildConfig</literal> is created, OpenShift Container Platform can automatically populate its source clone secret reference. This behavior allows the resulting builds to automatically use the credentials stored in the referenced secret to authenticate to a remote Git repository, without requiring further configuration.</simpara>
<simpara>To use this functionality, a secret containing the Git repository credentials must exist in the namespace in which the <literal>BuildConfig</literal> is later created. This secrets must include one or more annotations prefixed with <literal>build.openshift.io/source-secret-match-uri-</literal>. The value of each of these annotations is a Uniform Resource Identifier (URI) pattern, which is defined as follows. When a <literal>BuildConfig</literal> is created without a source clone secret reference and its Git source URI matches a URI pattern in a secret annotation, OpenShift Container Platform automatically inserts a reference to that secret in the <literal>BuildConfig</literal>.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>A URI pattern must consist of:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>A valid scheme: <literal>*://</literal>, <literal>git://</literal>, <literal>http://</literal>, <literal>https://</literal> or <literal>ssh://</literal></simpara>
</listitem>
<listitem>
<simpara>A host: *` or a valid hostname or IP address optionally preceded by <literal>*.</literal></simpara>
</listitem>
<listitem>
<simpara>A path: <literal>/*</literal> or <literal>/</literal> followed by any characters optionally including <literal>*</literal> characters</simpara>
</listitem>
</itemizedlist>
<simpara>In all of the above, a <literal>*</literal> character is interpreted as a wildcard.</simpara>
<important>
<simpara>URI patterns must match Git source URIs which are conformant to <link xlink:href="https://www.ietf.org/rfc/rfc3986.txt">RFC3986</link>. Do not include a username (or password) component in a URI pattern.</simpara>
<simpara>For example, if you use <literal>ssh://git@bitbucket.atlassian.com:7999/ATLASSIAN jira.git</literal> for a git repository URL, the source secret must be specified as <literal>ssh://bitbucket.atlassian.com:7999/*</literal> (and not <literal>ssh://git@bitbucket.atlassian.com:7999/*</literal>).</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate secret mysecret \
    'build.openshift.io/source-secret-match-uri-1=ssh://bitbucket.atlassian.com:7999/*'</programlisting>
</important>
<formalpara>
<title>Procedure</title>
<para>If multiple secrets match the Git URI of a particular <literal>BuildConfig</literal>, OpenShift Container Platform selects the secret with the longest match. This allows for basic overriding, as in the following example.</para>
</formalpara>
<simpara>The following fragment shows two partial source clone secrets, the first matching any server in the domain <literal>mycorp.com</literal> accessed by HTTPS, and the second overriding access to servers <literal>mydev1.mycorp.com</literal> and <literal>mydev2.mycorp.com</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Secret
apiVersion: v1
metadata:
  name: matches-all-corporate-servers-https-only
  annotations:
    build.openshift.io/source-secret-match-uri-1: https://*.mycorp.com/*
data:
  ...
---
kind: Secret
apiVersion: v1
metadata:
  name: override-for-my-dev-servers-https-only
  annotations:
    build.openshift.io/source-secret-match-uri-1: https://mydev1.mycorp.com/*
    build.openshift.io/source-secret-match-uri-2: https://mydev2.mycorp.com/*
data:
  ...</programlisting>
<itemizedlist>
<listitem>
<simpara>Add a <literal>build.openshift.io/source-secret-match-uri-</literal> annotation to a pre-existing secret using:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate secret mysecret \
    'build.openshift.io/source-secret-match-uri-1=https://*.mycorp.com/*'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-manually-add-source-clone-secrets_creating-build-inputs">
<title>Manually adding a source clone secret</title>
<simpara>Source clone secrets can be added manually to a build configuration by adding a <literal>sourceSecret</literal> field to the <literal>source</literal> section inside the <literal>BuildConfig</literal> and setting it to the name of the secret that you created. In this example, it is the <literal>basicsecret</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "build.openshift.io/v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  output:
    to:
      kind: "ImageStreamTag"
      name: "sample-image:latest"
  source:
    git:
      uri: "https://github.com/user/app.git"
    sourceSecret:
      name: "basicsecret"
  strategy:
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "python-33-centos7:latest"</programlisting>
<formalpara>
<title>Procedure</title>
<para>You can also use the <literal>oc set build-secret</literal> command to set the source clone secret on an existing build configuration.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>To set the source clone secret on an existing build configuration, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set build-secret --source bc/sample-build basicsecret</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-gitconfig-file_creating-build-inputs">
<title>Creating a secret from a .gitconfig file</title>
<simpara>If the cloning of your application is dependent on a <literal>.gitconfig</literal> file, then you can create a secret that contains it. Add it to the builder service account and then your <literal>BuildConfig</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a secret from a <literal>.gitconfig</literal> file:</simpara>
</listitem>
</itemizedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=&lt;path/to/.gitconfig&gt;</programlisting>
<note>
<simpara>SSL verification can be turned off if <literal>sslVerify=false</literal> is set for the <literal>http</literal>
section in your <literal>.gitconfig</literal> file:</simpara>
<programlisting language="text" linenumbering="unnumbered">[http]
        sslVerify=false</programlisting>
</note>
</section>
<section xml:id="builds-gitconfig-file-secured-git_creating-build-inputs">
<title>Creating a secret from a .gitconfig file for secured Git</title>
<simpara>If your Git server is secured with two-way SSL and user name with password, you must add the certificate files to your source build and add references to the certificate files in the <literal>.gitconfig</literal> file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have Git credentials.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Add the certificate files to your source build and add references to the certificate files in the <literal>.gitconfig</literal> file.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add the <literal>client.crt</literal>, <literal>cacert.crt</literal>, and <literal>client.key</literal> files to the <literal>/var/run/secrets/openshift.io/source/</literal> folder in the application source code.</simpara>
</listitem>
<listitem>
<simpara>In the <literal>.gitconfig</literal> file for the server, add the <literal>[http]</literal> section shown in the following example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cat .gitconfig</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[user]
        name = &lt;name&gt;
        email = &lt;email&gt;
[http]
        sslVerify = false
        sslCert = /var/run/secrets/openshift.io/source/client.crt
        sslKey = /var/run/secrets/openshift.io/source/client.key
        sslCaInfo = /var/run/secrets/openshift.io/source/cacert.crt</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
--from-literal=username=&lt;user_name&gt; \ <co xml:id="CO6-1"/>
--from-literal=password=&lt;password&gt; \ <co xml:id="CO6-2"/>
--from-file=.gitconfig=.gitconfig \
--from-file=client.crt=/var/run/secrets/openshift.io/source/client.crt \
--from-file=cacert.crt=/var/run/secrets/openshift.io/source/cacert.crt \
--from-file=client.key=/var/run/secrets/openshift.io/source/client.key</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>The user&#8217;s Git user name.</para>
</callout>
<callout arearefs="CO6-2">
<para>The password for this user.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<important>
<simpara>To avoid having to enter your password again, be sure to specify the source-to-image (S2I) image in your builds. However, if you cannot clone the repository, you must still specify your user name and password to promote the build.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><literal>/var/run/secrets/openshift.io/source/</literal> folder in the application source code.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secret-basic-auth_creating-build-inputs">
<title>Creating a secret from source code basic authentication</title>
<simpara>Basic authentication requires either a combination of <literal>--username</literal> and <literal>--password</literal>, or a token to authenticate against the software configuration management (SCM) server.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>User name and password to access the private repository.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the secret first before using the <literal>--username</literal> and <literal>--password</literal> to access the private repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-literal=username=&lt;user_name&gt; \
    --from-literal=password=&lt;password&gt; \
    --type=kubernetes.io/basic-auth</programlisting>
</listitem>
<listitem>
<simpara>Create a basic authentication secret with a token:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-literal=password=&lt;token&gt; \
    --type=kubernetes.io/basic-auth</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-source-secret-ssh-key-auth_creating-build-inputs">
<title>Creating a secret from source code SSH key authentication</title>
<simpara>SSH key based authentication requires a private SSH key.</simpara>
<simpara>The repository keys are usually located in the <literal>$HOME/.ssh/</literal> directory, and are named <literal>id_dsa.pub</literal>, <literal>id_ecdsa.pub</literal>, <literal>id_ed25519.pub</literal>, or <literal>id_rsa.pub</literal> by default.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Generate SSH key credentials:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh-keygen -t ed25519 -C "your_email@example.com"</programlisting>
<note>
<simpara>Creating a passphrase for the SSH key  prevents OpenShift Container Platform from building. When prompted for a passphrase, leave it blank.</simpara>
</note>
<simpara>Two files are created: the public key and a corresponding private key (one of <literal>id_dsa</literal>, <literal>id_ecdsa</literal>, <literal>id_ed25519</literal>, or <literal>id_rsa</literal>). With both of these in place, consult your source control management (SCM) system&#8217;s manual on how to upload
the public key. The private key is used to access your private repository.</simpara>
</listitem>
<listitem>
<simpara>Before using the SSH key to access the private repository, create the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-file=ssh-privatekey=&lt;path/to/ssh/private/key&gt; \
    --from-file=&lt;path/to/known_hosts&gt; \ <co xml:id="CO7-1"/>
    --type=kubernetes.io/ssh-auth</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Optional: Adding this field enables strict server host key check.</para>
</callout>
</calloutlist>
<warning>
<simpara>Skipping the <literal>known_hosts</literal> file while creating the secret makes the build vulnerable to a potential man-in-the-middle (MITM) attack.</simpara>
</warning>
<note>
<simpara>Ensure that the <literal>known_hosts</literal> file includes an entry for the host of your source code.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-source-secret-trusted-ca_creating-build-inputs">
<title>Creating a secret from source code trusted certificate authorities</title>
<simpara>The set of Transport Layer Security (TLS) certificate authorities (CA) that are trusted during a Git clone operation are built into the OpenShift Container Platform infrastructure images. If your Git server uses a self-signed certificate or one signed by an authority not trusted by the image, you can create a secret that contains the certificate or disable TLS verification.</simpara>
<simpara>If you create a secret for the CA certificate, OpenShift Container Platform uses it to access your Git server during the Git clone operation. Using this method is significantly more secure than disabling Git SSL verification, which accepts any TLS certificate that is presented.</simpara>
<formalpara>
<title>Procedure</title>
<para>Create a secret with a CA certificate file.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If your CA uses Intermediate Certificate Authorities, combine the certificates for all CAs in a <literal>ca.crt</literal> file. Enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat intermediateCA.crt intermediateCA.crt rootCA.crt &gt; ca.crt</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic mycert --from-file=ca.crt=&lt;/path/to/file&gt; <co xml:id="CO8-1"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>You must use the key name <literal>ca.crt</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-source-secret-combinations_creating-build-inputs">
<title>Source secret combinations</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs.</simpara>
<section xml:id="builds-source-secret-combinations-ssh-gitconfig_creating-build-inputs">
<title>Creating a SSH-based authentication secret with a <literal>.gitconfig</literal> file</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs, such as a SSH-based authentication secret with a <literal>.gitconfig</literal> file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>SSH authentication</simpara>
</listitem>
<listitem>
<simpara>.gitconfig file</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a SSH-based authentication secret with a <literal>.gitconfig</literal> file, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-file=ssh-privatekey=&lt;path/to/ssh/private/key&gt; \
    --from-file=&lt;path/to/.gitconfig&gt; \
    --type=kubernetes.io/ssh-auth</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secret-combinations-gitconfig-ca_creating-build-inputs">
<title>Creating a secret that combines a .gitconfig file and CA certificate</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs, such as a secret that combines a <literal>.gitconfig</literal> file and certificate authority (CA) certificate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>.gitconfig file</simpara>
</listitem>
<listitem>
<simpara>CA certificate</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a secret that combines a <literal>.gitconfig</literal> file and CA certificate, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-file=ca.crt=&lt;path/to/certificate&gt; \
    --from-file=&lt;path/to/.gitconfig&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secret-combinations-basic-auth-ca_creating-build-inputs">
<title>Creating a basic authentication secret with a CA certificate</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs, such as a secret that combines a basic authentication and certificate authority (CA) certificate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Basic authentication credentials</simpara>
</listitem>
<listitem>
<simpara>CA certificate</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a basic authentication secret with a CA certificate, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-literal=username=&lt;user_name&gt; \
    --from-literal=password=&lt;password&gt; \
    --from-file=ca-cert=&lt;/path/to/file&gt; \
    --type=kubernetes.io/basic-auth</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secret-combinations-basic-auth-gitconfig_creating-build-inputs">
<title>Creating a basic authentication secret with a .gitconfig file</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs, such as a secret that combines a basic authentication and <literal>.gitconfig</literal> file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Basic authentication credentials</simpara>
</listitem>
<listitem>
<simpara><literal>.gitconfig</literal> file</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a basic authentication secret with a <literal>.gitconfig</literal> file, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-literal=username=&lt;user_name&gt; \
    --from-literal=password=&lt;password&gt; \
    --from-file=&lt;/path/to/.gitconfig&gt; \
    --type=kubernetes.io/basic-auth</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secret-combinations-basic-auth-gitconfig-ca_creating-build-inputs">
<title>Creating a basic authentication secret with a .gitconfig file and CA certificate</title>
<simpara>You can combine the different methods for creating source clone secrets for your specific needs, such as a secret that combines a basic authentication, <literal>.gitconfig</literal> file, and certificate authority (CA) certificate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Basic authentication credentials</simpara>
</listitem>
<listitem>
<simpara><literal>.gitconfig</literal> file</simpara>
</listitem>
<listitem>
<simpara>CA certificate</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a basic authentication secret with a <literal>.gitconfig</literal> file and CA certificate, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    --from-literal=username=&lt;user_name&gt; \
    --from-literal=password=&lt;password&gt; \
    --from-file=&lt;/path/to/.gitconfig&gt; \
    --from-file=ca-cert=&lt;/path/to/file&gt; \
    --type=kubernetes.io/basic-auth</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</section>
<section xml:id="builds-binary-source_creating-build-inputs">
<title>Binary (local) source</title>
<simpara>Streaming content from a local file system to the builder is called a <literal>Binary</literal> type build. The corresponding value of <literal>BuildConfig.spec.source.type</literal> is <literal>Binary</literal> for these builds.</simpara>
<simpara>This source type is unique in that it is leveraged solely based on your use of the <literal>oc start-build</literal>.</simpara>
<note>
<simpara>Binary type builds require content to be streamed from the local file system, so automatically triggering a binary type build, like an image change trigger, is not possible. This is because the binary files cannot be provided. Similarly, you cannot launch binary type builds from the web console.</simpara>
</note>
<simpara>To utilize binary builds, invoke <literal>oc start-build</literal> with one of these options:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>--from-file</literal>: The contents of the file you specify are sent as a binary stream to the builder. You can also specify a URL to a file. Then, the builder stores the data in a file with the same name at the top of the build context.</simpara>
</listitem>
<listitem>
<simpara><literal>--from-dir</literal> and <literal>--from-repo</literal>: The contents are archived and sent as a binary stream to the builder. Then, the builder extracts the contents of the archive within the build context directory. With <literal>--from-dir</literal>, you can also specify a URL to an archive, which is extracted.</simpara>
</listitem>
<listitem>
<simpara><literal>--from-archive</literal>: The archive you specify is sent to the builder, where it is extracted within the build context directory. This option behaves the same as <literal>--from-dir</literal>; an archive is created on your host first, whenever the argument to these options is a directory.</simpara>
</listitem>
</itemizedlist>
<simpara>In each of the previously listed cases:</simpara>
<itemizedlist>
<listitem>
<simpara>If your <literal>BuildConfig</literal> already has a <literal>Binary</literal> source type defined, it is effectively ignored and replaced by what the client sends.</simpara>
</listitem>
<listitem>
<simpara>If your <literal>BuildConfig</literal> has a <literal>Git</literal> source type defined, it is dynamically disabled, since <literal>Binary</literal> and <literal>Git</literal> are mutually exclusive, and the data in the binary stream provided to the builder takes precedence.</simpara>
</listitem>
</itemizedlist>
<simpara>Instead of a file name, you can pass a URL with HTTP or HTTPS schema to <literal>--from-file</literal> and <literal>--from-archive</literal>. When using <literal>--from-file</literal> with a URL, the name of the file in the builder image is determined by the <literal>Content-Disposition</literal> header sent by the web server, or the last component of the URL path if the header is not present. No form of authentication is supported and it is not possible to use custom TLS certificate or disable certificate validation.</simpara>
<simpara>When using <literal>oc new-build --binary=true</literal>, the command ensures that the restrictions associated with binary builds are enforced. The resulting <literal>BuildConfig</literal> has a source type of <literal>Binary</literal>, meaning that the only valid way to run a build for this <literal>BuildConfig</literal> is to use <literal>oc start-build</literal> with one of the <literal>--from</literal> options to provide the requisite binary data.</simpara>
<simpara>The Dockerfile and <literal>contextDir</literal> source options have special meaning with binary builds.</simpara>
<simpara>Dockerfile can be used with any binary build source. If Dockerfile is used and the binary stream is an archive, its contents serve as a replacement Dockerfile to any Dockerfile in the archive. If Dockerfile is used with the <literal>--from-file</literal> argument, and the file argument is named Dockerfile, the value from Dockerfile replaces the value from the binary stream.</simpara>
<simpara>In the case of the binary stream encapsulating extracted archive content, the value of the <literal>contextDir</literal> field is interpreted as a subdirectory within the archive, and, if valid, the builder changes into that subdirectory before executing the build.</simpara>
</section>
<section xml:id="builds-input-secrets-configmaps_creating-build-inputs">
<title>Input secrets and config maps</title>
<important>
<simpara>To prevent the contents of input secrets and config maps from appearing in build output container images, use build volumes in your <link xlink:href="../../cicd/builds/build-strategies.xml#builds-using-build-volumes_build-strategies-docker">Docker build</link> and <link xlink:href="../../cicd/builds/build-strategies.xml#builds-using-build-volumes_build-strategies-s2i">source-to-image build</link> strategies.</simpara>
</important>
<simpara>In some scenarios, build operations require credentials or other configuration data to access dependent resources, but it is undesirable for that information to be placed in source control. You can define input secrets and input config maps for this purpose.</simpara>
<simpara>For example, when building a Java application with Maven, you can set up a private mirror of Maven Central or JCenter that is accessed by private keys. To download libraries from that private mirror, you have to supply the
following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A <literal>settings.xml</literal> file configured with the mirror&#8217;s URL and connection settings.</simpara>
</listitem>
<listitem>
<simpara>A private key referenced in the settings file, such as <literal>~/.ssh/id_rsa</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>For security reasons, you do not want to expose your credentials in the application image.</simpara>
<simpara>This example describes a Java application, but you can use the same approach for adding SSL certificates into the <literal>/etc/ssl/certs</literal> directory, API keys or tokens, license files, and more.</simpara>
<section xml:id="builds-secrets-overview_creating-build-inputs">
<title>What is a secret?</title>
<simpara>The <literal>Secret</literal> object type provides a mechanism to hold sensitive information such as passwords, OpenShift Container Platform client configuration files, <literal>dockercfg</literal> files, private source repository credentials, and so on. Secrets decouple sensitive content from the pods. You can mount secrets into containers using a volume plugin or the system can use secrets to perform actions on behalf of a pod.</simpara>
<formalpara>
<title>YAML Secret Object Definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: test-secret
  namespace: my-namespace
type: Opaque <co xml:id="CO9-1"/>
data: <co xml:id="CO9-2"/>
  username: &lt;username&gt; <co xml:id="CO9-3"/>
  password: &lt;password&gt;
stringData: <co xml:id="CO9-4"/>
  hostname: myapp.mydomain.com <co xml:id="CO9-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>Indicates the structure of the secret&#8217;s key names and values.</para>
</callout>
<callout arearefs="CO9-2">
<para>The allowable format for the keys in the <literal>data</literal> field must meet the guidelines in the <literal>DNS_SUBDOMAIN</literal> value in the Kubernetes identifiers glossary.</para>
</callout>
<callout arearefs="CO9-3">
<para>The value associated with keys in the <literal>data</literal> map must be base64 encoded.</para>
</callout>
<callout arearefs="CO9-4">
<para>Entries in the <literal>stringData</literal> map are converted to base64 and the entry are then moved to the <literal>data</literal> map automatically. This field is write-only. The value is only be returned by the <literal>data</literal> field.</para>
</callout>
<callout arearefs="CO9-5">
<para>The value associated with keys in the <literal>stringData</literal> map is made up of plain text strings.</para>
</callout>
</calloutlist>
<section xml:id="builds-secrets-overview-properties_creating-build-inputs">
<title>Properties of secrets</title>
<simpara>Key properties include:</simpara>
<itemizedlist>
<listitem>
<simpara>Secret data can be referenced independently from its definition.</simpara>
</listitem>
<listitem>
<simpara>Secret data volumes are backed by temporary file-storage facilities (tmpfs) and never come to rest on a node.</simpara>
</listitem>
<listitem>
<simpara>Secret data can be shared within a namespace.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-secrets-overview-types_creating-build-inputs">
<title>Types of Secrets</title>
<simpara>The value in the <literal>type</literal> field indicates the structure of the secret&#8217;s key names and values. The type can be used to enforce the presence of user names and keys in the secret object. If you do not want validation, use the <literal>opaque</literal> type, which is the default.</simpara>
<simpara>Specify one of the following types to trigger minimal server-side validation to ensure the presence of specific key names in the secret data:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kubernetes.io/service-account-token</literal>. Uses a service account token.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/dockercfg</literal>. Uses the <literal>.dockercfg</literal> file for required Docker credentials.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/dockerconfigjson</literal>. Uses the <literal>.docker/config.json</literal> file for required Docker credentials.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/basic-auth</literal>. Use with basic authentication.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/ssh-auth</literal>. Use with SSH key authentication.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/tls</literal>. Use with TLS certificate authorities.</simpara>
</listitem>
</itemizedlist>
<simpara>Specify <literal>type= Opaque</literal> if you do not want validation, which means the secret does not claim to conform to any convention for key names or values. An <literal>opaque</literal> secret, allows for unstructured <literal>key:value</literal> pairs that can contain arbitrary values.</simpara>
<note>
<simpara>You can specify other arbitrary types, such as <literal>example.com/my-secret-type</literal>. These types are not enforced server-side, but indicate that the creator of the
secret intended to conform to the key/value requirements of that type.</simpara>
</note>
</section>
<section xml:id="builds-secrets-overview-updates_creating-build-inputs">
<title>Updates to secrets</title>
<simpara>When you modify the value of a secret, the value used by an already running pod does not dynamically change. To change a secret, you must delete the original pod and create a new pod, in some cases with an identical <literal>PodSpec</literal>.</simpara>
<simpara>Updating a secret follows the same workflow as deploying a new container image. You can use the <literal>kubectl rolling-update</literal> command.</simpara>
<simpara>The <literal>resourceVersion</literal> value in a secret is not specified when it is referenced. Therefore, if a secret is updated at the same time as pods are starting, the version of the secret that is used for the pod is not defined.</simpara>
<note>
<simpara>Currently, it is not possible to check the resource version of a secret object that was used when a pod was created. It is planned that pods report this information, so that a controller could restart ones using an old <literal>resourceVersion</literal>. In the interim, do not update the data of existing secrets, but create new ones with distinct names.</simpara>
</note>
</section>
</section>
<section xml:id="builds-creating-secrets_creating-build-inputs">
<title>Creating secrets</title>
<simpara>You must create a secret before creating the pods that depend on that secret.</simpara>
<simpara>When creating secrets:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a secret object with secret data.</simpara>
</listitem>
<listitem>
<simpara>Update the pod service account to allow the reference to the secret.</simpara>
</listitem>
<listitem>
<simpara>Create a pod, which consumes the secret as an environment variable or as a file using a <literal>secret</literal> volume.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the create command to create a secret object from a JSON or YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;</programlisting>
<simpara>For example, you can create a secret from your local <literal>.docker/config.json</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic dockerhub \
    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
<simpara>This command generates a JSON specification of the secret named <literal>dockerhub</literal> and creates the object.</simpara>
<formalpara>
<title>YAML Opaque Secret Object Definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque <co xml:id="CO10-1"/>
data:
  username: &lt;username&gt;
  password: &lt;password&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>Specifies an <emphasis>opaque</emphasis> secret.</para>
</callout>
</calloutlist>
<formalpara>
<title>Docker Configuration JSON File Secret Object Definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: aregistrykey
  namespace: myapps
type: kubernetes.io/dockerconfigjson <co xml:id="CO11-1"/>
data:
  .dockerconfigjson:bm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg== <co xml:id="CO11-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO11-1">
<para>Specifies that the secret is using a docker configuration JSON file.</para>
</callout>
<callout arearefs="CO11-2">
<para>The output of a base64-encoded the docker configuration JSON file</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-using-secrets_creating-build-inputs">
<title>Using secrets</title>
<simpara>After creating secrets, you can create a pod to reference your secret, get logs, and delete the pod.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the pod to reference your secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;your_yaml_file&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Get the logs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs secret-example-pod</programlisting>
</listitem>
<listitem>
<simpara>Delete the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pod secret-example-pod</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>Example YAML files with secret data:</simpara>
<formalpara>
<title>YAML Secret That Will Create Four Files</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: test-secret
data:
  username: &lt;username&gt; <co xml:id="CO12-1"/>
  password: &lt;password&gt; <co xml:id="CO12-2"/>
stringData:
  hostname: myapp.mydomain.com <co xml:id="CO12-3"/>
  secret.properties: |-     <co xml:id="CO12-4"/>
    property1=valueA
    property2=valueB</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>File contains decoded values.</para>
</callout>
<callout arearefs="CO12-2">
<para>File contains decoded values.</para>
</callout>
<callout arearefs="CO12-3">
<para>File contains the provided string.</para>
</callout>
<callout arearefs="CO12-4">
<para>File contains the provided data.</para>
</callout>
</calloutlist>
<formalpara>
<title>YAML of a pod populating files in a volume with secret data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: secret-example-pod
spec:
  containers:
    - name: secret-test-container
      image: busybox
      command: [ "/bin/sh", "-c", "cat /etc/secret-volume/*" ]
      volumeMounts:
          # name must match the volume name below
          - name: secret-volume
            mountPath: /etc/secret-volume
            readOnly: true
  volumes:
    - name: secret-volume
      secret:
        secretName: test-secret
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML of a pod populating environment variables with secret data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: secret-example-pod
spec:
  containers:
    - name: secret-test-container
      image: busybox
      command: [ "/bin/sh", "-c", "export" ]
      env:
        - name: TEST_SECRET_USERNAME_ENV_VAR
          valueFrom:
            secretKeyRef:
              name: test-secret
              key: username
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<formalpara>
<title>YAML of a Build Config Populating Environment Variables with Secret Data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: secret-example-bc
spec:
  strategy:
    sourceStrategy:
      env:
      - name: TEST_SECRET_USERNAME_ENV_VAR
        valueFrom:
          secretKeyRef:
            name: test-secret
            key: username</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-adding-input-secrets-configmaps_creating-build-inputs">
<title>Adding input secrets and config maps</title>
<simpara>To provide credentials and other configuration data to a build without placing them in source control, you can define input secrets and input config maps.</simpara>
<simpara>In some scenarios, build operations require credentials or other configuration data to access dependent resources. To make that information available without placing it in source control, you can define input secrets and input config maps.</simpara>
<formalpara>
<title>Procedure</title>
<para>To add an input secret, config maps, or both to an existing <literal>BuildConfig</literal> object:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the <literal>ConfigMap</literal> object, if it does not exist:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap settings-mvn \
    --from-file=settings.xml=&lt;path/to/settings.xml&gt;</programlisting>
<simpara>This creates a new config map named <literal>settings-mvn</literal>, which contains the plain text content of the <literal>settings.xml</literal> file.</simpara>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core/v1
kind: ConfigMap
metadata:
  name: settings-mvn
data:
  settings.xml: |
    &lt;settings&gt;
    â€¦ # Insert maven settings here
    &lt;/settings&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Create the <literal>Secret</literal> object, if it does not exist:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic secret-mvn \
    --from-file=ssh-privatekey=&lt;path/to/.ssh/id_rsa&gt;
    --type=kubernetes.io/ssh-auth</programlisting>
<simpara>This creates a new secret named <literal>secret-mvn</literal>, which contains the base64 encoded content of the <literal>id_rsa</literal> private key.</simpara>
<tip>
<simpara>You can alternatively apply the following YAML to create the input secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core/v1
kind: Secret
metadata:
  name: secret-mvn
type: kubernetes.io/ssh-auth
data:
  ssh-privatekey: |
    # Insert ssh private key, base64 encoded</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Add the config map and secret to the <literal>source</literal> section in the existing
<literal>BuildConfig</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: https://github.com/wildfly/quickstart.git
  contextDir: helloworld
  configMaps:
    - configMap:
        name: settings-mvn
  secrets:
    - secret:
        name: secret-mvn</programlisting>
</listitem>
</orderedlist>
<simpara>To include the secret and config map in a new <literal>BuildConfig</literal> object, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-build \
    openshift/wildfly-101-centos7~https://github.com/wildfly/quickstart.git \
    --context-dir helloworld --build-secret â€œsecret-mvnâ€ \
    --build-config-map "settings-mvn"</programlisting>
<simpara>During the build, the <literal>settings.xml</literal> and <literal>id_rsa</literal> files are copied into the directory where the source code is located. In OpenShift Container Platform S2I builder images, this is the image working directory, which is set using the <literal>WORKDIR</literal> instruction in the <literal>Dockerfile</literal>. If you want to specify another directory, add a <literal>destinationDir</literal> to the definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: https://github.com/wildfly/quickstart.git
  contextDir: helloworld
  configMaps:
    - configMap:
        name: settings-mvn
      destinationDir: ".m2"
  secrets:
    - secret:
        name: secret-mvn
      destinationDir: ".ssh"</programlisting>
<simpara>You can also specify the destination directory when creating a new <literal>BuildConfig</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-build \
    openshift/wildfly-101-centos7~https://github.com/wildfly/quickstart.git \
    --context-dir helloworld --build-secret â€œsecret-mvn:.sshâ€ \
    --build-config-map "settings-mvn:.m2"</programlisting>
<simpara>In both cases, the <literal>settings.xml</literal> file is added to the <literal>./.m2</literal> directory of the build environment, and the <literal>id_rsa</literal> key is added to the <literal>./.ssh</literal> directory.</simpara>
</section>
<section xml:id="builds-source-to-image_creating-build-inputs">
<title>Source-to-image strategy</title>
<simpara>When using a <literal>Source</literal> strategy, all defined input secrets are copied to their respective <literal>destinationDir</literal>. If you left <literal>destinationDir</literal> empty, then the secrets are placed in the working directory of the builder image.</simpara>
<simpara>The same rule is used when a <literal>destinationDir</literal> is a relative path. The secrets are placed in the paths that are relative to the working directory of the image. The final directory in the <literal>destinationDir</literal> path is created if it does not exist in the builder image. All preceding directories in the <literal>destinationDir</literal> must exist, or an error will occur.</simpara>
<note>
<simpara>Input secrets are added as world-writable, have <literal>0666</literal> permissions, and are truncated to size zero after executing the <literal>assemble</literal> script. This means that the secret files exist in the resulting image, but they are empty for security reasons.</simpara>
<simpara>Input config maps are not truncated after the <literal>assemble</literal> script completes.</simpara>
</note>
</section>
<section xml:id="builds-docker-strategy_creating-build-inputs">
<title>Docker strategy</title>
<simpara>When using a docker strategy, you can add all defined input secrets into your container image using the <link xlink:href="https://docs.docker.com/engine/reference/builder/#add"><literal>ADD</literal></link> and <link xlink:href="https://docs.docker.com/engine/reference/builder/#copy"><literal>COPY</literal> instructions</link> in your Dockerfile.</simpara>
<simpara>If you do not specify the <literal>destinationDir</literal> for a secret, then the files are copied into the same directory in which the Dockerfile is located. If you specify a relative path as <literal>destinationDir</literal>, then the secrets are copied into that directory, relative to your Dockerfile location. This makes the secret files available to the Docker build operation as part of the context directory used during the build.</simpara>
<formalpara>
<title>Example of a Dockerfile referencing secret and config map data</title>
<para>
<screen>FROM centos/ruby-22-centos7

USER root
COPY ./secret-dir /secrets
COPY ./config /

# Create a shell script that will output secrets and ConfigMaps when the image is run
RUN echo '#!/bin/sh' &gt; /input_report.sh
RUN echo '(test -f /secrets/secret1 &amp;&amp; echo -n "secret1=" &amp;&amp; cat /secrets/secret1)' &gt;&gt; /input_report.sh
RUN echo '(test -f /config &amp;&amp; echo -n "relative-configMap=" &amp;&amp; cat /config)' &gt;&gt; /input_report.sh
RUN chmod 755 /input_report.sh

CMD ["/bin/sh", "-c", "/input_report.sh"]</screen>
</para>
</formalpara>
<important>
<simpara>Users normally remove their input secrets from the final application image so that the secrets are not present in the container running from that image. However, the secrets still exist in the image itself in the layer where they were added. This removal is part of the Dockerfile itself.</simpara>
<simpara>To prevent the contents of input secrets and config maps from appearing in the build output container images and avoid this removal process altogether, <link xlink:href="../../cicd/builds/build-strategies.xml#builds-using-build-volumes_build-strategies-docker">use build volumes</link> in your Docker build strategy instead.</simpara>
</important>
</section>
<section xml:id="builds-custom-strategy_creating-build-inputs">
<title>Custom strategy</title>
<simpara>When using a Custom strategy, all the defined input secrets and config maps are available in the builder container in the <literal>/var/run/secrets/openshift.io/build</literal> directory. The custom build image must use these secrets and config maps appropriately. With the Custom strategy, you can define secrets as described in Custom strategy options.</simpara>
<simpara>There is no technical difference between existing strategy secrets and the input secrets. However, your builder image can distinguish between them and use them differently, based on your build use case.</simpara>
<simpara>The input secrets are always mounted into the <literal>/var/run/secrets/openshift.io/build</literal> directory, or your builder can parse the <literal>$BUILD</literal> environment variable, which includes the full build object.</simpara>
<important>
<simpara>If a pull secret for the registry exists in both the namespace and the node, builds default to using the pull secret in the namespace.</simpara>
</important>
</section>
</section>
<section xml:id="builds-using-external-artifacts_creating-build-inputs">
<title>External artifacts</title>
<simpara>It is not recommended to store binary files in a source repository. Therefore, you must define a build which pulls additional files, such as Java <literal>.jar</literal> dependencies, during the build process. How this is done depends on the build strategy you are using.</simpara>
<simpara>For a Source build strategy, you must put appropriate shell commands into the <literal>assemble</literal> script:</simpara>
<formalpara>
<title><literal>.s2i/bin/assemble</literal> File</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#!/bin/sh
APP_VERSION=1.0
wget http://repository.example.com/app/app-$APP_VERSION.jar -O app.jar</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>.s2i/bin/run</literal> File</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#!/bin/sh
exec java -jar app.jar</programlisting>
</para>
</formalpara>
<simpara>For a Docker build strategy, you must modify the Dockerfile and invoke
shell commands with the <link xlink:href="https://docs.docker.com/engine/reference/builder/#run"><literal>RUN</literal> instruction</link>:</simpara>
<formalpara>
<title>Excerpt of Dockerfile</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">FROM jboss/base-jdk:8

ENV APP_VERSION 1.0
RUN wget http://repository.example.com/app/app-$APP_VERSION.jar -O app.jar

EXPOSE 8080
CMD [ "java", "-jar", "app.jar" ]</programlisting>
</para>
</formalpara>
<simpara>In practice, you may want to use an environment variable for the file location so that the specific file to be downloaded can be customized using an environment variable defined on the <literal>BuildConfig</literal>, rather than updating the
Dockerfile or
<literal>assemble</literal> script.</simpara>
<simpara>You can choose between different methods of defining environment variables:</simpara>
<itemizedlist>
<listitem>
<simpara>Using the <literal>.s2i/environment</literal> file] (only for a Source build strategy)</simpara>
</listitem>
<listitem>
<simpara>Setting in <literal>BuildConfig</literal></simpara>
</listitem>
<listitem>
<simpara>Providing explicitly using <literal>oc start-build --env</literal> (only for builds that are triggered manually)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-docker-credentials-private-registries_creating-build-inputs">
<title>Using docker credentials for private registries</title>
<simpara>You can supply builds with a .<literal>docker/config.json</literal> file with valid credentials for private container registries. This allows you to push the output image into a private container image registry or pull a builder image from the private container image registry that requires authentication.</simpara>
<simpara>You can supply credentials for multiple repositories within the same registry, each with credentials specific to that registry path.</simpara>
<note>
<simpara>For the OpenShift Container Platform container image registry, this is not required because secrets are generated automatically for you by OpenShift Container Platform.</simpara>
</note>
<simpara>The <literal>.docker/config.json</literal> file is found in your home directory by default and
has the following format:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">auths:
  index.docker.io/v1/: <co xml:id="CO13-1"/>
    auth: "YWRfbGzhcGU6R2labnRib21ifTE=" <co xml:id="CO13-2"/>
    email: "user@example.com" <co xml:id="CO13-3"/>
  docker.io/my-namespace/my-user/my-image: <co xml:id="CO13-4"/>
    auth: "GzhYWRGU6R2fbclabnRgbkSp=""
    email: "user@example.com"
  docker.io/my-namespace: <co xml:id="CO13-5"/>
    auth: "GzhYWRGU6R2deesfrRgbkSp=""
    email: "user@example.com"</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>URL of the registry.</para>
</callout>
<callout arearefs="CO13-2">
<para>Encrypted password.</para>
</callout>
<callout arearefs="CO13-3">
<para>Email address for the login.</para>
</callout>
<callout arearefs="CO13-4">
<para>URL and credentials for a specific image in a namespace.</para>
</callout>
<callout arearefs="CO13-5">
<para>URL and credentials for a registry namespace.</para>
</callout>
</calloutlist>
<simpara>You can define multiple container image registries or define multiple repositories in the same registry. Alternatively, you can also add authentication entries to this file by running the <literal>docker login</literal> command. The file will be created if it does not exist.</simpara>
<simpara>Kubernetes provides <literal>Secret</literal> objects, which can be used to store configuration and passwords.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have a <literal>.docker/config.json</literal> file.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the secret from your local <literal>.docker/config.json</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic dockerhub \
    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
<simpara>This generates a JSON specification of the secret named <literal>dockerhub</literal> and creates the object.</simpara>
</listitem>
<listitem>
<simpara>Add a <literal>pushSecret</literal> field into the <literal>output</literal> section of the <literal>BuildConfig</literal> and set it to the name of the <literal>secret</literal> that you created, which in the previous example is <literal>dockerhub</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  output:
    to:
      kind: "DockerImage"
      name: "private.registry.com/org/private-image:latest"
    pushSecret:
      name: "dockerhub"</programlisting>
<simpara>You can use the <literal>oc set build-secret</literal> command to set the push secret on the build configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set build-secret --push bc/sample-build dockerhub</programlisting>
<simpara>You can also link the push secret to the service account used by the build instead of specifying the <literal>pushSecret</literal> field. By default, builds use the <literal>builder</literal> service account. The push secret is automatically added to the build if the secret contains a credential that matches the repository hosting the build&#8217;s output image.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link builder dockerhub</programlisting>
</listitem>
<listitem>
<simpara>Pull the builder container image from a private container image registry by specifying the <literal>pullSecret</literal> field, which is part of the build strategy definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  sourceStrategy:
    from:
      kind: "DockerImage"
      name: "docker.io/user/private_repository"
    pullSecret:
      name: "dockerhub"</programlisting>
<simpara>You can use the <literal>oc set build-secret</literal> command to set the pull secret on the build configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set build-secret --pull bc/sample-build dockerhub</programlisting>
<note>
<simpara>This example uses <literal>pullSecret</literal> in a Source build, but it is also applicable in Docker and Custom builds.</simpara>
</note>
<simpara>You can also link the pull secret to the service account used by the build instead of specifying the <literal>pullSecret</literal> field. By default, builds use the <literal>builder</literal> service account. The pull secret is automatically added to the build if the secret contains a credential that matches the repository hosting the build&#8217;s input image. To link the pull secret to the service account used by the build instead of specifying the <literal>pullSecret</literal> field, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link builder dockerhub</programlisting>
<note>
<simpara>You must specify a <literal>from</literal> image in the <literal>BuildConfig</literal> spec to take advantage of this feature. Docker strategy builds generated by <literal>oc new-build</literal> or <literal>oc new-app</literal> may not do this in some situations.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-build-environment_creating-build-inputs">
<title>Build environments</title>
<simpara>As with pod environment variables, build environment variables can be defined in terms of references to other resources or variables using the Downward API. There are some exceptions, which are noted.</simpara>
<simpara>You can also manage environment variables defined in the <literal>BuildConfig</literal> with the <literal>oc set env</literal> command.</simpara>
<note>
<simpara>Referencing container resources using <literal>valueFrom</literal> in build environment variables is not supported as the references are resolved before the container is created.</simpara>
</note>
<section xml:id="builds-using-build-fields-as-environment-variables_creating-build-inputs">
<title>Using build fields as environment variables</title>
<simpara>You can inject information about the build object by setting the <literal>fieldPath</literal> environment variable source to the <literal>JsonPath</literal> of the field from which you are interested in obtaining the value.</simpara>
<note>
<simpara>Jenkins Pipeline strategy does not support <literal>valueFrom</literal> syntax for environment variables.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>fieldPath</literal> environment variable source to the <literal>JsonPath</literal> of the field from which you are interested in obtaining the value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">env:
  - name: FIELDREF_ENV
    valueFrom:
      fieldRef:
        fieldPath: metadata.name</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-using-secrets-as-environment-variables_creating-build-inputs">
<title>Using secrets as environment variables</title>
<simpara>You can make key values from secrets available as environment variables using the <literal>valueFrom</literal> syntax.</simpara>
<important>
<simpara>This method shows the secrets as plain text in the output of the build pod console. To avoid this, use input secrets and config maps instead.</simpara>
</important>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To use a secret as an environment variable, set the <literal>valueFrom</literal> syntax:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: secret-example-bc
spec:
  strategy:
    sourceStrategy:
      env:
      - name: MYVAL
        valueFrom:
          secretKeyRef:
            key: myval
            name: mysecret</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-input-secrets-configmaps_creating-build-inputs">Input secrets and config maps</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-service-serving-certificate-secrets_creating-build-inputs">
<title>Service serving certificate secrets</title>
<simpara>Service serving certificate secrets are intended to support complex middleware applications that need out-of-the-box certificates. It has the same settings as the server certificates generated by the administrator tooling for nodes and masters.</simpara>
<formalpara>
<title>Procedure</title>
<para>To secure communication to your service, have the cluster generate a signed serving certificate/key pair into a secret in your namespace.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Set the <literal>service.beta.openshift.io/serving-cert-secret-name</literal> annotation on your service with the value set to the name you want to use for your secret.</simpara>
<simpara>Then, your <literal>PodSpec</literal> can mount that secret. When it is available, your pod runs. The certificate is good for the internal service DNS name, <literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal>.</simpara>
<simpara>The certificate and key are in PEM format, stored in <literal>tls.crt</literal> and <literal>tls.key</literal> respectively. The certificate/key pair is automatically replaced when it gets close to expiration. View the expiration date in the <literal>service.beta.openshift.io/expiry</literal> annotation on the secret, which is in RFC3339 format.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>In most cases, the service DNS name <literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal> is not externally routable. The primary use of <literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal> is for intracluster or intraservice communication, and with re-encrypt routes.</simpara>
</note>
<simpara>Other pods can trust cluster-created certificates, which are only signed for
internal DNS names, by using the certificate authority (CA) bundle in the <literal>/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt</literal> file that is automatically mounted in their pod.</simpara>
<simpara>The signature algorithm for this feature is <literal>x509.SHA256WithRSA</literal>. To manually rotate, delete the generated secret. A new certificate is created.</simpara>
</section>
<section xml:id="builds-secrets-restrictions_creating-build-inputs">
<title>Secrets restrictions</title>
<simpara>To use a secret, a pod needs to reference the secret. A secret can be used with a pod in three ways:</simpara>
<itemizedlist>
<listitem>
<simpara>To populate environment variables for containers.</simpara>
</listitem>
<listitem>
<simpara>As files in a volume mounted on one or more of its containers.</simpara>
</listitem>
<listitem>
<simpara>By kubelet when pulling images for the pod.</simpara>
</listitem>
</itemizedlist>
<simpara>Volume type secrets write data into the container as a file using the volume mechanism. <literal>imagePullSecrets</literal> use service accounts for the automatic injection of the secret into all pods in a namespaces.</simpara>
<simpara>When a template contains a secret definition, the only way for the template to use the provided secret is to ensure that the secret volume sources are validated and that the specified object reference actually points to an object of type <literal>Secret</literal>. Therefore, a secret needs to be created before any pods that depend on it. The most effective way to ensure this is to have it get injected automatically through the use of a service account.</simpara>
<simpara>Secret API objects reside in a namespace. They can only be referenced by pods in that same namespace.</simpara>
<simpara>Individual secrets are limited to 1MB in size. This is to discourage the creation of large secrets that would exhaust apiserver and kubelet memory. However, creation of a number of smaller secrets could also exhaust memory.</simpara>
</section>
</section>
<section xml:id="managing-build-output">
<title>Managing build output</title>

<simpara>Use the following sections for an overview of and instructions for managing
build output.</simpara>
<section xml:id="builds-docker-source-build-output_managing-build-output">
<title>Build output</title>
<simpara>Builds that use the
docker or
source-to-image (S2I) strategy result in the creation of a new container image. The image is then pushed to the container image registry specified in the <literal>output</literal> section of the <literal>Build</literal> specification.</simpara>
<simpara>If the output kind is <literal>ImageStreamTag</literal>, then the image will be pushed to the integrated OpenShift image registry and tagged in the specified imagestream. If the output is of type <literal>DockerImage</literal>, then the name of the output reference will be used as a docker push specification. The specification may contain a registry or will default to DockerHub if no registry is specified. If the output section of the build specification is empty, then the image will not be pushed at the end of the build.</simpara>
<formalpara>
<title>Output to an ImageStreamTag</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  output:
    to:
      kind: "ImageStreamTag"
      name: "sample-image:latest"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output to a docker Push Specification</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  output:
    to:
      kind: "DockerImage"
      name: "my-registry.mycompany.com:5000/myimages/myimage:tag"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="builds-output-image-environment-variables_managing-build-output">
<title>Output image environment variables</title>
<simpara>docker and
source-to-image (S2I) strategy builds set the following environment variables on output images:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Variable</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_BUILD_NAME</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_BUILD_NAMESPACE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Namespace of the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_BUILD_SOURCE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The source URL of the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_BUILD_REFERENCE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Git reference used in the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_BUILD_COMMIT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source commit used in the build</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Additionally, any user-defined environment variable, for example those configured with
S2I]
or docker
strategy options, will also be part of the output image environment variable list.</simpara>
</section>
<section xml:id="builds-output-image-labels_managing-build-output">
<title>Output image labels</title>
<simpara>docker and
source-to-image (S2I)` builds set the following labels on output images:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.commit.author</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Author of the source commit used in the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.commit.date</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Date of the source commit used in the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.commit.id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Hash of the source commit used in the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.commit.message</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Message of the source commit used in the build</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.commit.ref</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Branch or reference specified in the source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.build.source-location</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source URL for the build</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>You can also use the <literal>BuildConfig.spec.output.imageLabels</literal> field to specify a list of custom labels that will be applied to each image built from the build configuration.</simpara>
<formalpara>
<title>Custom Labels to be Applied to Built Images</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  output:
    to:
      kind: "ImageStreamTag"
      name: "my-image:latest"
    imageLabels:
    - name: "vendor"
      value: "MyCompany"
    - name: "authoritative-source-url"
      value: "registry.mycompany.com"</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="build-strategies">
<title>Using build strategies</title>

<simpara>The following sections define the primary supported build strategies, and how to
use them.</simpara>
<section xml:id="builds-strategy-docker-build_build-strategies">
<title>Docker build</title>
<simpara>OpenShift Container Platform uses Buildah to build a container image from a Dockerfile. For more information on building container images with Dockerfiles, see <link xlink:href="https://docs.docker.com/engine/reference/builder/">the Dockerfile reference documentation</link>.</simpara>
<tip>
<simpara>If you set Docker build arguments by using the <literal>buildArgs</literal> array, see <link xlink:href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact">Understand how ARG and FROM interact</link> in the Dockerfile reference documentation.</simpara>
</tip>
<section xml:id="builds-strategy-docker-from-image_build-strategies">
<title>Replacing Dockerfile FROM image</title>
<simpara>You can replace the <literal>FROM</literal> instruction of the Dockerfile with the <literal>from</literal> of the <literal>BuildConfig</literal> object. If the Dockerfile uses multi-stage builds, the image in the last <literal>FROM</literal> instruction will be replaced.</simpara>
<formalpara>
<title>Procedure</title>
<para>To replace the <literal>FROM</literal> instruction of the Dockerfile with the <literal>from</literal> of the <literal>BuildConfig</literal>.</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  dockerStrategy:
    from:
      kind: "ImageStreamTag"
      name: "debian:latest"</programlisting>
</section>
<section xml:id="builds-strategy-dockerfile-path_build-strategies">
<title>Using Dockerfile path</title>
<simpara>By default, docker builds use a Dockerfile located at the root of the context specified in the <literal>BuildConfig.spec.source.contextDir</literal> field.</simpara>
<simpara>The <literal>dockerfilePath</literal> field allows the build to use a different path to locate your Dockerfile, relative to the <literal>BuildConfig.spec.source.contextDir</literal> field. It can be a different file name than the default Dockerfile, such as <literal>MyDockerfile</literal>, or a path to a Dockerfile in a subdirectory, such as <literal>dockerfiles/app1/Dockerfile</literal>.</simpara>
<formalpara>
<title>Procedure</title>
<para>To use the <literal>dockerfilePath</literal> field for the build to use a different path to locate your Dockerfile, set:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  dockerStrategy:
    dockerfilePath: dockerfiles/app1/Dockerfile</programlisting>
</section>
<section xml:id="builds-strategy-docker-environment-variables_build-strategies">
<title>Using docker environment variables</title>
<simpara>To make environment variables available to the docker build process and resulting image, you can add environment variables to the <literal>dockerStrategy</literal> definition of the build configuration.</simpara>
<simpara>The environment variables defined there are inserted as a single <literal>ENV</literal> Dockerfile instruction right after the <literal>FROM</literal> instruction, so that it can be referenced later on within the Dockerfile.</simpara>
<formalpara>
<title>Procedure</title>
<para>The variables are defined during build and stay in the output image, therefore they will be present in any container that runs that image as well.</para>
</formalpara>
<simpara>For example, defining a custom HTTP proxy to be used during build and runtime:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">dockerStrategy:
...
  env:
    - name: "HTTP_PROXY"
      value: "http://myproxy.net:5187/"</programlisting>
<simpara>You can also manage environment variables defined in the build configuration with the <literal>oc set env</literal> command.</simpara>
</section>
<section xml:id="builds-strategy-docker-build-arguments_build-strategies">
<title>Adding docker build arguments</title>
<simpara>You can set <link xlink:href="https://docs.docker.com/engine/reference/builder/#arg">docker build arguments</link> using the <literal>buildArgs</literal> array. The build arguments are passed to docker when a build is started.</simpara>
<tip>
<simpara>See <link xlink:href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact">Understand how ARG and FROM interact</link> in the Dockerfile reference documentation.</simpara>
</tip>
<formalpara>
<title>Procedure</title>
<para>To set docker build arguments, add entries to the <literal>buildArgs</literal> array, which is located in the <literal>dockerStrategy</literal> definition of the <literal>BuildConfig</literal> object. For example:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">dockerStrategy:
...
  buildArgs:
    - name: "foo"
      value: "bar"</programlisting>
<note>
<simpara>Only the <literal>name</literal> and <literal>value</literal> fields are supported. Any settings on the <literal>valueFrom</literal> field are ignored.</simpara>
</note>
</section>
<section xml:id="builds-strategy-docker-squash-layers_build-strategies">
<title>Squashing layers with docker builds</title>
<simpara>Docker builds normally create a layer representing each instruction in a Dockerfile. Setting the <literal>imageOptimizationPolicy</literal> to <literal>SkipLayers</literal> merges all instructions into a single layer on top of the base image.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>imageOptimizationPolicy</literal> to <literal>SkipLayers</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  dockerStrategy:
    imageOptimizationPolicy: SkipLayers</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-using-build-volumes_build-strategies-docker">
<title>Using build volumes</title>
<simpara>You can mount build volumes to give running builds access to information that you don&#8217;t want to persist in the output container image.</simpara>
<simpara>Build volumes provide sensitive information, such as repository credentials, that the build environment or configuration only needs at build time. Build volumes are different from <link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-define-build-inputs_creating-build-inputs">build inputs</link>, whose data can persist in the output container image.</simpara>
<simpara>The mount points of build volumes, from which the running build reads data, are functionally similar to <link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/">pod volume mounts</link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have <link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-input-secrets-configmaps_creating-build-inputs">added an input secret, config map, or both to a BuildConfig object</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>In the <literal>dockerStrategy</literal> definition of the <literal>BuildConfig</literal> object, add any build volumes to the <literal>volumes</literal> array. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  dockerStrategy:
    volumes:
      - name: secret-mvn <co xml:id="CO14-1"/>
        mounts:
        - destinationPath: /opt/app-root/src/.ssh <co xml:id="CO14-2"/>
        source:
          type: Secret <co xml:id="CO14-3"/>
          secret:
            secretName: my-secret <co xml:id="CO14-4"/>
      - name: settings-mvn <co xml:id="CO14-5"/>
        mounts:
        - destinationPath: /opt/app-root/src/.m2  <co xml:id="CO14-6"/>
        source:
          type: ConfigMap <co xml:id="CO14-7"/>
          configMap:
            name: my-config <co xml:id="CO14-8"/>
      - name: my-csi-volume <co xml:id="CO14-9"/>
        mounts:
        - destinationPath: /opt/app-root/src/some_path  <co xml:id="CO14-10"/>
        source:
          type: CSI <co xml:id="CO14-11"/>
          csi:
            driver: csi.sharedresource.openshift.io <co xml:id="CO14-12"/>
            readOnly: true <co xml:id="CO14-13"/>
            volumeAttributes: <co xml:id="CO14-14"/>
              attribute: value</programlisting>
<calloutlist>
<callout arearefs="CO14-1 CO14-5 CO14-9">
<para>Required. A unique name.</para>
</callout>
<callout arearefs="CO14-2 CO14-6 CO14-10">
<para>Required. The absolute path of the mount point. It must not contain <literal>..</literal> or <literal>:</literal> and doesn&#8217;t collide with the destination path generated by the builder. The <literal>/opt/app-root/src</literal> is the default home directory for many Red Hat S2I-enabled images.</para>
</callout>
<callout arearefs="CO14-3 CO14-7 CO14-11">
<para>Required. The type of source, <literal>ConfigMap</literal>, <literal>Secret</literal>, or <literal>CSI</literal>.</para>
</callout>
<callout arearefs="CO14-4 CO14-8">
<para>Required. The name of the source.</para>
</callout>
<callout arearefs="CO14-12">
<para>Required. The driver that provides the ephemeral CSI volume.</para>
</callout>
<callout arearefs="CO14-13">
<para>Required. This value must be set to <literal>true</literal>. Provides a read-only volume.</para>
</callout>
<callout arearefs="CO14-14">
<para>Optional. The volume attributes of the ephemeral CSI volume. Consult the CSI driver&#8217;s documentation for supported attribute keys and values.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<note>
<simpara>The Shared Resource CSI Driver is supported as a Technology Preview feature.</simpara>
</note>
</section>
</section>
<section xml:id="builds-strategy-s2i-build_build-strategies-docker">
<title>Source-to-image build</title>
<simpara>Source-to-image (S2I) is a tool for building reproducible container images. It produces ready-to-run images by injecting application source into a container image and assembling a new image. The new image incorporates the base image, the builder, and built source and is ready to use with the <literal>buildah run</literal> command. S2I supports incremental builds, which re-use previously downloaded dependencies, previously built artifacts, and so on.</simpara>
<section xml:id="builds-strategy-s2i-incremental-builds_build-strategies-docker">
<title>Performing source-to-image incremental builds</title>
<simpara>Source-to-image (S2I) can perform incremental builds, which means it reuses artifacts from previously-built images.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create an incremental build, apply the following modification to the strategy definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "incremental-image:latest" <co xml:id="CO15-1"/>
    incremental: true <co xml:id="CO15-2"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Specify an image that supports incremental builds. Consult the documentation of the builder image to determine if it supports this behavior.</para>
</callout>
<callout arearefs="CO15-2">
<para>This flag controls whether an incremental build is attempted. If the builder image does not support incremental builds, the build will still succeed, but you will get a log message stating the incremental build was not successful because of a missing <literal>save-artifacts</literal> script.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See S2I Requirements for information on how to create a builder image supporting incremental builds.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-strategy-s2i-override-builder-image-scripts_build-strategies-docker">
<title>Overriding source-to-image builder image scripts</title>
<simpara>You can override the <literal>assemble</literal>, <literal>run</literal>, and <literal>save-artifacts</literal> source-to-image (S2I) scripts provided by the builder image.</simpara>
<formalpara>
<title>Procedure</title>
<para>To override the <literal>assemble</literal>, <literal>run</literal>, and <literal>save-artifacts</literal> S2I scripts provided by the builder image, either:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Provide an <literal>assemble</literal>, <literal>run</literal>, or <literal>save-artifacts</literal> script in the <literal>.s2i/bin</literal> directory of your application source repository.</simpara>
</listitem>
<listitem>
<simpara>Provide a URL of a directory containing the scripts as part of the strategy definition. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "builder-image:latest"
    scripts: "http://somehost.com/scripts_directory" <co xml:id="CO16-1"/></programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>This path will have <literal>run</literal>, <literal>assemble</literal>, and <literal>save-artifacts</literal> appended to it. If any or all scripts are found they will be used in place of the same named scripts provided in the image.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<note>
<simpara>Files located at the <literal>scripts</literal> URL take precedence over files located in <literal>.s2i/bin</literal> of the source repository.</simpara>
</note>
</section>
<section xml:id="builds-strategy-s2i-environment-variables_build-strategies-docker">
<title>Source-to-image environment variables</title>
<simpara>There are two ways to make environment variables available to the source build process and resulting image. Environment files and BuildConfig environment values. Variables provided will be present during the build process and in the output image.</simpara>
<section xml:id="builds-strategy-s2i-environment-files_build-strategies-docker">
<title>Using source-to-image environment files</title>
<simpara>Source build enables you to set environment values, one per line, inside your application, by specifying them in a <literal>.s2i/environment</literal> file in the source repository. The environment variables specified in this file are present during the build process and in the output image.</simpara>
<simpara>If you provide a <literal>.s2i/environment</literal> file in your source repository, source-to-image (S2I) reads this file during the build. This allows customization of the build behavior as the <literal>assemble</literal> script may use these variables.</simpara>
<formalpara>
<title>Procedure</title>
<para>For example, to disable assets compilation for your Rails application during the build:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Add <literal>DISABLE_ASSET_COMPILATION=true</literal> in the <literal>.s2i/environment</literal> file.</simpara>
</listitem>
</itemizedlist>
<simpara>In addition to builds, the specified environment variables are also available in the running application itself. For example, to cause the Rails application to start in <literal>development</literal> mode instead of <literal>production</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Add <literal>RAILS_ENV=development</literal> to the <literal>.s2i/environment</literal> file.</simpara>
</listitem>
</itemizedlist>
<simpara>The complete list of supported environment variables is available in the using images section for each image.</simpara>
</section>
<section xml:id="builds-strategy-s2i-buildconfig-environment_build-strategies-docker">
<title>Using source-to-image build configuration environment</title>
<simpara>You can add environment variables to the <literal>sourceStrategy</literal> definition of the build configuration. The environment variables defined there are visible during the <literal>assemble</literal> script execution and will be defined in the output image, making them also available to the <literal>run</literal> script and application code.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>For example, to disable assets compilation for your Rails application:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">sourceStrategy:
...
  env:
    - name: "DISABLE_ASSET_COMPILATION"
      value: "true"</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>The build environment section provides more advanced instructions.</simpara>
</listitem>
<listitem>
<simpara>You can also manage environment variables defined in the build configuration with the <literal>oc set env</literal> command.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-strategy-s2i-ignore-source-files_build-strategies-docker">
<title>Ignoring source-to-image source files</title>
<simpara>Source-to-image (S2I) supports a <literal>.s2iignore</literal> file, which contains a list of file patterns that should be ignored. Files in the build working directory, as provided by the various input sources, that match a pattern found in the <literal>.s2iignore</literal> file will not be made available to the <literal>assemble</literal> script.</simpara>
</section>
<section xml:id="images-create-s2i_build-strategies-docker">
<title>Creating images from source code with source-to-image</title>
<simpara>Source-to-image (S2I) is a framework that makes it easy to write images that take application source code as an input and produce a new image that runs the assembled application as output.</simpara>
<simpara>The main advantage of using S2I for building reproducible container images is the ease of use for developers. As a builder image author, you must understand two basic concepts in order for your images to provide the best S2I performance, the build process and S2I scripts.</simpara>
<section xml:id="images-create-s2i-build_build-strategies-docker">
<title>Understanding the source-to-image build process</title>
<simpara>The build process consists of the following three fundamental elements, which are combined into a final container image:</simpara>
<itemizedlist>
<listitem>
<simpara>Sources</simpara>
</listitem>
<listitem>
<simpara>Source-to-image (S2I) scripts</simpara>
</listitem>
<listitem>
<simpara>Builder image</simpara>
</listitem>
</itemizedlist>
<simpara>S2I generates a Dockerfile with the builder image as the first <literal>FROM</literal> instruction. The Dockerfile generated by S2I is then passed to Buildah.</simpara>
</section>
<section xml:id="images-create-s2i-scripts_build-strategies-docker">
<title>How to write source-to-image scripts</title>
<simpara>You can write source-to-image (S2I) scripts in any programming language, as long as the scripts are executable inside the builder image. S2I supports multiple options providing <literal>assemble</literal>/<literal>run</literal>/<literal>save-artifacts</literal> scripts. All of these locations are checked on each build in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A script specified in the build configuration.</simpara>
</listitem>
<listitem>
<simpara>A script found in the application source <literal>.s2i/bin</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>A script found at the default image URL with the <literal>io.openshift.s2i.scripts-url</literal> label.</simpara>
</listitem>
</orderedlist>
<simpara>Both the <literal>io.openshift.s2i.scripts-url</literal> label specified in the image and the script specified in a build configuration can take one of the following forms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>image:///path_to_scripts_dir</literal>: absolute path inside the image to a directory where the S2I scripts are located.</simpara>
</listitem>
<listitem>
<simpara><literal>file:///path_to_scripts_dir</literal>: relative or absolute path to a directory on the host where the S2I scripts are located.</simpara>
</listitem>
<listitem>
<simpara><literal>http(s)://path_to_scripts_dir</literal>: URL to a directory where the S2I scripts are located.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>S2I scripts</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Script</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>assemble</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>assemble</literal> script builds the application artifacts from a source and places them into appropriate directories inside the image. This script is required. The workflow for this script is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Optional: Restore build artifacts. If you want to support incremental builds, make sure to define <literal>save-artifacts</literal> as well.</simpara>
</listitem>
<listitem>
<simpara>Place the application source in the desired location.</simpara>
</listitem>
<listitem>
<simpara>Build the application artifacts.</simpara>
</listitem>
<listitem>
<simpara>Install the artifacts into locations appropriate for them to run.</simpara>
</listitem>
</orderedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>run</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>run</literal> script executes your application. This script is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>save-artifacts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>save-artifacts</literal> script gathers all dependencies that can speed up the build processes that follow. This script is optional. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>For Ruby, <literal>gems</literal> installed by Bundler.</simpara>
</listitem>
<listitem>
<simpara>For Java, <literal>.m2</literal> contents.</simpara>
</listitem>
</itemizedlist>
<simpara>These dependencies are gathered into a <literal>tar</literal> file and streamed to the standard output.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>usage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>usage</literal> script allows you to inform the user how to properly use your image. This script is optional.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>test/run</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>test/run</literal> script allows you to create a process to check if the image is working correctly. This script is optional. The proposed flow of that process is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Build the image.</simpara>
</listitem>
<listitem>
<simpara>Run the image to verify the <literal>usage</literal> script.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>s2i build</literal> to verify the <literal>assemble</literal> script.</simpara>
</listitem>
<listitem>
<simpara>Optional: Run <literal>s2i build</literal> again to verify the <literal>save-artifacts</literal> and <literal>assemble</literal> scripts save and restore artifacts functionality.</simpara>
</listitem>
<listitem>
<simpara>Run the image to verify the test application is working.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The suggested location to put the test application built by your <literal>test/run</literal> script is the <literal>test/test-app</literal> directory in your image repository.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><emphasis role="strong">Example S2I scripts</emphasis></simpara>
<simpara>The following example S2I scripts are written in Bash. Each example assumes its <literal>tar</literal> contents are unpacked into the <literal>/tmp/s2i</literal> directory.</simpara>
<formalpara>
<title><literal>assemble</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# restore build artifacts
if [ "$(ls /tmp/s2i/artifacts/ 2&gt;/dev/null)" ]; then
    mv /tmp/s2i/artifacts/* $HOME/.
fi

# move the application source
mv /tmp/s2i/src $HOME/src

# build application artifacts
pushd ${HOME}
make all

# install the artifacts
make install
popd</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>run</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# run the application
/opt/application/run.sh</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>save-artifacts</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

pushd ${HOME}
if [ -d deps ]; then
    # all deps contents to tar stream
    tar cf - deps
fi
popd</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>usage</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# inform the user how to use the image
cat &lt;&lt;EOF
This is a S2I sample builder image, to use it, install
https://github.com/openshift/source-to-image
EOF</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://blog.openshift.com/create-s2i-builder-image/">S2I Image Creation Tutorial</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-using-build-volumes_build-strategies-s2i">
<title>Using build volumes</title>
<simpara>You can mount build volumes to give running builds access to information that you don&#8217;t want to persist in the output container image.</simpara>
<simpara>Build volumes provide sensitive information, such as repository credentials, that the build environment or configuration only needs at build time. Build volumes are different from <link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-define-build-inputs_creating-build-inputs">build inputs</link>, whose data can persist in the output container image.</simpara>
<simpara>The mount points of build volumes, from which the running build reads data, are functionally similar to <link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/">pod volume mounts</link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have <link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-input-secrets-configmaps_creating-build-inputs">added an input secret, config map, or both to a BuildConfig object</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>In the <literal>sourceStrategy</literal> definition of the <literal>BuildConfig</literal> object, add any build volumes to the <literal>volumes</literal> array. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  sourceStrategy:
    volumes:
      - name: secret-mvn <co xml:id="CO17-1"/>
        mounts:
        - destinationPath: /opt/app-root/src/.ssh <co xml:id="CO17-2"/>
        source:
          type: Secret <co xml:id="CO17-3"/>
          secret:
            secretName: my-secret <co xml:id="CO17-4"/>
      - name: settings-mvn <co xml:id="CO17-5"/>
        mounts:
        - destinationPath: /opt/app-root/src/.m2 <co xml:id="CO17-6"/>
        source:
          type: ConfigMap <co xml:id="CO17-7"/>
          configMap:
            name: my-config <co xml:id="CO17-8"/>
      - name: my-csi-volume <co xml:id="CO17-9"/>
        mounts:
        - destinationPath: /opt/app-root/src/some_path  <co xml:id="CO17-10"/>
        source:
          type: CSI <co xml:id="CO17-11"/>
          csi:
            driver: csi.sharedresource.openshift.io <co xml:id="CO17-12"/>
            readOnly: true <co xml:id="CO17-13"/>
            volumeAttributes: <co xml:id="CO17-14"/>
              attribute: value</programlisting>
</listitem>
</itemizedlist>
<calloutlist>
<callout arearefs="CO17-1 CO17-5 CO17-9">
<para>Required. A unique name.</para>
</callout>
<callout arearefs="CO17-2 CO17-6 CO17-10">
<para>Required. The absolute path of the mount point. It must not contain <literal>..</literal> or <literal>:</literal> and doesn&#8217;t collide with the destination path generated by the builder. The <literal>/opt/app-root/src</literal> is the default home directory for many Red Hat S2I-enabled images.</para>
</callout>
<callout arearefs="CO17-3 CO17-7 CO17-11">
<para>Required. The type of source, <literal>ConfigMap</literal>, <literal>Secret</literal>, or <literal>CSI</literal>.</para>
</callout>
<callout arearefs="CO17-4 CO17-8">
<para>Required. The name of the source.</para>
</callout>
<callout arearefs="CO17-12">
<para>Required. The driver that provides the ephemeral CSI volume.</para>
</callout>
<callout arearefs="CO17-13">
<para>Required. This value must be set to <literal>true</literal>. Provides a read-only volume.</para>
</callout>
<callout arearefs="CO17-14">
<para>Optional. The volume attributes of the ephemeral CSI volume. Consult the CSI driver&#8217;s documentation for supported attribute keys and values.</para>
</callout>
</calloutlist>
<note>
<simpara>The Shared Resource CSI Driver is supported as a Technology Preview feature.</simpara>
</note>
</section>
</section>
<section xml:id="builds-strategy-custom-build_build-strategies-s2i">
<title>Custom build</title>
<simpara>The custom build strategy allows developers to define a specific builder image responsible for the entire build process. Using your own builder image allows you to customize your build process.</simpara>
<simpara>A custom builder image is a plain container image embedded with build process logic, for example for building RPMs or base images.</simpara>
<simpara>Custom builds run with a high level of privilege and are not available to users by default. Only users who can be trusted with cluster administration permissions should be granted access to run custom builds.</simpara>
<section xml:id="builds-strategy-custom-from-image_build-strategies-s2i">
<title>Using FROM image for custom builds</title>
<simpara>You can use the <literal>customStrategy.from</literal> section to indicate the image to use for the custom build</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>customStrategy.from</literal> section:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  customStrategy:
    from:
      kind: "DockerImage"
      name: "openshift/sti-image-builder"</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-strategy-custom-secrets_build-strategies-s2i">
<title>Using secrets in custom builds</title>
<simpara>In addition to secrets for source and images that can be added to all build types, custom strategies allow adding an arbitrary list of secrets to the builder pod.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To mount each secret at a specific location, edit the <literal>secretSource</literal> and <literal>mountPath</literal> fields of the <literal>strategy</literal> YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  customStrategy:
    secrets:
      - secretSource: <co xml:id="CO18-1"/>
          name: "secret1"
        mountPath: "/tmp/secret1" <co xml:id="CO18-2"/>
      - secretSource:
          name: "secret2"
        mountPath: "/tmp/secret2"</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para><literal>secretSource</literal> is a reference to a secret in the same namespace as the build.</para>
</callout>
<callout arearefs="CO18-2">
<para><literal>mountPath</literal> is the path inside the custom builder where the secret should be mounted.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-strategy-custom-environment-variables_build-strategies-s2i">
<title>Using environment variables for custom builds</title>
<simpara>To make environment variables available to the custom build process, you can add environment variables to the <literal>customStrategy</literal> definition of the build configuration.</simpara>
<simpara>The environment variables defined there are passed to the pod that runs the
custom build.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a custom HTTP proxy to be used during build:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">customStrategy:
...
  env:
    - name: "HTTP_PROXY"
      value: "http://myproxy.net:5187/"</programlisting>
</listitem>
<listitem>
<simpara>To manage environment variables defined in the build configuration, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set env &lt;enter_variables&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="images-custom_build-strategies-s2i">
<title>Using custom builder images</title>
<simpara>OpenShift Container Platform&#8217;s custom build strategy enables you to define a specific builder image responsible for the entire build process. When you need a build to produce individual artifacts such as packages, JARs, WARs, installable ZIPs, or base images, use a custom builder image using the custom build strategy.</simpara>
<simpara>A custom builder image is a plain container image embedded with build process logic, which is used for building artifacts such as RPMs or base container images.</simpara>
<simpara>Additionally, the custom builder allows implementing any extended build process, such as a CI/CD flow that runs unit or integration tests.</simpara>
<section xml:id="images-custom-builder-image-ref_build-strategies-s2i">
<title>Custom builder image</title>
<simpara>Upon invocation, a custom builder image receives the following environment variables with the information needed to proceed with the build:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Custom Builder Environment Variables</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Variable Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>BUILD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The entire serialized JSON of the <literal>Build</literal> object definition. If you must use a specific API version for serialization, you can set the <literal>buildAPIVersion</literal> parameter in the custom strategy specification of the build configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SOURCE_REPOSITORY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The URL of a Git repository with source to be built.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SOURCE_URI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Uses the same value as <literal>SOURCE_REPOSITORY</literal>. Either can be used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SOURCE_CONTEXT_DIR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the subdirectory of the Git repository to be used when building. Only present if defined.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SOURCE_REF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Git reference to be built.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ORIGIN_VERSION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the OpenShift Container Platform master that created this build object.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OUTPUT_REGISTRY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The container image registry to push the image to.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OUTPUT_IMAGE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The container image tag name for the image being built.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PUSH_DOCKERCFG_PATH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The path to the container registry credentials for running a <literal>podman push</literal>  operation.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="images-custom-builder-flow_build-strategies-s2i">
<title>Custom builder workflow</title>
<simpara>Although custom builder image authors have flexibility in defining the build process, your builder image must adhere to the following required steps necessary for running a build inside of OpenShift Container Platform:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>Build</literal> object definition contains all the necessary information about input parameters for the build.</simpara>
</listitem>
<listitem>
<simpara>Run the build process.</simpara>
</listitem>
<listitem>
<simpara>If your build produces an image, push it to the output location of the build if it is defined. Other output locations can be passed with environment variables.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="builds-strategy-pipeline-build_build-strategies-s2i">
<title>Pipeline build</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>The Pipeline build strategy allows developers to define a Jenkins pipeline for use by the Jenkins pipeline plugin. The build can be started, monitored, and managed by OpenShift Container Platform in the same way as any other build type.</simpara>
<simpara>Pipeline workflows are defined in a <literal>jenkinsfile</literal>, either embedded directly in the build configuration, or supplied in a Git repository and referenced by the build configuration.</simpara>
<section xml:id="builds-understanding-openshift-pipeline_build-strategies-s2i">
<title>Understanding OpenShift Container Platform pipelines</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>Pipelines give you control over building, deploying, and promoting your applications on OpenShift Container Platform. Using a combination of the Jenkins Pipeline build strategy, <literal>jenkinsfiles</literal>, and the OpenShift Container Platform Domain Specific Language (DSL) provided by the Jenkins Client Plugin, you can create advanced build, test, deploy, and promote pipelines for any scenario.</simpara>
<simpara><emphasis role="strong">OpenShift Container Platform Jenkins Sync Plugin</emphasis></simpara>
<simpara>The OpenShift Container Platform Jenkins Sync Plugin keeps the build configuration and build objects in sync with Jenkins jobs and builds, and provides the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Dynamic job and run creation in Jenkins.</simpara>
</listitem>
<listitem>
<simpara>Dynamic creation of agent pod templates from image streams, image stream tags, or config maps.</simpara>
</listitem>
<listitem>
<simpara>Injection of environment variables.</simpara>
</listitem>
<listitem>
<simpara>Pipeline visualization in the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Integration with the Jenkins Git plugin, which passes commit information from OpenShift Container Platform builds to the Jenkins Git plugin.</simpara>
</listitem>
<listitem>
<simpara>Synchronization of secrets into Jenkins credential entries.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">OpenShift Container Platform Jenkins Client Plugin</emphasis></simpara>
<simpara>The OpenShift Container Platform Jenkins Client Plugin is a Jenkins plugin which aims to provide a readable, concise, comprehensive, and fluent Jenkins Pipeline syntax for rich interactions with an OpenShift Container Platform API Server. The plugin uses the OpenShift Container Platform command line tool, <literal>oc</literal>, which must be available on the nodes executing the script.</simpara>
<simpara>The Jenkins Client Plugin must be installed on your Jenkins master so the OpenShift Container Platform DSL will be available to use within the <literal>jenkinsfile</literal> for your application. This plugin is installed and enabled by default when using the OpenShift Container Platform Jenkins image.</simpara>
<simpara>For OpenShift Container Platform Pipelines within your project, you will must use the Jenkins Pipeline Build Strategy. This strategy defaults to using a <literal>jenkinsfile</literal> at the root of your source repository, but also provides the following configuration options:</simpara>
<itemizedlist>
<listitem>
<simpara>An inline <literal>jenkinsfile</literal> field within your build configuration.</simpara>
</listitem>
<listitem>
<simpara>A <literal>jenkinsfilePath</literal> field within your build configuration that references the location of the <literal>jenkinsfile</literal> to use relative to the source <literal>contextDir</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The optional <literal>jenkinsfilePath</literal> field specifies the name of the file to use, relative to the source <literal>contextDir</literal>. If <literal>contextDir</literal> is omitted, it defaults to the root of the repository. If <literal>jenkinsfilePath</literal> is omitted, it defaults to <literal>jenkinsfile</literal>.</simpara>
</note>
</section>
<section xml:id="builds-strategy-pipeline-providing-jenkinsfile_build-strategies-s2i">
<title>Providing the Jenkins file for pipeline builds</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>The <literal>jenkinsfile</literal> uses the standard groovy language syntax to allow fine grained control over the configuration, build, and deployment of your application.</simpara>
<simpara>You can supply the <literal>jenkinsfile</literal> in one of the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>A file located within your source code repository.</simpara>
</listitem>
<listitem>
<simpara>Embedded as part of your build configuration using the <literal>jenkinsfile</literal> field.</simpara>
</listitem>
</itemizedlist>
<simpara>When using the first option, the <literal>jenkinsfile</literal> must be included in your applications source code repository at one of the following locations:</simpara>
<itemizedlist>
<listitem>
<simpara>A file named <literal>jenkinsfile</literal> at the root of your repository.</simpara>
</listitem>
<listitem>
<simpara>A file named <literal>jenkinsfile</literal> at the root of the source <literal>contextDir</literal> of your repository.</simpara>
</listitem>
<listitem>
<simpara>A file name specified via the <literal>jenkinsfilePath</literal> field of the <literal>JenkinsPipelineStrategy</literal> section of your BuildConfig, which is relative to the source <literal>contextDir</literal> if supplied, otherwise it defaults to the root of the repository.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>jenkinsfile</literal> is run on the Jenkins agent pod, which must have the
OpenShift Container Platform client binaries available if you intend to use the OpenShift Container Platform DSL.</simpara>
<formalpara>
<title>Procedure</title>
<para>To provide the Jenkins file, you can either:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Embed the Jenkins file in the build configuration.</simpara>
</listitem>
<listitem>
<simpara>Include in the build configuration a reference to the Git repository that contains the Jenkins file.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Embedded Definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: "BuildConfig"
apiVersion: "v1"
metadata:
  name: "sample-pipeline"
spec:
  strategy:
    jenkinsPipelineStrategy:
      jenkinsfile: |-
        node('agent') {
          stage 'build'
          openshiftBuild(buildConfig: 'ruby-sample-build', showBuildLogs: 'true')
          stage 'deploy'
          openshiftDeploy(deploymentConfig: 'frontend')
        }</programlisting>
</para>
</formalpara>
<formalpara>
<title>Reference to Git Repository</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: "BuildConfig"
apiVersion: "v1"
metadata:
  name: "sample-pipeline"
spec:
  source:
    git:
      uri: "https://github.com/openshift/ruby-hello-world"
  strategy:
    jenkinsPipelineStrategy:
      jenkinsfilePath: some/repo/dir/filename <co xml:id="CO19-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO19-1">
<para>The optional <literal>jenkinsfilePath</literal> field specifies the name of the file to use, relative to the source <literal>contextDir</literal>. If <literal>contextDir</literal> is omitted, it defaults to the root of the repository. If <literal>jenkinsfilePath</literal> is omitted, it defaults to <literal>jenkinsfile</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="builds-strategy-pipeline-environment-variables_build-strategies-s2i">
<title>Using environment variables for pipeline builds</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>To make environment variables available to the Pipeline build process, you can add environment variables to the <literal>jenkinsPipelineStrategy</literal> definition of the build configuration.</simpara>
<simpara>Once defined, the environment variables will be set as parameters for any Jenkins job associated with the build configuration.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To define environment variables to be used during build, edit the YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">jenkinsPipelineStrategy:
...
  env:
    - name: "FOO"
      value: "BAR"</programlisting>
</listitem>
</itemizedlist>
<simpara>You can also manage environment variables defined in the build configuration with the <literal>oc set env</literal> command.</simpara>
<section xml:id="builds-strategy-pipeline-mapping-buildconfig-jenkins_build-strategies-s2i">
<title>Mapping between BuildConfig environment variables and Jenkins job parameters</title>
<simpara>When a Jenkins job is created or updated based on changes to a Pipeline strategy build configuration, any environment variables in the build configuration are mapped to Jenkins job parameters definitions, where the default values for the Jenkins job parameters definitions are the current values of the associated environment variables.</simpara>
<simpara>After the Jenkins job&#8217;s initial creation, you can still add additional parameters to the job from the Jenkins console. The parameter names differ from the names of the environment variables in the build configuration. The parameters are honored when builds are started for those Jenkins jobs.</simpara>
<simpara>How you start builds for the Jenkins job dictates how the parameters are set.</simpara>
<itemizedlist>
<listitem>
<simpara>If you start with <literal>oc start-build</literal>, the values of the environment variables in the build configuration are the parameters set for the corresponding job instance. Any changes you make to the parameters' default values from the Jenkins console are ignored. The build configuration values take precedence.</simpara>
</listitem>
<listitem>
<simpara>If you start with <literal>oc start-build -e</literal>, the values for the environment variables specified in the <literal>-e</literal> option take precedence.</simpara>
<itemizedlist>
<listitem>
<simpara>If you specify an environment variable not listed in the build configuration, they will be added as a Jenkins job parameter definitions.</simpara>
</listitem>
<listitem>
<simpara>Any changes you make from the Jenkins console to the parameters corresponding to the environment variables are ignored. The build configuration and what you specify with <literal>oc start-build -e</literal> takes precedence.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If you start the Jenkins job with the Jenkins console, then you can control the setting of the parameters with the Jenkins console as part of starting a build for the job.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It is recommended that you specify in the build configuration all possible environment variables to be associated with job parameters. Doing so reduces disk I/O and improves performance during Jenkins processing.</simpara>
</note>
</section>
</section>
<section xml:id="builds-tutorial-pipeline_build-strategies-s2i">
<title>Pipeline build tutorial</title>
<important>
<simpara>The Pipeline build strategy is deprecated in OpenShift Container Platform 4. Equivalent and improved functionality is present in the OpenShift Container Platform Pipelines based on Tekton.</simpara>
<simpara>Jenkins images on OpenShift Container Platform are fully supported and users should follow Jenkins user documentation for defining their <literal>jenkinsfile</literal> in a job or store it in a Source Control Management system.</simpara>
</important>
<simpara>This example demonstrates how to create an OpenShift Container Platform Pipeline that will build, deploy, and verify a <literal>Node.js/MongoDB</literal> application using the <literal>nodejs-mongodb.json</literal> template.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the Jenkins master:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">  $ oc project &lt;project_name&gt;</programlisting>
<simpara>Select the project that you want to use or create a new project with <literal>oc new-project &lt;project_name&gt;</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">  $ oc new-app jenkins-ephemeral <co xml:id="CO20-1"/></programlisting>
<simpara>If you want to use persistent storage, use <literal>jenkins-persistent</literal> instead.</simpara>
</listitem>
<listitem>
<simpara>Create a file named <literal>nodejs-sample-pipeline.yaml</literal> with the following content:</simpara>
<note>
<simpara>This creates a <literal>BuildConfig</literal> object that employs the Jenkins pipeline strategy to build, deploy, and scale the <literal>Node.js/MongoDB</literal> example application.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">kind: "BuildConfig"
apiVersion: "v1"
metadata:
  name: "nodejs-sample-pipeline"
spec:
  strategy:
    jenkinsPipelineStrategy:
      jenkinsfile: &lt;pipeline content from below&gt;
    type: JenkinsPipeline</programlisting>
</listitem>
<listitem>
<simpara>After you create a <literal>BuildConfig</literal> object with a <literal>jenkinsPipelineStrategy</literal>, tell the
pipeline what to do by using an inline <literal>jenkinsfile</literal>:</simpara>
<note>
<simpara>This example does not set up a Git repository for the application.</simpara>
<simpara>The following <literal>jenkinsfile</literal> content is written in Groovy using the OpenShift Container Platform DSL. For this example, include inline content in the <literal>BuildConfig</literal> object using the YAML Literal Style, though including a <literal>jenkinsfile</literal> in your source repository is the preferred method.</simpara>
</note>
<programlisting language="groovy" linenumbering="unnumbered">def templatePath = 'https://raw.githubusercontent.com/openshift/nodejs-ex/master/openshift/templates/nodejs-mongodb.json' <co xml:id="CO20-2"/>
def templateName = 'nodejs-mongodb-example' <co xml:id="CO20-3"/>
pipeline {
  agent {
    node {
      label 'nodejs' <co xml:id="CO20-4"/>
    }
  }
  options {
    timeout(time: 20, unit: 'MINUTES') <co xml:id="CO20-5"/>
  }
  stages {
    stage('preamble') {
        steps {
            script {
                openshift.withCluster() {
                    openshift.withProject() {
                        echo "Using project: ${openshift.project()}"
                    }
                }
            }
        }
    }
    stage('cleanup') {
      steps {
        script {
            openshift.withCluster() {
                openshift.withProject() {
                  openshift.selector("all", [ template : templateName ]).delete() <co xml:id="CO20-6"/>
                  if (openshift.selector("secrets", templateName).exists()) { <co xml:id="CO20-7"/>
                    openshift.selector("secrets", templateName).delete()
                  }
                }
            }
        }
      }
    }
    stage('create') {
      steps {
        script {
            openshift.withCluster() {
                openshift.withProject() {
                  openshift.newApp(templatePath) <co xml:id="CO20-8"/>
                }
            }
        }
      }
    }
    stage('build') {
      steps {
        script {
            openshift.withCluster() {
                openshift.withProject() {
                  def builds = openshift.selector("bc", templateName).related('builds')
                  timeout(5) { <co xml:id="CO20-9"/>
                    builds.untilEach(1) {
                      return (it.object().status.phase == "Complete")
                    }
                  }
                }
            }
        }
      }
    }
    stage('deploy') {
      steps {
        script {
            openshift.withCluster() {
                openshift.withProject() {
                  def rm = openshift.selector("dc", templateName).rollout()
                  timeout(5) { <co xml:id="CO20-10"/>
                    openshift.selector("dc", templateName).related('pods').untilEach(1) {
                      return (it.object().status.phase == "Running")
                    }
                  }
                }
            }
        }
      }
    }
    stage('tag') {
      steps {
        script {
            openshift.withCluster() {
                openshift.withProject() {
                  openshift.tag("${templateName}:latest", "${templateName}-staging:latest") <co xml:id="CO20-11"/>
                }
            }
        }
      }
    }
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO20-2">
<para>Path of the template to use.</para>
</callout>
<callout arearefs="CO20-1 CO20-3">
<para>Name of the template that will be created.</para>
</callout>
<callout arearefs="CO20-4">
<para>Spin up a <literal>node.js</literal> agent pod on which to run this build.</para>
</callout>
<callout arearefs="CO20-5">
<para>Set a timeout of 20 minutes for this pipeline.</para>
</callout>
<callout arearefs="CO20-6">
<para>Delete everything with this template label.</para>
</callout>
<callout arearefs="CO20-7">
<para>Delete any secrets with this template label.</para>
</callout>
<callout arearefs="CO20-8">
<para>Create a new application from the <literal>templatePath</literal>.</para>
</callout>
<callout arearefs="CO20-9">
<para>Wait up to five minutes for the build to complete.</para>
</callout>
<callout arearefs="CO20-10">
<para>Wait up to five minutes for the deployment to complete.</para>
</callout>
<callout arearefs="CO20-11">
<para>If everything else succeeded, tag the <literal>$ {templateName}:latest</literal> image as
<literal>$ {templateName}-staging:latest</literal>. A pipeline build configuration for the staging
environment can watch for the <literal>$ {templateName}-staging:latest</literal> image to change
and then deploy it to the staging environment.</para>
</callout>
</calloutlist>
<note>
<simpara>The previous example was written using the declarative pipeline style, but the older scripted pipeline style is also supported.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the Pipeline <literal>BuildConfig</literal> in your OpenShift Container Platform cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f nodejs-sample-pipeline.yaml</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you do not want to create your own file, you can use the sample from the Origin repository by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f https://raw.githubusercontent.com/openshift/origin/master/examples/jenkins/pipeline/nodejs-sample-pipeline.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Start the Pipeline:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build nodejs-sample-pipeline</programlisting>
<note>
<simpara>Alternatively, you can start your pipeline with the OpenShift Container Platform web console by navigating to the Builds &#8594; Pipeline section and clicking <emphasis role="strong">Start Pipeline</emphasis>, or by visiting the Jenkins Console, navigating to the Pipeline that you created, and clicking <emphasis role="strong">Build Now</emphasis>.</simpara>
</note>
<simpara>Once the pipeline is started, you should see the following actions performed within your project:</simpara>
<itemizedlist>
<listitem>
<simpara>A job instance is created on the Jenkins server.</simpara>
</listitem>
<listitem>
<simpara>An agent pod is launched, if your pipeline requires one.</simpara>
</listitem>
<listitem>
<simpara>The pipeline runs on the agent pod, or the master if no agent is required.</simpara>
<itemizedlist>
<listitem>
<simpara>Any previously created resources with the <literal>template=nodejs-mongodb-example</literal> label will be deleted.</simpara>
</listitem>
<listitem>
<simpara>A new application, and all of its associated resources, will be created from the <literal>nodejs-mongodb-example</literal> template.</simpara>
</listitem>
<listitem>
<simpara>A build will be started using the <literal>nodejs-mongodb-example</literal> <literal>BuildConfig</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>The pipeline will wait until the build has completed to trigger the next stage.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>A deployment will be started using the <literal>nodejs-mongodb-example</literal> deployment configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>The pipeline will wait until the deployment has completed to trigger the next stage.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the build and deploy are successful, the <literal>nodejs-mongodb-example:latest</literal> image will be tagged as <literal>nodejs-mongodb-example:stage</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The agent pod is deleted, if one was required for the pipeline.</simpara>
<note>
<simpara>The best way to visualize the pipeline execution is by viewing it in the OpenShift Container Platform web console. You can view your pipelines by logging in to the web console and navigating to Builds &#8594; Pipelines.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="builds-strategy-secrets-web-console_build-strategies-s2i">
<title>Adding secrets with web console</title>
<simpara>You can add a secret to your build configuration so that it can access a private repository.</simpara>
<formalpara>
<title>Procedure</title>
<para>To add a secret to your build configuration so that it can access a private
repository from the OpenShift Container Platform web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a new OpenShift Container Platform project.</simpara>
</listitem>
<listitem>
<simpara>Create a secret that contains credentials for accessing a private source code
repository.</simpara>
</listitem>
<listitem>
<simpara>Create a build configuration.</simpara>
</listitem>
<listitem>
<simpara>On the build configuration editor page or in the <literal>create app from builder image</literal> page of the web console, set the <emphasis role="strong">Source Secret</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-strategy-enable-pulling-pushing_build-strategies-s2i">
<title>Enabling pulling and pushing</title>
<simpara>You can enable pulling to a private registry by setting the pull secret and pushing by setting the push secret in the build configuration.</simpara>
<formalpara>
<title>Procedure</title>
<para>To enable pulling to a private registry:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Set the pull secret in the build configuration.</simpara>
</listitem>
</itemizedlist>
<simpara>To enable pushing:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the push secret in the build configuration.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="custom-builds-buildah">
<title>Custom image builds with Buildah</title>

<simpara>With OpenShift Container Platform 4.14, a docker socket will not be present on the host
nodes. This means the <emphasis>mount docker socket</emphasis> option of a custom build is not
guaranteed to provide an accessible docker socket for use within a custom build
image.</simpara>
<simpara>If you require this capability in order to build and push images, add the Buildah
tool your custom build image and use it to build and push the image within your
custom build logic. The following is an example of how to run custom builds with
Buildah.</simpara>
<note>
<simpara>Using the custom build strategy requires permissions that normal users do
not have by default because it allows the user to execute arbitrary code inside
a privileged container running on the cluster. This level of access can be used
to compromise the cluster and therefore should be granted only to users who are
trusted with administrative privileges on the cluster.</simpara>
</note>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Review how to <link xlink:href="../../cicd/builds/securing-builds-by-strategy.xml#securing-builds-by-strategy">grant custom build permissions</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-create-custom-build-artifacts_custom-builds-buildah">
<title>Creating custom build artifacts</title>
<simpara>You must create the image you want to use as your custom build image.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Starting with an empty directory, create a file named <literal>Dockerfile</literal> with the following content:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM registry.redhat.io/rhel8/buildah
# In this example, `/tmp/build` contains the inputs that build when this
# custom builder image is run. Normally the custom builder image fetches
# this content from some location at build time, by using git clone as an example.
ADD dockerfile.sample /tmp/input/Dockerfile
ADD build.sh /usr/bin
RUN chmod a+x /usr/bin/build.sh
# /usr/bin/build.sh contains the actual custom build logic that will be run when
# this custom builder image is run.
ENTRYPOINT ["/usr/bin/build.sh"]</programlisting>
</listitem>
<listitem>
<simpara>In the same directory, create a file named <literal>dockerfile.sample</literal>. This file is included in the custom build image and defines the image that is produced by the custom build:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM registry.access.redhat.com/ubi9/ubi
RUN touch /tmp/build</programlisting>
</listitem>
<listitem>
<simpara>In the same directory, create a file named <literal>build.sh</literal>. This file contains the logic that is run when the custom build runs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">#!/bin/sh
# Note that in this case the build inputs are part of the custom builder image, but normally this
# is retrieved from an external source.
cd /tmp/input
# OUTPUT_REGISTRY and OUTPUT_IMAGE are env variables provided by the custom
# build framework
TAG="${OUTPUT_REGISTRY}/${OUTPUT_IMAGE}"


# performs the build of the new image defined by dockerfile.sample
buildah --storage-driver vfs bud --isolation chroot -t ${TAG} .


# buildah requires a slight modification to the push secret provided by the service
# account to use it for pushing the image
cp /var/run/secrets/openshift.io/push/.dockercfg /tmp
(echo "{ \"auths\": " ; cat /var/run/secrets/openshift.io/push/.dockercfg ; echo "}") &gt; /tmp/.dockercfg


# push the new image to the target for the build
buildah --storage-driver vfs push --tls-verify=false --authfile /tmp/.dockercfg ${TAG}</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-build-custom-builder-image_custom-builds-buildah">
<title>Build custom builder image</title>
<simpara>You can use OpenShift Container Platform to build and push custom builder images to use in a custom strategy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Define all the inputs that will go into creating your new custom builder image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a <literal>BuildConfig</literal> object that will build your custom builder image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-build --binary --strategy=docker --name custom-builder-image</programlisting>
</listitem>
<listitem>
<simpara>From the directory in which you created your custom build image, run the build:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build custom-builder-image --from-dir . -F</programlisting>
<simpara>After the build completes, your new custom builder image is available in your project in an image stream tag that is named <literal>custom-builder-image:latest</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-use-custom-builder-image_custom-builds-buildah">
<title>Use custom builder image</title>
<simpara>You can define a <literal>BuildConfig</literal> object that uses the custom strategy in conjunction with your custom builder image to execute your custom build logic.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Define all the required inputs for new custom builder image.</simpara>
</listitem>
<listitem>
<simpara>Build your custom builder image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file named <literal>buildconfig.yaml</literal>. This file defines the <literal>BuildConfig</literal> object that is created in your project and executed:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: BuildConfig
apiVersion: build.openshift.io/v1
metadata:
  name: sample-custom-build
  labels:
    name: sample-custom-build
  annotations:
    template.alpha.openshift.io/wait-for-ready: 'true'
spec:
  strategy:
    type: Custom
    customStrategy:
      forcePull: true
      from:
        kind: ImageStreamTag
        name: custom-builder-image:latest
        namespace: &lt;yourproject&gt; <co xml:id="CO21-1"/>
  output:
    to:
      kind: ImageStreamTag
      name: sample-custom:latest</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Specify your project name.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>BuildConfig</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f buildconfig.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a file named <literal>imagestream.yaml</literal>. This file defines the image stream to which the build will push the image:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageStream
apiVersion: image.openshift.io/v1
metadata:
  name: sample-custom
spec: {}</programlisting>
</listitem>
<listitem>
<simpara>Create the imagestream:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f imagestream.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run your custom build:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build sample-custom-build -F</programlisting>
<simpara>When the build runs, it launches a pod running the custom builder image that was built earlier. The pod runs the <literal>build.sh</literal> logic that is defined as the entrypoint for the custom builder image. The <literal>build.sh</literal> logic invokes Buildah to build the <literal>dockerfile.sample</literal> that was embedded in the custom builder image, and then uses Buildah to push the new image to the <literal>sample-custom image stream</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="basic-build-operations">
<title>Performing and configuring basic builds</title>

<simpara>The following sections provide instructions for basic build operations, including starting and canceling builds, editing <literal>BuildConfigs</literal>, deleting <literal>BuildConfigs</literal>, viewing build details, and accessing build logs.</simpara>
<section xml:id="builds-basic-start-build_basic-build-operations">
<title>Starting a build</title>
<simpara>You can manually start a new build from an existing build configuration in your current project.</simpara>
<formalpara>
<title>Procedure</title>
<para>To manually start a build, enter the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build &lt;buildconfig_name&gt;</programlisting>
<section xml:id="builds-basic-start-re-run_basic-build-operations">
<title>Re-running a build</title>
<simpara>You can manually re-run a build using the <literal>--from-build</literal> flag.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To manually re-run a build, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build --from-build=&lt;build_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-start-logs_basic-build-operations">
<title>Streaming build logs</title>
<simpara>You can specify the <literal>--follow</literal> flag to stream the build&#8217;s logs in <literal>stdout</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To manually stream a build&#8217;s logs in <literal>stdout</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build &lt;buildconfig_name&gt; --follow</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-start-environment-variable_basic-build-operations">
<title>Setting environment variables when starting a build</title>
<simpara>You can specify the <literal>--env</literal> flag to set any desired environment variable for the build.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To specify a desired environment variable, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build &lt;buildconfig_name&gt; --env=&lt;key&gt;=&lt;value&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-start-source_basic-build-operations">
<title>Starting a build with source</title>
<simpara>Rather than relying on a Git source pull
or a Dockerfile
for a build, you can also start a build by directly pushing your source, which could be the contents of a Git or SVN working directory, a set of pre-built binary artifacts you want to deploy, or a single file. This can be done by specifying one of the following options for the <literal>start-build</literal> command:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--from-dir=&lt;directory&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a directory that will be archived and used as a binary input for the build.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--from-file=&lt;file&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a single file that will be the only file in the build source. The file is placed in the root of an empty directory with the same file name as the original file provided.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--from-repo=&lt;local_source_repo&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a path to a local repository to use as the binary input for a build. Add the <literal>--commit</literal> option to control which branch, tag, or commit is used for the build.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When passing any of these options directly to the build, the contents are streamed to the build and override the current build source settings.</simpara>
<note>
<simpara>Builds triggered from binary input will not preserve the source on the server, so rebuilds triggered by base image changes will use the source specified in the build configuration.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Start a build from a source using the following command to send the contents of a local Git repository as an archive from the tag <literal>v2</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build hello-world --from-repo=../hello-world --commit=v2</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-basic-cancel-build_basic-build-operations">
<title>Canceling a build</title>
<simpara>You can cancel a build using the web console, or with the following CLI command.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To manually cancel a build, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc cancel-build &lt;build_name&gt;</programlisting>
</listitem>
</itemizedlist>
<section xml:id="builds-basic-cancel-multiple_basic-build-operations">
<title>Canceling multiple builds</title>
<simpara>You can cancel multiple builds with the following CLI command.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To manually cancel multiple builds, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc cancel-build &lt;build1_name&gt; &lt;build2_name&gt; &lt;build3_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-cancel-all_basic-build-operations">
<title>Canceling all builds</title>
<simpara>You can cancel all builds from the build configuration with the following CLI command.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To cancel all builds, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc cancel-build bc/&lt;buildconfig_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-cancel-all-state_basic-build-operations">
<title>Canceling all builds in a given state</title>
<simpara>You can cancel all builds in a given state, such as <literal>new</literal> or <literal>pending</literal>, while ignoring the builds in other states.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To cancel all in a given state, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc cancel-build bc/&lt;buildconfig_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-basic-edit-buildconfig_basic-build-operations">
<title>Editing a BuildConfig</title>
<simpara>To edit your build configurations, you use the <emphasis role="strong">Edit BuildConfig</emphasis> option in the <emphasis role="strong">Builds</emphasis> view of the <emphasis role="strong">Developer</emphasis> perspective.</simpara>
<simpara>You can use either of the following views to edit a <literal>BuildConfig</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Form view</emphasis> enables you to edit your <literal>BuildConfig</literal> using the standard form fields and checkboxes.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">YAML view</emphasis> enables you to edit your <literal>BuildConfig</literal> with full control over the operations.</simpara>
</listitem>
</itemizedlist>
<simpara>You can switch between the <emphasis role="strong">Form view</emphasis> and <emphasis role="strong">YAML view</emphasis> without losing any data. The data in the <emphasis role="strong">Form view</emphasis> is transferred to the <emphasis role="strong">YAML view</emphasis> and vice versa.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Builds</emphasis> view of the <emphasis role="strong">Developer</emphasis> perspective, click the menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> to see the <emphasis role="strong">Edit BuildConfig</emphasis> option.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Edit BuildConfig</emphasis> to see the <emphasis role="strong">Form view</emphasis> option.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Git</emphasis> section, enter the Git repository URL for the codebase you want to use to create an application. The URL is then validated.</simpara>
<itemizedlist>
<listitem>
<simpara>Optional: Click <emphasis role="strong">Show Advanced Git Options</emphasis> to add details such as:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Git Reference</emphasis> to specify a branch, tag, or commit that contains code you want to use to build the application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Context Dir</emphasis> to specify the subdirectory that contains code you want to use to build the application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Source Secret</emphasis> to create a <emphasis role="strong">Secret Name</emphasis> with credentials for pulling your source code from a private repository.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Build from</emphasis> section, select the option that you would like to build from. You can use the following options:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Image Stream tag</emphasis> references an image for a given image stream and tag. Enter the project, image stream, and tag of the location you would like to build from and push to.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Image Stream image</emphasis> references an image for a given image stream and image name. Enter the image stream image you would like to build from. Also enter the project, image stream, and tag to push to.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Docker image</emphasis>: The Docker image is referenced through a Docker image repository. You will also need to enter the project, image stream, and tag to refer to where you would like to push to.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Optional: In the <emphasis role="strong">Environment Variables</emphasis> section, add the environment variables associated with the project by using the <emphasis role="strong">Name</emphasis> and <emphasis role="strong">Value</emphasis> fields. To add more environment variables, use <emphasis role="strong">Add Value</emphasis>, or <emphasis role="strong">Add from ConfigMap</emphasis> and <emphasis role="strong">Secret</emphasis> .</simpara>
</listitem>
<listitem>
<simpara>Optional: To further customize your application, use the following advanced options:</simpara>
<variablelist>
<varlistentry>
<term>Trigger</term>
<listitem>
<simpara>Triggers a new image build when the builder image changes. Add more triggers by clicking <emphasis role="strong">Add Trigger</emphasis> and selecting the <emphasis role="strong">Type</emphasis> and <emphasis role="strong">Secret</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Secrets</term>
<listitem>
<simpara>Adds secrets for your application. Add more secrets by clicking <emphasis role="strong">Add secret</emphasis> and selecting the <emphasis role="strong">Secret</emphasis> and <emphasis role="strong">Mount point</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Policy</term>
<listitem>
<simpara>Click <emphasis role="strong">Run policy</emphasis> to select the build run policy. The selected policy determines the order in which builds created from the build configuration must run.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Hooks</term>
<listitem>
<simpara>Select <emphasis role="strong">Run build hooks after image is built</emphasis> to run commands at the end of the build and verify the image. Add <emphasis role="strong">Hook type</emphasis>, <emphasis role="strong">Command</emphasis>, and <emphasis role="strong">Arguments</emphasis> to append to the command.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> to save the <literal>BuildConfig</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-basic-delete-buildconfig_basic-build-operations">
<title>Deleting a BuildConfig</title>
<simpara>You can delete a <literal>BuildConfig</literal> using the following command.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To delete a <literal>BuildConfig</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete bc &lt;BuildConfigName&gt;</programlisting>
<simpara>This also deletes all builds that were instantiated from this <literal>BuildConfig</literal>.</simpara>
</listitem>
<listitem>
<simpara>To delete a <literal>BuildConfig</literal> and keep the builds instatiated from the <literal>BuildConfig</literal>, specify the <literal>--cascade=false</literal> flag when you enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete --cascade=false bc &lt;BuildConfigName&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-view-build-details_basic-build-operations">
<title>Viewing build details</title>
<simpara>You can view build details with the web console or by using the <literal>oc describe</literal> CLI command.</simpara>
<simpara>This displays information including:</simpara>
<itemizedlist>
<listitem>
<simpara>The build source.</simpara>
</listitem>
<listitem>
<simpara>The build strategy.</simpara>
</listitem>
<listitem>
<simpara>The output destination.</simpara>
</listitem>
<listitem>
<simpara>Digest of the image in the destination registry.</simpara>
</listitem>
<listitem>
<simpara>How the build was created.</simpara>
</listitem>
</itemizedlist>
<simpara>If the build uses the
<literal>Docker</literal> or
<literal>Source</literal> strategy, the <literal>oc describe</literal> output also includes information about the source revision used for the build, including the commit ID, author, committer, and message.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To view build details, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe build &lt;build_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-access-build-logs_basic-build-operations">
<title>Accessing build logs</title>
<simpara>You can access build logs using the web console or the CLI.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To stream the logs using the build directly, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe build &lt;build_name&gt;</programlisting>
</listitem>
</itemizedlist>
<section xml:id="builds-basic-access-buildconfig-logs_basic-build-operations">
<title>Accessing BuildConfig logs</title>
<simpara>You can access <literal>BuildConfig</literal> logs using the web console or the CLI.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To stream the logs of the latest build for a <literal>BuildConfig</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -f bc/&lt;buildconfig_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-access-buildconfig-version-logs_basic-build-operations">
<title>Accessing BuildConfig logs for a given version build</title>
<simpara>You can access logs for a given version build for a <literal>BuildConfig</literal> using the web console or the CLI.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To stream the logs for a given version build for a <literal>BuildConfig</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs --version=&lt;number&gt; bc/&lt;buildconfig_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-basic-access-build-verbosity_basic-build-operations">
<title>Enabling log verbosity</title>
<simpara>You can enable a more verbose output by passing the <literal>BUILD_LOGLEVEL</literal> environment variable as part of the <literal>sourceStrategy</literal>
or <literal>dockerStrategy</literal>
in a <literal>BuildConfig</literal>.</simpara>
<note>
<simpara>An administrator can set the default build verbosity for the entire OpenShift Container Platform instance by configuring <literal>env/BUILD_LOGLEVEL</literal>. This default can be overridden by specifying <literal>BUILD_LOGLEVEL</literal> in a given <literal>BuildConfig</literal>. You can specify a higher priority override on the command line for non-binary builds by passing <literal>--build-loglevel</literal> to <literal>oc start-build</literal>.</simpara>
</note>
<simpara>Available log levels for source builds are as follows:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Level 0</simpara>
</entry>
<entry>
<simpara>Produces output from containers running the <literal>assemble</literal> script and all encountered errors. This is the default.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Level 1</simpara>
</entry>
<entry>
<simpara>Produces basic information about the executed process.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Level 2</simpara>
</entry>
<entry>
<simpara>Produces very detailed information about the executed process.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Level 3</simpara>
</entry>
<entry>
<simpara>Produces very detailed information about the executed process, and a listing of the archive contents.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Level 4</simpara>
</entry>
<entry>
<simpara>Currently produces the same information as level 3.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Level 5</simpara>
</entry>
<entry>
<simpara>Produces everything mentioned on previous levels and additionally provides docker push messages.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To enable more verbose output, pass the <literal>BUILD_LOGLEVEL</literal> environment variable as part of the <literal>sourceStrategy</literal>
or <literal>dockerStrategy</literal>
in a <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">sourceStrategy:
...
  env:
    - name: "BUILD_LOGLEVEL"
      value: "2" <co xml:id="CO22-1"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>Adjust this value to the desired log level.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="triggering-builds-build-hooks">
<title>Triggering and modifying builds</title>

<simpara>The following sections outline how to trigger builds and modify builds using build hooks.</simpara>
<section xml:id="builds-triggers_triggering-builds-build-hooks">
<title>Build triggers</title>
<simpara>When defining a <literal>BuildConfig</literal>, you can define triggers to control the circumstances in which the <literal>BuildConfig</literal> should be run. The following build triggers are available:</simpara>
<itemizedlist>
<listitem>
<simpara>Webhook</simpara>
</listitem>
<listitem>
<simpara>Image change</simpara>
</listitem>
<listitem>
<simpara>Configuration change</simpara>
</listitem>
</itemizedlist>
<section xml:id="builds-webhook-triggers_triggering-builds-build-hooks">
<title>Webhook triggers</title>
<simpara>Webhook triggers allow you to trigger a new build by sending a request to the OpenShift Container Platform API endpoint. You can define these triggers using GitHub, GitLab, Bitbucket, or Generic webhooks.</simpara>
<simpara>Currently, OpenShift Container Platform webhooks only support the analogous versions of the push event for each of the Git-based Source Code Management (SCM) systems. All other event types are ignored.</simpara>
<simpara>When the push events are processed, the OpenShift Container Platform control plane host confirms if the branch reference inside the event matches the branch reference in the corresponding <literal>BuildConfig</literal>. If so, it then checks out the exact commit reference noted in the webhook event on the OpenShift Container Platform build. If they do not match, no build is triggered.</simpara>
<note>
<simpara><literal>oc new-app</literal> and <literal>oc new-build</literal> create GitHub and Generic webhook triggers automatically, but any other needed webhook triggers must be added manually. You can manually add triggers by setting triggers.</simpara>
</note>
<simpara>For all webhooks, you must define a secret with a key named <literal>WebHookSecretKey</literal> and the value being the value to be supplied when invoking the webhook. The webhook definition must then reference the secret. The secret ensures the uniqueness of the URL, preventing others from triggering the build. The value of the key is compared to the secret provided during the webhook invocation.</simpara>
<simpara>For example here is a GitHub webhook with a reference to a secret named <literal>mysecret</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "GitHub"
github:
  secretReference:
    name: "mysecret"</programlisting>
<simpara>The secret is then defined as follows. Note that the value of the secret is base64 encoded as is required for any <literal>data</literal> field of a <literal>Secret</literal> object.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- kind: Secret
  apiVersion: v1
  metadata:
    name: mysecret
    creationTimestamp:
  data:
    WebHookSecretKey: c2VjcmV0dmFsdWUx</programlisting>
<section xml:id="builds-using-github-webhooks_triggering-builds-build-hooks">
<title>Using GitHub webhooks</title>
<simpara>GitHub webhooks handle the call made by GitHub when a repository is updated. When defining the trigger, you must specify a secret, which is part of the URL you supply to GitHub when configuring the webhook.</simpara>
<simpara>Example GitHub webhook definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "GitHub"
github:
  secretReference:
    name: "mysecret"</programlisting>
<note>
<simpara>The secret used in the webhook trigger configuration is not the same as <literal>secret</literal> field you encounter when configuring webhook in GitHub UI. The former is to make the webhook URL unique and hard to predict, the latter is an optional string field used to create HMAC hex digest of the body, which is sent as an <literal>X-Hub-Signature</literal> header.</simpara>
</note>
<simpara>The payload URL is returned as the GitHub Webhook URL by the <literal>oc describe</literal>
command (see Displaying Webhook URLs), and is structured as follows:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/github</programlisting>
</para>
</formalpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a <literal>BuildConfig</literal> from a GitHub repository.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure a GitHub Webhook:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>After creating a <literal>BuildConfig</literal> from a GitHub repository, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe bc/&lt;name-of-your-BuildConfig&gt;</programlisting>
<simpara>This generates a webhook GitHub URL that looks like:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">&lt;https://api.starter-us-east-1.openshift.com:443/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/github</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Cut and paste this URL into GitHub, from the GitHub web console.</simpara>
</listitem>
<listitem>
<simpara>In your GitHub repository, select <emphasis role="strong">Add Webhook</emphasis> from <emphasis role="strong">Settings &#8594; Webhooks</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Paste the URL output into the <emphasis role="strong">Payload URL</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Change the <emphasis role="strong">Content Type</emphasis> from GitHub&#8217;s default <literal>application/x-www-form-urlencoded</literal> to <literal>application/json</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add webhook</emphasis>.</simpara>
<simpara>You should see a message from GitHub stating that your webhook was successfully configured.</simpara>
<simpara>Now, when you push a change to your GitHub repository, a new build automatically starts, and upon a successful build a new deployment starts.</simpara>
<note>
<simpara><link xlink:href="https://gogs.io">Gogs</link> supports the same webhook payload format as GitHub. Therefore, if you are using a Gogs server, you can define a GitHub webhook trigger on your <literal>BuildConfig</literal> and trigger it by your Gogs server as well.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Given a file containing a valid JSON payload, such as <literal>payload.json</literal>, you can manually trigger the webhook with <literal>curl</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -H "X-GitHub-Event: push" -H "Content-Type: application/json" -k -X POST --data-binary @payload.json https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/github</programlisting>
<simpara>The <literal>-k</literal> argument is only necessary if your API server does not have a properly
signed certificate.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The build will only be triggered if the <literal>ref</literal> value from GitHub webhook event matches the <literal>ref</literal> value specified in the <literal>source.git</literal> field of the <literal>BuildConfig</literal> resource.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://gogs.io">Gogs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-using-gitlab-webhooks_triggering-builds-build-hooks">
<title>Using GitLab webhooks</title>
<simpara>GitLab webhooks handle the call made by GitLab when a repository is updated. As with the GitHub triggers, you must specify a secret. The following example is a trigger definition YAML within the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "GitLab"
gitlab:
  secretReference:
    name: "mysecret"</programlisting>
<simpara>The payload URL is returned as the GitLab Webhook URL by the <literal>oc describe</literal> command, and is structured as follows:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/gitlab</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure a GitLab Webhook:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Describe the <literal>BuildConfig</literal> to get the webhook URL:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe bc &lt;name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Copy the webhook URL, replacing <literal>&lt;secret&gt;</literal> with your secret value.</simpara>
</listitem>
<listitem>
<simpara>Follow the <link xlink:href="https://docs.gitlab.com/ce/user/project/integrations/webhooks.html#webhooks">GitLab setup instructions</link>
to paste the webhook URL into your GitLab repository settings.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Given a file containing a valid JSON payload, such as <literal>payload.json</literal>, you can
manually trigger the webhook with <literal>curl</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -H "X-GitLab-Event: Push Hook" -H "Content-Type: application/json" -k -X POST --data-binary @payload.json https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/gitlab</programlisting>
<simpara>The <literal>-k</literal> argument is only necessary if your API server does not have a properly
signed certificate.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-using-bitbucket-webhooks_triggering-builds-build-hooks">
<title>Using Bitbucket webhooks</title>
<simpara><link xlink:href="https://confluence.atlassian.com/bitbucket/manage-webhooks-735643732.html">Bitbucket webhooks</link> handle the call made by Bitbucket when a repository is updated. Similar to the previous triggers, you must specify a secret. The following example is a trigger definition YAML within the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "Bitbucket"
bitbucket:
  secretReference:
    name: "mysecret"</programlisting>
<simpara>The payload URL is returned as the Bitbucket Webhook URL by the <literal>oc describe</literal> command, and is structured as follows:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/bitbucket</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To configure a Bitbucket Webhook:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Describe the 'BuildConfig' to get the webhook URL:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe bc &lt;name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Copy the webhook URL, replacing <literal>&lt;secret&gt;</literal> with your secret value.</simpara>
</listitem>
<listitem>
<simpara>Follow the <link xlink:href="https://confluence.atlassian.com/bitbucket/manage-webhooks-735643732.html">Bitbucket setup instructions</link> to paste the webhook URL into your Bitbucket repository settings.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Given a file containing a valid JSON payload, such as <literal>payload.json</literal>, you can
manually trigger the webhook with <literal>curl</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -H "X-Event-Key: repo:push" -H "Content-Type: application/json" -k -X POST --data-binary @payload.json https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/bitbucket</programlisting>
<simpara>The <literal>-k</literal> argument is only necessary if your API server does not have a properly signed certificate.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-using-generic-webhooks_triggering-builds-build-hooks">
<title>Using generic webhooks</title>
<simpara>Generic webhooks are invoked from any system capable of making a web request. As with the other webhooks, you must specify a secret, which is part of the URL that the caller must use to trigger the build. The secret ensures the uniqueness of the URL, preventing others from triggering the build. The following is an example trigger definition YAML within the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "Generic"
generic:
  secretReference:
    name: "mysecret"
  allowEnv: true <co xml:id="CO23-1"/></programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Set to <literal>true</literal> to allow a generic webhook to pass in environment variables.</para>
</callout>
</calloutlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To set up the caller, supply the calling system with the URL of the generic
webhook endpoint for your build:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/generic</programlisting>
</para>
</formalpara>
<simpara>The caller must invoke the webhook as a <literal>POST</literal> operation.</simpara>
</listitem>
<listitem>
<simpara>To invoke the webhook manually you can use <literal>curl</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -X POST -k https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/generic</programlisting>
<simpara>The HTTP verb must be set to <literal>POST</literal>. The insecure <literal>-k</literal> flag is specified to ignore certificate validation. This second flag is not necessary if your cluster has properly signed certificates.</simpara>
<simpara>The endpoint can accept an optional payload with the following format:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">git:
  uri: "&lt;url to git repository&gt;"
  ref: "&lt;optional git reference&gt;"
  commit: "&lt;commit hash identifying a specific git commit&gt;"
  author:
    name: "&lt;author name&gt;"
    email: "&lt;author e-mail&gt;"
  committer:
    name: "&lt;committer name&gt;"
    email: "&lt;committer e-mail&gt;"
  message: "&lt;commit message&gt;"
env: <co xml:id="CO24-1"/>
   - name: "&lt;variable name&gt;"
     value: "&lt;variable value&gt;"</programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>Similar to the <literal>BuildConfig</literal> environment variables, the environment variables defined here are made available to your build. If these variables collide with the <literal>BuildConfig</literal> environment variables, these variables take precedence. By default, environment variables passed by webhook are ignored. Set the <literal>allowEnv</literal> field to <literal>true</literal> on the webhook definition to enable this behavior.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To pass this payload using <literal>curl</literal>, define it in a file named <literal>payload_file.yaml</literal> and run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -H "Content-Type: application/yaml" --data-binary @payload_file.yaml -X POST -k https://&lt;openshift_api_host:port&gt;/apis/build.openshift.io/v1/namespaces/&lt;namespace&gt;/buildconfigs/&lt;name&gt;/webhooks/&lt;secret&gt;/generic</programlisting>
<simpara>The arguments are the same as the previous example with the addition of a header and a payload. The <literal>-H</literal> argument sets the <literal>Content-Type</literal> header to <literal>application/yaml</literal> or <literal>application/json</literal> depending on your payload format. The <literal>--data-binary</literal> argument is used to send a binary payload with newlines intact with the <literal>POST</literal> request.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>OpenShift Container Platform permits builds to be triggered by the generic webhook even if an invalid request payload is presented, for example, invalid content type, unparsable or invalid content, and so on. This behavior is maintained for backwards compatibility. If an invalid request payload is presented, OpenShift Container Platform returns a warning in JSON format as part of its <literal>HTTP 200 OK</literal> response.</simpara>
</note>
</section>
<section xml:id="builds-displaying-webhook-urls_triggering-builds-build-hooks">
<title>Displaying webhook URLs</title>
<simpara>You can use the following command to display webhook URLs associated with a build configuration. If the command does not display any webhook URLs, then no webhook trigger is defined for that build configuration.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To display any webhook URLs associated with a <literal>BuildConfig</literal>, run:</simpara>
</listitem>
</itemizedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe bc &lt;name&gt;</programlisting>
</section>
</section>
<section xml:id="builds-using-image-change-triggers_triggering-builds-build-hooks">
<title>Using image change triggers</title>
<simpara>As a developer, you can configure your build to run automatically every time a base image changes.</simpara>
<simpara>You can use image change triggers to automatically invoke your build when a new version of an upstream image is available. For example, if a build is based on a RHEL image, you can trigger that build to run any time the RHEL image changes. As a result, the application image is always running on the latest RHEL base image.</simpara>
<note>
<simpara>Image streams that point to container images in <link xlink:href="http://docs.docker.com/v1.7/reference/api/hub_registry_spec/#docker-registry-1-0">v1 container registries</link> only trigger a build once when the image stream tag becomes available and not on subsequent image updates. This is due to the lack of uniquely identifiable images in v1 container registries.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define an <literal>ImageStream</literal> that points to the upstream image you want to use as a trigger:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: "ImageStream"
apiVersion: "v1"
metadata:
  name: "ruby-20-centos7"</programlisting>
<simpara>This defines the image stream that is tied to a container image repository located at <literal><emphasis>&lt;system-registry&gt;</emphasis>/<emphasis>&lt;namespace&gt;</emphasis>/ruby-20-centos7</literal>. The <literal>&lt;system-registry&gt;</literal> is defined as a service with the name <literal>docker-registry</literal> running in OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>If an image stream is the base image for the build, set the <literal>from</literal> field in the build strategy to point to the <literal>ImageStream</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  sourceStrategy:
    from:
      kind: "ImageStreamTag"
      name: "ruby-20-centos7:latest"</programlisting>
<simpara>In this case, the <literal>sourceStrategy</literal> definition is consuming the <literal>latest</literal> tag of the image stream named <literal>ruby-20-centos7</literal> located within this namespace.</simpara>
</listitem>
<listitem>
<simpara>Define a build with one or more triggers that point to <literal>ImageStreams</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "ImageChange" <co xml:id="CO25-1"/>
imageChange: {}
type: "ImageChange" <co xml:id="CO25-2"/>
imageChange:
  from:
    kind: "ImageStreamTag"
    name: "custom-image:latest"</programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>An image change trigger that monitors the <literal>ImageStream</literal> and <literal>Tag</literal> as defined by the build strategy&#8217;s <literal>from</literal> field. The <literal>imageChange</literal> object here must be empty.</para>
</callout>
<callout arearefs="CO25-2">
<para>An image change trigger that monitors an arbitrary image stream. The <literal>imageChange</literal> part, in this case, must include a <literal>from</literal> field that references the <literal>ImageStreamTag</literal> to monitor.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<simpara>When using an image change trigger for the strategy image stream, the generated build is supplied with an immutable docker tag that points to the latest image corresponding to that tag. This new image reference is used by the strategy when it executes for the build.</simpara>
<simpara>For other image change triggers that do not reference the strategy image stream, a new build is started, but the build strategy is not updated with a unique image reference.</simpara>
<simpara>Since this example has an image change trigger for the strategy, the resulting build is:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  sourceStrategy:
    from:
      kind: "DockerImage"
      name: "172.30.17.3:5001/mynamespace/ruby-20-centos7:&lt;immutableid&gt;"</programlisting>
<simpara>This ensures that the triggered build uses the new image that was just pushed to the repository, and the build can be re-run any time with the same inputs.</simpara>
<simpara>You can pause an image change trigger to allow multiple changes on the referenced image stream before a build is started. You can also set the <literal>paused</literal> attribute to true when initially adding an <literal>ImageChangeTrigger</literal> to a <literal>BuildConfig</literal> to prevent a build from being immediately triggered.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: "ImageChange"
imageChange:
  from:
    kind: "ImageStreamTag"
    name: "custom-image:latest"
  paused: true</programlisting>
<simpara>In addition to setting the image field for all <literal>Strategy</literal> types, for custom builds, the <literal>OPENSHIFT_CUSTOM_BUILD_BASE_IMAGE</literal> environment variable is checked.
If it does not exist, then it is created with the immutable image reference. If it does exist, then it is updated with the immutable image reference.</simpara>
<simpara>If a build is triggered due to a webhook trigger or manual request, the build that is created uses the <literal>&lt;immutableid&gt;</literal> resolved from the <literal>ImageStream</literal> referenced by the <literal>Strategy</literal>. This ensures that builds are performed using consistent image tags for ease of reproduction.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="http://docs.docker.com/v1.7/reference/api/hub_registry_spec/#docker-registry-1-0">v1 container registries</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-image-change-trigger-identification_triggering-builds-build-hooks">
<title>Identifying the image change trigger of a build</title>
<simpara>As a developer, if you have image change triggers, you can identify which image change initiated the last build. This can be useful for debugging or troubleshooting builds.</simpara>
<formalpara>
<title>Example <literal>BuildConfig</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: bc-ict-example
  namespace: bc-ict-example-namespace
spec:

# ...

  triggers:
  - imageChange:
      from:
        kind: ImageStreamTag
        name: input:latest
        namespace: bc-ict-example-namespace
  - imageChange:
      from:
        kind: ImageStreamTag
        name: input2:latest
        namespace: bc-ict-example-namespace
    type: ImageChange
status:
  imageChangeTriggers:
  - from:
      name: input:latest
      namespace: bc-ict-example-namespace
    lastTriggerTime: "2021-06-30T13:47:53Z"
    lastTriggeredImageID: image-registry.openshift-image-registry.svc:5000/bc-ict-example-namespace/input@sha256:0f88ffbeb9d25525720bfa3524cb1bf0908b7f791057cf1acfae917b11266a69
  - from:
      name: input2:latest
      namespace: bc-ict-example-namespace
    lastTriggeredImageID:  image-registry.openshift-image-registry.svc:5000/bc-ict-example-namespace/input2@sha256:0f88ffbeb9d25525720bfa3524cb2ce0908b7f791057cf1acfae917b11266a69

  lastVersion: 1</programlisting>
</para>
</formalpara>
<note>
<simpara>This example omits elements that are not related to image change triggers.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have configured multiple image change triggers. These triggers have triggered one or more builds.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In <literal>buildConfig.status.imageChangeTriggers</literal> to identify the <literal>lastTriggerTime</literal> that has the latest timestamp.</simpara>
<simpara>This <literal>ImageChangeTriggerStatus</literal></simpara>
<literallayout class="monospaced">Then you use the `name` and `namespace` from that build to find the corresponding image change trigger in `buildConfig.spec.triggers`.</literallayout>
</listitem>
<listitem>
<simpara>Under <literal>imageChangeTriggers</literal>, compare  timestamps to identify the latest</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Image change triggers</title>
<para>In your build configuration, <literal>buildConfig.spec.triggers</literal> is an array of build trigger policies, <literal>BuildTriggerPolicy</literal>.</para>
</formalpara>
<simpara>Each <literal>BuildTriggerPolicy</literal> has a <literal>type</literal> field and set of pointers fields. Each pointer field corresponds to one of the allowed values for the <literal>type</literal> field. As such, you can only set <literal>BuildTriggerPolicy</literal> to only one pointer field.</simpara>
<simpara>For image change triggers, the value of <literal>type</literal> is <literal>ImageChange</literal>. Then, the <literal>imageChange</literal> field is the pointer to an <literal>ImageChangeTrigger</literal> object, which has the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>lastTriggeredImageID</literal>: This field, which is not shown in the example, is deprecated in OpenShift Container Platform 4.8 and will be ignored in a future release. It contains the resolved image reference for the <literal>ImageStreamTag</literal> when the last build was triggered from this <literal>BuildConfig</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>paused</literal>: You can use this field, which is not shown in the example, to temporarily disable this particular image change trigger.</simpara>
</listitem>
<listitem>
<simpara><literal>from</literal>: You use this field to reference the <literal>ImageStreamTag</literal> that drives this image change trigger. Its type is the core Kubernetes type, <literal>OwnerReference</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>from</literal> field has the following fields of note:
<emphasis role="strong"> <literal>kind</literal>: For image change triggers, the only supported value is <literal>ImageStreamTag</literal>.
</emphasis> <literal>namespace</literal>: You use this field to specify the namespace of the <literal>ImageStreamTag</literal>.
** <literal>name</literal>: You use this field to specify the <literal>ImageStreamTag</literal>.</simpara>
<formalpara>
<title>Image change trigger status</title>
<para>In your build configuration, <literal>buildConfig.status.imageChangeTriggers</literal> is an array of <literal>ImageChangeTriggerStatus</literal> elements. Each <literal>ImageChangeTriggerStatus</literal> element includes the <literal>from</literal>, <literal>lastTriggeredImageID</literal>, and <literal>lastTriggerTime</literal> elements shown in the preceding example.</para>
</formalpara>
<simpara>The <literal>ImageChangeTriggerStatus</literal> that has the most recent <literal>lastTriggerTime</literal> triggered the most recent build. You use its <literal>name</literal> and <literal>namespace</literal> to identify the image change trigger in <literal>buildConfig.spec.triggers</literal> that triggered the build.</simpara>
<simpara>The <literal>lastTriggerTime</literal> with the most recent timestamp signifies the <literal>ImageChangeTriggerStatus</literal> of the last build. This <literal>ImageChangeTriggerStatus</literal> has the same <literal>name</literal> and <literal>namespace</literal> as the image change trigger in <literal>buildConfig.spec.triggers</literal> that triggered the build.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="http://docs.docker.com/v1.7/reference/api/hub_registry_spec/#docker-registry-1-0">v1 container registries</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-configuration-change-triggers_triggering-builds-build-hooks">
<title>Configuration change triggers</title>
<simpara>A configuration change trigger allows a build to be automatically invoked as soon as a new <literal>BuildConfig</literal> is created.</simpara>
<simpara>The following is an example trigger definition YAML within the <literal>BuildConfig</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  type: "ConfigChange"</programlisting>
<note>
<simpara>Configuration change triggers currently only work when creating a new <literal>BuildConfig</literal>. In a future release, configuration change triggers will also be able to launch a build whenever a <literal>BuildConfig</literal> is updated.</simpara>
</note>
<section xml:id="builds-setting-triggers-manually_triggering-builds-build-hooks">
<title>Setting triggers manually</title>
<simpara>Triggers can be added to and removed from build configurations with <literal>oc set triggers</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To set a GitHub webhook trigger on a build configuration, use:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers bc &lt;name&gt; --from-github</programlisting>
</listitem>
<listitem>
<simpara>To set an imagechange trigger, use:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers bc &lt;name&gt; --from-image='&lt;image&gt;'</programlisting>
</listitem>
<listitem>
<simpara>To remove a trigger, add <literal>--remove</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers bc &lt;name&gt; --from-bitbucket --remove</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>When a webhook trigger already exists, adding it again regenerates the webhook secret.</simpara>
</note>
<simpara>For more information, consult the help documentation with by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers --help</programlisting>
</section>
</section>
</section>
<section xml:id="builds-build-hooks_triggering-builds-build-hooks">
<title>Build hooks</title>
<simpara>Build hooks allow behavior to be injected into the build process.</simpara>
<simpara>The <literal>postCommit</literal> field of a <literal>BuildConfig</literal> object runs commands inside a temporary container that is running the build output image. The hook is run immediately after the last layer of the image has been committed and before the image is pushed to a registry.</simpara>
<simpara>The current working directory is set to the image&#8217;s <literal>WORKDIR</literal>, which is the default working directory of the container image. For most images, this is where the source code is located.</simpara>
<simpara>The hook fails if the script or command returns a non-zero exit code or if starting the temporary container fails. When the hook fails it marks the build as failed and the image is not pushed to a registry. The reason for failing can be inspected by looking at the build logs.</simpara>
<simpara>Build hooks can be used to run unit tests to verify the image before the build is marked complete and the image is made available in a registry. If all tests pass and the test runner returns with exit code <literal>0</literal>, the build is marked successful. In case of any test failure, the build is marked as failed. In all cases, the build log contains the output of the test runner, which can be used to identify failed tests.</simpara>
<simpara>The <literal>postCommit</literal> hook is not only limited to running tests, but can be used for other commands as well. Since it runs in a temporary container, changes made by the hook do not persist, meaning that running the hook cannot affect the final image. This behavior allows for, among other uses, the installation and usage of test dependencies that are automatically discarded and are not present in the final image.</simpara>
<section xml:id="builds-configuring-post-commit-build-hooks_triggering-builds-build-hooks">
<title>Configuring post commit build hooks</title>
<simpara>There are different ways to configure the post build hook. All forms in the following examples are equivalent and run <literal>bundle exec rake test --verbose</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Shell script:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">postCommit:
  script: "bundle exec rake test --verbose"</programlisting>
<simpara>The <literal>script</literal> value is a shell script to be run with <literal>/bin/sh -ic</literal>. Use this when a shell script is appropriate to execute the build hook. For example, for running unit tests as above. To control the image entry point, or if the image does not have <literal>/bin/sh</literal>, use <literal>command</literal> and/or <literal>args</literal>.</simpara>
<note>
<simpara>The additional <literal>-i</literal> flag was introduced to improve the experience working with CentOS and RHEL images, and may be removed in a future release.</simpara>
</note>
</listitem>
<listitem>
<simpara>Command as the image entry point:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">postCommit:
  command: ["/bin/bash", "-c", "bundle exec rake test --verbose"]</programlisting>
<simpara>In this form, <literal>command</literal> is the command to run, which overrides the image
entry point in the exec form, as documented in the <link xlink:href="https://docs.docker.com/engine/reference/builder/#entrypoint">Dockerfile reference</link>. This is needed if the image does not have <literal>/bin/sh</literal>, or if you do not want to use a shell. In all other cases, using <literal>script</literal> might be more convenient.</simpara>
</listitem>
<listitem>
<simpara>Command with arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">postCommit:
  command: ["bundle", "exec", "rake", "test"]
  args: ["--verbose"]</programlisting>
<simpara>This form is equivalent to appending the arguments to <literal>command</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Providing both <literal>script</literal> and <literal>command</literal> simultaneously creates an invalid build hook.</simpara>
</note>
</section>
<section xml:id="builds-using-cli-post-commit-build-hooks_triggering-builds-build-hooks">
<title>Using the CLI to set post commit build hooks</title>
<simpara>The <literal>oc set build-hook</literal> command can be used to set the build hook for a build configuration.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To set a command as the post-commit build hook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set build-hook bc/mybc \
    --post-commit \
    --command \
    -- bundle exec rake test --verbose</programlisting>
</listitem>
<listitem>
<simpara>To set a script as the post-commit build hook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set build-hook bc/mybc --post-commit --script="bundle exec rake test --verbose"</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="advanced-build-operations">
<title>Performing advanced builds</title>

<simpara>The following sections provide instructions for advanced build operations including
setting build resources and maximum duration, assigning builds to nodes, chaining
builds, build pruning, and build run policies.</simpara>
<section xml:id="builds-setting-build-resources_advanced-build-operations">
<title>Setting build resources</title>
<simpara>By default, builds are completed by pods using unbound resources, such as memory and CPU. These resources can be limited.</simpara>
<formalpara>
<title>Procedure</title>
<para>You can limit resource use in two ways:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Limit resource use by specifying resource limits in the default container limits of a project.</simpara>
</listitem>
<listitem>
<simpara>Limit resource use by specifying resource limits as part of the build configuration. ** In the following example, each of the <literal>resources</literal>, <literal>cpu</literal>, and <literal>memory</literal> parameters are optional:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  resources:
    limits:
      cpu: "100m" <co xml:id="CO26-1"/>
      memory: "256Mi" <co xml:id="CO26-2"/></programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para><literal>cpu</literal> is in CPU units: <literal>100m</literal> represents 0.1 CPU units (100 * 1e-3).</para>
</callout>
<callout arearefs="CO26-2">
<para><literal>memory</literal> is in bytes: <literal>256Mi</literal> represents 268435456 bytes (256 * 2 ^ 20).</para>
</callout>
</calloutlist>
<simpara>However, if a quota has been defined for your project, one of the following two items is required:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>resources</literal> section set with an explicit <literal>requests</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">resources:
  requests: <co xml:id="CO27-1"/>
    cpu: "100m"
    memory: "256Mi"</programlisting>
<calloutlist>
<callout arearefs="CO27-1">
<para>The <literal>requests</literal> object contains the list of resources that correspond to the list of resources in the quota.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>A limit range defined in your project, where the defaults from the <literal>LimitRange</literal> object apply to pods created during the build process.</simpara>
<simpara>Otherwise, build pod creation will fail, citing a failure to satisfy quota.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-setting-maximum-duration_advanced-build-operations">
<title>Setting maximum duration</title>
<simpara>When defining a <literal>BuildConfig</literal> object, you can define its maximum duration by setting the <literal>completionDeadlineSeconds</literal> field. It is specified in seconds and is not set by default. When not set, there is no maximum duration enforced.</simpara>
<simpara>The maximum duration is counted from the time when a build pod gets scheduled in the system, and defines how long it can be active, including the time needed to pull the builder image. After reaching the specified timeout, the build is terminated by OpenShift Container Platform.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To set maximum duration, specify <literal>completionDeadlineSeconds</literal> in your <literal>BuildConfig</literal>. The following example shows the part of a <literal>BuildConfig</literal> specifying <literal>completionDeadlineSeconds</literal> field for 30 minutes:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  completionDeadlineSeconds: 1800</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>This setting is not supported with the Pipeline Strategy option.</simpara>
</note>
</section>
<section xml:id="builds-assigning-builds-to-nodes_advanced-build-operations">
<title>Assigning builds to specific nodes</title>
<simpara>Builds can be targeted to run on specific nodes by specifying labels in the <literal>nodeSelector</literal> field of a build configuration. The <literal>nodeSelector</literal> value is a set of key-value pairs that are matched to <literal>Node</literal> labels when scheduling the build pod.</simpara>
<simpara>The <literal>nodeSelector</literal> value can also be controlled by cluster-wide default and override values. Defaults will only be applied if the build configuration does not define any key-value pairs for the <literal>nodeSelector</literal> and also does not define an explicitly empty map value of <literal>nodeSelector:{}</literal>. Override values will replace values in the build configuration on a key by key basis.</simpara>
<note>
<simpara>If the specified <literal>NodeSelector</literal> cannot be matched to a node with those labels, the build still stay in the <literal>Pending</literal> state indefinitely.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Assign builds to run on specific nodes by assigning labels in the <literal>nodeSelector</literal> field of the <literal>BuildConfig</literal>, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  nodeSelector:<co xml:id="CO28-1"/>
    key1: value1
    key2: value2</programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>Builds associated with this build configuration will run only on nodes with the <literal>key1=value2</literal> and <literal>key2=value2</literal> labels.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-chaining-builds_advanced-build-operations">
<title>Chained builds</title>
<simpara>For compiled languages such as Go, C, C++, and Java, including the dependencies necessary for compilation in the application image might increase the size of the image or introduce vulnerabilities that can be exploited.</simpara>
<simpara>To avoid these problems, two builds can be chained together. One build that produces the compiled artifact, and a second build that places that artifact in a separate image that runs the artifact.</simpara>
<simpara>In the following example, a source-to-image (S2I) build is combined with a docker build to compile an artifact that is then placed in a separate runtime image.</simpara>
<note>
<simpara>Although this example chains a S2I build and a docker build, the first build can use any strategy that produces an image containing the desired artifacts, and the second build can use any strategy that can consume input content from an image.</simpara>
</note>
<simpara>The first build takes the application source and produces an image containing a <literal>WAR</literal> file. The image is pushed to the <literal>artifact-image</literal> image stream. The path of the output artifact depends on the <literal>assemble</literal> script of the S2I builder used. In this case, it is output to <literal>/wildfly/standalone/deployments/ROOT.war</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: artifact-build
spec:
  output:
    to:
      kind: ImageStreamTag
      name: artifact-image:latest
  source:
    git:
      uri: https://github.com/openshift/openshift-jee-sample.git
      ref: "master"
  strategy:
    sourceStrategy:
      from:
        kind: ImageStreamTag
        name: wildfly:10.1
        namespace: openshift</programlisting>
<simpara>The second build uses image source with a path to the WAR file inside the output image from the first build. An inline <literal>dockerfile</literal> copies that <literal>WAR</literal> file into a runtime image.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: image-build
spec:
  output:
    to:
      kind: ImageStreamTag
      name: image-build:latest
  source:
    dockerfile: |-
      FROM jee-runtime:latest
      COPY ROOT.war /deployments/ROOT.war
    images:
    - from: <co xml:id="CO29-1"/>
        kind: ImageStreamTag
        name: artifact-image:latest
      paths: <co xml:id="CO29-2"/>
      - sourcePath: /wildfly/standalone/deployments/ROOT.war
        destinationDir: "."
  strategy:
    dockerStrategy:
      from: <co xml:id="CO29-3"/>
        kind: ImageStreamTag
        name: jee-runtime:latest
  triggers:
  - imageChange: {}
    type: ImageChange</programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para><literal>from</literal> specifies that the docker build should include the output of the image from the <literal>artifact-image</literal> image stream, which was the target of the previous build.</para>
</callout>
<callout arearefs="CO29-2">
<para><literal>paths</literal> specifies which paths from the target image to include in the current docker build.</para>
</callout>
<callout arearefs="CO29-3">
<para>The runtime image is used as the source image for the docker build.</para>
</callout>
</calloutlist>
<simpara>The result of this setup is that the output image of the second build does not have to contain any of the build tools that are needed to create the <literal>WAR</literal> file. Also, because the second build contains an image change trigger, whenever the first build is run and produces a new image with the binary artifact, the second build is automatically triggered to produce a runtime image that contains that artifact. Therefore, both builds behave as a single build with two stages.</simpara>
</section>
<section xml:id="builds-build-pruning_advanced-build-operations">
<title>Pruning builds</title>
<simpara>By default, builds that have completed their lifecycle are persisted indefinitely. You can limit the number of previous builds that are retained.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Limit the number of previous builds that are retained by supplying a positive integer value for <literal>successfulBuildsHistoryLimit</literal> or <literal>failedBuildsHistoryLimit</literal> in your <literal>BuildConfig</literal>, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "BuildConfig"
metadata:
  name: "sample-build"
spec:
  successfulBuildsHistoryLimit: 2 <co xml:id="CO30-1"/>
  failedBuildsHistoryLimit: 2 <co xml:id="CO30-2"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para><literal>successfulBuildsHistoryLimit</literal> will retain up to two builds with a status of <literal>completed</literal>.</para>
</callout>
<callout arearefs="CO30-2">
<para><literal>failedBuildsHistoryLimit</literal> will retain up to two builds with a status of <literal>failed</literal>, <literal>canceled</literal>, or <literal>error</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Trigger build pruning by one of the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Updating a build configuration.</simpara>
</listitem>
<listitem>
<simpara>Waiting for a build to complete its lifecycle.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>Builds are sorted by their creation timestamp with the oldest builds being pruned first.</simpara>
<note>
<simpara>Administrators can manually prune builds using the 'oc adm' object pruning command.</simpara>
</note>
</section>
<section xml:id="builds-build-run-policy_advanced-build-operations">
<title>Build run policy</title>
<simpara>The build run policy describes the order in which the builds created from the build configuration should run. This can be done by changing the value of the <literal>runPolicy</literal> field in the <literal>spec</literal> section of the <literal>Build</literal> specification.</simpara>
<simpara>It is also possible to change the <literal>runPolicy</literal> value for existing build configurations, by:</simpara>
<itemizedlist>
<listitem>
<simpara>Changing <literal>Parallel</literal> to <literal>Serial</literal> or <literal>SerialLatestOnly</literal> and triggering a new build from this configuration causes the new build to wait until all parallel builds complete as the serial build can only run alone.</simpara>
</listitem>
<listitem>
<simpara>Changing <literal>Serial</literal> to <literal>SerialLatestOnly</literal> and triggering a new build causes cancellation of all existing builds in queue, except the currently running build and the most recently created build. The newest build runs next.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="running-entitled-builds">
<title>Using Red Hat subscriptions in builds</title>

<simpara role="_abstract">Use the following sections to run entitled builds on OpenShift Container Platform.</simpara>
<section xml:id="builds-create-imagestreamtag_running-entitled-builds">
<title>Creating an image stream tag for the Red Hat Universal Base Image</title>
<simpara>To use Red Hat subscriptions within a build, you create an image stream tag to reference the Universal Base Image (UBI).</simpara>
<simpara>To make the UBI available <emphasis role="strong">in every project</emphasis> in the cluster, you add the image stream tag to the <literal>openshift</literal> namespace. Otherwise, to make it available <emphasis role="strong">in a specific project</emphasis>, you add the image stream tag to that project.</simpara>
<simpara>The benefit of using image stream tags this way is that doing so grants access to the UBI based on the <literal>registry.redhat.io</literal> credentials in the install pull secret without exposing the pull secret to other users. This is more convenient than requiring each developer to install pull secrets with <literal>registry.redhat.io</literal> credentials in each project.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create an <literal>ImageStreamTag</literal> in the <literal>openshift</literal> namespace, so it is available to developers in all projects, enter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag --source=docker registry.redhat.io/ubi9/ubi:latest ubi:latest -n openshift</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create an <literal>ImageStreamTag</literal> in the <literal>openshift</literal> namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: ubi
  namespace: openshift
spec:
  tags:
  - from:
      kind: DockerImage
      name: registry.redhat.io/ubi9/ubi:latest
    name: latest
    referencePolicy:
      type: Source</programlisting>
</tip>
</listitem>
<listitem>
<simpara>To create an <literal>ImageStreamTag</literal> in a single project, enter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag --source=docker registry.redhat.io/ubi9/ubi:latest ubi:latest</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create an <literal>ImageStreamTag</literal> in a single project:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  name: ubi
spec:
  tags:
  - from:
      kind: DockerImage
      name: registry.redhat.io/ubi9/ubi:latest
    name: latest
    referencePolicy:
      type: Source</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-source-secrets-entitlements_running-entitled-builds">
<title>Adding subscription entitlements as a build secret</title>
<simpara>Builds that use Red Hat subscriptions to install content must include the entitlement keys as a build secret.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>You must have access to Red Hat entitlements through your subscription. The entitlement secret is automatically created by the Insights Operator.</para>
</formalpara>
<tip>
<simpara>When you perform an Entitlement Build using Red Hat Enterprise Linux (RHEL) 7, you must have the following instructions in your Dockerfile before you run any <literal>yum</literal> commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">RUN rm /etc/rhsm-host</programlisting>
</tip>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the etc-pki-entitlement secret as a build volume in the build configurationâ€™s Docker strategy:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  dockerStrategy:
    from:
      kind: ImageStreamTag
      name: ubi:latest
    volumes:
    - name: etc-pki-entitlement
      mounts:
      - destinationPath: /etc/pki/entitlement
      source:
        type: Secret
        secret:
          secretName: etc-pki-entitlement</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_running_builds_with_subscription_manager">
<title>Running builds with Subscription Manager</title>
<section xml:id="builds-strategy-docker-entitled-subman_running-entitled-builds">
<title>Docker builds using Subscription Manager</title>
<simpara>Docker strategy builds can use the Subscription Manager to install subscription content.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>The entitlement keys must be added as build strategy volumes.</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>Use the following as an example Dockerfile to install content with the Subscription Manager:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM registry.redhat.io/ubi9/ubi:latest
RUN dnf search kernel-devel --showduplicates &amp;&amp; \
        dnf install -y kernel-devel</programlisting>
</section>
</section>
<section xml:id="_running_builds_with_red_hat_satellite_subscriptions">
<title>Running builds with Red Hat Satellite subscriptions</title>
<section xml:id="builds-source-input-satellite-config_running-entitled-builds">
<title>Adding Red Hat Satellite configurations to builds</title>
<simpara>Builds that use Red Hat Satellite to install content must provide appropriate configurations to obtain content from Satellite repositories.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must provide or create a <literal>yum</literal>-compatible repository configuration file that downloads content from your Satellite instance.</simpara>
<formalpara>
<title>Sample repository configuration</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[test-&lt;name&gt;]
name=test-&lt;number&gt;
baseurl = https://satellite.../content/dist/rhel/server/7/7Server/x86_64/os
enabled=1
gpgcheck=0
sslverify=0
sslclientkey = /etc/pki/entitlement/...-key.pem
sslclientcert = /etc/pki/entitlement/....pem</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ConfigMap</literal> containing the Satellite repository configuration file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap yum-repos-d --from-file /path/to/satellite.repo</programlisting>
</listitem>
<listitem>
<simpara>Add the Satellite repository configuration and entitlement key as a build volumes:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">strategy:
  dockerStrategy:
    from:
      kind: ImageStreamTag
      name: ubi:latest
    volumes:
    - name: yum-repos-d
      mounts:
      - destinationPath: /etc/yum.repos.d
      source:
        type: ConfigMap
        configMap:
          name: yum-repos-d
    - name: etc-pki-entitlement
      mounts:
      - destinationPath: /etc/pki/entitlement
      source:
        type: Secret
        secret:
          secretName: etc-pki-entitlement</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-strategy-docker-entitled-satellite_running-entitled-builds">
<title>Docker builds using Red Hat Satellite subscriptions</title>
<simpara>Docker strategy builds can use Red Hat Satellite repositories to install subscription content.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have added the entitlement keys and Satellite repository configurations as build volumes.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Use the following as an example Dockerfile to install content with Satellite:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM registry.redhat.io/ubi9/ubi:latest
RUN dnf search kernel-devel --showduplicates &amp;&amp; \
        dnf install -y kernel-devel</programlisting>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/solutions/5847331">How to use builds with Red Hat Satellite subscriptions and which certificate to use</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="builds-running-entitled-builds-with-sharedsecret-objects_running-entitled-builds">
<title>Running entitled builds using SharedSecret objects</title>
<simpara>You can configure and perform a build in one namespace that securely uses RHEL entitlements from a <literal>Secret</literal> object in another namespace.</simpara>
<simpara>You can still access RHEL entitlements from OpenShift Builds by creating a <literal>Secret</literal> object with your subscription credentials in the same namespace as your <literal>Build</literal> object. However, now, in OpenShift Container Platform 4.10 and later, you can access your credentials and certificates from a <literal>Secret</literal> object in one of the OpenShift Container Platform system namespaces. You run entitled builds with a CSI volume mount of a <literal>SharedSecret</literal> custom resource (CR) instance that references the <literal>Secret</literal> object.</simpara>
<simpara>This procedure relies on the newly introduced Shared Resources CSI Driver feature, which you can use to declare CSI Volume mounts in OpenShift Container Platform Builds. It also relies on the OpenShift Container Platform Insights Operator.</simpara>
<important>
<simpara>Managing machines with the Cluster API is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>The Shared Resources CSI Driver feature also belongs to the <literal>TechPreviewNoUpgrade</literal> feature set, which is a subset of the current Technology Preview features. You can enable the <literal>TechPreviewNoUpgrade</literal> feature set on test clusters, where you can fully test them while leaving the features disabled on production clusters. Enabling this feature set cannot be undone and prevents minor version updates. This feature set is not recommended on production clusters. See "Enabling Technology Preview features using feature gates" in the following "Additional resources" section.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have enabled the  <literal>TechPreviewNoUpgrade</literal> feature set by using the feature gates.</simpara>
</listitem>
<listitem>
<simpara>You have a <literal>SharedSecret</literal> custom resource (CR) instance that references the <literal>Secret</literal> object where the Insights Operator stores the subscription credentials.</simpara>
</listitem>
<listitem>
<simpara>You must have permission to perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create build configs and start builds.</simpara>
</listitem>
<listitem>
<simpara>Discover which <literal>SharedSecret</literal> CR instances are available by entering the <literal>oc get sharedsecrets</literal> command and getting a non-empty list back.</simpara>
</listitem>
<listitem>
<simpara>Determine if the <literal>builder</literal> service account available to you in your namespace is allowed to use the given <literal>SharedSecret</literal> CR instance. In other words, you can run <literal>oc adm policy who-can use &lt;identifier of specific SharedSecret&gt;</literal> to see if the <literal>builder</literal> service account in your namespace is listed.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>If neither of the last two prerequisites in this list are met, establish, or ask someone to establish, the necessary role-based access control (RBAC) so that you can discover <literal>SharedSecret</literal> CR instances and enable service accounts to use <literal>SharedSecret</literal> CR instances.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Grant the <literal>builder</literal> service account RBAC permissions to use the <literal>SharedSecret</literal> CR instance by using <literal>oc apply</literal> with YAML content:</simpara>
<note>
<simpara>Currently, <literal>kubectl</literal> and <literal>oc</literal> have hard-coded special case logic restricting the <literal>use</literal> verb to roles centered around pod security. Therefore, you cannot use <literal>oc create role &#8230;&#8203;</literal> to create the role needed for consuming <literal>SharedSecret</literal> CR instances.</simpara>
</note>
<formalpara>
<title>Example <literal>oc apply -f</literal> command with YAML <literal>Role</literal> object definition</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: shared-resource-my-share
  namespace: my-namespace
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedsecrets
    resourceNames:
      - my-share
    verbs:
      - use
EOF</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>RoleBinding</literal> associated with the role by using the <literal>oc</literal> command:</simpara>
<formalpara>
<title>Example <literal>oc create rolebinding</literal> command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create rolebinding shared-resource-my-share --role=shared-resource-my-share --serviceaccount=my-namespace:builder</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>BuildConfig</literal> object that accesses the RHEL entitlements.</simpara>
<formalpara>
<title>Example YAML <literal>BuildConfig</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: my-csi-bc
  namespace: my-csi-app-namespace
spec:
  runPolicy: Serial
  source:
    dockerfile: |
      FROM registry.redhat.io/ubi9/ubi:latest
      RUN ls -la /etc/pki/entitlement
      RUN rm /etc/rhsm-host
      RUN yum repolist --disablerepo=*
      RUN subscription-manager repos --enable rhocp-4.9-for-rhel-8-x86_64-rpms
      RUN yum -y update
      RUN yum install -y openshift-clients.x86_64
  strategy:
    type: Docker
    dockerStrategy:
      volumes:
        - mounts:
            - destinationPath: "/etc/pki/entitlement"
          name: my-csi-shared-secret
          source:
            csi:
              driver: csi.sharedresource.openshift.io
              readOnly: true
              volumeAttributes:
                sharedSecret: my-share-bc
            type: CSI</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Start a build from the <literal>BuildConfig</literal> object and follow the logs with the <literal>oc</literal> command.</simpara>
<formalpara>
<title>Example oc start-build command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc start-build my-csi-bc -F</programlisting>
</para>
</formalpara>
<example>
<title>Example output from the oc start-build command</title>
<note>
<simpara>Some sections of the following output have been replaced with <literal>&#8230;&#8203;</literal></simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">build.build.openshift.io/my-csi-bc-1 started
Caching blobs under "/var/cache/blobs".

Pulling image registry.redhat.io/ubi9/ubi:latest ...
Trying to pull registry.redhat.io/ubi9/ubi:latest...
Getting image source signatures
Copying blob sha256:5dcbdc60ea6b60326f98e2b49d6ebcb7771df4b70c6297ddf2d7dede6692df6e
Copying blob sha256:8671113e1c57d3106acaef2383f9bbfe1c45a26eacb03ec82786a494e15956c3
Copying config sha256:b81e86a2cb9a001916dc4697d7ed4777a60f757f0b8dcc2c4d8df42f2f7edb3a
Writing manifest to image destination
Storing signatures
Adding transient rw bind mount for /run/secrets/rhsm
STEP 1/9: FROM registry.redhat.io/ubi9/ubi:latest
STEP 2/9: RUN ls -la /etc/pki/entitlement
total 360
drwxrwxrwt. 2 root root 	80 Feb  3 20:28 .
drwxr-xr-x. 10 root root	154 Jan 27 15:53 ..
-rw-r--r--. 1 root root   3243 Feb  3 20:28 entitlement-key.pem
-rw-r--r--. 1 root root 362540 Feb  3 20:28 entitlement.pem
time="2022-02-03T20:28:32Z" level=warning msg="Adding metacopy option, configured globally"
--&gt; 1ef7c6d8c1a
STEP 3/9: RUN rm /etc/rhsm-host
time="2022-02-03T20:28:33Z" level=warning msg="Adding metacopy option, configured globally"
--&gt; b1c61f88b39
STEP 4/9: RUN yum repolist --disablerepo=*
Updating Subscription Management repositories.


...

--&gt; b067f1d63eb
STEP 5/9: RUN subscription-manager repos --enable rhocp-4.9-for-rhel-8-x86_64-rpms
Repository 'rhocp-4.9-for-rhel-8-x86_64-rpms' is enabled for this system.
time="2022-02-03T20:28:40Z" level=warning msg="Adding metacopy option, configured globally"
--&gt; 03927607ebd
STEP 6/9: RUN yum -y update
Updating Subscription Management repositories.

...

Upgraded:
  systemd-239-51.el8_5.3.x86_64      	systemd-libs-239-51.el8_5.3.x86_64
  systemd-pam-239-51.el8_5.3.x86_64
Installed:
  diffutils-3.6-6.el8.x86_64           	libxkbcommon-0.9.1-1.el8.x86_64
  xkeyboard-config-2.28-1.el8.noarch

Complete!
time="2022-02-03T20:29:05Z" level=warning msg="Adding metacopy option, configured globally"
--&gt; db57e92ff63
STEP 7/9: RUN yum install -y openshift-clients.x86_64
Updating Subscription Management repositories.

...

Installed:
  bash-completion-1:2.7-5.el8.noarch
  libpkgconf-1.4.2-1.el8.x86_64
  openshift-clients-4.9.0-202201211735.p0.g3f16530.assembly.stream.el8.x86_64
  pkgconf-1.4.2-1.el8.x86_64
  pkgconf-m4-1.4.2-1.el8.noarch
  pkgconf-pkg-config-1.4.2-1.el8.x86_64

Complete!
time="2022-02-03T20:29:19Z" level=warning msg="Adding metacopy option, configured globally"
--&gt; 609507b059e
STEP 8/9: ENV "OPENSHIFT_BUILD_NAME"="my-csi-bc-1" "OPENSHIFT_BUILD_NAMESPACE"="my-csi-app-namespace"
--&gt; cab2da3efc4
STEP 9/9: LABEL "io.openshift.build.name"="my-csi-bc-1" "io.openshift.build.namespace"="my-csi-app-namespace"
COMMIT temp.builder.openshift.io/my-csi-app-namespace/my-csi-bc-1:edfe12ca
--&gt; 821b582320b
Successfully tagged temp.builder.openshift.io/my-csi-app-namespace/my-csi-bc-1:edfe12ca
821b582320b41f1d7bab4001395133f86fa9cc99cc0b2b64c5a53f2b6750db91
Build complete, no image push requested</programlisting>
</example>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional_resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../support/remote_health_monitoring/insights-operator-simple-access.xml#insights-operator-simple-access">Importing simple content access certificates with Insights Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../nodes/clusters/nodes-cluster-enabling-features.xml#nodes-cluster-enabling">Enabling features using feature gates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../openshift_images/image-streams-manage.xml#image-streams-managing">Managing image streams</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/builds/build-strategies.xml#build-strategies">build strategy</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="securing-builds-by-strategy">
<title>Securing builds by strategy</title>

<simpara>Builds in OpenShift Container Platform are run in privileged containers. Depending on the build strategy used, if you have privileges, you can run builds to escalate their permissions on the cluster and host nodes. And as a security measure, it limits who can run builds and the strategy that is used for those builds. Custom builds are inherently less safe than source builds, because they can execute any code within a privileged container, and are disabled by default. Grant docker build permissions with caution, because a vulnerability in the Dockerfile processing logic could result in a privileges being granted on the host node.</simpara>
<simpara>By default, all users that can create builds are granted permission to use the docker and Source-to-image (S2I) build strategies. Users with cluster administrator privileges can enable the custom build strategy, as referenced in the restricting build strategies to a user globally section.</simpara>
<simpara>You can control who can build and which build strategies they can use by using an authorization policy. Each build strategy has a corresponding build subresource. A user must have permission to create a build and permission to create on the build strategy subresource to create builds using that strategy. Default roles are provided that grant the create permission on the build strategy subresource.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Build Strategy Subresources and Roles</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Strategy</entry>
<entry align="left" valign="top">Subresource</entry>
<entry align="left" valign="top">Role</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Docker</simpara></entry>
<entry align="left" valign="top"><simpara>builds/docker</simpara></entry>
<entry align="left" valign="top"><simpara>system:build-strategy-docker</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Source-to-Image</simpara></entry>
<entry align="left" valign="top"><simpara>builds/source</simpara></entry>
<entry align="left" valign="top"><simpara>system:build-strategy-source</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Custom</simpara></entry>
<entry align="left" valign="top"><simpara>builds/custom</simpara></entry>
<entry align="left" valign="top"><simpara>system:build-strategy-custom</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>JenkinsPipeline</simpara></entry>
<entry align="left" valign="top"><simpara>builds/jenkinspipeline</simpara></entry>
<entry align="left" valign="top"><simpara>system:build-strategy-jenkinspipeline</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="builds-disabling-build-strategy-globally_securing-builds-by-strategy">
<title>Disabling access to a build strategy globally</title>
<simpara>To prevent access to a particular build strategy globally, log in as a user with cluster administrator privileges, remove the corresponding role from the <literal>system:authenticated</literal> group, and apply the annotation <literal>rbac.authorization.kubernetes.io/autoupdate: "false"</literal> to protect them from changes between the API restarts. The following example shows disabling the docker build strategy.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the <literal>rbac.authorization.kubernetes.io/autoupdate</literal> annotation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit clusterrolebinding system:build-strategy-docker-binding</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    rbac.authorization.kubernetes.io/autoupdate: "false" <co xml:id="CO31-1"/>
  creationTimestamp: 2018-08-10T01:24:14Z
  name: system:build-strategy-docker-binding
  resourceVersion: "225"
  selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/system%3Abuild-strategy-docker-binding
  uid: 17b1f3d4-9c3c-11e8-be62-0800277d20bf
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:build-strategy-docker
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:authenticated</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO31-1">
<para>Change the <literal>rbac.authorization.kubernetes.io/autoupdate</literal> annotation&#8217;s value to <literal>"false"</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Remove the role:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy remove-cluster-role-from-group system:build-strategy-docker system:authenticated</programlisting>
</listitem>
<listitem>
<simpara>Ensure the build strategy subresources are also removed from these roles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit clusterrole admin</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit clusterrole edit</programlisting>
</listitem>
<listitem>
<simpara>For each role, specify the subresources that correspond to the resource of the strategy to disable.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Disable the docker Build Strategy for <emphasis role="strong">admin</emphasis>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterRole
metadata:
  name: admin
...
- apiGroups:
  - ""
  - build.openshift.io
  resources:
  - buildconfigs
  - buildconfigs/webhooks
  - builds/custom <co xml:id="CO32-1"/>
  - builds/source
  verbs:
  - create
  - delete
  - deletecollection
  - get
  - list
  - patch
  - update
  - watch
...</programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>Add <literal>builds/custom</literal> and <literal>builds/source</literal> to disable docker builds globally for users with the <emphasis role="strong">admin</emphasis> role.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="builds-restricting-build-strategy-globally_securing-builds-by-strategy">
<title>Restricting build strategies to users globally</title>
<simpara>You can allow a set of specific users to create builds with a particular strategy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Disable global access to the build strategy.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Assign the role that corresponds to the build strategy to a specific user. For
example, to add the <literal>system:build-strategy-docker</literal> cluster role to the user
<literal>devuser</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-cluster-role-to-user system:build-strategy-docker devuser</programlisting>
<warning>
<simpara>Granting a user access at the cluster level to the <literal>builds/docker</literal> subresource means that the user can create builds with the docker strategy in any project in which they can create builds.</simpara>
</warning>
</listitem>
</itemizedlist>
</section>
<section xml:id="builds-restricting-build-strategy-to-user_securing-builds-by-strategy">
<title>Restricting build strategies to a user within a project</title>
<simpara>Similar to granting the build strategy role to a user globally, you can allow a set of specific users within a project to create builds with a particular strategy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Disable global access to the build strategy.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Assign the role that corresponds to the build strategy to a specific user within a project. For example, to add the <literal>system:build-strategy-docker</literal> role within the project <literal>devproject</literal> to the user <literal>devuser</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-role-to-user system:build-strategy-docker devuser -n devproject</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="build-configuration">
<title>Build configuration resources</title>

<simpara>Use the following procedure to configure build settings.</simpara>
<section xml:id="builds-configuration-parameters_build-configuration">
<title>Build controller configuration parameters</title>
<simpara>The <literal>build.config.openshift.io/cluster</literal> resource offers the following configuration parameters.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Build</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds cluster-wide information on how to handle builds. The canonical, and only valid name is <literal>cluster</literal>.</simpara>
<simpara><literal>spec</literal>: Holds user-settable values for the build controller configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>buildDefaults</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls the default information for builds.</simpara>
<simpara><literal>defaultProxy</literal>: Contains the default proxy settings for all build operations, including image pull or push and source download.</simpara>
<simpara>You can override values by setting the <literal>HTTP_PROXY</literal>, <literal>HTTPS_PROXY</literal>, and <literal>NO_PROXY</literal> environment variables in the <literal>BuildConfig</literal> strategy.</simpara>
<simpara><literal>gitProxy</literal>: Contains the proxy settings for Git operations only. If set, this overrides any proxy settings for all Git commands, such as <literal>git clone</literal>.</simpara>
<simpara>Values that are not set here are inherited from DefaultProxy.</simpara>
<simpara><literal>env</literal>: A set of default environment variables that are applied to the build if the specified variables do not exist on the build.</simpara>
<simpara><literal>imageLabels</literal>: A list of labels that are applied to the resulting image. You can override a default label by providing a label with the same name in the <literal>BuildConfig</literal>.</simpara>
<simpara><literal>resources</literal>: Defines resource requirements to execute the build.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ImageLabel</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>name</literal>: Defines the name of the label. It must have non-zero length.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>buildOverrides</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls override settings for builds.</simpara>
<simpara><literal>imageLabels</literal>: A list of labels that are applied to the resulting image. If you provided a label in the <literal>BuildConfig</literal> with the same name as one in this table, your label will be overwritten.</simpara>
<simpara><literal>nodeSelector</literal>: A selector which must be true for the build pod to fit on a node.</simpara>
<simpara><literal>tolerations</literal>: A list of tolerations that overrides any existing tolerations set on a build pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BuildList</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>items</literal>: Standard object&#8217;s metadata.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="builds-configuration-file_build-configuration">
<title>Configuring build settings</title>
<simpara>You can configure build settings by editing the <literal>build.config.openshift.io/cluster</literal> resource.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>build.config.openshift.io/cluster</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit build.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>build.config.openshift.io/cluster</literal> resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Build<co xml:id="CO33-1"/>
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 2
  name: cluster
  resourceVersion: "107233"
  selfLink: /apis/config.openshift.io/v1/builds/cluster
  uid: e2e9cc14-78a9-11e9-b92b-06d6c7da38dc
spec:
  buildDefaults:<co xml:id="CO33-2"/>
    defaultProxy:<co xml:id="CO33-3"/>
      httpProxy: http://proxy.com
      httpsProxy: https://proxy.com
      noProxy: internal.com
    env:<co xml:id="CO33-4"/>
    - name: envkey
      value: envvalue
    gitProxy:<co xml:id="CO33-5"/>
      httpProxy: http://gitproxy.com
      httpsProxy: https://gitproxy.com
      noProxy: internalgit.com
    imageLabels:<co xml:id="CO33-6"/>
    - name: labelkey
      value: labelvalue
    resources:<co xml:id="CO33-7"/>
      limits:
        cpu: 100m
        memory: 50Mi
      requests:
        cpu: 10m
        memory: 10Mi
  buildOverrides:<co xml:id="CO33-8"/>
    imageLabels:<co xml:id="CO33-9"/>
    - name: labelkey
      value: labelvalue
    nodeSelector:<co xml:id="CO33-10"/>
      selectorkey: selectorvalue
    tolerations:<co xml:id="CO33-11"/>
    - effect: NoSchedule
      key: node-role.kubernetes.io/builds
operator: Exists</programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para><literal>Build</literal>: Holds cluster-wide information on how to handle builds. The canonical, and only valid name is <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO33-2">
<para><literal>buildDefaults</literal>: Controls the default information for builds.</para>
</callout>
<callout arearefs="CO33-3">
<para><literal>defaultProxy</literal>: Contains the default proxy settings for all build operations, including image pull or push and source download.</para>
</callout>
<callout arearefs="CO33-4">
<para><literal>env</literal>: A set of default environment variables that are applied to the build if the specified variables do not exist on the build.</para>
</callout>
<callout arearefs="CO33-5">
<para><literal>gitProxy</literal>: Contains the proxy settings for Git operations only. If set, this overrides any Proxy settings for all Git commands, such as <literal>git clone</literal>.</para>
</callout>
<callout arearefs="CO33-6">
<para><literal>imageLabels</literal>: A list of labels that are applied to the resulting image.
You can override a default label by providing a label with the same name in the <literal>BuildConfig</literal>.</para>
</callout>
<callout arearefs="CO33-7">
<para><literal>resources</literal>: Defines resource requirements to execute the build.</para>
</callout>
<callout arearefs="CO33-8">
<para><literal>buildOverrides</literal>: Controls override settings for builds.</para>
</callout>
<callout arearefs="CO33-9">
<para><literal>imageLabels</literal>: A list of labels that are applied to the resulting image.
If you provided a label in the <literal>BuildConfig</literal> with the same name as one in this table, your label will be overwritten.</para>
</callout>
<callout arearefs="CO33-10">
<para><literal>nodeSelector</literal>: A selector which must be true for the build pod to fit on a node.</para>
</callout>
<callout arearefs="CO33-11">
<para><literal>tolerations</literal>: A list of tolerations that overrides any existing tolerations set on a build pod.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="troubleshooting-builds_build-configuration">
<title>Troubleshooting builds</title>

<simpara>Use the following to troubleshoot build issues.</simpara>
<section xml:id="builds-troubleshooting-access-resources_troubleshooting-builds">
<title>Resolving denial for access to resources</title>
<simpara>If your request for access to resources is denied:</simpara>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>A build fails with:</simpara>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="terminal" linenumbering="unnumbered">requested access to the resource is denied</programlisting>
<variablelist>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>You have exceeded one of the image quotas set on your project. Check your current quota and verify the limits applied and storage in use:</simpara>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe quota</programlisting>
</section>
<section xml:id="builds-troubleshooting-service-certificate-generation_troubleshooting-builds">
<title>Service certificate generation failure</title>
<simpara>If your request for access to resources is denied:</simpara>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>If a service certificate generation fails with (service&#8217;s <literal>service.beta.openshift.io/serving-cert-generation-error</literal> annotation contains):</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">secret/ssl-key references serviceUID 62ad25ca-d703-11e6-9d6f-0e9c0057b608, which does not match 77b6dd80-d716-11e6-9d6f-0e9c0057b60</programlisting>
</para>
</formalpara>
<variablelist>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>The service that generated the certificate no longer exists, or has a different <literal>serviceUID</literal>. You must force certificates regeneration by removing the old secret, and clearing the following annotations on the service: <literal>service.beta.openshift.io/serving-cert-generation-error</literal> and <literal>service.beta.openshift.io/serving-cert-generation-error-num</literal>:</simpara>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret &lt;secret_name&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service &lt;service_name&gt; service.beta.openshift.io/serving-cert-generation-error-</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service &lt;service_name&gt; service.beta.openshift.io/serving-cert-generation-error-num-</programlisting>
<note>
<simpara>The command removing annotation has a <literal>-</literal> after the annotation name to be
removed.</simpara>
</note>
</section>
</section>
<section xml:id="setting-up-trusted-ca">
<title>Setting up additional trusted certificate authorities for builds</title>

<simpara>Use the following sections to set up additional certificate authorities (CA) to be trusted by builds when pulling images from an image registry.</simpara>
<simpara>The procedure requires a cluster administrator to create a <literal>ConfigMap</literal> and add additional CAs as keys in the <literal>ConfigMap</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>ConfigMap</literal> must be created in the <literal>openshift-config</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara><literal>domain</literal> is the key in the <literal>ConfigMap</literal> and <literal>value</literal> is the PEM-encoded certificate.</simpara>
<itemizedlist>
<listitem>
<simpara>Each CA must be associated with a domain. The domain format is <literal>hostname[..port]</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <literal>ConfigMap</literal> name must be set in the <literal>image.config.openshift.io/cluster</literal> cluster scoped configuration resource&#8217;s <literal>spec.additionalTrustedCA</literal> field.</simpara>
</listitem>
</itemizedlist>
<section xml:id="configmap-adding-ca_setting-up-trusted-ca">
<title>Adding certificate authorities to the cluster</title>
<simpara>You can add certificate authorities (CA) to the cluster for use when pushing and pulling images with the following procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have access to the public certificates of the registry, usually a <literal>hostname/ca.crt</literal> file located in the <literal>/etc/docker/certs.d/</literal> directory.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ConfigMap</literal> in the <literal>openshift-config</literal> namespace containing the trusted certificates for the registries that use self-signed certificates. For each CA file, ensure the key in the <literal>ConfigMap</literal> is the hostname of the registry in the <literal>hostname[..port]</literal> format:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap registry-cas -n openshift-config \
--from-file=myregistry.corp.com..5000=/etc/docker/certs.d/myregistry.corp.com:5000/ca.crt \
--from-file=otherregistry.com=/etc/docker/certs.d/otherregistry.com/ca.crt</programlisting>
</listitem>
<listitem>
<simpara>Update the cluster image configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch image.config.openshift.io/cluster --patch '{"spec":{"additionalTrustedCA":{"name":"registry-cas"}}}' --type=merge</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional_resources_2" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#create-a-configmap">Create a <literal>ConfigMap</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubectl.docs.kubernetes.io/guides/config_management/secrets_configmaps/">Secrets and <literal>ConfigMaps</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../networking/configuring-a-custom-pki.xml#configuring-a-custom-pki">Configuring a custom PKI</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_pipelines">
<title>Pipelines</title>
<section xml:id="about-pipelines">
<title>About Red Hat OpenShift Pipelines</title>

<simpara>Red Hat OpenShift Pipelines is a cloud-native, continuous integration and continuous delivery (CI/CD) solution based on Kubernetes resources. It uses Tekton building blocks to automate deployments across multiple platforms by abstracting away the underlying implementation details. Tekton introduces a number of standard custom resource definitions (CRDs) for defining CI/CD pipelines that are portable across Kubernetes distributions.</simpara>
<note>
<simpara>Because Red Hat OpenShift Pipelines releases on a different cadence from OpenShift Container Platform, the Red Hat OpenShift Pipelines documentation is now available as separate documentation sets for each minor version of the product.</simpara>
<simpara>The Red Hat OpenShift Pipelines documentation is available at <link xlink:href="https://docs.openshift.com/pipelines/">https://docs.openshift.com/pipelines/</link>.</simpara>
<simpara>Documentation for specific versions is available using the version selector drop-down list, or directly by adding the version to the URL, for example, <link xlink:href="https://docs.openshift.com/pipelines/1.11">https://docs.openshift.com/pipelines/1.11</link>.</simpara>
<simpara>In addition, the Red Hat OpenShift Pipelines documentation is also available on the Red Hat Customer Portal at <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openshift_pipelines/">https://access.redhat.com/documentation/en-us/red_hat_openshift_pipelines/</link>.</simpara>
<simpara>For additional information about the Red Hat OpenShift Pipelines life cycle and supported platforms, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#pipelines">Platform Life Cycle Policy</link>.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="_gitops">
<title>GitOps</title>
<section xml:id="about-redhat-openshift-gitops">
<title>About Red Hat OpenShift GitOps</title>

<simpara>Red Hat OpenShift GitOps is an Operator that uses Argo CD as the declarative GitOps engine. It enables GitOps workflows across multicluster OpenShift and Kubernetes infrastructure. Using Red Hat OpenShift GitOps, administrators can consistently configure and deploy Kubernetes-based infrastructure and applications across clusters and development lifecycles. Red Hat OpenShift GitOps is based on the open source project <link xlink:href="https://argoproj.github.io/cd/">Argo CD</link> and provides a similar set of features to what the upstream offers, with additional automation, integration into Red Hat {OCP} and the benefits of Red Hatâ€™s enterprise support, quality assurance and focus on enterprise security.</simpara>
<note>
<simpara>Because Red Hat OpenShift GitOps releases on a different cadence from {OCP}, the Red Hat OpenShift GitOps documentation is now available as separate documentation sets for each minor version of the product.</simpara>
<simpara>The Red Hat OpenShift GitOps documentation is available at <link xlink:href="https://docs.openshift.com/gitops/">https://docs.openshift.com/gitops/</link>.</simpara>
<simpara>Documentation for specific versions is available using the version selector dropdown, or directly by adding the version to the URL, for example, <link xlink:href="https://docs.openshift.com/gitops/1.8">https://docs.openshift.com/gitops/1.8</link>.</simpara>
<simpara>In addition, the Red Hat OpenShift GitOps documentation is also available on the Red Hat Portal at <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openshift_gitops/">https://access.redhat.com/documentation/en-us/red_hat_openshift_gitops/</link>.</simpara>
<simpara>For additional information about the Red Hat OpenShift GitOps life cycle and supported platforms, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#gitops">Platform Life Cycle Policy</link>.</simpara>
</note>
<simpara>Red Hat OpenShift GitOps ensures consistency in applications when you deploy them to different clusters in different environments, such as: development, staging, and production. Red Hat OpenShift GitOps organizes the deployment process around the configuration repositories and makes them the central element. It always has at least two repositories:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Application repository with the source code</simpara>
</listitem>
<listitem>
<simpara>Environment configuration repository that defines the desired state of the application</simpara>
</listitem>
</orderedlist>
<simpara>These repositories contain a declarative description of the infrastructure you need in your specified environment. They also contain an automated process to make your environment match the described state.</simpara>
<simpara>Red Hat OpenShift GitOps uses Argo CD to maintain cluster resources. Argo CD is an open-source declarative tool for the continuous integration and continuous deployment (CI/CD) of applications. Red Hat OpenShift GitOps implements Argo CD as a controller so that it continuously monitors application definitions and configurations defined in a Git repository. Then, Argo CD compares the specified state of these configurations with their live state on the cluster.</simpara>
<simpara>Argo CD reports any configurations that deviate from their specified state. These reports allow administrators to automatically or manually resync configurations to the defined state. Therefore, Argo CD enables you to deliver global custom resources, like the resources that are used to configure {OCP} clusters.</simpara>
<section xml:id="key-features">
<title>Key features</title>
<simpara>Red Hat OpenShift GitOps helps you automate the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Ensure that the clusters have similar states for configuration, monitoring, and storage</simpara>
</listitem>
<listitem>
<simpara>Apply or revert configuration changes to multiple {OCP} clusters</simpara>
</listitem>
<listitem>
<simpara>Associate templated configuration with different environments</simpara>
</listitem>
<listitem>
<simpara>Promote applications across clusters, from staging to production</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_about-op-gitops" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/container-platform/latest/operators/understanding/crds/crd-extending-api-with-crds.html#crd-extending-api-with-crds">Extending the Kubernetes API with custom resource definitions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/container-platform/latest/operators/understanding/crds/crd-managing-resources-from-crds.html#crd-managing-resources-from-crds">Managing resources from custom resource definitions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/gitops/latest/understanding_openshift_gitops/what-is-gitops.html#what-is-gitops">What is GitOps?</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_jenkins">
<title>Jenkins</title>
<section xml:id="images-other-jenkins">
<title>Configuring Jenkins images</title>

<simpara>OpenShift Container Platform provides a container image for running Jenkins. This image provides a Jenkins server instance, which can be used to set up a basic flow for continuous testing, integration, and delivery.</simpara>
<simpara>The image is based on the Red Hat Universal Base ImagesÂ (UBI).</simpara>
<simpara>OpenShift Container Platform follows the <link xlink:href="https://jenkins.io/changelog-stable/">LTS</link> release of Jenkins. OpenShift Container Platform provides an image that contains Jenkins 2.x.</simpara>
<simpara>The OpenShift Container Platform Jenkins images are available on <link xlink:href="https://quay.io">Quay.io</link> or <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman pull registry.redhat.io/ocp-tools-4/jenkins-rhel8:&lt;image_tag&gt;</programlisting>
<simpara>To use these images, you can either access them directly from these registries or push them into your OpenShift Container Platform container image registry. Additionally, you can create an image stream that points to the image, either in your container image registry or at the external location. Your OpenShift Container Platform resources can then reference the image stream.</simpara>
<simpara>But for convenience, OpenShift Container Platform provides image streams in the <literal>openshift</literal> namespace for the core Jenkins image as well as the example Agent images provided for OpenShift Container Platform integration with Jenkins.</simpara>
<section xml:id="images-other-jenkins-config-customization_images-other-jenkins">
<title>Configuration and customization</title>
<simpara>You can manage Jenkins authentication in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform OAuth authentication provided by the OpenShift Container Platform Login plugin.</simpara>
</listitem>
<listitem>
<simpara>Standard authentication provided by Jenkins.</simpara>
</listitem>
</itemizedlist>
<section xml:id="images-other-jenkins-oauth-auth_images-other-jenkins">
<title>OpenShift Container Platform OAuth authentication</title>
<simpara>OAuth authentication is activated by configuring options on the <emphasis role="strong">Configure Global Security</emphasis> panel in the Jenkins UI, or by setting the <literal>OPENSHIFT_ENABLE_OAUTH</literal> environment variable on the Jenkins <emphasis role="strong">Deployment configuration</emphasis> to anything other than <literal>false</literal>. This activates the OpenShift Container Platform Login plugin, which retrieves the configuration information from pod data or by interacting with the OpenShift Container Platform API server.</simpara>
<simpara>Valid credentials are controlled by the OpenShift Container Platform identity provider.</simpara>
<simpara>Jenkins supports both browser and non-browser access.</simpara>
<simpara>Valid users are automatically added to the Jenkins authorization matrix at log in, where OpenShift Container Platform roles dictate the specific Jenkins permissions that users have. The roles used by default are the predefined <literal>admin</literal>, <literal>edit</literal>, and <literal>view</literal>. The login plugin executes self-SAR requests against those roles in the project or namespace that Jenkins is running in.</simpara>
<simpara>Users with the <literal>admin</literal> role have the traditional Jenkins administrative user permissions. Users with the <literal>edit</literal> or <literal>view</literal> role have progressively fewer permissions.</simpara>
<simpara>The default OpenShift Container Platform <literal>admin</literal>, <literal>edit</literal>, and <literal>view</literal> roles and the Jenkins permissions those roles are assigned in the Jenkins instance are configurable.</simpara>
<simpara>When running Jenkins in an OpenShift Container Platform pod, the login plugin looks for a config map named <literal>openshift-jenkins-login-plugin-config</literal> in the namespace that Jenkins is running in.</simpara>
<simpara>If this plugin finds and can read in that config map, you can define the role to Jenkins Permission mappings. Specifically:</simpara>
<itemizedlist>
<listitem>
<simpara>The login plugin treats the key and value pairs in the config map as Jenkins permission to OpenShift Container Platform role mappings.</simpara>
</listitem>
<listitem>
<simpara>The key is the Jenkins permission group short ID and the Jenkins permission short ID, with those two separated by a hyphen character.</simpara>
</listitem>
<listitem>
<simpara>If you want to add the <literal>Overall Jenkins Administer</literal> permission to an OpenShift Container Platform role, the key should be <literal>Overall-Administer</literal>.</simpara>
</listitem>
<listitem>
<simpara>To get a sense of which permission groups and permissions IDs are available, go to the matrix authorization page in the Jenkins console and IDs for the groups and individual permissions in the table they provide.</simpara>
</listitem>
<listitem>
<simpara>The value of the key and value pair is the list of OpenShift Container Platform roles the permission should apply to, with each role separated by a comma.</simpara>
</listitem>
<listitem>
<simpara>If you want to add the <literal>Overall Jenkins Administer</literal> permission to both the default <literal>admin</literal> and <literal>edit</literal> roles, as well as a new Jenkins role you have created, the value for the key <literal>Overall-Administer</literal> would be <literal>admin,edit,jenkins</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The <literal>admin</literal> user that is pre-populated in the OpenShift Container Platform Jenkins image with administrative privileges is not given those privileges when OpenShift Container Platform OAuth is used. To grant these permissions the OpenShift Container Platform cluster administrator must explicitly define that user in the OpenShift Container Platform identity provider and assigns the <literal>admin</literal> role to the user.</simpara>
</note>
<simpara>Jenkins users' permissions that are stored can be changed after the users are initially established. The OpenShift Container Platform Login plugin polls the OpenShift Container Platform API server for permissions and updates the permissions stored in Jenkins for each user with the permissions retrieved from OpenShift Container Platform. If the Jenkins UI is used to update permissions for a Jenkins user, the permission changes are overwritten the next time the plugin polls OpenShift Container Platform.</simpara>
<simpara>You can control how often the polling occurs with the <literal>OPENSHIFT_PERMISSIONS_POLL_INTERVAL</literal> environment variable. The default polling interval is five minutes.</simpara>
<simpara>The easiest way to create a new Jenkins service using OAuth authentication is to use a template.</simpara>
</section>
<section xml:id="images-other-jenkins-auth_images-other-jenkins">
<title>Jenkins authentication</title>
<simpara>Jenkins authentication is used by default if the image is run directly, without using a template.</simpara>
<simpara>The first time Jenkins starts, the configuration is created along with the administrator user and password. The default user credentials are <literal>admin</literal> and <literal>password</literal>. Configure the default password by setting the <literal>JENKINS_PASSWORD</literal> environment variable when using, and only when using, standard Jenkins authentication.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a Jenkins application that uses standard Jenkins authentication:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-app -e \
    JENKINS_PASSWORD=&lt;password&gt; \
    ocp-tools-4/jenkins-rhel8</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-other-jenkins-env-var_images-other-jenkins">
<title>Jenkins environment variables</title>
<simpara>The Jenkins server can be configured with the following environment variables:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Variable</entry>
<entry align="left" valign="top">Definition</entry>
<entry align="left" valign="top">Example values and settings</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_ENABLE_OAUTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines whether the OpenShift Container Platform Login plugin manages authentication when logging in to Jenkins. To enable, set to <literal>true</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JENKINS_PASSWORD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The password for the <literal>admin</literal> user when using standard Jenkins authentication. Not applicable when <literal>OPENSHIFT_ENABLE_OAUTH</literal> is set to <literal>true</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>password</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_MAX_HEAP_PARAM</literal>,
<literal>CONTAINER_HEAP_PERCENT</literal>,
<literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These values control the maximum heap size of the Jenkins JVM. If
<literal>JAVA_MAX_HEAP_PARAM</literal> is set, its value takes precedence. Otherwise, the maximum heap size is dynamically calculated as <literal>CONTAINER_HEAP_PERCENT</literal> of the container memory limit, optionally capped at <literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal> MiB.</simpara><simpara>By default, the maximum heap size of the Jenkins JVM is set to 50% of the container memory limit with no cap.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>JAVA_MAX_HEAP_PARAM</literal> example setting: <literal>-Xmx512m</literal></simpara><simpara><literal>CONTAINER_HEAP_PERCENT</literal> default: <literal>0.5</literal>, or 50%</simpara><simpara><literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal> example setting: <literal>512 MiB</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_INITIAL_HEAP_PARAM</literal>,
<literal>CONTAINER_INITIAL_PERCENT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These values control the initial heap size of the Jenkins JVM. If <literal>JAVA_INITIAL_HEAP_PARAM</literal> is set, its value takes precedence. Otherwise, the initial heap size is dynamically calculated as <literal>CONTAINER_INITIAL_PERCENT</literal> of the dynamically calculated maximum heap size.</simpara><simpara>By default, the JVM sets the initial heap size.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>JAVA_INITIAL_HEAP_PARAM</literal> example setting: <literal>-Xms32m</literal></simpara><simpara><literal>CONTAINER_INITIAL_PERCENT</literal> example setting: <literal>0.1</literal>, or 10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CONTAINER_CORE_LIMIT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If set, specifies an integer number of cores used for sizing numbers of internal JVM threads.</simpara></entry>
<entry align="left" valign="top"><simpara>Example setting: <literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_TOOL_OPTIONS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies options to apply to all JVMs running in this container. It is not recommended to override this value.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -Dsun.zip.disableMemoryMapping=true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_GC_OPTS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies Jenkins JVM garbage collection parameters. It is not recommended to override this value.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>-XX:+UseParallelGC -XX:MinHeapFreeRatio=5 -XX:MaxHeapFreeRatio=10 -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JENKINS_JAVA_OVERRIDES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies additional options for the Jenkins JVM. These options are appended to all other options, including the Java options above, and may be used to override any of them if necessary. Separate each additional option with a space; if any option contains space characters, escape them with a backslash.</simpara></entry>
<entry align="left" valign="top"><simpara>Example settings: <literal>-Dfoo -Dbar</literal>; <literal>-Dfoo=first\ value -Dbar=second\ value</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JENKINS_OPTS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies arguments to Jenkins.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>INSTALL_PLUGINS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies additional Jenkins plugins to install when the container is first run or when <literal>OVERRIDE_PV_PLUGINS_WITH_IMAGE_PLUGINS</literal> is set to <literal>true</literal>. Plugins are specified as a comma-delimited list of name:version pairs.</simpara></entry>
<entry align="left" valign="top"><simpara>Example setting: <literal>git:3.7.0,subversion:2.10.2</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OPENSHIFT_PERMISSIONS_POLL_INTERVAL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the interval in milliseconds that the OpenShift Container Platform Login plugin polls OpenShift Container Platform for the permissions that are associated with each user that is defined in Jenkins.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>300000</literal> - 5 minutes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OVERRIDE_PV_CONFIG_WITH_IMAGE_CONFIG</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When running this image with an OpenShift Container Platform persistent volume (PV) for the Jenkins configuration directory, the transfer of configuration from the image to the PV is performed only the first time the image starts because the PV is assigned when the persistent volume claim (PVC) is created. If you create a custom image that extends this image and updates the configuration in the custom image after the initial startup, the configuration is not copied over unless you set this environment variable to <literal>true</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OVERRIDE_PV_PLUGINS_WITH_IMAGE_PLUGINS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When running this image with an OpenShift Container Platform PV for the Jenkins configuration directory, the transfer of plugins from the image to the PV is performed only the first time the image starts because the PV is assigned when the PVC is created. If you create a custom image that extends this image and updates plugins in the custom image after the initial startup, the plugins are not copied over unless you set this environment variable to <literal>true</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ENABLE_FATAL_ERROR_LOG_FILE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When running this image with an OpenShift Container Platform PVC for the Jenkins configuration directory, this environment variable allows the fatal error log file to persist when a fatal error occurs. The fatal error file is saved at <literal>/var/lib/jenkins/logs</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AGENT_BASE_IMAGE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Setting this value overrides the image used for the <literal>jnlp</literal> container in the sample Kubernetes plugin pod templates provided with this image. Otherwise, the image from the <literal>jenkins-agent-base-rhel8:latest</literal> image stream tag in the <literal>openshift</literal> namespace is used.</simpara></entry>
<entry align="left" valign="top"><simpara>Default:
<literal>image-registry.openshift-image-registry.svc:5000/openshift/jenkins-agent-base-rhel8:latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_BUILDER_IMAGE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Setting this value overrides the image used for the <literal>java-builder</literal> container in the <literal>java-builder</literal> sample Kubernetes plugin pod templates provided with this image. Otherwise, the image from the <literal>java:latest</literal> image stream tag in the <literal>openshift</literal> namespace is used.</simpara></entry>
<entry align="left" valign="top"><simpara>Default:
<literal>image-registry.openshift-image-registry.svc:5000/openshift/java:latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_FIPS_OPTIONS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Setting this value controls how the JVM operates when running on a FIPS node. For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/openjdk/11/html-single/configuring_openjdk_11_on_rhel_with_fips/index#config-fips-in-openjdk">Configure OpenJDK 11 in FIPS mode</link>.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>-Dcom.redhat.fips=false</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="images-other-jenkins-cross-project_images-other-jenkins">
<title>Providing Jenkins cross project access</title>
<simpara>If you are going to run Jenkins somewhere other than your same project, you must provide an access token to Jenkins to access your project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Identify the secret for the service account that has appropriate permissions to access the project Jenkins must access:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe serviceaccount jenkins</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:       default
Labels:     &lt;none&gt;
Secrets:    {  jenkins-token-uyswp    }
            {  jenkins-dockercfg-xcr3d    }
Tokens:     jenkins-token-izv1u
            jenkins-token-uyswp</programlisting>
</para>
</formalpara>
<simpara>In this case the secret is named <literal>jenkins-token-uyswp</literal>.</simpara>
</listitem>
<listitem>
<simpara>Retrieve the token from the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe secret &lt;secret name from above&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:       jenkins-token-uyswp
Labels:     &lt;none&gt;
Annotations:    kubernetes.io/service-account.name=jenkins,kubernetes.io/service-account.uid=32f5b661-2a8f-11e5-9528-3c970e3bf0b7
Type:   kubernetes.io/service-account-token
Data
====
ca.crt: 1066 bytes
token:  eyJhbGc..&lt;content cut&gt;....wRA</programlisting>
</para>
</formalpara>
<simpara>The token parameter contains the token value Jenkins requires to access the project.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="images-other-jenkins-cross-volume-mount_images-other-jenkins">
<title>Jenkins cross volume mount points</title>
<simpara>The Jenkins image can be run with mounted volumes to enable persistent storage for the configuration:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/var/lib/jenkins</literal> is the data directory where Jenkins stores configuration files, including job definitions.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-other-jenkins-customize-s2i_images-other-jenkins">
<title>Customizing the Jenkins image through source-to-image</title>
<simpara>To customize the official OpenShift Container Platform Jenkins image, you can use the image as a source-to-image (S2I) builder.</simpara>
<simpara>You can use S2I to copy your custom Jenkins jobs definitions, add additional plugins, or replace the provided <literal>config.xml</literal> file with your own, custom, configuration.</simpara>
<simpara>To include your modifications in the Jenkins image, you must have a Git repository with the following directory structure:</simpara>
<variablelist>
<varlistentry>
<term><literal>plugins</literal></term>
<listitem>
<simpara>This directory contains those binary Jenkins plugins you want to copy into Jenkins.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>plugins.txt</literal></term>
<listitem>
<simpara>This file lists the plugins you want to install using the following syntax:</simpara>
</listitem>
</varlistentry>
</variablelist>
<screen>pluginId:pluginVersion</screen>
<variablelist>
<varlistentry>
<term><literal>configuration/jobs</literal></term>
<listitem>
<simpara>This directory contains the Jenkins job definitions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>configuration/config.xml</literal></term>
<listitem>
<simpara>This file contains your custom Jenkins configuration.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The contents of the <literal>configuration/</literal> directory is copied to the <literal>/var/lib/jenkins/</literal> directory, so you can also include additional files, such as <literal>credentials.xml</literal>, there.</simpara>
<formalpara>
<title>Sample build configuration customizes the Jenkins image in OpenShift Container Platform</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: custom-jenkins-build
spec:
  source:                       <co xml:id="CO34-1"/>
    git:
      uri: https://github.com/custom/repository
    type: Git
  strategy:                     <co xml:id="CO34-2"/>
    sourceStrategy:
      from:
        kind: ImageStreamTag
        name: jenkins:2
        namespace: openshift
    type: Source
  output:                       <co xml:id="CO34-3"/>
    to:
      kind: ImageStreamTag
      name: custom-jenkins:latest</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>The <literal>source</literal> parameter defines the source Git repository with the layout described above.</para>
</callout>
<callout arearefs="CO34-2">
<para>The <literal>strategy</literal> parameter defines the original Jenkins image to use as a source image for the build.</para>
</callout>
<callout arearefs="CO34-3">
<para>The <literal>output</literal> parameter defines the resulting, customized Jenkins image that you can use in deployment configurations instead of the official Jenkins image.</para>
</callout>
</calloutlist>
</section>
<section xml:id="images-other-jenkins-config-kubernetes_images-other-jenkins">
<title>Configuring the Jenkins Kubernetes plugin</title>
<simpara>The OpenShift Jenkins image includes the preinstalled <link xlink:href="https://wiki.jenkins-ci.org/display/JENKINS/Kubernetes+Plugin">Kubernetes plugin for Jenkins</link> so that Jenkins agents can be dynamically provisioned on multiple container hosts using Kubernetes and OpenShift Container Platform.</simpara>
<simpara>To use the Kubernetes plugin, OpenShift Container Platform provides an OpenShift Agent Base image that is suitable for use as a Jenkins agent.</simpara>
<important>
<simpara>OpenShift Container Platform 4.11 moves the OpenShift Jenkins and OpenShift Agent Base images to the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal> so that Red Hat can produce and update the images outside the OpenShift Container Platform lifecycle. Previously, these images were in the OpenShift Container Platform install payload and the <literal>openshift4</literal> repository at <literal>registry.redhat.io</literal>.</simpara>
<simpara>The OpenShift Jenkins Maven and NodeJS Agent images were removed from the OpenShift Container Platform 4.11 payload. Red Hat no longer produces these images, and they are not available from the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal>. Red Hat maintains the 4.10 and earlier versions of these images for any significant bug fixes or security CVEs, following the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift">OpenShift Container Platform lifecycle policy</link>.</simpara>
<simpara>For more information, see the "Important changes to OpenShift Jenkins images" link in the following "Additional resources" section.</simpara>
</important>
<simpara>The Maven and Node.js agent images are automatically configured as Kubernetes pod template images within the OpenShift Container Platform Jenkins image configuration for the Kubernetes plugin. That configuration includes labels for each image that you can apply to any of your Jenkins jobs under their <literal>Restrict where this project can be run</literal> setting. If the label is applied, jobs run under an OpenShift Container Platform pod running the respective agent image.</simpara>
<important>
<simpara>In OpenShift Container Platform 4.10 and later, the recommended pattern for running Jenkins agents using the Kubernetes plugin is to use pod templates with both <literal>jnlp</literal> and <literal>sidecar</literal> containers. The <literal>jnlp</literal> container uses the OpenShift Container Platform Jenkins Base agent image to facilitate launching a separate pod for your build. The <literal>sidecar</literal> container image has the tools needed to build in a particular language within the separate pod that was launched. Many container images from the Red Hat Container Catalog are referenced in the sample image streams in the <literal>openshift</literal> namespace. The OpenShift Container Platform Jenkins image has a pod template named <literal>java-build</literal> with sidecar containers that demonstrate this approach. This pod template uses the latest Java version provided by the <literal>java</literal> image stream in the <literal>openshift</literal> namespace.</simpara>
</important>
<simpara>The Jenkins image also provides auto-discovery and auto-configuration of additional agent images for the Kubernetes plugin.</simpara>
<simpara>With the OpenShift Container Platform sync plugin, on Jenkins startup, the Jenkins image searches within the project it is running, or the projects listed in the plugin&#8217;s configuration, for the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>Image streams with the <literal>role</literal>  label set to <literal>jenkins-agent</literal>.</simpara>
</listitem>
<listitem>
<simpara>Image stream tags with the <literal>role</literal> annotation set to <literal>jenkins-agent</literal>.</simpara>
</listitem>
<listitem>
<simpara>Config maps with the <literal>role</literal> label set to <literal>jenkins-agent</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>When the Jenkins image finds an image stream with the appropriate label, or an image stream tag with the appropriate annotation, it generates the corresponding Kubernetes plugin configuration. This way, you can assign your Jenkins jobs to run in a pod running the container image provided by the image stream.</simpara>
<simpara>The name and image references of the image stream, or image stream tag, are mapped to the name and image fields in the Kubernetes plugin pod template. You can control the label field of the Kubernetes plugin pod template by setting an annotation on the image stream, or image stream tag object, with the key <literal>agent-label</literal>. Otherwise, the name is used as the label.</simpara>
<note>
<simpara>Do not log in to the Jenkins console and change the pod template configuration. If you do so after the pod template is created, and the OpenShift Container Platform Sync plugin detects that the image associated with the image stream or image stream tag has changed, it replaces the pod template and overwrites those configuration changes. You cannot merge a new configuration with the existing configuration.</simpara>
<simpara>Consider the config map approach if you have more complex configuration needs.</simpara>
</note>
<simpara>When it finds a config map with the appropriate label, the Jenkins image assumes that any values in the key-value data payload of the config map contain Extensible Markup Language (XML) consistent with the configuration format for Jenkins and the Kubernetes plugin pod templates. One key advantage of config maps over image streams and image stream tags is that you can control all the Kubernetes plugin pod template parameters.</simpara>
<formalpara>
<title>Sample config map for <literal>jenkins-agent</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: jenkins-agent
  labels:
    role: jenkins-agent
data:
  template1: |-
    &lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;
      &lt;inheritFrom&gt;&lt;/inheritFrom&gt;
      &lt;name&gt;template1&lt;/name&gt;
      &lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;
      &lt;idleMinutes&gt;0&lt;/idleMinutes&gt;
      &lt;label&gt;template1&lt;/label&gt;
      &lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;
      &lt;nodeSelector&gt;&lt;/nodeSelector&gt;
      &lt;volumes/&gt;
      &lt;containers&gt;
        &lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
          &lt;name&gt;jnlp&lt;/name&gt;
          &lt;image&gt;openshift/jenkins-agent-maven-35-centos7:v3.10&lt;/image&gt;
          &lt;privileged&gt;false&lt;/privileged&gt;
          &lt;alwaysPullImage&gt;true&lt;/alwaysPullImage&gt;
          &lt;workingDir&gt;/tmp&lt;/workingDir&gt;
          &lt;command&gt;&lt;/command&gt;
          &lt;args&gt;${computer.jnlpmac} ${computer.name}&lt;/args&gt;
          &lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;
          &lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;
          &lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;
          &lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;
          &lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;
          &lt;envVars/&gt;
        &lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
      &lt;/containers&gt;
      &lt;envVars/&gt;
      &lt;annotations/&gt;
      &lt;imagePullSecrets/&gt;
      &lt;nodeProperties/&gt;
    &lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;</programlisting>
</para>
</formalpara>
<simpara>The following example shows two containers that reference image streams in the <literal>openshift</literal> namespace. One container handles the JNLP contract for launching Pods as Jenkins Agents. The other container uses an image with tools for building code in a particular coding language:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: jenkins-agent
  labels:
    role: jenkins-agent
data:
  template2: |-
        &lt;org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;
          &lt;inheritFrom&gt;&lt;/inheritFrom&gt;
          &lt;name&gt;template2&lt;/name&gt;
          &lt;instanceCap&gt;2147483647&lt;/instanceCap&gt;
          &lt;idleMinutes&gt;0&lt;/idleMinutes&gt;
          &lt;label&gt;template2&lt;/label&gt;
          &lt;serviceAccount&gt;jenkins&lt;/serviceAccount&gt;
          &lt;nodeSelector&gt;&lt;/nodeSelector&gt;
          &lt;volumes/&gt;
          &lt;containers&gt;
            &lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
              &lt;name&gt;jnlp&lt;/name&gt;
              &lt;image&gt;image-registry.openshift-image-registry.svc:5000/openshift/jenkins-agent-base-rhel8:latest&lt;/image&gt;
              &lt;privileged&gt;false&lt;/privileged&gt;
              &lt;alwaysPullImage&gt;true&lt;/alwaysPullImage&gt;
              &lt;workingDir&gt;/home/jenkins/agent&lt;/workingDir&gt;
              &lt;command&gt;&lt;/command&gt;
              &lt;args&gt;\$(JENKINS_SECRET) \$(JENKINS_NAME)&lt;/args&gt;
              &lt;ttyEnabled&gt;false&lt;/ttyEnabled&gt;
              &lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;
              &lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;
              &lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;
              &lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;
              &lt;envVars/&gt;
            &lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
            &lt;org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
              &lt;name&gt;java&lt;/name&gt;
              &lt;image&gt;image-registry.openshift-image-registry.svc:5000/openshift/java:latest&lt;/image&gt;
              &lt;privileged&gt;false&lt;/privileged&gt;
              &lt;alwaysPullImage&gt;true&lt;/alwaysPullImage&gt;
              &lt;workingDir&gt;/home/jenkins/agent&lt;/workingDir&gt;
              &lt;command&gt;cat&lt;/command&gt;
              &lt;args&gt;&lt;/args&gt;
              &lt;ttyEnabled&gt;true&lt;/ttyEnabled&gt;
              &lt;resourceRequestCpu&gt;&lt;/resourceRequestCpu&gt;
              &lt;resourceRequestMemory&gt;&lt;/resourceRequestMemory&gt;
              &lt;resourceLimitCpu&gt;&lt;/resourceLimitCpu&gt;
              &lt;resourceLimitMemory&gt;&lt;/resourceLimitMemory&gt;
              &lt;envVars/&gt;
            &lt;/org.csanchez.jenkins.plugins.kubernetes.ContainerTemplate&gt;
          &lt;/containers&gt;
          &lt;envVars/&gt;
          &lt;annotations/&gt;
          &lt;imagePullSecrets/&gt;
          &lt;nodeProperties/&gt;
        &lt;/org.csanchez.jenkins.plugins.kubernetes.PodTemplate&gt;</programlisting>
<note>
<simpara>Do not log in to the Jenkins console and change the pod template configuration. If you do so after the pod template is created, and the OpenShift Container Platform Sync plugin detects that the image associated with the image stream or image stream tag has changed, it replaces the pod template and overwrites those configuration changes. You cannot merge a new configuration with the existing configuration.</simpara>
<simpara>Consider the config map approach if you have more complex configuration needs.</simpara>
</note>
<simpara>After it is installed, the OpenShift Container Platform Sync plugin monitors the API server of OpenShift Container Platform for updates to image streams, image stream tags, and config maps and adjusts the configuration of the Kubernetes plugin.</simpara>
<simpara>The following rules apply:</simpara>
<itemizedlist>
<listitem>
<simpara>Removing the label or annotation from the config map, image stream, or image stream tag deletes any existing <literal>PodTemplate</literal> from the configuration of the Kubernetes plugin.</simpara>
</listitem>
<listitem>
<simpara>If those objects are removed, the corresponding configuration is removed from the Kubernetes plugin.</simpara>
</listitem>
<listitem>
<simpara>If you create appropriately labeled or annotated <literal>ConfigMap</literal>, <literal>ImageStream</literal>, or <literal>ImageStreamTag</literal> objects, or add labels after their initial creation, this results in the creation of a <literal>PodTemplate</literal> in the Kubernetes-plugin configuration.</simpara>
</listitem>
<listitem>
<simpara>In the case of the <literal>PodTemplate</literal> by config map form, changes to the config map data for the <literal>PodTemplate</literal> are applied to the <literal>PodTemplate</literal> settings in the Kubernetes plugin configuration. The changes also override any changes that were made to the <literal>PodTemplate</literal> through the Jenkins UI between changes to the config map.</simpara>
</listitem>
</itemizedlist>
<simpara>To use a container image as a Jenkins agent, the image must run the agent as an entry point. For more details, see the official <link xlink:href="https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds#Distributedbuilds-Launchslaveagentheadlessly">Jenkins documentation</link>.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../cicd/jenkins/important-changes-to-openshift-jenkins-images.xml#important-changes-to-openshift-jenkins-images">Important changes to OpenShift Jenkins images</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-other-jenkins-permissions_images-other-jenkins">
<title>Jenkins permissions</title>
<simpara>If in the config map the <literal>&lt;serviceAccount&gt;</literal> element of the pod template XML is the OpenShift Container Platform service account used for the resulting pod, the service account credentials are mounted into the pod. The permissions are associated with the service account and control which operations against the OpenShift Container Platform master are allowed from the pod.</simpara>
<simpara>Consider the following scenario with service accounts used for the pod, which is launched by the Kubernetes Plugin that runs in the OpenShift Container Platform Jenkins image.</simpara>
<simpara>If you use the example template for Jenkins that is provided by OpenShift Container Platform, the <literal>jenkins</literal> service account is defined with the <literal>edit</literal> role for the project Jenkins runs in, and the master Jenkins pod has that service account mounted.</simpara>
<simpara>The two default Maven and NodeJS pod templates that are injected into the Jenkins configuration are also set to use the same service account as the Jenkins master.</simpara>
<itemizedlist>
<listitem>
<simpara>Any pod templates that are automatically discovered by the OpenShift Container Platform sync plugin because their image streams or image stream tags have the required label or annotations are configured to use the Jenkins master service account as their service account.</simpara>
</listitem>
<listitem>
<simpara>For the other ways you can provide a pod template definition into Jenkins and the Kubernetes plugin, you have to explicitly specify the service account to use. Those other ways include the Jenkins console, the <literal>podTemplate</literal> pipeline DSL that is provided by the Kubernetes plugin, or labeling a config map whose data is the XML configuration for a pod template.</simpara>
</listitem>
<listitem>
<simpara>If you do not specify a value for the service account, the <literal>default</literal> service account is used.</simpara>
</listitem>
<listitem>
<simpara>Ensure that whatever service account is used has the necessary permissions, roles, and so on defined within OpenShift Container Platform to manipulate whatever projects you choose to manipulate from the within the pod.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-other-jenkins-create-service_images-other-jenkins">
<title>Creating a Jenkins service from a template</title>
<simpara>Templates provide parameter fields to define all the environment variables with predefined default values. OpenShift Container Platform provides templates to make creating a new Jenkins service easy. The Jenkins templates should be registered in the default <literal>openshift</literal> project by your cluster administrator during the initial cluster setup.</simpara>
<simpara>The two available templates both define deployment configuration and a service. The templates differ in their storage strategy, which affects whether the Jenkins content persists across a pod restart.</simpara>
<note>
<simpara>A pod might be restarted when it is moved to another node or when an update of the deployment configuration triggers a redeployment.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara><literal>jenkins-ephemeral</literal> uses ephemeral storage. On pod restart, all data is lost. This template is only useful for development or testing.</simpara>
</listitem>
<listitem>
<simpara><literal>jenkins-persistent</literal> uses a Persistent Volume (PV) store. Data survives a pod restart.</simpara>
</listitem>
</itemizedlist>
<simpara>To use a PV store, the cluster administrator must define a PV pool in the OpenShift Container Platform deployment.</simpara>
<simpara>After you select which template you want, you must instantiate the template to be able to use Jenkins.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new Jenkins application using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>A PV:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-app jenkins-persistent</programlisting>
</listitem>
<listitem>
<simpara>Or an <literal>emptyDir</literal> type volume where configuration does not persist across pod restarts:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-app jenkins-ephemeral</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>With both templates, you can run <literal>oc describe</literal> on them to see all the parameters available for overriding.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe jenkins-ephemeral</programlisting>
</section>
<section xml:id="images-other-jenkins-kubernetes-plugin_images-other-jenkins">
<title>Using the Jenkins Kubernetes plugin</title>
<simpara>In the following example, the <literal>openshift-jee-sample</literal> <literal>BuildConfig</literal> object causes a Jenkins Maven agent pod to be dynamically provisioned. The pod clones some Java source code, builds a WAR file, and causes a second <literal>BuildConfig</literal>, <literal>openshift-jee-sample-docker</literal> to run. The second <literal>BuildConfig</literal> layers the new WAR file into a container image.</simpara>
<important>
<simpara>OpenShift Container Platform 4.11 removed the OpenShift Jenkins Maven and NodeJS Agent images from its payload. Red Hat no longer produces these images, and they are not available from the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal>. Red Hat maintains the 4.10 and earlier versions of these images for any significant bug fixes or security CVEs, following the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift">OpenShift Container Platform lifecycle policy</link>.</simpara>
<simpara>For more information, see the "Important changes to OpenShift Jenkins images" link in the following "Additional resources" section.</simpara>
</important>
<formalpara>
<title>Sample <literal>BuildConfig</literal> that uses the Jenkins Kubernetes plugin</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: List
apiVersion: v1
items:
- kind: ImageStream
  apiVersion: image.openshift.io/v1
  metadata:
    name: openshift-jee-sample
- kind: BuildConfig
  apiVersion: build.openshift.io/v1
  metadata:
    name: openshift-jee-sample-docker
  spec:
    strategy:
      type: Docker
    source:
      type: Docker
      dockerfile: |-
        FROM openshift/wildfly-101-centos7:latest
        COPY ROOT.war /wildfly/standalone/deployments/ROOT.war
        CMD $STI_SCRIPTS_PATH/run
      binary:
        asFile: ROOT.war
    output:
      to:
        kind: ImageStreamTag
        name: openshift-jee-sample:latest
- kind: BuildConfig
  apiVersion: build.openshift.io/v1
  metadata:
    name: openshift-jee-sample
  spec:
    strategy:
      type: JenkinsPipeline
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          node("maven") {
            sh "git clone https://github.com/openshift/openshift-jee-sample.git ."
            sh "mvn -B -Popenshift package"
            sh "oc start-build -F openshift-jee-sample-docker --from-file=target/ROOT.war"
          }
    triggers:
    - type: ConfigChange</programlisting>
</para>
</formalpara>
<simpara>It is also possible to override the specification of the dynamically created Jenkins agent pod. The following is a modification to the preceding example, which overrides the container memory and specifies an environment variable.</simpara>
<formalpara>
<title>Sample <literal>BuildConfig</literal> that uses the Jenkins Kubernetes plugin, specifying memory limit and environment variable</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: BuildConfig
apiVersion: build.openshift.io/v1
metadata:
  name: openshift-jee-sample
spec:
  strategy:
    type: JenkinsPipeline
    jenkinsPipelineStrategy:
      jenkinsfile: |-
        podTemplate(label: "mypod", <co xml:id="CO35-1"/>
                    cloud: "openshift", <co xml:id="CO35-2"/>
                    inheritFrom: "maven", <co xml:id="CO35-3"/>
                    containers: [
            containerTemplate(name: "jnlp", <co xml:id="CO35-4"/>
                              image: "openshift/jenkins-agent-maven-35-centos7:v3.10", <co xml:id="CO35-5"/>
                              resourceRequestMemory: "512Mi", <co xml:id="CO35-6"/>
                              resourceLimitMemory: "512Mi", <co xml:id="CO35-7"/>
                              envVars: [
              envVar(key: "CONTAINER_HEAP_PERCENT", value: "0.25") <co xml:id="CO35-8"/>
            ])
          ]) {
          node("mypod") { <co xml:id="CO35-9"/>
            sh "git clone https://github.com/openshift/openshift-jee-sample.git ."
            sh "mvn -B -Popenshift package"
            sh "oc start-build -F openshift-jee-sample-docker --from-file=target/ROOT.war"
          }
        }
  triggers:
  - type: ConfigChange</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO35-1">
<para>A new pod template called <literal>mypod</literal> is defined dynamically. The new pod template name is referenced in the node stanza.</para>
</callout>
<callout arearefs="CO35-2">
<para>The <literal>cloud</literal> value must be set to <literal>openshift</literal>.</para>
</callout>
<callout arearefs="CO35-3">
<para>The new pod template can inherit its configuration from an existing pod template. In this case, inherited from the Maven pod template that is pre-defined by OpenShift Container Platform.</para>
</callout>
<callout arearefs="CO35-4">
<para>This example overrides values in the pre-existing container, and must be specified by name. All Jenkins agent images shipped with OpenShift Container Platform use the Container name <literal>jnlp</literal>.</para>
</callout>
<callout arearefs="CO35-5">
<para>Specify the container image name again. This is a known issue.</para>
</callout>
<callout arearefs="CO35-6">
<para>A memory request of <literal>512 Mi</literal> is specified.</para>
</callout>
<callout arearefs="CO35-7">
<para>A memory limit of <literal>512 Mi</literal> is specified.</para>
</callout>
<callout arearefs="CO35-8">
<para>An environment variable <literal>CONTAINER_HEAP_PERCENT</literal>, with value <literal>0.25</literal>, is specified.</para>
</callout>
<callout arearefs="CO35-9">
<para>The node stanza references the name of the defined pod template.</para>
</callout>
</calloutlist>
<simpara>By default, the pod is deleted when the build completes. This behavior can be modified with the plugin or within a pipeline Jenkinsfile.</simpara>
<simpara>Upstream Jenkins has more recently introduced a YAML declarative format for defining a <literal>podTemplate</literal> pipeline DSL in-line with your pipelines. An example of this format, using the sample <literal>java-builder</literal> pod template that is defined in the OpenShift Container Platform Jenkins image:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">def nodeLabel = 'java-buidler'

pipeline {
  agent {
    kubernetes {
      cloud 'openshift'
      label nodeLabel
      yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    worker: ${nodeLabel}
spec:
  containers:
  - name: jnlp
    image: image-registry.openshift-image-registry.svc:5000/openshift/jenkins-agent-base-rhel8:latest
    args: ['\$(JENKINS_SECRET)', '\$(JENKINS_NAME)']
  - name: java
    image: image-registry.openshift-image-registry.svc:5000/openshift/java:latest
    command:
    - cat
    tty: true
"""
    }
  }

  options {
    timeout(time: 20, unit: 'MINUTES')
  }

  stages {
    stage('Build App') {
      steps {
        container("java") {
          sh "mvn --version"
        }
     }
    }
  }
}</programlisting>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../cicd/jenkins/important-changes-to-openshift-jenkins-images.xml#important-changes-to-openshift-jenkins-images">Important changes to OpenShift Jenkins images</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-other-jenkins-memory_images-other-jenkins">
<title>Jenkins memory requirements</title>
<simpara>When deployed by the provided Jenkins Ephemeral or Jenkins Persistent templates, the default memory limit is <literal>1 Gi</literal>.</simpara>
<simpara>By default, all other process that run in the Jenkins container cannot use more than a total of <literal>512 MiB</literal> of memory. If they require more memory, the container halts. It is therefore highly recommended that pipelines run external commands in an agent container wherever possible.</simpara>
<simpara>And if <literal>Project</literal> quotas allow for it, see recommendations from the Jenkins documentation on what a Jenkins master should have from a memory perspective. Those recommendations proscribe to allocate even more memory for the Jenkins master.</simpara>
<simpara>It is recommended to specify memory request and limit values on agent containers created by the Jenkins Kubernetes plugin. Admin users can set default values on a per-agent image basis through the Jenkins configuration. The memory request and limit parameters can also be overridden on a per-container basis.</simpara>
<simpara>You can increase the amount of memory available to Jenkins by overriding the <literal>MEMORY_LIMIT</literal> parameter when instantiating the Jenkins Ephemeral or Jenkins Persistent template.</simpara>
</section>
<section xml:id="_additional_resources_3" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xlink:href="../../architecture/understanding-development.xml#base-image-options">Base image options</link> for more information about the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/getting_started_with_containers/index#using_red_hat_base_container_images_standard_and_minimal">Red Hat Universal Base Images</link>Â (UBI).</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/jenkins/important-changes-to-openshift-jenkins-images.xml#important-changes-to-openshift-jenkins-images">Important changes to OpenShift Jenkins images</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-other-jenkins-agent">
<title>Jenkins agent</title>

<simpara>OpenShift Container Platform provides a base image for use as a Jenkins agent.</simpara>
<simpara>The Base image for Jenkins agents does the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Pulls in both the required tools, headless Java, the Jenkins JNLP client, and the useful ones, including <literal>git</literal>, <literal>tar</literal>, <literal>zip</literal>, and <literal>nss</literal>, among others.</simpara>
</listitem>
<listitem>
<simpara>Establishes the JNLP agent as the entry point.</simpara>
</listitem>
<listitem>
<simpara>Includes the <literal>oc</literal> client tool for invoking command line operations from within Jenkins jobs.</simpara>
</listitem>
<listitem>
<simpara>Provides Dockerfiles for both Red Hat Enterprise Linux (RHEL) and <literal>localdev</literal> images.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Use a version of the agent image that is appropriate for your OpenShift Container Platform release version. Embedding an <literal>oc</literal> client version that is not compatible with the OpenShift Container Platform version can cause unexpected behavior.</simpara>
</important>
<simpara>The OpenShift Container Platform Jenkins image also defines the following sample <literal>java-builder</literal> pod template to illustrate how you can use the agent image with the Jenkins Kubernetes plugin.</simpara>
<simpara>The <literal>java-builder</literal> pod template employs two containers:
* A <literal>jnlp</literal> container that uses the OpenShift Container Platform Base agent image and handles the JNLP contract for starting and stopping Jenkins agents.
* A <literal>java</literal> container that uses the <literal>java</literal> OpenShift Container Platform Sample ImageStream, which contains the various Java binaries, including the Maven binary <literal>mvn</literal>, for building code.</simpara>
<section xml:id="images-other-jenkins-agent-images_images-other-jenkins-agent">
<title>Jenkins agent images</title>
<simpara>The OpenShift Container Platform Jenkins agent images are available on <link xlink:href="https://quay.io">Quay.io</link> or <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>.</simpara>
<simpara>Jenkins images are available through the Red Hat Registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker pull registry.redhat.io/ocp-tools-4/jenkins-rhel8:&lt;image_tag&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ docker pull registry.redhat.io/ocp-tools-4/jenkins-agent-base-rhel8:&lt;image_tag&gt;</programlisting>
<simpara>To use these images, you can either access them directly from <link xlink:href="https://quay.io">Quay.io</link> or <link xlink:href="https://registry.redhat.io">registry.redhat.io</link> or push them into your OpenShift Container Platform container image registry.</simpara>
</section>
<section xml:id="images-other-jenkins-agent-env-var_images-other-jenkins-agent">
<title>Jenkins agent environment variables</title>
<simpara>Each Jenkins agent container can be configured with the following environment variables.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Variable</entry>
<entry align="left" valign="top">Definition</entry>
<entry align="left" valign="top">Example values and settings</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_MAX_HEAP_PARAM</literal>,
<literal>CONTAINER_HEAP_PERCENT</literal>,
<literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These values control the maximum heap size of the Jenkins JVM. If <literal>JAVA_MAX_HEAP_PARAM</literal> is set, its value takes precedence. Otherwise, the maximum heap size is dynamically calculated as <literal>CONTAINER_HEAP_PERCENT</literal> of the container memory limit, optionally capped at <literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal> MiB.</simpara><simpara>By default, the maximum heap size of the Jenkins JVM is set to 50% of the container memory limit with no cap.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>JAVA_MAX_HEAP_PARAM</literal> example setting: <literal>-Xmx512m</literal></simpara><simpara><literal>CONTAINER_HEAP_PERCENT</literal> default: <literal>0.5</literal>, or 50%</simpara><simpara><literal>JENKINS_MAX_HEAP_UPPER_BOUND_MB</literal> example setting: <literal>512 MiB</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_INITIAL_HEAP_PARAM</literal>,
<literal>CONTAINER_INITIAL_PERCENT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These values control the initial heap size of the Jenkins JVM. If <literal>JAVA_INITIAL_HEAP_PARAM</literal> is set, its value takes precedence. Otherwise, the initial heap size is dynamically calculated as <literal>CONTAINER_INITIAL_PERCENT</literal> of the dynamically calculated maximum heap size.</simpara><simpara>By default, the JVM sets the initial heap size.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>JAVA_INITIAL_HEAP_PARAM</literal> example setting: <literal>-Xms32m</literal></simpara><simpara><literal>CONTAINER_INITIAL_PERCENT</literal> example setting: <literal>0.1</literal>, or 10%</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CONTAINER_CORE_LIMIT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If set, specifies an integer number of cores used for sizing numbers of internal
JVM threads.</simpara></entry>
<entry align="left" valign="top"><simpara>Example setting: <literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_TOOL_OPTIONS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies options to apply to all JVMs running in this container. It is not recommended to override this value.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -Dsun.zip.disableMemoryMapping=true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JAVA_GC_OPTS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies Jenkins JVM garbage collection parameters. It is not recommended to override this value.</simpara></entry>
<entry align="left" valign="top"><simpara>Default: <literal>-XX:+UseParallelGC -XX:MinHeapFreeRatio=5 -XX:MaxHeapFreeRatio=10 -XX:GCTimeRatio=4 -XX:AdaptiveSizePolicyWeight=90</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>JENKINS_JAVA_OVERRIDES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies additional options for the Jenkins JVM. These options are appended to all other options, including the Java options above, and can be used to override any of them, if necessary. Separate each additional option with a space and if any option contains space characters, escape them with a backslash.</simpara></entry>
<entry align="left" valign="top"><simpara>Example settings: <literal>-Dfoo -Dbar</literal>; <literal>-Dfoo=first\ value -Dbar=second\ value</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_JAVA_VERSION</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the version of Java version to use to run the agent in its container. The container base image has two versions of java installed: <literal>java-11</literal> and <literal>java-1.8.0</literal>. If you extend the container base image, you can specify any alternative version of java using its associated suffix.</simpara></entry>
<entry align="left" valign="top"><simpara>The default value is <literal>java-11</literal>.</simpara><simpara>Example setting: <literal>java-1.8.0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="images-other-jenkins-agent-memory_images-other-jenkins-agent">
<title>Jenkins agent memory requirements</title>
<simpara>A JVM is used in all Jenkins agents to host the Jenkins JNLP agent as well as to run any Java applications such as <literal>javac</literal>, Maven, or Gradle.</simpara>
<simpara>By default, the Jenkins JNLP agent JVM uses 50% of the container memory limit for its heap. This value can be modified by the <literal>CONTAINER_HEAP_PERCENT</literal> environment variable. It can also be capped at an upper limit or overridden entirely.</simpara>
<simpara>By default, any other processes run in the Jenkins agent container, such as shell scripts or <literal>oc</literal> commands run from pipelines, cannot use more than the remaining 50% memory limit without provoking an OOM kill.</simpara>
<simpara>By default, each further JVM process that runs in a Jenkins agent container uses up to 25% of the container memory limit for its heap. It might be necessary to tune this limit for many build workloads.</simpara>
</section>
<section xml:id="images-other-jenkins-agent-gradle_images-other-jenkins-agent">
<title>Jenkins agent Gradle builds</title>
<simpara>Hosting Gradle builds in the Jenkins agent on OpenShift Container Platform presents additional complications because in addition to the Jenkins JNLP agent and Gradle JVMs, Gradle spawns a third JVM to run tests if they are specified.</simpara>
<simpara>The following settings are suggested as a starting point for running Gradle builds in a memory constrained Jenkins agent on OpenShift Container Platform. You can modify these settings as required.</simpara>
<itemizedlist>
<listitem>
<simpara>Ensure the long-lived Gradle daemon is disabled by adding <literal>org.gradle.daemon=false</literal> to the <literal>gradle.properties</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Disable parallel build execution by ensuring <literal>org.gradle.parallel=true</literal> is not set in the <literal>gradle.properties</literal> file and that <literal>--parallel</literal> is not set as a command line argument.</simpara>
</listitem>
<listitem>
<simpara>To prevent Java compilations running out-of-process, set <literal>java { options.fork = false }</literal> in the <literal>build.gradle</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Disable multiple additional test processes by ensuring <literal>test { maxParallelForks = 1 }</literal> is set in the <literal>build.gradle</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Override the Gradle JVM memory parameters by the <literal>GRADLE_OPTS</literal>, <literal>JAVA_OPTS</literal> or <literal>JAVA_TOOL_OPTIONS</literal> environment variables.</simpara>
</listitem>
<listitem>
<simpara>Set the maximum heap size and JVM arguments for any Gradle test JVM by defining the <literal>maxHeapSize</literal> and <literal>jvmArgs</literal> settings in <literal>build.gradle</literal>, or through the <literal>-Dorg.gradle.jvmargs</literal> command line argument.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-other-jenkins-agent-pod-retention_images-other-jenkins-agent">
<title>Jenkins agent pod retention</title>
<simpara>Jenkins agent pods, are deleted by default after the build completes or is stopped. This behavior can be changed by the Kubernetes plugin pod retention setting. Pod retention can be set for all Jenkins builds, with overrides for each pod template. The following behaviors are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Always</literal> keeps the build pod regardless of build result.</simpara>
</listitem>
<listitem>
<simpara><literal>Default</literal> uses the plugin value, which is the pod template only.</simpara>
</listitem>
<listitem>
<simpara><literal>Never</literal> always deletes the pod.</simpara>
</listitem>
<listitem>
<simpara><literal>On Failure</literal> keeps the pod if it fails during the build.</simpara>
</listitem>
</itemizedlist>
<simpara>You can override pod retention in the pipeline Jenkinsfile:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">podTemplate(label: "mypod",
  cloud: "openshift",
  inheritFrom: "maven",
  podRetention: onFailure(), <co xml:id="CO36-1"/>
  containers: [
    ...
  ]) {
  node("mypod") {
    ...
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO36-1">
<para>Allowed values for <literal>podRetention</literal> are <literal>never()</literal>, <literal>onFailure()</literal>, <literal>always()</literal>, and <literal>default()</literal>.</para>
</callout>
</calloutlist>
<warning>
<simpara>Pods that are kept might continue to run and count against resource quotas.</simpara>
</warning>
</section>
</section>
<section xml:id="migrating-from-jenkins-to-openshift-pipelines_images-other-jenkins-agent">
<title>Migrating from Jenkins to OpenShift Pipelines or Tekton</title>

<simpara>You can migrate your CI/CD workflows from Jenkins to <link xlink:href="https://docs.openshift.com/pipelines/latest/about/understanding-openshift-pipelines.html">Red Hat OpenShift Pipelines</link>, a cloud-native CI/CD experience based on the Tekton project.</simpara>
<section xml:id="jt-comparison-of-jenkins-and-openshift-pipelines-concepts_migrating-from-jenkins-to-openshift-pipelines">
<title>Comparison of Jenkins and OpenShift Pipelines concepts</title>
<simpara>You can review and compare the following equivalent terms used in Jenkins and OpenShift Pipelines.</simpara>
<section xml:id="_jenkins_terminology">
<title>Jenkins terminology</title>
<simpara>Jenkins offers declarative and scripted pipelines that are extensible using shared libraries and plugins. Some basic terms in Jenkins are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Pipeline</emphasis>: Automates the entire process of building, testing, and deploying applications by using <link xlink:href="https://groovy-lang.org/">Groovy</link> syntax.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Node</emphasis>: A machine capable of either orchestrating or executing a scripted pipeline.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Stage</emphasis>: A conceptually distinct subset of tasks performed in a pipeline. Plugins or user interfaces often use this block to display the status or progress of tasks.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Step</emphasis>: A single task that specifies the exact action to be taken, either by using a command or a script.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_openshift_pipelines_terminology">
<title>OpenShift Pipelines terminology</title>
<simpara>OpenShift Pipelines uses <link xlink:href="https://yaml.org/">YAML</link> syntax for declarative pipelines and consists of tasks. Some basic terms in OpenShift Pipelines are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Pipeline</emphasis>: A set of tasks in a series, in parallel, or both.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Task</emphasis>: A sequence of steps as commands, binaries, or scripts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">PipelineRun</emphasis>: Execution of a pipeline with one or more tasks.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">TaskRun</emphasis>: Execution of a task with one or more steps.</simpara>
<note>
<simpara>You can initiate a PipelineRun or a TaskRun with a set of inputs such as parameters and workspaces, and the execution results in a set of outputs and artifacts.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">Workspace</emphasis>: In OpenShift Pipelines, workspaces are conceptual blocks that serve the following purposes:</simpara>
<itemizedlist>
<listitem>
<simpara>Storage of inputs, outputs, and build artifacts.</simpara>
</listitem>
<listitem>
<simpara>Common space to share data among tasks.</simpara>
</listitem>
<listitem>
<simpara>Mount points for credentials held in secrets, configurations held in config maps, and common tools shared by an organization.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>In Jenkins, there is no direct equivalent of OpenShift Pipelines workspaces. You can think of the control node as a workspace, as it stores the cloned code repository, build history, and artifacts. When a job is assigned to a different node, the cloned code and the generated artifacts are stored in that node, but the control node maintains the build history.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
<section xml:id="_mapping_of_concepts">
<title>Mapping of concepts</title>
<simpara>The building blocks of Jenkins and OpenShift Pipelines are not equivalent, and a specific comparison does not provide a technically accurate mapping. The following terms and concepts in Jenkins and OpenShift Pipelines correlate in general:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Jenkins and OpenShift Pipelines - basic comparison</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Jenkins</entry>
<entry align="left" valign="top">OpenShift Pipelines</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Pipeline</simpara></entry>
<entry align="left" valign="top"><simpara>Pipeline and PipelineRun</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Stage</simpara></entry>
<entry align="left" valign="top"><simpara>Task</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Step</simpara></entry>
<entry align="left" valign="top"><simpara>A step in a task</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="jt-migrating-a-sample-pipeline-from-jenkins-to-openshift-pipelines_migrating-from-jenkins-to-openshift-pipelines">
<title>Migrating a sample pipeline from Jenkins to OpenShift Pipelines</title>
<simpara>You can use the following equivalent examples to help migrate your build, test, and deploy pipelines from Jenkins to OpenShift Pipelines.</simpara>
<section xml:id="_jenkins_pipeline">
<title>Jenkins pipeline</title>
<simpara>Consider a Jenkins pipeline written in Groovy for building, testing, and deploying:</simpara>
<programlisting language="groovy" linenumbering="unnumbered">pipeline {
   agent any
   stages {
       stage('Build') {
           steps {
               sh 'make'
           }
       }
       stage('Test'){
           steps {
               sh 'make check'
               junit 'reports/**/*.xml'
           }
       }
       stage('Deploy') {
           steps {
               sh 'make publish'
           }
       }
   }
}</programlisting>
</section>
<section xml:id="_openshift_pipelines_pipeline">
<title>OpenShift Pipelines pipeline</title>
<simpara>To create a pipeline in OpenShift Pipelines that is equivalent to the preceding Jenkins pipeline, you create the following three tasks:</simpara>
<formalpara>
<title>Example <literal>build</literal> task YAML definition file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: myproject-build
spec:
  workspaces:
  - name: source
  steps:
  - image: my-ci-image
    command: ["make"]
    workingDir: $(workspaces.source.path)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>test</literal> task YAML definition file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: myproject-test
spec:
  workspaces:
  - name: source
  steps:
  - image: my-ci-image
    command: ["make check"]
    workingDir: $(workspaces.source.path)
  - image: junit-report-image
    script: |
      #!/usr/bin/env bash
      junit-report reports/**/*.xml
    workingDir: $(workspaces.source.path)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>deploy</literal> task YAML definition file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: myprojectd-deploy
spec:
  workspaces:
  - name: source
  steps:
  - image: my-deploy-image
    command: ["make deploy"]
    workingDir: $(workspaces.source.path)</programlisting>
</para>
</formalpara>
<simpara>You can combine the three tasks sequentially to form a pipeline in OpenShift Pipelines:</simpara>
<formalpara>
<title>Example: OpenShift Pipelines pipeline for building, testing, and deployment</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: myproject-pipeline
spec:
  workspaces:
  - name: shared-dir
  tasks:
  - name: build
    taskRef:
      name: myproject-build
    workspaces:
    - name: source
      workspace: shared-dir
  - name: test
    taskRef:
      name: myproject-test
    workspaces:
    - name: source
      workspace: shared-dir
  - name: deploy
    taskRef:
      name: myproject-deploy
    workspaces:
    - name: source
      workspace: shared-dir</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="jt-migrating-from-jenkins-plugins-to-openshift-pipelines-hub-tasks_migrating-from-jenkins-to-openshift-pipelines">
<title>Migrating from Jenkins plugins to Tekton Hub tasks</title>
<simpara>You can extend the capability of Jenkins by using <link xlink:href="https://plugins.jenkinsci.org">plugins</link>. To achieve similar extensibility in OpenShift Pipelines, use any of the tasks available from <link xlink:href="https://hub.tekton.dev">Tekton Hub</link>.</simpara>
<simpara>For example, consider the <link xlink:href="https://hub.tekton.dev/tekton/task/git-clone">git-clone</link> task in Tekton Hub, which corresponds to the <link xlink:href="https://plugins.jenkins.io/git/">git plugin</link> for Jenkins.</simpara>
<formalpara>
<title>Example: <literal>git-clone</literal> task from Tekton Hub</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
 name: demo-pipeline
spec:
 params:
   - name: repo_url
   - name: revision
 workspaces:
   - name: source
 tasks:
   - name: fetch-from-git
     taskRef:
       name: git-clone
     params:
       - name: url
         value: $(params.repo_url)
       - name: revision
         value: $(params.revision)
     workspaces:
     - name: output
       workspace: source</programlisting>
</para>
</formalpara>
</section>
<section xml:id="jt-extending-openshift-pipelines-capabilities-using-custom-tasks-and-scripts_migrating-from-jenkins-to-openshift-pipelines">
<title>Extending OpenShift Pipelines capabilities using custom tasks and scripts</title>
<simpara>In OpenShift Pipelines, if you do not find the right task in Tekton Hub, or need greater control over tasks, you can create custom tasks and scripts to extend the capabilities of OpenShift Pipelines.</simpara>
<formalpara>
<title>Example: A custom task for running the <literal>maven test</literal> command</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: maven-test
spec:
  workspaces:
  - name: source
  steps:
  - image: my-maven-image
    command: ["mvn test"]
    workingDir: $(workspaces.source.path)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example: Run a custom shell script by providing its path</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
steps:
  image: ubuntu
  script: |
      #!/usr/bin/env bash
      /workspace/my-script.sh
...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example: Run a custom Python script by writing it in the YAML file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
steps:
  image: python
  script: |
      #!/usr/bin/env python3
      print(â€œhello from python!â€)
...</programlisting>
</para>
</formalpara>
</section>
<section xml:id="jt-comparison-of-jenkins-openshift-pipelines-execution-models_migrating-from-jenkins-to-openshift-pipelines">
<title>Comparison of Jenkins and OpenShift Pipelines execution models</title>
<simpara>Jenkins and OpenShift Pipelines offer similar functions but are different in architecture and execution.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Comparison of execution models in Jenkins and OpenShift Pipelines</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Jenkins</entry>
<entry align="left" valign="top">OpenShift Pipelines</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Jenkins has a controller node. Jenkins runs pipelines and steps centrally, or orchestrates jobs running in other nodes.</simpara></entry>
<entry align="left" valign="top"><simpara>OpenShift Pipelines is serverless and distributed, and there is no central dependency for execution.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Containers are launched by the Jenkins controller node through the pipeline.</simpara></entry>
<entry align="left" valign="top"><simpara>OpenShift Pipelines adopts a 'container-first' approach, where every step runs as a container in a pod (equivalent to nodes in Jenkins).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Extensibility is achieved by using plugins.</simpara></entry>
<entry align="left" valign="top"><simpara>Extensibility is achieved by using tasks in Tekton Hub or by creating custom tasks and scripts.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="jt-examples-of-common-use-cases_migrating-from-jenkins-to-openshift-pipelines">
<title>Examples of common use cases</title>
<simpara>Both Jenkins and OpenShift Pipelines offer capabilities for common CI/CD use cases, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>Compiling, building, and deploying images using Apache Maven</simpara>
</listitem>
<listitem>
<simpara>Extending the core capabilities by using plugins</simpara>
</listitem>
<listitem>
<simpara>Reusing shareable libraries and custom scripts</simpara>
</listitem>
</itemizedlist>
<section xml:id="_running_a_maven_pipeline_in_jenkins_and_openshift_pipelines">
<title>Running a Maven pipeline in Jenkins and OpenShift Pipelines</title>
<simpara>You can use Maven in both Jenkins and OpenShift Pipelines workflows for compiling, building, and deploying images. To map your existing Jenkins workflow to OpenShift Pipelines, consider the following examples:</simpara>
<formalpara>
<title>Example: Compile and build an image and deploy it to OpenShift using Maven in Jenkins</title>
<para>
<programlisting language="groovy" linenumbering="unnumbered">#!/usr/bin/groovy
node('maven') {
    stage 'Checkout'
    checkout scm

    stage 'Build'
    sh 'cd helloworld &amp;&amp; mvn clean'
    sh 'cd helloworld &amp;&amp; mvn compile'

    stage 'Run Unit Tests'
    sh 'cd helloworld &amp;&amp; mvn test'

    stage 'Package'
    sh 'cd helloworld &amp;&amp; mvn package'

    stage 'Archive artifact'
    sh 'mkdir -p artifacts/deployments &amp;&amp; cp helloworld/target/*.war artifacts/deployments'
    archive 'helloworld/target/*.war'

    stage 'Create Image'
    sh 'oc login https://kubernetes.default -u admin -p admin --insecure-skip-tls-verify=true'
    sh 'oc new-project helloworldproject'
    sh 'oc project helloworldproject'
    sh 'oc process -f helloworld/jboss-eap70-binary-build.json | oc create -f -'
    sh 'oc start-build eap-helloworld-app --from-dir=artifacts/'

    stage 'Deploy'
    sh 'oc new-app helloworld/jboss-eap70-deploy.json' }</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example: Compile and build an image and deploy it to OpenShift using Maven in OpenShift Pipelines.</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: maven-pipeline
spec:
  workspaces:
    - name: shared-workspace
    - name: maven-settings
    - name: kubeconfig-dir
      optional: true
  params:
    - name: repo-url
    - name: revision
    - name: context-path
  tasks:
    - name: fetch-repo
      taskRef:
        name: git-clone
      workspaces:
        - name: output
          workspace: shared-workspace
      params:
        - name: url
          value: "$(params.repo-url)"
        - name: subdirectory
          value: ""
        - name: deleteExisting
          value: "true"
        - name: revision
          value: $(params.revision)
    - name: mvn-build
      taskRef:
        name: maven
      runAfter:
        - fetch-repo
      workspaces:
        - name: source
          workspace: shared-workspace
        - name: maven-settings
          workspace: maven-settings
      params:
        - name: CONTEXT_DIR
          value: "$(params.context-path)"
        - name: GOALS
          value: ["-DskipTests", "clean", "compile"]
    - name: mvn-tests
      taskRef:
        name: maven
      runAfter:
        - mvn-build
      workspaces:
        - name: source
          workspace: shared-workspace
        - name: maven-settings
          workspace: maven-settings
      params:
        - name: CONTEXT_DIR
          value: "$(params.context-path)"
        - name: GOALS
          value: ["test"]
    - name: mvn-package
      taskRef:
        name: maven
      runAfter:
        - mvn-tests
      workspaces:
        - name: source
          workspace: shared-workspace
        - name: maven-settings
          workspace: maven-settings
      params:
        - name: CONTEXT_DIR
          value: "$(params.context-path)"
        - name: GOALS
          value: ["package"]
    - name: create-image-and-deploy
      taskRef:
        name: openshift-client
      runAfter:
        - mvn-package
      workspaces:
        - name: manifest-dir
          workspace: shared-workspace
        - name: kubeconfig-dir
          workspace: kubeconfig-dir
      params:
        - name: SCRIPT
          value: |
            cd "$(params.context-path)"
            mkdir -p ./artifacts/deployments &amp;&amp; cp ./target/*.war ./artifacts/deployments
            oc new-project helloworldproject
            oc project helloworldproject
            oc process -f jboss-eap70-binary-build.json | oc create -f -
            oc start-build eap-helloworld-app --from-dir=artifacts/
            oc new-app jboss-eap70-deploy.json</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_extending_the_core_capabilities_of_jenkins_and_openshift_pipelines_by_using_plugins">
<title>Extending the core capabilities of Jenkins and OpenShift Pipelines by using plugins</title>
<simpara>Jenkins has the advantage of a large ecosystem of numerous plugins developed over the years by its extensive user base. You can search and browse the plugins in the <link xlink:href="https://plugins.jenkins.io/">Jenkins Plugin Index</link>.</simpara>
<simpara>OpenShift Pipelines also has many tasks developed and contributed by the community and enterprise users. A publicly available catalog of reusable OpenShift Pipelines tasks are available in the <link xlink:href="https://hub.tekton.dev/">Tekton Hub</link>.</simpara>
<simpara>In addition, OpenShift Pipelines incorporates many of the plugins of the Jenkins ecosystem within its core capabilities. For example, authorization is a critical function in both Jenkins and OpenShift Pipelines. While Jenkins ensures authorization using the <link xlink:href="https://plugins.jenkins.io/role-strategy/">Role-based Authorization Strategy</link> plugin, OpenShift Pipelines uses OpenShift&#8217;s built-in Role-based Access Control system.</simpara>
</section>
<section xml:id="_sharing_reusable_code_in_jenkins_and_openshift_pipelines">
<title>Sharing reusable code in Jenkins and OpenShift Pipelines</title>
<simpara>Jenkins <link xlink:href="https://www.jenkins.io/doc/book/pipeline/shared-libraries/">shared libraries</link> provide reusable code for parts of Jenkins pipelines. The libraries are shared between <link xlink:href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/">Jenkinsfiles</link> to create highly modular pipelines without code repetition.</simpara>
<simpara>Although there is no direct equivalent of Jenkins shared libraries in OpenShift Pipelines, you can achieve similar workflows by using tasks from the <link xlink:href="https://hub.tekton.dev/">Tekton Hub</link> in combination with custom tasks and scripts.</simpara>
</section>
</section>
<section xml:id="_additional_resources_4" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/pipelines/latest/about/understanding-openshift-pipelines.html">Understanding OpenShift Pipelines</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/using-rbac.xml#using-rbac">Role-based Access Control</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="important-changes-to-openshift-jenkins-images">
<title>Important changes to OpenShift Jenkins images</title>

<simpara>OpenShift Container Platform 4.11 moves the OpenShift Jenkins and OpenShift Agent Base images to the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal>. It also removes the OpenShift Jenkins Maven and NodeJS Agent images from its payload:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform 4.11 moves the OpenShift Jenkins and OpenShift Agent Base images to the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal> so that Red Hat can produce and update the images outside the OpenShift Container Platform lifecycle. Previously, these images were in the OpenShift Container Platform install payload and the <literal>openshift4</literal> repository at <literal>registry.redhat.io</literal>.</simpara>
</listitem>
<listitem>
<simpara>OpenShift Container Platform 4.10 deprecated the OpenShift Jenkins Maven and NodeJS Agent images. OpenShift Container Platform 4.11 removes these images from its payload. Red Hat no longer produces these images, and they are not available from the <literal>ocp-tools-4</literal> repository at <literal>registry.redhat.io</literal>. Red Hat maintains the 4.10 and earlier versions of these images for any significant bug fixes or security CVEs, following the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift">OpenShift Container Platform lifecycle policy</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>These changes support the OpenShift Container Platform 4.10 recommendation to use <link xlink:href="../../cicd/jenkins/images-other-jenkins.xml#images-other-jenkins-config-kubernetes_images-other-jenkins">multiple container Pod Templates with the Jenkins Kubernetes Plugin</link>.</simpara>
<section xml:id="relocation-of-openshift-jenkins-images_important-changes-to-openshift-jenkins-images">
<title>Relocation of OpenShift Jenkins images</title>
<simpara>OpenShift Container Platform 4.11 makes significant changes to the location and availability of specific OpenShift Jenkins images. Additionally, you can configure when and how to update these images.</simpara>
<itemizedlist>
<title>What stays the same with the OpenShift Jenkins images?</title>
<listitem>
<simpara>The Cluster Samples Operator manages the <literal>ImageStream</literal> and <literal>Template</literal> objects for operating the OpenShift Jenkins images.</simpara>
</listitem>
<listitem>
<simpara>By default, the Jenkins <literal>DeploymentConfig</literal> object from the Jenkins pod template triggers a redeployment when the Jenkins image changes. By default, this image is referenced by the <literal>jenkins:2</literal> image stream tag of Jenkins image stream in the <literal>openshift</literal> namespace in the <literal>ImageStream</literal> YAML file in the Samples Operator payload.</simpara>
</listitem>
<listitem>
<simpara>If you upgrade from OpenShift Container Platform 4.10 and earlier to 4.11, the deprecated <literal>maven</literal> and <literal>nodejs</literal> pod templates are still in the default image configuration.</simpara>
</listitem>
<listitem>
<simpara>If you upgrade from OpenShift Container Platform 4.10 and earlier to 4.11, the <literal>jenkins-agent-maven</literal> and <literal>jenkins-agent-nodejs</literal> image streams still exist in your cluster. To maintain these image streams, see the following section, "What happens with the <literal>jenkins-agent-maven</literal> and <literal>jenkins-agent-nodejs</literal> image streams in the <literal>openshift</literal> namespace?"</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>What changes in the support matrix of the OpenShift Jenkins image?</title>
<para>Each new image in the <literal>ocp-tools-4</literal> repository in the <literal>registry.redhat.io</literal> registry supports multiple versions of OpenShift Container Platform. When Red Hat updates one of these new images, it is simultaneously available for all versions. This availability is ideal when Red Hat updates an image in response to a security advisory. Initially, this change applies to OpenShift Container Platform 4.11 and later. It is planned that this change will eventually apply to OpenShift Container Platform 4.9 and later.</para>
</formalpara>
<simpara>Previously, each Jenkins image supported only one version of OpenShift Container Platform and Red Hat might update those images sequentially over time.</simpara>
<formalpara>
<title>What additions are there with the OpenShift Jenkins and Jenkins Agent Base ImageStream and ImageStreamTag objects?</title>
<para>By moving from an in-payload image stream to an image stream that references non-payload images, OpenShift Container Platform can define additional image stream tags. Red Hat has created a series of new image stream tags to go along with the existing <literal>"value": "jenkins:2"</literal> and <literal>"value": "image-registry.openshift-image-registry.svc:5000/openshift/jenkins-agent-base-rhel8:latest"</literal> image stream tags present in OpenShift Container Platform 4.10 and earlier. These new image stream tags address some requests to improve how the Jenkins-related image streams are maintained.</para>
</formalpara>
<simpara>About the new image stream tags:</simpara>
<variablelist>
<varlistentry>
<term><literal>ocp-upgrade-redeploy</literal></term>
<listitem>
<simpara>To update your Jenkins image when you upgrade OpenShift Container Platform, use this image stream tag in your Jenkins deployment configuration. This image stream tag corresponds to the existing <literal>2</literal> image stream tag of the <literal>jenkins</literal> image stream and the <literal>latest</literal> image stream tag of the <literal>jenkins-agent-base-rhel8</literal> image stream. It employs an image tag specific to only one SHA or image digest. When the <literal>ocp-tools-4</literal> image changes, such as for Jenkins security advisories, Red Hat Engineering updates the Cluster Samples Operator payload.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>user-maintained-upgrade-redeploy</literal></term>
<listitem>
<simpara>To manually redeploy Jenkins after you upgrade OpenShift Container Platform, use this image stream tag in your Jenkins deployment configuration. This image stream tag uses the least specific image version indicator available. When you redeploy Jenkins, run the following command: <literal>$ oc import-image jenkins:user-maintained-upgrade-redeploy -n openshift</literal>. When you issue this command, the OpenShift Container Platform <literal>ImageStream</literal> controller accesses the <literal>registry.redhat.io</literal> image registry and stores any updated images in the OpenShift image registry&#8217;s slot for that Jenkins <literal>ImageStreamTag</literal> object. Otherwise, if you do not run this command, your Jenkins deployment configuration does not trigger a redeployment.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>scheduled-upgrade-redeploy</literal></term>
<listitem>
<simpara>To automatically redeploy the latest version of the Jenkins image when it is released, use this image stream tag in your Jenkins deployment configuration. This image stream tag uses the periodic importing of image stream tags feature of the OpenShift Container Platform image stream controller, which checks for changes in the backing image. If the image changes, for example, due to a recent Jenkins security advisory, OpenShift Container Platform triggers a redeployment of your Jenkins deployment configuration. See "Configuring periodic importing of image stream tags" in the following "Additional resources."</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>What happens with the <literal>jenkins-agent-maven</literal> and <literal>jenkins-agent-nodejs</literal> image streams in the <literal>openshift</literal> namespace?</title>
<para>The OpenShift Jenkins Maven and NodeJS Agent images for OpenShift Container Platform were deprecated in 4.10, and are removed from the OpenShift Container Platform install payload in 4.11. They do not have alternatives defined in the <literal>ocp-tools-4</literal> repository. However, you can work around this by using the sidecar pattern described in the "Jenkins agent" topic mentioned in the following "Additional resources" section.</para>
</formalpara>
<simpara>However, the Cluster Samples Operator does not delete the <literal>jenkins-agent-maven</literal> and <literal>jenkins-agent-nodejs</literal> image streams created by prior releases, which point to the tags of the respective OpenShift Container Platform payload images on <literal>registry.redhat.io</literal>. Therefore, you can pull updates to these images by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image jenkins-agent-nodejs -n openshift</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image jenkins-agent-maven -n openshift</programlisting>
</section>
<section xml:id="customizing-the-jenkins-image-stream-tag_important-changes-to-openshift-jenkins-images">
<title>Customizing the Jenkins image stream tag</title>
<simpara>To override the default upgrade behavior and control how the Jenkins image is upgraded, you set the image stream tag value that your Jenkins deployment configurations use.</simpara>
<simpara>The default upgrade behavior is the behavior that existed when the Jenkins image was part of the install payload. The image stream tag names, <literal>2</literal> and <literal>ocp-upgrade-redeploy</literal>, in the <literal>jenkins-rhel.json</literal> image stream file use SHA-specific image references. Therefore, when those tags are updated with a new SHA, the OpenShift Container Platform image change controller automatically redeploys the Jenkins deployment configuration from the associated templates, such as <literal>jenkins-ephemeral.json</literal> or <literal>jenkins-persistent.json</literal>.</simpara>
<simpara>For new deployments, to override that default value, you change the value of the  <literal>JENKINS_IMAGE_STREAM_TAG</literal> in the <literal>jenkins-ephemeral.json</literal> Jenkins template. For example, replace the <literal>2</literal> in <literal>"value": "jenkins:2"</literal> with one of the following image stream tags:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ocp-upgrade-redeploy</literal>, the default value, updates your Jenkins image when you upgrade OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara><literal>user-maintained-upgrade-redeploy</literal> requires you to manually redeploy Jenkins by running <literal>$ oc import-image jenkins:user-maintained-upgrade-redeploy -n openshift</literal> after upgrading OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara><literal>scheduled-upgrade-redeploy</literal> periodically checks the given <literal>&lt;image&gt;:&lt;tag&gt;</literal> combination for changes and upgrades the image when it changes. The image change controller pulls the changed image and redeploys the Jenkins deployment configuration provisioned by the templates. For more information about this scheduled import policy, see the "Adding tags to image streams" in the following "Additional resources."</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>To override the current upgrade value for existing deployments, change the values of the environment variables that correspond to those template parameters.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are running OpenShift Jenkins on OpenShift Container Platform 4.14.</simpara>
</listitem>
<listitem>
<simpara>You know the namespace where OpenShift Jenkins is deployed.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the image stream tag value, replacing <literal>&lt;namespace&gt;</literal> with namespace where OpenShift Jenkins is deployed and <literal>&lt;image_stream_tag&gt;</literal> with an image stream tag:</simpara>
<formalpara>
<title>Example</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch dc jenkins -p '{"spec":{"triggers":[{"type":"ImageChange","imageChangeParams":{"automatic":true,"containerNames":["jenkins"],"from":{"kind":"ImageStreamTag","namespace":"&lt;namespace&gt;","name":"jenkins:&lt;image_stream_tag&gt;"}}}]}}'</programlisting>
</para>
</formalpara>
<tip>
<simpara>Alternatively, to edit the Jenkins deployment configuration YAML, enter <literal>$ oc edit dc/jenkins -n &lt;namespace&gt;</literal> and update the <literal>value: 'jenkins:&lt;image_stream_tag&gt;'</literal> line.</simpara>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_important-changes-to-openshift-jenkins-images_important-changes-to-openshift-jenkins-images" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../openshift_images/managing_images/tagging-images.xml#images-add-tags-to-imagestreams_tagging-images">Adding tags to image streams</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../openshift_images/image-streams-manage.xml#images-imagestream-import_image-streams-managing">Configuring periodic importing of image stream tags</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/jenkins/images-other-jenkins-agent.xml#images-other-jenkins-agent">Jenkins agent</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://catalog.redhat.com/software/containers/search?q=Jenkins%202&amp;p=1">Certified <literal>jenkins</literal> images</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://catalog.redhat.com/software/containers/search?q=Jenkins%20Agent%20Base&amp;p=1">Certified <literal>jenkins-agent-base</literal> images</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://catalog.redhat.com/software/containers/search?q=jenkins-agent-maven&amp;p=1">Certified <literal>jenkins-agent-maven</literal> images</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://catalog.redhat.com/software/containers/search?q=jenkins-agent-nodejs&amp;p=1">Certified <literal>jenkins-agent-nodejs</literal> images</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
</book>