<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Service Mesh</title>
<date>2024-02-20</date>
</info>
<chapter xml:id="_service_mesh_2_x">
<title>Service Mesh 2.x</title>
<section xml:id="ossm-about">
<title>About OpenShift Service Mesh</title>

<note>
<simpara>Because Red Hat OpenShift Service Mesh releases on a different cadence from OpenShift Container Platform and because the Red Hat OpenShift Service Mesh Operator supports deploying multiple versions of the <literal>ServiceMeshControlPlane</literal>, the Service Mesh documentation does not maintain separate documentation sets for minor versions of the product.  The current documentation set applies to the most recent version of Service Mesh unless version-specific limitations are called out in a particular topic or for a particular feature.</simpara>
<simpara>For additional information about the Red Hat OpenShift Service Mesh life cycle and supported platforms, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Platform Life Cycle Policy</link>.</simpara>
</note>
<section xml:id="ossm-servicemesh-overview_ossm-about">
<title>Introduction to Red Hat OpenShift Service Mesh</title>
<simpara>Red Hat OpenShift Service Mesh addresses a variety of problems in a microservice architecture by creating a centralized point of control in an application. It adds a transparent layer on existing distributed applications without requiring any changes to the application code.</simpara>
<simpara>Microservice architectures split the work of enterprise applications into modular services, which can make scaling and maintenance easier. However, as an enterprise application built on a microservice architecture grows in size and complexity, it becomes difficult to understand and manage. Service Mesh can address those architecture problems by capturing or intercepting traffic between services and can modify, redirect, or create new requests to other services.</simpara>
<simpara>Service Mesh, which is based on the open source <link xlink:href="https://istio.io/">Istio project</link>, provides an easy way to create a network of deployed services that provides discovery, load balancing, service-to-service authentication, failure recovery, metrics, and monitoring. A service mesh also provides more complex operational functionality, including A/B testing, canary releases, access control, and end-to-end authentication.</simpara>
</section>
<section xml:id="ossm-core-features_ossm-about">
<title>Core features</title>
<simpara>Red Hat OpenShift Service Mesh provides a number of key capabilities uniformly across a network of services:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Traffic Management</emphasis> - Control the flow of traffic and API calls between services, make calls more reliable, and make the network more robust in the face of adverse conditions.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Service Identity and Security</emphasis> - Provide services in the mesh with a verifiable identity and provide the ability to protect service traffic as it flows over networks of varying degrees of trustworthiness.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Policy Enforcement</emphasis> - Apply organizational policy to the interaction between services, ensure access policies are enforced and resources are fairly distributed among consumers. Policy changes are made by configuring the mesh, not by changing application code.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Telemetry</emphasis> - Gain understanding of the dependencies between services and the nature and flow of traffic between them, providing the ability to quickly identify issues.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="service-mesh-release-notes">
<title>Service Mesh Release Notes</title>

<section xml:id="making-open-source-more-inclusive_ossm-release-notes">
<title>Making open source more inclusive</title>
<simpara>Red Hat is committed to replacing problematic language in our code, documentation, and web properties. We are beginning with these four terms: master, slave, blacklist, and whitelist. Because of the enormity of this endeavor, these changes will be implemented gradually over several upcoming releases. For more details, see <link xlink:href="https://www.redhat.com/en/blog/making-open-source-more-inclusive-eradicating-problematic-language">our CTO Chris Wright&#8217;s message</link>.</simpara>
</section>
<section xml:id="ossm-rn-new-features_ossm-release-notes">
<title>New features and enhancements</title>
<simpara>This release adds improvements related to the following components and concepts.</simpara>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4_5">
<title>New features Red Hat OpenShift Service Mesh version 2.4.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4_5">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4.5</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.11</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4_4">
<title>New features Red Hat OpenShift Service Mesh version 2.4.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4_4">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4.4</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4_3">
<title>New features Red Hat OpenShift Service Mesh version 2.4.3</title>
<itemizedlist>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator is now available on ARM-based clusters as a Technology Preview feature.</simpara>
</listitem>
<listitem>
<simpara>The <literal>envoyExtAuthzGrpc</literal> field has been added, which is used to configure an external authorization provider using the gRPC API.</simpara>
</listitem>
<listitem>
<simpara>Common Vulnerabilities and Exposures (CVEs) have been addressed.</simpara>
</listitem>
<listitem>
<simpara>This release is supported on OpenShift Container Platform 4.10 and newer versions.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4_3">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4.3</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_red_hat_openshift_service_mesh_operator_to_arm_based_clusters">
<title>Red Hat OpenShift Service Mesh operator to ARM-based clusters</title>
<important>
<simpara>Red Hat OpenShift Service Mesh operator to ARM based clusters is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>This release makes the Red Hat OpenShift Service Mesh Operator available on ARM-based clusters as a Technology Preview feature. Images are available for Istio, Envoy, Prometheus, Kiali, and Grafana. Images are not available for Jaeger, so Jaeger must be disabled as a Service Mesh add-on.</simpara>
</section>
<section xml:id="_remote_procedure_calls_grpc_api_support_for_external_authorization_configuration">
<title>Remote Procedure Calls (gRPC) API support for external authorization configuration</title>
<simpara>This enhancement adds the <literal>envoyExtAuthzGrpc</literal> field to configure an external authorization provider using the gRPC API.</simpara>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4_2">
<title>New features Red Hat OpenShift Service Mesh version 2.4.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4_1">
<title>New features Red Hat OpenShift Service Mesh version 2.4.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_4">
<title>New features Red Hat OpenShift Service Mesh version 2.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_4">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.4</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.16.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.65.6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_cluster_wide_deployments">
<title>Cluster-wide deployments</title>
<simpara>This enhancement introduces a generally available version of cluster-wide deployments. A cluster-wide deployment contains a service mesh control plane that monitors resources for an entire cluster. The control plane uses a single query across all namespaces to monitor each Istio or Kubernetes resource that affects the mesh configuration. Reducing the number of queries the control plane performs in a cluster-wide deployment improves performance.</simpara>
</section>
<section xml:id="_support_for_discovery_selectors">
<title>Support for discovery selectors</title>
<simpara>This enhancement introduces a generally available version of the <literal>meshConfig.discoverySelectors</literal> field, which can be used in cluster-wide deployments to limit the services the service mesh control plane can discover.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  meshConfig
    discoverySelectors:
    - matchLabels:
        env: prod
        region: us-east1
    - matchExpressions:
      - key: app
        operator: In
        values:
          - cassandra
          - spark</programlisting>
</section>
<section xml:id="_integration_with_cert_manager_istio_csr">
<title>Integration with cert-manager istio-csr</title>
<simpara>With this update, Red Hat OpenShift Service Mesh integrates with the <literal>cert-manager</literal> controller and the <literal>istio-csr</literal> agent. <literal>cert-manager</literal> adds certificates and certificate issuers as resource types in Kubernetes clusters, and simplifies the process of obtaining, renewing, and using those certificates. <literal>cert-manager</literal> provides and rotates an intermediate CA certificate for Istio. Integration with <literal>istio-csr</literal> enables users to delegate signing certificate requests from Istio proxies to <literal>cert-manager</literal>. <literal>ServiceMeshControlPlane</literal> v2.4 accepts CA certificates provided by <literal>cert-manager</literal> as <literal>cacerts</literal> secret.</simpara>
<note>
<simpara>Integration with <literal>cert-manager</literal> and <literal>istio-csr</literal> is not supported on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</note>
</section>
<section xml:id="_integration_with_external_authorization_systems">
<title>Integration with external authorization systems</title>
<simpara>This enhancement introduces a generally available method of integrating Red Hat OpenShift Service Mesh with external authorization systems by using the <literal>action: CUSTOM</literal> field of the <literal>AuthorizationPolicy</literal> resource. Use the <literal>envoyExtAuthzHttp</literal> field to delegate the access control to an external authorization system.</simpara>
</section>
<section xml:id="_integration_with_external_prometheus_installation">
<title>Integration with external Prometheus installation</title>
<simpara>This enhancement introduces a generally available version of the Prometheus extension provider. You can expose metrics to the OpenShift Container Platform monitoring stack or a custom Prometheus installation by setting the value of the <literal>extensionProviders</literal> field to <literal>prometheus</literal> in the <literal>spec.meshConfig</literal> specification. The telemetry object configures Istio proxies to collect traffic metrics. Service Mesh only supports the Telemetry API for Prometheus metrics.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  meshConfig:
    extensionProviders:
    - name: prometheus
      prometheus: {}
---
apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: enable-prometheus-metrics
spec:
  metrics:
  - providers:
    - name: prometheus</programlisting>
</section>
<section xml:id="_single_stack_ipv6_support">
<title>Single stack IPv6 support</title>
<simpara>This enhancement introduces generally available support for single stack IPv6 clusters, providing access to a broader range of IP addresses. Dual stack IPv4 or IPv6 cluster is not supported.</simpara>
<note>
<simpara>Single stack IPv6 support is not available on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</note>
</section>
<section xml:id="_openshift_container_platform_gateway_api_support">
<title>OpenShift Container Platform Gateway API support</title>
<important>
<simpara>OpenShift Container Platform Gateway API support is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>This enhancement introduces an updated Technology Preview version of the OpenShift Container Platform Gateway API. By default, the OpenShift Container Platform Gateway API is disabled.</simpara>
<section xml:id="_enabling_openshift_container_platform_gateway_api">
<title>Enabling OpenShift Container Platform Gateway API</title>
<simpara>To enable the OpenShift Container Platform Gateway API, set the value of the <literal>enabled</literal> field to <literal>true</literal> in the <literal>techPreview.gatewayAPI</literal> specification of the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  techPreview:
    gatewayAPI:
      enabled: true</programlisting>
<simpara>Previously, environment variables were used to enable the Gateway API.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        container:
          env:
            PILOT_ENABLE_GATEWAY_API: "true"
            PILOT_ENABLE_GATEWAY_API_STATUS: "true"
            PILOT_ENABLE_GATEWAY_API_DEPLOYMENT_CONTROLLER: "true"</programlisting>
</section>
</section>
<section xml:id="_control_plane_deployment_on_infrastructure_nodes">
<title>Control plane deployment on infrastructure nodes</title>
<simpara>Service Mesh control plane deployment is now supported and documented on OpenShift infrastructure nodes. For more information, see the following documentation:</simpara>
<itemizedlist>
<listitem>
<simpara>Configuring all Service Mesh control plane components to run on infrastructure nodes</simpara>
</listitem>
<listitem>
<simpara>Configuring individual Service Mesh control plane components to run on infrastructure nodes</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_istio_1_16_support">
<title>Istio 1.16 support</title>
<simpara>Service Mesh 2.4 is based on Istio 1.16, which brings in new features and product enhancements. While many Istio 1.16 features are supported, the following exceptions should be noted:</simpara>
<itemizedlist>
<listitem>
<simpara>HBONE protocol for sidecars is an experimental feature that is not supported.</simpara>
</listitem>
<listitem>
<simpara>Service Mesh on ARM64 architecture is not supported.</simpara>
</listitem>
<listitem>
<simpara>OpenTelemetry API remains a Technology Preview feature.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_9">
<title>New features Red Hat OpenShift Service Mesh version 2.3.9</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_9">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.9</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.14</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_8">
<title>New features Red Hat OpenShift Service Mesh version 2.3.8</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_8">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.8</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.13</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_7">
<title>New features Red Hat OpenShift Service Mesh version 2.3.7</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_7">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.7</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.11</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_6">
<title>New features Red Hat OpenShift Service Mesh version 2.3.6</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_6">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.6</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_5">
<title>New features Red Hat OpenShift Service Mesh version 2.3.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_5">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.5</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_4">
<title>New features Red Hat OpenShift Service Mesh version 2.3.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_4">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.4</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.9</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_3">
<title>New features Red Hat OpenShift Service Mesh version 2.3.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_3">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.3</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_2">
<title>New features Red Hat OpenShift Service Mesh version 2.3.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3_1">
<title>New features Red Hat OpenShift Service Mesh version 2.3.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh introduces new features, addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_3">
<title>New features Red Hat OpenShift Service Mesh version 2.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh introduces new features, addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_3">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.3</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.22.4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.57.3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_new_container_network_interface_cni_daemonset_container_and_configmap">
<title>New Container Network Interface (CNI) DaemonSet container and ConfigMap</title>
<simpara>The <literal>openshift-operators</literal> namespace includes a new istio CNI DaemonSet <literal>istio-cni-node-v2-3</literal> and a new <literal>ConfigMap</literal> resource, <literal>istio-cni-config-v2-3</literal>.</simpara>
<simpara>When upgrading to Service Mesh Control Plane 2.3, the existing <literal>istio-cni-node</literal> DaemonSet is not changed, and a new <literal>istio-cni-node-v2-3</literal> DaemonSet is created.</simpara>
<simpara>This name change does not affect previous releases or any <literal>istio-cni-node</literal> CNI DaemonSet associated with a Service Mesh Control Plane deployed using a previous release.</simpara>
</section>
<section xml:id="_gateway_injection_support">
<title>Gateway injection support</title>
<simpara>This release introduces generally available support for Gateway injection. Gateway configurations are applied to standalone Envoy proxies that are running at the edge of the mesh, rather than the sidecar Envoy proxies running alongside your service workloads. This enables the ability to customize gateway options. When using gateway injection, you must create the following resources in the namespace where you want to run your gateway proxy: <literal>Service</literal>, <literal>Deployment</literal>, <literal>Role</literal>, and <literal>RoleBinding</literal>.</simpara>
</section>
<section xml:id="_istio_1_14_support">
<title>Istio 1.14 Support</title>
<simpara>Service Mesh 2.3 is based on Istio 1.14, which brings in new features and product enhancements. While many Istio 1.14 features are supported, the following exceptions should be noted:</simpara>
<itemizedlist>
<listitem>
<simpara>ProxyConfig API is supported with the exception of the image field.</simpara>
</listitem>
<listitem>
<simpara>Telemetry API is a Technology Preview feature.</simpara>
</listitem>
<listitem>
<simpara>SPIRE runtime is not a supported feature.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_openshift_service_mesh_console">
<title>OpenShift Service Mesh Console</title>
<important>
<simpara>OpenShift Service Mesh Console is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>This release introduces a Technology Preview version of the OpenShift Container Platform Service Mesh Console, which integrates the Kiali interface directly into the OpenShift web console. For additional information, see <link xlink:href="https://cloud.redhat.com/blog/introducing-the-openshift-service-mesh-console-a-developer-preview">Introducing the OpenShift Service Mesh Console (A Technology Preview)</link></simpara>
</section>
<section xml:id="_cluster_wide_deployment">
<title>Cluster-wide deployment</title>
<important>
<simpara>Cluster-wide deployment is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>This release introduces cluster-wide deployment as a Technology Preview feature. A cluster-wide deployment contains a Service Mesh Control Plane that monitors resources for an entire cluster. The control plane uses a single query across all namespaces to monitor each Istio or Kubernetes resource kind that affects the mesh configuration. In contrast, the multitenant approach uses a query per namespace for each resource kind. Reducing the number of queries the control plane performs in a cluster-wide deployment improves performance.</simpara>
<note>
<simpara>This cluster-wide deployment documentation is only applicable for control planes deployed using SMCP v2.3. cluster-wide deployments created using SMCP v2.3 are not compatible with cluster-wide deployments created using SMCP v2.4.</simpara>
</note>
<section xml:id="_configuring_cluster_wide_deployment">
<title>Configuring cluster-wide deployment</title>
<simpara>The following example <literal>ServiceMeshControlPlane</literal> object configures a cluster-wide deployment.</simpara>
<simpara>To create an SMCP for cluster-wide deployment, a user must belong to the <literal>cluster-admin</literal> ClusterRole. If the SMCP is configured for cluster-wide deployment, it must be the only SMCP in the cluster. You cannot change the control plane mode from multitenant to cluster-wide (or from cluster-wide to multitenant). If a multitenant control plane already exists, delete it and create a new one.</simpara>
<simpara>This example configures the SMCP for cluster-wide deployment.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: maistra.io/v2
  kind: ServiceMeshControlPlane
  metadata:
    name: cluster-wide
    namespace: istio-system
  spec:
    version: v2.3
    techPreview:
      controlPlaneMode: ClusterScoped <co xml:id="CO1-1"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Enables Istiod to monitor resources at the cluster level rather than monitor each individual namespace.</para>
</callout>
</calloutlist>
<simpara>Additionally, the SMMR must also be configured for cluster-wide deployment. This example configures the SMMR for cluster-wide deployment.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: maistra.io/v1
  kind: ServiceMeshMemberRoll
  metadata:
    name: default
  spec:
    members:
    - '*' <co xml:id="CO2-1"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Adds all namespaces to the mesh, including any namespaces you subsequently create. The following namespaces are not part of the mesh: kube, openshift, kube-* and openshift-*.</para>
</callout>
</calloutlist>
</section>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_12">
<title>New features Red Hat OpenShift Service Mesh version 2.2.12</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_12">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.12</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.11</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_11">
<title>New features Red Hat OpenShift Service Mesh version 2.2.11</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.11 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_11">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.11</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.47.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.10</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_10">
<title>New features Red Hat OpenShift Service Mesh version 2.2.10</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_10">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.10</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_9">
<title>New features Red Hat OpenShift Service Mesh version 2.2.9</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_9">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.9</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_8">
<title>New features Red Hat OpenShift Service Mesh version 2.2.8</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_8">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.8</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_7">
<title>New features Red Hat OpenShift Service Mesh version 2.2.7</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.10 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_7">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.7</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.42.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_6">
<title>New features Red Hat OpenShift Service Mesh version 2.2.6</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_6">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.6</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_5">
<title>New features Red Hat OpenShift Service Mesh version 2.2.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_5">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.5</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.39</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_4">
<title>New features Red Hat OpenShift Service Mesh version 2.2.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_4">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.4</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_3">
<title>New features Red Hat OpenShift Service Mesh version 2.2.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_3">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.3</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_2">
<title>New features Red Hat OpenShift Service Mesh version 2.2.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.2-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_copy_route_labels">
<title>Copy route labels</title>
<simpara>With this enhancement, in addition to copying annotations, you can copy specific labels for an OpenShift route. Red Hat OpenShift Service Mesh copies all labels and annotations present in the Istio Gateway resource (with the exception of annotations starting with kubectl.kubernetes.io) into the managed OpenShift Route resource.</simpara>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_version_2_2_1">
<title>New features Red Hat OpenShift Service Mesh version 2.2.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.34.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.2-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_2">
<title>New features Red Hat OpenShift Service Mesh 2.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds new features and enhancements, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.20.4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.34.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.48.0.16</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_wasmplugin_api">
<title><literal>WasmPlugin</literal> API</title>
<simpara>This release adds support for the <literal>WasmPlugin</literal> API and deprecates the <literal>ServiceMeshExtension</literal> API.</simpara>
</section>
<section xml:id="_rosa_support">
<title>ROSA support</title>
<simpara>This release introduces service mesh support for Red Hat OpenShift on AWS (ROSA), including multi-cluster federation.</simpara>
</section>
<section xml:id="_istio_node_daemonset_renamed">
<title><literal>istio-node</literal> DaemonSet renamed</title>
<simpara>This release, the <literal>istio-node</literal> DaemonSet is renamed to <literal>istio-cni-node</literal> to match the name in upstream Istio.</simpara>
</section>
<section xml:id="_envoy_sidecar_networking_changes">
<title>Envoy sidecar networking changes</title>
<simpara>Istio 1.10 updated Envoy to send traffic to the application container using <literal>eth0</literal> rather than <literal>lo</literal> by default.</simpara>
</section>
<section xml:id="_service_mesh_control_plane_1_1">
<title>Service Mesh Control Plane 1.1</title>
<simpara>This release marks the end of support for Service Mesh Control Planes based on Service Mesh 1.1 for all platforms.</simpara>
</section>
<section xml:id="_istio_1_12_support">
<title>Istio 1.12 Support</title>
<simpara>Service Mesh 2.2 is based on Istio 1.12, which brings in new features and product enhancements. While many Istio 1.12 features are supported, the following unsupported features should be noted:</simpara>
<itemizedlist>
<listitem>
<simpara>AuthPolicy Dry Run is a tech preview feature.</simpara>
</listitem>
<listitem>
<simpara>gRPC Proxyless Service Mesh is a tech preview feature.</simpara>
</listitem>
<listitem>
<simpara>Telemetry API is a tech preview feature.</simpara>
</listitem>
<listitem>
<simpara>Discovery selectors is not a supported feature.</simpara>
</listitem>
<listitem>
<simpara>External control plane is not a supported feature.</simpara>
</listitem>
<listitem>
<simpara>Gateway injection is not a supported feature.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_kubernetes_gateway_api">
<title>Kubernetes Gateway API</title>
<important>
<simpara>Kubernetes Gateway API is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Kubernetes Gateway API is a technology preview feature that is disabled by default. If the Kubernetes API deployment controller is disabled, you must manually deploy and link an ingress gateway to the created Gateway object.</simpara>
<simpara>If the Kubernetes API deployment controller is enabled, then an ingress gateway automatically deploys when a Gateway object is created.</simpara>
<section xml:id="_installing_the_gateway_api_crds">
<title>Installing the Gateway API CRDs</title>
<simpara>The Gateway API CRDs do not come preinstalled by default on OpenShift clusters. Install the CRDs prior to enabling Gateway API support in the SMCP.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ kubectl get crd gateways.gateway.networking.k8s.io || { kubectl kustomize "github.com/kubernetes-sigs/gateway-api/config/crd?ref=v0.4.0" | kubectl apply -f -; }</programlisting>
</section>
<section xml:id="_enabling_kubernetes_gateway_api">
<title>Enabling Kubernetes Gateway API</title>
<simpara>To enable the feature, set the following environment variables for the <literal>Istiod</literal> container in <literal>ServiceMeshControlPlane</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        container:
          env:
            PILOT_ENABLE_GATEWAY_API: "true"
            PILOT_ENABLE_GATEWAY_API_STATUS: "true"
            # and optionally, for the deployment controller
            PILOT_ENABLE_GATEWAY_API_DEPLOYMENT_CONTROLLER: "true"</programlisting>
<simpara>Restricting route attachment on Gateway API listeners is possible using the <literal>SameNamespace</literal> or <literal>All</literal> settings. Istio ignores usage of label selectors in <literal>listeners.allowedRoutes.namespaces</literal> and reverts to the default behavior (<literal>SameNamespace</literal>).</simpara>
</section>
<section xml:id="_manually_linking_an_existing_gateway_to_a_gateway_resource">
<title>Manually linking an existing gateway to a Gateway resource</title>
<simpara>If the Kubernetes API deployment controller is disabled, you must manually deploy and then link an ingress gateway to the created Gateway resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: gateway.networking.k8s.io/v1alpha2
  kind: Gateway
  metadata:
    name: gateway
  spec:
    addresses:
    - value: ingress.istio-gateways.svc.cluster.local
      type: Hostname</programlisting>
</section>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_6">
<title>New features Red Hat OpenShift Service Mesh 2.1.6</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_6">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.6</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.16</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_5_2">
<title>New features Red Hat OpenShift Service Mesh 2.1.5.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), contains bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_5_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.5.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.17</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_5_1">
<title>New features Red Hat OpenShift Service Mesh 2.1.5.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_5_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.5.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.13</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_5">
<title>New features Red Hat OpenShift Service Mesh 2.1.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 and later versions.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_5">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.5</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.12-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_4">
<title>New features Red Hat OpenShift Service Mesh 2.1.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_4">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.4</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.12-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_3">
<title>New features Red Hat OpenShift Service Mesh 2.1.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_3">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.3</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.10-2</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_2_1">
<title>New features Red Hat OpenShift Service Mesh 2.1.2.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_2_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.2.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.9</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_2">
<title>New features Red Hat OpenShift Service Mesh 2.1.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<simpara>With this release, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator is now installed to the <literal>openshift-distributed-tracing</literal> namespace by default.  Previously the default installation had been in the <literal>openshift-operator</literal> namespace.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.8</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_1_1">
<title>New features Red Hat OpenShift Service Mesh 2.1.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<simpara>This release also adds the ability to disable the automatic creation of network policies.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="ossm-config-disable-networkpolicy_ossm-release-notes">
<title>Disabling network policies</title>
<simpara>Red Hat OpenShift Service Mesh automatically creates and manages a number of <literal>NetworkPolicies</literal> resources in the Service Mesh control plane and application namespaces. This is to ensure that applications and the control plane can communicate with each other.</simpara>
<simpara>If you want to disable the automatic creation and management of <literal>NetworkPolicies</literal> resources, for example to enforce company security policies, you can do so.  You can edit the <literal>ServiceMeshControlPlane</literal> to set the <literal>spec.security.manageNetworkPolicy</literal> setting to <literal>false</literal></simpara>
<note>
<simpara>When you disable <literal>spec.security.manageNetworkPolicy</literal> Red Hat OpenShift Service Mesh will not create <emphasis role="strong">any</emphasis> <literal>NetworkPolicy</literal> objects.  The system administrator is responsible for managing the network and fixing any issues this might cause.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the project where you installed the Service Mesh control plane, for example <literal>istio-system</literal>, from the Project menu.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator. In the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> column, click the name of your <literal>ServiceMeshControlPlane</literal>, for example <literal>basic-install</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create ServiceMeshControlPlane Details</emphasis> page, click <literal>YAML</literal> to modify your configuration.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>ServiceMeshControlPlane</literal> field <literal>spec.security.manageNetworkPolicy</literal> to <literal>false</literal>, as shown in this example.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  security:
      trust:
      manageNetworkPolicy: false</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_new_features_and_enhancements_red_hat_openshift_service_mesh_2_1">
<title>New features and enhancements Red Hat OpenShift Service Mesh 2.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds support for Istio 1.9.8, Envoy Proxy 1.17.1, Jaeger 1.24.1, and Kiali 1.36.5 on OpenShift Container Platform 4.6 EUS, 4.7, 4.8, 4.9, along with new features and enhancements.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.9.6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.17.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.36.5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_service_mesh_federation">
<title>Service Mesh Federation</title>
<simpara>New Custom Resource Definitions (CRDs) have been added to support federating service meshes. Service meshes may be federated both within the same cluster or across different OpenShift clusters. These new resources include:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ServiceMeshPeer</literal> - Defines a federation with a separate service mesh, including gateway configuration, root trust certificate configuration, and status fields. In a pair of federated meshes, each mesh will define its own separate <literal>ServiceMeshPeer</literal> resource.</simpara>
</listitem>
<listitem>
<simpara><literal>ExportedServiceMeshSet</literal> - Defines which services for a given <literal>ServiceMeshPeer</literal> are available for the peer mesh to import.</simpara>
</listitem>
<listitem>
<simpara><literal>ImportedServiceSet</literal> - Defines which services for a given <literal>ServiceMeshPeer</literal> are imported from the peer mesh. These services must also be made available by the peer’s <literal>ExportedServiceMeshSet</literal> resource.</simpara>
</listitem>
</itemizedlist>
<simpara>Service Mesh Federation is not supported between clusters on Red Hat OpenShift Service on AWS (ROSA), Azure Red Hat OpenShift (ARO), or OpenShift Dedicated (OSD).</simpara>
</section>
<section xml:id="_ovn_kubernetes_container_network_interface_cni_generally_available">
<title>OVN-Kubernetes Container Network Interface (CNI) generally available</title>
<simpara>The OVN-Kubernetes Container Network Interface (CNI) was previously introduced as a Technology Preview feature in Red Hat OpenShift Service Mesh 2.0.1 and is now generally available in Red Hat OpenShift Service Mesh 2.1 and 2.0.x for use on OpenShift Container Platform 4.7.32, OpenShift Container Platform 4.8.12, and OpenShift Container Platform 4.9.</simpara>
</section>
<section xml:id="_service_mesh_webassembly_wasm_extensions">
<title>Service Mesh WebAssembly (WASM) Extensions</title>
<simpara>The <literal>ServiceMeshExtensions</literal> Custom Resource Definition (CRD), first introduced in 2.0 as Technology Preview, is now generally available. You can use CRD to build your own plugins, but Red Hat does not provide support for the plugins you create.</simpara>
<simpara>Mixer has been completely removed in Service Mesh 2.1. Upgrading from a Service Mesh 2.0.x release to 2.1 will be blocked if Mixer is enabled. Mixer plugins will need to be ported to WebAssembly Extensions.</simpara>
</section>
<section xml:id="_3scale_webassembly_adapter_wasm">
<title>3scale WebAssembly Adapter (WASM)</title>
<simpara>With Mixer now officially removed, OpenShift Service Mesh 2.1 does not support the 3scale mixer adapter. Before upgrading to Service Mesh 2.1, remove the Mixer-based 3scale adapter and any additional Mixer plugins. Then, manually install and configure the new 3scale WebAssembly adapter with Service Mesh 2.1+ using a <literal>ServiceMeshExtension</literal> resource.</simpara>
<simpara>3scale 2.11 introduces an updated Service Mesh integration based on  <literal>WebAssembly</literal>.</simpara>
</section>
<section xml:id="_istio_1_9_support">
<title>Istio 1.9 Support</title>
<simpara>Service Mesh 2.1 is based on Istio 1.9, which brings in a large number of new features and product enhancements. While the majority of Istio 1.9 features are supported, the following exceptions should be noted:</simpara>
<itemizedlist>
<listitem>
<simpara>Virtual Machine integration is not yet supported</simpara>
</listitem>
<listitem>
<simpara>Kubernetes Gateway API is not yet supported</simpara>
</listitem>
<listitem>
<simpara>Remote fetch and load of WebAssembly HTTP filters are not yet supported</simpara>
</listitem>
<listitem>
<simpara>Custom CA Integration using the Kubernetes CSR API is not yet supported</simpara>
</listitem>
<listitem>
<simpara>Request Classification for monitoring traffic is a tech preview feature</simpara>
</listitem>
<listitem>
<simpara>Integration with external authorization systems via Authorization policy’s CUSTOM action is a tech preview feature</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_improved_service_mesh_operator_performance">
<title>Improved Service Mesh operator performance</title>
<simpara>The amount of time Red Hat OpenShift Service Mesh uses to prune old resources at the end of every <literal>ServiceMeshControlPlane</literal> reconciliation has been reduced. This results in faster <literal>ServiceMeshControlPlane</literal> deployments, and allows changes applied to existing SMCPs to take effect more quickly.</simpara>
</section>
<section xml:id="_kiali_updates">
<title>Kiali updates</title>
<simpara>Kiali 1.36 includes the following features and enhancements:</simpara>
<itemizedlist>
<listitem>
<simpara>Service Mesh troubleshooting functionality</simpara>
<itemizedlist>
<listitem>
<simpara>Control plane and gateway monitoring</simpara>
</listitem>
<listitem>
<simpara>Proxy sync statuses</simpara>
</listitem>
<listitem>
<simpara>Envoy configuration views</simpara>
</listitem>
<listitem>
<simpara>Unified view showing Envoy proxy and application logs interleaved</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Namespace and cluster boxing to support federated service mesh views</simpara>
</listitem>
<listitem>
<simpara>New validations, wizards, and distributed tracing enhancements</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_11_1">
<title>New features Red Hat OpenShift Service Mesh 2.0.11.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 or later.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_0_11_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.0.11.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.6.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.17</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_11">
<title>New features Red Hat OpenShift Service Mesh 2.0.11</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs), bug fixes, and is supported on OpenShift Container Platform 4.9 or later.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_0_11">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.0.11</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.6.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.36</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.16-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_10">
<title>New features Red Hat OpenShift Service Mesh 2.0.10</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_0_10">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.0.10</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.6.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.28.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.16-1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_9">
<title>New features Red Hat OpenShift Service Mesh 2.0.9</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_2_0_9">
<title>Component versions included in Red Hat OpenShift Service Mesh version 2.0.9</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.6.14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Envoy Proxy</simpara></entry>
<entry align="left" valign="top"><simpara>1.14.5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.11</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_8">
<title>New features Red Hat OpenShift Service Mesh 2.0.8</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_7_1">
<title>New features Red Hat OpenShift Service Mesh 2.0.7.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs).</simpara>
<section xml:id="_change_in_how_red_hat_openshift_service_mesh_handles_uri_fragments">
<title>Change in how Red Hat OpenShift Service Mesh handles URI fragments</title>
<simpara>Red Hat OpenShift Service Mesh contains a remotely exploitable vulnerability, <link xlink:href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-39156">CVE-2021-39156</link>, where an HTTP request with a fragment (a section in the end of a URI that begins with a # character) in the URI path could bypass the Istio URI path-based authorization policies. For instance, an Istio authorization policy denies requests sent to the URI path <literal>/user/profile</literal>. In the vulnerable versions, a request with URI path <literal>/user/profile#section1</literal> bypasses the deny policy and routes to the backend (with the normalized URI <literal>path /user/profile%23section1</literal>), possibly leading to a security incident.</simpara>
<simpara>You are impacted by this vulnerability if you use authorization policies with DENY actions and <literal>operation.paths</literal>, or ALLOW actions and <literal>operation.notPaths</literal>.</simpara>
<simpara>With the mitigation, the fragment part of the request’s URI is removed before the authorization and routing. This prevents a request with a fragment in its URI from bypassing authorization policies which are based on the URI without the fragment part.</simpara>
<simpara>To opt-out from the new behavior in the mitigation, the fragment section in the URI will be kept. You can configure your <literal>ServiceMeshControlPlane</literal> to keep URI fragments.</simpara>
<warning>
<simpara>Disabling the new behavior will normalize your paths as described above and is considered unsafe. Ensure that you have accommodated for this in any security policies before opting to keep URI fragments.</simpara>
</warning>
<formalpara>
<title>Example <literal>ServiceMeshControlPlane</literal> modification</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  techPreview:
    meshConfig:
      defaultConfig:
        proxyMetadata: HTTP_STRIP_FRAGMENT_FROM_PATH_UNSAFE_IF_DISABLED: "false"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_required_update_for_authorization_policies">
<title>Required update for authorization policies</title>
<simpara>Istio generates hostnames for both the hostname itself and all matching ports. For instance, a virtual service or Gateway for a host of "httpbin.foo" generates a config matching "httpbin.foo and httpbin.foo:*". However, exact match authorization policies only match the exact string given for the <literal>hosts</literal> or <literal>notHosts</literal> fields.</simpara>
<simpara>Your cluster is impacted if you have <literal>AuthorizationPolicy</literal> resources using exact string comparison for the rule to determine <link xlink:href="https://istio.io/latest/docs/reference/config/security/authorization-policy/#Operation">hosts or notHosts</link>.</simpara>
<simpara>You must update your authorization policy <link xlink:href="https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule">rules</link> to use prefix match instead of exact match.  For example, replacing <literal>hosts: ["httpbin.com"]</literal> with <literal>hosts: ["httpbin.com:*"]</literal> in the first <literal>AuthorizationPolicy</literal> example.</simpara>
<formalpara>
<title>First example AuthorizationPolicy using prefix match</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: httpbin
  namespace: foo
spec:
  action: DENY
  rules:
  - from:
    - source:
        namespaces: ["dev"]
    to:
    - operation:
        hosts: [“httpbin.com”,"httpbin.com:*"]</programlisting>
</para>
</formalpara>
<formalpara>
<title>Second example AuthorizationPolicy using prefix match</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: httpbin
  namespace: default
spec:
  action: DENY
  rules:
  - to:
    - operation:
        hosts: ["httpbin.example.com:*"]</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_7">
<title>New features Red Hat OpenShift Service Mesh 2.0.7</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_red_hat_openshift_service_mesh_on_red_hat_openshift_dedicated_and_microsoft_azure_red_hat_openshift">
<title>Red Hat OpenShift Service Mesh on Red Hat OpenShift Dedicated and Microsoft Azure Red Hat OpenShift</title>
<simpara>Red Hat OpenShift Service Mesh is now supported through Red Hat OpenShift Dedicated and Microsoft Azure Red Hat OpenShift.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_6">
<title>New features Red Hat OpenShift Service Mesh 2.0.6</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_5">
<title>New features Red Hat OpenShift Service Mesh 2.0.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_4">
<title>New features Red Hat OpenShift Service Mesh 2.0.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<important>
<simpara>There are manual steps that must be completed to address CVE-2021-29492 and CVE-2021-31920.</simpara>
</important>
<section xml:id="manual-updates-cve-2021-29492_ossm-release-notes">
<title>Manual updates required by CVE-2021-29492 and CVE-2021-31920</title>
<simpara>Istio contains a remotely exploitable vulnerability where an HTTP request path with multiple slashes or escaped slash characters (<literal>%2F</literal> or <literal>%5C</literal>) could potentially bypass an Istio authorization policy when path-based authorization rules are used.</simpara>
<simpara>For example, assume an Istio cluster administrator defines an authorization DENY policy to reject the request at path <literal>/admin</literal>. A request sent to the URL path <literal>//admin</literal> will NOT be rejected by the authorization policy.</simpara>
<simpara>According to <link xlink:href="https://tools.ietf.org/html/rfc3986#section-6">RFC 3986</link>, the path <literal>//admin</literal> with multiple slashes should technically be treated as a different path from the <literal>/admin</literal>. However, some backend services choose to normalize the URL paths by merging multiple slashes into a single slash. This can result in a bypass of the authorization policy (<literal>//admin</literal> does not match <literal>/admin</literal>), and a user can access the resource at path <literal>/admin</literal> in the backend; this would represent a security incident.</simpara>
<simpara>Your cluster is impacted by this vulnerability if you have authorization policies using <literal>ALLOW action + notPaths</literal> field or <literal>DENY action + paths field</literal> patterns. These patterns are vulnerable to unexpected policy bypasses.</simpara>
<simpara>Your cluster is NOT impacted by this vulnerability if:</simpara>
<itemizedlist>
<listitem>
<simpara>You don’t have authorization policies.</simpara>
</listitem>
<listitem>
<simpara>Your authorization policies don’t define <literal>paths</literal> or <literal>notPaths</literal> fields.</simpara>
</listitem>
<listitem>
<simpara>Your authorization policies use <literal>ALLOW action + paths</literal> field or <literal>DENY action + notPaths</literal> field patterns. These patterns could only cause unexpected rejection instead of policy bypasses. The upgrade is optional for these cases.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Red Hat OpenShift Service Mesh configuration location for path normalization is different from the Istio configuration.</simpara>
</note>
</section>
<section xml:id="_updating_the_path_normalization_configuration">
<title>Updating the path normalization configuration</title>
<simpara>Istio authorization policies can be based on the URL paths in the HTTP request.
<link xlink:href="https://en.wikipedia.org/wiki/URI_normalization">Path normalization</link>, also known as URI normalization, modifies and standardizes the incoming requests' paths so that the normalized paths can be processed in a standard way.
Syntactically different paths may be equivalent after path normalization.</simpara>
<simpara>Istio supports the following normalization schemes on the request paths before evaluating against the authorization policies and routing the requests:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Normalization schemes</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>NONE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No normalization is done. Anything received by Envoy will be forwarded exactly as-is to any backend service.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>../%2Fa../b</literal> is evaluated by the authorization policies and sent to your service.</simpara></entry>
<entry align="left" valign="top"><simpara>This setting is vulnerable to CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BASE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is currently the option used in the <emphasis role="strong">default</emphasis> installation of Istio. This applies the <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path"><literal>normalize_path</literal></link> option on Envoy proxies, which follows <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> with extra normalization to convert backslashes to forward slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a/../b</literal> is normalized to <literal>/b</literal>. <literal>\da</literal> is normalized to <literal>/da</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>This setting is vulnerable to CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MERGE_SLASHES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slashes are merged after the <emphasis>BASE</emphasis> normalization.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a//b</literal> is normalized to <literal>/a/b</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Update to this setting to mitigate CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The strictest setting when you allow all traffic by default. This setting is recommended, with the caveat that you must thoroughly test your authorization policies routes. <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">Percent-encoded</link> slash and backslash characters (<literal>%2F</literal>, <literal>%2f</literal>, <literal>%5C</literal> and <literal>%5c</literal>) are decoded to <literal>/</literal> or <literal>\</literal>, before the <literal>MERGE_SLASHES</literal> normalization.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a%2fb</literal> is normalized to <literal>/a/b</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Update to this setting to mitigate CVE-2021-31920. This setting is more secure, but also has the potential to break applications. Test your applications before deploying to production.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The normalization algorithms are conducted in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Percent-decode <literal>%2F</literal>, <literal>%2f</literal>, <literal>%5C</literal> and <literal>%5c</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and other normalization implemented by the <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path"><literal>normalize_path</literal></link> option in Envoy.</simpara>
</listitem>
<listitem>
<simpara>Merge slashes.</simpara>
</listitem>
</orderedlist>
<warning>
<simpara>While these normalization options represent recommendations from HTTP standards and common industry practices, applications may interpret a URL in any way it chooses to. When using denial policies, ensure that you understand how your application behaves.</simpara>
</warning>
</section>
<section xml:id="_path_normalization_configuration_examples">
<title>Path normalization configuration examples</title>
<simpara>Ensuring Envoy normalizes request paths to match your backend services' expectations is critical to the security of your system.
The following examples can be used as a reference for you to configure your system.
The normalized URL paths, or the original URL paths if <literal>NONE</literal> is selected, will be:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Used to check against the authorization policies.</simpara>
</listitem>
<listitem>
<simpara>Forwarded to the backend application.</simpara>
</listitem>
</orderedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration examples</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">If your application&#8230;&#8203;</entry>
<entry align="left" valign="top">Choose&#8230;&#8203;</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Relies on the proxy to do normalization</simpara></entry>
<entry align="left" valign="top"><simpara><literal>BASE</literal>, <literal>MERGE_SLASHES</literal> or <literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and does not merge slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>BASE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and merges slashes, but does not decode <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">percent-encoded</link> slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link>, decodes <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">percent-encoded</link> slashes, and merges slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Processes request paths in a way that is incompatible with <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>NONE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_configuring_your_smcp_for_path_normalization">
<title>Configuring your SMCP for path normalization</title>
<simpara>To configure path normalization for Red Hat OpenShift Service Mesh, specify the following in your <literal>ServiceMeshControlPlane</literal>. Use the configuration examples to help determine the settings for your system.</simpara>
<formalpara>
<title>SMCP v2 pathNormalization</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  techPreview:
    global:
      pathNormalization: &lt;option&gt;</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_configuring_for_case_normalization">
<title>Configuring for case normalization</title>
<simpara>In some environments, it may be useful to have paths in authorization policies compared in a case insensitive manner.
For example, treating <literal><link xlink:href="https://myurl/get">https://myurl/get</link></literal> and <literal><link xlink:href="https://myurl/GeT">https://myurl/GeT</link></literal> as equivalent.
In those cases, you can use the <literal>EnvoyFilter</literal> shown below.
This filter will change both the path used for comparison and the path presented to the application. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<simpara>Save the <literal>EnvoyFilter</literal> to a file and run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;myEnvoyFilterFile&gt;</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: ingress-case-insensitive
  namespace: istio-system
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: GATEWAY
      listener:
        filterChain:
          filter:
            name: "envoy.filters.network.http_connection_manager"
            subFilter:
              name: "envoy.filters.http.router"
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.lua
        typed_config:
            "@type": "type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
            inlineCode: |
              function envoy_on_request(request_handle)
                local path = request_handle:headers():get(":path")
                request_handle:headers():replace(":path", string.lower(path))
              end</programlisting>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_3">
<title>New features Red Hat OpenShift Service Mesh 2.0.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<simpara>In addition, this release has the following new features:</simpara>
<itemizedlist>
<listitem>
<simpara>Added an option to the <literal>must-gather</literal> data collection tool that gathers information from a specified Service Mesh control plane namespace. For more information, see <link xlink:href="https://issues.redhat.com/browse/OSSM-351">OSSM-351</link>.</simpara>
</listitem>
<listitem>
<simpara>Improved performance for Service Mesh control planes with hundreds of namespaces</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_2">
<title>New features Red Hat OpenShift Service Mesh 2.0.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds support for IBM Z&#174; and IBM Power&#174; Systems. It also addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0_1">
<title>New features Red Hat OpenShift Service Mesh 2.0.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_2_0">
<title>New features Red Hat OpenShift Service Mesh 2.0</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds support for Istio 1.6.5, Jaeger 1.20.0, Kiali 1.24.2, and the 3scale Istio Adapter 2.0 and OpenShift Container Platform 4.6.</simpara>
<simpara>In addition, this release has the following new features:</simpara>
<itemizedlist>
<listitem>
<simpara>Simplifies installation, upgrades, and management of the Service Mesh control plane.</simpara>
</listitem>
<listitem>
<simpara>Reduces the Service Mesh control plane&#8217;s resource usage and startup time.</simpara>
</listitem>
<listitem>
<simpara>Improves performance by reducing inter-control plane communication over networking.</simpara>
<itemizedlist>
<listitem>
<simpara>Adds support for Envoy&#8217;s Secret Discovery Service (SDS). SDS is a more secure and efficient mechanism for delivering secrets to Envoy side car proxies.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Removes the need to use Kubernetes Secrets, which have well known security risks.</simpara>
</listitem>
<listitem>
<simpara>Improves performance during certificate rotation, as proxies no longer require a restart to recognize new certificates.</simpara>
<itemizedlist>
<listitem>
<simpara>Adds support for Istio&#8217;s Telemetry v2 architecture, which is built using WebAssembly extensions. This new architecture brings significant performance improvements.</simpara>
</listitem>
<listitem>
<simpara>Updates the ServiceMeshControlPlane resource to v2 with a streamlined configuration to make it easier to manage the Service Mesh Control Plane.</simpara>
</listitem>
<listitem>
<simpara>Introduces WebAssembly extensions as a <link xlink:href="https://access.redhat.com/support/offerings/techpreview">Technology Preview</link> feature.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-tech-preview_ossm-release-notes">
<title>Technology Preview</title>
<simpara>Some features in this release are currently in Technology Preview. These experimental features are not intended for production use.</simpara>
<important>
<simpara>Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
</section>
<section xml:id="ossm-deprecated-features_ossm-release-notes">
<title>Deprecated and removed features</title>
<simpara>Some features available in previous releases have been deprecated or removed.</simpara>
<simpara>Deprecated functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<simpara>Removed functionality no longer exists in the product.</simpara>
<section xml:id="_deprecated_and_removed_features_in_red_hat_openshift_service_mesh_2_4">
<title>Deprecated and removed features in Red Hat OpenShift Service Mesh 2.4</title>
<simpara>The v2.1 <literal>ServiceMeshControlPlane</literal> resource is no longer supported. Customers should upgrade their mesh deployments to use a later version of the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<simpara>Support for Istio OpenShift Routing (IOR) is deprecated and will be removed in a future release.</simpara>
<simpara>Support for Grafana is deprecated and will be removed in a future release.</simpara>
<simpara>Support for the following cipher suites, which were deprecated in Red Hat OpenShift Service Mesh 2.3, has been removed from the default list of ciphers used in TLS negotiations on both the client and server sides. Applications that require access to services requiring one of these cipher suites will fail to connect when a TLS connection is initiated from the proxy.</simpara>
<itemizedlist>
<listitem>
<simpara>ECDHE-ECDSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>AES128-GCM-SHA256</simpara>
</listitem>
<listitem>
<simpara>AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-ECDSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>AES256-GCM-SHA384</simpara>
</listitem>
<listitem>
<simpara>AES256-SHA</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_deprecated_and_removed_features_in_red_hat_openshift_service_mesh_2_3">
<title>Deprecated and removed features in Red Hat OpenShift Service Mesh 2.3</title>
<simpara>Support for the following cipher suites has been deprecated. In a future release, they will be removed from the default list of ciphers used in TLS negotiations on both the client and server sides.</simpara>
<itemizedlist>
<listitem>
<simpara>ECDHE-ECDSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>AES128-GCM-SHA256</simpara>
</listitem>
<listitem>
<simpara>AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-ECDSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>AES256-GCM-SHA384</simpara>
</listitem>
<listitem>
<simpara>AES256-SHA</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>ServiceMeshExtension</literal> API, which was deprecated in Red Hat OpenShift Service Mesh version 2.2, was removed in Red Hat OpenShift Service Mesh version 2.3. If you are using the <literal>ServiceMeshExtension</literal> API, you must migrate to the <literal>WasmPlugin</literal> API to continue using your WebAssembly extensions.</simpara>
</section>
<section xml:id="_deprecated_features_in_red_hat_openshift_service_mesh_2_2">
<title>Deprecated features in Red Hat OpenShift Service Mesh 2.2</title>
<simpara>The <literal>ServiceMeshExtension</literal> API is deprecated as of release 2.2 and will be removed in a future release.  While <literal>ServiceMeshExtension</literal> API is still supported in release 2.2, customers should start moving to the new <literal>WasmPlugin</literal> API.</simpara>
</section>
<section xml:id="_removed_features_in_red_hat_openshift_service_mesh_2_2">
<title>Removed features in Red Hat OpenShift Service Mesh 2.2</title>
<simpara>This release marks the end of support for Service Mesh control planes based on Service Mesh 1.1 for all platforms.</simpara>
</section>
<section xml:id="_removed_features_in_red_hat_openshift_service_mesh_2_1">
<title>Removed features in Red Hat OpenShift Service Mesh 2.1</title>
<simpara>In Service Mesh 2.1, the Mixer component is removed. Bug fixes and support is provided through the end of the Service Mesh 2.0 life cycle.</simpara>
<simpara>Upgrading from a Service Mesh 2.0.x release to 2.1 will not proceed if Mixer plugins are enabled. Mixer plugins must be ported to WebAssembly Extensions.</simpara>
</section>
<section xml:id="_deprecated_features_in_red_hat_openshift_service_mesh_2_0">
<title>Deprecated features in Red Hat OpenShift Service Mesh 2.0</title>
<simpara>The Mixer component was deprecated in release 2.0 and will be removed in release 2.1. While using Mixer for implementing extensions was still supported in release 2.0, extensions should have been migrated to the new <link xlink:href="https://istio.io/latest/blog/2020/wasm-announce/">WebAssembly</link> mechanism.</simpara>
<simpara>The following resource types are no longer supported in Red Hat OpenShift Service Mesh 2.0:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Policy</literal> (authentication.istio.io/v1alpha1) is no longer supported. Depending on the specific configuration in your Policy resource, you may have to configure multiple resources to achieve the same effect.</simpara>
<itemizedlist>
<listitem>
<simpara>Use <literal>RequestAuthentication</literal> (security.istio.io/v1beta1)</simpara>
</listitem>
<listitem>
<simpara>Use <literal>PeerAuthentication</literal> (security.istio.io/v1beta1)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ServiceMeshPolicy</literal> (maistra.io/v1) is no longer supported.</simpara>
<itemizedlist>
<listitem>
<simpara>Use <literal>RequestAuthentication</literal> or <literal>PeerAuthentication</literal>, as mentioned above, but place in the Service Mesh control plane namespace.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>RbacConfig</literal> (rbac.istio.io/v1alpha1) is no longer supported.</simpara>
<itemizedlist>
<listitem>
<simpara>Replaced by <literal>AuthorizationPolicy</literal> (security.istio.io/v1beta1), which encompasses behavior of <literal>RbacConfig</literal>, <literal>ServiceRole</literal>, and <literal>ServiceRoleBinding</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ServiceMeshRbacConfig</literal> (maistra.io/v1) is no longer supported.</simpara>
<itemizedlist>
<listitem>
<simpara>Use <literal>AuthorizationPolicy</literal> as above, but place in Service Mesh control plane namespace.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ServiceRole</literal> (rbac.istio.io/v1alpha1) is no longer supported.</simpara>
</listitem>
<listitem>
<simpara><literal>ServiceRoleBinding</literal> (rbac.istio.io/v1alpha1) is no longer supported.</simpara>
</listitem>
<listitem>
<simpara>In Kiali, the <literal>login</literal> and <literal>LDAP</literal> strategies are deprecated. A future version will introduce authentication using OpenID providers.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-known-issues_ossm-release-notes">
<title>Known issues</title>
<simpara>These limitations exist in Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Service Mesh does not yet fully support <link xlink:href="https://issues.redhat.com/browse/MAISTRA-1314">IPv6</link>. As a result, Red Hat OpenShift Service Mesh does not support dual-stack clusters.</simpara>
</listitem>
<listitem>
<simpara>Graph layout - The layout for the Kiali graph can render differently, depending on your application architecture and the data to display (number of graph nodes and their interactions). Because it is difficult if not impossible to create a single layout that renders nicely for every situation, Kiali offers a choice of several different layouts. To choose a different layout, you can choose a different <emphasis role="strong">Layout Schema</emphasis> from the <emphasis role="strong">Graph Settings</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>The first time you access related services such as distributed tracing platform (Jaeger) and Grafana, from the Kiali console, you must accept the certificate and re-authenticate using your OpenShift Container Platform login credentials. This happens due to an issue with how the framework displays embedded pages in the console.</simpara>
</listitem>
<listitem>
<simpara>The Bookinfo sample application cannot be installed on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</listitem>
<listitem>
<simpara>WebAssembly extensions are not supported on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</listitem>
<listitem>
<simpara>LuaJIT is not supported on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</listitem>
<listitem>
<simpara>Single stack IPv6 support is not available on IBM Power&#174;, IBM Z&#174;, and IBM&#174; LinuxONE.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-rn-known-issues-ossm_ossm-release-notes">
<title>Service Mesh known issues</title>
<simpara>These are the known issues in Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3890">OSSM-3890</link> Attempting to use the Gateway API in a multitenant mesh deployment generates an error message similar to the following:</simpara>
<programlisting language="text" linenumbering="unnumbered">2023-05-02T15:20:42.541034Z	error	watch error in cluster Kubernetes: failed to list *v1alpha2.TLSRoute: the server could not find the requested resource (get tlsroutes.gateway.networking.k8s.io)
2023-05-02T15:20:42.616450Z	info	kube	controller "gateway.networking.k8s.io/v1alpha2/TCPRoute" is syncing...</programlisting>
<simpara>To support Gateway API in a multitenant mesh deployment, all Gateway API Custom Resource Definition (CRD) files must be present in the cluster.</simpara>
<simpara>In a multitenant mesh deployment, CRD scan is disabled, and Istio has no way to discover which CRDs are present in a cluster. As a result, Istio attempts to watch all supported Gateway API CRDs, but generates errors if some of those CRDs are not present.</simpara>
<simpara>Service Mesh 2.3.1 and later versions support both <literal>v1alpha2</literal> and <literal>v1beta1</literal> CRDs. Therefore, both CRD versions must be present for a multitenant mesh deployment to support the Gateway API.</simpara>
<simpara>Workaround: In the following example, the <literal>kubectl get</literal> operation installs the <literal>v1alpha2</literal> and <literal>v1beta1</literal> CRDs. Note the URL contains the additional <literal>experimental</literal> segment and updates any of your existing scripts accordingly:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ kubectl get crd gateways.gateway.networking.k8s.io ||   { kubectl kustomize "github.com/kubernetes-sigs/gateway-api/config/crd/experimental?ref=v0.5.1" | kubectl apply -f -; }</programlisting>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2042">OSSM-2042</link> Deployment of SMCP named <literal>default</literal> fails. If you are creating an SMCP object, and set its version field to v2.3, the name of the object cannot be <literal>default</literal>. If the name is <literal>default</literal>, then the control plane fails to deploy, and OpenShift generates a <literal>Warning</literal> event with the following message:</simpara>
<simpara><literal>Error processing component mesh-config: error: [mesh-config/templates/telemetryv2_1.6.yaml: Internal error occurred: failed calling webhook "rev.validation.istio.io": Post "https://istiod-default.istio-system.svc:443/validate?timeout=10s": x509: certificate is valid for istiod.istio-system.svc, istiod-remote.istio-system.svc, istio-pilot.istio-system.svc, not istiod-default.istio-system.svc, mesh-config/templates/enable-mesh-permissive.yaml</literal></simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1655">OSSM-1655</link> Kiali dashboard shows error after enabling mTLS in <literal>SMCP</literal>.</simpara>
<simpara>After enabling the <literal>spec.security.controlPlane.mtls</literal> setting in the SMCP, the Kiali console displays the following error message <literal>No subsets defined</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1505">OSSM-1505</link> This issue only occurs when using the <literal>ServiceMeshExtension</literal> resource on OpenShift Container Platform 4.11. When you use <literal>ServiceMeshExtension</literal> on OpenShift Container Platform 4.11 the resource never becomes ready. If you inspect the issue using <literal>oc describe ServiceMeshExtension</literal> you will see the following error:  <literal>stderr: Error creating mount namespace before pivot: function not implemented</literal>.</simpara>
<simpara>Workaround: <literal>ServiceMeshExtension</literal> was deprecated in Service Mesh 2.2. Migrate from <literal>ServiceMeshExtension</literal> to the <literal>WasmPlugin</literal> resource.
For more information, see Migrating from <literal>ServiceMeshExtension</literal> to <literal>WasmPlugin</literal> resources.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1396">OSSM-1396</link> If a gateway resource contains the <literal>spec.externalIPs</literal> setting, instead of being recreated when the <literal>ServiceMeshControlPlane</literal> is updated, the gateway is removed and never recreated.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1168">OSSM-1168</link> When service mesh resources are created as a single YAML file, the Envoy proxy sidecar is not reliably injected into pods. When the SMCP, SMMR, and Deployment resources are created individually, the deployment works as expected.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1115">OSSM-1115</link> The <literal>concurrency</literal> field of the <literal>spec.proxy</literal> API did not propagate to the istio-proxy. The <literal>concurrency</literal> field works when set with <literal>ProxyConfig</literal>. The <literal>concurrency</literal> field specifies the number of worker threads to run. If the field is set to <literal>0</literal>, then the number of worker threads available is equal to the number of CPU cores. If the field is not set, then the number of worker threads available defaults to <literal>2</literal>.</simpara>
<simpara>In the following example, the <literal>concurrency</literal> field is set to <literal>0</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: ProxyConfig
metadata:
  name: mesh-wide-concurrency
  namespace: &lt;istiod-namespace&gt;
spec:
  concurrency: 0</programlisting>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1052">OSSM-1052</link> When configuring a Service <literal>ExternalIP</literal> for the ingressgateway in the Service Mesh control plane, the service is not created. The schema for the SMCP is missing the parameter for the service.</simpara>
<simpara>Workaround: Disable the gateway creation in the SMCP spec and manage the gateway deployment entirely manually (including Service, Role and RoleBinding).</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-882">OSSM-882</link> This applies for Service Mesh 2.1 and earlier. Namespace is in the accessible_namespace list but does not appear in Kiali UI. By default, Kiali will not show any namespaces that start with "kube" because these namespaces are typically internal-use only and not part of a mesh.</simpara>
<simpara>For example, if you create a namespace called 'akube-a' and add it to the Service Mesh member roll, then the Kiali UI does not display the namespace. For defined exclusion patterns, the software excludes namespaces that start with or contain the pattern.</simpara>
<simpara>Workaround: Change the Kiali Custom Resource setting so it prefixes the setting with a carat (^). For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">api:
  namespaces:
    exclude:
    - "^istio-operator"
    - "^kube-.*"
    - "^openshift.*"
    - "^ibm.*"
    - "^kiali-operator"</programlisting>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2692">MAISTRA-2692</link> With Mixer removed, custom metrics that have been defined in Service Mesh 2.0.x cannot be used in 2.1. Custom metrics can be configured using <literal>EnvoyFilter</literal>. Red Hat is unable to support <literal>EnvoyFilter</literal> configuration except where explicitly documented. This is due to tight coupling with the underlying Envoy APIs, meaning that backward compatibility cannot be maintained.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2648">MAISTRA-2648</link> Service mesh extensions are currently not compatible with meshes deployed on IBM Z&#174;.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-1959">MAISTRA-1959</link> <emphasis>Migration to 2.0</emphasis> Prometheus scraping (<literal>spec.addons.prometheus.scrape</literal> set to <literal>true</literal>) does not work when mTLS is enabled. Additionally, Kiali displays extraneous graph data when mTLS is disabled.</simpara>
<simpara>This problem can be addressed by excluding port 15020 from proxy configuration, for example,</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  proxy:
    networking:
      trafficControl:
        inbound:
          excludedPorts:
          - 15020</programlisting>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-453">MAISTRA-453</link> If you create a new project and deploy pods immediately, sidecar injection does not occur. The operator fails to add the <literal>maistra.io/member-of</literal> before the pods are created, therefore the pods must be deleted and recreated for sidecar injection to occur.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-158">MAISTRA-158</link> Applying multiple gateways referencing the same hostname will cause all gateways to stop functioning.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-rn-known-issues-kiali_ossm-release-notes">
<title>Kiali known issues</title>
<note>
<simpara>New issues for Kiali should be created in the <link xlink:href="https://issues.redhat.com/projects/OSSM/">OpenShift Service Mesh</link> project with the <literal>Component</literal> set to <literal>Kiali</literal>.</simpara>
</note>
<simpara>These are the known issues in Kiali:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-2206">KIALI-2206</link> When you are accessing the Kiali console for the first time, and there is no cached browser data for Kiali, the “View in Grafana” link on the Metrics tab of the Kiali Service Details page redirects to the wrong location. The only way you would encounter this issue is if you are accessing Kiali for the first time.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/kiali/kiali/issues/507">KIALI-507</link> Kiali does not support Internet Explorer 11. This is because the underlying frameworks do not support Internet Explorer. To access the Kiali console, use one of the two most recent versions of the Chrome, Edge, Firefox or Safari browser.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-fixed-issues_ossm-release-notes">
<title>Fixed issues</title>
<simpara>The following issue has been resolved in the current release:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3647">OSSM-3647</link> Previously, in the Service Mesh control plane (SMCP) v2.2 (Istio 1.12), WasmPlugins were applied only to inbound listeners. Since SMCP v2.3 (Istio 1.14), WasmPlugins have been applied to inbound and outbound listeners by default, which introduced regression for users of the 3scale WasmPlugin. Now, the environment variable <literal>APPLY_WASM_PLUGINS_TO_INBOUND_ONLY</literal> is added, which allows safe migration from SMCP v2.2 to v2.3 and v2.4.</simpara>
<simpara>The following setting should be added to the SMCP config:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        container:
          env:
            APPLY_WASM_PLUGINS_TO_INBOUND_ONLY: "true"</programlisting>
<simpara>To ensure safe migration, perform the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Set <literal>APPLY_WASM_PLUGINS_TO_INBOUND_ONLY</literal> in SMCP v2.2.</simpara>
</listitem>
<listitem>
<simpara>Upgrade to 2.4.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>spec.match[].mode: SERVER</literal> in WasmPlugins.</simpara>
</listitem>
<listitem>
<simpara>Remove the previously-added environment variable.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<simpara>The following issues have been resolved in previous releases:</simpara>
<section xml:id="ossm-rn-fixed-issues-ossm_ossm-release-notes">
<title>Service Mesh fixed issues</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-4851">OSSM-4851</link> Previously, an error occurred in the operator deploying new pods in a namespace scoped inside the mesh when <literal>runAsGroup</literal>, <literal>runAsUser</literal>, or <literal>fsGroup</literal> parameters were <literal>nil</literal>. Now, a yaml validation has been added to avoid the <literal>nil</literal> value.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3771">OSSM-3771</link> Previously, OpenShift routes could not be disabled for additional ingress gateways defined in a Service Mesh Control Plane (SMCP). Now, a <literal>routeConfig</literal> block can be added to each <literal>additionalIngress</literal> gateway so the creation of OpenShift routes can be enabled or disabled for each gateway.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-4197">OSSM-4197</link> Previously, if you deployed a v2.2 or v2.1 of the 'ServiceMeshControlPlane' resource, the <literal>/etc/cni/multus/net.d/</literal> directory was not created. As a result, the <literal>istio-cni</literal> pod failed to become ready, and the <literal>istio-cni</literal> pods log contained the following message:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ error   Installer exits with open /host/etc/cni/multus/net.d/v2-2-istio-cni.kubeconfig.tmp.841118073: no such file or directory</programlisting>
<simpara>Now, if you deploy a v2.2 or v2.1 of the 'ServiceMeshControlPlane' resource, the <literal>/etc/cni/multus/net.d/</literal> directory is created, and the <literal>istio-cni</literal> pod becomes ready.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3993">OSSM-3993</link> Previously, Kiali only supported OpenShift OAuth via a proxy on the standard HTTPS port of <literal>443</literal>. Now, Kiali supports OpenShift OAuth over a non-standard HTTPS port. To enable the port, you must set the <literal>spec.server.web_port</literal> field to the proxy&#8217;s non-standard HTTPS port in the Kiali CR.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3936">OSSM-3936</link> Previously, the values for the <literal>injection_label_rev</literal> and <literal>injection_label_name</literal> attributes were hardcoded. This prevented custom configurations from taking effect in the Kiali Custom Resource Definition (CRD). Now, the attribute values are not hardcoded. You can customize the values for the <literal>injection_label_rev</literal> and <literal>injection_label_name</literal> attributes in the <literal>spec.istio_labels</literal> specification.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3644">OSSM-3644</link> Previously, the federation egress-gateway received the wrong update of network gateway endpoints, causing extra endpoint entries. Now, the federation-egress gateway has been updated on the server side so it receives the correct network gateway endpoints.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3595">OSSM-3595</link> Previously, the <literal>istio-cni</literal> plugin sometimes failed on RHEL because SELinux did not allow the utility <literal>iptables-restore</literal> to open files in the <literal>/tmp</literal> directory. Now, SELinux passes <literal>iptables-restore</literal> via <literal>stdin</literal> input stream instead of via a file.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3586">OSSM-3586</link> Previously, Istio proxies were slow to start when Google Cloud Platform (GCP) metadata servers were not available. When you upgrade to Istio 1.14.6, Istio proxies start as expected on GCP, even if metadata servers are not available.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-3025">OSSM-3025</link> Istiod sometimes fails to become ready. Sometimes, when a mesh contained many member namespaces, the Istiod pod did not become ready due to a deadlock within Istiod. The deadlock is now resolved and the pod now starts as expected.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2493">OSSM-2493</link> Default <literal>nodeSelector</literal> and <literal>tolerations</literal> in SMCP not passed to Kiali. The <literal>nodeSelector</literal> and <literal>tolerations</literal> you add to <literal>SMCP.spec.runtime.defaults</literal> are now passed to the Kiali resource.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2492">OSSM-2492</link> Default tolerations in SMCP not passed to Jaeger. The <literal>nodeSelector</literal> and <literal>tolerations</literal> you add to <literal>SMCP.spec.runtime.defaults</literal> are now passed to the Jaeger resource.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2374">OSSM-2374</link> If you deleted one of the <literal>ServiceMeshMember</literal> resources, then the Service Mesh operator deleted the <literal>ServiceMeshMemberRoll</literal>. While this is expected behavior when you delete the last <literal>ServiceMeshMember</literal>, the operator should not delete the <literal>ServiceMeshMemberRoll</literal> if it contains any members in addition to the one that was deleted. This issue is now fixed and the operator only deletes the ServiceMeshMemberRoll when the last <literal>ServiceMeshMember</literal> resource is deleted.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2373">OSSM-2373</link> Error trying to get OAuth metadata when logging in. To fetch the cluster version, the <literal>system:anonymous</literal> account is used. With the cluster&#8217;s default bundled ClusterRoles and ClusterRoleBinding, the anonymous account can fetch the version correctly. If the <literal>system:anonymous</literal> account loses its privileges to fetch the cluster version, OpenShift authentication becomes unusable.</simpara>
<simpara>This is fixed by using the Kiali SA to fetch the cluster version. This also allows for improved security on the cluster.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2371">OSSM-2371</link> Despite Kiali being configured as "view-only," a user can change the proxy logging level via the Workload details' Logs tab&#8217;s kebab menu. This issue has been fixed so the options under "Set Proxy Log Level" are disabled when Kiali is configured as "view-only."</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2344">OSSM-2344</link> Restarting Istiod causes Kiali to flood CRI-O with port-forward requests. This issue occurred when Kiali could not connect to Istiod and Kiali simultaneously issued a large number of requests to istiod. Kiali now limits the number of requests it sends to istiod.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2335">OSSM-2335</link> Dragging the mouse pointer over the Traces scatterchart plot sometimes caused the Kiali console to stop responding due to concurrent backend requests.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2221">OSSM-2221</link> Previously, gateway injection in the <literal>ServiceMeshControlPlane</literal> namespace was not possible because the <literal>ignore-namespace</literal> label was applied to the namespace by default.</simpara>
<simpara>When creating a v2.4 control plane, the namespace no longer has the <literal>ignore-namespace</literal> label applied, and gateway injection is possible.</simpara>
<simpara>In the following example, the <literal>oc label</literal> command removes the <literal>ignore-namespace</literal> label from a namespace in an existing deployment:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;istio_system&gt; maistra.io/ignore-namespace-</programlisting>
<simpara>In the example above, &lt;istio_system&gt; represents the name of the <literal>ServiceMeshControlPlane</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-2053">OSSM-2053</link> Using Red Hat OpenShift Service Mesh Operator 2.2 or 2.3, during SMCP reconciliation, the SMMR controller removed the member namespaces from <literal>SMMR.status.configuredMembers</literal>. This caused the services in the member namespaces to become unavailable for a few moments.</simpara>
<simpara>Using Red Hat OpenShift Service Mesh Operator 2.2 or 2.3, the SMMR controller no longer removes the namespaces from <literal>SMMR.status.configuredMembers</literal>. Instead, the controller adds the namespaces to <literal>SMMR.status.pendingMembers</literal> to indicate that they are not up-to-date. During reconciliation, as each namespace synchronizes with the SMCP, the namespace is automatically removed from <literal>SMMR.status.pendingMembers</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1962">OSSM-1962</link> Use <literal>EndpointSlices</literal> in federation controller. The federation controller now uses <literal>EndpointSlices</literal>, which improves scalability and performance in large deployments. The PILOT_USE_ENDPOINT_SLICE flag is enabled by default. Disabling the flag prevents use of federation deployments.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1668">OSSM-1668</link> A new field <literal>spec.security.jwksResolverCA</literal> was added to the Version 2.1 <literal>SMCP</literal> but was missing in the 2.2.0 and 2.2.1 releases. When upgrading from an Operator version where this field was present to an Operator version that was missing this field, the <literal>.spec.security.jwksResolverCA</literal> field was not available in the <literal>SMCP</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1325">OSSM-1325</link> istiod pod crashes and displays the following error message: <literal>fatal error: concurrent map iteration and map write</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1211">OSSM-1211</link>
Configuring Federated service meshes for failover does not work as expected.</simpara>
<simpara>The Istiod pilot log displays the following error: <literal>envoy connection [C289] TLS error: 337047686:SSL routines:tls_process_server_certificate:certificate verify failed</literal></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1099">OSSM-1099</link>
The Kiali console displayed the message <literal>Sorry, there was a problem. Try a refresh or navigate to a different page.</literal></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1074">OSSM-1074</link>
Pod annotations defined in SMCP are not injected in the pods.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-999">OSSM-999</link>
Kiali retention did not work as expected. Calendar times were greyed out in the dashboard graph.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-797">OSSM-797</link> Kiali Operator pod generates <literal>CreateContainerConfigError</literal> while installing or updating the operator.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-722">OSSM-722</link>
Namespace starting with <literal>kube</literal> is hidden from Kiali.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-569">OSSM-569</link> There is no CPU memory limit for the Prometheus <literal>istio-proxy</literal> container. The Prometheus <literal>istio-proxy</literal> sidecar now uses the resource limits defined in <literal>spec.proxy.runtime.container</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-535">OSSM-535</link> Support validationMessages in SMCP. The <literal>ValidationMessages</literal> field in the Service Mesh Control Plane can now be set to <literal>True</literal>. This writes a log for the status of the resources, which can be helpful when troubleshooting problems.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-449">OSSM-449</link> VirtualService and Service causes an error "Only unique values for domains are permitted. Duplicate entry of domain."</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-419">OSSM-419</link> Namespaces with similar names will all show in Kiali namespace list, even though namespaces may not be defined in Service Mesh Member Role.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-296">OSSM-296</link> When adding health configuration to the Kiali custom resource (CR) is it not being replicated to the Kiali configmap.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-291">OSSM-291</link> In the Kiali console, on the Applications, Services, and Workloads pages, the "Remove Label from Filters" function is not working.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-289">OSSM-289</link> In the Kiali console, on the Service Details pages for the 'istio-ingressgateway' and 'jaeger-query' services there are no Traces being displayed. The traces exist in Jaeger.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-287">OSSM-287</link> In the Kiali console there are no traces being displayed on the Graph Service.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-285">OSSM-285</link> When trying to access the Kiali console, receive the following error message "Error trying to get OAuth Metadata".</simpara>
<simpara>Workaround: Restart the Kiali pod.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2735">MAISTRA-2735</link> The resources that the Service Mesh Operator deletes when reconciling the SMCP changed in Red Hat OpenShift Service Mesh version 2.1. Previously, the Operator deleted a resource with the following labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>maistra.io/owner</literal></simpara>
</listitem>
<listitem>
<simpara><literal>app.kubernetes.io/version</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Now, the Operator ignores resources that does not also include the <literal>app.kubernetes.io/managed-by=maistra-istio-operator</literal> label. If you create your own resources, you should not add the <literal>app.kubernetes.io/managed-by=maistra-istio-operator</literal> label to them.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-2687">MAISTRA-2687</link> Red Hat OpenShift Service Mesh 2.1 federation gateway does not send the full certificate chain when using external certificates. The Service Mesh federation egress gateway only sends the client certificate. Because the federation ingress gateway only knows about the root certificate, it cannot verify the client certificate unless you add the root certificate to the federation import <literal>ConfigMap</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2635">MAISTRA-2635</link> Replace deprecated Kubernetes API. To remain compatible with OpenShift Container Platform 4.8, the <literal>apiextensions.k8s.io/v1beta1</literal> API was deprecated as of Red Hat OpenShift Service Mesh 2.0.8.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2631">MAISTRA-2631</link> The WASM feature is not working because podman is failing due to nsenter binary not being present. Red Hat OpenShift Service Mesh generates the following error message: <literal>Error: error configuring CNI network plugin exec: "nsenter": executable file not found in $PATH</literal>. The container image now contains nsenter and WASM works as expected.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2534">MAISTRA-2534</link> When istiod attempted to fetch the JWKS for an issuer specified in a JWT rule, the issuer service responded with a 502.  This prevented the proxy container from becoming ready and caused deployments to hang. The fix for the <link xlink:href="https://github.com/istio/istio/issues/24629">community bug</link> has been included in the  Service Mesh 2.0.7 release.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-2411">MAISTRA-2411</link> When the Operator creates a new ingress gateway using <literal>spec.gateways.additionaIngress</literal> in the <literal>ServiceMeshControlPlane</literal>, Operator is not creating a <literal>NetworkPolicy</literal> for the additional ingress gateway like it does for the default istio-ingressgateway. This is causing a 503 response from the route of the new gateway.</simpara>
<simpara>Workaround: Manually create the <literal>NetworkPolicy</literal> in the &lt;istio-system&gt; namespace.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2401">MAISTRA-2401</link> CVE-2021-3586 servicemesh-operator: NetworkPolicy resources incorrectly specified ports for ingress resources. The NetworkPolicy resources installed for Red Hat OpenShift Service Mesh did not properly specify which ports could be accessed. This allowed access to all ports on these resources from any pod. Network policies applied to the following resources are affected:</simpara>
<itemizedlist>
<listitem>
<simpara>Galley</simpara>
</listitem>
<listitem>
<simpara>Grafana</simpara>
</listitem>
<listitem>
<simpara>Istiod</simpara>
</listitem>
<listitem>
<simpara>Jaeger</simpara>
</listitem>
<listitem>
<simpara>Kiali</simpara>
</listitem>
<listitem>
<simpara>Prometheus</simpara>
</listitem>
<listitem>
<simpara>Sidecar injector</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2378">MAISTRA-2378</link> When the cluster is configured to use OpenShift SDN with <literal>ovs-multitenant</literal> and the mesh contains a large number of namespaces (200+), the OpenShift Container Platform networking plugin is unable to configure the namespaces quickly. Service Mesh times out causing namespaces to be continuously dropped from the service mesh and then reenlisted.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2370">MAISTRA-2370</link> Handle tombstones in listerInformer. The updated cache codebase was not handling tombstones when translating the events from the namespace caches to the aggregated cache, leading to a panic in the go routine.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2117">MAISTRA-2117</link> Add optional <literal>ConfigMap</literal> mount to operator. The CSV now contains an optional <literal>ConfigMap</literal> volume mount, which mounts the <literal>smcp-templates</literal> <literal>ConfigMap</literal> if it exists. If the <literal>smcp-templates</literal> <literal>ConfigMap</literal> does not exist, the mounted directory is empty. When you create the <literal>ConfigMap</literal>, the directory is populated with the entries from the <literal>ConfigMap</literal> and can be referenced in <literal>SMCP.spec.profiles</literal>. No restart of the Service Mesh operator is required.</simpara>
<simpara>Customers using the 2.0 operator with a modified CSV to mount the smcp-templates ConfigMap can upgrade to Red Hat OpenShift Service Mesh 2.1. After upgrading, you can continue using an existing ConfigMap, and the profiles it contains, without editing the CSV. Customers that previously used ConfigMap with a different name will either have to rename the ConfigMap or update the CSV after upgrading.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2010">MAISTRA-2010</link> AuthorizationPolicy does not support <literal>request.regex.headers</literal> field. The <literal>validatingwebhook</literal> rejects any AuthorizationPolicy with the field, and even if you disable that, Pilot tries to validate it using the same code, and it does not work.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-1979">MAISTRA-1979</link> <emphasis>Migration to 2.0</emphasis> The conversion webhook drops the following important fields when converting <literal>SMCP.status</literal> from v2 to v1:</simpara>
<itemizedlist>
<listitem>
<simpara>conditions</simpara>
</listitem>
<listitem>
<simpara>components</simpara>
</listitem>
<listitem>
<simpara>observedGeneration</simpara>
</listitem>
<listitem>
<simpara>annotations</simpara>
<simpara>Upgrading the operator to 2.0 might break client tools that read the SMCP status using the maistra.io/v1 version of the resource.</simpara>
<simpara>This also causes the READY and STATUS columns to be empty when you run <literal>oc get servicemeshcontrolplanes.v1.maistra.io</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-1947">MAISTRA-1947</link> <emphasis>Technology Preview</emphasis> Updates to ServiceMeshExtensions are not applied.</simpara>
<simpara>Workaround: Remove and recreate the <literal>ServiceMeshExtensions</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-1983">MAISTRA-1983</link> <emphasis>Migration to 2.0</emphasis> Upgrading to 2.0.0 with an existing invalid <literal>ServiceMeshControlPlane</literal> cannot easily be repaired. The invalid items in the <literal>ServiceMeshControlPlane</literal> resource caused an unrecoverable error. The fix makes the errors recoverable. You can delete the invalid resource and replace it with a new one or edit the resource to fix the errors. For more information about editing your resource, see [Configuring the Red Hat OpenShift Service Mesh installation].</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-1502">MAISTRA-1502</link> As a result of CVEs fixes in version 1.0.10, the Istio dashboards are not available from the <emphasis role="strong">Home Dashboard</emphasis> menu in Grafana. To access the Istio dashboards, click the <emphasis role="strong">Dashboard</emphasis> menu in the navigation panel and select the <emphasis role="strong">Manage</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-1399">MAISTRA-1399</link> Red Hat OpenShift Service Mesh no longer prevents you from installing unsupported CNI protocols. The supported network configurations has not changed.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-1089">MAISTRA-1089</link> <emphasis>Migration to 2.0</emphasis> Gateways created in a non-control plane namespace are automatically deleted. After removing the gateway definition from the SMCP spec, you need to manually delete these resources.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-858">MAISTRA-858</link> The following Envoy log messages describing <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/intro/deprecated">deprecated options and configurations associated with Istio 1.1.x</link> are expected:</simpara>
<itemizedlist>
<listitem>
<simpara>[2019-06-03 07:03:28.943][19][warning][misc] [external/envoy/source/common/protobuf/utility.cc:129] Using deprecated option 'envoy.api.v2.listener.Filter.config'. This configuration will be removed from Envoy soon.</simpara>
</listitem>
<listitem>
<simpara>[2019-08-12 22:12:59.001][13][warning][misc] [external/envoy/source/common/protobuf/utility.cc:174] Using deprecated option 'envoy.api.v2.Listener.use_original_dst' from file lds.proto. This configuration will be removed from Envoy soon.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-806">MAISTRA-806</link> Evicted Istio Operator Pod causes mesh and CNI not to deploy.</simpara>
<simpara>Workaround: If the <literal>istio-operator</literal> pod is evicted while deploying the control pane, delete the evicted <literal>istio-operator</literal> pod.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-681">MAISTRA-681</link> When the Service Mesh control plane has many namespaces, it can lead to performance issues.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-193">MAISTRA-193</link> Unexpected console info messages are visible when health checking is enabled for citadel.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1821432">Bugzilla 1821432</link> The toggle controls in OpenShift Container Platform Custom Resource details page does not update the CR correctly. UI Toggle controls in the Service Mesh Control Plane (SMCP) Overview page in the OpenShift Container Platform web console sometimes updates the wrong field in the resource. To update a SMCP, edit the YAML content directly or update the resource from the command line instead of clicking the toggle controls.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ossm-architecture">
<title>Understanding Service Mesh</title>

<simpara>Red Hat OpenShift Service Mesh provides a platform for behavioral insight and operational control over your networked microservices in a service mesh. With Red Hat OpenShift Service Mesh, you can connect, secure, and monitor microservices in your OpenShift Container Platform environment.</simpara>
<section xml:id="ossm-understanding-service-mesh_ossm-architecture">
<title>Understanding service mesh</title>
<simpara>A <emphasis>service mesh</emphasis> is the network of microservices that make up applications in a distributed microservice architecture and the interactions between those microservices. When a Service Mesh grows in size and complexity, it can become harder to understand and manage.</simpara>
<simpara>Based on the open source <link xlink:href="https://istio.io/">Istio</link> project, Red Hat OpenShift Service Mesh adds a transparent layer on existing distributed applications without requiring any changes to the service code. You add Red Hat OpenShift Service Mesh support to services by deploying a special sidecar proxy to relevant services in the mesh that intercepts all network communication between microservices. You configure and manage the Service Mesh using the Service Mesh control plane features.</simpara>
<simpara>Red Hat OpenShift Service Mesh gives you an easy way to create a network of deployed services that provide:</simpara>
<itemizedlist>
<listitem>
<simpara>Discovery</simpara>
</listitem>
<listitem>
<simpara>Load balancing</simpara>
</listitem>
<listitem>
<simpara>Service-to-service authentication</simpara>
</listitem>
<listitem>
<simpara>Failure recovery</simpara>
</listitem>
<listitem>
<simpara>Metrics</simpara>
</listitem>
<listitem>
<simpara>Monitoring</simpara>
</listitem>
</itemizedlist>
<simpara>Red Hat OpenShift Service Mesh also provides more complex operational functions including:</simpara>
<itemizedlist>
<listitem>
<simpara>A/B testing</simpara>
</listitem>
<listitem>
<simpara>Canary releases</simpara>
</listitem>
<listitem>
<simpara>Access control</simpara>
</listitem>
<listitem>
<simpara>End-to-end authentication</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-architecture_ossm-architecture">
<title>Service Mesh architecture</title>
<simpara>Service mesh technology operates at the network communication level. That is, service mesh components capture or intercept traffic to and from microservices, either modifying requests, redirecting them, or creating new requests to other services.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-architecture.png"/>
</imageobject>
<textobject><phrase>Service Mesh architecture image</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>At a high level, Red Hat OpenShift Service Mesh consists of a data plane and a control plane</simpara>
<simpara>The <emphasis role="strong">data plane</emphasis> is a set of intelligent proxies, running alongside application containers in a pod, that intercept and control all inbound and outbound network communication between microservices in the service mesh.
The data plane is implemented in such a way that it intercepts all inbound (ingress) and outbound (egress) network traffic. The Istio data plane is composed of Envoy containers running along side application containers in a pod. The Envoy container acts as a proxy, controlling all network communication into and out of the pod.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Envoy proxies</emphasis> are the only Istio components that interact with data plane traffic. All incoming (ingress) and outgoing (egress) network traffic between services flows through the proxies. The Envoy proxy also collects all metrics related to services traffic within the mesh. Envoy proxies are deployed as sidecars, running in the same pod as services. Envoy proxies are also used to implement mesh gateways.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Sidecar proxies</emphasis> manage inbound and outbound communication for their workload instance.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Gateways</emphasis> are proxies operating as load balancers receiving incoming or outgoing HTTP/TCP connections. Gateway configurations are applied to standalone Envoy proxies that are running at the edge of the mesh, rather than sidecar Envoy proxies running alongside your service workloads. You use a Gateway to manage inbound and outbound traffic for your mesh, letting you specify which traffic you want to enter or leave the mesh.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Ingress-gateway</emphasis> - Also known as an Ingress Controller, the Ingress Gateway is a dedicated Envoy proxy that receives and controls traffic entering the service mesh. An Ingress Gateway allows features such as monitoring and route rules to be applied to traffic entering the cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Egress-gateway</emphasis> - Also known as an egress controller, the Egress Gateway is a dedicated Envoy proxy that manages traffic leaving the service mesh. An Egress Gateway allows features such as monitoring and route rules to be applied to traffic exiting the mesh.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The <emphasis role="strong">control plane</emphasis> manages and configures the proxies that make up the data plane. It is the authoritative source for configuration, manages access control and usage policies, and collects metrics from the proxies in the service mesh.</simpara>
<itemizedlist>
<listitem>
<simpara>The Istio control plane is composed of <emphasis role="strong">Istiod</emphasis> which consolidates several previous control plane components (Citadel, Galley, Pilot) into a single binary. Istiod provides service discovery, configuration, and certificate management. It converts high-level routing rules to Envoy configurations and propagates them to the sidecars at runtime.</simpara>
<itemizedlist>
<listitem>
<simpara>Istiod can act as a Certificate Authority (CA), generating certificates supporting secure mTLS communication in the data plane. You can also use an external CA for this purpose.</simpara>
</listitem>
<listitem>
<simpara>Istiod is responsible for injecting sidecar proxy containers into workloads deployed to an OpenShift cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Red Hat OpenShift Service Mesh uses the <emphasis role="strong">istio-operator</emphasis> to manage the installation of the control plane. An <emphasis>Operator</emphasis> is a piece of software that enables you to implement and automate common activities in your OpenShift cluster. It acts as a controller, allowing you to set or change the desired state of objects in your cluster, in this case, a Red Hat OpenShift Service Mesh installation.</simpara>
<simpara>Red Hat OpenShift Service Mesh also bundles the following Istio add-ons as part of the product:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kiali</emphasis> - Kiali is the management console for Red Hat OpenShift Service Mesh. It provides dashboards, observability, and robust configuration and validation capabilities. It shows the structure of your service mesh by inferring traffic topology and displays the health of your mesh. Kiali provides detailed metrics, powerful validation, access to Grafana, and strong integration with the distributed tracing platform (Jaeger).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Prometheus</emphasis> - Red Hat OpenShift Service Mesh uses Prometheus to store telemetry information from services. Kiali depends on Prometheus to obtain metrics, health status, and mesh topology.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger</emphasis> - Red Hat OpenShift Service Mesh supports the distributed tracing platform (Jaeger). Jaeger is an open source traceability server that centralizes and displays traces associated with a single request between multiple services. Using the distributed tracing platform (Jaeger) you can monitor and troubleshoot your microservices-based distributed systems.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Elasticsearch</emphasis> - Elasticsearch is an open source, distributed, JSON-based search and analytics engine. The distributed tracing platform (Jaeger) uses Elasticsearch for persistent storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Grafana</emphasis> - Grafana provides mesh administrators with advanced query and metrics analysis and dashboards for Istio data. Optionally, Grafana can be used to analyze service mesh metrics.</simpara>
</listitem>
</itemizedlist>
<simpara>The following Istio integrations are supported with Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">3scale</emphasis> - Istio provides an optional integration with Red Hat 3scale API Management solutions. For versions prior to 2.1, this integration was achieved via the 3scale Istio adapter. For version 2.1 and later, the 3scale integration is achieved via a WebAssembly module.</simpara>
</listitem>
</itemizedlist>
<simpara>For information about how to install the 3scale adapter, refer to the <link xlink:href="../../service_mesh/v2x/threescale-adapter.xml#threescale-adapter">3scale Istio adapter documentation</link></simpara>
</section>
<section xml:id="_understanding_kiali">
<title>Understanding Kiali</title>
<simpara>Kiali provides visibility into your service mesh by showing you the microservices in your service mesh, and how they are connected.</simpara>
<section xml:id="ossm-kiali-overview_ossm-architecture">
<title>Kiali overview</title>
<simpara>Kiali provides observability into the Service Mesh running on OpenShift Container Platform. Kiali helps you define, validate, and observe your Istio service mesh. It helps you to understand the structure of your service mesh by inferring the topology, and also provides information about the health of your service mesh.</simpara>
<simpara>Kiali provides an interactive graph view of your namespace in real time that provides visibility into features like circuit breakers, request rates, latency, and even graphs of traffic flows. Kiali offers insights about components at different levels, from Applications to Services and Workloads, and can display the interactions with contextual information and charts on the selected graph node or edge. Kiali also provides the ability to validate your Istio configurations, such as gateways, destination rules, virtual services, mesh policies, and more. Kiali provides detailed metrics, and a basic Grafana integration is available for advanced queries. Distributed tracing is provided by integrating Jaeger into the Kiali console.</simpara>
<simpara>Kiali is installed by default as part of the Red Hat OpenShift Service Mesh.</simpara>
</section>
<section xml:id="ossm-kiali-architecture_ossm-architecture">
<title>Kiali architecture</title>
<simpara>Kiali is based on the open source <link xlink:href="https://kiali.io/">Kiali project</link>. Kiali is composed of two components: the Kiali application and the Kiali console.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kiali application</emphasis> (back end) – This component runs in the container application platform and communicates with the service mesh components, retrieves and processes data, and exposes this data to the console. The Kiali application does not need storage. When deploying the application to a cluster, configurations are set in ConfigMaps and secrets.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Kiali console</emphasis> (front end) – The Kiali console is a web application. 	The Kiali application serves the Kiali console, which then queries the back end for data to present it to the user.</simpara>
</listitem>
</itemizedlist>
<simpara>In addition, Kiali depends on external services and components provided by the container application platform and Istio.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Red Hat Service Mesh</emphasis> (Istio) - Istio is a Kiali requirement. Istio is the component that provides and controls the service mesh. Although Kiali and Istio can be installed separately, Kiali depends on Istio and will not work if it is not present. Kiali needs to retrieve Istio data and configurations, which are exposed through Prometheus and the cluster API.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Prometheus</emphasis> - A dedicated Prometheus instance is included as part of the Red Hat OpenShift Service Mesh installation. When Istio telemetry is enabled, metrics data are stored in Prometheus. Kiali uses this Prometheus data to determine the mesh topology, display metrics, calculate health, show possible problems, and so on. Kiali communicates directly with Prometheus and assumes the data schema used by Istio Telemetry. Prometheus is an Istio dependency and a hard dependency for Kiali, and many of Kiali&#8217;s features will not work without Prometheus.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cluster API</emphasis> - Kiali uses the API of the OpenShift Container Platform (cluster API) to fetch and resolve service mesh configurations. Kiali queries the cluster API to retrieve, for example, definitions for namespaces, services, deployments, pods, and other entities. Kiali also makes queries to resolve relationships between the different cluster entities. The cluster API is also queried to retrieve Istio configurations like virtual services, destination rules, route rules, gateways, quotas, and so on.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger</emphasis> - Jaeger is optional, but is installed by default as part of the Red Hat OpenShift Service Mesh installation. When you install the distributed tracing platform (Jaeger) as part of the default Red Hat OpenShift Service Mesh installation, the Kiali console includes a tab to display distributed tracing data. Note that tracing data will not be available if you disable Istio&#8217;s distributed tracing feature. Also note that user must have access to the namespace where the Service Mesh control plane is installed to view tracing data.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Grafana</emphasis> - Grafana is optional, but is installed by default as part of the Red Hat OpenShift Service Mesh installation. When available, the metrics pages of Kiali display links to direct the user to the same metric in Grafana. Note that user must have access to the namespace where the Service Mesh control plane is installed to view links to the Grafana dashboard and view Grafana data.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-kiali-features_ossm-architecture">
<title>Kiali features</title>
<simpara>The Kiali console is integrated with Red Hat Service Mesh and provides the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Health</emphasis> – Quickly identify issues with applications, services, or workloads.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Topology</emphasis> – Visualize how your applications, services, or workloads communicate via the Kiali graph.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Metrics</emphasis> – Predefined metrics dashboards let you chart service mesh and application performance for Go, Node.js. Quarkus, Spring Boot, Thorntail and Vert.x. You can also create your own custom dashboards.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Tracing</emphasis> – Integration with Jaeger lets you follow the path of a request through various microservices that make up an application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Validations</emphasis> – Perform advanced validations on the most common Istio objects (Destination Rules, Service Entries, Virtual Services, and so on).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Configuration</emphasis> – Optional ability to create, update and delete Istio routing configuration using wizards or directly in the YAML editor in the Kiali Console.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_understanding_distributed_tracing">
<title>Understanding distributed tracing</title>
<simpara>Every time a user takes an action in an application, a request is executed by the architecture that may require dozens of different services to participate to produce a response.
The path of this request is a distributed transaction. The distributed tracing platform (Jaeger) lets you perform distributed tracing, which follows the path of a request through various microservices that make up an application.</simpara>
<simpara><emphasis role="strong">Distributed tracing</emphasis> is a technique that is used to tie the information about different units of work together—usually executed in different processes or hosts—to understand a whole chain of events in a distributed transaction.
Distributed tracing lets developers visualize call flows in large service oriented architectures.
It can be invaluable in understanding serialization, parallelism, and sources of latency.</simpara>
<simpara>The distributed tracing platform (Jaeger) records the execution of individual requests across the whole stack of microservices, and presents them as traces. A <emphasis role="strong">trace</emphasis> is a data/execution path through the system. An end-to-end trace comprises one or more spans.</simpara>
<simpara>A <emphasis role="strong">span</emphasis> represents a logical unit of work that has an operation name, the start time of the operation, and the duration. Spans may be nested and ordered to model causal relationships.</simpara>
<section xml:id="distr-tracing-product-overview_ossm-architecture">
<title>Distributed tracing overview</title>
<simpara>As a service owner, you can use distributed tracing to instrument your services to gather insights into your service architecture.
You can use the Red Hat OpenShift distributed tracing platform for monitoring, network profiling, and troubleshooting the interaction between components in modern, cloud-native, microservices-based applications.</simpara>
<simpara>With the distributed tracing platform, you can perform the following functions:</simpara>
<itemizedlist>
<listitem>
<simpara>Monitor distributed transactions</simpara>
</listitem>
<listitem>
<simpara>Optimize performance and latency</simpara>
</listitem>
<listitem>
<simpara>Perform root cause analysis</simpara>
</listitem>
</itemizedlist>
<simpara>The distributed tracing platform consists of three components:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger)</emphasis>, which is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger project</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Tempo)</emphasis>, which is based on the open source <link xlink:href="https://grafana.com/oss/tempo/">Grafana Tempo project</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat build of OpenTelemetry</emphasis>, which is based on the open source <link xlink:href="https://opentelemetry.io/">OpenTelemetry project</link>.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Jaeger does not use FIPS validated cryptographic modules.</simpara>
</important>
</section>
<section xml:id="distr-tracing-architecture_ossm-architecture">
<title>Red Hat OpenShift distributed tracing platform architecture</title>
<simpara>Red Hat OpenShift distributed tracing platform is made up of several components that work together to collect, store, and display tracing data.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger)</emphasis> - This component is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger project</link>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Client</emphasis> (Jaeger client, Tracer, Reporter, instrumented application, client libraries)- The distributed tracing platform (Jaeger) clients are language-specific implementations of the OpenTracing API. They can be used to instrument applications for distributed tracing either manually or with a variety of existing open source frameworks, such as Camel (Fuse), Spring Boot (RHOAR), MicroProfile (RHOAR/Thorntail), Wildfly (EAP), and many more, that are already integrated with OpenTracing.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Agent</emphasis> (Jaeger agent, Server Queue, Processor Workers) - The distributed tracing platform (Jaeger) agent is a network daemon that listens for spans sent over User Datagram Protocol (UDP), which it batches and sends to the Collector. The agent is meant to be placed on the same host as the instrumented application. This is typically accomplished by having a sidecar in container environments such as Kubernetes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger Collector</emphasis> (Collector, Queue, Workers) - Similar to the Jaeger agent, the Jaeger Collector receives spans and places them in an internal queue for processing. This allows the Jaeger Collector to return immediately to the client/agent instead of waiting for the span to make its way to the storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Storage</emphasis> (Data Store) - Collectors require a persistent storage backend. Red Hat OpenShift distributed tracing platform (Jaeger) has a pluggable mechanism for span storage. Note that for this release, the only supported storage is Elasticsearch.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Query</emphasis> (Query Service) - Query is a service that retrieves traces from storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Ingester</emphasis> (Ingester Service) - Red Hat OpenShift distributed tracing platform can use Apache Kafka as a buffer between the Collector and the actual Elasticsearch backing storage. Ingester is a service that reads data from Kafka and writes to the Elasticsearch storage backend.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger Console</emphasis> – With the Red Hat OpenShift distributed tracing platform (Jaeger) user interface, you can visualize your distributed tracing data. On the Search page, you can find traces and explore details of the spans that make up an individual trace.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Tempo)</emphasis> - This component is based on the open source <link xlink:href="https://grafana.com/oss/tempo/">Grafana Tempo project</link>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Gateway</emphasis> – The Gateway handles authentication, authorization, and forwarding requests to the Distributor or Query front-end service.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Distributor</emphasis> – The Distributor accepts spans in multiple formats including Jaeger, OpenTelemetry, and Zipkin. It routes spans to Ingesters by hashing the <literal>traceID</literal> and using a distributed consistent hash ring.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Ingester</emphasis> – The Ingester batches a trace into blocks, creates bloom filters and indexes, and then flushes it all to the back end.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Query Frontend</emphasis> – The Query Frontend is responsible for sharding the search space for an incoming query. The search query is then sent to the Queriers. The Query Frontend deployment exposes the Jaeger UI through the Tempo Query sidecar.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Querier</emphasis> - The Querier is responsible for finding the requested trace ID in either the Ingesters or the back-end storage. Depending on parameters, it can query the Ingesters and pull Bloom indexes from the back end to search blocks in object storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Compactor</emphasis> – The Compactors stream blocks to and from the back-end storage to reduce the total number of blocks.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat build of OpenTelemetry</emphasis> - This component is based on the open source <link xlink:href="https://opentelemetry.io/">OpenTelemetry project</link>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">OpenTelemetry Collector</emphasis> - The OpenTelemetry Collector is a vendor-agnostic way to receive, process, and export telemetry data. The OpenTelemetry Collector supports open-source observability data formats, for example, Jaeger and Prometheus, sending to one or more open-source or commercial back-ends. The Collector is the default location instrumentation libraries export their telemetry data.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="distr-tracing-features_ossm-architecture">
<title>Red Hat OpenShift distributed tracing platform features</title>
<simpara>Red Hat OpenShift distributed tracing platform provides the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Integration with Kiali – When properly configured, you can view distributed tracing platform data from the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>High scalability – The distributed tracing platform back end is designed to have no single points of failure and to scale with the business needs.</simpara>
</listitem>
<listitem>
<simpara>Distributed Context Propagation – Enables you to connect data from different components together to create a complete end-to-end trace.</simpara>
</listitem>
<listitem>
<simpara>Backwards compatibility with Zipkin – Red Hat OpenShift distributed tracing platform has APIs that enable it to be used as a drop-in replacement for Zipkin, but Red Hat is not supporting Zipkin compatibility in this release.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_next_steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/preparing-ossm-installation.xml#preparing-ossm-installation">Prepare to install Red Hat OpenShift Service Mesh</link> in your OpenShift Container Platform environment.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-deployment-models">
<title>Service mesh deployment models</title>

<simpara>Red Hat OpenShift Service Mesh supports several different deployment models that can be combined in different ways to best suit your business requirements.</simpara>
<simpara>In Istio, a tenant is a group of users that share common access and privileges for a set of deployed workloads. You can use tenants to provide a level of isolation between different teams. You can segregate access to different tenants using <literal>NetworkPolicies</literal>, <literal>AuthorizationPolicies</literal>, and <literal>exportTo</literal> annotations on istio.io or service resources.</simpara>
<section xml:id="ossm-deploy-cluster-wide-mesh_ossm-deployment-models">
<title>Cluster-Wide (Single Tenant) mesh deployment model</title>
<simpara>A cluster-wide deployment contains a Service Mesh Control Plane that monitors resources for an entire cluster. Monitoring resources for an entire cluster closely resembles Istio functionality in that the control plane uses a single query across all namespaces to monitor Istio and Kubernetes resources. As a result, cluster-wide deployments decrease the number of requests sent to the API server.</simpara>
<simpara>Similar to Istio, a cluster-wide mesh includes namespaces with the <literal>istio-injection=enabled</literal> namespace label by default. You can change this label by modifying the <literal>spec.labelSelectors</literal> field of the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</section>
<section xml:id="ossm-deploy-multitenant_ossm-deployment-models">
<title>Multitenant deployment model</title>
<simpara>Red Hat OpenShift Service Mesh installs a <literal>ServiceMeshControlPlane</literal> that is configured for multitenancy by default. Red Hat OpenShift Service Mesh uses a multitenant Operator to manage the Service Mesh control plane lifecycle. Within a mesh, namespaces are used for tenancy.</simpara>
<simpara>Red Hat OpenShift Service Mesh uses <literal>ServiceMeshControlPlane</literal> resources to manage mesh installations, whose scope is limited by default to namespace that contains the resource. You use <literal>ServiceMeshMemberRoll</literal> and <literal>ServiceMeshMember</literal> resources to include additional namespaces into the mesh. A namespace can only be included in a single mesh, and multiple meshes can be installed in a single OpenShift cluster.</simpara>
<simpara>Typical service mesh deployments use a single Service Mesh control plane to configure communication between services in the mesh. Red Hat OpenShift Service Mesh supports “soft multitenancy”, where there is one control plane and one mesh per tenant, and there can be multiple independent control planes within the cluster. Multitenant deployments specify the projects that can access the Service Mesh and isolate the Service Mesh from other control plane instances.</simpara>
<simpara>The cluster administrator gets control and visibility across all the Istio control planes, while the tenant administrator only gets control over their specific Service Mesh, Kiali, and Jaeger instances.</simpara>
<simpara>You can grant a team permission to deploy its workloads only to a given namespace or set of namespaces. If granted the <literal>mesh-user</literal> role by the service mesh administrator, users can create a <literal>ServiceMeshMember</literal> resource to add namespaces to the <literal>ServiceMeshMemberRoll</literal>.</simpara>
</section>
<section xml:id="ossm-deploy-multi-mesh_ossm-deployment-models">
<title>Multimesh or federated deployment model</title>
<simpara><emphasis>Federation</emphasis> is a deployment model that lets you share services and workloads between separate meshes managed in distinct administrative domains.</simpara>
<simpara>The Istio multi-cluster model requires a high level of trust between meshes and remote access to all Kubernetes API servers on which the individual meshes reside. Red Hat OpenShift Service Mesh federation takes an opinionated approach to a multi-cluster implementation of Service Mesh that assumes <emphasis>minimal</emphasis> trust between meshes.</simpara>
<simpara>A <emphasis>federated mesh</emphasis> is a group of meshes behaving as a single mesh. The services in each mesh can be unique services, for example a mesh adding services by importing them from another mesh, can provide additional workloads for the same services across the meshes, providing high availability, or a combination of both. All meshes that are joined into a federated mesh remain managed individually, and you must explicitly configure which services are exported to and imported from other meshes in the federation. Support functions such as certificate generation, metrics and trace collection remain local in their respective meshes.</simpara>
</section>
</section>
<section xml:id="ossm-vs-community">
<title>Service Mesh and Istio differences</title>

<simpara>Red Hat OpenShift Service Mesh differs from an installation of Istio to provide additional features or to handle differences when deploying on OpenShift Container Platform.</simpara>
<section xml:id="ossm-vs-istio_ossm-vs-istio">
<title>Differences between Istio and Red Hat OpenShift Service Mesh</title>
<simpara>The following features are different in Service Mesh and Istio.</simpara>
<section xml:id="ossm-cli-tool_ossm-vs-istio">
<title>Command line tool</title>
<simpara>The command line tool for Red Hat OpenShift Service Mesh is <literal>oc</literal>.  Red Hat OpenShift Service Mesh does not support <literal>istioctl</literal>.</simpara>
</section>
<section xml:id="ossm-installation-upgrade_ossm-vs-istio">
<title>Installation and upgrades</title>
<simpara>Red Hat OpenShift Service Mesh does not support Istio installation profiles.</simpara>
<simpara>Red Hat OpenShift Service Mesh does not support canary upgrades of the service mesh.</simpara>
</section>
<section xml:id="ossm-automatic-injection_ossm-vs-istio">
<title>Automatic injection</title>
<simpara>The upstream Istio community installation automatically injects the sidecar into pods within the projects you have labeled.</simpara>
<simpara>Red Hat OpenShift Service Mesh does not automatically inject the sidecar into any pods, but you must opt in to injection using an annotation without labeling projects. This method requires fewer privileges and does not conflict with other OpenShift Container Platform capabilities such as builder pods. To enable automatic injection, specify the <literal>sidecar.istio.io/inject</literal> label, or annotation, as described in the <emphasis>Automatic sidecar injection</emphasis> section.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Sidecar injection label and annotation settings</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top">Upstream Istio</entry>
<entry align="left" valign="top">Red Hat OpenShift Service Mesh</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Namespace Label</simpara></entry>
<entry align="left" valign="top"><simpara>supports "enabled" and "disabled"</simpara></entry>
<entry align="left" valign="top"><simpara>supports "disabled"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pod Label</simpara></entry>
<entry align="left" valign="top"><simpara>supports "true" and "false"</simpara></entry>
<entry align="left" valign="top"><simpara>supports "true" and "false"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pod Annotation</simpara></entry>
<entry align="left" valign="top"><simpara>supports "false" only</simpara></entry>
<entry align="left" valign="top"><simpara>supports "true" and "false"</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-rbac_ossm-vs-istio">
<title>Istio Role Based Access Control features</title>
<simpara>Istio Role Based Access Control (RBAC) provides a mechanism you can use to control access to a service. You can identify subjects by user name or by specifying a set of properties and apply access controls accordingly.</simpara>
<simpara>The upstream Istio community installation includes options to perform exact header matches, match wildcards in headers, or check for a header containing a specific prefix or suffix.</simpara>
<simpara>Red Hat OpenShift Service Mesh extends the ability to match request headers by using a regular expression. Specify a property key of <literal>request.regex.headers</literal> with a regular expression.</simpara>
<formalpara>
<title>Upstream Istio community matching request headers example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: httpbin-usernamepolicy
spec:
  action: ALLOW
  rules:
    - when:
        - key: 'request.regex.headers[username]'
          values:
            - "allowed.*"
  selector:
    matchLabels:
      app: httpbin</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-openssl_ossm-vs-istio">
<title>OpenSSL</title>
<simpara>Red Hat OpenShift Service Mesh replaces BoringSSL with OpenSSL. OpenSSL is a software library that contains an open source implementation of the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols. The Red Hat OpenShift Service Mesh Proxy binary dynamically links the OpenSSL libraries (libssl and libcrypto) from the underlying Red Hat Enterprise Linux operating system.</simpara>
</section>
<section xml:id="ossm-external-workloads_ossm-vs-istio">
<title>External workloads</title>
<simpara>Red Hat OpenShift Service Mesh does not support external workloads, such as virtual machines running outside OpenShift on bare metal servers.</simpara>
</section>
<section xml:id="ossm-virtual-machine-support_ossm-vs-istio">
<title>Virtual Machine Support</title>
<simpara>You can deploy virtual machines to OpenShift using OpenShift Virtualization. Then, you can apply a mesh policy, such as mTLS or AuthorizationPolicy, to these virtual machines, just like any other pod that is part of a mesh.</simpara>
</section>
<section xml:id="ossm-component-modifications_ossm-vs-istio">
<title>Component modifications</title>
<itemizedlist>
<listitem>
<simpara>A <emphasis>maistra-version</emphasis> label has been added to all resources.</simpara>
</listitem>
<listitem>
<simpara>All Ingress resources have been converted to OpenShift Route resources.</simpara>
</listitem>
<listitem>
<simpara>Grafana, distributed tracing (Jaeger), and Kiali are enabled by default and exposed through OpenShift routes.</simpara>
</listitem>
<listitem>
<simpara>Godebug has been removed from all templates</simpara>
</listitem>
<listitem>
<simpara>The <literal>istio-multi</literal> ServiceAccount and ClusterRoleBinding have been removed, as well as the <literal>istio-reader</literal> ClusterRole.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-envoy-filters_ossm-vs-istio">
<title>Envoy filters</title>
<simpara>Red Hat OpenShift Service Mesh does not support <literal>EnvoyFilter</literal> configuration except where explicitly documented. Due to tight coupling with the underlying Envoy APIs, backward compatibility cannot be maintained. <literal>EnvoyFilter</literal> patches are very sensitive to the format of the Envoy configuration that is generated by Istio. If the configuration generated by Istio changes, it has the potential to break the application of the <literal>EnvoyFilter</literal>.</simpara>
</section>
<section xml:id="ossm-envoy-services_ossm-vs-istio">
<title>Envoy services</title>
<simpara>Red Hat OpenShift Service Mesh does not support QUIC-based services.</simpara>
</section>
<section xml:id="ossm-cni_ossm-vs-istio">
<title>Istio Container Network Interface (CNI) plugin</title>
<simpara>Red Hat OpenShift Service Mesh includes CNI plugin, which provides you with an alternate way to configure application pod networking. The CNI plugin replaces the <literal>init-container</literal> network configuration eliminating the need to grant service accounts and projects access to security context constraints (SCCs) with elevated privileges.</simpara>
</section>
<section xml:id="ossm-global-mtls_ossm-vs-istio">
<title>Global mTLS settings</title>
<simpara>Red Hat OpenShift Service Mesh creates a <literal>PeerAuthentication</literal> resource that enables or disables Mutual TLS authentication (mTLS) within the mesh.</simpara>
</section>
<section xml:id="ossm-gateways_ossm-vs-istio">
<title>Gateways</title>
<simpara>Red Hat OpenShift Service Mesh installs ingress and egress gateways by default. You can disable gateway installation in the <literal>ServiceMeshControlPlane</literal> (SMCP) resource by using the following settings:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.gateways.enabled=false</literal> to disable both ingress and egress gateways.</simpara>
</listitem>
<listitem>
<simpara><literal>spec.gateways.ingress.enabled=false</literal> to disable ingress gateways.</simpara>
</listitem>
<listitem>
<simpara><literal>spec.gateways.egress.enabled=false</literal>  to disable egress gateways.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Operator annotates the default gateways to indicate that they are generated by and managed by the Red Hat OpenShift Service Mesh Operator.</simpara>
</note>
</section>
<section xml:id="ossm-multicluster-configuration_ossm-vs-istio">
<title>Multicluster configurations</title>
<simpara>Red Hat OpenShift Service Mesh support for multicluster configurations is limited to the federation of service meshes across multiple clusters.</simpara>
</section>
<section xml:id="ossm-certificate-signing-request_ossm-vs-istio">
<title>Custom Certificate Signing Requests (CSR)</title>
<simpara>You cannot configure Red Hat OpenShift Service Mesh to process CSRs through the Kubernetes certificate authority (CA).</simpara>
</section>
<section xml:id="ossm-routes-gateways_ossm-vs-istio">
<title>Routes for Istio Gateways</title>
<simpara>OpenShift routes for Istio Gateways are automatically managed in Red Hat OpenShift Service Mesh. Every time an Istio Gateway is created, updated or deleted inside the service mesh, an OpenShift route is created, updated or deleted.</simpara>
<simpara>A Red Hat OpenShift Service Mesh control plane component called Istio OpenShift Routing (IOR) synchronizes the gateway route. For more information, see Automatic route creation.</simpara>
<section xml:id="ossm-catch-all-domains_ossm-vs-istio">
<title>Catch-all domains</title>
<simpara>Catch-all domains ("*") are not supported. If one is found in the Gateway definition, Red Hat OpenShift Service Mesh <emphasis>will</emphasis> create the route, but will rely on OpenShift to create a default hostname. This means that the newly created route will <emphasis>not</emphasis> be a catch all ("*") route, instead it will have a hostname in the form <literal>&lt;route-name&gt;[-&lt;project&gt;].&lt;suffix&gt;</literal>. See the OpenShift Container Platform documentation for more information about how default hostnames work and how a <literal>cluster-admin</literal> can customize it. If you use Red Hat OpenShift Dedicated, refer to the Red Hat OpenShift Dedicated the <literal>dedicated-admin</literal> role.</simpara>
</section>
<section xml:id="ossm-subdomains_ossm-vs-istio">
<title>Subdomains</title>
<simpara>Subdomains (e.g.: "*.domain.com") are supported. However this ability doesn&#8217;t come enabled by default in OpenShift Container Platform. This means that Red Hat OpenShift Service Mesh <emphasis>will</emphasis> create the route with the subdomain, but it will only be in effect if OpenShift Container Platform is configured to enable it.</simpara>
</section>
<section xml:id="ossm-tls_ossm-vs-istio">
<title>Transport layer security</title>
<simpara>Transport Layer Security (TLS) is supported. This means that, if the Gateway contains a <literal>tls</literal> section, the OpenShift Route will be configured to support TLS.</simpara>
<bridgehead xml:id="additional-resources_ossm-vs-istio-v2x" role="_additional-resources" renderas="sect5">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-traffic-manage.xml#ossm-auto-route_traffic-management">Automatic route creation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ossm-multitenant-install_ossm-vs-istio">
<title>Multitenant installations</title>
<simpara>Whereas upstream Istio takes a single tenant approach, Red Hat OpenShift Service Mesh supports multiple independent control planes within the cluster. Red Hat OpenShift Service Mesh uses a multitenant operator to manage the control plane lifecycle.</simpara>
<simpara>Red Hat OpenShift Service Mesh installs a multitenant control plane by default. You specify the projects that can access the Service Mesh, and isolate the Service Mesh from other control plane instances.</simpara>
<section xml:id="ossm-mt-vs-clusterwide_ossm-vs-istio">
<title>Multitenancy versus cluster-wide installations</title>
<simpara>The main difference between a multitenant installation and a cluster-wide installation is the scope of privileges used by istod. The components no longer use cluster-scoped Role Based Access Control (RBAC) resource <literal>ClusterRoleBinding</literal>.</simpara>
<simpara>Every project in the <literal>ServiceMeshMemberRoll</literal> <literal>members</literal> list will have a <literal>RoleBinding</literal> for each service account associated with the control plane deployment and each control plane deployment will only watch those member projects. Each member project has a <literal>maistra.io/member-of</literal> label added to it, where the <literal>member-of</literal> value is the project containing the control plane installation.</simpara>
<simpara>Red Hat OpenShift Service Mesh configures each member project to ensure network access between itself, the control plane, and other member projects. The exact configuration differs depending on how OpenShift Container Platform software-defined networking (SDN) is configured. See About OpenShift SDN for additional details.</simpara>
<simpara>If the OpenShift Container Platform cluster is configured to use the SDN plugin:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>NetworkPolicy</literal></emphasis>: Red Hat OpenShift Service Mesh creates a <literal>NetworkPolicy</literal> resource in each member project allowing ingress to all pods from the other members and the control plane. If you remove a member from Service Mesh, this <literal>NetworkPolicy</literal> resource is deleted from the project.</simpara>
<note>
<simpara>This also restricts ingress to only member projects. If you require ingress from non-member projects, you need to create a <literal>NetworkPolicy</literal> to allow that traffic through.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">Multitenant</emphasis>: Red Hat OpenShift Service Mesh joins the <literal>NetNamespace</literal> for each member project to the <literal>NetNamespace</literal> of the control plane project (the equivalent of running <literal>oc adm pod-network join-projects --to control-plane-project member-project</literal>). If you remove a member from the Service Mesh, its <literal>NetNamespace</literal> is isolated from the control plane (the equivalent of running <literal>oc adm pod-network isolate-projects member-project</literal>).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Subnet</emphasis>: No additional configuration is performed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-cluster-scoped-resources_ossm-vs-istio">
<title>Cluster scoped resources</title>
<simpara>Upstream Istio has two cluster scoped resources that it relies on. The <literal>MeshPolicy</literal> and the <literal>ClusterRbacConfig</literal>. These are not compatible with a multitenant cluster and have been replaced as described below.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>ServiceMeshPolicy</emphasis> replaces MeshPolicy for configuration of control-plane-wide authentication policies. This must be created in the same project as the control plane.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ServicemeshRbacConfig</emphasis> replaces ClusterRbacConfig for configuration of control-plane-wide role based access control. This must be created in the same project as the control plane.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-kiali-service-mesh_ossm-vs-istio">
<title>Kiali and service mesh</title>
<simpara>Installing Kiali via the Service Mesh on OpenShift Container Platform differs from community Kiali installations in multiple ways. These modifications are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<itemizedlist>
<listitem>
<simpara>Kiali has been enabled by default.</simpara>
</listitem>
<listitem>
<simpara>Ingress has been enabled by default.</simpara>
</listitem>
<listitem>
<simpara>Updates have been made to the Kiali ConfigMap.</simpara>
</listitem>
<listitem>
<simpara>Updates have been made to the ClusterRole settings for Kiali.</simpara>
</listitem>
<listitem>
<simpara>Do not edit the ConfigMap, because your changes might be overwritten by the Service Mesh or Kiali Operators. Files that the Kiali Operator manages have a <literal>kiali.io/</literal> label or annotation. Updating the Operator files should be restricted to those users with <literal>cluster-admin</literal> privileges. If you use Red Hat OpenShift Dedicated, updating the Operator files should be restricted to those users with <literal>dedicated-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-jaeger-service-mesh_ossm-vs-istio">
<title>Distributed tracing and service mesh</title>
<simpara>Installing the distributed tracing platform (Jaeger) with the Service Mesh on OpenShift Container Platform differs from community Jaeger installations in multiple ways. These modifications are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<itemizedlist>
<listitem>
<simpara>Distributed tracing has been enabled by default for Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>Ingress has been enabled by default for Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>The name for the Zipkin port name has changed to <literal>jaeger-collector-zipkin</literal> (from <literal>http</literal>)</simpara>
</listitem>
<listitem>
<simpara>Jaeger uses Elasticsearch for storage by default when you select either the <literal>production</literal> or <literal>streaming</literal> deployment option.</simpara>
</listitem>
<listitem>
<simpara>The community version of Istio provides a generic "tracing" route. Red Hat OpenShift Service Mesh uses a "jaeger" route that is installed by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator and is already protected by OAuth.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh uses a sidecar for the Envoy proxy, and Jaeger also uses a sidecar, for the Jaeger agent.
These two sidecars are configured separately and should not be confused with each other. The proxy sidecar creates spans related to the pod&#8217;s ingress and egress traffic. The agent sidecar receives the spans emitted by the application and sends them to the Jaeger Collector.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="preparing-ossm-installation">
<title>Preparing to install Service Mesh</title>

<simpara>Before you can install Red Hat OpenShift Service Mesh, you must subscribe to OpenShift Container Platform and install OpenShift Container Platform in a supported configuration.</simpara>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Maintain an active OpenShift Container Platform subscription on your Red Hat account. If you do not have a subscription, contact your sales representative for more information.</simpara>
</listitem>
<listitem>
<simpara>Review the <link xlink:href="../../architecture/architecture-installation.xml#installation-overview_architecture-installation">OpenShift Container Platform 4.14 overview</link>.</simpara>
</listitem>
<listitem>
<simpara>Install OpenShift Container Platform 4.14. If you are installing Red Hat OpenShift Service Mesh on a <link xlink:href="../../installing/installing-preparing.xml#supported-installation-methods-for-different-platforms">restricted network</link>, follow the instructions for your chosen OpenShift Container Platform infrastructure.</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-account.xml#installing-aws-account">Install OpenShift Container Platform 4.14 on AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-user-infra.xml#installing-aws-user-infra">Install OpenShift Container Platform 4.14 on user-provisioned AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installing-bare-metal">Install OpenShift Container Platform 4.14 on bare metal</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_vsphere/upi/installing-vsphere.xml#installing-vsphere">Install OpenShift Container Platform 4.14 on vSphere</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_ibm_z/installing-ibm-z.xml#installing-ibm-z">Install OpenShift Container Platform 4.14 on IBM Z&#174; and IBM&#174; LinuxONE</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_ibm_power/installing-ibm-power.xml#installing-ibm-power">Install OpenShift Container Platform 4.14 on IBM Power&#174;</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Install the version of the OpenShift Container Platform command line utility (the <literal>oc</literal> client tool) that matches your OpenShift Container Platform version and add it to your path.</simpara>
<itemizedlist>
<listitem>
<simpara>If you are using OpenShift Container Platform 4.14, see <link xlink:href="../../cli_reference/openshift_cli/getting-started-cli.xml#cli-about-cli_cli-developer-commands">About the OpenShift CLI</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>For additional information about Red Hat OpenShift Service Mesh lifecycle and supported platforms, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Support Policy</link>.</simpara>
</section>
<section xml:id="ossm-supported-configurations_preparing-ossm-installation">
<title>Supported configurations</title>
<simpara>The following configurations are supported for the current release of Red Hat OpenShift Service Mesh.</simpara>
<section xml:id="ossm-supported-platforms_preparing-ossm-installation">
<title>Supported platforms</title>
<simpara>The Red Hat OpenShift Service Mesh Operator supports multiple versions of the <literal>ServiceMeshControlPlane</literal> resource. Version 2.4 Service Mesh control planes are supported on the following platform versions:</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Container Platform version 4.10 or later.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Dedicated version 4.</simpara>
</listitem>
<listitem>
<simpara>Azure Red Hat OpenShift (ARO) version 4.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service on AWS (ROSA).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-unsupported-configurations_preparing-ossm-installation">
<title>Unsupported configurations</title>
<simpara>Explicitly unsupported cases include:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Online is not supported for Red Hat OpenShift Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh does not support the management of microservices outside the cluster where Service Mesh is running.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-networks_preparing-ossm-installation">
<title>Supported network configurations</title>
<simpara>Red Hat OpenShift Service Mesh supports the following network configurations.</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift-SDN</simpara>
</listitem>
<listitem>
<simpara>OVN-Kubernetes is available on all supported versions of OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Third-Party Container Network Interface (CNI) plugins that have been certified on OpenShift Container Platform and passed Service Mesh conformance testing. See <link xlink:href="https://access.redhat.com/articles/5436171">Certified OpenShift CNI Plug-ins</link> for more information.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-sm_preparing-ossm-installation">
<title>Supported configurations for Service Mesh</title>
<itemizedlist>
<listitem>
<simpara>This release of Red Hat OpenShift Service Mesh is only available on OpenShift Container Platform x86_64, IBM Z&#174;, and IBM Power&#174;.</simpara>
<itemizedlist>
<listitem>
<simpara>IBM Z&#174; is only supported on OpenShift Container Platform 4.10 and later.</simpara>
</listitem>
<listitem>
<simpara>IBM Power&#174; is only supported on OpenShift Container Platform 4.10 and later.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Configurations where all Service Mesh components are contained within a single OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Configurations that do not integrate external services such as virtual machines.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh does not support <literal>EnvoyFilter</literal> configuration except where explicitly documented.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-kiali_preparing-ossm-installation">
<title>Supported configurations for Kiali</title>
<itemizedlist>
<listitem>
<simpara>The Kiali console is only supported on the two most recent releases of the Google Chrome, Microsoft Edge, Mozilla Firefox, or Apple Safari browsers.</simpara>
</listitem>
<listitem>
<simpara>The <literal>openshift</literal> authentication strategy is the only supported authentication configuration when Kiali is deployed with Red Hat OpenShift Service Mesh (OSSM). The <literal>openshift</literal> strategy controls access based on the individual&#8217;s role-based access control (RBAC) roles of the OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-jaeger_preparing-ossm-installation">
<title>Supported configurations for Distributed Tracing</title>
<itemizedlist>
<listitem>
<simpara>Jaeger agent as a sidecar is the only supported configuration for Jaeger. Jaeger as a daemonset is not supported for multitenant installations or OpenShift Dedicated.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-webassembly_preparing-ossm-installation">
<title>Supported WebAssembly module</title>
<itemizedlist>
<listitem>
<simpara>3scale WebAssembly is the only provided WebAssembly module. You can create custom WebAssembly modules.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_next_steps_2">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/installing-ossm.xml#installing-ossm">Install Red Hat OpenShift Service Mesh</link> in your OpenShift Container Platform environment.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="installing-ossm">
<title>Installing the Operators</title>

<simpara>To install Red Hat OpenShift Service Mesh, first install the required Operators on OpenShift Container Platform and then create a <literal>ServiceMeshControlPlane</literal> resource to deploy the control plane.</simpara>
<note>
<simpara>This basic installation is configured based on the default OpenShift settings and is not designed for production use.  Use this default installation to verify your installation, and then configure your service mesh for your specific environment.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Read the <link xlink:href="../../service_mesh/v2x/preparing-ossm-installation.xml#preparing-ossm-installation">Preparing to install Red Hat OpenShift Service Mesh</link> process.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<simpara>The following steps show how to install a basic instance of Red Hat OpenShift Service Mesh on OpenShift Container Platform.</simpara>
<section xml:id="ossm-installation-activities_installing-ossm">
<title>Operator overview</title>
<simpara>Red Hat OpenShift Service Mesh requires the following Operators:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">OpenShift Elasticsearch</emphasis> - (Optional) Provides database storage for tracing and logging with the distributed tracing platform (Jaeger). It is based on the open source <link xlink:href="https://www.elastic.co/">Elasticsearch</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger)</emphasis> - Provides distributed tracing to monitor and troubleshoot transactions in complex distributed systems. It is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Kiali Operator provided by Red Hat</emphasis> - Provides observability for your service mesh. You can view configurations, monitor traffic, and analyze traces in a single console. It is based on the open source <link xlink:href="https://www.kiali.io/">Kiali</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> - Allows you to connect, secure, control, and observe the microservices that comprise your applications. The Service Mesh Operator defines and monitors the <literal>ServiceMeshControlPlane</literal> resources that manage the deployment, updating, and deletion of the Service Mesh components. It is based on the open source <link xlink:href="https://istio.io/">Istio</link> project.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Do not install Community versions of the Operators. Community Operators are not supported.</simpara>
</warning>
</section>
<section xml:id="ossm-install-ossm-operator_installing-ossm">
<title>Installing the Operators</title>
<simpara>To install Red Hat OpenShift Service Mesh, install the following Operators in this order. Repeat the procedure for each Operator.</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Elasticsearch</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform (Jaeger)</simpara>
</listitem>
<listitem>
<simpara>Kiali Operator provided by Red Hat</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you have already installed the OpenShift Elasticsearch Operator as part of OpenShift Logging, you do not need to install the OpenShift Elasticsearch Operator again. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator will create the Elasticsearch instance using the installed OpenShift Elasticsearch Operator.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type the name of the Operator into the filter box and select the Red Hat version of the Operator. Community versions of the Operators are not supported.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page for each Operator, accept  the default settings.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>. Wait until the Operator has installed before repeating the steps for the next Operator in the list.</simpara>
<itemizedlist>
<listitem>
<simpara>The OpenShift Elasticsearch Operator is installed in the <literal>openshift-operators-redhat</literal> namespace and is available for all namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) is installed in the <literal>openshift-distributed-tracing</literal> namespace and is available for all namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>The Kiali Operator provided by Red Hat and the Red Hat OpenShift Service Mesh Operator are installed in the <literal>openshift-operators</literal> namespace and are available for all namespaces in the cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all you have installed all four Operators, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> to verify that your Operators installed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-operator-infrastructure-node_installing-ossm">
<title>Configuring the Service Mesh Operator to run on infrastructure nodes</title>
<simpara>This task should only be performed if the Service Mesh Operator runs on an infrastructure node.</simpara>
<simpara>If the operator will run on a worker node, skip this task.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>One of the nodes comprising the deployment must be an infrastructure node. For more information, see "Creating infrastructure machine sets."</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the operators installed in the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-operators get subscriptions</programlisting>
</listitem>
<listitem>
<simpara>Edit the Service Mesh Operator <literal>Subscription</literal> resource to specify where the operator should run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-operators edit subscription &lt;name&gt; <co xml:id="CO3-1"/></programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para><literal>&lt;name&gt;</literal> represents the name of the <literal>Subscription</literal> resource. The default name of the <literal>Subscription</literal> resource is <literal>servicemeshoperator</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the <literal>nodeSelector</literal> and <literal>tolerations</literal> to <literal>spec.config</literal> in the <literal>Subscription</literal> resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  config:
    nodeSelector: <co xml:id="CO4-1"/>
      node-role.kubernetes.io/infra: ""
    tolerations: <co xml:id="CO4-2"/>
    - effect: NoSchedule
      key: node-role.kubernetes.io/infra
      value: reserved
    - effect: NoExecute
      key: node-role.kubernetes.io/infra
      value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Ensures that the operator pod is only scheduled on an infrastructure node.</para>
</callout>
<callout arearefs="CO4-2">
<para>Ensures that the pod is accepted by the infrastructure node.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-confirm-operator-infrastructure-node_installing-ossm">
<title>Verifying the Service Mesh Operator is running on infrastructure node</title>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Verify that the node associated with the Operator pod is an infrastructure node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-operators get po -l name=istio-operator -owide</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="_next_steps_3">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator does not create the Service Mesh custom resource definitions (CRDs) until you deploy a Service Mesh control plane. You can use the <literal>ServiceMeshControlPlane</literal> resource to install and configure the Service Mesh components. For more information, see <link xlink:href="../../service_mesh/v2x/ossm-create-smcp.xml#ossm-create-smcp">Creating the ServiceMeshControlPlane</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-create-smcp">
<title>Creating the ServiceMeshControlPlane</title>

<section xml:id="ossm-about-smcp_ossm-create-smcp">
<title>About ServiceMeshControlPlane</title>
<simpara>The control plane includes Istiod, Ingress and Egress Gateways, and other components, such as Kiali and Jaeger. The control plane must be deployed in a separate namespace than the Service Mesh Operators and the data plane applications and services. You can deploy a basic installation of the <literal>ServiceMeshControlPlane</literal>(SMCP) from the OpenShift Container Platform web console or the command line using the <literal>oc</literal> client tool.</simpara>
<note>
<simpara>This basic installation is configured based on the default OpenShift Container Platform settings and is not designed for production use. Use this default installation to verify your installation, and then configure your <literal>ServiceMeshControlPlane</literal> settings for your environment.</simpara>
</note>
<note>
<simpara>Red Hat OpenShift Service on AWS (ROSA) places additional restrictions on where you can create resources, and as a result, the default deployment does not work. See Installing Service Mesh on Red Hat OpenShift Service on AWS for additional requirements before deploying your SMCP in a ROSA environment.</simpara>
</note>
<note>
<simpara>The Service Mesh documentation uses <literal>istio-system</literal> as the example project, but you can deploy the service mesh to any project.</simpara>
</note>
<section xml:id="ossm-control-plane-deploy-operatorhub_ossm-create-smcp">
<title>Deploying the Service Mesh control plane from the web console</title>
<simpara>You can deploy a basic <literal>ServiceMeshControlPlane</literal> by using the web console.  In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> field, enter <literal>istio-system</literal>. The <literal>ServiceMeshControlPlane</literal> resource must be installed in a project that is separate from your microservices and Operators.</simpara>
<simpara>These steps use <literal>istio-system</literal> as an example, but you can deploy your Service Mesh control plane in any project as long as it is separate from the project that contains your services.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator, then click <emphasis role="strong">Istio Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab, click <emphasis role="strong">Create ServiceMeshControlPlane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create ServiceMeshControlPlane</emphasis> page, accept the default Service Mesh control plane version to take advantage of the features available in the most current version of the product. The version of the control plane determines the features available regardless of the version of the Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>. The Operator creates pods, services, and Service Mesh control plane components based on your configuration parameters. You can configure <literal>ServiceMeshControlPlane</literal> settings later.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To verify the control plane installed correctly, click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the name of the new control plane.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Resources</emphasis> tab to see the Red Hat OpenShift Service Mesh control plane resources the Operator created and configured.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-control-plane-deploy-cli_ossm-create-smcp">
<title>Deploying the Service Mesh control plane using the CLI</title>
<simpara>You can deploy a basic <literal>ServiceMeshControlPlane</literal> from the command line.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ServiceMeshControlPlane</literal> file named <literal>istio-installation.yaml</literal> using the following example. The version of the Service Mesh control plane determines the features available regardless of the version of the Operator.</simpara>
<formalpara>
<title>Example version 2.4 istio-installation.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  version: v2.4
  tracing:
    type: Jaeger
    sampling: 10000
  addons:
    jaeger:
      name: jaeger
      install:
        storage:
          type: Memory
    kiali:
      enabled: true
      name: kiali
    grafana:
      enabled: true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Service Mesh control plane, where <literal>&lt;istio_installation.yaml&gt;</literal> includes the full path to your file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f &lt;istio_installation.yaml&gt;</programlisting>
</listitem>
<listitem>
<simpara>To watch the progress of the pod deployment, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n istio-system -w</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   READY   STATUS    RESTARTS   AGE
grafana-b4d59bd7-mrgbr                 2/2     Running   0          65m
istio-egressgateway-678dc97b4c-wrjkp   1/1     Running   0          108s
istio-ingressgateway-b45c9d54d-4qg6n   1/1     Running   0          108s
istiod-basic-55d78bbbcd-j5556          1/1     Running   0          108s
jaeger-67c75bd6dc-jv6k6                2/2     Running   0          65m
kiali-6476c7656c-x5msp                 1/1     Running   0          43m
prometheus-58954b8d6b-m5std            2/2     Running   0          66m</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-validate-control-plane-cli_ossm-create-smcp">
<title>Validating your SMCP installation with the CLI</title>
<simpara>You can validate the creation of the <literal>ServiceMeshControlPlane</literal> from the command line.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify the Service Mesh control plane installation, where <literal>istio-system</literal> is the namespace where you installed the Service Mesh control plane.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n istio-system</programlisting>
<simpara>The installation has finished successfully when the <literal>STATUS</literal> column is <literal>ComponentsReady</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME    READY   STATUS            PROFILES      VERSION   AGE
basic   10/10   ComponentsReady   ["default"]   2.1.1     66m</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-about-control-plane-components-and-infrastructure-nodes_ossm-create-smcp">
<title>About control plane components and infrastructure nodes</title>
<simpara>Infrastructure nodes provide a way to isolate infrastructure workloads for two primary purposes:</simpara>
<itemizedlist>
<listitem>
<simpara>To prevent incurring billing costs against subscription counts</simpara>
</listitem>
<listitem>
<simpara>To separate maintenance and management of infrastructure workloads</simpara>
</listitem>
</itemizedlist>
<simpara>You can configure some or all of the Service Mesh control plane components to run on infrastructure nodes.</simpara>
<section xml:id="ossm-config-control-plane-infrastructure-node-console_ossm-create-smcp">
<title>Configuring all control plane components to run on infrastructure nodes using the web console</title>
<simpara>Perform this task if all of the components deployed by the Service Mesh control plane will run on infrastructure nodes. These deployed components include Istiod, Ingress Gateway, and Egress Gateway, and optional applications such as Prometheus, Grafana, and Distributed Tracing.</simpara>
<simpara>If the control plane will run on a worker node, skip this task.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator, and then click <emphasis role="strong">Istio Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the control plane resource. For example, <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">YAML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>nodeSelector</literal> and <literal>tolerations</literal> fields to the <literal>spec.runtime.defaults.pod</literal> specification in the <literal>ServiceMeshControlPlane</literal> resource, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    defaults:
      pod:
        nodeSelector: <co xml:id="CO5-1"/>
          node-role.kubernetes.io/infra: ""
        tolerations: <co xml:id="CO5-2"/>
        - effect: NoSchedule
          key: node-role.kubernetes.io/infra
          value: reserved
        - effect: NoExecute
          key: node-role.kubernetes.io/infra
          value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Ensures that the <literal>ServiceMeshControlPlane</literal> pod is only scheduled on an infrastructure node.</para>
</callout>
<callout arearefs="CO5-2">
<para>Ensures that the pod is accepted by the infrastructure node for execution.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-individual-control-plane-infrastructure-node-console_ossm-create-smcp">
<title>Configuring individual control plane components to run on infrastructure nodes using the web console</title>
<simpara>Perform this task if individual components deployed by the Service Mesh control plane will run on infrastructure nodes. These deployed components include Istiod, the Ingress Gateway, and the Egress Gateway.</simpara>
<simpara>If the control plane will run on a worker node, skip this task.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator, and then click <emphasis role="strong">Istio Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the control plane resource. For example, <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">YAML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>nodeSelector</literal> and <literal>tolerations</literal> fields to the <literal>spec.runtime.components.pilot.pod</literal> specification in the <literal>ServiceMeshControlPlane</literal> resource, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        pod:
          nodeSelector: <co xml:id="CO6-1"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO6-2"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Ensures that the <literal>Istiod</literal> pod is only scheduled on an infrastructure node.</para>
</callout>
<callout arearefs="CO6-2">
<para>Ensures that the pod is accepted by the infrastructure node for execution.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the <literal>nodeSelector</literal> and the <literal>tolerations</literal> fields to the <literal>spec.gateways.ingress.runtime.pod</literal> and <literal>spec.gateways.egress.runtime.pod</literal> specifications in the <literal>ServiceMeshControlPlane</literal> resource, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  gateways:
    ingress:
      runtime:
        pod:
          nodeSelector: <co xml:id="CO7-1"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO7-2"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved
    egress:
      runtime:
        pod:
          nodeSelector: <co xml:id="CO7-3"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO7-4"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO7-1 CO7-3">
<para>Ensures that the gateway pod is only scheduled on an infrastructure node</para>
</callout>
<callout arearefs="CO7-2 CO7-4">
<para>Ensures that the pod is accepted by the infrastructure node for execution.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-control-plane-infrastructure-node-cli_ossm-create-smcp">
<title>Configuring all control plane components to run on infrastructure nodes using the CLI</title>
<simpara>Perform this task if all of the components deployed by the Service Mesh control plane will run on infrastructure nodes. These deployed components include Istiod, Ingress Gateway, and Egress Gateway, and optional applications such as Prometheus, Grafana, and Distributed Tracing.</simpara>
<simpara>If the control plane will run on a worker node, skip this task.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the <literal>ServiceMeshControlPlane</literal> resource as a YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system edit smcp &lt;name&gt; <co xml:id="CO8-1"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para><literal>&lt;name&gt;</literal> represents the name of the <literal>ServiceMeshControlPlane</literal> resource.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To run all of the Service Mesh components deployed by the <literal>ServiceMeshControlPlane</literal> on infrastructure nodes, add the <literal>nodeSelector</literal> and <literal>tolerations</literal> fields to the <literal>spec.runtime.defaults.pod</literal> spec in the <literal>ServiceMeshControlPlane</literal> resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    defaults:
      pod:
        nodeSelector: <co xml:id="CO9-1"/>
          node-role.kubernetes.io/infra: ""
        tolerations: <co xml:id="CO9-2"/>
        - effect: NoSchedule
          key: node-role.kubernetes.io/infra
          value: reserved
        - effect: NoExecute
          key: node-role.kubernetes.io/infra
          value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>Ensures that the SMCP pods are only scheduled on an infrastructure node.</para>
</callout>
<callout arearefs="CO9-2">
<para>Ensures that the pods are accepted by the infrastructure node.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-individual-control-plane-infrastructure-node-cli_ossm-create-smcp">
<title>Configuring individual control plane components to run on infrastructure nodes using the CLI</title>
<simpara>Perform this task if individual components deployed by the Service Mesh control plane will run on infrastructure nodes. These deployed components include Istiod, the Ingress Gateway, and the Egress Gateway.</simpara>
<simpara>If the control plane will run on a worker node, skip this task.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the <literal>ServiceMeshControlPlane</literal> resource as a YAML file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system edit smcp &lt;name&gt; <co xml:id="CO10-1"/></programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para><literal>&lt;name&gt;</literal> represents the name of the <literal>ServiceMeshControlPlane</literal> resource.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To run the Istiod component on an infrastructure node, add the <literal>nodeSelector</literal> and the <literal>tolerations</literal> fields to the <literal>spec.runtime.components.pilot.pod</literal> spec in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        pod:
          nodeSelector: <co xml:id="CO11-1"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO11-2"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Ensures that the <literal>Istiod</literal> pod is only scheduled on an infrastructure node.</para>
</callout>
<callout arearefs="CO11-2">
<para>Ensures that the pod is accepted by the infrastructure node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To run Ingress and Egress Gateways on infrastructure nodes, add the <literal>nodeSelector</literal> and the <literal>tolerations</literal> fields to the <literal>spec.gateways.ingress.runtime.pod</literal> spec and the <literal>spec.gateways.egress.runtime.pod</literal> spec in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  gateways:
    ingress:
      runtime:
        pod:
          nodeSelector: <co xml:id="CO12-1"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO12-2"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved
    egress:
      runtime:
        pod:
          nodeSelector: <co xml:id="CO12-3"/>
            node-role.kubernetes.io/infra: ""
          tolerations: <co xml:id="CO12-4"/>
          - effect: NoSchedule
            key: node-role.kubernetes.io/infra
            value: reserved
          - effect: NoExecute
            key: node-role.kubernetes.io/infra
            value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO12-1 CO12-3">
<para>Ensures that the gateway pod is only scheduled on an infrastructure node</para>
</callout>
<callout arearefs="CO12-2 CO12-4">
<para>Ensures that the pod is accepted by the infrastructure node.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-confirm-smcp-infrastructure-node_ossm-create-smcp">
<title>Verifying the Service Mesh control plane is running on infrastructure nodes</title>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Confirm that the nodes associated with Istiod, Ingress Gateway, and Egress Gateway pods are infrastructure nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system get pods -owide</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-about-control-plane-and-cluster-wide-deployment_ossm-create-smcp">
<title>About control plane and cluster-wide deployments</title>
<simpara>A cluster-wide deployment contains a Service Mesh Control Plane that monitors resources for an entire cluster. Monitoring resources for an entire cluster closely resembles Istio functionality in that the control plane uses a single query across all namespaces to monitor Istio and Kubernetes resources. As a result, cluster-wide deployments decrease the number of requests sent to the API server.</simpara>
<simpara>You can configure the Service Mesh Control Plane for cluster-wide deployments using either the OpenShift Container Platform web console or the CLI.</simpara>
<section xml:id="ossm-deploy-cluster-wide-control-plane-console_ossm-create-smcp">
<title>Configuring the control plane for cluster-wide deployment with the web console</title>
<simpara>You can configure the <literal>ServiceMeshControlPlane</literal> resource for cluster-wide deployment using the OpenShift Container Platform web console. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator is installed.</simpara>
</listitem>
<listitem>
<simpara>You are logged in using an account with the <literal>cluster-admin</literal> role, or if you use Red Hat OpenShift Dedicated with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> field, enter <literal>istio-system</literal>. The <literal>ServiceMeshControlPlane</literal> resource must be installed in a project that is separate from your microservices and Operators.</simpara>
<simpara>These steps use <literal>istio-system</literal> as an example. You can deploy the Service Mesh control plane to any project as long as it is separate from the project that contains your services.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator, then click <emphasis role="strong">Istio Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab, click <emphasis role="strong">Create ServiceMeshControlPlane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">YAML view</emphasis>. The version of the Service Mesh control plane determines the features available regardless of the version of the Operator.</simpara>
</listitem>
<listitem>
<simpara>Modify the <literal>spec.mode</literal> field of the YAML file to specify <literal>ClusterWide</literal>.</simpara>
<formalpara>
<title>Example version 2.4 istio-installation.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  version: v2.4
  mode: ClusterWide</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>. The Operator creates pods, services, and Service Mesh control plane components based on your configuration parameters. The operator also creates the <literal>ServiceMeshMemberRoll</literal> if it does not exist as part of the default configuration.</simpara>
</listitem>
<listitem>
<simpara>To verify that the control plane installed correctly, click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the name of the new <literal>ServiceMeshControlPlane</literal> object.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Resources</emphasis> tab to see the Red Hat OpenShift Service Mesh control plane resources that the Operator created and configured.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-deploy-cluster-wide-control-plane-cli_ossm-create-smcp">
<title>Configuring the control plane for cluster-wide deployment with the CLI</title>
<simpara>You can configure the <literal>ServiceMeshControlPlane</literal> resource for cluster-wide deployment using the CLI. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane namespace.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator is installed.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ServiceMeshControlPlane</literal> file named <literal>istio-installation.yaml</literal> using the following example.</simpara>
<formalpara>
<title>Example version 2.4 istio-installation.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  version: v2.4
  mode: ClusterWide</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Service Mesh control plane, where <literal>&lt;istio_installation.yaml&gt;</literal> includes the full path to your file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f &lt;istio_installation.yaml&gt;</programlisting>
</listitem>
<listitem>
<simpara>To monitor the progress of the pod deployment, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n istio-system -w</programlisting>
<simpara>You should see output similar to the following example:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   READY   STATUS    RESTARTS   AGE
grafana-b4d59bd7-mrgbr                 2/2     Running   0          65m
istio-egressgateway-678dc97b4c-wrjkp   1/1     Running   0          108s
istio-ingressgateway-b45c9d54d-4qg6n   1/1     Running   0          108s
istiod-basic-55d78bbbcd-j5556          1/1     Running   0          108s
jaeger-67c75bd6dc-jv6k6                2/2     Running   0          65m
kiali-6476c7656c-x5msp                 1/1     Running   0          43m
prometheus-58954b8d6b-m5std            2/2     Running   0          66m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-customize-smrr-cluster-wide_ossm-create-smcp">
<title>Customizing the member roll for a cluster-wide mesh</title>
<simpara>In cluster-wide mode, when you create the <literal>ServiceMeshControlPlane</literal> resource, the <literal>ServiceMeshMemberRoll</literal> resource is also created. You can modify the <literal>ServiceMeshMemberRoll</literal> resource after it gets created. After you modify the resource, the Service Mesh operator no longer changes it. If you modify the <literal>ServiceMeshMemberRoll</literal> resource by using the OpenShift Container Platform web console, accept the prompt to overwrite the modifications.</simpara>
<simpara>Alternatively, you can create a <literal>ServiceMeshMemberRoll</literal> resource before deploying the <literal>ServiceMeshControlPlane</literal> resource. When you create the <literal>ServiceMeshControlPlane</literal> resource, the Service Mesh Operator will not modify the <literal>ServiceMeshMemberRoll</literal>.</simpara>
<note>
<simpara>The <literal>ServiceMeshMemberRoll</literal> resource name must be named <literal>default</literal> and must be created in the same project namespace as the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
</note>
<simpara>There are two ways to add a namespace to the mesh. You can either add the namespace by specifying its name in the <literal>spec.members</literal> list, or configure a set of namespace label selectors to include or exclude namespaces based on their labels.</simpara>
<note>
<simpara>Regardless of how members are specified in the <literal>ServiceMeshMemberRoll</literal> resource, you can also add members to the mesh by creating the <literal>ServiceMeshMember</literal> resource in each namespace.</simpara>
</note>
</section>
</section>
<section xml:id="ossm-validate-control-plane-kiali_ossm-create-smcp">
<title>Validating your SMCP installation with Kiali</title>
<simpara>You can use the Kiali console to validate your Service Mesh installation. The Kiali console offers several ways to validate your Service Mesh components are deployed and configured properly.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the route for the Kiali console. Click the route <emphasis role="strong">Location</emphasis> to launch the console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
<simpara>When you first log in to the Kiali Console, you see the <emphasis role="strong">Overview</emphasis> page which displays all the namespaces in your service mesh that you have permission to view. When there are multiple namespaces shown on the <emphasis role="strong">Overview</emphasis> page, Kiali shows namespaces with health or validation problems first.</simpara>
<figure>
<title>Kiali Overview page</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-overview.png"/>
</imageobject>
<textobject><phrase>Kiali Overview page showing istio-system</phrase></textobject>
</mediaobject>
</figure>
<simpara>The tile for each namespace displays the number of labels, the <emphasis role="strong">Istio Config</emphasis> health, the number of and <emphasis role="strong">Applications</emphasis> health, and <emphasis role="strong">Traffic</emphasis> for the namespace. If you are validating the console installation and namespaces have not yet been added to the mesh, there might not be any data to display other than <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Kiali has four dashboards specifically for the namespace where the Service Mesh control plane is installed.  To view these dashboards, click the <emphasis role="strong">Options</emphasis> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> on the tile for the control plane namespace, for example, <literal>istio-system</literal>, and select one of the following options:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Istio Mesh Dashboard</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Istio Control Plane Dashboard</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Istio Performance Dashboard</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Istio Wasm Exetension Dashboard</emphasis></simpara>
<figure>
<title>Grafana Istio Control Plane Dashboard</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-grafana-control-plane-dashboard.png"/>
</imageobject>
<textobject><phrase>Istio Control Plane Dashboard showing data for bookinfo sample project</phrase></textobject>
</mediaobject>
</figure>
<simpara>Kiali also installs two additional Grafana dashboards, available from the Grafana <emphasis role="strong">Home</emphasis> page:</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Istio Workload Dashboard</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Istio Service Dashboard</emphasis></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To view the Service Mesh control plane nodes, click the <emphasis role="strong">Graph</emphasis> page, select the <emphasis role="strong">Namespace</emphasis> where you installed the <literal>ServiceMeshControlPlane</literal> from the menu, for example <literal>istio-system</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If necessary, click <emphasis role="strong">Display idle nodes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To learn more about the <emphasis role="strong">Graph</emphasis> page, click the <emphasis role="strong">Graph tour</emphasis> link.</simpara>
</listitem>
<listitem>
<simpara>To view the mesh topology, select one or more additional namespaces from the Service Mesh Member Roll from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To view the list of applications in the <literal>istio-system</literal> namespace, click the <emphasis role="strong">Applications</emphasis> page. Kiali displays the health of the applications.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Hover your mouse over the information icon to view any additional information noted in the <emphasis role="strong">Details</emphasis> column.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To view the list of workloads in the <literal>istio-system</literal> namespace, click the <emphasis role="strong">Workloads</emphasis> page. Kiali displays the health of the workloads.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Hover your mouse over the information icon to view any additional information noted in the <emphasis role="strong">Details</emphasis> column.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To view the list of services in the <literal>istio-system</literal> namespace, click the <emphasis role="strong">Services</emphasis> page. Kiali displays the health of the services and of the configurations.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Hover your mouse over the information icon to view any additional information noted in the <emphasis role="strong">Details</emphasis> column.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To view a list of the Istio Configuration objects in the <literal>istio-system</literal> namespace, click the <emphasis role="strong">Istio Config</emphasis> page. Kiali displays the health of the configuration.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If there are configuration errors, click the row and Kiali opens the configuration file with the error highlighted.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-install-rosa_ossm-create-smcp">
<title>Installing on Red Hat OpenShift Service on AWS (ROSA)</title>
<simpara>Starting with version 2.2, Red Hat OpenShift Service Mesh supports installation on Red Hat OpenShift Service on AWS (ROSA). This section documents the additional requirements when installing Service Mesh on this platform.</simpara>
<section xml:id="ossm-install-rosa-location_ossm-create-smcp">
<title>Installation location</title>
<simpara>You must create a new namespace, for example <literal>istio-system</literal>, when installing Red Hat OpenShift Service Mesh and creating the <literal>ServiceMeshControlPlane</literal>.</simpara>
</section>
<section xml:id="ossm-install-rosa-smcp_ossm-create-smcp">
<title>Required Service Mesh control plane configuration</title>
<simpara>The default configuration in the <literal>ServiceMeshControlPlane</literal> file does not work on a ROSA cluster. You must modify the default SMCP and set <literal>spec.security.identity.type=ThirdParty</literal> when installing on Red Hat OpenShift Service on AWS.</simpara>
<formalpara>
<title>Example <literal>ServiceMeshControlPlane</literal> resource for ROSA</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  version: v2.4
  security:
    identity:
      type: ThirdParty  #required setting for ROSA
  tracing:
    type: Jaeger
    sampling: 10000
  policy:
    type: Istiod
  addons:
    grafana:
      enabled: true
    jaeger:
      install:
        storage:
          type: Memory
    kiali:
      enabled: true
    prometheus:
      enabled: true
  telemetry:
    type: Istiod</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-install-rosa-kiali-config_ossm-create-smcp">
<title>Restrictions on Kiali configuration</title>
<simpara>Red Hat OpenShift Service on AWS places additional restrictions on where you can create resources and does not let you create the Kiali resource in a Red Hat managed namespace.</simpara>
<simpara>This means that the following common settings for <literal>spec.deployment.accessible_namespaces</literal> are not allowed in a ROSA cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>['**']</literal>   (all namespaces)</simpara>
</listitem>
<listitem>
<simpara><literal>default</literal></simpara>
</listitem>
<listitem>
<simpara><literal>codeready-*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift-*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>redhat-*</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The validation error message provides a complete list of all the restricted namespaces.</simpara>
<formalpara>
<title>Example <literal>Kiali</literal> resource for ROSA</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: kiali.io/v1alpha1
kind: Kiali
metadata:
  name: kiali
  namespace: istio-system
spec:
  auth:
    strategy: openshift
  deployment:
    accessible_namespaces:   #restricted setting for ROSA
      - istio-system
    image_pull_policy: ''
    ingress_enabled: true
    namespace: istio-system</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_additional_resources" role="_additional-resources">
<title>Additional resources</title>
<simpara>Red Hat OpenShift Service Mesh supports multiple independent control planes within the cluster. You can create reusable configurations with <literal>ServiceMeshControlPlane</literal> profiles. For more information, see <link xlink:href="../../service_mesh/v2x/ossm-profiles-users.xml#ossm-control-plane-profiles_ossm-profiles-users">Creating control plane profiles</link>.</simpara>
</section>
<section xml:id="_next_steps_4">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>Add a project to the Service Mesh so that applications can be made available. For more information, see <link xlink:href="../../service_mesh/v2x/ossm-create-mesh.xml#ossm-create-mesh">Adding services to a service mesh</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-create-mesh">
<title>Adding services to a service mesh</title>

<simpara>A project contains services; however, the services are only available if you add the project to the service mesh.</simpara>
<section xml:id="ossm-about-adding-namespace_ossm-create-mesh">
<title>About adding projects to a service mesh</title>
<simpara>After installing the Operators and creating the <literal>ServiceMeshControlPlane</literal> resource, add one or more projects to the service mesh.</simpara>
<note>
<simpara>In OpenShift Container Platform, a project is essentially a Kubernetes namespace with additional annotations, such as the range of user IDs that can be used in the project. Typically, the OpenShift Container Platform web console uses the term project, and the CLI uses the term namespace, but the terms are essentially synonymous.</simpara>
</note>
<simpara>You can add projects to an existing service mesh using either the OpenShift Container Platform web console or the CLI. There are three methods to add a project to a service mesh:</simpara>
<itemizedlist>
<listitem>
<simpara>Specifying the project name in the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Configuring label selectors in the <literal>spec.labelSelectors</literal> field of the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Creating the <literal>ServiceMeshMember</literal> resource in the project.</simpara>
</listitem>
</itemizedlist>
<simpara>If you use the first method, then you must create the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</section>
<section xml:id="ossm-member-roll-create_ossm-create-mesh">
<title>Creating the Red Hat OpenShift Service Mesh member roll</title>
<simpara>The <literal>ServiceMeshMemberRoll</literal> lists the projects that belong to the Service Mesh control plane. Only projects listed in the <literal>ServiceMeshMemberRoll</literal> are affected by the control plane. A project does not belong to a service mesh until you add it to the member roll for a particular control plane deployment.</simpara>
<simpara>You must create a <literal>ServiceMeshMemberRoll</literal> resource named <literal>default</literal> in the same project as the <literal>ServiceMeshControlPlane</literal>, for example <literal>istio-system</literal>.</simpara>
<section xml:id="ossm-member-roll-create-console_ossm-create-mesh">
<title>Creating the member roll from the web console</title>
<simpara>You can add one or more projects to the Service Mesh member roll from the web console. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>List of existing projects to add to the service mesh.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>If you do not already have services for your mesh, or you are starting from scratch, create a project for your applications. It must be different from the project where you installed the Service Mesh control plane.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a name in the <emphasis role="strong">Name</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project where your <literal>ServiceMeshControlPlane</literal> resource is deployed from the list, for example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ServiceMeshMemberRoll</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Members</emphasis>, then enter the name of your project in the <emphasis role="strong">Value</emphasis> field. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-member-roll-create-cli_ossm-create-mesh">
<title>Creating the member roll from the CLI</title>
<simpara>You can add a project to the <literal>ServiceMeshMemberRoll</literal> from the command line.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>List of projects to add to the service mesh.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>If you do not already have services for your mesh, or you are starting from scratch, create a project for your applications. It must be different from the project where you installed the Service Mesh control plane.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;your-project&gt;</programlisting>
</listitem>
<listitem>
<simpara>To add your projects as members, modify the following example YAML. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<formalpara>
<title>Example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system
spec:
  members:
    # a list of projects joined into the service mesh
    - your-project-name
    - another-project-name</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload and create the <literal>ServiceMeshMemberRoll</literal> resource in the <literal>istio-system</literal> namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f servicemeshmemberroll-default.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify the <literal>ServiceMeshMemberRoll</literal> was created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smmr -n istio-system default</programlisting>
<simpara>The installation has finished successfully when the <literal>STATUS</literal> column is <literal>Configured</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-about-adding-projects-using-smmr_ossm-create-mesh">
<title>About adding projects using the ServiceMeshMemberRoll resource</title>
<simpara>Using the <literal>ServiceMeshMemberRoll</literal> resource is the simplest way to add a project to a service mesh. To add a project, specify the project name in the <literal>spec.members</literal> field of the <literal>ServiceMeshMemberRoll</literal> resource. The <literal>ServiceMeshMemberRoll</literal> resource specifies which projects are controlled by the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-adding-project-using-smmr.png"/>
</imageobject>
<textobject><phrase>Adding project using `ServiceMeshMemberRoll` resource image</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Adding projects using this method requires the user to have the <literal>update servicemeshmemberrolls</literal> and the <literal>update pods</literal> privileges in the project that is being added.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>If you already have an application, workload, or service to add to the service mesh, see the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Adding or removing projects from the mesh using the <literal>ServiceMeshMemberRoll</literal> resource with the web console</simpara>
</listitem>
<listitem>
<simpara>Adding or removing projects from the mesh using the <literal>ServiceMeshMemberRoll</literal> resource with the CLI</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Alternatively, to install a sample application called Bookinfo and add it to a <literal>ServiceMeshMemberRoll</literal> resource, see the Bookinfo example application tutorial.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-add-project-member-roll-recourse-console_ossm-create-mesh">
<title>Adding or removing projects from the mesh using the ServiceMeshMemberRoll resource with the web console</title>
<simpara>You can add or remove projects from the mesh using the <literal>ServiceMeshMemberRoll</literal> resource with the OpenShift Container Platform web console. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> mesh.</simpara>
<simpara>The <literal>ServiceMeshMemberRoll</literal> resource is deleted when its corresponding <literal>ServiceMeshControlPlane</literal> resource is deleted.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>The name of the project with the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>The names of the projects you want to add or remove from the mesh.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project where your <literal>ServiceMeshControlPlane</literal> resource is deployed from the list. For example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>default</literal> link.</simpara>
</listitem>
<listitem>
<simpara>Click the YAML tab.</simpara>
</listitem>
<listitem>
<simpara>Modify the YAML to add projects as members (or delete them to remove existing members). You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<formalpara>
<title>Example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system #control plane project
spec:
  members:
    # a list of projects joined into the service mesh
    - your-project-name
    - another-project-name</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-add-project-member-roll-resource-cli_ossm-create-mesh">
<title>Adding or removing projects from the mesh using ServiceMeshMemberRoll resource with the CLI</title>
<simpara>You can add one or more projects to the mesh using the <literal>ServiceMeshMemberRoll</literal> resource with the CLI. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> mesh.</simpara>
<simpara>The <literal>ServiceMeshMemberRoll</literal> resource is deleted when its corresponding <literal>ServiceMeshControlPlane</literal> resource is deleted.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>The name of the project with the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>The names of the projects you want to add or remove from the mesh.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit smmr -n &lt;controlplane-namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Modify the YAML to add or remove projects as members. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<formalpara>
<title>Example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system #control plane project
spec:
  members:
    # a list of projects joined into the service mesh
    - your-project-name
    - another-project-name</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Save the file and exit the editor.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-about-adding-projects-using-smm_ossm-create-mesh">
<title>About adding projects using the ServiceMeshMember resource</title>
<simpara>A <literal>ServiceMeshMember</literal> resource provides a way to add a project to a service mesh without modifying the <literal>ServiceMeshMemberRoll</literal> resource. To add a project, create a <literal>ServiceMeshMember</literal> resource in the project that you want to add to the service mesh. When the Service Mesh Operator processes the <literal>ServiceMeshMember</literal> object, the project appears in the <literal>status.members</literal> list of the <literal>ServiceMeshMemberRoll</literal> resource. Then, the services that reside in the project are made available to the mesh.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-adding-project-using-smm.png"/>
</imageobject>
<textobject><phrase>Adding project using `ServiceMeshMember` resource image</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The mesh administrator must grant each mesh user permission to reference the <literal>ServiceMeshControlPlane</literal> resource in the <literal>ServiceMeshMember</literal> resource. With this permission in place, a mesh user can add a project to a mesh even when that user does not have direct access rights for the service mesh project or the <literal>ServiceMeshMemberRoll</literal> resource. For more information, see Creating the Red Hat OpenShift Service Mesh members.</simpara>
<section xml:id="ossm-adding-project-using-smm-resource-console_ossm-create-mesh">
<title>Adding a project to the mesh using the ServiceMeshMember resource with the web console</title>
<simpara>You can add one or more projects to the mesh using the <literal>ServiceMeshMember</literal> resource with the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You know the name of the <literal>ServiceMeshControlPlane</literal> resource and the name of the project that the resource belongs to.</simpara>
</listitem>
<listitem>
<simpara>You know the name of the project you want to add to the mesh.</simpara>
</listitem>
<listitem>
<simpara>A service mesh administrator must explicitly grant access to the service mesh. Administrators can grant users permissions to access the mesh by assigning them the <literal>mesh-user</literal> <literal>Role</literal> using a <literal>RoleBinding</literal> or <literal>ClusterRoleBinding</literal>. For more information, see <emphasis>Creating the Red Hat OpenShift Service Mesh members</emphasis>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project that you want to add to the mesh from the drop-down list. For example, <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ServiceMeshMember</emphasis></simpara>
</listitem>
<listitem>
<simpara>Accept the default name for the <literal>ServiceMeshMember</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click to expand <emphasis role="strong">ControlPlaneRef</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Namespace</emphasis> field, select the project that the <literal>ServiceMeshControlPlane</literal> resource belongs to. For example, <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Name</emphasis> field, enter the name of the <literal>ServiceMeshControlPlane</literal> resource that this namespace belongs to. For example, <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Confirm the <literal>ServiceMeshMember</literal> resource was created, and that the project was added to the mesh. Click the resource name; for example, <literal>default</literal>. View the <emphasis role="strong">Conditions</emphasis> section shown at the end of the screen. Confirm that the <literal>Status</literal> of the <literal>Reconciled</literal> and <literal>Ready</literal> conditions is <literal>True</literal>. If the <literal>Status</literal> is <literal>False</literal>, see the <literal>Reason</literal> and <literal>Message</literal> columns for more information.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-adding-project-using-smm-resource-cli_ossm-create-mesh">
<title>Adding a project to the mesh using the ServiceMeshMember resource with the CLI</title>
<simpara>You can add one or more projects to the mesh using the <literal>ServiceMeshMember</literal> resource with the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>You know the name of the <literal>ServiceMeshControlPlane</literal> resource and the name of the project it belongs to.</simpara>
</listitem>
<listitem>
<simpara>You know the name of the project you want to add to the mesh.</simpara>
</listitem>
<listitem>
<simpara>A service mesh administrator must explicitly grant access to the service mesh. Administrators can grant users permissions to access the mesh by assigning them the <literal>mesh-user</literal> <literal>Role</literal> using a <literal>RoleBinding</literal> or <literal>ClusterRoleBinding</literal>. For more information, see <emphasis>Creating the Red Hat OpenShift Service Mesh members</emphasis>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Create the YAML file for the <literal>ServiceMeshMember</literal> manifest. The manifest adds the <literal>my-application</literal> project to the service mesh that was created by the <literal>ServiceMeshControlPlane</literal> resource deployed in the <literal>istio-system</literal> namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
  name: default
  namespace: my-application
spec:
  controlPlaneRef:
    namespace: istio-system
    name: basic</programlisting>
</listitem>
<listitem>
<simpara>Apply the YAML file to create the <literal>ServiceMeshMember</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;file-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>After creating the <literal>ServiceMeshMember</literal> resource, verify that the namespace is part of the mesh. Confirm the that the value <literal>True</literal> appears in the <literal>READY</literal> column when you run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smm default -n my-application</programlisting>
<simpara>Alternatively, if you can access the <literal>ServiceMeshMemberRoll</literal> resource, you can also confirm that the <literal>my-application</literal> namespace is displayed in the <literal>status.members</literal> and <literal>status.configuredMembers</literal> fields of the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-about-adding-projects-using-label-selectors_ossm-create-mesh">
<title>About adding projects using label selectors</title>
<simpara>For cluster-wide deployments, you can use label selectors to add projects to the mesh. Label selectors specified in the <literal>ServiceMeshMemberRoll</literal> resource enable the Service Mesh Operator to add or remove namespaces to or from the mesh based on namespace labels. Unlike other standard OpenShift Container Platform resources that you can use to specify a single label selector, you can use the <literal>ServiceMeshMemberRoll</literal> resource to specify multiple label selectors.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-adding-project-using-label-selector.png"/>
</imageobject>
<textobject><phrase>Adding project using label selector image</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If the labels for a namespace match any of the selectors specified in the <literal>ServiceMeshMemberRoll</literal> resource, then the namespace is included in the mesh.</simpara>
<note>
<simpara>In OpenShift Container Platform, a project is essentially a Kubernetes namespace with additional annotations, such as the range of user IDs that can be used in the project. Typically, the OpenShift Container Platform web console uses the term <emphasis>project</emphasis>, and the CLI uses the term <emphasis>namespace</emphasis>, but the terms are essentially synonymous.</simpara>
</note>
<section xml:id="ossm-adding-project-using-label-selectors-console_ossm-create-mesh">
<title>Adding a project to the mesh using label selectors with the web console</title>
<simpara>You can use labels selectors to add a project to the Service Mesh with the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>The deployment has an existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu, and from the drop-down list, select the project where your <literal>ServiceMeshMemberRoll</literal> resource is deployed. For example, <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ServiceMeshMember Roll</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Accept the default name for the <literal>ServiceMeshMemberRoll</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Labels</emphasis> field, enter key-value pairs to define the labels that identify which namespaces to include in the service mesh. If a project namespace has either label specified by the selectors, then the project namespace is included in the service mesh. You do not need to include both labels.</simpara>
<simpara>For example, entering <literal>mykey=myvalue</literal> includes all namespaces with this label as part of the mesh. When the selector identifies a match, the project namespace is added to the service mesh.</simpara>
<simpara>Entering <literal>myotherkey=myothervalue</literal> includes all namespaces with this label as part of the mesh. When the selector identifies a match, the project namespace is added to the service mesh.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-adding-project-using-label-selectors-cli_ossm-create-mesh">
<title>Adding a project to the mesh using label selectors with the CLI</title>
<simpara>You can use label selectors to add a project to the Service Mesh with the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>The deployment has an existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>You are logged in as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you are logged in as a user with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit smmr default -n istio-system</programlisting>
<simpara>You can deploy the Service Mesh control plane to any project provided that it is separate from the project that contains your services.</simpara>
</listitem>
<listitem>
<simpara>Modify the YAML file to include namespace label selectors in the <literal>spec.memberSelectors</literal> field of the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<note>
<simpara>Instead of using the <literal>matchLabels</literal> field, you can also use the <literal>matchExpressions</literal> field in the selector.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system
spec:
  memberSelectors: <co xml:id="CO13-1"/>
  - matchLabels: <co xml:id="CO13-2"/>
      mykey: myvalue <co xml:id="CO13-3"/>
  - matchLabels: <co xml:id="CO13-4"/>
      myotherkey: myothervalue <co xml:id="CO13-5"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Contains the label selectors used to identify which project namespaces are included in the service mesh. If a project namespace has either label specified by the selectors, then the project namespace is included in the service mesh. The project namespace does not need both labels to be included.</para>
</callout>
<callout arearefs="CO13-2 CO13-3">
<para>Specifies all namespaces with the <literal>mykey=myvalue</literal> label. When the selector identifies a match, the project namespace is added to the service mesh.</para>
</callout>
<callout arearefs="CO13-4 CO13-5">
<para>Specifies all namespaces with the <literal>myotherkey=myothervalue</literal> label. When the selector identifies a match, the project namespace is added to the service mesh.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-tutorial-bookinfo-overview_ossm-create-mesh">
<title>Bookinfo example application</title>
<simpara>The Bookinfo example application allows you to test your Red Hat OpenShift Service Mesh 2.4.5 installation on OpenShift Container Platform.</simpara>
<simpara>The Bookinfo application displays information about a book, similar to a single catalog entry of an online book store. The application displays a page that describes the book, book details (ISBN, number of pages, and other information), and book reviews.</simpara>
<simpara>The Bookinfo application consists of these microservices:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>productpage</literal> microservice calls the <literal>details</literal> and <literal>reviews</literal> microservices to populate the page.</simpara>
</listitem>
<listitem>
<simpara>The <literal>details</literal> microservice contains book information.</simpara>
</listitem>
<listitem>
<simpara>The <literal>reviews</literal> microservice contains book reviews. It also calls the <literal>ratings</literal> microservice.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ratings</literal> microservice contains book ranking information that accompanies a book review.</simpara>
</listitem>
</itemizedlist>
<simpara>There are three versions of the reviews microservice:</simpara>
<itemizedlist>
<listitem>
<simpara>Version v1 does not call the <literal>ratings</literal> Service.</simpara>
</listitem>
<listitem>
<simpara>Version v2 calls the <literal>ratings</literal> Service and displays each rating as one to five black stars.</simpara>
</listitem>
<listitem>
<simpara>Version v3 calls the <literal>ratings</literal> Service and displays each rating as one to five red stars.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-tutorial-bookinfo-install_ossm-create-mesh">
<title>Installing the Bookinfo application</title>
<simpara>This tutorial walks you through how to create a sample application by creating a project, deploying the Bookinfo application to that project, and viewing the running application in Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>OpenShift Container Platform 4.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh 2.4.5 installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Bookinfo sample application cannot be installed on IBM Z&#174; and IBM Power&#174;.</simpara>
</note>
<note>
<simpara>The commands in this section assume the Service Mesh control plane project is <literal>istio-system</literal>.  If you installed the control plane in another namespace, edit each command before you run it.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>bookinfo</literal> as the <emphasis role="strong">Project Name</emphasis>, enter a <emphasis role="strong">Display Name</emphasis>, and enter a <emphasis role="strong">Description</emphasis>, then click <emphasis role="strong">Create</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command from the CLI to create the <literal>bookinfo</literal> project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project bookinfo</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and use the Service Mesh control plane namespace. In this example, use <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you have already created a Istio Service Mesh Member Roll, click the name, then click the YAML tab to open the YAML editor.</simpara>
</listitem>
<listitem>
<simpara>If you have not created a <literal>ServiceMeshMemberRoll</literal>, click <emphasis role="strong">Create ServiceMeshMemberRoll</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Members</emphasis>, then enter the name of your project in the <emphasis role="strong">Value</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to save the updated Service Mesh Member Roll.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Or, save the following example to a YAML file.</simpara>
<formalpara>
<title>Bookinfo ServiceMeshMemberRoll example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
spec:
  members:
  - bookinfo</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload that file and create the <literal>ServiceMeshMemberRoll</literal> resource in the <literal>istio-system</literal> namespace.   In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f servicemeshmemberroll-default.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to verify the <literal>ServiceMeshMemberRoll</literal> was created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smmr -n istio-system -o wide</programlisting>
<simpara>The installation has finished successfully when the <literal>STATUS</literal> column is <literal>Configured</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY   STATUS       AGE   MEMBERS
default   1/1     Configured   70s   ["bookinfo"]</programlisting>
</listitem>
<listitem>
<simpara>From the CLI, deploy the Bookinfo application in the <emphasis>`bookinfo`</emphasis> project by applying the <literal>bookinfo.yaml</literal> file:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/platform/kube/bookinfo.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">service/details created
serviceaccount/bookinfo-details created
deployment.apps/details-v1 created
service/ratings created
serviceaccount/bookinfo-ratings created
deployment.apps/ratings-v1 created
service/reviews created
serviceaccount/bookinfo-reviews created
deployment.apps/reviews-v1 created
deployment.apps/reviews-v2 created
deployment.apps/reviews-v3 created
service/productpage created
serviceaccount/bookinfo-productpage created
deployment.apps/productpage-v1 created</programlisting>
</listitem>
<listitem>
<simpara>Create the ingress gateway by applying the <literal>bookinfo-gateway.yaml</literal> file:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/bookinfo-gateway.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">gateway.networking.istio.io/bookinfo-gateway created
virtualservice.networking.istio.io/bookinfo created</programlisting>
</listitem>
<listitem>
<simpara>Set the value for the <literal>GATEWAY_URL</literal> parameter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-adding-destination-rules_ossm-create-mesh">
<title>Adding default destination rules</title>
<simpara>Before you can use the Bookinfo application, you must first add default destination rules. There are two preconfigured YAML files, depending on whether or not you enabled mutual transport layer security (TLS) authentication.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To add destination rules, run one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>If you did not enable mutual TLS:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/destination-rule-all.yaml</programlisting>
</listitem>
<listitem>
<simpara>If you enabled mutual TLS:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/destination-rule-all-mtls.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">destinationrule.networking.istio.io/productpage created
destinationrule.networking.istio.io/reviews created
destinationrule.networking.istio.io/ratings created
destinationrule.networking.istio.io/details created</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-verify-install_ossm-create-mesh">
<title>Verifying the Bookinfo installation</title>
<simpara>To confirm that the sample Bookinfo application was successfully deployed, perform the following steps.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat OpenShift Service Mesh installed.</simpara>
</listitem>
<listitem>
<simpara>Complete the steps for installing the Bookinfo sample app.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure from CLI</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Verify that all pods are ready with this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n bookinfo</programlisting>
<simpara>All pods should have a status of <literal>Running</literal>. You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              READY   STATUS    RESTARTS   AGE
details-v1-55b869668-jh7hb        2/2     Running   0          12m
productpage-v1-6fc77ff794-nsl8r   2/2     Running   0          12m
ratings-v1-7d7d8d8b56-55scn       2/2     Running   0          12m
reviews-v1-868597db96-bdxgq       2/2     Running   0          12m
reviews-v2-5b64f47978-cvssp       2/2     Running   0          12m
reviews-v3-6dfd49b55b-vcwpf       2/2     Running   0          12m</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to retrieve the URL for the product page:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">echo "http://$GATEWAY_URL/productpage"</programlisting>
</listitem>
<listitem>
<simpara>Copy and paste the output in a web browser to verify the Bookinfo product page is deployed.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from Kiali web console</title>
<listitem>
<simpara>Obtain the address for the Kiali web console.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with <literal>cluster-admin</literal> rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>Click the link in the <emphasis role="strong">Location</emphasis> column for Kiali.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>. The Kiali <emphasis role="strong">Overview</emphasis> screen presents tiles for each project namespace.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In Kiali, click <emphasis role="strong">Graph</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select bookinfo from the <emphasis role="strong">Namespace</emphasis> list, and App graph from the <emphasis role="strong">Graph Type</emphasis> list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Display idle nodes</emphasis> from the <emphasis role="strong">Display</emphasis> menu.</simpara>
<simpara>This displays nodes that are defined but have not received or sent requests. It can confirm that an application is properly defined, but that no request traffic has been reported.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-graph-bookinfo.png"/>
</imageobject>
<textobject><phrase>Kiali displaying bookinfo application</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>Use the <emphasis role="strong">Duration</emphasis> menu to increase the time period to help ensure older traffic is captured.</simpara>
</listitem>
<listitem>
<simpara>Use the <emphasis role="strong">Refresh Rate</emphasis> menu to refresh traffic more or less often, or not at all.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Services</emphasis>, <emphasis role="strong">Workloads</emphasis> or <emphasis role="strong">Istio Config</emphasis> to see list views of bookinfo components, and confirm that they are healthy.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-removing_ossm-create-mesh">
<title>Removing the Bookinfo application</title>
<simpara>Follow these steps to remove the Bookinfo application.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>OpenShift Container Platform 4.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh 2.4.5 installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-delete-bookinfo-project_ossm-create-mesh">
<title>Delete the Bookinfo project</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>bookinfo</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject>, and then click <emphasis role="strong">Delete Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <literal>bookinfo</literal> in the confirmation dialog box, and then click <emphasis role="strong">Delete</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command using the CLI to create the <literal>bookinfo</literal> project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project bookinfo</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-remove-bookinfo-smmr_ossm-create-mesh">
<title>Remove the Bookinfo project from the Service Mesh member roll</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose <literal>istio-system</literal> from the list.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> link under <emphasis role="strong">Provided APIS</emphasis> for the <emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>ServiceMeshMemberRoll</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> and select <emphasis role="strong">Edit Service Mesh Member Roll</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Edit the default Service Mesh Member Roll YAML and remove <literal>bookinfo</literal> from the <emphasis role="strong">members</emphasis> list.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command using the CLI to remove the <literal>bookinfo</literal> project from the <literal>ServiceMeshMemberRoll</literal>. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system patch --type='json' smmr default -p '[{"op": "remove", "path": "/spec/members", "value":["'"bookinfo"'"]}]'</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> to update Service Mesh Member Roll.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="_next_steps_5">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>To continue the installation process, you must <link xlink:href="../../service_mesh/v2x/prepare-to-deploy-applications-ossm.xml#deploying-applications-ossm">enable sidecar injection</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="deploying-applications-ossm">
<title>Enabling sidecar injection</title>

<simpara>After adding the namespaces that contain your services to your mesh, the next step is to enable automatic sidecar injection in the Deployment resource for your application. You must enable automatic sidecar injection for each deployment.</simpara>
<simpara>If you have installed the Bookinfo sample application, the application was deployed and the sidecars were injected as part of the installation procedure. If you are using your own project and service, deploy your applications on OpenShift Container Platform.</simpara>
<simpara>For more information, see the OpenShift Container Platform documentation, <link xlink:href="../../applications/deployments/what-deployments-are.xml">Understanding deployments</link>.</simpara>
<note>
<simpara>Traffic started by Init Containers, specialized containers that run before the application containers in a pod, cannot travel outside of the service mesh by default. Any action Init Containers perform that requires establishing a network traffic connection outside of the mesh fails.</simpara>
<simpara>For more information about connecting Init Containers to a service, see the Red Hat Knowledgebase solution <link xlink:href="https://access.redhat.com/solutions/6653601">initContainer in CrashLoopBackOff on pod with Service Mesh sidecar injected</link></simpara>
</note>
<section xml:id="_prerequisites_2">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-create-mesh.xml#ossm-tutorial-bookinfo-overview_ossm-create-mesh">Services deployed to the mesh</link>, for example the Bookinfo sample application.</simpara>
</listitem>
<listitem>
<simpara>A Deployment resource file.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-automatic-sidecar-injection_deploying-applications-ossm">
<title>Enabling automatic sidecar injection</title>
<simpara>When deploying an application, you must opt-in to injection by configuring the annotation <literal>sidecar.istio.io/inject</literal> in <literal>spec.template.metadata.annotations</literal> to <literal>true</literal> in the <literal>deployment</literal> object. Opting in ensures that the sidecar injection does not interfere with other OpenShift Container Platform features such as builder pods used by numerous frameworks within the OpenShift Container Platform ecosystem.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Identify the namespaces that are part of your service mesh and the deployments that need automatic sidecar injection.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To find your deployments use the <literal>oc get</literal> command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;namespace&gt;</programlisting>
<simpara>For example, to view the deployment file for the 'ratings-v1' microservice in the <literal>bookinfo</literal> namespace, use the following command to see the resource in YAML format.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get deployment -n bookinfo ratings-v1 -o yaml</programlisting>
</listitem>
<listitem>
<simpara>Open the application&#8217;s deployment configuration YAML file in an editor.</simpara>
</listitem>
<listitem>
<simpara>Add <literal>spec.template.metadata.annotations.sidecar.istio/inject</literal> to your Deployment YAML and set <literal>sidecar.istio.io/inject</literal> to <literal>true</literal> as shown in the following example.</simpara>
<formalpara>
<title>Example snippet from bookinfo deployment-ratings-v1.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ratings-v1
  namespace: bookinfo
  labels:
    app: ratings
    version: v1
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: 'true'</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Save the Deployment configuration file.</simpara>
</listitem>
<listitem>
<simpara>Add the file back to the project that contains your app.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n &lt;namespace&gt; -f deployment.yaml</programlisting>
<simpara>In this example, <literal>bookinfo</literal> is the name of the project that contains the <literal>ratings-v1</literal> app and <literal>deployment-ratings-v1.yaml</literal> is the file you edited.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n bookinfo -f deployment-ratings-v1.yaml</programlisting>
</listitem>
<listitem>
<simpara>To verify that the resource uploaded successfully, run the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;namespace&gt; &lt;deploymentName&gt; -o yaml</programlisting>
<simpara>For example,</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n bookinfo ratings-v1 -o yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-validating-sidecar_deploying-applications-ossm">
<title>Validating sidecar injection</title>
<simpara>The Kiali console offers several ways to validate whether or not your applications, services, and workloads have a sidecar proxy.</simpara>
<figure>
<title>Missing sidecar badge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-node-badge-missing-sidecar.png"/>
</imageobject>
<textobject><phrase>Missing Sidecar badge</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <emphasis role="strong">Graph</emphasis> page displays a node badge indicating a <emphasis role="strong">Missing Sidecar</emphasis> on the following graphs:</simpara>
<itemizedlist>
<listitem>
<simpara>App graph</simpara>
</listitem>
<listitem>
<simpara>Versioned app graph</simpara>
</listitem>
<listitem>
<simpara>Workload graph</simpara>
</listitem>
</itemizedlist>
<figure>
<title>Missing sidecar icon</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-icon-missing-sidecar.png"/>
</imageobject>
<textobject><phrase>Missing Sidecar icon</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <emphasis role="strong">Applications</emphasis> page displays a <emphasis role="strong">Missing Sidecar</emphasis> icon in the <emphasis role="strong">Details</emphasis> column for any applications in a namespace that do not have a sidecar.</simpara>
<simpara>The <emphasis role="strong">Workloads</emphasis> page displays a <emphasis role="strong">Missing Sidecar</emphasis> icon in the <emphasis role="strong">Details</emphasis> column for any applications in a namespace that do not have a sidecar.</simpara>
<simpara>The <emphasis role="strong">Services</emphasis> page displays a <emphasis role="strong">Missing Sidecar</emphasis> icon in the <emphasis role="strong">Details</emphasis> column for any applications in a namespace that do not have a sidecar. When there are multiple versions of a service, you use the <emphasis role="strong">Service Details</emphasis> page to view <emphasis role="strong">Missing Sidecar</emphasis> icons.</simpara>
<simpara>The <emphasis role="strong">Workload Details</emphasis> page has a special unified <emphasis role="strong">Logs</emphasis> tab that lets you view and correlate application and proxy logs. You can view the Envoy logs as another way to validate sidecar injection for your application workloads.</simpara>
<simpara>The <emphasis role="strong">Workload Details</emphasis> page also has an <emphasis role="strong">Envoy</emphasis> tab for any workload that is an Envoy proxy or has been injected with an Envoy proxy. This tab displays a built-in Envoy dashboard that includes subtabs for <emphasis role="strong">Clusters</emphasis>, <emphasis role="strong">Listeners</emphasis>, <emphasis role="strong">Routes</emphasis>, <emphasis role="strong">Bootstrap</emphasis>, <emphasis role="strong">Config</emphasis>, and <emphasis role="strong">Metrics</emphasis>.</simpara>
<simpara>For information about enabling Envoy access logs, see the <link xlink:href="../../service_mesh/v2x/ossm-troubleshooting-istio.xml#enabling-envoy-access-logs">Troubleshooting</link> section.</simpara>
<simpara>For information about viewing Envoy logs, see <link xlink:href="../../service_mesh/v2x/ossm-observability.xml#ossm-viewing-logs_observability">Viewing logs in the Kiali console</link></simpara>
</section>
<section xml:id="ossm-sidecar-injection-env-var_deploying-applications-ossm">
<title>Setting proxy environment variables through annotations</title>
<simpara>Configuration for the Envoy sidecar proxies is managed by the <literal>ServiceMeshControlPlane</literal>.</simpara>
<simpara>You can set environment variables for the sidecar proxy for applications by adding pod annotations to the deployment in the <literal>injection-template.yaml</literal> file. The environment variables are injected to the sidecar.</simpara>
<formalpara>
<title>Example injection-template.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: resource
spec:
  replicas: 7
  selector:
    matchLabels:
      app: resource
  template:
    metadata:
      annotations:
        sidecar.maistra.io/proxyEnv: "{ \"maistra_test_env\": \"env_value\", \"maistra_test_env_2\": \"env_value_2\" }"</programlisting>
</para>
</formalpara>
<warning>
<simpara>You should never include <literal>maistra.io/</literal> labels and annotations when creating your own custom resources.  These labels and annotations indicate that the resources are generated and managed by the Operator. If you are copying content from an Operator-generated resource when creating your own resources, do not include labels or annotations that start with <literal>maistra.io/</literal>.  Resources that include these labels or annotations will be overwritten or deleted by the Operator during the next reconciliation.</simpara>
</warning>
</section>
<section xml:id="ossm-update-app-sidecar_deploying-applications-ossm">
<title>Updating sidecar proxies</title>
<simpara>In order to update the configuration for sidecar proxies the application administrator must restart the application pods.</simpara>
<simpara>If your deployment uses automatic sidecar injection, you can update the pod template in the deployment by adding or modifying an annotation. Run the following command to redeploy the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch deployment/&lt;deployment&gt; -p '{"spec":{"template":{"metadata":{"annotations":{"kubectl.kubernetes.io/restartedAt": "'`date -Iseconds`'"}}}}}'</programlisting>
<simpara>If your deployment does not use automatic sidecar injection, you must manually update the sidecars by modifying the sidecar container image specified in the deployment or pod, and then restart the pods.</simpara>
</section>
<section xml:id="_next_steps_6">
<title>Next steps</title>
<simpara>Configure Red Hat OpenShift Service Mesh features for your environment.</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-security.xml#ossm-security">Security</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-traffic-manage.xml#ossm-routing-traffic">Traffic management</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-observability.xml#ossm-observability">Metrics, logs, and traces</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="upgrading-ossm">
<title>Upgrading Service Mesh</title>

<simpara>To access the most current features of Red Hat OpenShift Service Mesh, upgrade to the current version, 2.4.5.</simpara>
<section xml:id="ossm-versioning_ossm-upgrade">
<title>Understanding versioning</title>
<simpara>Red Hat uses semantic versioning for product releases. Semantic Versioning is a 3-component number in the format of X.Y.Z, where:</simpara>
<itemizedlist>
<listitem>
<simpara>X stands for a Major version. Major releases usually denote some sort of breaking change: architectural changes, API changes, schema changes, and similar major updates.</simpara>
</listitem>
<listitem>
<simpara>Y stands for a Minor version. Minor releases contain new features and functionality while maintaining backwards compatibility.</simpara>
</listitem>
<listitem>
<simpara>Z stands for a Patch version (also known as a z-stream release). Patch releases are used to addresses Common Vulnerabilities and Exposures (CVEs) and release bug fixes. New features and functionality are generally not released as part of a Patch release.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_how_versioning_affects_service_mesh_upgrades">
<title>How versioning affects Service Mesh upgrades</title>
<simpara>Depending on the version of the update you are making, the upgrade process is different.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Patch updates</emphasis> - Patch upgrades are managed by the Operator Lifecycle Manager (OLM); they happen automatically when you update your Operators.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Minor upgrades</emphasis> - Minor upgrades require both updating to the most recent Red Hat OpenShift Service Mesh Operator version and manually modifying the <literal>spec.version</literal> value in your <literal>ServiceMeshControlPlane</literal> resources.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Major upgrades</emphasis> - Major upgrades require both updating to the most recent Red Hat OpenShift Service Mesh Operator version and manually modifying the <literal>spec.version</literal> value in your <literal>ServiceMeshControlPlane</literal> resources. Because major upgrades can contain changes that are not backwards compatible, additional manual changes might be required.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-versions_ossm-upgrade">
<title>Understanding Service Mesh versions</title>
<simpara>In order to understand what version of Red Hat OpenShift Service Mesh you have deployed on your system, you need to understand how each of the component versions is managed.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Operator</emphasis> version - The most current Operator version is 2.4.5. The Operator version number only indicates the version of the currently installed Operator. Because the Red Hat OpenShift Service Mesh Operator supports multiple versions of the Service Mesh control plane, the version of the Operator does not determine the version of your deployed <literal>ServiceMeshControlPlane</literal> resources.</simpara>
<important>
<simpara>Upgrading to the latest Operator version automatically applies patch updates, but does not automatically upgrade your Service Mesh control plane to the latest minor version.</simpara>
</important>
</listitem>
<listitem>
<simpara><emphasis role="strong">ServiceMeshControlPlane</emphasis> version - The <literal>ServiceMeshControlPlane</literal> version determines what version of Red Hat OpenShift Service Mesh you are using. The value of the <literal>spec.version</literal> field in the <literal>ServiceMeshControlPlane</literal> resource controls the architecture and configuration settings that are used to install and deploy Red Hat OpenShift Service Mesh. When you create the Service Mesh control plane you can set the version in one of two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>To configure in the Form View, select the version from the <emphasis role="strong">Control Plane Version</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>To configure in the YAML View, set the value for <literal>spec.version</literal> in the YAML file.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Operator Lifecycle Manager (OLM) does not manage Service Mesh control plane upgrades, so the version number for your Operator and <literal>ServiceMeshControlPlane</literal> (SMCP) may not match, unless you have manually upgraded your SMCP.</simpara>
</section>
</section>
<section xml:id="ossm-upgrade-considerations_ossm-upgrade">
<title>Upgrade considerations</title>
<simpara>The <literal>maistra.io/</literal> label or annotation should not be used on a user-created custom resource, because it indicates that the resource was generated by and should be managed by the Red Hat OpenShift Service Mesh Operator.</simpara>
<warning>
<simpara>During the upgrade, the Operator makes changes, including deleting or replacing files, to resources that include the following labels or annotations that indicate that the resource is managed by the Operator.</simpara>
</warning>
<simpara>Before upgrading check for user-created custom resources that include the following labels or annotations:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>maistra.io/</literal> AND the <literal>app.kubernetes.io/managed-by</literal> label set to <literal>maistra-istio-operator</literal> (Red Hat OpenShift Service Mesh)</simpara>
</listitem>
<listitem>
<simpara><literal>kiali.io/</literal> (Kiali)</simpara>
</listitem>
<listitem>
<simpara><literal>jaegertracing.io/</literal> (Red Hat OpenShift distributed tracing platform (Jaeger))</simpara>
</listitem>
<listitem>
<simpara><literal>logging.openshift.io/</literal> (Red Hat Elasticsearch)</simpara>
</listitem>
</itemizedlist>
<simpara>Before upgrading, check your user-created custom resources for labels or annotations that indicate they are Operator managed. Remove the label or annotation from custom resources that you do not want to be managed by the Operator.</simpara>
<simpara>When upgrading to version 2.0, the Operator only deletes resources with these labels in the same namespace as the SMCP.</simpara>
<simpara>When upgrading to version 2.1, the Operator deletes resources with these labels in all namespaces.</simpara>
<section xml:id="ossm-upgrade-known-issues_ossm-upgrade">
<title>Known issues that may affect upgrade</title>
<simpara>Known issues that may affect your upgrade include:</simpara>
<itemizedlist>
<listitem>
<simpara>When upgrading an Operator, custom configurations for Jaeger or Kiali might be reverted. Before upgrading an Operator, note any custom configuration settings for the Jaeger or Kiali objects in the Service Mesh production deployment so that you can recreate them.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh does not support the use of <literal>EnvoyFilter</literal> configuration except where explicitly documented. This is due to tight coupling with the underlying Envoy APIs, meaning that backward compatibility cannot be maintained. If you are using Envoy Filters, and the configuration generated by Istio has changed due to the lastest version of Envoy introduced by upgrading your <literal>ServiceMeshControlPlane</literal>, that has the potential to break any <literal>EnvoyFilter</literal> you may have implemented.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1505">OSSM-1505</link> <literal>ServiceMeshExtension</literal> does not work with OpenShift Container Platform version 4.11. Because <literal>ServiceMeshExtension</literal> has been deprecated in Red Hat OpenShift Service Mesh 2.2, this known issue will not be fixed and you must migrate your extensions to <literal>WasmPluging</literal></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1396">OSSM-1396</link> If a gateway resource contains the <literal>spec.externalIPs</literal> setting, rather than being recreated when the <literal>ServiceMeshControlPlane</literal> is updated, the gateway is removed and never recreated.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-1052">OSSM-1052</link> When configuring a Service <literal>ExternalIP</literal> for the ingressgateway in the Service Mesh control plane, the service is not created. The schema for the SMCP is missing the parameter for the service.</simpara>
<simpara>Workaround: Disable the gateway creation in the SMCP spec and manage the gateway deployment entirely manually (including Service, Role and RoleBinding).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-upgrading-operator_ossm-upgrade">
<title>Upgrading the Operators</title>
<simpara>In order to keep your Service Mesh patched with the latest security fixes, bug fixes, and software updates, you must keep your Operators updated. You initiate patch updates by upgrading your Operators.</simpara>
<important>
<simpara>The version of the Operator does <emphasis role="strong">not</emphasis> determine the version of your service mesh. The version of your deployed Service Mesh control plane determines your version of Service Mesh.</simpara>
</important>
<simpara>Because the Red Hat OpenShift Service Mesh Operator supports multiple versions of the Service Mesh control plane, updating the Red Hat OpenShift Service Mesh Operator does <emphasis>not</emphasis> update the <literal>spec.version</literal> value of your deployed <literal>ServiceMeshControlPlane</literal>. Also note that the <literal>spec.version</literal> value is a two digit number, for example 2.2, and that patch updates, for example 2.2.1, are not reflected in the SMCP version value.</simpara>
<simpara>Operator Lifecycle Manager (OLM) controls the installation, upgrade, and role-based access control (RBAC) of Operators in a cluster. The OLM runs by default in OpenShift Container Platform. OLM queries for available Operators as well as upgrades for installed Operators.</simpara>
<simpara>Whether or not you have to take action to upgrade your Operators depends on the settings you selected when installing them. When you installed each of your Operators, you selected an <emphasis role="strong">Update Channel</emphasis> and an <emphasis role="strong">Approval Strategy</emphasis>. The combination of these two settings determine when and how your Operators are updated.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Interaction of Update Channel and Approval Strategy</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top">Versioned channel</entry>
<entry align="left" valign="top">"Stable" or "Preview" Channel</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Automatic</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Automatically updates the Operator for minor and patch releases for that version only. Will not automatically update to the next major version (that is, from version 2.0 to 3.0). Manual change to Operator subscription required to update to the next major version.</simpara></entry>
<entry align="left" valign="top"><simpara>Automatically updates Operator for all major, minor, and patch releases.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Manual</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Manual updates required for minor and patch releases for the specified version. Manual change to Operator subscription required to update to the next major version.</simpara></entry>
<entry align="left" valign="top"><simpara>Manual updates required for all major, minor, and patch releases.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>When you update your Red Hat OpenShift Service Mesh Operator the Operator Lifecycle Manager (OLM) removes the old Operator pod and starts a new pod. Once the new Operator pod starts, the reconciliation process checks the <literal>ServiceMeshControlPlane</literal> (SMCP), and if there are updated container images available for any of the Service Mesh control plane components, it replaces those Service Mesh control plane pods with ones that use the new container images.</simpara>
<simpara>When you upgrade the Kiali and Red Hat OpenShift distributed tracing platform (Jaeger) Operators, the OLM reconciliation process scans the cluster and upgrades the managed instances to the version of the new Operator. For example, if you update the Red Hat OpenShift distributed tracing platform (Jaeger) Operator from version 1.30.2 to version 1.34.1, the Operator scans for running instances of distributed tracing platform (Jaeger) and upgrades them to 1.34.1 as well.</simpara>
<simpara>To stay on a particular patch version of Red Hat OpenShift Service Mesh, you would need to disable automatic updates and remain on that specific version of the Operator.</simpara>
<simpara>For more information about upgrading Operators, refer to the <link xlink:href="../../operators/admin/olm-upgrading-operators.xml">Operator Lifecycle Manager</link> documentation.</simpara>
</section>
<section xml:id="upgrading-control-plane">
<title>Upgrading the control plane</title>
<simpara>You must manually update the control plane for minor and major releases. The community Istio project recommends canary upgrades, Red Hat OpenShift Service Mesh only supports in-place upgrades. Red Hat OpenShift Service Mesh requires that you upgrade from each minor release to the next minor release in sequence. For example, you must upgrade from version 2.0 to version 2.1, and then upgrade to version 2.2. You cannot update from Red Hat OpenShift Service Mesh 2.0 to 2.2 directly.</simpara>
<simpara>When you upgrade the service mesh control plane, all Operator managed resources, for example gateways, are also upgraded.</simpara>
<simpara>Although you can deploy multiple versions of the control plane in the same cluster, Red Hat OpenShift Service Mesh does not support canary upgrades of the service mesh. That is, you can have different SCMP resources with different values for <literal>spec.version</literal>, but they cannot be managing the same mesh.</simpara>
<simpara>For more information about migrating your extensions, refer to <link xlink:href="../../service_mesh/v2x/ossm-extensions.xml#ossm-extensions-migration-overview_ossm-extensions">Migrating from ServiceMeshExtension to WasmPlugin resources</link>.</simpara>
<section xml:id="ossm-upgrade-23-24-changes_ossm-upgrade">
<title>Upgrade changes from version 2.3 to version 2.4</title>
<simpara>Upgrading the Service Mesh control plane from version 2.3 to 2.4 introduces the following behavioral changes:</simpara>
<itemizedlist>
<listitem>
<simpara>Support for Istio OpenShift Routing (IOR) has been deprecated. IOR functionality is still enabled, but it will be removed in a future release.</simpara>
</listitem>
<listitem>
<simpara>The following cipher suites are no longer supported, and were removed from the list of ciphers used in client and server side TLS negotiations.</simpara>
<itemizedlist>
<listitem>
<simpara>ECDHE-ECDSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>AES128-GCM-SHA256</simpara>
</listitem>
<listitem>
<simpara>AES128-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-ECDSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>ECDHE-RSA-AES256-SHA</simpara>
</listitem>
<listitem>
<simpara>AES256-GCM-SHA384</simpara>
</listitem>
<listitem>
<simpara>AES256-SHA</simpara>
<simpara>Applications that require access to services that use one of these cipher suites will fail to connect when the proxy initiates a TLS connection.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-upgrade-22-23-changes_ossm-upgrade">
<title>Upgrade changes from version 2.2 to version 2.3</title>
<simpara>Upgrading the Service Mesh control plane from version 2.2 to 2.3 introduces the following behavioral changes:</simpara>
<itemizedlist>
<listitem>
<simpara>This release requires use of the <literal>WasmPlugin</literal> API. Support for the <literal>ServiceMeshExtension</literal> API, which was deprecated in 2.2, has now been removed. If you attempt to upgrade while using the <literal>ServiceMeshExtension</literal> API, then the upgrade fails.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-upgrade-21-22-changes_ossm-upgrade">
<title>Upgrade changes from version 2.1 to version 2.2</title>
<simpara>Upgrading the Service Mesh control plane from version 2.1 to 2.2 introduces the following behavioral changes:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>istio-node</literal> DaemonSet is renamed to <literal>istio-cni-node</literal> to match the name in upstream Istio.</simpara>
</listitem>
<listitem>
<simpara>Istio 1.10 updated Envoy to send traffic to the application container using <literal>eth0</literal> rather than <literal>lo</literal> by default.</simpara>
</listitem>
<listitem>
<simpara>This release adds support for the <literal>WasmPlugin</literal> API and deprecates the <literal>ServiceMeshExtension</literal> API.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-upgrade-20-21-changes_ossm-upgrade">
<title>Upgrade changes from version 2.0 to version 2.1</title>
<simpara>Upgrading the Service Mesh control plane from version 2.0 to 2.1 introduces the following architectural and behavioral changes.</simpara>
<formalpara>
<title>Architecture changes</title>
<para>Mixer has been completely removed in Red Hat OpenShift Service Mesh 2.1. Upgrading from a Red Hat OpenShift Service Mesh 2.0.x release to 2.1 will be blocked if Mixer is enabled.</para>
</formalpara>
<simpara>If you see the following message when upgrading from v2.0 to v2.1, update the existing <literal>Mixer</literal> type to <literal>Istiod</literal> type in the existing Control Plane spec before you update the <literal>.spec.version</literal> field:</simpara>
<programlisting language="text" linenumbering="unnumbered">An error occurred
admission webhook smcp.validation.maistra.io denied the request: [support for policy.type "Mixer" and policy.Mixer options have been removed in v2.1, please use another alternative, support for telemetry.type "Mixer" and telemetry.Mixer options have been removed in v2.1, please use another alternative]”</programlisting>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  policy:
    type: Istiod
  telemetry:
    type: Istiod
  version: v2.4</programlisting>
<itemizedlist xml:id="ossm-upgrading-differences-behavior_ossm-upgrade">
<title>Behavioral changes</title>
<listitem>
<simpara><literal>AuthorizationPolicy</literal> updates:</simpara>
<itemizedlist>
<listitem>
<simpara>With the PROXY protocol, if you&#8217;re using <literal>ipBlocks</literal> and <literal>notIpBlocks</literal> to specify remote IP addresses, update the configuration to use <literal>remoteIpBlocks</literal> and <literal>notRemoteIpBlocks</literal> instead.</simpara>
</listitem>
<listitem>
<simpara>Added support for nested JSON Web Token (JWT) claims.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>EnvoyFilter</literal> breaking changes&gt;</simpara>
<itemizedlist>
<listitem>
<simpara>Must use <literal>typed_config</literal></simpara>
</listitem>
<listitem>
<simpara>xDS v2 is no longer supported</simpara>
</listitem>
<listitem>
<simpara>Deprecated filter names</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Older versions of proxies may report 503 status codes when receiving 1xx or 204 status codes from newer proxies.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-upgrading-smcp_ossm-upgrade">
<title>Upgrading the Service Mesh control plane</title>
<simpara>To upgrade Red Hat OpenShift Service Mesh, you must update the version field of the Red Hat OpenShift Service Mesh <literal>ServiceMeshControlPlane</literal> v2 resource. Then, once it is configured and applied, restart the application pods to update each sidecar proxy and its configuration.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are running OpenShift Container Platform 4.9 or later.</simpara>
</listitem>
<listitem>
<simpara>You have the latest Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Switch to the project that contains your <literal>ServiceMeshControlPlane</literal> resource. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Check your v2 <literal>ServiceMeshControlPlane</literal> resource configuration to verify it is valid.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to view your <literal>ServiceMeshControlPlane</literal> resource as a v2 resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -o yaml</programlisting>
<tip>
<simpara>Back up your Service Mesh control plane configuration.</simpara>
</tip>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the <literal>.spec.version</literal> field and apply the configuration.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4</programlisting>
<simpara>Alternatively, instead of using the command line, you can use the web console to edit the Service Mesh control plane. In the OpenShift Container Platform web console, click <emphasis role="strong">Project</emphasis> and select the project name you just entered.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Find your <literal>ServiceMeshControlPlane</literal> instance.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">YAML view</emphasis> and update text of the YAML file, as shown in the previous example.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-migrating-to-20_ossm-upgrade">
<title>Migrating Red Hat OpenShift Service Mesh from version 1.1 to version 2.0</title>
<simpara>Upgrading from version 1.1 to 2.0 requires manual steps that migrate your workloads and application to a new instance of Red Hat OpenShift Service Mesh running the new version.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must upgrade to OpenShift Container Platform 4.7. before you upgrade to Red Hat OpenShift Service Mesh 2.0.</simpara>
</listitem>
<listitem>
<simpara>You must have Red Hat OpenShift Service Mesh version 2.0 operator. If you selected the <emphasis role="strong">automatic</emphasis> upgrade path, the operator automatically downloads the latest information. However, there are steps you must take to use the features in Red Hat OpenShift Service Mesh version 2.0.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-migrating_ossm-upgrade">
<title>Upgrading Red Hat OpenShift Service Mesh</title>
<simpara>To upgrade Red Hat OpenShift Service Mesh, you must create an instance of Red Hat OpenShift Service Mesh <literal>ServiceMeshControlPlane</literal> v2 resource in a new namespace. Then, once it&#8217;s configured, move your microservice applications and workloads from your old mesh to the new service mesh.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check your v1 <literal>ServiceMeshControlPlane</literal> resource configuration to make sure it is valid.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to view your <literal>ServiceMeshControlPlane</literal> resource as a v2 resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -o yaml</programlisting>
</listitem>
<listitem>
<simpara>Check the <literal>spec.techPreview.errored.message</literal> field in the output for information about any invalid fields.</simpara>
</listitem>
<listitem>
<simpara>If there are invalid fields in your v1 resource, the resource is not reconciled and cannot be edited as a v2 resource. All updates to v2 fields will be overridden by the original v1 settings. To fix the invalid fields, you can replace, patch, or edit the v1 version of the resource. You can also delete the resource without fixing it. After the resource has been fixed, it can be reconciled, and you can to modify or view the v2 version of the resource.</simpara>
</listitem>
<listitem>
<simpara>To fix the resource by editing a file, use <literal>oc get</literal> to retrieve the resource, edit the text file locally, and replace the resource with the file you edited.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp.v1.maistra.io &lt;smcp_name&gt; &gt; smcp-resource.yaml
#Edit the smcp-resource.yaml file.
$ oc replace -f smcp-resource.yaml</programlisting>
</listitem>
<listitem>
<simpara>To fix the resource using patching, use <literal>oc patch</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch smcp.v1.maistra.io &lt;smcp_name&gt; --type json --patch '[{"op": "replace","path":"/spec/path/to/bad/setting","value":"corrected-value"}]'</programlisting>
</listitem>
<listitem>
<simpara>To fix the resource by editing with command line tools, use <literal>oc edit</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit smcp.v1.maistra.io &lt;smcp_name&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Back up your Service Mesh control plane configuration. Switch to the project that contains your <literal>ServiceMeshControlPlane</literal> resource.  In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command to retrieve the current configuration. Your &lt;smcp_name&gt; is specified in the metadata of your <literal>ServiceMeshControlPlane</literal> resource, for example <literal>basic-install</literal> or <literal>full-install</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get servicemeshcontrolplanes.v1.maistra.io &lt;smcp_name&gt; -o yaml &gt; &lt;smcp_name&gt;.v1.yaml</programlisting>
</listitem>
<listitem>
<simpara>Convert your <literal>ServiceMeshControlPlane</literal> to a v2 control plane version that contains information about your configuration as a starting point.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp &lt;smcp_name&gt; -o yaml &gt; &lt;smcp_name&gt;.v2.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a project. In the OpenShift Container Platform console Project menu, click <literal>New Project</literal> and enter a name for your project, <literal>istio-system-upgrade</literal>, for example. Or, you can run this command from the CLI.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project istio-system-upgrade</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>metadata.namespace</literal> field in your v2 <literal>ServiceMeshControlPlane</literal> with your new project name. In this example, use <literal>istio-system-upgrade</literal>.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>version</literal> field from 1.1 to 2.0 or remove it in your v2 <literal>ServiceMeshControlPlane</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>ServiceMeshControlPlane</literal> in the new namespace. On the command line, run the following command to deploy the control plane with the v2 version of the <literal>ServiceMeshControlPlane</literal> that you retrieved. In this example, replace `&lt;smcp_name.v2&gt; `with the path to your file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system-upgrade -f &lt;smcp_name&gt;.v2.yaml</programlisting>
<simpara>Alternatively, you can use the console to create the Service Mesh control plane. In the OpenShift Container Platform web console, click <emphasis role="strong">Project</emphasis>. Then, select the project name you just entered.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ServiceMeshControlPlane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">YAML view</emphasis> and paste text of the YAML file you retrieved into the field. Check that the <literal>apiVersion</literal> field is set to <literal>maistra.io/v2</literal> and modify the <literal>metadata.namespace</literal> field to use the new namespace, for example <literal>istio-system-upgrade</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-migrating-smcp_ossm-upgrade">
<title>Configuring the 2.0 ServiceMeshControlPlane</title>
<simpara>The <literal>ServiceMeshControlPlane</literal> resource has been changed for Red Hat OpenShift Service Mesh version 2.0. After you created a v2 version of the <literal>ServiceMeshControlPlane</literal> resource, modify it to take advantage of the new features and to fit your deployment. Consider the following changes to the specification and behavior of Red Hat OpenShift Service Mesh 2.0 as you&#8217;re modifying your <literal>ServiceMeshControlPlane</literal> resource. You can also refer to the Red Hat OpenShift Service Mesh 2.0 product documentation for new information to features you use. The v2 resource must be used for Red Hat OpenShift Service Mesh 2.0 installations.</simpara>
<section xml:id="ossm-migrating-differences-arch_ossm-upgrade">
<title>Architecture changes</title>
<simpara>The architectural units used by previous versions have been replaced by Istiod. In 2.0 the Service Mesh control plane components Mixer, Pilot, Citadel, Galley, and the sidecar injector functionality have been combined into a single component, Istiod.</simpara>
<simpara>Although Mixer is no longer supported as a control plane component, Mixer policy and telemetry plugins are now supported through WASM extensions in Istiod. Mixer can be enabled for policy and telemetry if you need to integrate legacy Mixer plugins.</simpara>
<simpara>Secret Discovery Service (SDS) is used to distribute certificates and keys to sidecars directly from Istiod. In Red Hat OpenShift Service Mesh version 1.1, secrets were generated by Citadel, which were used by the proxies to retrieve their client certificates and keys.</simpara>
</section>
<section xml:id="ossm-migrating-differences-annotation_ossm-upgrade">
<title>Annotation changes</title>
<simpara>The following annotations are no longer supported in v2.0. If you are using one of these annotations, you must update your workload before moving it to a v2.0 Service Mesh control plane.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>sidecar.maistra.io/proxyCPULimit</literal> has been replaced with <literal>sidecar.istio.io/proxyCPULimit</literal>. If you were using <literal>sidecar.maistra.io</literal> annotations on your workloads, you must modify those workloads to use <literal>sidecar.istio.io</literal> equivalents instead.</simpara>
</listitem>
<listitem>
<simpara><literal>sidecar.maistra.io/proxyMemoryLimit</literal> has been replaced with <literal>sidecar.istio.io/proxyMemoryLimit</literal></simpara>
</listitem>
<listitem>
<simpara><literal>sidecar.istio.io/discoveryAddress</literal> is no longer supported. Also, the default discovery address has moved from <literal>pilot.&lt;control_plane_namespace&gt;.svc:15010</literal> (or port 15011, if mtls is enabled) to <literal>istiod-&lt;smcp_name&gt;.&lt;control_plane_namespace&gt;.svc:15012</literal>.</simpara>
</listitem>
<listitem>
<simpara>The health status port is no longer configurable and is hard-coded to 15021.  * If you were defining a custom status port, for example, <literal>status.sidecar.istio.io/port</literal>, you must remove the override before moving the workload to a v2.0 Service Mesh control plane. Readiness checks can still be disabled by setting the status port to <literal>0</literal>.</simpara>
</listitem>
<listitem>
<simpara>Kubernetes Secret resources are no longer used to distribute client certificates for sidecars. Certificates are now distributed through Istiod&#8217;s SDS service. If you were relying on mounted secrets, they are longer available for workloads in v2.0 Service Mesh control planes.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-migrating-differences-behavior_ossm-upgrade">
<title>Behavioral changes</title>
<simpara>Some features in Red Hat OpenShift Service Mesh 2.0 work differently than they did in previous versions.</simpara>
<itemizedlist>
<listitem>
<simpara>The readiness port on gateways has moved from <literal>15020</literal> to <literal>15021</literal>.</simpara>
</listitem>
<listitem>
<simpara>The target host visibility includes VirtualService, as well as ServiceEntry resources. It includes any restrictions applied through Sidecar resources.</simpara>
</listitem>
<listitem>
<simpara>Automatic mutual TLS is enabled by default. Proxy to proxy communication is automatically configured to use mTLS, regardless of global PeerAuthentication policies in place.</simpara>
</listitem>
<listitem>
<simpara>Secure connections are always used when proxies communicate with the Service Mesh control plane regardless of <literal>spec.security.controlPlane.mtls</literal> setting. The <literal>spec.security.controlPlane.mtls</literal> setting is only used when configuring connections for Mixer telemetry or policy.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-migrating-unsupported-resources_ossm-upgrade">
<title>Migration details for unsupported resources</title>
<formalpara>
<title>Policy (authentication.istio.io/v1alpha1)</title>
<para>Policy resources must be migrated to new resource types for use with v2.0 Service Mesh control planes, PeerAuthentication and RequestAuthentication. Depending on the specific configuration in your Policy resource, you may have to configure multiple resources to achieve the same effect.</para>
</formalpara>
<formalpara>
<title>Mutual TLS</title>
<para>Mutual TLS enforcement is accomplished using the <literal>security.istio.io/v1beta1</literal> PeerAuthentication resource. The legacy <literal>spec.peers.mtls.mode</literal> field maps directly to the new resource&#8217;s <literal>spec.mtls.mode</literal> field. Selection criteria has changed from specifying a service name in <literal>spec.targets[x].name</literal> to a label selector in <literal>spec.selector.matchLabels</literal>. In PeerAuthentication, the labels must match the selector on the services named in the targets list. Any port-specific settings will need to be mapped into <literal>spec.portLevelMtls</literal>.</para>
</formalpara>
<formalpara>
<title>Authentication</title>
<para>Additional authentication methods specified in <literal>spec.origins</literal>, must be mapped into a <literal>security.istio.io/v1beta1</literal> RequestAuthentication resource.  <literal>spec.selector.matchLabels</literal> must be configured similarly to the same field on PeerAuthentication. Configuration specific to JWT principals from <literal>spec.origins.jwt</literal> items map to similar fields in <literal>spec.rules</literal> items.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.origins[x].jwt.triggerRules</literal> specified in the Policy must be mapped into one or more <literal>security.istio.io/v1beta1</literal> AuthorizationPolicy resources. Any <literal>spec.selector.labels</literal> must be configured similarly to the same field on RequestAuthentication.</simpara>
</listitem>
<listitem>
<simpara><literal>spec.origins[x].jwt.triggerRules.excludedPaths</literal> must be mapped into an AuthorizationPolicy whose spec.action is set to ALLOW, with <literal>spec.rules[x].to.operation.path</literal> entries matching the excluded paths.</simpara>
</listitem>
<listitem>
<simpara><literal>spec.origins[x].jwt.triggerRules.includedPaths</literal> must be mapped into a separate AuthorizationPolicy whose <literal>spec.action</literal> is set to <literal>ALLOW</literal>, with <literal>spec.rules[x].to.operation.path</literal> entries matching the included paths, and <literal>spec.rules.[x].from.source.requestPrincipals</literal> entries that align with the <literal>specified spec.origins[x].jwt.issuer</literal> in the Policy resource.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>ServiceMeshPolicy (maistra.io/v1)</title>
<para>ServiceMeshPolicy was configured automatically for the Service Mesh control plane through the <literal>spec.istio.global.mtls.enabled</literal> in the v1 resource or <literal>spec.security.dataPlane.mtls</literal> in the v2 resource setting. For v2 control planes, a functionally equivalent PeerAuthentication resource is created during installation. This feature is deprecated in Red Hat OpenShift Service Mesh version 2.0</para>
</formalpara>
<formalpara>
<title>RbacConfig, ServiceRole, ServiceRoleBinding (rbac.istio.io/v1alpha1)</title>
<para>These resources were replaced by the <literal>security.istio.io/v1beta1</literal> AuthorizationPolicy resource.</para>
</formalpara>
<simpara>Mimicking RbacConfig behavior requires writing a default AuthorizationPolicy whose settings depend on the spec.mode specified in the RbacConfig.</simpara>
<itemizedlist>
<listitem>
<simpara>When <literal>spec.mode</literal> is set to <literal>OFF</literal>, no resource is required as the default policy is ALLOW, unless an AuthorizationPolicy applies to the request.</simpara>
</listitem>
<listitem>
<simpara>When <literal>spec.mode</literal> is set to ON, set <literal>spec: {}</literal>.  You must create AuthorizationPolicy policies for all services in the mesh.</simpara>
</listitem>
<listitem>
<simpara><literal>spec.mode</literal> is set to <literal>ON_WITH_INCLUSION</literal>, must create an AuthorizationPolicy with <literal>spec: {}</literal> in each included namespace. Inclusion of individual services is not supported by AuthorizationPolicy. However, as soon as any AuthorizationPolicy is created that applies to the workloads for the service, all other requests not explicitly allowed will be denied.</simpara>
</listitem>
<listitem>
<simpara>When <literal>spec.mode</literal> is set to <literal>ON_WITH_EXCLUSION</literal>, it is not supported by AuthorizationPolicy. A global DENY policy can be created, but an AuthorizationPolicy must be created for every workload in the mesh because there is no allow-all policy that can be applied to either a namespace or a workload.</simpara>
</listitem>
</itemizedlist>
<simpara>AuthorizationPolicy includes configuration for both the selector to which the configuration applies, which is similar to the function ServiceRoleBinding provides and the rules which should be applied, which is similar to the function ServiceRole provides.</simpara>
<formalpara>
<title>ServiceMeshRbacConfig (maistra.io/v1)</title>
<para>This resource is replaced by using a <literal>security.istio.io/v1beta1</literal> AuthorizationPolicy resource with an empty spec.selector in the Service Mesh control plane&#8217;s namespace.  This policy will be the default authorization policy applied to all workloads in the mesh.  For specific migration details, see RbacConfig above.</para>
</formalpara>
</section>
<section xml:id="ossm-migrating-mixer_ossm-upgrade">
<title>Mixer plugins</title>
<simpara>Mixer components are disabled by default in version 2.0. If you rely on Mixer plugins for your workload, you must configure your version 2.0 <literal>ServiceMeshControlPlane</literal> to include the Mixer components.</simpara>
<simpara>To enable the Mixer policy components, add the following snippet to your <literal>ServiceMeshControlPlane</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  policy:
    type: Mixer</programlisting>
<simpara>To enable the Mixer telemetry components, add the following snippet to your <literal>ServiceMeshControlPlane</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  telemetry:
    type: Mixer</programlisting>
<simpara>Legacy mixer plugins can also be migrated to WASM and integrated using the new ServiceMeshExtension (maistra.io/v1alpha1) custom resource.</simpara>
<simpara>Built-in WASM filters included in the upstream Istio distribution are not available in Red Hat OpenShift Service Mesh 2.0.</simpara>
</section>
<section xml:id="ossm-migrating-mtls_ossm-upgrade">
<title>Mutual TLS changes</title>
<simpara>When using mTLS with workload specific PeerAuthentication policies, a corresponding DestinationRule is required to allow traffic if the workload policy differs from the namespace/global policy.</simpara>
<simpara>Auto mTLS is enabled by default, but can be disabled by setting <literal>spec.security.dataPlane.automtls</literal> to false in the <literal>ServiceMeshControlPlane</literal> resource. When disabling auto mTLS, DestinationRules may be required for proper communication between services. For example, setting PeerAuthentication to <literal>STRICT</literal> for one namespace may prevent services in other namespaces from accessing them, unless a DestinationRule configures TLS mode for the services in the namespace.</simpara>
<simpara>For information about mTLS, see <link xlink:href="../../service_mesh/v2x/ossm-security.xml#ossm-security-mtls_ossm-security">Enabling mutual Transport Layer Security (mTLS)</link></simpara>
<section xml:id="_other_mtls_examples">
<title>Other mTLS Examples</title>
<simpara>To disable mTLS For productpage service in the bookinfo sample application, your Policy resource was configured the following way for Red Hat OpenShift Service Mesh v1.1.</simpara>
<formalpara>
<title>Example Policy resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: productpage-mTLS-disable
  namespace: &lt;namespace&gt;
spec:
  targets:
  - name: productpage</programlisting>
</para>
</formalpara>
<simpara>To disable mTLS For productpage service in the bookinfo sample application, use the following example to configure your PeerAuthentication resource for Red Hat OpenShift Service Mesh v2.0.</simpara>
<formalpara>
<title>Example PeerAuthentication resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: productpage-mTLS-disable
  namespace: &lt;namespace&gt;
spec:
  mtls:
    mode: DISABLE
  selector:
    matchLabels:
      # this should match the selector for the "productpage" service
      app: productpage</programlisting>
</para>
</formalpara>
<simpara>To enable mTLS With JWT authentication for the <literal>productpage</literal> service in the bookinfo sample application, your Policy resource was configured the following way for Red Hat OpenShift Service Mesh v1.1.</simpara>
<formalpara>
<title>Example Policy resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
  name: productpage-mTLS-with-JWT
  namespace: &lt;namespace&gt;
spec:
  targets:
  - name: productpage
    ports:
    - number: 9000
  peers:
  - mtls:
  origins:
  - jwt:
      issuer: "https://securetoken.google.com"
      audiences:
      - "productpage"
      jwksUri: "https://www.googleapis.com/oauth2/v1/certs"
      jwtHeaders:
      - "x-goog-iap-jwt-assertion"
      triggerRules:
      - excludedPaths:
        - exact: /health_check
  principalBinding: USE_ORIGIN</programlisting>
</para>
</formalpara>
<simpara>To enable mTLS With JWT authentication for the productpage service in the bookinfo sample application, use the following example to configure your PeerAuthentication resource for Red Hat OpenShift Service Mesh v2.0.</simpara>
<formalpara>
<title>Example PeerAuthentication resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">#require mtls for productpage:9000
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: productpage-mTLS-with-JWT
  namespace: &lt;namespace&gt;
spec:
  selector:
    matchLabels:
      # this should match the selector for the "productpage" service
      app: productpage
  portLevelMtls:
    9000:
      mode: STRICT
---
#JWT authentication for productpage
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: productpage-mTLS-with-JWT
  namespace: &lt;namespace&gt;
spec:
  selector:
    matchLabels:
      # this should match the selector for the "productpage" service
      app: productpage
  jwtRules:
  - issuer: "https://securetoken.google.com"
    audiences:
    - "productpage"
    jwksUri: "https://www.googleapis.com/oauth2/v1/certs"
    fromHeaders:
    - name: "x-goog-iap-jwt-assertion"
---
#Require JWT token to access product page service from
#any client to all paths except /health_check
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: productpage-mTLS-with-JWT
  namespace: &lt;namespace&gt;
spec:
  action: ALLOW
  selector:
    matchLabels:
      # this should match the selector for the "productpage" service
      app: productpage
  rules:
  - to: # require JWT token to access all other paths
      - operation:
          notPaths:
          - /health_check
    from:
      - source:
          # if using principalBinding: USE_PEER in the Policy,
          # then use principals, e.g.
          # principals:
          # - “*”
          requestPrincipals:
          - “*”
  - to: # no JWT token required to access health_check
      - operation:
          paths:
          - /health_check</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="ossm-migrating-config-recipes_ossm-upgrade">
<title>Configuration recipes</title>
<simpara>You can configure the following items with these configuration recipes.</simpara>
<section xml:id="ossm-migrating-config-mtls_ossm-upgrade">
<title>Mutual TLS in a data plane</title>
<simpara>Mutual TLS for data plane communication is configured through <literal>spec.security.dataPlane.mtls</literal> in the <literal>ServiceMeshControlPlane</literal> resource, which is <literal>false</literal> by default.</simpara>
</section>
<section xml:id="ossm-migrating-config-sign-key_ossm-upgrade">
<title>Custom signing key</title>
<simpara>Istiod manages client certificates and private keys used by service proxies. By default, Istiod uses a self-signed certificate for signing, but you can configure a custom certificate and private key. For more information about how to configure signing keys, see <link xlink:href="../../service_mesh/v2x/ossm-security.xml#ossm-cert-manage_ossm-security">Adding an external certificate authority key and certificate</link></simpara>
</section>
<section xml:id="ossm-migrating-config-tracing_ossm-upgrade">
<title>Tracing</title>
<simpara>Tracing is configured in <literal>spec.tracing</literal>. Currently, the only type of tracer that is supported is <literal>Jaeger</literal>. Sampling is a scaled integer representing 0.01% increments, for example, 1 is 0.01% and 10000 is 100%. The tracing implementation and sampling rate can be specified:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  tracing:
    sampling: 100 # 1%
    type: Jaeger</programlisting>
<simpara>Jaeger is configured in the <literal>addons</literal> section of the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  addons:
    jaeger:
      name: jaeger
      install:
        storage:
          type: Memory # or Elasticsearch for production mode
          memory:
            maxTraces: 100000
          elasticsearch: # the following values only apply if storage:type:=Elasticsearch
            storage: # specific storageclass configuration for the Jaeger Elasticsearch (optional)
              size: "100G"
              storageClassName: "storageclass"
            nodeCount: 3
            redundancyPolicy: SingleRedundancy
  runtime:
    components:
      tracing.jaeger: {} # general Jaeger specific runtime configuration (optional)
      tracing.jaeger.elasticsearch: #runtime configuration for Jaeger Elasticsearch deployment (optional)
        container:
          resources:
            requests:
              memory: "1Gi"
              cpu: "500m"
            limits:
              memory: "1Gi"</programlisting>
<simpara>The Jaeger installation can be customized with the <literal>install</literal> field. Container configuration, such as resource limits is configured in <literal>spec.runtime.components.jaeger</literal> related fields. If a Jaeger resource matching the value of <literal>spec.addons.jaeger.name</literal> exists, the Service Mesh control plane will be configured to use the existing installation. Use an existing Jaeger resource to fully customize your Jaeger installation.</simpara>
</section>
<section xml:id="ossm-migrating-config-vis_ossm-upgrade">
<title>Visualization</title>
<simpara>Kiali and Grafana are configured under the <literal>addons</literal> section of the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  addons:
    grafana:
      enabled: true
      install: {} # customize install
    kiali:
      enabled: true
      name: kiali
      install: {} # customize install</programlisting>
<simpara>The Grafana and Kiali installations can be customized through their respective <literal>install</literal> fields. Container customization, such as resource limits, is configured in <literal>spec.runtime.components.kiali</literal> and <literal>spec.runtime.components.grafana</literal>. If an existing Kiali resource matching the value of name exists, the Service Mesh control plane configures the Kiali resource for use with the control plane. Some fields in the Kiali resource are overridden, such as the <literal>accessible_namespaces</literal> list, as well as the endpoints for Grafana, Prometheus, and tracing. Use an existing resource to fully customize your Kiali installation.</simpara>
</section>
<section xml:id="_resource_utilization_and_scheduling">
<title>Resource utilization and scheduling</title>
<simpara>Resources are configured under <literal>spec.runtime.&lt;component&gt;</literal>. The following component names are supported.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Versions supported</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>security</simpara></entry>
<entry align="left" valign="top"><simpara>Citadel container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>galley</simpara></entry>
<entry align="left" valign="top"><simpara>Galley container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>pilot</simpara></entry>
<entry align="left" valign="top"><simpara>Pilot/Istiod container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>mixer</simpara></entry>
<entry align="left" valign="top"><simpara>istio-telemetry and istio-policy containers</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mixer.policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>istio-policy container</simpara></entry>
<entry align="left" valign="top"><simpara>v2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mixer.telemetry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>istio-telemetry container</simpara></entry>
<entry align="left" valign="top"><simpara>v2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>global.oauthproxy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>oauth-proxy container used with various addons</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sidecarInjectorWebhook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>sidecar injector webhook container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger</literal></simpara></entry>
<entry align="left" valign="top"><simpara>general Jaeger container - not all settings may be applied. Complete customization of Jaeger installation is supported by specifying an existing Jaeger resource in the Service Mesh control plane configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger.agent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>settings specific to Jaeger agent</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger.allInOne</literal></simpara></entry>
<entry align="left" valign="top"><simpara>settings specific to Jaeger allInOne</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger.collector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>settings specific to Jaeger collector</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger.elasticsearch</literal></simpara></entry>
<entry align="left" valign="top"><simpara>settings specific to Jaeger elasticsearch deployment</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing.jaeger.query</literal></simpara></entry>
<entry align="left" valign="top"><simpara>settings specific to Jaeger query</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>prometheus</simpara></entry>
<entry align="left" valign="top"><simpara>prometheus container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>kiali</simpara></entry>
<entry align="left" valign="top"><simpara>Kiali container - complete customization of Kiali installation is supported by specifying an existing Kiali resource in the Service Mesh control plane configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>grafana</simpara></entry>
<entry align="left" valign="top"><simpara>Grafana container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3scale</simpara></entry>
<entry align="left" valign="top"><simpara>3scale container</simpara></entry>
<entry align="left" valign="top"><simpara>v1.0/1.1/2.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>wasmExtensions.cacher</literal></simpara></entry>
<entry align="left" valign="top"><simpara>WASM extensions cacher container</simpara></entry>
<entry align="left" valign="top"><simpara>v2.0 - tech preview</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Some components support resource limiting and scheduling. For more information, see <link xlink:href="../../service_mesh/v2x/ossm-performance-scalability.xml#ossm-performance-scalability">Performance and scalability</link>.</simpara>
</section>
</section>
<section xml:id="ossm-migrrating-apps_ossm-upgrade">
<title>Next steps for migrating your applications and workloads</title>
<simpara>Move the application workload to the new mesh and remove the old instances to complete your upgrade.</simpara>
</section>
</section>
</section>
<section xml:id="upgrading-data-plane">
<title>Upgrading the data plane</title>
<simpara>Your data plane will still function after you have upgraded the control plane. But in order to apply updates to the Envoy proxy and any changes to the proxy configuration, you must restart your application pods and workloads.</simpara>
<section xml:id="ossm-upgrading-apps-workloads_ossm-upgrade">
<title>Updating your applications and workloads</title>
<simpara>To complete the migration, restart all of the application pods in the mesh to upgrade the Envoy sidecar proxies and their configuration.</simpara>
<simpara>To perform a rolling update of a deployment use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rollout restart &lt;deployment&gt;</programlisting>
<simpara>You must perform a rolling update for all applications that make up the mesh.</simpara>
</section>
</section>
</section>
<section xml:id="ossm-profiles-users">
<title>Managing users and profiles</title>

<section xml:id="ossm-members_ossm-profiles-users">
<title>Creating the Red Hat OpenShift Service Mesh members</title>
<simpara><literal>ServiceMeshMember</literal> resources provide a way for Red Hat OpenShift Service Mesh administrators to delegate permissions to add projects to a service mesh, even when the respective users don&#8217;t have direct access to the service mesh project or member roll. While project administrators are automatically given permission to create the <literal>ServiceMeshMember</literal> resource in their project, they cannot point it to any <literal>ServiceMeshControlPlane</literal> until the service mesh administrator explicitly grants access to the service mesh. Administrators can grant users permissions to access the mesh by granting them the <literal>mesh-user</literal> user role. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user -n istio-system --role-namespace istio-system mesh-user &lt;user_name&gt;</programlisting>
<simpara>Administrators can modify the <literal>mesh-user</literal> role binding in the Service Mesh control plane project to specify the users and groups that are granted access. The <literal>ServiceMeshMember</literal> adds the project to the <literal>ServiceMeshMemberRoll</literal> within the Service Mesh control plane project that it references.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMember
metadata:
  name: default
spec:
  controlPlaneRef:
    namespace: istio-system
    name: basic</programlisting>
<simpara>The <literal>mesh-users</literal> role binding is created automatically after the administrator creates the <literal>ServiceMeshControlPlane</literal> resource. An administrator can use the following command to add a role to a user.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user</programlisting>
<simpara>The administrator can also create the <literal>mesh-user</literal> role binding before the administrator creates the <literal>ServiceMeshControlPlane</literal> resource. For example, the administrator can create it in the same <literal>oc apply</literal> operation as the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<simpara>This example adds a role binding for <literal>alice</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  namespace: istio-system
  name: mesh-users
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mesh-user
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: alice</programlisting>
</section>
<section xml:id="ossm-control-plane-profiles_ossm-profiles-users">
<title>Creating Service Mesh control plane profiles</title>
<simpara>You can create reusable configurations with <literal>ServiceMeshControlPlane</literal> profiles. Individual users can extend the profiles they create with their own configurations. Profiles can also inherit configuration information from other profiles. For example, you can create an accounting control plane for the accounting team and a marketing control plane for the marketing team. If you create a development template and a production template, members of the marketing team and the accounting team can extend the development and production profiles with team-specific customization.</simpara>
<simpara>When you configure Service Mesh control plane profiles, which follow the same syntax as the <literal>ServiceMeshControlPlane</literal>, users inherit settings in a hierarchical fashion. The Operator is delivered with a <literal>default</literal> profile with default settings for Red Hat OpenShift Service Mesh.</simpara>
<section xml:id="ossm-create-configmap_ossm-profiles-users">
<title>Creating the ConfigMap</title>
<simpara>To add custom profiles, you must create a <literal>ConfigMap</literal> named <literal>smcp-templates</literal> in the <literal>openshift-operators</literal> project. The Operator container automatically mounts the <literal>ConfigMap</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Location of the Operator deployment.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a <literal>cluster-admin</literal>. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>From the CLI, run this command to create the ConfigMap named <literal>smcp-templates</literal> in the <literal>openshift-operators</literal> project and replace <literal>&lt;profiles-directory&gt;</literal> with the location of the <literal>ServiceMeshControlPlane</literal> files on your local disk:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap --from-file=&lt;profiles-directory&gt; smcp-templates -n openshift-operators</programlisting>
</listitem>
<listitem>
<simpara>You can use the <literal>profiles</literal> parameter in the <literal>ServiceMeshControlPlane</literal> to specify one or more templates.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: maistra.io/v2
  kind: ServiceMeshControlPlane
  metadata:
    name: basic
  spec:
    profiles:
    - default</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-network-policy_ossm-profiles-users">
<title>Setting the correct network policy</title>
<simpara>Service Mesh creates network policies in the Service Mesh control plane and member namespaces to allow traffic between them. Before you deploy, consider the following conditions to ensure the services in your service mesh that were previously exposed through an OpenShift Container Platform route.</simpara>
<itemizedlist>
<listitem>
<simpara>Traffic into the service mesh must always go through the ingress-gateway for Istio to work properly.</simpara>
</listitem>
<listitem>
<simpara>Deploy services external to the service mesh in separate namespaces that are not in any service mesh.</simpara>
</listitem>
<listitem>
<simpara>Non-mesh services that need to be deployed within a service mesh enlisted namespace should label their deployments <literal>maistra.io/expose-route: "true"</literal>, which ensures OpenShift Container Platform routes to these services still work.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ossm-security">
<title>Security</title>

<simpara>If your service mesh application is constructed with a complex array of microservices, you can use Red Hat OpenShift Service Mesh to customize the security of the communication between those services. The infrastructure of OpenShift Container Platform along with the traffic management features of Service Mesh help you manage the complexity of your applications and secure microservices.</simpara>
<formalpara>
<title>Before you begin</title>
<para>If you have a project, add your project to the <link xlink:href="../../service_mesh/v2x/ossm-create-mesh.xml#ossm-member-roll-create_ossm-create-mesh"><literal>ServiceMeshMemberRoll</literal> resource</link>.</para>
</formalpara>
<simpara>If you don&#8217;t have a project, install the <link xlink:href="../../service_mesh/v2x/ossm-create-mesh.xml#ossm-tutorial-bookinfo-overview_ossm-create-mesh">Bookinfo sample application</link> and add it to the <literal>ServiceMeshMemberRoll</literal> resource. The sample application helps illustrate security concepts.</simpara>
<section xml:id="ossm-security-mtls_ossm-security">
<title>About mutual Transport Layer Security (mTLS)</title>
<simpara>Mutual Transport Layer Security (mTLS) is a protocol that enables two parties to authenticate each other. It is the default mode of authentication in some protocols (IKE, SSH) and optional in others (TLS). You can use mTLS without changes to the application or service code. The TLS is handled entirely by the service mesh infrastructure and between the two sidecar proxies.</simpara>
<simpara>By default, mTLS in Red Hat OpenShift Service Mesh is enabled and set to permissive mode, where the sidecars in Service Mesh accept both plain-text traffic and connections that are encrypted using mTLS. If a service in your mesh configured to use strict mTLS is communicating with a service outside the mesh, communication might break between those services because strict mTLS requires both the client and the server to be able to verify the identify of each other. Use permissive mode while you migrate your workloads to Service Mesh. Then, you can enable strict mTLS across your mesh, namespace, or application.</simpara>
<simpara>Enabling mTLS across your mesh at the Service Mesh control plane level secures all the traffic in your service mesh without rewriting your applications and workloads. You can secure namespaces in your mesh at the data plane level in the <literal>ServiceMeshControlPlane</literal> resource. To customize traffic encryption connections, configure namespaces at the application level with <literal>PeerAuthentication</literal> and <literal>DestinationRule</literal> resources.</simpara>
<section xml:id="ossm-security-enabling-strict-mtls_ossm-security">
<title>Enabling strict mTLS across the service mesh</title>
<simpara>If your workloads do not communicate with outside services, you can quickly enable mTLS across your mesh without communication interruptions. You can enable it by setting <literal>spec.security.dataPlane.mtls</literal> to <literal>true</literal> in the <literal>ServiceMeshControlPlane</literal> resource. The Operator creates the required resources.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  version: v2.4
  security:
    dataPlane:
      mtls: true</programlisting>
<simpara>You can also enable mTLS by using the OpenShift Container Platform web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Service Mesh Control Plane</emphasis> under <emphasis role="strong">Provided APIs</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your <literal>ServiceMeshControlPlane</literal> resource, for example, <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Details</emphasis> page, click the toggle in the <emphasis role="strong">Security</emphasis> section for <emphasis role="strong">Data Plane Security</emphasis>.</simpara>
</listitem>
</orderedlist>
<section xml:id="ossm-security-mtls-sidecars-incoming-services_ossm-security">
<title>Configuring sidecars for incoming connections for specific services</title>
<simpara>You can also configure mTLS for individual services by creating a policy.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following example.</simpara>
<formalpara>
<title>PeerAuthentication Policy example policy.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: &lt;namespace&gt;
spec:
  mtls:
    mode: STRICT</programlisting>
</para>
</formalpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Replace <literal>&lt;namespace&gt;</literal> with the namespace where the service is located.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to create the resource in the namespace where the service is located. It must match the <literal>namespace</literal> field in the Policy resource you just created.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n &lt;namespace&gt; -f &lt;policy.yaml&gt;</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>If you are not using automatic mTLS and you are setting <literal>PeerAuthentication</literal> to STRICT, you must create a <literal>DestinationRule</literal> resource for your service.</simpara>
</note>
</section>
<section xml:id="ossm-security-mtls-sidecars-outgoing_ossm-security">
<title>Configuring sidecars for outgoing connections</title>
<simpara>Create a destination rule to configure Service Mesh to use mTLS when sending requests to other services in the mesh.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following example.</simpara>
<formalpara>
<title>DestinationRule example destination-rule.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: default
  namespace: &lt;namespace&gt;
spec:
  host: "*.&lt;namespace&gt;.svc.cluster.local"
  trafficPolicy:
   tls:
    mode: ISTIO_MUTUAL</programlisting>
</para>
</formalpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Replace <literal>&lt;namespace&gt;</literal> with the namespace where the service is located.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to create the resource in the namespace where the service is located. It must match the <literal>namespace</literal> field in the <literal>DestinationRule</literal> resource you just created.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n &lt;namespace&gt; -f &lt;destination-rule.yaml&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-security-min-max-tls_ossm-security">
<title>Setting the minimum and maximum protocol versions</title>
<simpara>If your environment has specific requirements for encrypted traffic in your service mesh, you can control the cryptographic functions that are allowed by setting the <literal>spec.security.controlPlane.tls.minProtocolVersion</literal> or <literal>spec.security.controlPlane.tls.maxProtocolVersion</literal> in your <literal>ServiceMeshControlPlane</literal> resource. Those values, configured in your Service Mesh control plane resource, define the minimum and maximum TLS version used by mesh components when communicating securely over TLS.</simpara>
<simpara>The default is <literal>TLS_AUTO</literal> and does not specify a version of TLS.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Valid values</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>TLS_AUTO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>default</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Service Mesh Control Plane</emphasis> under <emphasis role="strong">Provided APIs</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your <literal>ServiceMeshControlPlane</literal> resource, for example, <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Insert the following code snippet in the YAML editor. Replace the value in the <literal>minProtocolVersion</literal> with the TLS version value. In this example, the minimum TLS version is set to <literal>TLSv1_2</literal>.</simpara>
<formalpara>
<title>ServiceMeshControlPlane snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ServiceMeshControlPlane
spec:
  security:
    controlPlane:
      tls:
        minProtocolVersion: TLSv1_2</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Refresh</emphasis> to verify that the changes updated correctly.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-validating-sidecar_ossm-security">
<title>Validating encryption with Kiali</title>
<simpara>The Kiali console offers several ways to validate whether or not your applications, services, and workloads have mTLS encryption enabled.</simpara>
<figure>
<title>Masthead icon mesh-wide mTLS enabled</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-masthead-mtls-enabled.png"/>
</imageobject>
<textobject><phrase>mTLS enabled</phrase></textobject>
</mediaobject>
</figure>
<simpara>At the right side of the masthead, Kiali shows a lock icon when the mesh has strictly enabled mTLS for the whole service mesh. It means that all communications in the mesh use mTLS.</simpara>
<figure>
<title>Masthead icon mesh-wide mTLS partially enabled</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-masthead-mtls-partial.png"/>
</imageobject>
<textobject><phrase>mTLS partially enabled</phrase></textobject>
</mediaobject>
</figure>
<simpara>Kiali displays a hollow lock icon when either the mesh is configured in <literal>PERMISSIVE</literal> mode or there is a error in the mesh-wide mTLS configuration.</simpara>
<figure>
<title>Security badge</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-graph-badge-security.png"/>
</imageobject>
<textobject><phrase>Security badge</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <emphasis role="strong">Graph</emphasis> page has the option to display a <emphasis role="strong">Security</emphasis> badge on the graph edges to indicate that mTLS is enabled.  To enable security badges on the graph, from the <emphasis role="strong">Display</emphasis> menu, under <emphasis role="strong">Show Badges</emphasis>, select the <emphasis role="strong">Security</emphasis> checkbox.  When an edge shows a lock icon, it means at least one request with mTLS enabled is present.  In case there are both mTLS and non-mTLS requests, the side-panel will show the percentage of requests that use mTLS.</simpara>
<simpara>The <emphasis role="strong">Applications Detail Overview</emphasis> page displays a <emphasis role="strong">Security</emphasis> icon on the graph edges where at least one request with mTLS enabled is present.</simpara>
<simpara>The <emphasis role="strong">Workloads Detail Overview</emphasis> page displays a <emphasis role="strong">Security</emphasis> icon on the graph edges where at least one request with mTLS enabled is present.</simpara>
<simpara>The <emphasis role="strong">Services Detail Overview</emphasis> page displays a <emphasis role="strong">Security</emphasis> icon on the graph edges where at least one request with mTLS enabled is present.  Also note that Kiali displays a lock icon in the <emphasis role="strong">Network</emphasis> section next to ports that are configured for mTLS.</simpara>
</section>
</section>
<section xml:id="ossm-vs-istio_ossm-security">
<title>Configuring Role Based Access Control (RBAC)</title>
<simpara>Role-based access control (RBAC) objects determine whether a user or service is allowed to perform a given action within a project. You can define mesh-, namespace-, and workload-wide access control for your workloads in the mesh.</simpara>
<simpara>To configure RBAC, create an <literal>AuthorizationPolicy</literal> resource in the namespace for which you are configuring access. If you are configuring mesh-wide access, use the project where you installed the Service Mesh control plane, for example <literal>istio-system</literal>.</simpara>
<simpara>For example, with RBAC, you can create policies that:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure intra-project communication.</simpara>
</listitem>
<listitem>
<simpara>Allow or deny full access to all workloads in the default namespace.</simpara>
</listitem>
<listitem>
<simpara>Allow or deny ingress gateway access.</simpara>
</listitem>
<listitem>
<simpara>Require a token for access.</simpara>
</listitem>
</itemizedlist>
<simpara>An authorization policy includes a selector, an action, and a list of rules:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>selector</literal> field specifies the target of the policy.</simpara>
</listitem>
<listitem>
<simpara>The <literal>action</literal> field specifies whether to allow or deny the request.</simpara>
</listitem>
<listitem>
<simpara>The <literal>rules</literal> field specifies when to trigger the action.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>from</literal> field specifies constraints on the request origin.</simpara>
</listitem>
<listitem>
<simpara>The <literal>to</literal> field specifies constraints on request target and parameters.</simpara>
</listitem>
<listitem>
<simpara>The <literal>when</literal> field specifies additional conditions that to apply the rule.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create your <literal>AuthorizationPolicy</literal> resource. The following example shows a resource that updates the ingress-policy <literal>AuthorizationPolicy</literal> to deny an IP address from accessing the ingress gateway.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: ingress-policy
  namespace: istio-system
spec:
  selector:
    matchLabels:
      app: istio-ingressgateway
  action: DENY
  rules:
  - from:
    - source:
      ipBlocks: ["1.2.3.4"]</programlisting>
</listitem>
<listitem>
<simpara>Run the following command after you write your resource to create your resource in your namespace. The namespace must match your <literal>metadata.namespace</literal> field in your <literal>AuthorizationPolicy</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f &lt;filename&gt;</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Next steps</title>
<para>Consider the following examples for other common configurations.</para>
</formalpara>
<section xml:id="_configure_intra_project_communication">
<title>Configure intra-project communication</title>
<simpara>You can use <literal>AuthorizationPolicy</literal> to configure your Service Mesh control plane to allow or deny the traffic communicating with your mesh or services in your mesh.</simpara>
<section xml:id="_restrict_access_to_services_outside_a_namespace">
<title>Restrict access to services outside a namespace</title>
<simpara>You can deny requests from any source that is not in the <literal>bookinfo</literal> namespace with the following <literal>AuthorizationPolicy</literal> resource example.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
 name: httpbin-deny
 namespace: bookinfo
spec:
 selector:
   matchLabels:
     app: httpbin
     version: v1
 action: DENY
 rules:
 - from:
   - source:
       notNamespaces: ["bookinfo"]</programlisting>
</section>
<section xml:id="_creating_allow_all_and_default_deny_all_authorization_policies">
<title>Creating allow-all and default deny-all authorization policies</title>
<simpara>The following example shows an allow-all authorization policy that allows full access to all workloads in the <literal>bookinfo</literal> namespace.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: allow-all
  namespace: bookinfo
spec:
  action: ALLOW
  rules:
  - {}</programlisting>
<simpara>The following example shows a policy that denies any access to all workloads in the <literal>bookinfo</literal> namespace.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: deny-all
  namespace: bookinfo
spec:
  {}</programlisting>
</section>
</section>
<section xml:id="_allow_or_deny_access_to_the_ingress_gateway">
<title>Allow or deny access to the ingress gateway</title>
<simpara>You can set an authorization policy to add allow or deny lists based on IP addresses.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: ingress-policy
  namespace: istio-system
spec:
  selector:
    matchLabels:
      app: istio-ingressgateway
  action: ALLOW
  rules:
  - from:
    - source:
       ipBlocks: ["1.2.3.4", "5.6.7.0/24"]</programlisting>
</section>
<section xml:id="_restrict_access_with_json_web_token">
<title>Restrict access with JSON Web Token</title>
<simpara>You can restrict what can access your mesh with a JSON Web Token (JWT). After authentication, a user or service can access routes, services that are associated with that token.</simpara>
<simpara>Create a <literal>RequestAuthentication</literal> resource, which defines the authentication methods that are supported by a workload. The following example accepts a JWT issued by <literal><link xlink:href="http://localhost:8080/auth/realms/master">http://localhost:8080/auth/realms/master</link></literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "security.istio.io/v1beta1"
kind: "RequestAuthentication"
metadata:
  name: "jwt-example"
  namespace: bookinfo
spec:
  selector:
    matchLabels:
      app: httpbin
  jwtRules:
  - issuer: "http://localhost:8080/auth/realms/master"
    jwksUri: "http://keycloak.default.svc:8080/auth/realms/master/protocol/openid-connect/certs"</programlisting>
<simpara>Then, create an <literal>AuthorizationPolicy</literal> resource in the same namespace to work with <literal>RequestAuthentication</literal> resource you created. The following example requires a JWT to be present in the <literal>Authorization</literal> header when sending a request to <literal>httpbin</literal> workloads.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "security.istio.io/v1beta1"
kind: "AuthorizationPolicy"
metadata:
  name: "frontend-ingress"
  namespace: bookinfo
spec:
  selector:
    matchLabels:
      app: httpbin
  action: DENY
  rules:
  - from:
    - source:
        notRequestPrincipals: ["*"]</programlisting>
</section>
</section>
<section xml:id="ossm-security-cipher_ossm-security">
<title>Configuring cipher suites and ECDH curves</title>
<simpara>Cipher suites and Elliptic-curve Diffie–Hellman (ECDH curves) can help you secure your service mesh. You can define a comma separated list of cipher suites using <literal>spec.security.controlplane.tls.cipherSuites</literal> and ECDH curves using <literal>spec.security.controlplane.tls.ecdhCurves</literal> in your <literal>ServiceMeshControlPlane</literal> resource. If either of these attributes are empty, then the default values are used.</simpara>
<simpara>The <literal>cipherSuites</literal> setting is effective if your service mesh uses TLS 1.2 or earlier. It has no effect when negotiating with TLS 1.3.</simpara>
<simpara>Set your cipher suites in the comma separated list in order of priority. For example, <literal>ecdhCurves: CurveP256, CurveP384</literal> sets <literal>CurveP256</literal> as a higher priority than <literal>CurveP384</literal>.</simpara>
<note>
<simpara>You must include either <literal>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</literal> or  <literal>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</literal> when you configure the cipher suite. HTTP/2 support requires at least one of these cipher suites.</simpara>
</note>
<simpara>The supported cipher suites are:</simpara>
<itemizedlist>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_3DES_EDE_CBC_SHA</simpara>
</listitem>
</itemizedlist>
<simpara>The supported ECDH Curves are:</simpara>
<itemizedlist>
<listitem>
<simpara>CurveP256</simpara>
</listitem>
<listitem>
<simpara>CurveP384</simpara>
</listitem>
<listitem>
<simpara>CurveP521</simpara>
</listitem>
<listitem>
<simpara>X25519</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-configuring-jwks-resolver-ca_ossm-security">
<title>Configuring JSON Web Key Sets resolver certificate authority</title>
<simpara>You can configure your own JSON Web Key Sets (JWKS) resolver certificate authority (CA) from the <literal>ServiceMeshControlPlane</literal> (SMCP) spec.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>ServiceMeshControlPlane</literal> spec file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ oc edit smcp &lt;smcp-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Enable <literal>mtls</literal> for the data plane by setting the value of the <literal>mtls</literal> field to <literal>true</literal> in the <literal>ServiceMeshControlPlane</literal> spec, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  security:
    dataPlane:
        mtls: true # enable mtls for data plane
    # JWKSResolver extra CA
    # PEM-encoded certificate content to trust an additional CA
    jwksResolverCA: |
        -----BEGIN CERTIFICATE-----
        [...]
        [...]
        -----END CERTIFICATE-----
...</programlisting>
</listitem>
<listitem>
<simpara>Save the changes. OpenShift Container Platform automatically applies them.</simpara>
</listitem>
</orderedlist>
<simpara>A <literal>ConfigMap</literal> such as <literal>pilot-jwks-cacerts-&lt;SMCP name&gt;</literal> is created with the CA <literal>.pem data</literal>.</simpara>
<formalpara>
<title>Example ConfigMap <literal>pilot-jwks-cacerts-&lt;SMCP name&gt;</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
data:
  extra.pem: |
      -----BEGIN CERTIFICATE-----
      [...]
      [...]
      -----END CERTIFICATE-----</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-cert-manage_ossm-security">
<title>Adding an external certificate authority key and certificate</title>
<simpara>By default, Red Hat OpenShift Service Mesh generates a self-signed root certificate and key and uses them to sign the workload certificates. You can also use the user-defined certificate and key to sign workload certificates with user-defined root certificate. This task demonstrates an example to plug certificates and key into Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install Red Hat OpenShift Service Mesh with mutual TLS enabled to configure certificates.</simpara>
</listitem>
<listitem>
<simpara>This example uses the certificates from the <link xlink:href="https://github.com/maistra/istio/tree/maistra-2.4/samples/certs">Maistra repository</link>. For production, use your own certificates from your certificate authority.</simpara>
</listitem>
<listitem>
<simpara>Deploy the Bookinfo sample application to verify the results with these instructions.</simpara>
</listitem>
<listitem>
<simpara>OpenSSL is required to verify certificates.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-cert-manage-add-cert-key_ossm-security">
<title>Adding an existing certificate and key</title>
<simpara>To use an existing signing (CA) certificate and key, you must create a chain of trust file that includes the CA certificate, key, and root certificate. You must use the following exact file names for each of the corresponding certificates. The CA certificate is named <literal>ca-cert.pem</literal>, the key is <literal>ca-key.pem</literal>, and the root certificate, which signs <literal>ca-cert.pem</literal>, is named <literal>root-cert.pem</literal>. If your workload uses intermediate certificates, you must specify them in a <literal>cert-chain.pem</literal> file.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Save the example certificates from the <link xlink:href="https://github.com/maistra/istio/tree/maistra-2.4/samples/certs">Maistra repository</link> locally and replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
</listitem>
<listitem>
<simpara>Create a secret named <literal>cacert</literal> that includes the input files <literal>ca-cert.pem</literal>, <literal>ca-key.pem</literal>, <literal>root-cert.pem</literal> and <literal>cert-chain.pem</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic cacerts -n istio-system --from-file=&lt;path&gt;/ca-cert.pem \
    --from-file=&lt;path&gt;/ca-key.pem --from-file=&lt;path&gt;/root-cert.pem \
    --from-file=&lt;path&gt;/cert-chain.pem</programlisting>
</listitem>
<listitem>
<simpara>In the <literal>ServiceMeshControlPlane</literal> resource set <literal>spec.security.dataPlane.mtls true</literal> to <literal>true</literal> and configure the <literal>certificateAuthority</literal> field as shown in the following example. The default <literal>rootCADir</literal> is <literal>/etc/cacerts</literal>. You do not need to set the <literal>privateKey</literal> if the key and certs are mounted in the default location.  Service Mesh reads the certificates and key from the secret-mount files.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  security:
    dataPlane:
      mtls: true
    certificateAuthority:
      type: Istiod
      istiod:
        type: PrivateKey
        privateKey:
          rootCADir: /etc/cacerts</programlisting>
</listitem>
<listitem>
<simpara>After creating/changing/deleting the <literal>cacert</literal> secret, the Service Mesh control plane <literal>istiod</literal> and <literal>gateway</literal> pods must be restarted so the changes go into effect. Use the following command to restart the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system delete pods -l 'app in (istiod,istio-ingressgateway, istio-egressgateway)'</programlisting>
<simpara>The Operator will automatically recreate the pods after they have been deleted.</simpara>
</listitem>
<listitem>
<simpara>Restart the bookinfo application pods so that the sidecar proxies pick up the secret changes. Use the following command to restart the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n bookinfo delete pods --all</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">pod "details-v1-6cd699df8c-j54nh" deleted
pod "productpage-v1-5ddcb4b84f-mtmf2" deleted
pod "ratings-v1-bdbcc68bc-kmng4" deleted
pod "reviews-v1-754ddd7b6f-lqhsv" deleted
pod "reviews-v2-675679877f-q67r2" deleted
pod "reviews-v3-79d7549c7-c2gjs" deleted</programlisting>
</listitem>
<listitem>
<simpara>Verify that the pods were created and are ready with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n bookinfo</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-cert-manage-verify-cert_ossm-security">
<title>Verifying your certificates</title>
<simpara>Use the Bookinfo sample application to verify that the workload certificates are signed by the certificates that were plugged into the CA. This process requires that you have <literal>openssl</literal> installed on your machine.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To extract certificates from bookinfo workloads use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sleep 60
$ oc -n bookinfo exec "$(oc -n bookinfo get pod -l app=productpage -o jsonpath={.items..metadata.name})" -c istio-proxy -- openssl s_client -showcerts -connect details:9080 &gt; bookinfo-proxy-cert.txt
$ sed -n '/-----BEGIN CERTIFICATE-----/{:start /-----END CERTIFICATE-----/!{N;b start};/.*/p}' bookinfo-proxy-cert.txt &gt; certs.pem
$ awk 'BEGIN {counter=0;} /BEGIN CERT/{counter++} { print &gt; "proxy-cert-" counter ".pem"}' &lt; certs.pem</programlisting>
<simpara>After running the command, you should have three files in your working directory: <literal>proxy-cert-1.pem</literal>, <literal>proxy-cert-2.pem</literal> and <literal>proxy-cert-3.pem</literal>.</simpara>
</listitem>
<listitem>
<simpara>Verify that the root certificate is the same as the one specified by the administrator. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in &lt;path&gt;/root-cert.pem -text -noout &gt; /tmp/root-cert.crt.txt</programlisting>
<simpara>Run the following syntax at the terminal window.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in ./proxy-cert-3.pem -text -noout &gt; /tmp/pod-root-cert.crt.txt</programlisting>
<simpara>Compare the certificates by running the following syntax at the terminal window.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ diff -s /tmp/root-cert.crt.txt /tmp/pod-root-cert.crt.txt</programlisting>
<simpara>You should see the following result:
<literal>Files /tmp/root-cert.crt.txt and /tmp/pod-root-cert.crt.txt are identical</literal></simpara>
</listitem>
<listitem>
<simpara>Verify that the CA certificate is the same as the one specified by the administrator. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in &lt;path&gt;/ca-cert.pem -text -noout &gt; /tmp/ca-cert.crt.txt</programlisting>
<simpara>Run the following syntax at the terminal window.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in ./proxy-cert-2.pem -text -noout &gt; /tmp/pod-cert-chain-ca.crt.txt</programlisting>
<simpara>Compare the certificates by running the following syntax at the terminal window.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ diff -s /tmp/ca-cert.crt.txt /tmp/pod-cert-chain-ca.crt.txt</programlisting>
<simpara>You should see the following result:
<literal>Files /tmp/ca-cert.crt.txt and /tmp/pod-cert-chain-ca.crt.txt are identical.</literal></simpara>
</listitem>
<listitem>
<simpara>Verify the certificate chain from the root certificate to the workload certificate. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl verify -CAfile &lt;(cat &lt;path&gt;/ca-cert.pem &lt;path&gt;/root-cert.pem) ./proxy-cert-1.pem</programlisting>
<simpara>You should see the following result:
<literal>./proxy-cert-1.pem: OK</literal></simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-cert-cleanup_ossm-security">
<title>Removing the certificates</title>
<simpara>To remove the certificates you added, follow these steps.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Remove the secret <literal>cacerts</literal>. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret cacerts -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Redeploy Service Mesh with a self-signed root certificate in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  security:
    dataPlane:
      mtls: true</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-cert-manager-integration-istio_ossm-security">
<title>About integrating Service Mesh with cert-manager and istio-csr</title>
<simpara>The cert-manager tool is a solution for X.509 certificate management on Kubernetes. It delivers a unified API to integrate applications with private or public key infrastructure (PKI), such as Vault, Google Cloud Certificate Authority Service, Let&#8217;s Encrypt, and other providers.</simpara>
<simpara>The cert-manager tool ensures the certificates are valid and up-to-date by attempting to renew certificates at a configured time before they expire.</simpara>
<simpara>For Istio users, cert-manager also provides integration with <literal>istio-csr</literal>, which is a certificate authority (CA) server that handles certificate signing requests (CSR) from Istio proxies. The server then delegates signing to cert-manager, which forwards CSRs to the configured CA server.</simpara>
<note>
<simpara>Red Hat provides support for integrating with <literal>istio-csr</literal> and cert-manager. Red Hat does not provide direct support for the <literal>istio-csr</literal> or the community cert-manager components. The use of community cert-manager shown here is for demonstration purposes only.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>One of these versions of cert-manager:</simpara>
<itemizedlist>
<listitem>
<simpara>cert-manager Operator for Red Hat OpenShift 1.10 or later</simpara>
</listitem>
<listitem>
<simpara>community cert-manager Operator 1.11 or later</simpara>
</listitem>
<listitem>
<simpara>cert-manager 1.11 or later</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>OpenShift Service Mesh Operator 2.4 or later</simpara>
</listitem>
<listitem>
<simpara><literal>istio-csr</literal> 0.6.0 or later</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>To avoid creating config maps in all namespaces when the <literal>istio-csr</literal> server is installed with the <literal>jetstack/cert-manager-istio-csr</literal> Helm chart, use the following setting: <literal>app.controller.configmapNamespaceSelector: "maistra.io/member-of: &lt;istio-namespace&gt;"</literal> in the <literal>istio-csr.yaml</literal> file.</simpara>
</note>
<section xml:id="ossm-cert-manager-installation_ossm-security">
<title>Installing cert-manager</title>
<simpara>You can install the <literal>cert-manager</literal> tool to manage the lifecycle of TLS certificates and ensure that they are valid and up-to-date. If you are running Istio in your environment, you can also install the <literal>istio-csr</literal> certificate authority (CA) server, which handles certificate signing requests (CSR) from Istio proxies. The <literal>istio-csr</literal> CA delegates signing to the <literal>cert-manager</literal> tool, which delegates to the configured CA.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the root cluster issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f cluster-issuer.yaml</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n istio-system -f istio-ca.yaml</programlisting>
<formalpara>
<title>Example <literal>cluster-issuer.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-root-issuer
  namespace: cert-manager
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: root-ca
  namespace: cert-manager
spec:
  isCA: true
  duration: 21600h # 900d
  secretName: root-ca
  commonName: root-ca.my-company.net
  subject:
    organizations:
    - my-company.net
  issuerRef:
    name: selfsigned-root-issuer
    kind: Issuer
    group: cert-manager.io
---
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: root-ca
spec:
  ca:
    secretName: root-ca</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>istio-ca.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: istio-ca
  namespace: istio-system
spec:
  isCA: true
  duration: 21600h
  secretName: istio-ca
  commonName: istio-ca.my-company.net
  subject:
    organizations:
    - my-company.net
  issuerRef:
    name: root-ca
    kind: ClusterIssuer
    group: cert-manager.io
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: istio-ca
  namespace: istio-system
spec:
  ca:
    secretName: istio-ca</programlisting>
</para>
</formalpara>
<informalexample>
<note>
<simpara>The namespace of the <literal>selfsigned-root-issuer</literal> issuer and <literal>root-ca</literal> certificate is <literal>cert-manager</literal> because <literal>root-ca</literal> is a cluster issuer, so the cert-manager looks for a referenced secret in its own namespace. Its own namespace is <literal>cert-manager</literal> in the case of the cert-manager Operator for Red Hat OpenShift.</simpara>
</note>
</informalexample>
</listitem>
<listitem>
<simpara>Install <literal>istio-csr</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ helm install istio-csr jetstack/cert-manager-istio-csr \
    -n istio-system \
    -f deploy/examples/cert-manager/istio-csr/istio-csr.yaml</programlisting>
<formalpara>
<title>Example <literal>istio-csr.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">replicaCount: 2

image:
  repository: quay.io/jetstack/cert-manager-istio-csr
  tag: v0.6.0
  pullSecretName: ""

app:
  certmanager:
    namespace: istio-system
    issuer:
      group: cert-manager.io
      kind: Issuer
      name: istio-ca

  controller:
    configmapNamespaceSelector: "maistra.io/member-of=istio-system"
    leaderElectionNamespace: istio-system

  istio:
    namespace: istio-system
    revisions: ["basic"]

  server:
    maxCertificateDuration: 5m

  tls:
    certificateDNSNames:
    # This DNS name must be set in the SMCP spec.security.certificateAuthority.cert-manager.address
    - cert-manager-istio-csr.istio-system.svc</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Deploy SMCP:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f mesh.yaml -n istio-system</programlisting>
<formalpara>
<title>Example <literal>mesh.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  addons:
    grafana:
      enabled: false
    kiali:
      enabled: false
    prometheus:
      enabled: false
  proxy:
    accessLogging:
      file:
        name: /dev/stdout
  security:
    certificateAuthority:
      cert-manager:
        address: cert-manager-istio-csr.istio-system.svc:443
      type: cert-manager
    dataPlane:
      mtls: true
    identity:
      type: ThirdParty
  tracing:
    type: None
---
apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
spec:
  members:
  - httpbin
  - sleep</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<informalexample>
<note>
<simpara><literal>security.identity.type: ThirdParty</literal> must be set when <literal>security.certificateAuthority.type: cert-manager</literal> is configured.</simpara>
</note>
</informalexample>
<formalpara>
<title>Verification</title>
<para>Use the sample <literal>httpbin</literal> service and <literal>sleep</literal> app to check mTLS traffic from ingress gateways and verify that the <literal>cert-manager</literal> tool is installed.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Deploy the HTTP and <literal>sleep</literal> apps:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;namespace&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/maistra/istio/maistra-2.4/samples/httpbin/httpbin.yaml</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/maistra/istio/maistra-2.4/samples/sleep/sleep.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that <literal>sleep</literal> can access the <literal>httpbin</literal> service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec "$(oc get pod -l app=sleep -n &lt;namespace&gt; \
   -o jsonpath={.items..metadata.name})" -c sleep -n &lt;namespace&gt; -- \
   curl http://httpbin.&lt;namespace&gt;:8000/ip -s -o /dev/null \
   -w "%{http_code}\n"</programlisting>
<formalpara>
<title>Example output:</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">200</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check mTLS traffic from the ingress gateway to the <literal>httpbin</literal> service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n &lt;namespace&gt; -f https://raw.githubusercontent.com/maistra/istio/maistra-2.4/samples/httpbin/httpbin-gateway.yaml</programlisting>
</listitem>
<listitem>
<simpara>Get the <literal>istio-ingressgateway</literal> route:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">INGRESS_HOST=$(oc -n istio-system get routes istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Verify mTLS traffic from the ingress gateway to the <literal>httpbin</literal> service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s -I http://$INGRESS_HOST/headers -o /dev/null -w "%{http_code}" -s</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="additional-resources_cert-manager-operator-red-hat-openshift" role="_additional-resources">
<title>Additional resources</title>
<simpara>For information about how to install the cert-manager Operator for OpenShift Container Platform, see:
<link xlink:href="../../security/cert_manager_operator/cert-manager-operator-install.xml">Installing the cert-manager Operator for Red Hat OpenShift</link>.</simpara>
</section>
</section>
<section xml:id="ossm-routing-traffic">
<title>Managing traffic in your service mesh</title>

<simpara>Using Red Hat OpenShift Service Mesh, you can control the flow of traffic and API calls between services. Some services in your service mesh might need to communicate within the mesh and others might need to be hidden. You can manage the traffic to hide specific backend services, expose services, create testing or versioning deployments, or add a security layer on a set of services.</simpara>
<section xml:id="ossm-gateways_traffic-management">
<title>Using gateways</title>
<simpara>You can use a gateway to manage inbound and outbound traffic for your mesh to specify which traffic you want to enter or leave the mesh. Gateway configurations are applied to standalone Envoy proxies that are running at the edge of the mesh, rather than sidecar Envoy proxies running alongside your service workloads.</simpara>
<simpara>Unlike other mechanisms for controlling traffic entering your systems, such as the Kubernetes Ingress APIs, Red Hat OpenShift Service Mesh gateways use the full power and flexibility of traffic routing.</simpara>
<simpara>The Red Hat OpenShift Service Mesh gateway resource can use layer 4-6 load balancing properties, such as ports, to expose and configure Red Hat OpenShift Service Mesh TLS settings. Instead of adding application-layer traffic routing (L7) to the same API resource, you can bind a regular Red Hat OpenShift Service Mesh virtual service to the gateway and manage gateway traffic like any other data plane traffic in a service mesh.</simpara>
<simpara>Gateways are primarily used to manage ingress traffic, but you can also configure egress gateways. An egress gateway lets you configure a dedicated exit node for the traffic leaving the mesh. This enables you to limit which services have access to external networks, which adds security control to your service mesh. You can also use a gateway to configure a purely internal proxy.</simpara>
<formalpara>
<title>Gateway example</title>
<para>A gateway resource describes a load balancer operating at the edge of the mesh receiving incoming or outgoing HTTP/TCP connections. The specification describes a set of ports that should be exposed, the type of protocol to use, SNI configuration for the load balancer, and so on.</para>
</formalpara>
<simpara>The following example shows a sample gateway configuration for external HTTPS ingress traffic:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: ext-host-gwy
spec:
  selector:
    istio: ingressgateway # use istio default controller
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - ext-host.example.com
    tls:
      mode: SIMPLE
      serverCertificate: /tmp/tls.crt
      privateKey: /tmp/tls.key</programlisting>
<simpara>This gateway configuration lets HTTPS traffic from <literal>ext-host.example.com</literal> into the mesh on port 443, but doesn’t specify any routing for the traffic.</simpara>
<simpara>To specify routing and for the gateway to work as intended, you must also bind the gateway to a virtual service. You do this using the virtual service&#8217;s gateways field, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: virtual-svc
spec:
  hosts:
  - ext-host.example.com
  gateways:
    - ext-host-gwy</programlisting>
<simpara>You can then configure the virtual service with routing rules for the external traffic.</simpara>
<section xml:id="ossm-automatic-gateway-injection_traffic-management">
<title>Enabling gateway injection</title>
<simpara>Gateway configurations apply to standalone Envoy proxies running at the edge of the mesh, rather than sidecar Envoy proxies running alongside your service workloads. Because gateways are Envoy proxies, you can configure Service Mesh to inject gateways automatically, similar to how you can inject sidecars.</simpara>
<simpara>Using automatic injection for gateways, you can deploy and manage gateways independent from the <literal>ServiceMeshControlPlane</literal> resource and manage the gateways with your user applications. Using auto-injection for gateway deployments gives developers full control over the gateway deployment while simplifying operations. When a new upgrade is available, or a configuration has changed, you restart the gateway pods to update them. Doing so makes the experience of operating a gateway deployment the same as operating sidecars.</simpara>
<note>
<simpara>Injection is disabled by default for the <literal>ServiceMeshControlPlane</literal> namespace, for example the <literal>istio-system</literal> namespace. As a security best practice, deploy gateways in a different namespace from the control plane.</simpara>
</note>
</section>
<section xml:id="ossm-deploying-automatic-gateway-injection_traffic-management">
<title>Deploying automatic gateway injection</title>
<simpara>When deploying a gateway, you must opt-in to injection by adding an injection label or annotation to the gateway <literal>deployment</literal> object. The following example deploys a gateway.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The namespace must be a member of the mesh by defining it in the <literal>ServiceMeshMemberRoll</literal> or by creating a <literal>ServiceMeshMember</literal> resource.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set a unique label for the Istio ingress gateway. This setting is required to ensure that the gateway can select the workload. This example uses <literal>ingressgateway</literal> as the name of the gateway.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Service
metadata:
  name: istio-ingressgateway
  namespace: istio-ingress
spec:
  type: ClusterIP
  selector:
    istio: ingressgateway
  ports:
  - name: http2
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8443
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: istio-ingressgateway
  namespace: istio-ingress
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  template:
    metadata:
      annotations:
        inject.istio.io/templates: gateway
      labels:
        istio: ingressgateway
        sidecar.istio.io/inject: "true" <co xml:id="CO14-1"/>
    spec:
      containers:
      - name: istio-proxy
        image: auto <co xml:id="CO14-2"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Enable gateway injection by setting the <literal>sidecar.istio.io/inject</literal> field to <literal>"true"</literal>.</para>
</callout>
<callout arearefs="CO14-2">
<para>Set the <literal>image</literal> field to <literal>auto</literal> so that the image automatically updates each time the pod starts.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Set up roles to allow reading credentials for TLS.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: istio-ingressgateway-sds
  namespace: istio-ingress
rules:
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: istio-ingressgateway-sds
  namespace: istio-ingress
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: istio-ingressgateway-sds
subjects:
- kind: ServiceAccount
  name: default</programlisting>
</listitem>
<listitem>
<simpara>Grant access to the new gateway from outside the cluster, which is required whenever <literal>spec.security.manageNetworkPolicy</literal> is set to <literal>true</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: gatewayingress
  namespace: istio-ingress
spec:
  podSelector:
    matchLabels:
      istio: ingressgateway
  ingress:
    - {}
  policyTypes:
  - Ingress</programlisting>
</listitem>
<listitem>
<simpara>Automatically scale the pod when ingress traffic increases. This example sets the minimum replicas to <literal>2</literal> and the maximum replicas to <literal>5</literal>. It also creates another replica when utilization reaches 80%.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  labels:
    istio: ingressgateway
    release: istio
  name: ingressgatewayhpa
  namespace: istio-ingress
spec:
  maxReplicas: 5
  metrics:
  - resource:
      name: cpu
      target:
        averageUtilization: 80
        type: Utilization
    type: Resource
  minReplicas: 2
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: istio-ingressgateway</programlisting>
</listitem>
<listitem>
<simpara>Specify the minimum number of pods that must be running on the node. This example ensures one replica is running if a pod gets restarted on a new node.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  labels:
    istio: ingressgateway
    release: istio
  name: ingressgatewaypdb
  namespace: istio-ingress
spec:
  minAvailable: 1
  selector:
    matchLabels:
      istio: ingressgateway</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-routing-ingress_traffic-management">
<title>Managing ingress traffic</title>
<simpara>In Red Hat OpenShift Service Mesh, the Ingress Gateway enables features such as monitoring, security, and route rules to apply to traffic that enters the cluster. Use a Service Mesh gateway to expose a service outside of the service mesh.</simpara>
<section xml:id="ossm-routing-determine-ingress_traffic-management">
<title>Determining the ingress IP and ports</title>
<simpara>Ingress configuration differs depending on if your environment supports an external load balancer. An external load balancer is set in the ingress IP and ports for the cluster. To determine if your cluster&#8217;s IP and ports are configured for external load balancers, run the following command. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get svc istio-ingressgateway -n istio-system</programlisting>
<simpara>That command returns the <literal>NAME</literal>, <literal>TYPE</literal>, <literal>CLUSTER-IP</literal>, <literal>EXTERNAL-IP</literal>, <literal>PORT(S)</literal>, and <literal>AGE</literal> of each item in your namespace.</simpara>
<simpara>If the <literal>EXTERNAL-IP</literal> value is set, your environment has an external load balancer that you can use for the ingress gateway.</simpara>
<simpara>If the <literal>EXTERNAL-IP</literal> value is <literal>&lt;none&gt;</literal>, or perpetually <literal>&lt;pending&gt;</literal>, your environment does not provide an external load balancer for the ingress gateway.
You can access the gateway using the service&#8217;s <link xlink:href="../../networking/configuring-node-port-service-range.xml">node port</link>.</simpara>
<section xml:id="ossm-routing-config-ig-lb_traffic-management">
<title>Determining ingress ports with a load balancer</title>
<simpara>Follow these instructions if your environment has an external load balancer.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to set the ingress IP and ports. This command sets a variable in your terminal.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_HOST=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].port}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the secure ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export SECURE_INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].port}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the TCP ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export TCP_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="tcp")].port}')</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>In some environments, the load balancer may be exposed using a hostname instead of an IP address. For that case, the ingress gateway&#8217;s <literal>EXTERNAL-IP</literal> value is not an IP address. Instead, it&#8217;s a hostname, and the previous command fails to set the <literal>INGRESS_HOST</literal> environment variable.</simpara>
<simpara>In that case, use the following command to correct the <literal>INGRESS_HOST</literal> value:</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_HOST=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')</programlisting>
</section>
<section xml:id="ossm-routing-config-ig-no-lb_traffic-management">
<title>Determining ingress ports without a load balancer</title>
<simpara>If your environment does not have an external load balancer, determine the ingress ports and use a node port instead.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the ingress ports.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].nodePort}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the secure ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export SECURE_INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].nodePort}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the TCP ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export TCP_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="tcp")].nodePort}')</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-routing-ingress-gateway_traffic-management">
<title>Configuring an ingress gateway</title>
<simpara>An ingress gateway is a load balancer operating at the edge of the mesh that receives incoming HTTP/TCP connections. It configures exposed ports and protocols but does not include any traffic routing configuration. Traffic routing for ingress traffic is instead configured with routing rules, the same way as for internal service requests.</simpara>
<simpara>The following steps show how to create a gateway and configure a <literal>VirtualService</literal> to expose a service in the Bookinfo sample application to outside traffic for paths <literal>/productpage</literal> and <literal>/login</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a gateway to accept traffic.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, and copy the following YAML into it.</simpara>
<formalpara>
<title>Gateway example gateway.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "*"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the YAML file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f gateway.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>VirtualService</literal> object to rewrite the host header.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, and copy the following YAML into it.</simpara>
<formalpara>
<title>Virtual service example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
  - "*"
  gateways:
  - bookinfo-gateway
  http:
  - match:
    - uri:
        exact: /productpage
    - uri:
        prefix: /static
    - uri:
        exact: /login
    - uri:
        exact: /logout
    - uri:
        prefix: /api/v1/products
    route:
    - destination:
        host: productpage
        port:
          number: 9080</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the YAML file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f vs.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Test that the gateway and VirtualService have been set correctly.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the Gateway URL.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Set the port number. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export TARGET_PORT=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.port.targetPort}')</programlisting>
</listitem>
<listitem>
<simpara>Test a page that has been explicitly exposed.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">curl -s -I "$GATEWAY_URL/productpage"</programlisting>
<simpara>The expected result is <literal>200</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-auto-route_traffic-management">
<title>Understanding automatic routes</title>
<simpara>OpenShift routes for gateways are automatically managed in Service Mesh. Every time an Istio Gateway is created, updated or deleted inside the service mesh, an OpenShift route is created, updated or deleted.</simpara>
<section xml:id="ossm-auto-route-subdomains_traffic-management">
<title>Routes with subdomains</title>
<simpara>Red Hat OpenShift Service Mesh creates the route with the subdomain, but OpenShift Container Platform must be configured to enable it. Subdomains, for example <literal>*.domain.com</literal>, are supported, but not by default. Configure an OpenShift Container Platform wildcard policy before configuring a wildcard host gateway.</simpara>
<simpara>For more information, see <link xlink:href="../../networking/ingress-operator.xml#using-wildcard-routes_configuring-ingress">Using wildcard routes</link>.</simpara>
</section>
<section xml:id="ossm-auto-route-create-subdomains_traffic-management">
<title>Creating subdomain routes</title>
<simpara>The following example creates a gateway in the Bookinfo sample application, which creates subdomain routes.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: gateway1
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - www.bookinfo.com
    - bookinfo.example.com</programlisting>
<simpara>The <literal>Gateway</literal> resource creates the following OpenShift routes. You can check that the routes are created by using the following command. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system get routes</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME           HOST/PORT             PATH  SERVICES               PORT  TERMINATION   WILDCARD
gateway1-lvlfn bookinfo.example.com        istio-ingressgateway   &lt;all&gt;               None
gateway1-scqhv www.bookinfo.com            istio-ingressgateway   &lt;all&gt;               None</programlisting>
</para>
</formalpara>
<simpara>If you delete the gateway, Red Hat OpenShift Service Mesh deletes the routes. However, routes you have manually created are never modified by Red Hat OpenShift Service Mesh.</simpara>
</section>
<section xml:id="ossm-auto-route-annotations_traffic-management">
<title>Route labels and annotations</title>
<simpara>Sometimes specific labels or annotations are needed in an OpenShift route.
For example, some advanced features in OpenShift routes are managed using special annotations. See "Route-specific annotations" in the following "Additional resources" section.</simpara>
<simpara>For this and other use cases, Red Hat OpenShift Service Mesh will copy all labels and annotations present in the Istio gateway resource (with the exception of annotations starting with <literal>kubectl.kubernetes.io</literal>) into the managed OpenShift route resource.</simpara>
<simpara>If you need specific labels or annotations in the OpenShift routes created by Service Mesh, create them in the Istio gateway resource and they will be copied into the OpenShift route resources managed by the Service Mesh.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/routes/route-configuration.xml#nw-route-specific-annotations_route-configuration">Route-specific annotations</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-auto-route-enable_traffic-management">
<title>Disabling automatic route creation</title>
<simpara>By default, the <literal>ServiceMeshControlPlane</literal> resource automatically synchronizes the Istio gateway resources with OpenShift routes. Disabling the automatic route creation allows you more flexibility to control routes if you have a special case or prefer to control routes manually.</simpara>
<section xml:id="disabling-automatic-route-creation-specific-cases_traffic-management">
<title>Disabling automatic route creation for specific cases</title>
<simpara>If you want to disable the automatic management of OpenShift routes for a specific Istio gateway, you must add the annotation <literal>maistra.io/manageRoute: false</literal> to the gateway metadata definition. Red Hat OpenShift Service Mesh will ignore Istio gateways with this annotation, while keeping the automatic management of the other Istio gateways.</simpara>
</section>
<section xml:id="disabling-automatic-route-creation-all-cases_traffic-management">
<title>Disabling automatic route creation for all cases</title>
<simpara>You can disable the automatic management of OpenShift routes for all gateways in your mesh.</simpara>
<simpara>Disable integration between Istio gateways and OpenShift routes by setting the <literal>ServiceMeshControlPlane</literal> field <literal>gateways.openshiftRoute.enabled</literal> to <literal>false</literal>. For example, see the following resource snippet.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1alpha1
kind: ServiceMeshControlPlane
metadata:
  namespace: istio-system
spec:
  gateways:
    openshiftRoute:
      enabled: false</programlisting>
</section>
</section>
</section>
<section xml:id="ossm-routing-service-entries_traffic-management">
<title>Understanding service entries</title>
<simpara>A service entry adds an entry to the service registry that Red Hat OpenShift Service Mesh maintains internally. After you add the service entry, the Envoy proxies send traffic to the service as if it is a service in your mesh. Service entries allow you to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Manage traffic for services that run outside of the service mesh.</simpara>
</listitem>
<listitem>
<simpara>Redirect and forward traffic for external destinations (such as, APIs consumed from the web) or traffic to services in legacy infrastructure.</simpara>
</listitem>
<listitem>
<simpara>Define retry, timeout, and fault injection policies for external destinations.</simpara>
</listitem>
<listitem>
<simpara>Run a mesh service in a Virtual Machine (VM) by adding VMs to your mesh.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Add services from a different cluster to the mesh to configure a multicluster Red Hat OpenShift Service Mesh mesh on Kubernetes.</simpara>
</note>
<formalpara>
<title>Service entry examples</title>
<para>The following example is a mesh-external service entry that adds the <literal>ext-resource</literal> external dependency to the Red Hat OpenShift Service Mesh service registry:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: svc-entry
spec:
  hosts:
  - ext-svc.example.com
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  location: MESH_EXTERNAL
  resolution: DNS</programlisting>
<simpara>Specify the external resource using the <literal>hosts</literal> field. You can qualify it fully or use a wildcard prefixed domain name.</simpara>
<simpara>You can configure virtual services and destination rules to control traffic to a service entry in the same way you configure traffic for any other service in the mesh. For example, the following destination rule configures the traffic route to use mutual TLS to secure the connection to the <literal>ext-svc.example.com</literal> external service that is configured using the service entry:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ext-res-dr
spec:
  host: ext-svc.example.com
  trafficPolicy:
    tls:
      mode: MUTUAL
      clientCertificate: /etc/certs/myclientcert.pem
      privateKey: /etc/certs/client_private_key.pem
      caCertificates: /etc/certs/rootcacerts.pem</programlisting>
</section>
<section xml:id="ossm-routing-virtual-services_traffic-management">
<title>Using VirtualServices</title>
<simpara>You can route requests dynamically to multiple versions of a microservice through Red Hat OpenShift Service Mesh with a virtual service. With virtual services, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Address multiple application services through a single virtual service. If your mesh uses Kubernetes, for example, you can configure a virtual service to handle all services in a specific namespace. A virtual service enables you to turn a monolithic application into a service consisting of distinct microservices with a seamless consumer experience.</simpara>
</listitem>
<listitem>
<simpara>Configure traffic rules in combination with gateways to control ingress and egress traffic.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-routing-vs_traffic-management">
<title>Configuring VirtualServices</title>
<simpara>Requests are routed to services within a service mesh with virtual services. Each virtual service consists of a set of routing rules that are evaluated in order. Red Hat OpenShift Service Mesh matches each given request to the virtual service to a specific real destination within the mesh.</simpara>
<simpara>Without virtual services, Red Hat OpenShift Service Mesh distributes traffic using least requests load balancing between all service instances. With a virtual service, you can specify traffic behavior for one or more hostnames. Routing rules in the virtual service tell Red Hat OpenShift Service Mesh how to send the traffic for the virtual service to appropriate destinations. Route destinations can be versions of the same service or entirely different services.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following example to route requests to different versions of the Bookinfo sample application service depending on which user connects to the application.</simpara>
<formalpara>
<title>Example VirtualService.yaml</title>
<para>
<programlisting language="YAML" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to apply <literal>VirtualService.yaml</literal>, where <literal>VirtualService.yaml</literal> is the path to the file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;VirtualService.yaml&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_virtualservice_configuration_reference">
<title>VirtualService configuration reference</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  hosts:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>hosts</literal> field lists the virtual service&#8217;s destination address to which the routing rules apply. This is the address(es) that are used to send requests to the service. The virtual service hostname can be an IP address, a DNS name, or a short name that resolves to a fully qualified domain name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  http:
  - match:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>http</literal> section contains the virtual service&#8217;s routing rules which describe match conditions and actions for routing HTTP/1.1, HTTP2, and gRPC traffic sent to the destination as specified in the hosts field. A routing rule consists of the destination where you want the traffic to go and any specified match conditions.
The first routing rule in the example has a condition that begins with the match field. In this example, this routing applies to all requests from the user <literal>jason</literal>. Add the <literal>headers</literal>, <literal>end-user</literal>, and <literal>exact</literal> fields to select the appropriate requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  http:
  - match:
    - destination:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>destination</literal> field in the route section specifies the actual destination for traffic that matches this condition. Unlike the virtual service&#8217;s host, the destination&#8217;s host must be a real destination that exists in the Red Hat OpenShift Service Mesh service registry. This can be a mesh service with proxies or a non-mesh service added using a service entry. In this example, the hostname is a Kubernetes service name:</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="ossm-routing-destination-rules_traffic-management">
<title>Understanding destination rules</title>
<simpara>Destination rules are applied after virtual service routing rules are evaluated, so they apply to the traffic&#8217;s real destination. Virtual services route traffic to a destination. Destination rules configure what happens to traffic at that destination.</simpara>
<simpara>By default, Red Hat OpenShift Service Mesh uses a least requests load balancing policy, where the service instance in the pool with the least number of active connections receives the request. Red Hat OpenShift Service Mesh also supports the following models, which you can specify in destination rules for requests to a particular service or service subset.</simpara>
<itemizedlist>
<listitem>
<simpara>Random: Requests are forwarded at random to instances in the pool.</simpara>
</listitem>
<listitem>
<simpara>Weighted: Requests are forwarded to instances in the pool according to a specific percentage.</simpara>
</listitem>
<listitem>
<simpara>Least requests: Requests are forwarded to instances with the least number of requests.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Destination rule example</title>
<para>The following example destination rule configures three different subsets for the <literal>my-svc</literal> destination service, with different load balancing policies:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: my-destination-rule
spec:
  host: my-svc
  trafficPolicy:
    loadBalancer:
      simple: RANDOM
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
  - name: v3
    labels:
      version: v3</programlisting>
</section>
<section xml:id="ossm-understanding-networkpolicy_traffic-management">
<title>Understanding network policies</title>
<simpara>Red Hat OpenShift Service Mesh automatically creates and manages a number of <literal>NetworkPolicies</literal> resources in the Service Mesh control plane and application namespaces. This is to ensure that applications and the control plane can communicate with each other.</simpara>
<simpara>For example, if you have configured your OpenShift Container Platform cluster to use the SDN plugin, Red Hat OpenShift Service Mesh creates a <literal>NetworkPolicy</literal> resource in each member project. This enables ingress to all pods in the mesh from the other mesh members and the control plane. This also restricts ingress to only member projects. If you require ingress from non-member projects, you need to create a <literal>NetworkPolicy</literal> to allow that traffic through. If you remove a namespace from Service Mesh, this <literal>NetworkPolicy</literal> resource is deleted from the project.</simpara>
<section xml:id="ossm-config-disable-networkpolicy_traffic-management">
<title>Disabling automatic NetworkPolicy creation</title>
<simpara>If you want to disable the automatic creation and management of <literal>NetworkPolicy</literal> resources, for example to enforce company security policies, or to allow direct access to pods in the mesh, you can do so. You can edit the <literal>ServiceMeshControlPlane</literal> and set <literal>spec.security.manageNetworkPolicy</literal> to <literal>false</literal>.</simpara>
<note>
<simpara>When you disable <literal>spec.security.manageNetworkPolicy</literal> Red Hat OpenShift Service Mesh will not create <emphasis role="strong">any</emphasis> <literal>NetworkPolicy</literal> objects. The system administrator is responsible for managing the network and fixing any issues this might cause.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat OpenShift Service Mesh Operator version 2.1.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara><literal>ServiceMeshControlPlane</literal> resource updated to version 2.1 or higher.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the project where you installed the Service Mesh control plane, for example <literal>istio-system</literal>, from the <emphasis role="strong">Project</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator. In the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> column, click the name of your <literal>ServiceMeshControlPlane</literal>, for example <literal>basic-install</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create ServiceMeshControlPlane Details</emphasis> page, click <literal>YAML</literal> to modify your configuration.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>ServiceMeshControlPlane</literal> field <literal>spec.security.manageNetworkPolicy</literal> to <literal>false</literal>, as shown in this example.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
spec:
  security:
      manageNetworkPolicy: false</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-routing-sidecar_traffic-management">
<title>Configuring sidecars for traffic management</title>
<simpara>By default, Red Hat OpenShift Service Mesh configures every Envoy proxy to accept traffic on all the ports of its associated workload, and to reach every workload in the mesh when forwarding traffic. You can use a sidecar configuration to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Fine-tune the set of ports and protocols that an Envoy proxy accepts.</simpara>
</listitem>
<listitem>
<simpara>Limit the set of services that the Envoy proxy can reach.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>To optimize performance of your service mesh, consider limiting Envoy proxy configurations.</simpara>
</note>
<simpara>In the Bookinfo sample application, configure a Sidecar so all services can reach other services running in the same namespace and control plane. This Sidecar configuration is required for using Red Hat OpenShift Service Mesh policy and telemetry features.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following example to specify that you want a sidecar configuration to apply to all workloads in a particular namespace. Otherwise, choose specific workloads using a <literal>workloadSelector</literal>.</simpara>
<formalpara>
<title>Example sidecar.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Sidecar
metadata:
  name: default
  namespace: bookinfo
spec:
  egress:
  - hosts:
    - "./*"
    - "istio-system/*"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to apply <literal>sidecar.yaml</literal>, where <literal>sidecar.yaml</literal> is the path to the file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sidecar.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify that the sidecar was created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sidecar</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_routing_tutorial">
<title>Routing Tutorial</title>
<simpara>This guide references the Bookinfo sample application to provide examples of routing in an example application. Install the <link xlink:href="../../service_mesh/v2x/prepare-to-deploy-applications-ossm.xml#ossm-tutorial-bookinfo-overview_ossm-create-mesh">Bookinfo application</link> to learn how these routing examples work.</simpara>
<section xml:id="ossm-routing-bookinfo_traffic-management">
<title>Bookinfo routing tutorial</title>
<simpara>The Service Mesh Bookinfo sample application consists of four separate microservices, each with multiple versions. After installing the Bookinfo sample application, three different versions of the <literal>reviews</literal> microservice run concurrently.</simpara>
<simpara>When you access the Bookinfo app <literal>/product</literal> page in a browser and refresh several times, sometimes the book review output contains star ratings and other times it does not. Without an explicit default service version to route to, Service Mesh routes requests to all available versions one after the other.</simpara>
<simpara>This tutorial helps you apply rules that route all traffic to <literal>v1</literal> (version 1) of the microservices. Later, you can apply a rule to route traffic based on the value of an HTTP request header.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>Deploy the Bookinfo sample application to work with the following examples.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-routing-bookinfo-applying_traffic-management">
<title>Applying a virtual service</title>
<simpara>In the following procedure, the virtual service routes all traffic to <literal>v1</literal> of each micro-service by applying virtual services that set the default version for the micro-services.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the virtual services.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/virtual-service-all-v1.yaml</programlisting>
</listitem>
<listitem>
<simpara>To verify that you applied the virtual services, display the defined routes with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get virtualservices -o yaml</programlisting>
<simpara>That command returns a resource of <literal>kind: VirtualService</literal> in YAML format.</simpara>
</listitem>
</orderedlist>
<simpara>You have configured Service Mesh to route to the <literal>v1</literal> version of the Bookinfo microservices including the <literal>reviews</literal> service version 1.</simpara>
</section>
<section xml:id="ossm-routing-bookinfo-test_traffic-management">
<title>Testing the new route configuration</title>
<simpara>Test the new configuration by refreshing the <literal>/productpage</literal> of the Bookinfo application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the value for the <literal>GATEWAY_URL</literal> parameter. You can use this variable to find the URL for your Bookinfo product page later. In this example, istio-system is the name of the control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to retrieve the URL for the product page.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">echo "http://$GATEWAY_URL/productpage"</programlisting>
</listitem>
<listitem>
<simpara>Open the Bookinfo site in your browser.</simpara>
</listitem>
</orderedlist>
<simpara>The reviews part of the page displays with no rating stars, no matter how many times you refresh. This is because you configured Service Mesh to route all traffic for the reviews service to the version <literal>reviews:v1</literal> and this version of the service does not access the star ratings service.</simpara>
<simpara>Your service mesh now routes traffic to one version of a service.</simpara>
</section>
<section xml:id="ossm-routing-bookinfo-route_traffic-management">
<title>Route based on user identity</title>
<simpara>Change the route configuration so that all traffic from a specific user is routed to a specific service version. In this case, all traffic from a user named <literal>jason</literal> will be routed to the service <literal>reviews:v2</literal>.</simpara>
<simpara>Service Mesh does not have any special, built-in understanding of user identity. This example is enabled by the fact that the <literal>productpage</literal> service adds a custom <literal>end-user</literal> header to all outbound HTTP requests to the reviews service.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to enable user-based routing in the Bookinfo sample application.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/virtual-service-reviews-test-v2.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to confirm the rule is created. This command returns all resources of <literal>kind: VirtualService</literal> in YAML format.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get virtualservice reviews -o yaml</programlisting>
</listitem>
<listitem>
<simpara>On the <literal>/productpage</literal> of the Bookinfo app, log in as user <literal>jason</literal> with no password.</simpara>
</listitem>
<listitem>
<simpara>Refresh the browser. The star ratings appear next to each review.</simpara>
</listitem>
<listitem>
<simpara>Log in as another user (pick any name you want). Refresh the browser. Now the stars are gone. Traffic is now routed to <literal>reviews:v1</literal> for all users except Jason.</simpara>
</listitem>
</orderedlist>
<simpara>You have successfully configured the Bookinfo sample application to route traffic based on user identity.</simpara>
</section>
</section>
</section>
<section xml:id="ossm-observability">
<title>Metrics, logs, and traces</title>

<simpara>Once you have added your application to the mesh, you can observe the data flow through your application. If you do not have your own application installed, you can see how observability works in Red Hat OpenShift Service Mesh by installing the <link xlink:href="../../service_mesh/v2x/prepare-to-deploy-applications-ossm.xml#ossm-tutorial-bookinfo-overview_ossm-create-mesh">Bookinfo sample application</link>.</simpara>
<section xml:id="ossm-observability-addresses_observability">
<title>Discovering console addresses</title>
<simpara>Red Hat OpenShift Service Mesh provides the following consoles to view your service mesh data:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kiali console</emphasis> - Kiali is the management console for Red Hat OpenShift Service Mesh.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger console</emphasis> - Jaeger is the management console for Red Hat OpenShift distributed tracing platform.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Grafana console</emphasis> - Grafana provides mesh administrators with advanced query and metrics analysis and dashboards for Istio data. Optionally, Grafana can be used to analyze service mesh metrics.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Prometheus console</emphasis> - Red Hat OpenShift Service Mesh uses Prometheus to store telemetry information from services.</simpara>
</listitem>
</itemizedlist>
<simpara>When you install the Service Mesh control plane, it automatically generates routes for each of the installed components. Once you have the route address, you can access the Kiali, Jaeger, Prometheus, or Grafana console to view and manage your service mesh data.</simpara>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>The component must be enabled and installed.  For example, if you did not install distributed tracing, you will not be able to access the Jaeger console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure from OpenShift console</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the component console whose route you want to access.  Click the route <emphasis role="strong">Location</emphasis> to launch the console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from the CLI</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Switch to the Service Mesh control plane project. In this example, <literal>istio-system</literal> is the Service Mesh control plane project.  Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project istio-system</programlisting>
</listitem>
<listitem>
<simpara>To get the routes for the various Red Hat OpenShift Service Mesh consoles, run the folowing command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get routes</programlisting>
<simpara>This command returns the URLs for the Kiali, Jaeger, Prometheus, and Grafana web consoles, and any other routes in your service mesh. You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    HOST/PORT                         SERVICES              PORT    TERMINATION
bookinfo-gateway        bookinfo-gateway-yourcompany.com  istio-ingressgateway          http2
grafana                 grafana-yourcompany.com           grafana               &lt;all&gt;   reencrypt/Redirect
istio-ingressgateway    istio-ingress-yourcompany.com     istio-ingressgateway  8080
jaeger                  jaeger-yourcompany.com            jaeger-query          &lt;all&gt;   reencrypt
kiali                   kiali-yourcompany.com             kiali                 20001   reencrypt/Redirect
prometheus              prometheus-yourcompany.com        prometheus            &lt;all&gt;   reencrypt/Redirect</programlisting>
</listitem>
<listitem>
<simpara>Copy the URL for the console you want to access from the <literal>HOST/PORT</literal> column into a browser to open the console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-accessing-kiali-console_observability">
<title>Accessing the Kiali console</title>
<simpara>You can view your application&#8217;s topology, health, and metrics in the Kiali console. If your service is experiencing problems, the Kiali console lets you view the data flow through your service. You can view insights about the mesh components at different levels, including abstract applications, services, and workloads. Kiali also provides an interactive graph view of your namespace in real time.</simpara>
<simpara>To access the Kiali console you must have Red Hat OpenShift Service Mesh installed, Kiali installed and configured.</simpara>
<simpara>The installation process creates a route to access the Kiali console.</simpara>
<simpara>If you know the URL for the Kiali console, you can access it directly.  If you do not know the URL, use the following directions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure for administrators</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console with an administrator role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Projects</emphasis> page, if necessary, use the filter to find the name of your project.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your project, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project details</emphasis> page, in the <emphasis role="strong">Launcher</emphasis> section, click the <emphasis role="strong">Kiali</emphasis> link.</simpara>
</listitem>
<listitem>
<simpara>Log in to the Kiali console with the same user name and password that you use to access the OpenShift Container Platform console.</simpara>
<simpara>When you first log in to the Kiali Console, you see the <emphasis role="strong">Overview</emphasis> page which displays all the namespaces in your service mesh that you have permission to view.</simpara>
<simpara>If you are validating the console installation and namespaces have not yet been added to the mesh, there might not be any data to display other than <literal>istio-system</literal>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure for developers</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console with a developer role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project Details</emphasis> page, if necessary, use the filter to find the name of your project.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your project, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project</emphasis> page, in the <emphasis role="strong">Launcher</emphasis> section, click the <emphasis role="strong">Kiali</emphasis> link.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-observability-visual_observability">
<title>Viewing service mesh data in the Kiali console</title>
<simpara>The Kiali Graph offers a powerful visualization of your mesh traffic. The topology combines real-time request traffic with your Istio configuration information to present immediate insight into the behavior of your service mesh, letting you quickly pinpoint issues. Multiple Graph Types let you visualize traffic as a high-level service topology, a low-level workload topology, or as an application-level topology.</simpara>
<simpara>There are several graphs to choose from:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">App graph</emphasis> shows an aggregate workload for all applications that are labeled the same.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Service graph</emphasis> shows a node for each service in your mesh but excludes all applications and workloads from the graph. It provides a high level view and aggregates all traffic for defined services.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Versioned App graph</emphasis> shows a node for each version of an application. All versions of an application are grouped together.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Workload graph</emphasis> shows a node for each workload in your service mesh. This graph does not require you to use the application and version labels. If your application does not use version labels, use this the graph.</simpara>
</listitem>
</itemizedlist>
<simpara>Graph nodes are decorated with a variety of information, pointing out various route routing options like virtual services and service entries, as well as special configuration like fault-injection and circuit breakers. It can identify mTLS issues, latency issues, error traffic and more. The Graph is highly configurable, can show traffic animation, and has powerful Find and Hide abilities.</simpara>
<simpara>Click the <emphasis role="strong">Legend</emphasis> button to view information about the shapes, colors, arrows, and badges displayed in the graph.</simpara>
<simpara>To view a summary of metrics, select any node or edge in the graph to display its metric details in the summary details panel.</simpara>
<section xml:id="ossm-observability-topology_observability">
<title>Changing graph layouts in Kiali</title>
<simpara>The layout for the Kiali graph can render differently depending on your application architecture and the data to display. For example, the number of graph nodes and their interactions can determine how the Kiali graph is rendered. Because it is not possible to create a single layout that renders nicely for every situation, Kiali offers a choice of several different layouts.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>If you do not have your own application installed, install the Bookinfo sample application.  Then generate traffic for the Bookinfo application by entering the following command several times.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl "http://$GATEWAY_URL/productpage"</programlisting>
<simpara>This command simulates a user visiting the <literal>productpage</literal> microservice of the application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In Kiali console, click <emphasis role="strong">Graph</emphasis> to view a namespace graph.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Namespace</emphasis> menu, select your application namespace, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>To choose a different graph layout, do either or both of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Select different graph data groupings from the menu at the top of the graph.</simpara>
<itemizedlist>
<listitem>
<simpara>App graph</simpara>
</listitem>
<listitem>
<simpara>Service graph</simpara>
</listitem>
<listitem>
<simpara>Versioned App graph (default)</simpara>
</listitem>
<listitem>
<simpara>Workload graph</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select a different graph layout from the Legend at the bottom of the graph.</simpara>
<itemizedlist>
<listitem>
<simpara>Layout default dagre</simpara>
</listitem>
<listitem>
<simpara>Layout 1 cose-bilkent</simpara>
</listitem>
<listitem>
<simpara>Layout 2 cola</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-viewing-logs_observability">
<title>Viewing logs in the Kiali console</title>
<simpara>You can view logs for your workloads in the Kiali console.  The <emphasis role="strong">Workload Detail</emphasis> page includes a <emphasis role="strong">Logs</emphasis> tab which displays a unified logs view that displays both application and proxy logs. You can select how often you want the log display in Kiali to be refreshed.</simpara>
<simpara>To change the logging level on the logs displayed in Kiali, you change the logging configuration for the workload or the proxy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Service Mesh installed and configured.</simpara>
</listitem>
<listitem>
<simpara>Kiali installed and configured.</simpara>
</listitem>
<listitem>
<simpara>The address for the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Application or Bookinfo sample application added to the mesh.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
<simpara>The Kiali Overview page displays namespaces that have been added to the mesh that you have permissions to view.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Workloads</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Workloads</emphasis> page, select the project from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the workload whose logs you want to view.  Click the workload <emphasis role="strong">Name</emphasis>.  For example, click <emphasis role="strong">ratings-v1</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Workload Details</emphasis> page, click the <emphasis role="strong">Logs</emphasis> tab to view the logs for the workload.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>If you do not see any log entries, you may need to adjust either the Time Range or the Refresh interval.</simpara>
</tip>
</section>
<section xml:id="ossm-viewing-metrics_observability">
<title>Viewing metrics in the Kiali console</title>
<simpara>You can view inbound and outbound metrics for your applications, workloads, and services in the Kiali console.  The Detail pages include the following tabs:</simpara>
<itemizedlist>
<listitem>
<simpara>inbound Application metrics</simpara>
</listitem>
<listitem>
<simpara>outbound Application metrics</simpara>
</listitem>
<listitem>
<simpara>inbound Workload metrics</simpara>
</listitem>
<listitem>
<simpara>outbound Workload metrics</simpara>
</listitem>
<listitem>
<simpara>inbound Service metrics</simpara>
</listitem>
</itemizedlist>
<simpara>These tabs display predefined metrics dashboards, tailored to the relevant application, workload or service level. The application and workload detail views show request and response metrics such as volume, duration, size, or TCP traffic. The service detail view shows request and response metrics for inbound traffic only.</simpara>
<simpara>Kiali lets you customize the charts by choosing the charted dimensions. Kiali can also present metrics reported by either source or destination proxy metrics. And for troubleshooting, Kiali can overlay trace spans on the metrics.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Service Mesh installed and configured.</simpara>
</listitem>
<listitem>
<simpara>Kiali installed and configured.</simpara>
</listitem>
<listitem>
<simpara>The address for the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>(Optional) Distributed tracing installed and configured.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
<simpara>The Kiali Overview page displays namespaces that have been added to the mesh that you have permissions to view.</simpara>
</listitem>
<listitem>
<simpara>Click either <emphasis role="strong">Applications</emphasis>, <emphasis role="strong">Workloads</emphasis>, or <emphasis role="strong">Services</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Applications</emphasis>, <emphasis role="strong">Workloads</emphasis>, or <emphasis role="strong">Services</emphasis> page, select the project from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the application, workload, or service whose logs you want to view.  Click the <emphasis role="strong">Name</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Application Detail</emphasis>, <emphasis role="strong">Workload Details</emphasis>, or <emphasis role="strong">Service Details</emphasis> page, click either the <emphasis role="strong">Inbound Metrics</emphasis> or <emphasis role="strong">Outbound Metrics</emphasis> tab to view the metrics.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-overview-distr-tracing_observability">
<title>Distributed tracing</title>
<simpara>Distributed tracing is the process of tracking the performance of individual services in an application by tracing the path of the service calls in the application. Each time a user takes action in an application, a request is executed that might require many services to interact to produce a response. The path of this request is called a distributed transaction.</simpara>
<simpara>Red Hat OpenShift Service Mesh uses Red Hat OpenShift distributed tracing platform to allow developers to view call flows in a microservice application.</simpara>
<section xml:id="ossm-config-external-jaeger_observability">
<title>Connecting an existing distributed tracing instance</title>
<simpara>If you already have an existing Red Hat OpenShift distributed tracing platform (Jaeger) instance in OpenShift Container Platform, you can configure your <literal>ServiceMeshControlPlane</literal> resource to use that instance for distributed tracing platform.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform instance installed and configured.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator. In the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> column, click the name of your <literal>ServiceMeshControlPlane</literal> resource, for example <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the name of your distributed tracing platform (Jaeger) instance to the <literal>ServiceMeshControlPlane</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Add the name of your distributed tracing platform (Jaeger) instance to <literal>spec.addons.jaeger.name</literal> in your <literal>ServiceMeshControlPlane</literal> resource. In the following example, <literal>distr-tracing-production</literal> is the name of the distributed tracing platform (Jaeger) instance.</simpara>
<formalpara>
<title>Example distributed tracing configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  addons:
    jaeger:
      name: distr-tracing-production</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis> to verify the <literal>ServiceMeshControlPlane</literal> resource was configured correctly.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-config-sampling_observability">
<title>Adjusting the sampling rate</title>
<simpara>A trace is an execution path between services in the service mesh. A trace is comprised of one or more spans. A span is a logical unit of work that has a name, start time, and duration. The sampling rate determines how often a trace is persisted.</simpara>
<simpara>The Envoy proxy sampling rate is set to sample 100% of traces in your service mesh by default. A high sampling rate consumes cluster resources and performance but is useful when debugging issues. Before you deploy Red Hat OpenShift Service Mesh in production, set the value to a smaller proportion of traces. For example, set <literal>spec.tracing.sampling</literal> to <literal>100</literal> to sample 1% of traces.</simpara>
<simpara>Configure the Envoy proxy sampling rate as a scaled integer representing 0.01% increments.</simpara>
<simpara>In a basic installation, <literal>spec.tracing.sampling</literal> is set to <literal>10000</literal>, which samples 100% of traces. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Setting the value to 10 samples 0.1% of traces.</simpara>
</listitem>
<listitem>
<simpara>Setting the value to 500 samples 5% of traces.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Envoy proxy sampling rate applies for applications that are available to a Service Mesh, and use the Envoy proxy. This sampling rate determines how much data the Envoy proxy collects and tracks.</simpara>
<simpara>The Jaeger remote sampling rate applies to applications that are external to the Service Mesh, and do not use the Envoy proxy, such as a database. This sampling rate determines how much data the distributed tracing system collects and stores.
For more information, see <link xlink:href="../../distr_tracing/distr_tracing_jaeger/distr-tracing-jaeger-configuring.xml#distr-tracing-config-sampling_deploying-distributed-tracing-platform">Distributed tracing configuration options</link>.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator. In the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> column, click the name of your <literal>ServiceMeshControlPlane</literal> resource, for example <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>To adjust the sampling rate, set a different value for <literal>spec.tracing.sampling</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Set the value for <literal>spec.tracing.sampling</literal> in your <literal>ServiceMeshControlPlane</literal> resource. In the following example, set it to <literal>100</literal>.</simpara>
<formalpara>
<title>Jaeger sampling example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  tracing:
    sampling: 100</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis> to verify the <literal>ServiceMeshControlPlane</literal> resource was configured correctly.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-accessing-jaeger-console_observability">
<title>Accessing the Jaeger console</title>
<simpara>To access the Jaeger console you must have Red Hat OpenShift Service Mesh installed, Red Hat OpenShift distributed tracing platform (Jaeger) installed and configured.</simpara>
<simpara>The installation process creates a route to access the Jaeger console.</simpara>
<simpara>If you know the URL for the Jaeger console, you can access it directly.  If you do not know the URL, use the following directions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure from OpenShift console</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the <literal>jaeger</literal> route.  Click the route <emphasis role="strong">Location</emphasis> to launch the console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from Kiali console</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Distributed Tracing</emphasis> in the left navigation pane.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from the CLI</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>To query for details of the route using the command line, enter the following command. In this example, <literal>istio-system</literal> is the Service Mesh control plane namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export JAEGER_URL=$(oc get route -n istio-system jaeger -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Launch a browser and navigate to <literal>https://&lt;JAEGER_URL&gt;</literal>, where <literal>&lt;JAEGER_URL&gt;</literal> is the route that you discovered in the previous step.</simpara>
</listitem>
<listitem>
<simpara>Log in using the same user name and password that you use to access the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>If you have added services to the service mesh and have generated traces, you can use the filters and <emphasis role="strong">Find Traces</emphasis> button to search your trace data.</simpara>
<simpara>If you are validating the console installation, there is no trace data to display.</simpara>
</listitem>
</orderedlist>
<simpara>For more information about configuring Jaeger, see the <link xlink:href="../../distr_tracing/distr_tracing_jaeger/distr-tracing-jaeger-configuring.xml#distr-tracing-deploy-default_deploying-distributed-tracing-platform">distributed tracing documentation</link>.</simpara>
</section>
<section xml:id="ossm-access-grafana_observability">
<title>Accessing the Grafana console</title>
<simpara>Grafana is an analytics tool you can use to view, query, and analyze your service mesh metrics. In this example, <literal>istio-system</literal> is the Service Mesh control plane namespace. To access Grafana, do the following:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the link in the <emphasis role="strong">Location</emphasis> column for the <emphasis role="strong">Grafana</emphasis> row.</simpara>
</listitem>
<listitem>
<simpara>Log in to the Grafana console with your OpenShift Container Platform credentials.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-access-prometheus_observability">
<title>Accessing the Prometheus console</title>
<simpara>Prometheus is a monitoring and alerting tool that you can use to collect multi-dimensional data about your microservices. In this example, <literal>istio-system</literal> is the Service Mesh control plane namespace.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the link in the <emphasis role="strong">Location</emphasis> column for the <emphasis role="strong">Prometheus</emphasis> row.</simpara>
</listitem>
<listitem>
<simpara>Log in to the Prometheus console with your OpenShift Container Platform credentials.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-integrating-with-user-workload-monitoring_observability">
<title>Integrating with user-workload monitoring</title>
<simpara>By default, Red Hat OpenShift Service Mesh (OSSM) installs the Service Mesh control plane (SMCP) with a dedicated instance of Prometheus for collecting metrics from a mesh. However, production systems need more advanced monitoring systems, like OpenShift Container Platform monitoring for user-defined projects.</simpara>
<simpara>The following steps show how to integrate Service Mesh with user-workload monitoring.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>User-workload monitoring is enabled.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh Operator 2.4 is installed.</simpara>
</listitem>
<listitem>
<simpara>Kiali Operator 1.65 is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a token to Thanos for Kiali by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the <literal>SECRET</literal> environment variable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ SECRET=`oc get secret -n openshift-user-workload-monitoring |
 grep  prometheus-user-workload-token | head -n 1 | awk '{print $1 }'`</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>TOKEN</literal> environment variable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ TOKEN=`oc get secret $SECRET -n openshift-user-workload-monitoring -o jsonpath='{.data.token}' | base64 -d`</programlisting>
</listitem>
<listitem>
<simpara>Create a token to Thanos for Kiali by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic thanos-querier-web-token -n istio-system --from-literal=token=$TOKEN</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Configure Kiali for user-workload monitoring:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: kiali.io/v1alpha1
kind: Kiali
metadata:
  name: kiali-user-workload-monitoring
  namespace: istio-system
spec:
  external_services:
    istio:
      url_service_version: 'http://istiod-basic.istio-system:15014/version'
      config_map_name: istio-basic <co xml:id="CO15-1"/>
    prometheus:
      auth:
        token: secret:thanos-querier-web-token:token
        type: bearer
        use_kiali_token: false
      query_scope:
        mesh_id: "basic-istio-system"
      thanos_proxy:
        enabled: true
      url: https://thanos-querier.openshift-monitoring.svc.cluster.local:9091
  version: v1.65</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Set the <literal>ServiceMeshControlPlane</literal> name prefixed with <literal>istio-</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Configure the SMCP for external Prometheus:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  addons:
    prometheus:
      enabled: false <co xml:id="CO16-1"/>
    grafana:
      enabled: false <co xml:id="CO16-2"/>
    kiali:
      name: kiali-user-workload-monitoring
  meshConfig:
    extensionProviders:
    - name: prometheus
      prometheus: {}</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Disable the default Prometheus instance provided by OSSM.</para>
</callout>
<callout arearefs="CO16-2">
<para>Disable Grafana. It is not supported with an external Prometheus instance.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply a custom network policy to allow ingress traffic from the monitoring namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: user-workload-access
  namespace: bookinfo <co xml:id="CO17-1"/>
spec:
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          network.openshift.io/policy-group: monitoring
  podSelector: {}
  policyTypes:
  - Ingress</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>The custom network policy must be applied to all namespaces.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply a <literal>Telemetry</literal> object to enable traffic metrics in Istio proxies:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: telemetry.istio.io/v1alpha1
kind: Telemetry
metadata:
  name: enable-prometheus-metrics
  namespace: istio-system <co xml:id="CO18-1"/>
spec:
  selector: <co xml:id="CO18-2"/>
    matchLabels:
      app: bookinfo
  metrics:
  - providers:
    - name: prometheus</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>A <literal>Telemetry</literal> object created in the control plane namespace applies to all workloads in a mesh. To apply telemetry to only one namespace, create the object in the target namespace.</para>
</callout>
<callout arearefs="CO18-2">
<para>Optional: Setting the <literal>selector.matchLabels</literal> spec applies the <literal>Telemetry</literal> object to specific workloads in the target namespace.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply a <literal>ServiceMonitor</literal> object to monitor the Istio control plane:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: istiod-monitor
  namespace: istio-system <co xml:id="CO19-1"/>
spec:
  targetLabels:
  - app
  selector:
    matchLabels:
      istio: pilot
  endpoints:
  - port: http-monitoring
    interval: 30s
    relabelings:
    - action: replace
      replacement: "basic-istio-system" <co xml:id="CO19-2"/>
      targetLabel: mesh_id</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Create  this <literal>ServiceMonitor</literal> object in the Istio control plane namespace because it monitors the Istiod service. In this example, the namespace is <literal>istio-system</literal>.</para>
</callout>
<callout arearefs="CO19-2">
<para>The string <literal>"basic-istio-system"</literal> is a combination of the SMCP name and its namespace, but any label can be used as long as it is unique for every mesh using user workload monitoring in the cluster. The <literal>spec.prometheus.query_scope</literal> of the Kiali resource configured in Step 2 needs to match this value.</para>
</callout>
</calloutlist>
<note>
<simpara>If there is only one mesh using user-workload monitoring, then both the <literal>mesh_id</literal> relabeling and the <literal>spec.prometheus.query_scope</literal> field in the Kiali resource are optional (but the <literal>query_scope</literal> field given here should be removed if the <literal>mesh_id</literal> label is removed).</simpara>
<simpara>If there might be multiple meshes using user-workload monitoring, then both the <literal>mesh_id</literal> relabelings and the <literal>spec.prometheus.query_scope</literal> field in the Kiali resource are required so that Kiali only sees metrics from its associated mesh. If Kiali is not being deployed, applying the <literal>mesh_id</literal> relabeling is still recommended so that metrics from different meshes can be distinguished from one another.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply a <literal>PodMonitor</literal> object to collect metrics from Istio proxies:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: monitoring.coreos.com/v1
kind: PodMonitor
metadata:
  name: istio-proxies-monitor
  namespace: istio-system <co xml:id="CO20-1"/>
spec:
  selector:
    matchExpressions:
    - key: istio-prometheus-ignore
      operator: DoesNotExist
  podMetricsEndpoints:
  - path: /stats/prometheus
    interval: 30s
    relabelings:
    - action: keep
      sourceLabels: [__meta_kubernetes_pod_container_name]
      regex: "istio-proxy"
    - action: keep
      sourceLabels: [__meta_kubernetes_pod_annotationpresent_prometheus_io_scrape]
    - action: replace
      regex: (\d+);(([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4})
      replacement: '[$2]:$1'
      sourceLabels: [__meta_kubernetes_pod_annotation_prometheus_io_port,
      __meta_kubernetes_pod_ip]
      targetLabel: __address__
    - action: replace
      regex: (\d+);((([0-9]+?)(\.|$)){4})
      replacement: $2:$1
      sourceLabels: [__meta_kubernetes_pod_annotation_prometheus_io_port,
      __meta_kubernetes_pod_ip]
      targetLabel: __address__
    - action: labeldrop
      regex: "__meta_kubernetes_pod_label_(.+)"
    - sourceLabels: [__meta_kubernetes_namespace]
      action: replace
      targetLabel: namespace
    - sourceLabels: [__meta_kubernetes_pod_name]
      action: replace
      targetLabel: pod_name
    - action: replace
      replacement: "basic-istio-system" <co xml:id="CO20-2"/>
      targetLabel: mesh_id</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Since OpenShift Container Platform monitoring ignores the <literal>namespaceSelector</literal> spec in <literal>ServiceMonitor</literal> and <literal>PodMonitor</literal> objects, you must apply the <literal>PodMonitor</literal> object in all mesh namespaces, including the control plane namespace.</para>
</callout>
<callout arearefs="CO20-2">
<para>The string <literal>"basic-istio-system"</literal> is a combination of the SMCP name and its namespace, but any label can be used as long as it is unique for every mesh using user workload monitoring in the cluster. The <literal>spec.prometheus.query_scope</literal> of the Kiali resource configured in Step 2 needs to match this value.</para>
</callout>
</calloutlist>
<note>
<simpara>If there is only one mesh using user-workload monitoring, then both the <literal>mesh_id</literal> relabeling and the <literal>spec.prometheus.query_scope</literal> field in the Kiali resource are optional (but the <literal>query_scope</literal> field given here should be removed if the <literal>mesh_id</literal> label is removed).</simpara>
<simpara>If there might be multiple meshes using user-workload monitoring, then both the <literal>mesh_id</literal> relabelings and the <literal>spec.prometheus.query_scope</literal> field in the Kiali resource are required so that Kiali only sees metrics from its associated mesh. If Kiali is not being deployed, applying the <literal>mesh_id</literal> relabeling is still recommended so that metrics from different meshes can be distinguished from one another.</simpara>
</note>
</listitem>
<listitem>
<simpara>Open the OpenShift Container Platform web console, and check that metrics are visible.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_user-workload-monitoring" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../monitoring/enabling-monitoring-for-user-defined-projects.xml">Enabling monitoring for user-defined projects</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-performance-scalability">
<title>Performance and scalability</title>

<simpara>The default <literal>ServiceMeshControlPlane</literal> settings are not intended for production use; they are designed to install successfully on a default OpenShift Container Platform installation, which is a resource-limited environment. After you have verified a successful SMCP installation, you should modify the settings defined within the SMCP to suit your environment.</simpara>
<section xml:id="ossm-recommended-resources_performance-scalability">
<title>Setting limits on compute resources</title>
<simpara>By default, <literal>spec.proxy</literal> has the settings <literal>cpu: 10m</literal> and  <literal>memory: 128M</literal>. If you are using Pilot, <literal>spec.runtime.components.pilot</literal> has the same default values.</simpara>
<simpara>The settings in the following example are based on 1,000 services and 1,000 requests per second. You can change the values for <literal>cpu</literal> and <literal>memory</literal> in the <literal>ServiceMeshControlPlane</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator. In the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> column, click the name of your <literal>ServiceMeshControlPlane</literal>, for example <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the name of your standalone Jaeger instance to the <literal>ServiceMeshControlPlane</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Set the values for <literal>spec.proxy.runtime.container.resources.requests.cpu</literal> and <literal>spec.proxy.runtime.container.resources.requests.memory</literal> in your <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Example version 2.4 ServiceMeshControlPlane</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
  namespace: istio-system
spec:
  version: v2.4
  proxy:
    runtime:
      container:
        resources:
          requests:
            cpu: 600m
            memory: 50Mi
          limits: {}

  runtime:
    components:
      pilot:
        container:
          resources:
            requests:
              cpu: 1000m
              memory: 1.6Gi
            limits: {}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis> to verify the <literal>ServiceMeshControlPlane</literal> resource was configured correctly.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-load-test-results_performance-scalability">
<title>Load test results</title>
<simpara>The upstream Istio community load tests mesh consists of <emphasis role="strong">1000</emphasis> services and <emphasis role="strong">2000</emphasis> sidecars with 70,000 mesh-wide requests per second.
Running the tests using Istio 1.12.3, generated the following results:</simpara>
<itemizedlist>
<listitem>
<simpara>The Envoy proxy uses <emphasis role="strong">0.35 vCPU</emphasis> and <emphasis role="strong">40 MB memory</emphasis> per 1000 requests per second going through the proxy.</simpara>
</listitem>
<listitem>
<simpara>Istiod uses <emphasis role="strong">1 vCPU</emphasis> and <emphasis role="strong">1.5 GB</emphasis> of memory.</simpara>
</listitem>
<listitem>
<simpara>The Envoy proxy adds <emphasis role="strong">2.65 ms</emphasis> to the 90th percentile latency.</simpara>
</listitem>
<listitem>
<simpara>The legacy <literal>istio-telemetry</literal> service (disabled by default in Service Mesh 2.0) uses <emphasis role="strong">0.6 vCPU</emphasis> per 1000 mesh-wide requests per second for deployments that use Mixer.
The data plane components, the Envoy proxies, handle data flowing through the system. The Service Mesh control plane component, Istiod, configures the data plane. The data plane and control plane have distinct performance concerns.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_service_mesh_control_plane_performance">
<title>Service Mesh Control plane performance</title>
<simpara>Istiod configures sidecar proxies based on user authored configuration files and the current state of the system.
In a Kubernetes environment, Custom Resource Definitions (CRDs) and deployments constitute the configuration and state of the system.
The Istio configuration objects like gateways and virtual services, provide the user-authored configuration.
To produce the configuration for the proxies, Istiod processes the combined configuration and system state from the Kubernetes environment and the user-authored configuration.</simpara>
<simpara>The Service Mesh control plane supports thousands of services, spread across thousands of pods with a similar number of user authored virtual services and other configuration objects.
Istiod&#8217;s CPU and memory requirements scale with the number of configurations and possible system states.
The CPU consumption scales with the following factors:</simpara>
<itemizedlist>
<listitem>
<simpara>The rate of deployment changes.</simpara>
</listitem>
<listitem>
<simpara>The rate of configuration changes.</simpara>
</listitem>
<listitem>
<simpara>The number of proxies connecting to Istiod.</simpara>
</listitem>
</itemizedlist>
<simpara>However this part is inherently horizontally scalable.</simpara>
</section>
<section xml:id="_data_plane_performance">
<title>Data plane performance</title>
<simpara>Data plane performance depends on many factors, for example:</simpara>
<itemizedlist>
<listitem>
<simpara>Number of client connections</simpara>
</listitem>
<listitem>
<simpara>Target request rate</simpara>
</listitem>
<listitem>
<simpara>Request size and response size</simpara>
</listitem>
<listitem>
<simpara>Number of proxy worker threads</simpara>
</listitem>
<listitem>
<simpara>Protocol</simpara>
</listitem>
<listitem>
<simpara>CPU cores</simpara>
</listitem>
<listitem>
<simpara>Number and types of proxy filters, specifically telemetry v2 related filters.</simpara>
</listitem>
</itemizedlist>
<simpara>The latency, throughput, and the proxies' CPU and memory consumption are measured as a function of these factors.</simpara>
<section xml:id="_cpu_and_memory_consumption">
<title>CPU and memory consumption</title>
<simpara>Since the sidecar proxy performs additional work on the data path, it consumes CPU and memory. As of Istio 1.12.3, a proxy consumes about 0.5 vCPU per 1000 requests per second.</simpara>
<simpara>The memory consumption of the proxy depends on the total configuration state the proxy holds.
A large number of listeners, clusters, and routes can increase memory usage.</simpara>
<simpara>Since the proxy normally doesn&#8217;t buffer the data passing through, request rate doesn&#8217;t affect the memory consumption.</simpara>
</section>
<section xml:id="_additional_latency">
<title>Additional latency</title>
<simpara>Since Istio injects a sidecar proxy on the data path, latency is an important consideration. Istio adds an authentication filter, a telemetry filter, and a metadata exchange filter to the proxy.
Every additional filter adds to the path length inside the proxy and affects latency.</simpara>
<simpara>The Envoy proxy collects raw telemetry data after a response is sent to the client.
The time spent collecting raw telemetry for a request does not contribute to the total time taken to complete that request.
However, since the worker is busy handling the request, the worker won&#8217;t start handling the next request immediately.
This process adds to the queue wait time of the next request and affects average and tail latencies.
The actual tail latency depends on the traffic pattern.</simpara>
<simpara>Inside the mesh, a request traverses the client-side proxy and then the server-side proxy. In the default configuration of Istio 1.12.3 (that is, Istio with telemetry v2), the two proxies add about 1.7 ms and 2.7 ms to the 90th and 99th percentile latency, respectively, over the baseline data plane latency.</simpara>
</section>
</section>
</section>
</section>
<section xml:id="ossm-production">
<title>Configuring Service Mesh for production</title>

<simpara>When you are ready to move from a basic installation to production, you must configure your control plane, tracing, and security certificates to meet production requirements.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install and configure Red Hat OpenShift Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>Test your configuration in a staging environment.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-smcp-prod_ossm-architecture">
<title>Configuring your ServiceMeshControlPlane resource for production</title>
<simpara>If you have installed a basic <literal>ServiceMeshControlPlane</literal> resource to test Service Mesh, you must configure it to production specification before you use Red Hat OpenShift Service Mesh in production.</simpara>
<simpara>You cannot change the <literal>metadata.name</literal> field of an existing <literal>ServiceMeshControlPlane</literal> resource. For production deployments, you must customize the default template.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure the distributed tracing platform (Jaeger) for production.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>ServiceMeshControlPlane</literal> resource to use the <literal>production</literal> deployment strategy, by setting <literal>spec.addons.jaeger.install.storage.type</literal> to <literal>Elasticsearch</literal> and specify additional configuration options under <literal>install</literal>. You can create and configure your Jaeger instance and set <literal>spec.addons.jaeger.name</literal> to the name of the Jaeger instance.</simpara>
<formalpara>
<title>Default Jaeger parameters including Elasticsearch</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 100
    type: Jaeger
  addons:
    jaeger:
      name: MyJaeger
      install:
        storage:
          type: Elasticsearch
        ingress:
          enabled: true
  runtime:
    components:
      tracing.jaeger.elasticsearch: # only supports resources and image name
        container:
          resources: {}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Configure the sampling rate for production. For more information, see the Performance and scalability section.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Ensure your security certificates are production ready by installing security certificates from an external certificate authority. For more information, see the Security section.</simpara>
</listitem>
<listitem>
<simpara>Verify the results. Enter the following command to verify that the <literal>ServiceMeshControlPlane</literal> resource updated properly. In this example, <literal>basic</literal> is the name of the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp basic -o yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_ossm-production" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>For more information about tuning Service Mesh for performance, see <link xlink:href="../../service_mesh/v2x/ossm-performance-scalability.xml#ossm-performance-scalability">Performance and scalability</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-federation">
<title>Connecting service meshes</title>

<simpara><emphasis>Federation</emphasis> is a deployment model that lets you share services and workloads between separate meshes managed in distinct administrative domains.</simpara>
<section xml:id="ossm-federation-overview_federation">
<title>Federation overview</title>
<simpara>Federation is a set of features that let you connect services between separate meshes, allowing the use of Service Mesh features such as authentication, authorization, and traffic management across multiple, distinct administrative domains.</simpara>
<simpara>Implementing a federated mesh lets you run, manage, and observe a single service mesh running across multiple OpenShift clusters. Red Hat OpenShift Service Mesh federation takes an opinionated approach to a multi-cluster implementation of Service Mesh that assumes <emphasis>minimal</emphasis> trust between meshes.</simpara>
<simpara>Service Mesh federation assumes that each mesh is managed individually and retains its own administrator. The default behavior is that no communication is permitted and no information is shared between meshes. The sharing of information between meshes is on an explicit opt-in basis. Nothing is shared in a federated mesh unless it has been configured for sharing. Support functions such as certificate generation, metrics and trace collection remain local in their respective meshes.</simpara>
<simpara>You configure the <literal>ServiceMeshControlPlane</literal> on each service mesh to create ingress and egress gateways specifically for the federation, and to specify the trust domain for the mesh.</simpara>
<simpara>Federation also involves the creation of additional federation files. The following resources are used to configure the federation between two or more meshes.</simpara>
<itemizedlist>
<listitem>
<simpara>A <emphasis role="strong">ServiceMeshPeer</emphasis> resource declares the federation between a pair of service meshes.</simpara>
</listitem>
<listitem>
<simpara>An <emphasis role="strong">ExportedServiceSet</emphasis> resource declares that one or more services from the mesh are available for use by a peer mesh.</simpara>
</listitem>
<listitem>
<simpara>An <emphasis role="strong">ImportedServiceSet</emphasis> resource declares which services exported by a peer mesh will be imported into the mesh.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-features_federation">
<title>Federation features</title>
<simpara role="_abstract">Features of the Red Hat OpenShift Service Mesh federated approach to joining meshes include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Supports common root certificates for each mesh.</simpara>
</listitem>
<listitem>
<simpara>Supports different root certificates for each mesh.</simpara>
</listitem>
<listitem>
<simpara>Mesh administrators must manually configure certificate chains, service discovery endpoints, trust domains, etc for meshes outside of the Federated mesh.</simpara>
</listitem>
<listitem>
<simpara>Only export/import the services that you want to share between meshes.</simpara>
<itemizedlist>
<listitem>
<simpara>Defaults to not sharing information about deployed workloads with other meshes in the federation. A service can be <emphasis role="strong">exported</emphasis> to make it visible to other meshes and allow requests from workloads outside of its own mesh.</simpara>
</listitem>
<listitem>
<simpara>A service that has been exported can be <emphasis role="strong">imported</emphasis> to another mesh, enabling workloads on that mesh to send requests to the imported service.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Encrypts communication between meshes at all times.</simpara>
</listitem>
<listitem>
<simpara>Supports configuring load balancing across workloads deployed locally and workloads that are deployed in another mesh in the federation.</simpara>
</listitem>
</itemizedlist>
<simpara>When a mesh is joined to another mesh it can do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Provide trust details about itself to the federated mesh.</simpara>
</listitem>
<listitem>
<simpara>Discover trust details about the federated mesh.</simpara>
</listitem>
<listitem>
<simpara>Provide information to the federated mesh about its own exported services.</simpara>
</listitem>
<listitem>
<simpara>Discover information about services exported by the federated mesh.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-security_federation">
<title>Federation security</title>
<simpara>Red Hat OpenShift Service Mesh federation takes an opinionated approach to a multi-cluster implementation of Service Mesh that assumes minimal trust between meshes. Data security is built in as part of the federation features.</simpara>
<itemizedlist>
<listitem>
<simpara>Each mesh is considered to be a unique tenant, with a unique administration.</simpara>
</listitem>
<listitem>
<simpara>You create a unique trust domain for each mesh in the federation.</simpara>
</listitem>
<listitem>
<simpara>Traffic between the federated meshes is automatically encrypted using mutual Transport Layer Security (mTLS).</simpara>
</listitem>
<listitem>
<simpara>The Kiali graph only displays your mesh and services that you have imported. You cannot see the other mesh or services that have not been imported into your mesh.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-limitations_federation">
<title>Federation limitations</title>
<simpara>The Red Hat OpenShift Service Mesh federated approach to joining meshes has the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>Federation of meshes is not supported on OpenShift Dedicated.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-prerequisites_federation">
<title>Federation prerequisites</title>
<simpara>The Red Hat OpenShift Service Mesh federated approach to joining meshes has the following prerequisites:</simpara>
<itemizedlist>
<listitem>
<simpara>Two or more OpenShift Container Platform 4.6 or above clusters.</simpara>
</listitem>
<listitem>
<simpara>Federation was introduced in Red Hat OpenShift Service Mesh 2.1 or later. You must have the Red Hat OpenShift Service Mesh 2.1 or later Operator installed on each mesh that you want to federate.</simpara>
</listitem>
<listitem>
<simpara>You must have a version 2.1 or later <literal>ServiceMeshControlPlane</literal> deployed on each mesh that you want to federate.</simpara>
</listitem>
<listitem>
<simpara>You must configure the load balancers supporting the services associated with the federation gateways to support raw TLS traffic. Federation traffic consists of HTTPS for discovery and raw encrypted TCP for service traffic.</simpara>
</listitem>
<listitem>
<simpara>Services that you want to expose to another mesh should be deployed before you can export and import them. However, this is not a strict requirement. You can specify service names that do not yet exist for export/import. When you deploy the services named in the <literal>ExportedServiceSet</literal> and <literal>ImportedServiceSet</literal> they will be automatically made available for export/import.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-planning_federation">
<title>Planning your mesh federation</title>
<simpara>Before you start configuring your mesh federation, you should take some time to plan your implementation.</simpara>
<itemizedlist>
<listitem>
<simpara>How many meshes do you plan to join in a federation? You probably want to start with a limited number of meshes, perhaps two or three.</simpara>
</listitem>
<listitem>
<simpara>What naming convention do you plan to use for each mesh? Having a pre-defined naming convention will help with configuration and troubleshooting. The examples in this documentation use different colors for each mesh. You should decide on a naming convention that will help you determine who owns and manages each mesh, as well as the following federation resources:</simpara>
<itemizedlist>
<listitem>
<simpara>Cluster names</simpara>
</listitem>
<listitem>
<simpara>Cluster network names</simpara>
</listitem>
<listitem>
<simpara>Mesh names and namespaces</simpara>
</listitem>
<listitem>
<simpara>Federation ingress gateways</simpara>
</listitem>
<listitem>
<simpara>Federation egress gateways</simpara>
</listitem>
<listitem>
<simpara>Security trust domains</simpara>
<note>
<simpara>Each mesh in the federation must have its own unique trust domain.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Which services from each mesh do you plan to export to the federated mesh? Each service can be exported individually, or you can specify labels or use wildcards.</simpara>
<itemizedlist>
<listitem>
<simpara>Do you want to use aliases for the service namespaces?</simpara>
</listitem>
<listitem>
<simpara>Do you want to use aliases for the exported services?</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Which exported services does each mesh plan to import? Each mesh only imports the services that it needs.</simpara>
<itemizedlist>
<listitem>
<simpara>Do you want to use aliases for the imported services?</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-across-clusters_federation">
<title>Mesh federation across clusters</title>
<simpara>To connect one instance of the OpenShift Service Mesh with one running in a different cluster, the procedure is not much different as when connecting two meshes deployed in the same cluster. However, the ingress gateway of one mesh must be reachable from the other mesh. One way of ensuring this is to configure the gateway service as a <literal>LoadBalancer</literal> service if the cluster supports this type of service.</simpara>
<simpara>The service must be exposed through a load balancer that operates at Layer4 of the OSI model.</simpara>
<section xml:id="_exposing_the_federation_ingress_on_clusters_running_on_bare_metal">
<title>Exposing the federation ingress on clusters running on bare metal</title>
<simpara>If the cluster runs on bare metal and fully supports <literal>LoadBalancer</literal> services, the IP address found in the <literal>.status.loadBalancer.ingress.ip</literal> field of the ingress gateway <literal>Service</literal> object should be specified as one of the entries in the <literal>.spec.remote.addresses</literal> field of the <literal>ServiceMeshPeer</literal> object.</simpara>
<simpara>If the cluster does not support <literal>LoadBalancer</literal> services, using a <literal>NodePort</literal> service could be an option if the nodes are accessible from the cluster running the other mesh. In the <literal>ServiceMeshPeer</literal> object, specify the IP addresses of the nodes in the <literal>.spec.remote.addresses</literal> field and the service&#8217;s node ports in the <literal>.spec.remote.discoveryPort</literal> and <literal>.spec.remote.servicePort</literal> fields.</simpara>
</section>
<section xml:id="_exposing_the_federation_ingress_on_clusters_running_on_ibm_power_and_ibm_z">
<title>Exposing the federation ingress on clusters running on IBM Power and IBM Z</title>
<simpara>If the cluster runs on IBM Power&#174; or IBM Z&#174; infrastructure and fully supports <literal>LoadBalancer</literal> services, the IP address found in the <literal>.status.loadBalancer.ingress.ip</literal> field of the ingress gateway <literal>Service</literal> object should be specified as one of the entries in the <literal>.spec.remote.addresses</literal> field of the <literal>ServiceMeshPeer</literal> object.</simpara>
<simpara>If the cluster does not support <literal>LoadBalancer</literal> services, using a <literal>NodePort</literal> service could be an option if the nodes are accessible from the cluster running the other mesh. In the <literal>ServiceMeshPeer</literal> object, specify the IP addresses of the nodes in the <literal>.spec.remote.addresses</literal> field and the service&#8217;s node ports in the <literal>.spec.remote.discoveryPort</literal> and <literal>.spec.remote.servicePort</literal> fields.</simpara>
</section>
<section xml:id="_exposing_the_federation_ingress_on_amazon_web_services_aws">
<title>Exposing the federation ingress on Amazon Web Services (AWS)</title>
<simpara>By default, LoadBalancer services in clusters running on AWS do not support L4 load balancing. In order for Red Hat OpenShift Service Mesh federation to operate correctly, the following annotation must be added to the ingress gateway service:</simpara>
<simpara>service.beta.kubernetes.io/aws-load-balancer-type: nlb</simpara>
<simpara>The Fully Qualified Domain Name found in the <literal>.status.loadBalancer.ingress.hostname</literal> field of the ingress gateway <literal>Service</literal> object should be specified as one of the entries in the <literal>.spec.remote.addresses</literal> field of the <literal>ServiceMeshPeer</literal> object.</simpara>
</section>
<section xml:id="_exposing_the_federation_ingress_on_azure">
<title>Exposing the federation ingress on Azure</title>
<simpara>On Microsoft Azure, merely setting the service type to <literal>LoadBalancer</literal> suffices for mesh federation to operate correctly.</simpara>
<simpara>The IP address found in the <literal>.status.loadBalancer.ingress.ip</literal> field of the ingress gateway <literal>Service</literal> object should be specified as one of the entries in the <literal>.spec.remote.addresses</literal> field of the <literal>ServiceMeshPeer</literal> object.</simpara>
</section>
<section xml:id="_exposing_the_federation_ingress_on_google_cloud_platform_gcp">
<title>Exposing the federation ingress on Google Cloud Platform (GCP)</title>
<simpara>On Google Cloud Platform, merely setting the service type to <literal>LoadBalancer</literal> suffices for mesh federation to operate correctly.</simpara>
<simpara>The IP address found in the <literal>.status.loadBalancer.ingress.ip</literal> field of the ingress gateway <literal>Service</literal> object should be specified as one of the entries in the <literal>.spec.remote.addresses</literal> field of the <literal>ServiceMeshPeer</literal> object.</simpara>
</section>
</section>
<section xml:id="con-my-concept-module-a_federation">
<title>Federation implementation checklist</title>
<simpara>Federating services meshes involves the following activities:</simpara>
<itemizedlist mark="none">
<listitem>
<simpara>&#10063; Configure networking between the clusters that you are going to federate.</simpara>
<itemizedlist mark="none">
<listitem>
<simpara>&#10063; Configure the load balancers supporting the services associated with the federation gateways to support raw TLS traffic.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>&#10063; Installing the Red Hat OpenShift Service Mesh version 2.1 or later Operator in each of your clusters.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Deploying a version 2.1 or later <literal>ServiceMeshControlPlane</literal> to each of your clusters.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Configuring the SMCP for federation for each mesh that you want to federate:</simpara>
<itemizedlist mark="none">
<listitem>
<simpara>&#10063; Create a federation egress gateway for each mesh you are going to federate with.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Create a federation ingress gateway for each mesh you are going to federate with.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Configure a unique trust domain.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>&#10063; Federate two or more meshes by creating a <literal>ServiceMeshPeer</literal> resource for each mesh pair.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Export services by creating an <literal>ExportedServiceSet</literal> resource to make services available from one mesh to a peer mesh.</simpara>
</listitem>
<listitem>
<simpara>&#10063; Import services by creating an <literal>ImportedServiceSet</literal> resource to import services shared by a mesh peer.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-federation-config-smcp_federation">
<title>Configuring a Service Mesh control plane for federation</title>
<simpara>Before a mesh can be federated, you must configure the <literal>ServiceMeshControlPlane</literal> for mesh federation. Because all meshes that are members of the federation are equal, and each mesh is managed independently, you must configure the SMCP for <emphasis>each</emphasis> mesh that will participate in the federation.</simpara>
<simpara>In the following example, the administrator for the <literal>red-mesh</literal> is configuring the SMCP for federation with both the <literal>green-mesh</literal> and the <literal>blue-mesh</literal>.</simpara>
<formalpara>
<title>Sample SMCP for red-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: red-mesh
  namespace: red-mesh-system
spec:
  version: v2.4
  runtime:
    defaults:
      container:
        imagePullPolicy: Always
  gateways:
    additionalEgress:
      egress-green-mesh:
        enabled: true
        requestedNetworkView:
        - green-network
        service:
          metadata:
            labels:
              federation.maistra.io/egress-for: egress-green-mesh
          ports:
          - port: 15443
            name: tls
          - port: 8188
            name: http-discovery  #note HTTP here
      egress-blue-mesh:
        enabled: true
        requestedNetworkView:
        - blue-network
        service:
          metadata:
            labels:
              federation.maistra.io/egress-for: egress-blue-mesh
          ports:
          - port: 15443
            name: tls
          - port: 8188
            name: http-discovery  #note HTTP here
    additionalIngress:
      ingress-green-mesh:
        enabled: true
        service:
          type: LoadBalancer
          metadata:
            labels:
              federation.maistra.io/ingress-for: ingress-green-mesh
          ports:
          - port: 15443
            name: tls
          - port: 8188
            name: https-discovery  #note HTTPS here
      ingress-blue-mesh:
        enabled: true
        service:
          type: LoadBalancer
          metadata:
            labels:
              federation.maistra.io/ingress-for: ingress-blue-mesh
          ports:
          - port: 15443
            name: tls
          - port: 8188
            name: https-discovery  #note HTTPS here
  security:
    trust:
      domain: red-mesh.local</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>ServiceMeshControlPlane federation configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  cluster:
    name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the cluster. You are not required to specify a cluster name, but it is helpful for troubleshooting.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  cluster:
    network:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the cluster network. You are not required to specify a name for the network, but it is helpful for configuration and troubleshooting.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="_understanding_federation_gateways">
<title>Understanding federation gateways</title>
<simpara>You use a <emphasis role="strong">gateway</emphasis> to manage inbound and outbound traffic for your mesh, letting you specify which traffic you want to enter or leave the mesh.</simpara>
<simpara>You use ingress and egress gateways to manage traffic entering and leaving the service mesh (North-South traffic). When you create a federated mesh, you create additional ingress/egress gateways, to facilitate service discovery between federated meshes, communication between federated meshes, and to manage traffic flow between service meshes (East-West traffic).</simpara>
<simpara>To avoid naming conflicts between meshes, you must create separate egress and ingress gateways for each mesh. For example, <literal>red-mesh</literal> would have separate egress gateways for traffic going to <literal>green-mesh</literal> and <literal>blue-mesh</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Federation gateway parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  gateways:
    additionalEgress:
      &lt;egressName&gt;:</literallayout></entry>
<entry align="left" valign="top"><simpara>Define an additional egress gateway for <emphasis>each</emphasis> mesh peer in the federation.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  gateways:
    additionalEgress:
      &lt;egressName&gt;:
        enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables or disables the federation egress.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  gateways:
    additionalEgress:
      &lt;egressName&gt;:
        requestedNetworkView:</literallayout></entry>
<entry align="left" valign="top"><simpara>Networks associated with exported services.</simpara></entry>
<entry align="left" valign="top"><simpara>Set to the value of <literal>spec.cluster.network</literal> in the SMCP for the mesh, otherwise use &lt;ServiceMeshPeer-name&gt;-network. For example, if the <literal>ServiceMeshPeer</literal> resource for that mesh is named <literal>west</literal>, then the network would be named <literal>west-network</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalEgress:
      &lt;egressName&gt;:
        service:
          metadata:
            labels:
              federation.maistra.io/egress-for:</simpara></entry>
<entry align="left" valign="top"><simpara>Specify a unique label for the gateway to prevent federated traffic from flowing through the cluster&#8217;s default system gateways.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalEgress:
      &lt;egressName&gt;:
        service:
          ports:</simpara></entry>
<entry align="left" valign="top"><simpara>Used to specify the <literal>port:</literal> and <literal>name:</literal> used for TLS and service discovery. Federation traffic consists of raw encrypted TCP for service traffic.</simpara></entry>
<entry align="left" valign="top"><simpara>Port <literal>15443</literal> is required for sending TLS service requests to other meshes in the federation. Port <literal>8188</literal> is required for sending service discovery requests to other meshes in the federation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:</simpara></entry>
<entry align="left" valign="top"><simpara>Define an additional ingress gateway gateway for <emphasis>each</emphasis> mesh peer in the federation.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIgress:
      &lt;ingressName&gt;:
        enabled:</simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables or disables the federation ingress.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">`true`</literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:
      &lt;ingressName&gt;:
        service:
          type:</simpara></entry>
<entry align="left" valign="top"><simpara>The ingress gateway service must be exposed through a load balancer that operates at Layer 4 of the OSI model and is publicly available.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LoadBalancer</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:
      &lt;ingressName&gt;:
        service:
          type:</simpara></entry>
<entry align="left" valign="top"><simpara>If the cluster does not support <literal>LoadBalancer</literal> services, the ingress gateway service can be exposed through a <literal>NodePort</literal> service.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>NodePort</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:
      &lt;ingressName&gt;:
        service:
          metadata:
            labels:
              federation.maistra.io/ingress-for:</simpara></entry>
<entry align="left" valign="top"><simpara>Specify a unique label for the gateway to prevent federated traffic from flowing through the cluster&#8217;s default system gateways.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:
      &lt;ingressName&gt;:
        service:
          ports:</simpara></entry>
<entry align="left" valign="top"><simpara>Used to specify the <literal>port:</literal> and <literal>name:</literal> used for TLS and service discovery. Federation traffic consists of raw encrypted TCP for service traffic. Federation traffic consists of HTTPS for discovery.</simpara></entry>
<entry align="left" valign="top"><simpara>Port <literal>15443</literal> is required for receiving TLS service requests to other meshes in the federation. Port <literal>8188</literal> is required for receiving service discovery requests to other meshes in the federation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top"><simpara>spec:
  gateways:
    additionalIngress:
      &lt;ingressName&gt;:
        service:
          ports:
            nodePort:</simpara></entry>
<entry align="left" valign="top"><simpara>Used to specify the <literal>nodePort:</literal> if the cluster does not support <literal>LoadBalancer</literal> services.</simpara></entry>
<entry align="left" valign="top"><simpara>If specified, is required in addition to <literal>port:</literal> and <literal>name:</literal> for both TLS and service discovery. <literal>nodePort:</literal> must be in the range  <literal>30000</literal>-<literal>32767</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>In the following example, the administrator is configuring the SMCP for federation with  the <literal>green-mesh</literal> using a <literal>NodePort</literal> service.</simpara>
<formalpara>
<title>Sample SMCP for NodePort</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  gateways:
     additionalIngress:
      ingress-green-mesh:
        enabled: true
        service:
          type: NodePort
          metadata:
            labels:
              federation.maistra.io/ingress-for: ingress-green-mesh
          ports:
          - port: 15443
            nodePort: 30510
            name: tls
          - port: 8188
            nodePort: 32359
            name: https-discovery</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_understanding_federation_trust_domain_parameters">
<title>Understanding federation trust domain parameters</title>
<simpara>Each mesh in the federation must have its own unique trust domain. This value is used when configuring mesh federation in the <literal>ServiceMeshPeer</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ServiceMeshControlPlane
metadata:
  name: red-mesh
  namespace: red-mesh-system
spec:
  security:
    trust:
      domain: red-mesh.local</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Federation security parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  security:
    trust:
      domain:</literallayout></entry>
<entry align="left" valign="top"><simpara>Used to specify a unique name for the trust domain for the mesh. Domains must be unique for every mesh in the federation.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>&lt;mesh-name&gt;.local</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Procedure from the Console</title>
<para>Follow this procedure to edit the <literal>ServiceMeshControlPlane</literal> with the OpenShift Container Platform web console. This example uses the <literal>red-mesh</literal> as an example.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the cluster-admin role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane. For example, <literal>red-mesh-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab, click the name of your <literal>ServiceMeshControlPlane</literal>, for example <literal>red-mesh</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create ServiceMeshControlPlane Details</emphasis> page, click <literal>YAML</literal> to modify your configuration.</simpara>
</listitem>
<listitem>
<simpara>Modify your <literal>ServiceMeshControlPlane</literal> to add federation ingress and egress gateways and to specify the trust domain.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Procedure from the CLI</title>
<para>Follow this procedure to create or edit the <literal>ServiceMeshControlPlane</literal> with the command line. This example uses the <literal>red-mesh</literal> as an example.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane, for example red-mesh-system.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project red-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>ServiceMeshControlPlane</literal> file to add federation ingress and egress gateways and to specify the trust domain.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to edit the Service Mesh control plane where <literal>red-mesh-system</literal> is the system namespace and <literal>red-mesh</literal> is the name of the <literal>ServiceMeshControlPlane</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -n red-mesh-system smcp red-mesh</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command, where <literal>red-mesh-system</literal> is the system namespace, to see the status of the Service Mesh control plane installation.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n red-mesh-system</programlisting>
<simpara>The installation has finished successfully when the READY column indicates that all components are ready.</simpara>
<screen>NAME       READY   STATUS            PROFILES      VERSION   AGE
red-mesh   10/10   ComponentsReady   ["default"]   2.1.0     4m25s</screen>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-federation-joining_federation">
<title>Joining a federated mesh</title>
<simpara>You declare the federation between two meshes by creating a <literal>ServiceMeshPeer</literal> resource. The <literal>ServiceMeshPeer</literal> resource defines the federation between two meshes, and you use it to configure discovery for the peer mesh, access to the peer mesh, and certificates used to validate the other mesh’s clients.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-federated-mesh.png"/>
</imageobject>
<textobject><phrase>Service Mesh federated mesh peers illustration</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Meshes are federated on a one-to-one basis, so each pair of peers requires a pair of <literal>ServiceMeshPeer</literal> resources specifying the federation connection to the other service mesh. For example, federating two meshes named <literal>red</literal> and <literal>green</literal> would require two <literal>ServiceMeshPeer</literal> files.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On red-mesh-system, create a <literal>ServiceMeshPeer</literal> for the green mesh.</simpara>
</listitem>
<listitem>
<simpara>On green-mesh-system, create a <literal>ServiceMeshPeer</literal> for the red mesh.</simpara>
</listitem>
</orderedlist>
<simpara>Federating three meshes named <literal>red</literal>, <literal>blue</literal>, and <literal>green</literal> would require six <literal>ServiceMeshPeer</literal> files.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On red-mesh-system, create a <literal>ServiceMeshPeer</literal> for the green mesh.</simpara>
</listitem>
<listitem>
<simpara>On red-mesh-system, create a <literal>ServiceMeshPeer</literal> for the blue mesh.</simpara>
</listitem>
<listitem>
<simpara>On green-mesh-system, create a <literal>ServiceMeshPeer</literal> for the red mesh.</simpara>
</listitem>
<listitem>
<simpara>On green-mesh-system, create a <literal>ServiceMeshPeer</literal> for the blue mesh.</simpara>
</listitem>
<listitem>
<simpara>On blue-mesh-system, create a <literal>ServiceMeshPeer</literal> for the red mesh.</simpara>
</listitem>
<listitem>
<simpara>On blue-mesh-system, create a <literal>ServiceMeshPeer</literal> for the green mesh.</simpara>
</listitem>
</orderedlist>
<simpara>Configuration in the <literal>ServiceMeshPeer</literal> resource includes the following:</simpara>
<itemizedlist>
<listitem>
<simpara>The address of the other mesh’s ingress gateway, which is used for discovery and service requests.</simpara>
</listitem>
<listitem>
<simpara>The names of the local ingress and egress gateways that is used for interactions with the specified peer mesh.</simpara>
</listitem>
<listitem>
<simpara>The client ID used by the other mesh when sending requests to this mesh.</simpara>
</listitem>
<listitem>
<simpara>The trust domain used by the other mesh.</simpara>
</listitem>
<listitem>
<simpara>The name of a <literal>ConfigMap</literal> containing a root certificate that is used to validate client certificates in the trust domain used by the other mesh.</simpara>
</listitem>
</itemizedlist>
<simpara>In the following example, the administrator for the <literal>red-mesh</literal> is configuring federation with the <literal>green-mesh</literal>.</simpara>
<formalpara>
<title>Example ServiceMeshPeer resource for red-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ServiceMeshPeer
apiVersion: federation.maistra.io/v1
metadata:
  name: green-mesh
  namespace: red-mesh-system
spec:
  remote:
    addresses:
    - ingress-red-mesh.green-mesh-system.apps.domain.com
  gateways:
    ingress:
      name: ingress-green-mesh
    egress:
      name: egress-green-mesh
  security:
    trustDomain: green-mesh.local
    clientID: green-mesh.local/ns/green-mesh-system/sa/egress-red-mesh-service-account
    certificateChain:
      kind: ConfigMap
      name: green-mesh-ca-root-cert</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>ServiceMeshPeer configuration parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the peer mesh that this resource is configuring federation with.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  namespace:</literallayout></entry>
<entry align="left" valign="top"><simpara>System namespace for this mesh, that is, where the Service Mesh control plane is installed.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  remote:
    addresses:</literallayout></entry>
<entry align="left" valign="top"><simpara>List of public addresses of the peer meshes' ingress gateways that are servicing requests from this mesh.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  remote:
    discoveryPort:</literallayout></entry>
<entry align="left" valign="top"><simpara>The port on which the addresses are handling discovery requests.</simpara></entry>
<entry align="left" valign="top"><simpara>Defaults to 8188</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  remote:
    servicePort:</literallayout></entry>
<entry align="left" valign="top"><simpara>The port on which the addresses are handling service requests.</simpara></entry>
<entry align="left" valign="top"><simpara>Defaults to 15443</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  gateways:
    ingress:
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the ingress on this mesh that is servicing requests received from the peer mesh. For example, <literal>ingress-green-mesh</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  gateways:
    egress:
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the egress on this mesh that is servicing requests sent to the peer mesh. For example, <literal>egress-green-mesh</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  security:
    trustDomain:</literallayout></entry>
<entry align="left" valign="top"><simpara>The trust domain used by the peer mesh.</simpara></entry>
<entry align="left" valign="top"><simpara>&lt;peerMeshName&gt;.local</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  security:
    clientID:</literallayout></entry>
<entry align="left" valign="top"><simpara>The client ID used by the peer mesh when calling into this mesh.</simpara></entry>
<entry align="left" valign="top"><simpara>&lt;peerMeshTrustDomain&gt;/ns/&lt;peerMeshSystem&gt;/sa/&lt;peerMeshEgressGatewayName&gt;-service-account</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  security:
    certificateChain:
      kind: ConfigMap
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>The kind (for example, ConfigMap) and name of a resource containing the root certificate used to validate the client and server certificate(s) presented to this mesh by the peer mesh.
The key of the config map entry containing the certificate should be <literal>root-cert.pem</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>kind: ConfigMap
name: &lt;peerMesh&gt;-ca-root-cert</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="ossm-federation-create-peer_federation">
<title>Creating a ServiceMeshPeer resource</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Two or more OpenShift Container Platform 4.6 or above clusters.</simpara>
</listitem>
<listitem>
<simpara>The clusters must already be networked.</simpara>
</listitem>
<listitem>
<simpara>The load balancers supporting the services associated with the federation gateways must be configured to support raw TLS traffic.</simpara>
</listitem>
<listitem>
<simpara>Each cluster must have a version 2.1 or later <literal>ServiceMeshControlPlane</literal> configured to support federation deployed.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure from the CLI</title>
<para>Follow this procedure to create a <literal>ServiceMeshPeer</literal> resource from the command line. This example shows the <literal>red-mesh</literal> creating a peer resource for the <literal>green-mesh</literal>.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; &lt;API token&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the control plane, for example, <literal>red-mesh-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project red-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ServiceMeshPeer</literal> file based the following example for the two meshes that you want to federate.</simpara>
<formalpara>
<title>Example ServiceMeshPeer resource for red-mesh to green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ServiceMeshPeer
apiVersion: federation.maistra.io/v1
metadata:
  name: green-mesh
  namespace: red-mesh-system
spec:
  remote:
    addresses:
    - ingress-red-mesh.green-mesh-system.apps.domain.com
  gateways:
    ingress:
      name: ingress-green-mesh
    egress:
      name: egress-green-mesh
  security:
    trustDomain: green-mesh.local
    clientID: green-mesh.local/ns/green-mesh-system/sa/egress-red-mesh-service-account
    certificateChain:
      kind: ConfigMap
      name: green-mesh-ca-root-cert</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to deploy the resource, where <literal>red-mesh-system</literal> is the system namespace and <literal>servicemeshpeer.yaml</literal> includes a full path to the file you edited:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n red-mesh-system -f servicemeshpeer.yaml</programlisting>
</listitem>
<listitem>
<simpara>To confirm that connection between the red mesh and green mesh is established, inspect the status of the green-mesh <literal>ServiceMeshPeer</literal> in the red-mesh-system namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n red-mesh-system get servicemeshpeer green-mesh -o yaml</programlisting>
<formalpara>
<title>Example ServiceMeshPeer connection between red-mesh and green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">status:
  discoveryStatus:
    active:
    - pod: istiod-red-mesh-b65457658-9wq5j
      remotes:
      - connected: true
        lastConnected: "2021-10-05T13:02:25Z"
        lastFullSync: "2021-10-05T13:02:25Z"
        source: 10.128.2.149
      watch:
        connected: true
        lastConnected: "2021-10-05T13:02:55Z"
        lastDisconnectStatus: 503 Service Unavailable
        lastFullSync: "2021-10-05T13:05:43Z"</programlisting>
</para>
</formalpara>
<simpara>The <literal>status.discoveryStatus.active.remotes</literal> field shows that istiod in the peer mesh (in this example, the green mesh) is connected to istiod in the current mesh (in this example, the red mesh).</simpara>
<simpara>The <literal>status.discoveryStatus.active.watch</literal> field shows that istiod in the current mesh is connected to istiod in the peer mesh.</simpara>
<simpara>If you check the <literal>servicemeshpeer</literal> named <literal>red-mesh</literal> in <literal>green-mesh-system</literal>, you&#8217;ll find information about the same two connections from the perspective of the green mesh.</simpara>
<simpara>When the connection between two meshes is not established, the <literal>ServiceMeshPeer</literal> status indicates this in the <literal>status.discoveryStatus.inactive</literal> field.</simpara>
<simpara>For more information on why a connection attempt failed, inspect the Istiod log, the access log of the egress gateway handling egress traffic for the peer, and the ingress gateway handling ingress traffic for the current mesh in the peer mesh.</simpara>
<simpara>For example, if the red mesh can&#8217;t connect to the green mesh, check the following logs:</simpara>
<itemizedlist>
<listitem>
<simpara>istiod-red-mesh in red-mesh-system</simpara>
</listitem>
<listitem>
<simpara>egress-green-mesh in red-mesh-system</simpara>
</listitem>
<listitem>
<simpara>ingress-red-mesh in green-mesh-system</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-federation-config-export_federation">
<title>Exporting a service from a federated mesh</title>
<simpara>Exporting services allows a mesh to share one or more of its services with another member of the federated mesh.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-federation-export-service.png"/>
</imageobject>
<textobject><phrase>Service Mesh federation exporting service illustration</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You use an <literal>ExportedServiceSet</literal> resource to declare the services from one mesh that you are making available to another peer in the federated mesh. You must explicitly declare each service to be shared with a peer.</simpara>
<itemizedlist>
<listitem>
<simpara>You can select services by namespace or name.</simpara>
</listitem>
<listitem>
<simpara>You can use wildcards to select services; for example, to export all the services in a namespace.</simpara>
</listitem>
<listitem>
<simpara>You can export services using an alias. For example, you can export the <literal>foo/bar</literal> service as <literal>custom-ns/bar</literal>.</simpara>
</listitem>
<listitem>
<simpara>You can only export services that are visible to the mesh’s system namespace. For example, a service in another namespace with a <literal>networking.istio.io/exportTo</literal> label set to ‘.’ would not be a candidate for export.</simpara>
</listitem>
<listitem>
<simpara>For exported services, their target services will only see traffic from the ingress gateway, not the original requestor (that is, they won’t see the client ID of either the other mesh’s egress gateway or the workload originating the request)</simpara>
</listitem>
</itemizedlist>
<simpara>The following example is for services that <literal>red-mesh</literal> is exporting to <literal>green-mesh</literal>.</simpara>
<formalpara>
<title>Example ExportedServiceSet resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ExportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: green-mesh
  namespace: red-mesh-system
spec:
  exportRules:
  # export ratings.mesh-x-bookinfo as ratings.bookinfo
  - type: NameSelector
    nameSelector:
      namespace: red-mesh-bookinfo
      name: red-ratings
      alias:
        namespace: bookinfo
        name: ratings
  # export any service in red-mesh-bookinfo namespace with label export-service=true
  - type: LabelSelector
    labelSelector:
      namespace: red-mesh-bookinfo
      selector:
        matchLabels:
          export-service: "true"
      aliases: # export all matching services as if they were in the bookinfo namespace
      - namespace: "*"
        name: "*"
        alias:
          namespace: bookinfo</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>ExportedServiceSet parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the ServiceMeshPeer you are exposing this service to.</simpara></entry>
<entry align="left" valign="top"><simpara>Must match the <literal>name</literal> value for the mesh in the <literal>ServiceMeshPeer</literal> resource.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  namespace:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the project/namespace containing this resource (should be the system namespace for the mesh) .</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  exportRules:
  - type:</literallayout></entry>
<entry align="left" valign="top"><simpara>Type of rule that will govern the export for this service. The first matching rule found for the service will be used for the export.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>NameSelector</literal>, <literal>LabelSelector</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  exportRules:
  - type: NameSelector
    nameSelector:
      namespace:
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>NameSelector</literal> rule, specify the <literal>namespace</literal> of the service and the <literal>name</literal> of the service as defined in the <literal>Service</literal> resource.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  exportRules:
  - type: NameSelector
    nameSelector:
      alias:
        namespace:
        name:</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>NameSelector</literal> rule that uses an alias for the service, after specifying the <literal>namespace</literal> and <literal>name</literal> for the service, then specify the alias for the <literal>namespace</literal> and the alias to be used for <literal>name</literal> of the service.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  exportRules:
  - type: LabelSelector
    labelSelector:
      namespace: &lt;exportingMesh&gt;
      selector:
        matchLabels:
          &lt;labelKey&gt;: &lt;labelValue&gt;</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>LabelSelector</literal> rule, specify the <literal>namespace</literal> of the service and specify the <literal>label</literal> defined in the <literal>Service</literal> resource. In the example above, the label is <literal>export-service</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  exportRules:
  - type: LabelSelector
    labelSelector:
      namespace: &lt;exportingMesh&gt;
      selector:
        matchLabels:
          &lt;labelKey&gt;: &lt;labelValue&gt;
      aliases:
      - namespace:
        name:
        alias:
          namespace:
          name:</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>LabelSelector</literal> rule that uses aliases for the services, after specifying the <literal>selector</literal>, specify the aliases to be used for <literal>name</literal> or <literal>namespace</literal> of the service. In the example above, the namespace alias is <literal>bookinfo</literal> for all matching services.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Export services with the name "ratings" from all namespaces in the red-mesh to blue-mesh.</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ExportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: blue-mesh
  namespace: red-mesh-system
spec:
  exportRules:
  - type: NameSelector
    nameSelector:
      namespace: "*"
      name: ratings</programlisting>
</para>
</formalpara>
<formalpara>
<title>Export all services from the west-data-center namespace to green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ExportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: green-mesh
  namespace: red-mesh-system
spec:
  exportRules:
  - type: NameSelector
    nameSelector:
      namespace: west-data-center
      name: "*"</programlisting>
</para>
</formalpara>
<section xml:id="ossm-federation-create-export_federation">
<title>Creating an ExportedServiceSet</title>
<simpara>You create an <literal>ExportedServiceSet</literal> resource to explicitly declare the services that you want to be available to a mesh peer.</simpara>
<simpara>Services are exported as <literal>&lt;export-name&gt;.&lt;export-namespace&gt;.svc.&lt;ServiceMeshPeer.name&gt;-exports.local</literal> and will automatically route to the target service.  This is the name by which the exported service is known in the exporting mesh. When the ingress gateway receives a request destined for this name, it will be routed to the actual service being exported. For example, if a service named <literal>ratings.red-mesh-bookinfo</literal> is exported to <literal>green-mesh</literal> as <literal>ratings.bookinfo</literal>, the service will be exported under the name <literal>ratings.bookinfo.svc.green-mesh-exports.local</literal>, and traffic received by the ingress gateway for that hostname will be routed to the <literal>ratings.red-mesh-bookinfo</literal> service.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The cluster and <literal>ServiceMeshControlPlane</literal> have been configured for mesh federation.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can configure services for export even if they don&#8217;t exist yet. When a service that matches the value specified in the ExportedServiceSet is deployed, it will be automatically exported.</simpara>
</note>
<formalpara>
<title>Procedure from the CLI</title>
<para>Follow this procedure to create an <literal>ExportedServiceSet</literal> from the command line.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; &lt;API token&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane; for example, <literal>red-mesh-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project red-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Create an <literal>ExportedServiceSet</literal> file based on the following example where <literal>red-mesh</literal> is exporting services to <literal>green-mesh</literal>.</simpara>
<formalpara>
<title>Example ExportedServiceSet resource from red-mesh to green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: federation.maistra.io/v1
kind: ExportedServiceSet
metadata:
  name: green-mesh
  namespace: red-mesh-system
spec:
  exportRules:
  - type: NameSelector
    nameSelector:
      namespace: red-mesh-bookinfo
      name: ratings
      alias:
        namespace: bookinfo
        name: red-ratings
  - type: NameSelector
    nameSelector:
      namespace: red-mesh-bookinfo
      name: reviews</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload and create the <literal>ExportedServiceSet</literal> resource in the red-mesh-system namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n &lt;ControlPlaneNamespace&gt; -f &lt;ExportedServiceSet.yaml&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n red-mesh-system -f export-to-green-mesh.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create additional <literal>ExportedServiceSets</literal> as needed for each mesh peer in your federated mesh.</simpara>
</listitem>
<listitem>
<simpara>To validate the services you&#8217;ve exported from <literal>red-mesh</literal> to share with <literal>green-mesh</literal>, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get exportedserviceset &lt;PeerMeshExportedTo&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get exportedserviceset green-mesh -o yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to validate the services the red-mesh exports to share with green-mesh:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get exportedserviceset &lt;PeerMeshExportedTo&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n red-mesh-system get exportedserviceset green-mesh -o yaml</programlisting>
<formalpara>
<title>Example validating the services exported from the red mesh that are shared with the green mesh.</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  status:
    exportedServices:
    - exportedName: red-ratings.bookinfo.svc.green-mesh-exports.local
      localService:
        hostname: ratings.red-mesh-bookinfo.svc.cluster.local
        name: ratings
        namespace: red-mesh-bookinfo
    - exportedName: reviews.red-mesh-bookinfo.svc.green-mesh-exports.local
      localService:
        hostname: reviews.red-mesh-bookinfo.svc.cluster.local
        name: reviews
        namespace: red-mesh-bookinfo</programlisting>
</para>
</formalpara>
<simpara>The <literal>status.exportedServices</literal> array lists the services that are currently exported (these services matched the export rules in the <literal>ExportedServiceSet object</literal>). Each entry in the array indicates the name of the exported service and details about the local service that is exported.</simpara>
<simpara>If a service that you expected to be exported is missing, confirm the Service object exists, its name or labels match the <literal>exportRules</literal> defined in the <literal>ExportedServiceSet</literal> object, and that the Service object&#8217;s namespace is configured as a member of the service mesh using the <literal>ServiceMeshMemberRoll</literal> or <literal>ServiceMeshMember</literal> object.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-federation-config-import_federation">
<title>Importing a service into a federated mesh</title>
<simpara>Importing services lets you explicitly specify which services exported from another mesh should be accessible within your service mesh.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-federation-import-service.png"/>
</imageobject>
<textobject><phrase>Service Mesh federation importing service illustration</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You use an <literal>ImportedServiceSet</literal> resource to select services for import. Only services exported by a mesh peer and explicitly imported are available to the mesh. Services that you do not explicitly import are not made available within the mesh.</simpara>
<itemizedlist>
<listitem>
<simpara>You can select services by namespace or name.</simpara>
</listitem>
<listitem>
<simpara>You can use wildcards to select services, for example, to import all the services that were exported to the namespace.</simpara>
</listitem>
<listitem>
<simpara>You can select services for export using a label selector, which may be global to the mesh, or scoped to a specific member namespace.</simpara>
</listitem>
<listitem>
<simpara>You can import services using an alias. For example, you can import the <literal>custom-ns/bar</literal> service as <literal>other-mesh/bar</literal>.</simpara>
</listitem>
<listitem>
<simpara>You can specify a custom domain suffix, which will be appended to the <literal>name.namespace</literal> of an imported service for its fully qualified domain name; for example, <literal>bar.other-mesh.imported.local</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The following example is for the <literal>green-mesh</literal> importing a service that was exported by <literal>red-mesh</literal>.</simpara>
<formalpara>
<title>Example ImportedServiceSet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: red-mesh #name of mesh that exported the service
  namespace: green-mesh-system #mesh namespace that service is being imported into
spec:
  importRules: # first matching rule is used
  # import ratings.bookinfo as ratings.bookinfo
  - type: NameSelector
    importAsLocal: false
    nameSelector:
      namespace: bookinfo
      name: ratings
      alias:
        # service will be imported as ratings.bookinfo.svc.red-mesh-imports.local
        namespace: bookinfo
        name: ratings</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>ImportedServiceSet parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the ServiceMeshPeer that exported the service to the federated mesh.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">metadata:
  namespace:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the namespace containing the ServiceMeshPeer resource (the mesh system namespace).</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  importRules:
  - type:</literallayout></entry>
<entry align="left" valign="top"><simpara>Type of rule that will govern the import for the service. The first matching rule found for the service will be used for the import.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>NameSelector</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  importRules:
  - type: NameSelector
    nameSelector:
      namespace:
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>NameSelector</literal> rule, specify the <literal>namespace</literal> and the <literal>name</literal> of the exported service.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  importRules:
  - type: NameSelector
    importAsLocal:</literallayout></entry>
<entry align="left" valign="top"><simpara>Set to <literal>true</literal> to aggregate remote endpoint with local services. When <literal>true</literal>, services will be imported as <literal>&lt;name&gt;.&lt;namespace&gt;.svc.cluster.local</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  importRules:
  - type: NameSelector
    nameSelector:
      namespace:
      name:
      alias:
        namespace:
        name:</literallayout></entry>
<entry align="left" valign="top"><simpara>To create a <literal>NameSelector</literal> rule that uses an alias for the service, after specifying the <literal>namespace</literal> and <literal>name</literal> for the service, then specify the alias for the <literal>namespace</literal> and the alias to be used for <literal>name</literal> of the service.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Import the "bookinfo/ratings" service from the red-mesh into blue-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: red-mesh
  namespace: blue-mesh-system
spec:
  importRules:
  - type: NameSelector
    importAsLocal: false
    nameSelector:
      namespace: bookinfo
      name: ratings</programlisting>
</para>
</formalpara>
<formalpara>
<title>Import all services from the red-mesh&#8217;s west-data-center namespace into the green-mesh. These services will be accessible as &lt;name&gt;.west-data-center.svc.red-mesh-imports.local</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: red-mesh
  namespace: green-mesh-system
spec:
  importRules:
  - type: NameSelector
    importAsLocal: false
    nameSelector:
      namespace: west-data-center
      name: "*"</programlisting>
</para>
</formalpara>
<section xml:id="ossm-federation-create-import_federation">
<title>Creating an ImportedServiceSet</title>
<simpara>You create an <literal>ImportedServiceSet</literal> resource to explicitly declare the services that you want to import into your mesh.</simpara>
<simpara>Services are imported with the name <literal>&lt;exported-name&gt;.&lt;exported-namespace&gt;.svc.&lt;ServiceMeshPeer.name&gt;.remote</literal> which is a "hidden" service, visible only within the egress gateway namespace and is associated with the exported service&#8217;s hostname. The service will be available locally as <literal>&lt;export-name&gt;.&lt;export-namespace&gt;.&lt;domainSuffix&gt;</literal>, where <literal>domainSuffix</literal> is <literal>svc.&lt;ServiceMeshPeer.name&gt;-imports.local</literal> by default, unless <literal>importAsLocal</literal> is set to <literal>true</literal>, in which case <literal>domainSuffix</literal> is <literal>svc.cluster.local</literal>.  If <literal>importAsLocal</literal> is set to <literal>false</literal>, the domain suffix in the import rule will be applied.  You can treat the local import just like any other service in the mesh. It automatically routes through the egress gateway, where it is redirected to the exported service&#8217;s remote name.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The cluster and <literal>ServiceMeshControlPlane</literal> have been configured for mesh federation.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can configure services for import even if they haven&#8217;t been exported yet. When a service that matches the value specified in the ImportedServiceSet is deployed and exported, it will be automatically imported.</simpara>
</note>
<formalpara>
<title>Procedure from the CLI</title>
<para>Follow this procedure to create an <literal>ImportedServiceSet</literal> from the command line.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; &lt;API token&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane; for example, <literal>green-mesh-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project green-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Create an <literal>ImportedServiceSet</literal> file based on the following example where <literal>green-mesh</literal> is importing services previously exported by <literal>red-mesh</literal>.</simpara>
<formalpara>
<title>Example ImportedServiceSet resource from red-mesh to green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: red-mesh
  namespace: green-mesh-system
spec:
  importRules:
  - type: NameSelector
    importAsLocal: false
    nameSelector:
      namespace: bookinfo
      name: red-ratings
      alias:
        namespace: bookinfo
        name: ratings</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload and create the <literal>ImportedServiceSet</literal> resource in the green-mesh-system namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n &lt;ControlPlaneNamespace&gt; -f &lt;ImportedServiceSet.yaml&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n green-mesh-system -f import-from-red-mesh.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create additional <literal>ImportedServiceSet</literal> resources as needed for each mesh peer in your federated mesh.</simpara>
</listitem>
<listitem>
<simpara>To validate the services you&#8217;ve imported into <literal>green-mesh</literal>, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get importedserviceset &lt;PeerMeshImportedInto&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get importedserviceset green-mesh -o yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to validate the services imported into a mesh.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get importedserviceset &lt;PeerMeshImportedInto&gt; -o yaml</programlisting>
<formalpara>
<title>Example validating that the services exported from the red mesh have been imported into the green mesh using the status section of the <literal>importedserviceset/red-mesh' object in the 'green-mesh-system</literal> namespace:</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n green-mesh-system get importedserviceset/red-mesh -o yaml</programlisting>
</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">status:
  importedServices:
  - exportedName: red-ratings.bookinfo.svc.green-mesh-exports.local
    localService:
      hostname: ratings.bookinfo.svc.red-mesh-imports.local
      name: ratings
      namespace: bookinfo
  - exportedName: reviews.red-mesh-bookinfo.svc.green-mesh-exports.local
    localService:
      hostname: ""
      name: ""
      namespace: ""</programlisting>
<simpara>In the preceding example only the ratings service is imported, as indicated by the populated fields under <literal>localService</literal>. The reviews service is available for import, but isn&#8217;t currently imported because it does not match any <literal>importRules</literal> in the <literal>ImportedServiceSet</literal> object.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-federation-config-failover-overview_federation">
<title>Configuring a federated mesh for failover</title>
<simpara>Failover is the ability to switch automatically and seamlessly to a reliable backup system, for example another server. In the case of a federated mesh, you can configure a service in one mesh to failover to a service in another mesh.</simpara>
<simpara>You configure Federation for failover by setting the <literal>importAsLocal</literal> and <literal>locality</literal> settings in an <literal>ImportedServiceSet</literal> resource and then configuring a <literal>DestinationRule</literal> that configures failover for the service to the locality specified in the <literal>ImportedServiceSet</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Two or more OpenShift Container Platform 4.6 or above clusters already networked and federated.</simpara>
</listitem>
<listitem>
<simpara><literal>ExportedServiceSet</literal> resources already created for each mesh peer in the federated mesh.</simpara>
</listitem>
<listitem>
<simpara><literal>ImportedServiceSet</literal> resources already created for each mesh peer in the federated mesh.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-federation-config-importedserviceset-failover_federation">
<title>Configuring an ImportedServiceSet for failover</title>
<simpara>Locality-weighted load balancing allows administrators to control the distribution of traffic to endpoints based on the localities of where the traffic originates and where it will terminate. These localities are specified using arbitrary labels that designate a hierarchy of localities in {region}/{zone}/{sub-zone} form.</simpara>
<simpara>In the examples in this section, the <literal>green-mesh</literal> is located in the <literal>us-east</literal> region, and the <literal>red-mesh</literal> is located in the <literal>us-west</literal> region.</simpara>
<formalpara>
<title>Example <literal>ImportedServiceSet</literal> resource from red-mesh to green-mesh</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImportedServiceSet
apiVersion: federation.maistra.io/v1
metadata:
  name: red-mesh #name of mesh that exported the service
  namespace: green-mesh-system #mesh namespace that service is being imported into
spec:
  importRules: # first matching rule is used
  # import ratings.bookinfo as ratings.bookinfo
  - type: NameSelector
    importAsLocal: true
    nameSelector:
      namespace: bookinfo
      name: ratings
      alias:
        # service will be imported as ratings.bookinfo.svc.red-mesh-imports.local
        namespace: bookinfo
        name: ratings
  #Locality within which imported services should be associated.
  locality:
    region: us-west</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ImportedServiceLocality</literal> fields table</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>region:</simpara></entry>
<entry align="left" valign="top"><simpara>Region within which imported services are located.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>subzone:</simpara></entry>
<entry align="left" valign="top"><simpara>Subzone within which imported services are located.  I Subzone is specified, Zone must also be specified.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>zone:</simpara></entry>
<entry align="left" valign="top"><simpara>Zone within which imported services are located.  If Zone is specified, Region must also be specified.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; &lt;API token&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project &lt;smcp-system&gt;</programlisting>
<simpara>For example, <literal>green-mesh-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project green-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>ImportedServiceSet</literal> file, where <literal>&lt;ImportedServiceSet.yaml&gt;</literal> includes a full path to the file you want to edit, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -n &lt;smcp-system&gt; -f &lt;ImportedServiceSet.yaml&gt;</programlisting>
<simpara>For example, if you want to modify the file that imports from the red-mesh-system to the green-mesh-system as shown in the previous <literal>ImportedServiceSet</literal> example.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -n green-mesh-system -f import-from-red-mesh.yaml</programlisting>
</listitem>
<listitem>
<simpara>Modify the file:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set <literal>spec.importRules.importAsLocal</literal> to <literal>true</literal>.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>spec.locality</literal> to a <literal>region</literal>, <literal>zone</literal>, or <literal>subzone</literal>.</simpara>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-federation-config-destinationrule-failover_federation">
<title>Configuring a DestinationRule for failover</title>
<simpara>Create a <literal>DestinationRule</literal> resource that configures the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Outlier detection for the service. This is required in order for failover to function properly. In particular, it configures the sidecar proxies to know when endpoints for a service are unhealthy, eventually triggering a failover to the next locality.</simpara>
</listitem>
<listitem>
<simpara>Failover policy between regions. This ensures that failover beyond a region boundary will behave predictably.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; &lt;API token&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project &lt;smcp-system&gt;</programlisting>
<simpara>For example, <literal>green-mesh-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project green-mesh-system</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>DestinationRule</literal> file based on the following example where if green-mesh is unavailable, the traffic should be routed from the green-mesh in the <literal>us-east</literal> region to the red-mesh in <literal>us-west</literal>.</simpara>
<formalpara>
<title>Example <literal>DestinationRule</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: default-failover
  namespace: bookinfo
spec:
  host: "ratings.bookinfo.svc.cluster.local"
  trafficPolicy:
    loadBalancer:
      localityLbSetting:
        enabled: true
        failover:
          - from: us-east
            to: us-west
    outlierDetection:
      consecutive5xxErrors: 3
      interval: 10s
      baseEjectionTime: 1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Deploy the <literal>DestinationRule</literal>, where <literal>&lt;DestinationRule&gt;</literal> includes the full path to your file, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n &lt;application namespace&gt; -f &lt;DestinationRule.yaml&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n bookinfo -f green-mesh-us-west-DestinationRule.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-federation-remove-service_federation">
<title>Removing a service from the federated mesh</title>
<simpara>If you need to remove a service from the federated mesh, for example if it has become obsolete or has been replaced by a different service, you can do so.</simpara>
<section xml:id="_to_remove_a_service_from_a_single_mesh">
<title>To remove a service from a single mesh</title>
<simpara>Remove the entry for the service from the <literal>ImportedServiceSet</literal> resource for the mesh peer that no longer should access the service.</simpara>
</section>
<section xml:id="_to_remove_a_service_from_the_entire_federated_mesh">
<title>To remove a service from the entire federated mesh</title>
<simpara>Remove the entry for the service from the <literal>ExportedServiceSet</literal> resource for the mesh that owns the service.</simpara>
</section>
</section>
<section xml:id="ossm-federation-remove-mesh_federation">
<title>Removing a mesh from the federated mesh</title>
<simpara>If you need to remove a mesh from the federation, you can do so.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the removed mesh&#8217;s <literal>ServiceMeshControlPlane</literal> resource to remove all federation ingress gateways for peer meshes.</simpara>
</listitem>
<listitem>
<simpara>For each mesh peer that the removed mesh has been federated with:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Remove the <literal>ServiceMeshPeer</literal> resource that links the two meshes.</simpara>
</listitem>
<listitem>
<simpara>Edit the peer mesh&#8217;s <literal>ServiceMeshControlPlane</literal> resource to remove the egress gateway that serves the removed mesh.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-extensions">
<title>Extensions</title>

<simpara>You can use WebAssembly extensions to add new features directly into the Red Hat OpenShift Service Mesh proxies. This lets you move even more common functionality out of your applications, and implement them in a single language that compiles to WebAssembly bytecode.</simpara>
<note>
<simpara>WebAssembly extensions are not supported on IBM Z&#174; and IBM Power&#174;.</simpara>
</note>
<section xml:id="ossm-extensions-overview_ossm-extensions">
<title>WebAssembly modules overview</title>
<simpara>WebAssembly modules can be run on many platforms, including proxies, and have broad language support, fast execution, and a sandboxed-by-default security model.</simpara>
<simpara>Red Hat OpenShift Service Mesh extensions are <link xlink:href="https://www.envoyproxy.io/docs/envoy/v1.20.0/intro/arch_overview/http/http_filters#arch-overview-http-filters">Envoy HTTP Filters</link>, giving them a wide range of capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Manipulating the body and headers of requests and responses.</simpara>
</listitem>
<listitem>
<simpara>Out-of-band HTTP requests to services not in the request path, such as authentication or policy checking.</simpara>
</listitem>
<listitem>
<simpara>Side-channel data storage and queues for filters to communicate with each other.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>When creating new WebAssembly extensions, use the <literal>WasmPlugin</literal> API. The <literal>ServiceMeshExtension</literal> API was deprecated in Red Hat OpenShift Service Mesh version 2.2 and was removed in Red Hat OpenShift Service Mesh version 2.3.</simpara>
</note>
<simpara>There are two parts to writing a Red Hat OpenShift Service Mesh extension:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You must write your extension using an SDK that exposes the <link xlink:href="https://github.com/proxy-wasm/spec">proxy-wasm API</link> and compile it to a WebAssembly module.</simpara>
</listitem>
<listitem>
<simpara>You must then package the module into a container.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Supported languages</title>
<para>You can use any language that compiles to WebAssembly bytecode to write a Red Hat OpenShift Service Mesh extension, but the following languages have existing SDKs that expose the proxy-wasm API so that it can be consumed directly.</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported languages</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Language</entry>
<entry align="left" valign="top">Maintainer</entry>
<entry align="left" valign="top">Repository</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AssemblyScript</simpara></entry>
<entry align="left" valign="top"><simpara>solo.io</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://github.com/solo-io/proxy-runtime">solo-io/proxy-runtime</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C++</simpara></entry>
<entry align="left" valign="top"><simpara>proxy-wasm team (Istio Community)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk">proxy-wasm/proxy-wasm-cpp-sdk</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Go</simpara></entry>
<entry align="left" valign="top"><simpara>tetrate.io</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://github.com/tetratelabs/proxy-wasm-go-sdk">tetratelabs/proxy-wasm-go-sdk</link></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rust</simpara></entry>
<entry align="left" valign="top"><simpara>proxy-wasm team (Istio Community)</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">proxy-wasm/proxy-wasm-rust-sdk</link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-extensions-wasmplugin-format_ossm-extensions">
<title><literal>WasmPlugin</literal> container format</title>
<simpara>Istio supports Open Container Initiative (OCI) images in its Wasm Plugin mechanism. You can distribute your Wasm Plugins as a container image, and you can use the <literal>spec.url</literal> field to refer to a container registry location.  For example, <literal>quay.io/my-username/my-plugin:latest</literal>.</simpara>
<simpara>Because each execution environment (runtime) for a WASM module can have runtime-specific configuration parameters, a WASM image can be composed of two layers:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">plugin.wasm</emphasis> (Required) - Content layer. This layer consists of a <literal>.wasm</literal> binary containing the bytecode of your WebAssembly module, to be loaded by the runtime.  You must name this file <literal>plugin.wasm</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">runtime-config.json</emphasis> (Optional) - Configuration layer. This layer consists of a JSON-formatted string that describes metadata about the module for the target runtime. The config layer might also contain additional data, depending on the target runtime. For example, the config for a WASM Envoy Filter contains root_ids available on the filter.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-wasm-ref-wasmplugin_ossm-extensions">
<title>WasmPlugin API reference</title>
<simpara>The WasmPlugins API provides a mechanism to extend the functionality provided by the Istio proxy through WebAssembly filters.</simpara>
<simpara>You can deploy multiple WasmPlugins. The <literal>phase</literal> and <literal>priority</literal> settings determine the order of execution (as part of Envoy&#8217;s filter chain), allowing the configuration of complex interactions between user-supplied WasmPlugins and Istio’s internal filters.</simpara>
<simpara>In the following example, an authentication filter implements an OpenID flow and populates the Authorization header with a JSON Web Token (JWT). Istio authentication consumes this token and deploys it to the ingress gateway. The WasmPlugin file lives in the proxy sidecar filesystem. Note the field <literal>url</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: openid-connect
  namespace: istio-ingress
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  url: file:///opt/filters/openid.wasm
  sha256: 1ef0c9a92b0420cf25f7fe5d481b231464bc88f486ca3b9c83ed5cc21d2f6210
  phase: AUTHN
  pluginConfig:
    openid_server: authn
    openid_realm: ingress</programlisting>
<simpara>Below is the same example, but this time an Open Container Initiative (OCI) image is used instead of a file in the filesystem. Note the fields <literal>url</literal>, <literal>imagePullPolicy</literal>, and <literal>imagePullSecret</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: openid-connect
  namespace: istio-system
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  url: oci://private-registry:5000/openid-connect/openid:latest
  imagePullPolicy: IfNotPresent
  imagePullSecret: private-registry-pull-secret
  phase: AUTHN
  pluginConfig:
    openid_server: authn
    openid_realm: ingress</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>WasmPlugin Field Reference</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>spec.selector</simpara></entry>
<entry align="left" valign="top"><simpara>WorkloadSelector</simpara></entry>
<entry align="left" valign="top"><simpara>Criteria used to select the specific set of pods/VMs on which this plugin configuration should be applied. If omitted, this configuration will be applied to all workload instances in the same namespace. If the <literal>WasmPlugin</literal> field is present in the config root namespace, it will be applied to all applicable workloads in any namespace.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.url</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>URL of a Wasm module or OCI container. If no scheme is present, defaults to <literal>oci://</literal>, referencing an OCI image. Other valid schemes are <literal>file://</literal> for referencing .wasm module files present locally within the proxy container, and <literal>http[s]://</literal> for .wasm module files hosted remotely.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.sha256</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>SHA256 checksum that will be used to verify the Wasm module or OCI container. If the <literal>url</literal> field already references a SHA256 (using the <literal>@sha256:</literal> notation), it must match the value of this field. If an OCI image is referenced by tag and this field is set, its checksum will be verified against the contents of this field after pulling.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.imagePullPolicy</simpara></entry>
<entry align="left" valign="top"><simpara>PullPolicy</simpara></entry>
<entry align="left" valign="top"><simpara>The pull behavior to be applied when fetching an OCI image. Only relevant when images are referenced by tag instead of SHA. Defaults to the value <literal>IfNotPresent</literal>, except when an OCI image is referenced in the <literal>url</literal> field and the <literal>latest</literal> tag is used, in which case the value <literal>Always</literal> is the default, mirroring K8s behavior. Setting is ignored if the <literal>url</literal> field is referencing a Wasm module directly using <literal>file://</literal> or <literal>http[s]://</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.imagePullSecret</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>Credentials to use for OCI image pulling. The name of a secret in the same namespace as the <literal>WasmPlugin</literal> object that contains a pull secret for authenticating against the registry when pulling the image.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.phase</simpara></entry>
<entry align="left" valign="top"><simpara>PluginPhase</simpara></entry>
<entry align="left" valign="top"><simpara>Determines where in the filter chain this <literal>WasmPlugin</literal> object is injected.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.priority</simpara></entry>
<entry align="left" valign="top"><simpara><literal>int64</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines the ordering of <literal>WasmPlugins</literal> objects that have the same <literal>phase</literal> value. When multiple <literal>WasmPlugins</literal> objects are applied to the same workload in the same phase, they will be applied by priority and in descending order. If the <literal>priority</literal> field is not set, or two <literal>WasmPlugins</literal> objects with the same value, the ordering will be determined from the name and namespace of the <literal>WasmPlugins</literal> objects. Defaults to the value <literal>0</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.pluginName</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>The plugin name used in the Envoy configuration. Some Wasm modules might require this value to select the Wasm plugin to execute.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.pluginConfig</simpara></entry>
<entry align="left" valign="top"><simpara>Struct</simpara></entry>
<entry align="left" valign="top"><simpara>The configuration that will be passed on to the plugin.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.pluginConfig.verificationKey</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>The public key used to verify signatures of signed OCI images or Wasm modules. Must be supplied in PEM format.</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>WorkloadSelector</literal> object specifies the criteria used to determine if a filter can be applied to a proxy. The matching criteria includes the metadata associated with a proxy, workload instance information such as labels attached to the pod/VM, or any other information that the proxy provides to Istio during the initial handshake. If multiple conditions are specified, all conditions need to match in order for the workload instance to be selected. Currently, only label based selection mechanism is supported.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>WorkloadSelector</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>matchLabels</simpara></entry>
<entry align="left" valign="top"><simpara>map&lt;string, string&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>One or more labels that indicate a specific set of pods/VMs on which a policy should be applied. The scope of label search is restricted to the configuration namespace in which the resource is present.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>PullPolicy</literal> object specifies the pull behavior to be applied when fetching an OCI image.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>PullPolicy</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>&lt;empty&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Defaults to the value <literal>IfNotPresent</literal>, except for OCI images with tag latest, for which the default will be the value <literal>Always</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IfNotPresent</simpara></entry>
<entry align="left" valign="top"><simpara>If an existing version of the image has been pulled before, that will be used. If no version of the image is present locally, we will pull the latest version.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Always pull the latest version of an image when applying this plugin.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>Struct</literal> represents a structured data value, consisting of fields which map to dynamically typed values. In some languages, Struct might be supported by a native representation. For example, in scripting languages like JavaScript a struct is represented as an object.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Struct</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>fields</simpara></entry>
<entry align="left" valign="top"><simpara>map&lt;string, Value&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Map of dynamically typed values.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>PluginPhase</literal> specifies the phase in the filter chain where the plugin will be injected.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>PluginPhase</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>&lt;empty&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Control plane decides where to insert the plugin. This will generally be at the end of the filter chain, right before the Router. Do not specify PluginPhase if the plugin is independent of others.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AUTHN</simpara></entry>
<entry align="left" valign="top"><simpara>Insert plugin before Istio authentication filters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AUTHZ</simpara></entry>
<entry align="left" valign="top"><simpara>Insert plugin before Istio authorization filters and after Istio authentication filters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>STATS</simpara></entry>
<entry align="left" valign="top"><simpara>Insert plugin before Istio stats filters and after Istio authorization filters.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="ossm-wasmplugin-deploy_ossm-extensions">
<title>Deploying <literal>WasmPlugin</literal> resources</title>
<simpara>You can enable Red Hat OpenShift Service Mesh extensions using the <literal>WasmPlugin</literal> resource. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project. The following example creates an <literal>openid-connect</literal> filter that performs an OpenID Connect flow to authenticate the user.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the following example resource:</simpara>
<formalpara>
<title>Example plugin.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: openid-connect
  namespace: istio-system
spec:
  selector:
    matchLabels:
      istio: ingressgateway
  url: oci://private-registry:5000/openid-connect/openid:latest
  imagePullPolicy: IfNotPresent
  imagePullSecret: private-registry-pull-secret
  phase: AUTHN
  pluginConfig:
    openid_server: authn
    openid_realm: ingress</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply your <literal>plugin.yaml</literal> file with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f plugin.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-extensions-smextension-format_ossm-extensions">
<title><literal>ServiceMeshExtension</literal> container format</title>
<simpara>You must have a <literal>.wasm</literal> file containing the bytecode of your WebAssembly module, and a <literal>manifest.yaml</literal> file in the root of the container filesystem to make your container image a valid extension image.</simpara>
<note>
<simpara>When creating new WebAssembly extensions, use the <literal>WasmPlugin</literal> API. The <literal>ServiceMeshExtension</literal> API was deprecated in Red Hat OpenShift Service Mesh version 2.2 and was removed in Red Hat OpenShift Service Mesh version 2.3.</simpara>
</note>
<formalpara>
<title>manifest.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">schemaVersion: 1

name: &lt;your-extension&gt;
description: &lt;description&gt;
version: 1.0.0
phase: PreAuthZ
priority: 100
module: extension.wasm</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Field Reference for manifest.yml</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>schemaVersion</simpara></entry>
<entry align="left" valign="top"><simpara>Used for versioning of the manifest schema. Currently the only possible value is <literal>1</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>This is a required field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>name</simpara></entry>
<entry align="left" valign="top"><simpara>The name of your extension.</simpara></entry>
<entry align="left" valign="top"><simpara>This field is just metadata and currently unused.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>description</simpara></entry>
<entry align="left" valign="top"><simpara>The description of your extension.</simpara></entry>
<entry align="left" valign="top"><simpara>This field is just metadata and currently unused.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>version</simpara></entry>
<entry align="left" valign="top"><simpara>The version of your extension.</simpara></entry>
<entry align="left" valign="top"><simpara>This field is just metadata and currently unused.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>phase</simpara></entry>
<entry align="left" valign="top"><simpara>The default execution phase of your extension.</simpara></entry>
<entry align="left" valign="top"><simpara>This is a required field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>priority</simpara></entry>
<entry align="left" valign="top"><simpara>The default priority of your extension.</simpara></entry>
<entry align="left" valign="top"><simpara>This is a required field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>module</simpara></entry>
<entry align="left" valign="top"><simpara>The relative path from the container filesystem&#8217;s root to your WebAssembly module.</simpara></entry>
<entry align="left" valign="top"><simpara>This is a required field.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-wasm-ref-smextension_ossm-extensions">
<title>ServiceMeshExtension reference</title>
<simpara>The ServiceMeshExtension API provides a mechanism to extend the functionality provided by the Istio proxy through WebAssembly filters. There are two parts to writing a WebAssembly extension:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Write your extension using an SDK that exposes the proxy-wasm API and compile it to a WebAssembly module.</simpara>
</listitem>
<listitem>
<simpara>Package it into a container.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>When creating new WebAssembly extensions, use the <literal>WasmPlugin</literal> API. The <literal>ServiceMeshExtension</literal> API, which was deprecated in Red Hat OpenShift Service Mesh version 2.2, was removed in Red Hat OpenShift Service Mesh version 2.3.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>ServiceMeshExtension Field Reference</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>metadata.namespace</simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>metadata.namespace</literal> field of a <literal>ServiceMeshExtension</literal> source has a special semantic: if it equals the Control Plane Namespace, the extension will be applied to all workloads in the Service Mesh that match its <literal>workloadSelector</literal> value. When deployed to any other Mesh Namespace, it will only be applied to workloads in that same Namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.workloadSelector</simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>spec.workloadSelector</literal> field has the same semantic as the <literal>spec.selector</literal> field of the <link xlink:href="https://istio.io/v1.6/docs/reference/config/networking/gateway/#Gateway">Istio Gateway resource</link>. It will match a workload based on its Pod labels. If no <literal>workloadSelector</literal> value is specified, the extension will be applied to all workloads in the namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.config</simpara></entry>
<entry align="left" valign="top"><simpara>This is a structured field that will be handed over to the extension, with the semantics dependent on the extension you are deploying.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.image</simpara></entry>
<entry align="left" valign="top"><simpara>A container image URI pointing to the image that holds the extension.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.phase</simpara></entry>
<entry align="left" valign="top"><simpara>The phase determines where in the filter chain the extension is injected, in relation to existing Istio functionality like Authentication, Authorization and metrics generation. Valid values are: PreAuthN, PostAuthN, PreAuthZ, PostAuthZ, PreStats, PostStats. This field defaults to the value set in the <literal>manifest.yaml</literal> file of the extension, but can be overwritten by the user.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>spec.priority</simpara></entry>
<entry align="left" valign="top"><simpara>If multiple extensions with the same <literal>spec.phase</literal> value are applied to the same workload instance, the <literal>spec.priority</literal> value determines the ordering of execution. Extensions with higher priority will be executed first. This allows for inter-dependent extensions. This field defaults to the value set in the <literal>manifest.yaml</literal> file of the extension, but can be overwritten by the user.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="ossm-smextensions-deploy_ossm-extensions">
<title>Deploying <literal>ServiceMeshExtension</literal> resources</title>
<simpara>You can enable Red Hat OpenShift Service Mesh extensions using the <literal>ServiceMeshExtension</literal> resource. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<note>
<simpara>When creating new WebAssembly extensions, use the <literal>WasmPlugin</literal> API. The <literal>ServiceMeshExtension</literal> API was deprecated in Red Hat OpenShift Service Mesh version 2.2 and removed in Red Hat OpenShift Service Mesh version 2.3.</simpara>
</note>
<simpara>For a complete example that was built using the Rust SDK, take a look at the <link xlink:href="https://github.com/maistra/header-append-filter">header-append-filter</link>. It is a simple filter that appends one or more headers to the HTTP responses, with their names and values taken out from the <literal>config</literal> field of the extension. See a sample configuration in the snippet below.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the following example resource:</simpara>
<formalpara>
<title>Example ServiceMeshExtension resource extension.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshExtension
metadata:
  name: header-append
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      app: httpbin
  config:
    first-header: some-value
    another-header: another-value
  image: quay.io/maistra-dev/header-append-filter:2.1
  phase: PostAuthZ
  priority: 100</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply your <literal>extension.yaml</literal> file with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;extension&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-extensions-migration-overview_ossm-extensions">
<title>Migrating from <literal>ServiceMeshExtension</literal> to <literal>WasmPlugin</literal> resources</title>
<simpara>The <literal>ServiceMeshExtension</literal> API, which was deprecated in Red Hat OpenShift Service Mesh version 2.2, was removed in Red Hat OpenShift Service Mesh version 2.3. If you are using the <literal>ServiceMeshExtension</literal> API, you must migrate to the <literal>WasmPlugin</literal> API to continue using your WebAssembly extensions.</simpara>
<simpara>The APIs are very similar. The migration consists of two steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Renaming your plugin file and updating the module packaging.</simpara>
</listitem>
<listitem>
<simpara>Creating a <literal>WasmPlugin</literal> resource that references the updated container image.</simpara>
</listitem>
</orderedlist>
<section xml:id="ossm-extensions-migration-api-changes_ossm-extensions">
<title>API changes</title>
<simpara>The new <literal>WasmPlugin</literal> API is similar to the <literal>ServiceMeshExtension</literal>, but with a few differences, especially in the field names:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Field changes between <literal>ServiceMeshExtensions</literal> and <literal>WasmPlugin</literal></title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">ServiceMeshExtension</entry>
<entry align="left" valign="top">WasmPlugin</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>spec.pluginConfig</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.workloadSelector</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>spec.selector</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.image</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>spec.url</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.phase</literal> valid values: PreAuthN, PostAuthN, PreAuthZ, PostAuthZ, PreStats, PostStats</simpara></entry>
<entry align="left" valign="top"><simpara><literal>spec.phase</literal> valid values: &lt;empty&gt;, AUTHN, AUTHZ, STATS</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following is an example of how a <literal>ServiceMeshExtension</literal> resource could be converted into a <literal>WasmPlugin</literal> resource.</simpara>
<formalpara>
<title>ServiceMeshExtension resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshExtension
metadata:
  name: header-append
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      app: httpbin
  config:
    first-header: some-value
    another-header: another-value
  image: quay.io/maistra-dev/header-append-filter:2.2
  phase: PostAuthZ
  priority: 100</programlisting>
</para>
</formalpara>
<formalpara>
<title>New WasmPlugin resource equivalent to the ServiceMeshExtension above</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: header-append
  namespace: istio-system
spec:
  selector:
    matchLabels:
      app: httpbin
  url: oci://quay.io/maistra-dev/header-append-filter:2.2
  phase: STATS
  pluginConfig:
    first-header: some-value
    another-header: another-value</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-extensions-migration-format-changes_ossm-extensions">
<title>Container image format changes</title>
<simpara>The new <literal>WasmPlugin</literal> container image format is similar to the <literal>ServiceMeshExtensions</literal>, with the following differences:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>ServiceMeshExtension</literal> container format required a metadata file named <literal>manifest.yaml</literal> in the root directory of the container filesystem. The <literal>WasmPlugin</literal> container format does not require a <literal>manifest.yaml</literal> file.</simpara>
</listitem>
<listitem>
<simpara>The <literal>.wasm</literal> file (the actual plugin) that previously could have any filename now must be named <literal>plugin.wasm</literal> and must be located in the root directory of the container filesystem.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-extensions-migrating-to-wasmplugin_ossm-extensions">
<title>Migrating to <literal>WasmPlugin</literal> resources</title>
<simpara>To upgrade your WebAssembly extensions from the <literal>ServiceMeshExtension</literal> API to the <literal>WasmPlugin</literal> API, you rename your plugin file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><literal>ServiceMeshControlPlane</literal> is upgraded to version 2.2 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update your container image. If the plugin is already in <literal>/plugin.wasm</literal> inside the container, skip to the next step.  If not:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure the plugin file is named <literal>plugin.wasm</literal>. You must name the extension file <literal>plugin.wasm</literal>.</simpara>
</listitem>
<listitem>
<simpara>Ensure the plugin file is located in the root (/) directory. You must store extension files in the root of the container filesystem..</simpara>
</listitem>
<listitem>
<simpara>Rebuild your container image and push it to a container registry.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the <literal>ServiceMeshExtension</literal> resource and create a <literal>WasmPlugin</literal> resource that refers to the new container image you built.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-threescale-webassembly-module">
<title>Using the 3scale WebAssembly module</title>

<note>
<simpara>The <literal>threescale-wasm-auth</literal> module runs on integrations of 3scale API Management 2.11 or later with Red Hat OpenShift Service Mesh 2.1.0 or later.</simpara>
</note>
<simpara>The <literal>threescale-wasm-auth</literal> module is a <link xlink:href="https://webassembly.org">WebAssembly</link> module that uses a set of interfaces, known as an application binary interfaces (<emphasis>ABI</emphasis>). This is defined by the <link xlink:href="https://github.com/proxy-wasm/spec"><emphasis>Proxy-WASM</emphasis></link> specification to drive any piece of software that implements the ABI so it can authorize HTTP requests against 3scale.</simpara>
<simpara>As an ABI specification, Proxy-WASM defines the interaction between a piece of software named <emphasis>host</emphasis> and another named <emphasis>module</emphasis>, <emphasis>program</emphasis>, or <emphasis>extension</emphasis>. The host exposes a set of services used by the module to perform a task, and in this case, to process proxy requests.</simpara>
<simpara>The host environment is composed of a WebAssembly virtual machine interacting with a piece of software, in this case, an HTTP proxy.</simpara>
<simpara>The module itself runs in isolation to the outside world except for the instructions it runs on the virtual machine and the ABI specified by Proxy-WASM. This is a safe way to provide extension points to software: the extension can only interact in well-defined ways with the virtual machine and the host. The interaction provides a computing model and a connection to the outside world the proxy is meant to have.</simpara>
<section xml:id="compatibility_ossm-threescale-webassembly-module">
<title>Compatibility</title>
<simpara>The <literal>threescale-wasm-auth</literal> module is designed to be fully compatible with all implementations of the <emphasis>Proxy-WASM ABI</emphasis> specification. At this point, however, it has only been thoroughly tested to work with the <link xlink:href="https://www.envoyproxy.io">Envoy</link> reverse proxy.</simpara>
</section>
<section xml:id="usage-as-a-stand-alone-module_ossm-threescale-webassembly-module">
<title>Usage as a stand-alone module</title>
<simpara>Because of its self-contained design, it is possible to configure this module to work with Proxy-WASM proxies independently of Service Mesh, as well as 3scale Istio adapter deployments.</simpara>
</section>
<section xml:id="prerequisites_ossm-threescale-webassembly-module">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>The module works with all supported 3scale releases, except when configuring a service to use <link xlink:href="../../authentication/identity_providers/configuring-oidc-identity-provider.xml#configuring-oidc-identity-provider">OpenID connect (OIDC)</link>, which requires 3scale 2.11 or later.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-configuring-the-threescale-wasm-auth-module_ossm-threescale-webassembly-module">
<title>Configuring the threescale-wasm-auth module</title>
<simpara>Cluster administrators on OpenShift Container Platform can configure the <literal>threescale-wasm-auth</literal> module to authorize HTTP requests to 3scale API Management through an application binary interface (ABI). The ABI defines the interaction between host and the module, exposing the hosts services, and allows you to use the module to process proxy requests.</simpara>
<section xml:id="the-wasmplugin-api-extension_ossm-threescale-webassembly-module">
<title>The WasmPlugin API extension</title>
<simpara>Service Mesh provides a custom resource definition to specify and apply Proxy-WASM extensions to sidecar proxies, known as <link xlink:href="../../service_mesh/v2x/ossm-extensions.xml#ossm-extensions-wasmplugin-format_ossm-extensions"><literal>WasmPlugin</literal></link>. Service Mesh applies this custom resource to the set of workloads that require HTTP API management with 3scale.</simpara>
<simpara>See <link xlink:href="../../operators/understanding/crds/crd-extending-api-with-crds.xml#crd-extending-api-with-crds">custom resource definition</link> for more information.</simpara>
<note>
<simpara>Configuring the WebAssembly extension is currently a manual process. Support for fetching the configuration for services from the 3scale system will be available in a future release.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Identify a Kubernetes workload and namespace on your Service Mesh deployment that you will apply this module.</simpara>
</listitem>
<listitem>
<simpara>You must have a 3scale tenant account. See <link xlink:href="https://www.3scale.net/signup">SaaS</link> or <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.11/html-single/installing_3scale/index#install-threescale-on-openshift-guide">3scale 2.11 On-Premises</link> with a matching service and relevant applications and metrics defined.</simpara>
</listitem>
<listitem>
<simpara>If you apply the module to the <literal>&lt;product_page&gt;</literal> microservice in the <literal>bookinfo</literal> namespace, see the <link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#ossm-tutorial-bookinfo-overview_deploying-applications-ossm-v1x">Bookinfo sample application</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>The following example is the YAML format for the custom resource for <literal>threescale-wasm-auth</literal> module.
This example refers to the upstream Maistra version of Service Mesh, <literal>WasmPlugin</literal> API. You must declare the namespace where the <literal>threescale-wasm-auth</literal> module is deployed, alongside a <literal>selector</literal> to identify the set of applications the module will apply to:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
  namespace: &lt;bookinfo&gt; <co xml:id="CO21-1"/>
spec:
  selector: <co xml:id="CO21-2"/>
    labels:
      app: &lt;product_page&gt;
  pluginConfig: &lt;yaml_configuration&gt;
  url: oci://registry.redhat.io/3scale-amp2/3scale-auth-wasm-rhel8:0.0.3
  phase: AUTHZ
  priority: 100</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>The <literal>namespace</literal>.</para>
</callout>
<callout arearefs="CO21-2">
<para>The <literal>selector</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <literal>spec.pluginConfig</literal> field depends on the module configuration and it is not populated in the previous example. Instead, the example uses the <literal>&lt;yaml_configuration&gt;</literal> placeholder value. You can use the format of this custom resource example.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>spec.pluginConfig</literal> field varies depending on the application. All other fields persist across multiple instances of this custom resource. As examples:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>url</literal>:  Only changes when newer versions of the module are deployed.</simpara>
</listitem>
<listitem>
<simpara><literal>phase</literal>:  Remains the same, since this module needs to be invoked after the proxy has done any local authorization, such as validating OpenID Connect (OIDC) tokens.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After you have the module configuration in <literal>spec.pluginConfig</literal> and the rest of the custom resource, apply it with the <literal>oc apply</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f threescale-wasm-auth-bookinfo.yaml</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-extensions.xml#ossm-extensions-migration-overview_ossm-extensions">Migrating from <literal>ServiceMeshExtension</literal> to <literal>WasmPlugin</literal> resources</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources">Custom Resources</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-threescale-applying-external-service-entry-objects_ossm-threescale-webassembly-module">
<title>Applying 3scale external ServiceEntry objects</title>
<simpara>To have the <literal>threescale-wasm-auth</literal> module authorize requests against 3scale, the module must have access to 3scale services. You can do this within Red Hat OpenShift Service Mesh by applying an external <literal>ServiceEntry</literal> object and a corresponding <literal>DestinationRule</literal> object for TLS configuration to use the HTTPS protocol.</simpara>
<simpara>The custom resources (CRs) set up the service entries and destination rules for secure access from within Service Mesh to 3scale Hosted (SaaS) for the backend and system components of the Service Management API and the Account Management API. The Service Management API receives queries for the authorization status of each request. The Account Management API provides API management configuration settings for your services.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the following external <literal>ServiceEntry</literal> CR and related <literal>DestinationRule</literal> CR for 3scale Hosted <emphasis role="strong">backend</emphasis> to your cluster:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the <literal>ServiceEntry</literal> CR to a file called <literal>service-entry-threescale-saas-backend.yml</literal>:</simpara>
<formalpara>
<title>ServiceEntry CR</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: service-entry-threescale-saas-backend
spec:
  hosts:
  - su1.3scale.net
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  location: MESH_EXTERNAL
  resolution: DNS</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add the <literal>DestinationRule</literal> CR to a file called <literal>destination-rule-threescale-saas-backend.yml</literal>:</simpara>
<formalpara>
<title>DestinationRule CR</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: destination-rule-threescale-saas-backend
spec:
  host: su1.3scale.net
  trafficPolicy:
    tls:
      mode: SIMPLE
      sni: su1.3scale.net</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply and save the external <literal>ServiceEntry</literal> CR for the 3scale Hosted backend to your cluster, by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f service-entry-threescale-saas-backend.yml</programlisting>
</listitem>
<listitem>
<simpara>Apply and save the external <literal>DestinationRule</literal> CR for the 3scale Hosted backend to your cluster, by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f destination-rule-threescale-saas-backend.yml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Apply the following external <literal>ServiceEntry</literal> CR and related <literal>DestinationRule</literal> CR for 3scale Hosted <emphasis role="strong">system</emphasis> to your cluster:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the <literal>ServiceEntry</literal> CR to a file called <literal>service-entry-threescale-saas-system.yml</literal>:</simpara>
<formalpara>
<title>ServiceEntry CR</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: service-entry-threescale-saas-system
spec:
  hosts:
  - multitenant.3scale.net
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  location: MESH_EXTERNAL
  resolution: DNS</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add the <literal>DestinationRule</literal> CR to a file called <literal>destination-rule-threescale-saas-system.yml</literal>:</simpara>
<formalpara>
<title>DestinationRule CR</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: destination-rule-threescale-saas-system
spec:
  host: multitenant.3scale.net
  trafficPolicy:
    tls:
      mode: SIMPLE
      sni: multitenant.3scale.net</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply and save the external <literal>ServiceEntry</literal> CR for the 3scale Hosted system to your cluster, by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f service-entry-threescale-saas-system.yml</programlisting>
</listitem>
<listitem>
<simpara>Apply and save the external <literal>DestinationRule</literal> CR for the 3scale Hosted system to your cluster, by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;destination-rule-threescale-saas-system.yml&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>Alternatively, you can deploy an in-mesh 3scale service. To deploy an in-mesh 3scale service, change the location of the services in the CR by deploying 3scale and linking to the deployment.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-traffic-manage.xml#ossm-routing-service-entries_traffic-management">Service entry and destination rule documentation</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-webassembly-module-configuration_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module configuration</title>
<simpara>The <literal>WasmPlugin</literal> custom resource spec provides the configuration that the <literal>Proxy-WASM</literal> module reads from.</simpara>
<simpara>The spec is embedded in the host and read by the <literal>Proxy-WASM</literal> module. Typically, the configurations are in the JSON file format for the modules to parse, however the <literal>WasmPlugin</literal> resource can interpret the spec value as YAML and convert it to JSON for consumption by the module.</simpara>
<simpara>If you use the <literal>Proxy-WASM</literal> module in stand-alone mode, you must write the configuration using the JSON format. Using the JSON format means using escaping and quoting where needed within the <literal>host</literal> configuration files, for example <literal>Envoy</literal>. When you use the WebAssembly module with the <literal>WasmPlugin</literal> resource, the configuration is in the YAML format. In this case, an invalid configuration forces the module to show diagnostics based on its JSON representation to a sidecar&#8217;s logging stream.</simpara>
<important>
<simpara>The <literal>EnvoyFilter</literal> custom resource is not a supported API, although it can be used in some 3scale Istio adapter or Service Mesh releases. Using the <literal>EnvoyFilter</literal> custom resource is not recommended. Use the <literal>WasmPlugin</literal> API instead of the <literal>EnvoyFilter</literal> custom resource.
If you must use the <literal>EnvoyFilter</literal> custom resource, you must specify the spec in JSON format.</simpara>
</important>
<section xml:id="threescale-configuring-the-threescale-webassembly-module_ossm-threescale-webassembly-module">
<title>Configuring the 3scale WebAssembly module</title>
<simpara>The architecture of the 3scale WebAssembly module configuration depends on the 3scale account and authorization service, and the list of services to handle.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>The prerequisites are a set of minimum mandatory fields in all cases:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>For the 3scale account and authorization service: the <literal>backend-listener</literal> URL.</simpara>
</listitem>
<listitem>
<simpara>For the list of services to handle: the service IDs and at least one credential look up method and where to find it.</simpara>
</listitem>
<listitem>
<simpara>You will find examples for dealing with <literal>userkey</literal>, <literal>appid</literal> with <literal>appkey</literal>, and OpenID Connect (OIDC) patterns.</simpara>
</listitem>
<listitem>
<simpara>The WebAssembly module uses the settings you specified in the static configuration. For example, if you add a mapping rule configuration to the module, it will always apply, even when the 3scale Admin Portal has no such mapping rule. The rest of the <literal>WasmPlugin</literal> resource exists around the <literal>spec.pluginConfig</literal> YAML entry.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-webassembly-module-api-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module api object</title>
<simpara>The <literal>api</literal> top-level string from the 3scale WebAssembly module defines which version of the configuration the module will use.</simpara>
<note>
<simpara>A non-existent or unsupported version of the <literal>api</literal> object renders the 3scale WebAssembly module inoperable.</simpara>
</note>
<formalpara>
<title>The <literal>api</literal> top-level string example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
  namespace: &lt;bookinfo&gt;
spec:
  pluginConfig:
    api: v1
...</programlisting>
</para>
</formalpara>
<simpara>The <literal>api</literal> entry defines the rest of the values for the configuration. The only accepted value is <literal>v1</literal>. New settings that break compatibility with the current configuration or need more logic that modules using <literal>v1</literal> cannot handle, will require different values.</simpara>
</section>
<section xml:id="ossm-threescale-webassembly-module-system-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module system object</title>
<simpara>The <literal>system</literal> top-level object specifies how to access the 3scale Account Management API for a specific account. The <literal>upstream</literal> field is the most important part of the object. The <literal>system</literal> object is optional, but recommended unless you are providing a fully static configuration for the 3scale WebAssembly module, which is an option if you do not want to provide connectivity to the <emphasis>system</emphasis> component of 3scale.</simpara>
<simpara>When you provide static configuration objects in addition to the <literal>system</literal> object, the static ones always take precedence.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    system:
      name: &lt;saas_porta&gt;
      upstream: &lt;object&gt;
      token: &lt;my_account_token&gt;
      ttl: 300
  ...</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title><literal>system</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An identifier for the 3scale service, currently not referenced elsewhere.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>upstream</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The details about a network host to be contacted. <literal>upstream</literal> refers to the 3scale Account Management API host known as system.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>token</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A 3scale personal access token with read permissions.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ttl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum amount of seconds to consider a configuration retrieved from this host as valid before trying to fetch new changes. The default is 600 seconds (10 minutes). <emphasis role="strong">Note:</emphasis> there is no maximum amount, but the module will generally fetch any configuration within a reasonable amount of time after this TTL elapses.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-threescale-webassembly-module-upstream-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module upstream object</title>
<simpara>The <literal>upstream</literal> object describes an external host to which the proxy can perform calls.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
upstream:
  name: outbound|443||multitenant.3scale.net
  url: "https://myaccount-admin.3scale.net/"
  timeout: 5000
...</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title><literal>upstream</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>name</literal> is not a free-form identifier. It is the identifier for the external host as defined by the proxy configuration. In the case of stand-alone <literal>Envoy</literal> configurations, it maps to the name of a <link xlink:href="https://www.envoyproxy.io/docs/envoy/v1.19.0/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster">Cluster</link>, also known as <literal>upstream</literal> in other proxies. <emphasis role="strong">Note:</emphasis> the value of this field, because the Service Mesh and 3scale Istio adapter control plane configure the name according to a format using a vertical bar (|) as the separator of multiple fields. For the purposes of this integration, always use the format: <literal>outbound|&lt;port&gt;||&lt;hostname&gt;</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The complete URL to access the described service. Unless implied by the scheme, you must include the TCP port.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Timeout in milliseconds so that connections to this service that take more than the amount of time to respond will be considered errors. Default is 1000 seconds.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-threescale-webassembly-module-backend-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module backend object</title>
<simpara>The <literal>backend</literal> top-level object specifies how to access the 3scale Service Management API for authorizing and reporting HTTP requests. This service is provided by the <emphasis>Backend</emphasis> component of 3scale.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    ...
    backend:
      name: backend
      upstream: &lt;object&gt;
    ...</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title><literal>backend</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An identifier for the 3scale backend, currently not referenced elsewhere.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>upstream</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The details about a network host to be contacted. This must refer to the 3scale Account Management API host, known, system.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes. The most important and required field.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-threescale-webassembly-module-services-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module services object</title>
<simpara>The <literal>services</literal> top-level object specifies which service identifiers are handled by this particular instance of the <literal>module</literal>.</simpara>
<simpara>Since accounts have multiple services, you must specify which ones are handled. The rest of the configuration revolves around how to configure services.</simpara>
<simpara>The <literal>services</literal> field is required. It is an array that must contain at least one service to be useful.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    ...
    services:
    - id: "2555417834789"
      token: service_token
      authorities:
        - "*.app"
        - 0.0.0.0
        - "0.0.0.0:8443"
      credentials: &lt;object&gt;
      mapping_rules: &lt;object&gt;
    ...</programlisting>
<simpara>Each element in the <literal>services</literal> array represents a 3scale service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>services</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ID</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An identifier for this 3scale service, currently not referenced elsewhere.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>token</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This <literal>token</literal> can be found in the proxy configuration for your service in System or you can retrieve the it from System with following <literal>curl</literal> command:</simpara>
<simpara><literal>curl https://&lt;system_host&gt;/admin/api/services/&lt;service_id&gt;/proxy/configs/production/latest.json?access_token=&lt;access_token&gt;" | jq '.proxy_config.content.backend_authentication_value</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>authorities</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An array of strings, each one representing the <emphasis>Authority</emphasis> of a <emphasis>URL</emphasis> to match. These strings accept glob patterns supporting the asterisk (<emphasis>*</emphasis>), plus sign (<emphasis>+</emphasis>), and question mark (<emphasis>?</emphasis>) matchers.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>credentials</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An object defining which kind of credentials to look for and where.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mapping_rules</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An array of objects representing mapping rules and 3scale methods to hit.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-threescale-webassembly-module-credentials-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module credentials object</title>
<simpara>The <literal>credentials</literal> object is a component of the <literal>service</literal> object. <literal>credentials</literal> specifies which kind of credentials to be looked up and the steps to perform this action.</simpara>
<simpara>All fields are optional, but you must specify at least one, <literal>user_key</literal> or <literal>app_id</literal>. The order in which you specify each credential is irrelevant because it is pre-established by the module. Only specify one instance of each credential.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    ...
    services:
    - credentials:
        user_key: &lt;array_of_lookup_queries&gt;
        app_id: &lt;array_of_lookup_queries&gt;
        app_key: &lt;array_of_lookup_queries&gt;
    ...</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title><literal>credentials</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>user_key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an array of lookup queries that defines a 3scale user key. A user key is commonly known as an API key.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>app_id</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an array of lookup queries that define a 3scale application identifier. Application identifiers are provided by 3scale or by using an identity provider like <link xlink:href="https://access.redhat.com/products/red-hat-single-sign-on">Red Hat Single Sign-On (RH-SS0)</link>, or OpenID Connect (OIDC). The resolution of the lookup queries specified here, whenever it is successful and resolves to two values, it sets up the <literal>app_id</literal> and the <literal>app_key</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>app_key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an array of lookup queries that define a 3scale application key. Application keys without a resolved <literal>app_id</literal> are useless, so only specify this field when <literal>app_id</literal> has been specified.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-threescale-webassembly-module-lookup-queries_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module lookup queries</title>
<simpara>The <literal>lookup query</literal> object is part of any of the fields in the <literal>credentials</literal> object. It specifies how a given credential field should be found and processed. When evaluated, a successful resolution means that one or more values were found. A failed resolution means that no values were found.</simpara>
<simpara>Arrays of <literal>lookup queries</literal> describe a short-circuit or relationship: a successful resolution of one of the queries stops the evaluation of any remaining queries and assigns the value or values to the specified credential-type. Each query in the array is independent of each other.</simpara>
<simpara>A <literal>lookup query</literal> is made up of a single field, a source object, which can be one of a number of source types. See the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    ...
    services:
    - credentials:
        user_key:
          - &lt;source_type&gt;: &lt;object&gt;
          - &lt;source_type&gt;: &lt;object&gt;
          ...
        app_id:
          - &lt;source_type&gt;: &lt;object&gt;
          ...
        app_key:
          - &lt;source_type&gt;: &lt;object&gt;
          ...
    ...</programlisting>
</section>
<section xml:id="ossm-threescale-webassembly-module-source-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module source object</title>
<simpara>A <literal>source</literal> object exists as part of an array of sources within any of the <literal>credentials</literal> object fields. The object field name, referred to as a <literal>source</literal>-type is any one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>header</literal>: The lookup query receives HTTP request headers as input.</simpara>
</listitem>
<listitem>
<simpara><literal>query_string</literal>: The <literal>lookup query</literal> receives the URL query string parameters as input.</simpara>
</listitem>
<listitem>
<simpara><literal>filter</literal>: The <literal>lookup query</literal> receives filter metadata as input.</simpara>
</listitem>
</itemizedlist>
<simpara>All <literal>source</literal>-type objects have at least the following two fields:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>source</literal>-type object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>keys</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An array of strings, each one a <literal>key</literal>, referring to entries found in the input data.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ops</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An array of <literal>operations</literal> that perform a <literal>key</literal> entry match. The array is a pipeline where operations receive inputs and generate outputs on the next operation. An <literal>operation</literal> failing to provide an output resolves the <literal>lookup query</literal> as failed. The pipeline order of the operations determines the evaluation order.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>filter</literal> field name has a required <literal>path</literal> entry to show the path in the metadata you use to look up data.</simpara>
<simpara>When a <literal>key</literal> matches the input data, the rest of the keys are not evaluated and the source resolution algorithm jumps to executing the <literal>operations</literal> (<literal>ops</literal>) specified, if any. If no <literal>ops</literal> are specified, the result value of the matching <literal>key</literal>, if any, is returned.</simpara>
<simpara><literal>Operations</literal> provide a way to specify certain conditions and transformations for inputs you have after the first phase looks up a <literal>key</literal>. Use <literal>operations</literal> when you need to transform, decode, and assert properties, however they do not provide a mature language to deal with all needs and lack <emphasis>Turing-completeness</emphasis>.</simpara>
<simpara>A stack stored the outputs of <literal>operations</literal>. When evaluated, the <literal>lookup query</literal> finishes by assigning the value or values at the bottom of the stack, depending on how many values the credential consumes.</simpara>
</section>
<section xml:id="ossm-threescale-webassembly-module-operations-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module operations object</title>
<simpara>Each element in the <literal>ops</literal> array belonging to a specific <literal>source type</literal> is an <literal>operation</literal> object that either applies transformations to values or performs tests. The field name to use for such an object is the name of the <literal>operation</literal> itself, and any values are the parameters to the <literal>operation</literal>, which could be structure objects, for example, maps with fields and values, lists, or strings.</simpara>
<simpara>Most <literal>operations</literal> attend to one or more inputs, and produce one or more outputs. When they consume inputs or produce outputs, they work with a stack of values: each value consumed by the operations is popped from the stack of values and initially populated with any <literal>source</literal> matches. The values outputted by them are pushed to the stack. Other <literal>operations</literal> do not consume or produce outputs other than asserting certain properties, but they inspect a stack of values.</simpara>
<note>
<simpara>When resolution finishes, the values picked up by the next step, such as assigning the values to be an <literal>app_id</literal>, <literal>app_key</literal>, or <literal>user_key</literal>, are taken from the bottom values of the stack.</simpara>
</note>
<simpara>There are a few different <literal>operations</literal> categories:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>decode</literal>: These transform an input value by decoding it to get a different format.</simpara>
</listitem>
<listitem>
<simpara><literal>string</literal>: These take a string value as input and perform transformations and checks on it.</simpara>
</listitem>
<listitem>
<simpara><literal>stack</literal>: These take a set of values in the input and perform multiple stack transformations and selection of specific positions in the stack.</simpara>
</listitem>
<listitem>
<simpara><literal>check</literal>: These assert properties about sets of operations in a side-effect free way.</simpara>
</listitem>
<listitem>
<simpara><literal>control</literal>: These perform operations that allow for modifying the evaluation flow.</simpara>
</listitem>
<listitem>
<simpara><literal>format</literal>: These parse the format-specific structure of input values and look up values in it.</simpara>
</listitem>
</itemizedlist>
<simpara>All operations are specified by the name identifiers as strings.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>Available <link xlink:href="https://github.com/3scale/threescale-wasm-auth/blob/main/docs/operations.md">operations</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-webassembly-module-mapping-rules-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module mapping_rules object</title>
<simpara>The <literal>mapping_rules</literal> object is part of the <literal>service</literal> object. It specifies a set of REST path patterns and related 3scale metrics and count increments to use when the patterns match.</simpara>
<simpara>You need the value if no dynamic configuration is provided in the <literal>system</literal> top-level object. If the object is provided in addition to the <literal>system</literal> top-level entry, then the <literal>mapping_rules</literal> object is evaluated first.</simpara>
<simpara><literal>mapping_rules</literal> is an array object. Each element of that array is a <literal>mapping_rule</literal> object. The evaluated matching mapping rules on an incoming request provide the set of 3scale <literal>methods</literal> for authorization and reporting to the <emphasis>APIManager</emphasis>. When multiple matching rules refer to the same <literal>methods</literal>, there is a summation of <literal>deltas</literal> when calling into 3scale. For example, if two rules increase the <emphasis>Hits</emphasis> method twice with <literal>deltas</literal> of 1 and 3, a single method entry for Hits reporting to 3scale has a <literal>delta</literal> of 4.</simpara>
</section>
<section xml:id="ossm-threescale-webassembly-module-mapping-rule-object_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module mapping_rule object</title>
<simpara>The <literal>mapping_rule</literal> object is part of an array in the <literal>mapping_rules</literal> object.</simpara>
<simpara>The <literal>mapping_rule</literal> object fields specify the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>HTTP request method</emphasis> to match.</simpara>
</listitem>
<listitem>
<simpara>A pattern to match the path against.</simpara>
</listitem>
<listitem>
<simpara>The 3scale methods to report along with the amount to report. The order in which you specify the fields determines the evaluation order.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title><literal>mapping_rule</literal> object fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>method</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a string representing an HTTP request method, also known as verb. Values accepted match the any one of the accepted HTTP method names, case-insensitive. A special value of any matches any method.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pattern</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pattern to match the HTTP request&#8217;s URI path component. This pattern follows the same syntax as documented by 3scale. It allows wildcards (use of the asterisk (*) character) using any sequence of characters between braces such as <literal>{this}</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>usages</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of <literal>usage</literal> objects. When the rule matches, all methods with their <literal>deltas</literal> are added to the list of methods sent to 3scale for authorization and reporting.</simpara>
<simpara>Embed the <literal>usages</literal> object with the following required fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>name</literal>: The <literal>method</literal> system name to report.</simpara>
</listitem>
<listitem>
<simpara><literal>delta</literal>: For how much to increase that <literal>method</literal> by.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>last</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the successful matching of this rule should stop the evaluation of more mapping rules.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional Boolean. The default is <literal>false</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following example is independent of existing hierarchies between methods in 3scale. That is, anything run on the 3scale side will not affect this. For example, the <emphasis>Hits</emphasis> metric might be a parent of them all, so it stores 4 hits due to the sum of all reported methods in the authorized request and calls the 3scale <literal>Authrep</literal> API endpoint.</simpara>
<simpara>The example below uses a <literal>GET</literal> request to a path, <literal>/products/1/sold</literal>, that matches all the rules.</simpara>
<formalpara>
<title><literal>mapping_rules</literal> <literal>GET</literal> request example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  pluginConfig:
    ...
    mapping_rules:
      - method: GET
        pattern: /
        usages:
          - name: hits
            delta: 1
      - method: GET
        pattern: /products/
        usages:
          - name: products
            delta: 1
      - method: ANY
        pattern: /products/{id}/sold
        usages:
          - name: sales
            delta: 1
          - name: products
            delta: 1
    ...</programlisting>
</para>
</formalpara>
<simpara>All <literal>usages</literal> get added to the request the module performs to 3scale with usage data as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>Hits: 1</simpara>
</listitem>
<listitem>
<simpara>products: 2</simpara>
</listitem>
<listitem>
<simpara>sales: 1</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-threescale-webassembly-module-examples-for-credentials-use-cases_ossm-threescale-webassembly-module">
<title>The 3scale WebAssembly module examples for credentials use cases</title>
<simpara>You will spend most of your time applying configuration steps to obtain credentials in the requests to your services.</simpara>
<simpara>The following are <literal>credentials</literal> examples, which you can modify to adapt to specific use cases.</simpara>
<simpara>You can combine them all, although when you specify multiple source objects with their own <literal>lookup queries</literal>, they are evaluated in order until one of them successfully resolves.</simpara>
<section xml:id="api-key-in-query-string-parameters_ossm-threescale-webassembly-module">
<title>API key (user_key) in query string parameters</title>
<simpara>The following example looks up a <literal>user_key</literal> in a query string parameter or header of the same name:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  user_key:
    - query_string:
        keys:
          - user_key
    - header:
        keys:
          - user_key</programlisting>
</section>
<section xml:id="application-id-and-key_ossm-threescale-webassembly-module">
<title>Application ID and key</title>
<simpara>The following example looks up <literal>app_key</literal> and <literal>app_id</literal> credentials in a query or headers.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  app_id:
    - header:
        keys:
          - app_id
    - query_string:
        keys:
          - app_id
  app_key:
    - header:
        keys:
          - app_key
    - query_string:
        keys:
          - app_key</programlisting>
</section>
<section xml:id="authorization-header_ossm-threescale-webassembly-module">
<title>Authorization header</title>
<simpara>A request includes an <literal>app_id</literal> and <literal>app_key</literal> in an <literal>authorization</literal> header. If there is at least one or two values outputted at the end, then you can assign the <literal>app_key</literal>.</simpara>
<simpara>The resolution here assigns the <literal>app_key</literal> if there is one or two outputted at the end.</simpara>
<simpara>The <literal>authorization</literal> header specifies a value with the type of authorization and its value is encoded as <literal>Base64</literal>. This means you can split the value by a space character, take the second output and then split it again using a colon (:) as the separator. For example, if you use this format <literal>app_id:app_key</literal>, the header looks like the following example for <literal>credential</literal>:</simpara>
<screen>aladdin:opensesame:  Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l</screen>
<simpara>You must use lower case header field names as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  app_id:
    - header:
        keys:
          - authorization
        ops:
          - split:
              separator: " "
              max: 2
          - length:
              min: 2
          - drop:
              head: 1
          - base64_urlsafe
          - split:
              max: 2
  app_key:
    - header:
        keys:
          - app_key</programlisting>
<simpara>The previous example use case looks at the headers for an <literal>authorization</literal>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>It takes its string value and split it by a space, checking that it generates at least two values of a <literal>credential</literal>-type and the <literal>credential</literal> itself, then dropping the <literal>credential</literal>-type.</simpara>
</listitem>
<listitem>
<simpara>It then decodes the second value containing the data it needs, and splits it by using a colon (:) character to have an operations stack including first the <literal>app_id</literal>, then the <literal>app_key</literal>, if it exists.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If <literal>app_key</literal> does not exist in the authorization header then its specific sources are checked, for example, the header with the key <literal>app_key</literal> in this case.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To add extra conditions to <literal>credentials</literal>, allow <literal>Basic</literal> authorizations, where <literal>app_id</literal> is either <literal>aladdin</literal> or <literal>admin</literal>, or any <literal>app_id</literal> being at least 8 characters in length.</simpara>
</listitem>
<listitem>
<simpara><literal>app_key</literal> must contain a value and have a minimum of 64 characters as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  app_id:
    - header:
        keys:
          - authorization
        ops:
          - split:
              separator: " "
              max: 2
          - length:
              min: 2
          - reverse
          - glob:
            - Basic
          - drop:
              tail: 1
          - base64_urlsafe
          - split:
              max: 2
          - test:
              if:
                length:
                  min: 2
              then:
                - strlen:
                    max: 63
                - or:
                    - strlen:
                        min: 1
                    - drop:
                        tail: 1
          - assert:
            - and:
              - reverse
              - or:
                - strlen:
                    min: 8
                - glob:
                  - aladdin
                  - admin</programlisting>
</listitem>
<listitem>
<simpara>After picking up the <literal>authorization</literal> header value, you get a <literal>Basic</literal> <literal>credential</literal>-type by reversing the stack so that the type is placed on top.</simpara>
</listitem>
<listitem>
<simpara>Run a glob match on it. When it validates, and the credential is decoded and split, you get the <literal>app_id</literal> at the bottom of the stack, and potentially the <literal>app_key</literal> at the top.</simpara>
</listitem>
<listitem>
<simpara>Run a <literal>test:</literal> if there are two values in the stack, meaning an <literal>app_key</literal> was acquired.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure the string length is between 1 and 63, including <literal>app_id</literal> and <literal>app_key</literal>. If the key&#8217;s length is zero, drop it and continue as if no key exists. If there was only an <literal>app_id</literal> and no <literal>app_key</literal>, the missing else branch indicates a successful test and evaluation continues.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>The last operation, <literal>assert</literal>, indicates that no side-effects make it into the stack. You can then modify the stack:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Reverse the stack to have the <literal>app_id</literal> at the top.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Whether or not an <literal>app_key</literal> is present, reversing the stack ensures <literal>app_id</literal> is at the top.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Use <literal>and</literal> to preserve the contents of the stack across tests.</simpara>
<simpara>Then use one of the following possibilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Make sure <literal>app_id</literal> has a string length of at least 8.</simpara>
</listitem>
<listitem>
<simpara>Make sure <literal>app_id</literal> matches either <literal>aladdin</literal> or <literal>admin</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="openid-connect-use-case_ossm-threescale-webassembly-module">
<title>OpenID Connect (OIDC) use case</title>
<simpara>For Service Mesh and the 3scale Istio adapter, you must deploy a <literal>RequestAuthentication</literal> as shown in the following example, filling in your own workload data and <literal>jwtRules</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-example
  namespace: bookinfo
spec:
  selector:
    matchLabels:
      app: productpage
  jwtRules:
  - issuer: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak
    jwksUri: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak/protocol/openid-connect/certs</programlisting>
<simpara>When you apply the <literal>RequestAuthentication</literal>, it configures <literal>Envoy</literal> with a <link xlink:href="https://www.envoyproxy.io/docs/envoy/v1.19.0/api-v3/extensions/filters/http/jwt_authn/v3/config.proto.html">native plugin</link> to validate <literal>JWT</literal> tokens. The proxy validates everything before running the module so any requests that fail do not make it to the 3scale WebAssembly module.</simpara>
<simpara>When a <literal>JWT</literal> token is validated, the proxy stores its contents in an internal metadata object, with an entry whose key depends on the specific configuration of the plugin. This use case gives you the ability to look up structure objects with a single entry containing an unknown key name.</simpara>
<simpara>The 3scale <literal>app_id</literal> for OIDC matches the OAuth <literal>client_id</literal>. This is found in the <literal>azp</literal> or <literal>aud</literal> fields of <literal>JWT</literal> tokens.</simpara>
<simpara>To get <literal>app_id</literal> field from Envoy&#8217;s native <literal>JWT</literal> authentication filter, see the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  app_id:
    - filter:
        path:
          - envoy.filters.http.jwt_authn
          - "0"
        keys:
          - azp
          - aud
        ops:
          - take:
              head: 1</programlisting>
<simpara>The example instructs the module to use the <literal>filter</literal> source type to look up filter metadata for an object from the <literal>Envoy</literal>-specific <literal>JWT</literal> authentication native plugin. This plugin includes the <literal>JWT</literal> token as part of a structure object with a single entry and a preconfigured name. Use <literal>0</literal> to specify that you will only access the single entry.</simpara>
<simpara>The resulting value is a structure for which you will resolve two fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>azp</literal>: The value where <literal>app_id</literal> is found.</simpara>
</listitem>
<listitem>
<simpara><literal>aud</literal>: The value where this information can also be found.</simpara>
</listitem>
</itemizedlist>
<simpara>The operation ensures only one value is held for assignment.</simpara>
</section>
<section xml:id="picking-up-the-jwt-token-from-a-header_ossm-threescale-webassembly-module">
<title>Picking up the JWT token from a header</title>
<simpara>Some setups might have validation processes for <literal>JWT</literal> tokens where the validated token would reach this module via a header in JSON format.</simpara>
<simpara>To get the <literal>app_id</literal>, see the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">credentials:
  app_id:
    - header:
        keys:
          - x-jwt-payload
        ops:
          - base64_urlsafe
          - json:
            - keys:
              - azp
              - aud
          - take:
              head: 1</programlisting>
</section>
</section>
<section xml:id="ossm-threescale-webassembly-module-minimal-working-configuration_ossm-threescale-webassembly-module">
<title>3scale WebAssembly module minimal working configuration</title>
<simpara>The following is an example of a 3scale WebAssembly module minimal working configuration. You can copy and paste this and edit it to work with your own configuration.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: extensions.istio.io/v1alpha1
kind: WasmPlugin
metadata:
  name: &lt;threescale_wasm_plugin_name&gt;
spec:
  url: oci://registry.redhat.io/3scale-amp2/3scale-auth-wasm-rhel8:0.0.3
  imagePullSecret: &lt;optional_pull_secret_resource&gt;
  phase: AUTHZ
  priority: 100
  selector:
    labels:
      app: &lt;product_page&gt;
  pluginConfig:
    api: v1
    system:
      name: &lt;system_name&gt;
      upstream:
        name: outbound|443||multitenant.3scale.net
        url: https://istiodevel-admin.3scale.net/
        timeout: 5000
      token: &lt;token&gt;
    backend:
      name: &lt;backend_name&gt;
      upstream:
        name: outbound|443||su1.3scale.net
        url: https://su1.3scale.net/
        timeout: 5000
      extensions:
      - no_body
    services:
    - id: '2555417834780'
      authorities:
      - "*"
      credentials:
        user_key:
          - query_string:
              keys:
                - &lt;user_key&gt;
          - header:
              keys:
                - &lt;user_key&gt;
        app_id:
          - query_string:
              keys:
                - &lt;app_id&gt;
          - header:
              keys:
                - &lt;app_id&gt;
        app_key:
          - query_string:
              keys:
                - &lt;app_key&gt;
          - header:
              keys:
                - &lt;app_key&gt;</programlisting>
</section>
</section>
<section xml:id="threescale-adapter">
<title>Using the 3scale Istio adapter</title>

<simpara>The 3scale Istio Adapter is an optional adapter that allows you to label a service running within the Red Hat OpenShift Service Mesh and integrate that service with the 3scale API Management solution.
It is not required for Red Hat OpenShift Service Mesh.</simpara>
<important>
<simpara>You can only use the 3scale Istio adapter with Red Hat OpenShift Service Mesh versions 2.0 and below. The Mixer component was deprecated in release 2.0 and removed in release 2.1. For Red Hat OpenShift Service Mesh versions 2.1.0 and later you should use the <link xlink:href="../../service_mesh/v2x/ossm-threescale-webassembly-module.xml#ossm-threescale-webassembly-module">3scale WebAssembly module</link>.</simpara>
<simpara>If you want to enable 3scale backend cache with the 3scale Istio adapter, you must also enable Mixer policy and Mixer telemetry. See <link xlink:href="../../service_mesh/v2x/ossm-create-smcp.xml#ossm-create-smcp">Deploying the Red Hat OpenShift Service Mesh control plane</link>.</simpara>
</important>
<section xml:id="ossm-threescale-integrate_threescale-adapter">
<title>Integrate the 3scale adapter with Red Hat OpenShift Service Mesh</title>
<simpara>You can use these examples to configure requests to your services using the 3scale Istio Adapter.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>Red Hat OpenShift Service Mesh version 2.x</simpara>
</listitem>
<listitem>
<simpara>A working 3scale account (<link xlink:href="https://www.3scale.net/signup/">SaaS</link> or <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.9/html/installing_3scale/install-threescale-on-openshift-guide">3scale 2.9 On-Premises</link>)</simpara>
</listitem>
<listitem>
<simpara>Enabling backend cache requires 3scale 2.9 or greater</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh prerequisites</simpara>
</listitem>
<listitem>
<simpara>Ensure Mixer policy enforcement is enabled. Update Mixer policy enforcement section provides instructions to check the current Mixer policy enforcement status and enable policy enforcement.</simpara>
</listitem>
<listitem>
<simpara>Mixer policy and telemetry must be enabled if you are using a mixer plugin.</simpara>
<itemizedlist>
<listitem>
<simpara>You will need to properly configure the Service Mesh Control Plane (SMCP) when upgrading.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>To configure the 3scale Istio Adapter, refer to Red Hat OpenShift Service Mesh custom resources for instructions on adding adapter parameters to the custom resource file.</simpara>
</note>
<note>
<simpara>Pay particular attention to the <literal>kind: handler</literal> resource. You must update this with your 3scale account credentials. You can optionally add a <literal>service_id</literal> to a handler, but this is kept for backwards compatibility only, since it would render the handler only useful for one service in your 3scale account. If you add <literal>service_id</literal> to a handler, enabling 3scale for other services requires you to create more handlers with different <literal>service_ids</literal>.</simpara>
</note>
<simpara>Use a single handler per 3scale account by following the steps below:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a handler for your 3scale account and specify your account credentials. Omit any service identifier.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: "config.istio.io/v1alpha2"
  kind: handler
  metadata:
   name: threescale
  spec:
   adapter: threescale
   params:
     system_url: "https://&lt;organization&gt;-admin.3scale.net/"
     access_token: "&lt;ACCESS_TOKEN&gt;"
   connection:
     address: "threescale-istio-adapter:3333"</programlisting>
<simpara>Optionally, you can provide a <literal>backend_url</literal> field within the <emphasis>params</emphasis> section to override the URL provided by the 3scale configuration. This may be useful if the adapter runs on the same cluster as the 3scale on-premise instance, and you wish to leverage the internal cluster DNS.</simpara>
</listitem>
<listitem>
<simpara>Edit or patch the Deployment resource of any services belonging to your 3scale account as follows:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the <literal>"service-mesh.3scale.net/service-id"</literal> label with a value corresponding to a valid <literal>service_id</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>"service-mesh.3scale.net/credentials"</literal> label with its value being the <emphasis>name of the handler resource</emphasis> from step 1.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Do step 2 to link it to your 3scale account credentials and to its service identifier, whenever you intend to add more services.</simpara>
</listitem>
<listitem>
<simpara>Modify the rule configuration with your 3scale configuration to dispatch the rule to the threescale handler.</simpara>
<formalpara>
<title>Rule configuration example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: "config.istio.io/v1alpha2"
  kind: rule
  metadata:
    name: threescale
  spec:
    match: destination.labels["service-mesh.3scale.net"] == "true"
    actions:
      - handler: threescale.handler
        instances:
          - threescale-authorization.instance</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="ossm-threescale-cr_threescale-adapter">
<title>Generating 3scale custom resources</title>
<simpara>The adapter includes a tool that allows you to generate the <literal>handler</literal>, <literal>instance</literal>, and <literal>rule</literal> custom resources.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Usage</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h, --help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Produces help output for available options</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unique name for this URL, token pair</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n, --namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Namespace to generate templates</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>istio-system</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-t, --token</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale access token</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-u, --url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale Admin Portal URL</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--backend-url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale backend URL. If set, it overrides the value that is read from system configuration</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-s, --service</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale API/Service ID</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--auth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale authentication pattern to specify (1=API Key, 2=App Id/App Key, 3=OIDC)</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Hybrid</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-o, --output</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File to save produced manifests to</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Standard output</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Outputs the CLI version and exits immediately</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="ossm-threescale-templates_threescale-adapter">
<title>Generate templates from URL examples</title>
<note>
<itemizedlist>
<listitem>
<simpara>Run the following commands via <literal>oc exec</literal> from the 3scale adapter container image in <link linkend="ossm-threescale-manifests_threescale-adapter">Generating manifests from a deployed adapter</link>.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>3scale-config-gen</literal> command to help avoid YAML syntax and indentation errors.</simpara>
</listitem>
<listitem>
<simpara>You can omit the <literal>--service</literal> if you use the annotations.</simpara>
</listitem>
<listitem>
<simpara>This command must be invoked from within the container image via <literal>oc exec</literal>.</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>3scale-config-gen</literal> command to autogenerate templates files allowing the token, URL pair to be shared by multiple services as a single handler:</simpara>
<screen>$ 3scale-config-gen --name=admin-credentials --url="https://&lt;organization&gt;-admin.3scale.net:443" --token="[redacted]"</screen>
</listitem>
<listitem>
<simpara>The following example generates the templates with the service ID embedded in the handler:</simpara>
<screen>$ 3scale-config-gen --url="https://&lt;organization&gt;-admin.3scale.net" --name="my-unique-id" --service="123456789" --token="[redacted]"</screen>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.10/html-single/admin_portal_guide/index#tokens">Tokens</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-threescale-manifests_threescale-adapter">
<title>Generating manifests from a deployed adapter</title>
<note>
<itemizedlist>
<listitem>
<simpara><literal>NAME</literal> is an identifier you use to identify with the service you are managing with 3scale.</simpara>
</listitem>
<listitem>
<simpara>The <literal>CREDENTIALS_NAME</literal> reference is an identifier that corresponds to the <literal>match</literal> section in the rule configuration. This is automatically set to the <literal>NAME</literal> identifier if you are using the CLI tool.</simpara>
</listitem>
<listitem>
<simpara>Its value does not need to be anything specific: the label value should just match the contents of the rule. See <link xlink:href="https://github.com/3scale/3scale-istio-adapter/blob/v2.X/README.md#routing-service-traffic-through-the-adapter">Routing service traffic through the adapter</link> for more information.</simpara>
</listitem>
</itemizedlist>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run this command to generate manifests from a deployed adapter in the <literal>istio-system</literal> namespace:</simpara>
<screen>$ export NS="istio-system" URL="https://replaceme-admin.3scale.net:443" NAME="name" TOKEN="token"
oc exec -n ${NS} $(oc get po -n ${NS} -o jsonpath='{.items[?(@.metadata.labels.app=="3scale-istio-adapter")].metadata.name}') \
-it -- ./3scale-config-gen \
--url ${URL} --name ${NAME} --token ${TOKEN} -n ${NS}</screen>
</listitem>
<listitem>
<simpara>This will produce sample output to the terminal. Edit these samples if required and create the objects using the <literal>oc create</literal> command.</simpara>
</listitem>
<listitem>
<simpara>When the request reaches the adapter, the adapter needs to know how the service maps to an API on 3scale. You can provide this information in two ways:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Label the workload (recommended)</simpara>
</listitem>
<listitem>
<simpara>Hard code the handler as <literal>service_id</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the workload with the required annotations:</simpara>
<note>
<simpara>You only need to update the service ID provided in this example if it is not already embedded in the handler. <emphasis role="strong">The setting in the handler takes precedence</emphasis>.</simpara>
</note>
<screen>$ export CREDENTIALS_NAME="replace-me"
export SERVICE_ID="replace-me"
export DEPLOYMENT="replace-me"
patch="$(oc get deployment "${DEPLOYMENT}"
patch="$(oc get deployment "${DEPLOYMENT}" --template='{"spec":{"template":{"metadata":{"labels":{ {{ range $k,$v := .spec.template.metadata.labels }}"{{ $k }}":"{{ $v }}",{{ end }}"service-mesh.3scale.net/service-id":"'"${SERVICE_ID}"'","service-mesh.3scale.net/credentials":"'"${CREDENTIALS_NAME}"'"}}}}}' )"
oc patch deployment "${DEPLOYMENT}" --patch ''"${patch}"''</screen>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-threescale-routing_threescale-adapter">
<title>Routing service traffic through the adapter</title>
<simpara>Follow these steps to drive traffic for your service through the 3scale adapter.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Credentials and service ID from your 3scale administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Match the rule <literal>destination.labels["service-mesh.3scale.net/credentials"] == "threescale"</literal> that you previously created in the configuration, in the <literal>kind: rule</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Add the above label to <literal>PodTemplateSpec</literal> on the Deployment of the target workload to integrate a service. the value, <literal>threescale</literal>, refers to the name of the generated handler. This handler stores the access token required to call 3scale.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>destination.labels["service-mesh.3scale.net/service-id"] == "replace-me"</literal> label to the workload to pass the service ID to the adapter via the instance at request time.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-threescale-integration-settings_threescale-adapter">
<title>Configure the integration settings in 3scale</title>
<simpara>Follow this procedure to configure the 3scale integration settings.</simpara>
<note>
<simpara>For 3scale SaaS customers, Red Hat OpenShift Service Mesh is enabled as part of the Early Access program.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">[your_API_name]</emphasis> &#8594; <emphasis role="strong">Integration</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Istio</emphasis> option under <emphasis>Deployment</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">API Key (user_key)</emphasis> option under <emphasis>Authentication</emphasis> is selected by default.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Update Product</emphasis> to save your selection.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Configuration</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Update Configuration</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-threescale-caching_threescale-adapter">
<title>Caching behavior</title>
<simpara>Responses from 3scale System APIs are cached by default within the adapter. Entries will be purged from the cache when they become older than the <literal>cacheTTLSeconds</literal> value. Also by default, automatic refreshing of cached entries will be attempted seconds before they expire, based on the <literal>cacheRefreshSeconds</literal> value. You can disable automatic refreshing by setting this value higher than the <literal>cacheTTLSeconds</literal> value.</simpara>
<simpara>Caching can be disabled entirely by setting <literal>cacheEntriesMax</literal> to a non-positive value.</simpara>
<simpara>By using the refreshing process, cached values whose hosts become unreachable will be retried before eventually being purged when past their expiry.</simpara>
</section>
<section xml:id="ossm-threescale-authentication_threescale-adapter">
<title>Authenticating requests</title>
<simpara>This release supports the following authentication methods:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Standard API Keys</emphasis>: single randomized strings or hashes acting as an identifier and a secret token.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Application identifier and key pairs</emphasis>: immutable identifier and mutable secret key strings.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">OpenID authentication method</emphasis>: client ID string parsed from the JSON Web Token.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-threescale-authentication-patterns_threescale-adapter">
<title>Applying authentication patterns</title>
<simpara>Modify the <literal>instance</literal> custom resource, as illustrated in the following authentication method examples, to configure authentication behavior. You can accept the authentication credentials from:</simpara>
<itemizedlist>
<listitem>
<simpara>Request headers</simpara>
</listitem>
<listitem>
<simpara>Request parameters</simpara>
</listitem>
<listitem>
<simpara>Both request headers and query parameters</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>When specifying values from headers, they must be lower case. For example, if you want to send a header as <literal>User-Key</literal>, this must be referenced in the configuration as <literal>request.headers["user-key"]</literal>.</simpara>
</note>
<section xml:id="ossm-threescale-apikey-authentication_threescale-adapter">
<title>API key authentication method</title>
<simpara>Service Mesh looks for the API key in query parameters and request headers as specified in the <literal>user</literal> option in the <literal>subject</literal> custom resource parameter. It checks the values in the order given in the custom resource file. You can restrict the search for the API key to either query parameters or request headers by omitting the unwanted option.</simpara>
<simpara>In this example, Service Mesh looks for the API key in the <literal>user_key</literal> query parameter. If the API key is not in the query parameter, Service Mesh then checks the <literal>user-key</literal> header.</simpara>
<formalpara>
<title>API key authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
  namespace: istio-system
spec:
  template: authorization
  params:
    subject:
      user: request.query_params["user_key"] | request.headers["user-key"] | ""
    action:
      path: request.url_path
      method: request.method | "get"</programlisting>
</para>
</formalpara>
<simpara>If you want the adapter to examine a different query parameter or request header, change the name as appropriate. For example, to check for the API key in a query parameter named “key”, change <literal>request.query_params["user_key"]</literal> to <literal>request.query_params["key"]</literal>.</simpara>
</section>
<section xml:id="ossm-threescale-appidapikey-authentication_threescale-adapter">
<title>Application ID and application key pair authentication method</title>
<simpara>Service Mesh looks for the application ID and application key in query parameters and request headers, as specified in the <literal>properties</literal> option in the <literal>subject</literal> custom resource parameter. The application key is optional. It checks the values in the order given in the custom resource file. You can restrict the search for the credentials to either query parameters or request headers by not including the unwanted option.</simpara>
<simpara>In this example, Service Mesh looks for the application ID and application key in the query parameters first, moving on to the request headers if needed.</simpara>
<formalpara>
<title>Application ID and application key pair authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
  namespace: istio-system
spec:
  template: authorization
  params:
    subject:
        app_id: request.query_params["app_id"] | request.headers["app-id"] | ""
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
    action:
      path: request.url_path
      method: request.method | "get"</programlisting>
</para>
</formalpara>
<simpara>If you want the adapter to examine a different query parameter or request header, change the name as appropriate. For example, to check for the application ID in a query parameter named <literal>identification</literal>, change <literal>request.query_params["app_id"]</literal> to <literal>request.query_params["identification"]</literal>.</simpara>
</section>
<section xml:id="ossm-threescale-openid-authentication_threescale-adapter">
<title>OpenID authentication method</title>
<simpara>To use the <emphasis>OpenID Connect (OIDC) authentication method</emphasis>, use the <literal>properties</literal> value on the <literal>subject</literal> field to set <literal>client_id</literal>, and optionally <literal>app_key</literal>.</simpara>
<simpara>You can manipulate this object using the methods described previously. In the example configuration shown below, the client identifier (application ID) is parsed from the JSON Web Token (JWT) under the label <emphasis>azp</emphasis>. You can modify this as needed.</simpara>
<formalpara>
<title>OpenID authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
spec:
  template: threescale-authorization
  params:
    subject:
      properties:
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
        client_id: request.auth.claims["azp"] | ""
      action:
        path: request.url_path
        method: request.method | "get"
        service: destination.labels["service-mesh.3scale.net/service-id"] | ""</programlisting>
</para>
</formalpara>
<simpara>For this integration to work correctly, OIDC must still be done in 3scale for the client to be created in the identity provider (IdP). You should create a <link xlink:href="https://istio.io/latest/docs/tasks/security/authorization/authz-jwt/">Request authorization</link> for the service you want to protect in the same namespace as that service. The JWT is passed in the <literal>Authorization</literal> header of the request.</simpara>
<simpara>In the sample <literal>RequestAuthentication</literal> defined below, replace <literal>issuer</literal>, <literal>jwksUri</literal>, and <literal>selector</literal> as appropriate.</simpara>
<formalpara>
<title>OpenID Policy example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-example
  namespace: bookinfo
spec:
  selector:
    matchLabels:
      app: productpage
  jwtRules:
  - issuer: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak
    jwksUri: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak/protocol/openid-connect/certs</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-threescale-hybrid-authentication_threescale-adapter">
<title>Hybrid authentication method</title>
<simpara>You can choose to not enforce a particular authentication method and accept any valid credentials for either method. If both an API key and an application ID/application key pair are provided, Service Mesh uses the API key.</simpara>
<simpara>In this example, Service Mesh checks for an API key in the query parameters, then the request headers. If there is no API key, it then checks for an application ID and key in the query parameters, then the request headers.</simpara>
<formalpara>
<title>Hybrid authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
spec:
  template: authorization
  params:
    subject:
      user: request.query_params["user_key"] | request.headers["user-key"] |
      properties:
        app_id: request.query_params["app_id"] | request.headers["app-id"] | ""
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
        client_id: request.auth.claims["azp"] | ""
    action:
      path: request.url_path
      method: request.method | "get"
      service: destination.labels["service-mesh.3scale.net/service-id"] | ""</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="ossm-threescale-metrics_threescale-adapter">
<title>3scale Adapter metrics</title>
<simpara>The adapter, by default reports various Prometheus metrics that are exposed on port <literal>8080</literal> at the <literal>/metrics</literal> endpoint. These metrics provide insight into how the interactions between the adapter and 3scale are performing. The service is labeled to be automatically discovered and scraped by Prometheus.</simpara>
<note>
<simpara>There are incompatible changes in the 3scale Istio Adapter metrics since the previous releases in Service Mesh 1.x.</simpara>
</note>
<simpara>In Prometheus, metrics have been renamed with one addition for the backend cache, so that the following metrics exist as of Service Mesh 2.0:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Prometheus metrics</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Metric</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>threescale_latency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Histogram</simpara></entry>
<entry align="left" valign="top"><simpara>Request latency between adapter and 3scale.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>threescale_http_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>HTTP Status response codes for requests to 3scale backend.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>threescale_system_cache_hits</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of requests to the 3scale system fetched from the configuration cache.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>threescale_backend_cache_hits</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Total number of requests to 3scale backend fetched from the backend cache.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="threescale-backend-cache_threescale-adapter">
<title>3scale backend cache</title>
<simpara>The 3scale backend cache provides an authorization and reporting cache for clients of the 3scale Service Management API. This cache is embedded in the adapter to enable lower latencies in responses in certain situations assuming the administrator is willing to accept the trade-offs.</simpara>
<note>
<simpara>3scale backend cache is disabled by default. 3scale backend cache functionality trades inaccuracy in rate limiting and potential loss of hits since the last flush was performed for low latency and higher consumption of resources in the processor and memory.</simpara>
</note>
<section xml:id="_advantages_of_enabling_backend_cache">
<title>Advantages of enabling backend cache</title>
<simpara>The following are advantages to enabling the backend cache:</simpara>
<itemizedlist>
<listitem>
<simpara>Enable the backend cache when you find latencies are high while accessing services managed by the 3scale Istio Adapter.</simpara>
</listitem>
<listitem>
<simpara>Enabling the backend cache will stop the adapter from continually checking with the 3scale API manager for request authorizations, which will lower the latency.</simpara>
<itemizedlist>
<listitem>
<simpara>This creates an in-memory cache of 3scale authorizations for the 3scale Istio Adapter to store and reuse before attempting to contact the 3scale API manager for authorizations. Authorizations will then take much less time to be granted or denied.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Backend caching is useful in cases when you are hosting the 3scale API manager in another geographical location from the service mesh running the 3scale Istio Adapter.</simpara>
<itemizedlist>
<listitem>
<simpara>This is generally the case with the 3scale Hosted (SaaS) platform, but also if a user hosts their 3scale API manager in another cluster located in a different geographical location, in a different availability zone, or in any case where the network overhead to reach the 3scale API manager is noticeable.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="_trade_offs_for_having_lower_latencies">
<title>Trade-offs for having lower latencies</title>
<simpara>The following are trade-offs for having lower latencies:</simpara>
<itemizedlist>
<listitem>
<simpara>Each 3scale adapter&#8217;s authorization state updates every time a flush happens.</simpara>
<itemizedlist>
<listitem>
<simpara>This means two or more instances of the adapter will introduce more inaccuracy between flushing periods.</simpara>
</listitem>
<listitem>
<simpara>There is a greater chance of too many requests being granted that exceed limits and introduce erratic behavior, which leads to some requests going through and some not, depending on which adapter processes each request.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>An adapter cache that cannot flush its data and update its authorization information risks shut down or crashing without reporting its information to the API manager.</simpara>
</listitem>
<listitem>
<simpara>A fail open or fail closed policy will be applied when an adapter cache cannot determine whether a request must be granted or denied, possibly due to network connectivity issues in contacting the API manager.</simpara>
</listitem>
<listitem>
<simpara>When cache misses occur, typically right after booting the adapter or after a long period of no connectivity, latencies will grow in order to query the API manager.</simpara>
</listitem>
<listitem>
<simpara>An adapter cache must do much more work on computing authorizations than it would without an enabled cache, which will tax processor resources.</simpara>
</listitem>
<listitem>
<simpara>Memory requirements will grow proportionally to the combination of the amount of limits, applications, and services managed by the cache.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_backend_cache_configuration_settings">
<title>Backend cache configuration settings</title>
<simpara>The following points explain the backend cache configuration settings:</simpara>
<itemizedlist>
<listitem>
<simpara>Find the settings to configure the backend cache in the 3scale configuration options.</simpara>
</listitem>
<listitem>
<simpara>The last 3 settings control enabling of backend cache:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>PARAM_USE_CACHE_BACKEND</literal> - set to true to enable backend cache.</simpara>
</listitem>
<listitem>
<simpara><literal>PARAM_BACKEND_CACHE_FLUSH_INTERVAL_SECONDS</literal> - sets time in seconds between consecutive attempts to flush cache data to the API manager.</simpara>
</listitem>
<listitem>
<simpara><literal>PARAM_BACKEND_CACHE_POLICY_FAIL_CLOSED</literal> - set whether or not to allow/open or deny/close requests to the services when there is not enough cached data and the 3scale API manager cannot be reached.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="threescale-istio-adapter-apicast_threescale-adapter">
<title>3scale Istio Adapter APIcast emulation</title>
<simpara>The 3scale Istio Adapter performs as APIcast would when the following conditions occur:</simpara>
<itemizedlist>
<listitem>
<simpara>When a request cannot match any mapping rule defined, the returned HTTP code is 404 Not Found. This was previously 403 Forbidden.</simpara>
</listitem>
<listitem>
<simpara>When a request is denied because it goes over limits, the returned HTTP code is 429 Too Many Requests. This was previously 403 Forbidden.</simpara>
</listitem>
<listitem>
<simpara>When generating default templates via the CLI, it will use underscores rather than dashes for the headers, for example: <literal>user_key</literal> rather than <literal>user-key</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-istio-adapter-verification_threescale-adapter">
<title>3scale Istio adapter verification</title>
<simpara>You might want to check whether the 3scale Istio adapter is working as expected. If your adapter is not working, use the following steps to help troubleshoot the problem.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Ensure the <emphasis>3scale-adapter</emphasis> pod is running in the Service Mesh control plane namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;istio-system&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check that the <emphasis>3scale-adapter</emphasis> pod has printed out information about itself booting up, such as its version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs &lt;istio-system&gt;</programlisting>
</listitem>
<listitem>
<simpara>When performing requests to the services protected by the 3scale adapter integration, always try requests that lack the right credentials and ensure they fail. Check the 3scale adapter logs to gather additional information.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/container-platform/4.7/support/troubleshooting/investigating-pod-issues.html#inspecting-pod-and-container-logs_investigating-pod-issues">Inspecting pod and container logs</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-istio-adapter-troubleshooting-checklist_threescale-adapter">
<title>3scale Istio adapter troubleshooting checklist</title>
<simpara>As the administrator installing the 3scale Istio adapter, there are a number of scenarios that might be causing your integration to not function properly. Use the following list to troubleshoot your installation:</simpara>
<itemizedlist>
<listitem>
<simpara>Incorrect YAML indentation.</simpara>
</listitem>
<listitem>
<simpara>Missing YAML sections.</simpara>
</listitem>
<listitem>
<simpara>Forgot to apply the changes in the YAML to the cluster.</simpara>
</listitem>
<listitem>
<simpara>Forgot to label the service workloads with the <literal>service-mesh.3scale.net/credentials</literal> key.</simpara>
</listitem>
<listitem>
<simpara>Forgot to label the service workloads with <literal>service-mesh.3scale.net/service-id</literal> when using handlers that do not contain a <literal>service_id</literal> so they are reusable per account.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Rule</emphasis> custom resource points to the wrong handler or instance custom resources, or the references lack the corresponding namespace suffix.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Rule</emphasis> custom resource <literal>match</literal> section cannot possibly match the service you are configuring, or it points to a destination workload that is not currently running or does not exist.</simpara>
</listitem>
<listitem>
<simpara>Wrong access token or URL for the 3scale Admin Portal in the handler.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Instance</emphasis> custom resource&#8217;s <literal>params/subject/properties</literal> section fails to list the right parameters for <literal>app_id</literal>, <literal>app_key</literal>, or <literal>client_id</literal>, either because they specify the wrong location such as the query parameters, headers, and authorization claims, or the parameter names do not match the requests used for testing.</simpara>
</listitem>
<listitem>
<simpara>Failing to use the configuration generator without realizing that it actually lives in the adapter container image and needs <literal>oc exec</literal> to invoke it.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-troubleshooting">
<title>Troubleshooting your service mesh</title>

<simpara>This section describes how to identify and resolve common problems in Red Hat OpenShift Service Mesh. Use the following sections to help troubleshoot and debug problems when deploying Red Hat OpenShift Service Mesh on OpenShift Container Platform.</simpara>
<section xml:id="ossm-versions_troubleshooting-ossm">
<title>Understanding Service Mesh versions</title>
<simpara>In order to understand what version of Red Hat OpenShift Service Mesh you have deployed on your system, you need to understand how each of the component versions is managed.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Operator</emphasis> version - The most current Operator version is 2.4.5. The Operator version number only indicates the version of the currently installed Operator. Because the Red Hat OpenShift Service Mesh Operator supports multiple versions of the Service Mesh control plane, the version of the Operator does not determine the version of your deployed <literal>ServiceMeshControlPlane</literal> resources.</simpara>
<important>
<simpara>Upgrading to the latest Operator version automatically applies patch updates, but does not automatically upgrade your Service Mesh control plane to the latest minor version.</simpara>
</important>
</listitem>
<listitem>
<simpara><emphasis role="strong">ServiceMeshControlPlane</emphasis> version - The <literal>ServiceMeshControlPlane</literal> version determines what version of Red Hat OpenShift Service Mesh you are using. The value of the <literal>spec.version</literal> field in the <literal>ServiceMeshControlPlane</literal> resource controls the architecture and configuration settings that are used to install and deploy Red Hat OpenShift Service Mesh. When you create the Service Mesh control plane you can set the version in one of two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>To configure in the Form View, select the version from the <emphasis role="strong">Control Plane Version</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>To configure in the YAML View, set the value for <literal>spec.version</literal> in the YAML file.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Operator Lifecycle Manager (OLM) does not manage Service Mesh control plane upgrades, so the version number for your Operator and <literal>ServiceMeshControlPlane</literal> (SMCP) may not match, unless you have manually upgraded your SMCP.</simpara>
</section>
<section xml:id="_troubleshooting_operator_installation">
<title>Troubleshooting Operator installation</title>
<simpara>In addition to the information in this section, be sure to review the following topics:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../operators/understanding/olm-what-operators-are.xml">What are Operators?</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../operators/understanding/olm/olm-understanding-olm.xml">Operator Lifecycle Management concepts</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../support/troubleshooting/troubleshooting-operator-issues.xml">OpenShift Operator troubleshooting section</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../support/troubleshooting/troubleshooting-installations.xml">OpenShift installation troubleshooting section</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-validating-operators_troubleshooting-ossm">
<title>Validating Operator installation</title>
<simpara>When you install the Red Hat OpenShift Service Mesh Operators, OpenShift automatically creates the following objects as part of a successful Operator installation:</simpara>
<itemizedlist>
<listitem>
<simpara>config maps</simpara>
</listitem>
<listitem>
<simpara>custom resource definitions</simpara>
</listitem>
<listitem>
<simpara>deployments</simpara>
</listitem>
<listitem>
<simpara>pods</simpara>
</listitem>
<listitem>
<simpara>replica sets</simpara>
</listitem>
<listitem>
<simpara>roles</simpara>
</listitem>
<listitem>
<simpara>role bindings</simpara>
</listitem>
<listitem>
<simpara>secrets</simpara>
</listitem>
<listitem>
<simpara>service accounts</simpara>
</listitem>
<listitem>
<simpara>services</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>From the OpenShift Container Platform console</title>
<para>You can verify that the Operator pods are available and running by using the OpenShift Container Platform console.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <literal>openshift-operators</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that the following pods exist and have a status of <literal>running</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>istio-operator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>jaeger-operator</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kiali-operator</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select the <literal>openshift-operators-redhat</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that the <literal>elasticsearch-operator</literal> pod exists and has a status of <literal>running</literal>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>From the command line</title>
<listitem>
<simpara>Verify the Operator pods are available and running in the <literal>openshift-operators</literal> namespace with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-operators</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                               READY   STATUS    RESTARTS   AGE
istio-operator-bb49787db-zgr87     1/1     Running   0          15s
jaeger-operator-7d5c4f57d8-9xphf   1/1     Running   0          2m42s
kiali-operator-f9c8d84f4-7xh2v     1/1     Running   0          64s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify the Elasticsearch operator with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-operators-redhat</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                      READY   STATUS    RESTARTS   AGE
elasticsearch-operator-d4f59b968-796vq     1/1     Running   0          15s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-troubleshooting-operators_troubleshooting-ossm">
<title>Troubleshooting service mesh Operators</title>
<simpara>If you experience Operator issues:</simpara>
<itemizedlist>
<listitem>
<simpara>Verify your Operator subscription status.</simpara>
</listitem>
<listitem>
<simpara>Verify that you did not install a community version of the Operator, instead of the supported Red Hat version.</simpara>
</listitem>
<listitem>
<simpara>Verify that you have the <literal>cluster-admin</literal> role to install Red Hat OpenShift Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>Check for any errors in the Operator pod logs if the issue is related to installation of Operators.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can install Operators only through the OpenShift console, the OperatorHub is not accessible from the command line.</simpara>
</note>
<section xml:id="_viewing_operator_pod_logs">
<title>Viewing Operator pod logs</title>
<simpara>You can view Operator logs by using the <literal>oc logs</literal> command. Red Hat may request logs to help resolve support cases.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To view Operator pod logs, enter the command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-operators &lt;podName&gt;</programlisting>
<simpara>For example,</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-operators istio-operator-bb49787db-zgr87</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="_troubleshooting_the_control_plane">
<title>Troubleshooting the control plane</title>
<simpara>The Service Mesh <emphasis>control plane</emphasis> is composed of Istiod, which consolidates several previous control plane components (Citadel, Galley, Pilot) into a single binary. Deploying the <literal>ServiceMeshControlPlane</literal> also creates the other components that make up Red Hat OpenShift Service Mesh as described in the <link xlink:href="../../service_mesh/v2x/ossm-architecture.xml#ossm-architecture_ossm-architecture">architecture</link> topic.</simpara>
<section xml:id="ossm-validating-smcp_troubleshooting-ossm">
<title>Validating the Service Mesh control plane installation</title>
<simpara>When you create the Service Mesh control plane, the Service Mesh Operator uses the parameters that you have specified in the <literal>ServiceMeshControlPlane</literal> resource file to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Creates the Istio components and deploys the following pods:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>istiod</literal></simpara>
</listitem>
<listitem>
<simpara><literal>istio-ingressgateway</literal></simpara>
</listitem>
<listitem>
<simpara><literal>istio-egressgateway</literal></simpara>
</listitem>
<listitem>
<simpara><literal>grafana</literal></simpara>
</listitem>
<listitem>
<simpara><literal>prometheus</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Calls the Kiali Operator to create Kaili deployment based on configuration in either the SMCP or the Kiali custom resource.</simpara>
<note>
<simpara>You view the Kiali components under the Kiali Operator, not the Service Mesh Operator.</simpara>
</note>
</listitem>
<listitem>
<simpara>Calls the Red Hat OpenShift distributed tracing platform (Jaeger) Operator to create distributed tracing platform (Jaeger) components based on configuration in either the SMCP or the Jaeger custom resource.</simpara>
<note>
<simpara>You view the Jaeger components under the Red Hat OpenShift distributed tracing platform (Jaeger) Operator and the Elasticsearch components under the Red Hat Elasticsearch Operator, not the Service Mesh Operator.</simpara>
</note>
<formalpara>
<title>From the OpenShift Container Platform console</title>
<para>You can verify the Service Mesh control plane installation in the OpenShift Container Platform web console.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <literal>&lt;istio-system&gt;</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Select the Red Hat OpenShift Service Mesh Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your control plane, for example <literal>basic</literal>.</simpara>
</listitem>
<listitem>
<simpara>To view the resources created by the deployment, click the <emphasis role="strong">Resources</emphasis> tab. You can use the filter to narrow your view, for example, to check that all the <emphasis role="strong">Pods</emphasis> have a status of <literal>running</literal>.</simpara>
</listitem>
<listitem>
<simpara>If the SMCP status indicates any problems, check the <literal>status:</literal> output in the YAML file for more information.</simpara>
</listitem>
<listitem>
<simpara>Navigate back to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the OpenShift Elasticsearch Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Elasticsearch</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the deployment, for example <literal>elasticsearch</literal>.</simpara>
</listitem>
<listitem>
<simpara>To view the resources created by the deployment, click the <emphasis role="strong">Resources</emphasis> tab. .</simpara>
</listitem>
<listitem>
<simpara>If the <literal>Status</literal> column any problems, check the <literal>status:</literal> output on the <emphasis role="strong">YAML</emphasis> tab for more information.</simpara>
</listitem>
<listitem>
<simpara>Navigate back to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the Red Hat OpenShift distributed tracing platform (Jaeger) Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Jaeger</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your deployment, for example <literal>jaeger</literal>.</simpara>
</listitem>
<listitem>
<simpara>To view the resources created by the deployment, click the <emphasis role="strong">Resources</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>If the <literal>Status</literal> column indicates any problems, check the <literal>status:</literal> output on the <emphasis role="strong">YAML</emphasis> tab for more information.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Select the Kiali Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your deployment, for example <literal>kiali</literal>.</simpara>
</listitem>
<listitem>
<simpara>To view the resources created by the deployment, click the <emphasis role="strong">Resources</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>If the <literal>Status</literal> column any problems, check the <literal>status:</literal> output on the <emphasis role="strong">YAML</emphasis> tab for more information.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>From the command line</title>
<listitem>
<simpara>Run the following command to see if the Service Mesh control plane pods are available and running, where <literal>istio-system</literal> is the namespace where you installed the SMCP.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n istio-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   READY   STATUS    RESTARTS   AGE
grafana-6776785cfc-6fz7t               2/2     Running   0          102s
istio-egressgateway-5f49dd99-l9ppq     1/1     Running   0          103s
istio-ingressgateway-6dc885c48-jjd8r   1/1     Running   0          103s
istiod-basic-6c9cc55998-wg4zq          1/1     Running   0          2m14s
jaeger-6865d5d8bf-zrfss                2/2     Running   0          100s
kiali-579799fbb7-8mwc8                 1/1     Running   0          46s
prometheus-5c579dfb-6qhjk              2/2     Running   0          115s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of the Service Mesh control plane deployment by using the following command. Replace <literal>istio-system</literal> with the namespace where you deployed the SMCP.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n &lt;istio-system&gt;</programlisting>
<simpara>The installation has finished successfully when the STATUS column is <literal>ComponentsReady</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME    READY   STATUS            PROFILES      VERSION   AGE
basic   10/10   ComponentsReady   ["default"]   2.1.3     4m2s</programlisting>
</para>
</formalpara>
<simpara>If you have modified and redeployed your Service Mesh control plane, the status should read <literal>UpdateSuccessful</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            READY     STATUS             TEMPLATE   VERSION   AGE
basic-install   10/10     UpdateSuccessful   default     v1.1     3d16h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the SMCP status indicates anything other than <literal>ComponentsReady</literal> check the <literal>status:</literal> output in the SCMP resource for more information.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe smcp &lt;smcp-name&gt; -n &lt;controlplane-namespace&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe smcp basic -n istio-system</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of the Jaeger deployment with the following command, where <literal>istio-system</literal> is the namespace where you deployed the SMCP.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jaeger -n &lt;istio-system&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     STATUS    VERSION   STRATEGY   STORAGE   AGE
jaeger   Running   1.30.0    allinone   memory    15m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of the Kiali deployment with the following command, where <literal>istio-system</literal> is the namespace where you deployed the SMCP.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kiali -n &lt;istio-system&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME    AGE
kiali   15m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="ossm-accessing-kiali-console_troubleshooting-ossm">
<title>Accessing the Kiali console</title>
<simpara>You can view your application&#8217;s topology, health, and metrics in the Kiali console. If your service is experiencing problems, the Kiali console lets you view the data flow through your service. You can view insights about the mesh components at different levels, including abstract applications, services, and workloads. Kiali also provides an interactive graph view of your namespace in real time.</simpara>
<simpara>To access the Kiali console you must have Red Hat OpenShift Service Mesh installed, Kiali installed and configured.</simpara>
<simpara>The installation process creates a route to access the Kiali console.</simpara>
<simpara>If you know the URL for the Kiali console, you can access it directly.  If you do not know the URL, use the following directions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure for administrators</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console with an administrator role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Projects</emphasis> page, if necessary, use the filter to find the name of your project.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your project, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project details</emphasis> page, in the <emphasis role="strong">Launcher</emphasis> section, click the <emphasis role="strong">Kiali</emphasis> link.</simpara>
</listitem>
<listitem>
<simpara>Log in to the Kiali console with the same user name and password that you use to access the OpenShift Container Platform console.</simpara>
<simpara>When you first log in to the Kiali Console, you see the <emphasis role="strong">Overview</emphasis> page which displays all the namespaces in your service mesh that you have permission to view.</simpara>
<simpara>If you are validating the console installation and namespaces have not yet been added to the mesh, there might not be any data to display other than <literal>istio-system</literal>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure for developers</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console with a developer role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project Details</emphasis> page, if necessary, use the filter to find the name of your project.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your project, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Project</emphasis> page, in the <emphasis role="strong">Launcher</emphasis> section, click the <emphasis role="strong">Kiali</emphasis> link.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-accessing-jaeger-console_troubleshooting-ossm">
<title>Accessing the Jaeger console</title>
<simpara>To access the Jaeger console you must have Red Hat OpenShift Service Mesh installed, Red Hat OpenShift distributed tracing platform (Jaeger) installed and configured.</simpara>
<simpara>The installation process creates a route to access the Jaeger console.</simpara>
<simpara>If you know the URL for the Jaeger console, you can access it directly.  If you do not know the URL, use the following directions.</simpara>
<orderedlist numeration="arabic">
<title>Procedure from OpenShift console</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>If necessary, use the filter to find the <literal>jaeger</literal> route.  Click the route <emphasis role="strong">Location</emphasis> to launch the console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from Kiali console</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Distributed Tracing</emphasis> in the left navigation pane.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from the CLI</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>To query for details of the route using the command line, enter the following command. In this example, <literal>istio-system</literal> is the Service Mesh control plane namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export JAEGER_URL=$(oc get route -n istio-system jaeger -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Launch a browser and navigate to <literal>https://&lt;JAEGER_URL&gt;</literal>, where <literal>&lt;JAEGER_URL&gt;</literal> is the route that you discovered in the previous step.</simpara>
</listitem>
<listitem>
<simpara>Log in using the same user name and password that you use to access the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>If you have added services to the service mesh and have generated traces, you can use the filters and <emphasis role="strong">Find Traces</emphasis> button to search your trace data.</simpara>
<simpara>If you are validating the console installation, there is no trace data to display.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-troubleshooting-smcp_troubleshooting-ossm">
<title>Troubleshooting the Service Mesh control plane</title>
<simpara>If you are experiencing issues while deploying the Service Mesh control plane,</simpara>
<itemizedlist>
<listitem>
<simpara>Ensure that the <literal>ServiceMeshControlPlane</literal> resource is installed in a project that is separate from your services and Operators. This documentation uses the <literal>istio-system</literal> project as an example, but you can deploy your control plane in any project as long as it is separate from the project that contains your Operators and services.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the <literal>ServiceMeshControlPlane</literal> and <literal>Jaeger</literal> custom resources are deployed in the same project. For example, use the <literal>istio-system</literal> project for both.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_troubleshooting_the_data_plane">
<title>Troubleshooting the data plane</title>
<simpara>The <emphasis>data plane</emphasis> is a set of intelligent proxies that intercept and control all inbound and outbound network communications between services in the service mesh.</simpara>
<simpara>Red Hat OpenShift Service Mesh relies on a proxy sidecar within the application’s pod to provide service mesh capabilities to the application.</simpara>
<section xml:id="ossm-troubleshooting-injection_troubleshooting-ossm">
<title>Troubleshooting sidecar injection</title>
<simpara>Red Hat OpenShift Service Mesh does not automatically inject proxy sidecars to pods. You must opt in to sidecar injection.</simpara>
<section xml:id="_troubleshooting_istio_sidecar_injection">
<title>Troubleshooting Istio sidecar injection</title>
<simpara>Check to see if automatic injection is enabled in the Deployment for your application. If automatic injection for the Envoy proxy is enabled, there should be a <literal>sidecar.istio.io/inject:"true"</literal> annotation in the <literal>Deployment</literal> resource under <literal>spec.template.metadata.annotations</literal>.</simpara>
</section>
<section xml:id="_troubleshooting_jaeger_agent_sidecar_injection">
<title>Troubleshooting Jaeger agent sidecar injection</title>
<simpara>Check to see if automatic injection is enabled in the Deployment for your application. If automatic injection for the Jaeger agent is enabled, there should be a <literal>sidecar.jaegertracing.io/inject:"true"</literal> annotation in the <literal>Deployment</literal> resource.</simpara>
<simpara>For more information about sidecar injection, see <link xlink:href="../../service_mesh/v2x/prepare-to-deploy-applications-ossm.xml#ossm-automatic-sidecar-injection_deploying-applications-ossm">Enabling automatic injection</link></simpara>
</section>
</section>
</section>
</section>
<section xml:id="ossm-troubleshooting-proxy_troubleshooting-ossm">
<title>Troubleshooting Envoy proxy</title>
<simpara>The Envoy proxy intercepts all inbound and outbound traffic for all services in the service mesh. Envoy also collects and reports telemetry on the service mesh. Envoy is deployed as a sidecar to the relevant service in the same pod.</simpara>
<section xml:id="_enabling_envoy_access_logs">
<title>Enabling Envoy access logs</title>
<simpara>Envoy access logs are useful in diagnosing traffic failures and flows, and help with end-to-end traffic flow analysis.</simpara>
<simpara>To enable access logging for all istio-proxy containers, edit the <literal>ServiceMeshControlPlane</literal> (SMCP) object to add a file name for the logging output.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the cluster-admin role. Enter the following command. Then, enter your username and password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the Service Mesh control plane, for example <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>ServiceMeshControlPlane</literal> file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit smcp &lt;smcp_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>As show in the following example, use <literal>name</literal> to specify the file name for the proxy log. If you do not specify a value for <literal>name</literal>, no log entries will be written.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  proxy:
    accessLogging:
      file:
        name: /dev/stdout     #file name</programlisting>
</listitem>
</orderedlist>
<simpara>For more information about troubleshooting pod issues, see <link xlink:href="../../support/troubleshooting/investigating-pod-issues.xml">Investigating pod issues</link></simpara>
</section>
<section xml:id="support_troubleshooting-ossm">
<title>Getting support</title>
<simpara>If you experience difficulty with a procedure described in this documentation, or with OpenShift Container Platform in general, visit the <link xlink:href="http://access.redhat.com">Red Hat Customer Portal</link>.</simpara>
<simpara>From the Customer Portal, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Search or browse through the Red Hat Knowledgebase of articles and solutions relating to Red Hat products.</simpara>
</listitem>
<listitem>
<simpara>Submit a support case to Red Hat Support.</simpara>
</listitem>
<listitem>
<simpara>Access other product documentation.</simpara>
</listitem>
</itemizedlist>
<simpara>To identify issues with your cluster, you can use Insights in <link xlink:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link>. Insights provides details about issues and, if available, information on how to solve a problem.</simpara>
<simpara>If you have a suggestion for improving this documentation or have found an
error, submit a <link xlink:href="https://issues.redhat.com/secure/CreateIssueDetails!init.jspa?pid=12332330&amp;summary=Documentation_issue&amp;issuetype=1&amp;components=12367614&amp;priority=10200&amp;versions=12385624">Jira issue</link> for the most relevant documentation component. Please provide specific details, such as the section name and OpenShift Container Platform version.</simpara>
<section xml:id="support-knowledgebase-about_troubleshooting-ossm">
<title>About the Red Hat Knowledgebase</title>
<simpara>The <link xlink:href="https://access.redhat.com/knowledgebase">Red Hat Knowledgebase</link> provides rich content aimed at helping you make the most of Red Hat&#8217;s products and technologies. The Red Hat Knowledgebase consists of articles, product documentation, and videos outlining best practices on installing, configuring, and using Red Hat products. In addition, you can search for solutions to known issues, each providing concise root cause descriptions and remedial steps.</simpara>
</section>
<section xml:id="support-knowledgebase-search_troubleshooting-ossm">
<title>Searching the Red Hat Knowledgebase</title>
<simpara>In the event of an OpenShift Container Platform issue, you can perform an initial search to determine if a solution already exists within the Red Hat Knowledgebase.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a Red Hat Customer Portal account.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the <link xlink:href="http://access.redhat.com">Red Hat Customer Portal</link>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Search</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the search field, input keywords and strings relating to the problem, including:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform components (such as <emphasis role="strong">etcd</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>Related procedure (such as <emphasis role="strong">installation</emphasis>)</simpara>
</listitem>
<listitem>
<simpara>Warnings, error messages, and other outputs related to explicit failures</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Enter</emphasis> key.</simpara>
</listitem>
<listitem>
<simpara>Optional: Select the <emphasis role="strong">OpenShift Container Platform</emphasis> product filter.</simpara>
</listitem>
<listitem>
<simpara>Optional: Select the <emphasis role="strong">Documentation</emphasis> content type filter.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-about-collecting-ossm-data_troubleshooting-ossm">
<title>About collecting service mesh data</title>
<simpara>You can use the <literal>oc adm must-gather</literal> CLI command to collect information about your cluster, including features and objects associated with Red Hat OpenShift Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Container Platform CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To collect Red Hat OpenShift Service Mesh data with <literal>must-gather</literal>, you must specify the Red Hat OpenShift Service Mesh image.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/openshift-service-mesh/istio-must-gather-rhel8:2.4</programlisting>
</listitem>
<listitem>
<simpara>To collect Red Hat OpenShift Service Mesh data for a specific Service Mesh control plane namespace with <literal>must-gather</literal>, you must specify the Red Hat OpenShift Service Mesh image and namespace. In this example, after <literal>gather,</literal> replace <literal>&lt;namespace&gt;</literal> with your Service Mesh control plane namespace, such as <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/openshift-service-mesh/istio-must-gather-rhel8:2.4 gather &lt;namespace&gt;</programlisting>
<simpara>This creates a local directory that contains the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>The Istio Operator namespace and its child objects</simpara>
</listitem>
<listitem>
<simpara>All control plane namespaces and their children objects</simpara>
</listitem>
<listitem>
<simpara>All namespaces and their children objects that belong to any service mesh</simpara>
</listitem>
<listitem>
<simpara>All Istio custom resource definitions (CRD)</simpara>
</listitem>
<listitem>
<simpara>All Istio CRD objects, such as VirtualServices, in a given namespace</simpara>
</listitem>
<listitem>
<simpara>All Istio webhooks</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>For prompt support, supply diagnostic information for both OpenShift Container Platform and Red Hat OpenShift Service Mesh.</simpara>
</section>
<section xml:id="support-submitting-a-case_troubleshooting-ossm">
<title>Submitting a support case</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have a Red Hat Customer Portal account.</simpara>
</listitem>
<listitem>
<simpara>You have a Red Hat Standard or Premium subscription.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <link xlink:href="https://access.redhat.com/support/cases/#/case/list">the <emphasis role="strong">Customer Support</emphasis> page</link> of the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Get support</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Cases</emphasis> tab of the <emphasis role="strong">Customer Support</emphasis> page:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Optional: Change the pre-filled account and owner details if needed.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate category for your issue, such as <emphasis role="strong">Bug or Defect</emphasis>, and click <emphasis role="strong">Continue</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enter the following information:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">Summary</emphasis> field, enter a concise but descriptive problem summary and further details about the symptoms being experienced, as well as your expectations.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">OpenShift Container Platform</emphasis> from the <emphasis role="strong">Product</emphasis> drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">4.14</emphasis> from the <emphasis role="strong">Version</emphasis> drop-down.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Review the list of suggested Red Hat Knowledgebase solutions for a potential match against the problem that is being reported. If the suggested articles do not address the issue, click <emphasis role="strong">Continue</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Review the updated list of suggested Red Hat Knowledgebase solutions for a potential match against the problem that is being reported. The list is refined as you provide more information during the case creation process. If the suggested articles do not address the issue, click <emphasis role="strong">Continue</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the account information presented is as expected, and if not, amend accordingly.</simpara>
</listitem>
<listitem>
<simpara>Check that the autofilled OpenShift Container Platform Cluster ID is correct. If it is not, manually obtain your cluster ID.</simpara>
<itemizedlist>
<listitem>
<simpara>To manually obtain your cluster ID using the OpenShift Container Platform web console:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Overview</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Find the value in the <emphasis role="strong">Cluster ID</emphasis> field of the <emphasis role="strong">Details</emphasis> section.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Alternatively, it is possible to open a new support case through the OpenShift Container Platform web console and have your cluster ID autofilled.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the toolbar, navigate to <emphasis role="strong">(?) Help</emphasis> &#8594; <emphasis role="strong">Open Support Case</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Cluster ID</emphasis> value is autofilled.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To obtain your cluster ID using the OpenShift CLI (<literal>oc</literal>), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion -o jsonpath='{.items[].spec.clusterID}{"\n"}'</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Complete the following questions where prompted and then click <emphasis role="strong">Continue</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>What are you experiencing? What are you expecting to happen?</simpara>
</listitem>
<listitem>
<simpara>Define the value or impact to you or the business.</simpara>
</listitem>
<listitem>
<simpara>Where are you experiencing this behavior? What environment?</simpara>
</listitem>
<listitem>
<simpara>When does this behavior occur? Frequency? Repeatedly? At certain times?</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Upload relevant diagnostic data files and click <emphasis role="strong">Continue</emphasis>.
It is recommended to include data gathered using the <literal>oc adm must-gather</literal> command as a starting point, plus any issue specific data that is not collected by that command.</simpara>
</listitem>
<listitem>
<simpara>Input relevant case management details and click <emphasis role="strong">Continue</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Preview the case details and click <emphasis role="strong">Submit</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-reference">
<title>Service Mesh control plane configuration reference</title>

<simpara>You can customize your Red Hat OpenShift Service Mesh by modifying the default <literal>ServiceMeshControlPlane</literal> (SMCP) resource or by creating a completely custom SMCP resource. This reference section documents the configuration options available for the SMCP resource.</simpara>
<section xml:id="ossm-cr-example_ossm-reference">
<title>Service Mesh Control plane parameters</title>
<simpara>The following table lists the top-level parameters for the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ServiceMeshControlPlane</literal> resource parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>APIVersion defines the versioned schema of this representation of an object. Servers convert recognized schemas to the latest internal value, and may reject unrecognized values. The value for the <literal>ServiceMeshControlPlane</literal> version 2.0 is <literal>maistra.io/v2</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>The value for <literal>ServiceMeshControlPlane</literal> version 2.0 is <literal>maistra.io/v2</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kind is a string value that represents the REST resource this object represents.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ServiceMeshControlPlane</literal> is the only valid value for a ServiceMeshControlPlane.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Metadata about this <literal>ServiceMeshControlPlane</literal> instance. You can provide a name for your Service Mesh control plane installation to keep track of your work, for example, <literal>basic</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The specification of the desired state of this <literal>ServiceMeshControlPlane</literal>. This includes the configuration options for all components that comprise the Service Mesh control plane.</simpara></entry>
<entry align="left" valign="top"><simpara>For more information, see Table 2.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The current status of this <literal>ServiceMeshControlPlane</literal> and the components that comprise the Service Mesh control plane.</simpara></entry>
<entry align="left" valign="top"><simpara>For more information, see Table 3.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following table lists the specifications for the <literal>ServiceMeshControlPlane</literal> resource. Changing these parameters configures Red Hat OpenShift Service Mesh components.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ServiceMeshControlPlane</literal> resource spec</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Configurable parameters</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>addons</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>addons</literal> parameter configures additional features beyond core Service Mesh control plane components, such as visualization, or metric storage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>3scale</literal>, <literal>grafana</literal>, <literal>jaeger</literal>, <literal>kiali</literal>, and <literal>prometheus</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cluster</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>cluster</literal> parameter sets the general configuration of the cluster (cluster name, network name, multi-cluster, mesh expansion, etc.)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>meshExpansion</literal>, <literal>multiCluster</literal>, <literal>name</literal>, and <literal>network</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>gateways</literal> parameter to configure ingress and egress gateways for the mesh.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>enabled</literal>, <literal>additionalEgress</literal>, <literal>additionalIngress</literal>, <literal>egress</literal>, <literal>ingress</literal>, and  <literal>openshiftRoute</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>general</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>general</literal> parameter represents general Service Mesh control plane configuration that does not fit anywhere else.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>logging</literal> and <literal>validationMessages</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>policy</literal> parameter to configure policy checking for the Service Mesh control plane. Policy checking can be enabled by setting <literal>spec.policy.enabled</literal> to <literal>true</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>mixer</literal> <literal>remote</literal>, or <literal>type</literal>. <literal>type</literal> can be set to <literal>Istiod</literal>, <literal>Mixer</literal> or <literal>None</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>profiles</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You select the <literal>ServiceMeshControlPlane</literal> profile to use for default values using the <literal>profiles</literal> parameter.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>proxy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>proxy</literal> parameter to configure the default behavior for sidecars.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>accessLogging</literal>, <literal>adminPort</literal>, <literal>concurrency</literal>, and <literal>envoyMetricsService</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>runtime</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>runtime</literal> parameter to configure the Service Mesh control plane components.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>components</literal>, and <literal>defaults</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>security</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>security</literal> parameter allows you to configure aspects of security for the Service Mesh control plane.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>certificateAuthority</literal>, <literal>controlPlane</literal>, <literal>identity</literal>, <literal>dataPlane</literal> and <literal>trust</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>techPreview</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>techPreview</literal> parameter enables early access to features that are in technology preview.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>telemetry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>spec.mixer.telemetry.enabled</literal> is set to <literal>true</literal>, telemetry is enabled.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>mixer</literal>, <literal>remote</literal>, and <literal>type</literal>. <literal>type</literal> can be set to <literal>Istiod</literal>, <literal>Mixer</literal> or <literal>None</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tracing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>tracing</literal> parameter to enables distributed tracing for the mesh.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>sampling</literal>, <literal>type</literal>. <literal>type</literal> can be set to <literal>Jaeger</literal> or <literal>None</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>You use the <literal>version</literal> parameter to specify what Maistra version of the Service Mesh control plane to install. When creating a <literal>ServiceMeshControlPlane</literal> with an empty version, the admission webhook sets the version to the current version. New <literal>ServiceMeshControlPlanes</literal> with an empty version are set to <literal>v2.0</literal>. Existing <literal>ServiceMeshControlPlanes</literal> with an empty version keep their setting.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><literal>ControlPlaneStatus</literal> represents the current state of your service mesh.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ServiceMeshControlPlane</literal> resource <literal>ControlPlaneStatus</literal></title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>annotations</literal> parameter stores additional, usually redundant status information, such as the number of components deployed by the <literal>ServiceMeshControlPlane</literal>. These statuses are used by the command line tool, <literal>oc</literal>, which does not yet allow counting objects in JSONPath expressions.</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>conditions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Represents the latest available observations of the object&#8217;s current state. <literal>Reconciled</literal> indicates whether the operator has finished reconciling the actual state of deployed components with the configuration in the <literal>ServiceMeshControlPlane</literal> resource. <literal>Installed</literal> indicates whether the Service Mesh control plane has been installed. <literal>Ready</literal> indicates whether all Service Mesh control plane components are ready.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>components</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shows the status of each deployed Service Mesh control plane component.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>appliedSpec</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The resulting specification of the configuration options after all profiles have been applied.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ControlPlaneSpec</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>appliedValues</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The resulting values.yaml used to generate the charts.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ControlPlaneSpec</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>chartVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the charts that were last processed for this resource.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>observedGeneration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The generation observed by the controller during the most recent reconciliation. The information in the status pertains to this particular generation of the object. The <literal>status.conditions</literal> are not up-to-date if the <literal>status.observedGeneration</literal> field doesn&#8217;t match <literal>metadata.generation</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operatorVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the operator that last processed this resource.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>readiness</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The readiness status of components &amp; owned resources.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>This example <literal>ServiceMeshControlPlane</literal> definition contains all of the supported parameters.</simpara>
<formalpara>
<title>Example <literal>ServiceMeshControlPlane</literal> resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  proxy:
    runtime:
      container:
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 128Mi
  tracing:
    type: Jaeger
  gateways:
    ingress: # istio-ingressgateway
      service:
        type: ClusterIP
        ports:
        - name: status-port
          port: 15020
        - name: http2
          port: 80
          targetPort: 8080
        - name: https
          port: 443
          targetPort: 8443
      meshExpansionPorts: []
    egress: # istio-egressgateway
      service:
        type: ClusterIP
        ports:
        - name: status-port
          port: 15020
        - name: http2
          port: 80
          targetPort: 8080
        - name: https
          port: 443
          targetPort: 8443
    additionalIngress:
      some-other-ingress-gateway: {}
    additionalEgress:
      some-other-egress-gateway: {}

  policy:
    type: Mixer
    mixer: # only applies if policy.type: Mixer
      enableChecks: true
      failOpen: false

  telemetry:
    type: Istiod # or Mixer
    mixer: # only applies if telemetry.type: Mixer, for v1 telemetry
      sessionAffinity: false
      batching:
        maxEntries: 100
        maxTime: 1s
      adapters:
        kubernetesenv: true
        stdio:
          enabled: true
          outputAsJSON: true
  addons:
    grafana:
      enabled: true
      install:
        config:
          env: {}
          envSecrets: {}
        persistence:
          enabled: true
          storageClassName: ""
          accessMode: ReadWriteOnce
          capacity:
            requests:
              storage: 5Gi
        service:
          ingress:
            contextPath: /grafana
            tls:
              termination: reencrypt
    kiali:
      name: kiali
      enabled: true
      install: # install kiali CR if not present
        dashboard:
          viewOnly: false
          enableGrafana: true
          enableTracing: true
          enablePrometheus: true
      service:
        ingress:
          contextPath: /kiali
    jaeger:
      name: jaeger
      install:
        storage:
          type: Elasticsearch # or Memory
          memory:
            maxTraces: 100000
          elasticsearch:
            nodeCount: 3
            storage: {}
            redundancyPolicy: SingleRedundancy
            indexCleaner: {}
        ingress: {} # jaeger ingress configuration
  runtime:
    components:
      pilot:
        deployment:
          replicas: 2
        pod:
          affinity: {}
        container:
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 128Mi
      grafana:
        deployment: {}
        pod: {}
      kiali:
        deployment: {}
        pod: {}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_spec_parameters">
<title>spec parameters</title>
<section xml:id="ossm-cr-general_ossm-reference">
<title>general parameters</title>
<simpara>Here is an example that illustrates the <literal>spec.general</literal> parameters for the <literal>ServiceMeshControlPlane</literal> object and a description of the available parameters with appropriate values.</simpara>
<formalpara>
<title>Example general parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  general:
    logging:
      componentLevels: {}
          # misc: error
      logAsJSON: false
    validationMessages: true</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio general parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">logging:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to configure logging for the Service Mesh control plane components.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">logging:
 componentLevels:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify the component logging level.</simpara></entry>
<entry align="left" valign="top"><simpara>Possible values: <literal>trace</literal>, <literal>debug</literal>, <literal>info</literal>, <literal>warning</literal>, <literal>error</literal>, <literal>fatal</literal>, <literal>panic</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">logging:
 logAsJSON:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to enable or disable JSON logging.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">validationMessages:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to enable or disable validation messages to the status fields of istio.io resources. This can be useful for detecting configuration errors in resources.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-cr-profiles_ossm-reference">
<title>profiles parameters</title>
<simpara>You can create reusable configurations with <literal>ServiceMeshControlPlane</literal> object profiles. If you do not configure the <literal>profile</literal> setting, Red Hat OpenShift Service Mesh uses the default profile.</simpara>
<simpara>Here is an example that illustrates the <literal>spec.profiles</literal> parameter for the <literal>ServiceMeshControlPlane</literal> object:</simpara>
<formalpara>
<title>Example profiles parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  profiles:
  - YourProfileName</programlisting>
</para>
</formalpara>
<simpara>For information about creating profiles, see the <link xlink:href="../../service_mesh/v2x/ossm-profiles-users.xml#ossm-control-plane-profiles_ossm-profiles-users">Creating control plane profiles</link>.</simpara>
<simpara>For more detailed examples of security configuration, see <link xlink:href="../../service_mesh/v2x/ossm-security.xml#ossm-security-mtls_ossm-security">Mutual Transport Layer Security (mTLS)</link>.</simpara>
</section>
<section xml:id="ossm-cr-techPreview_ossm-reference">
<title>techPreview parameters</title>
<simpara>The <literal>spec.techPreview</literal> parameter enables early access to features that are in Technology Preview.</simpara>
<important>
<simpara>Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
</section>
<section xml:id="ossm-cr-tracing_ossm-reference">
<title>tracing parameters</title>
<simpara>The following example illustrates the <literal>spec.tracing</literal> parameters for the <literal>ServiceMeshControlPlane</literal> object, and a description of the available parameters with appropriate values.</simpara>
<formalpara>
<title>Example tracing parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 100
    type: Jaeger</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio tracing parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">tracing:
 sampling:</literallayout></entry>
<entry align="left" valign="top"><simpara>The sampling rate determines how often the Envoy proxy generates a trace. You use the sampling rate to control what percentage of requests get reported to your tracing system.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer values between 0 and 10000 representing increments of 0.01% (0 to 100%). For example, setting the value to <literal>10</literal> samples 0.1% of requests, setting the value to <literal>100</literal> will sample 1% of requests setting the value to <literal>500</literal> samples 5% of requests, and a setting of <literal>10000</literal> samples 100% of requests.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10000</literal> (100% of traces)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">tracing:
 type:</literallayout></entry>
<entry align="left" valign="top"><simpara>Currently the only tracing type that is supported is <literal>Jaeger</literal>. Jaeger is enabled by default. To disable tracing, set the <literal>type</literal> parameter to <literal>None</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>None</literal>, <literal>Jaeger</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Jaeger</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-cr-version_ossm-reference">
<title>version parameter</title>
<simpara>The Red Hat OpenShift Service Mesh Operator supports installation of different versions of the <literal>ServiceMeshControlPlane</literal>. You use the version parameter to specify what version of the Service Mesh control plane to install. If you do not specify a version parameter when creating your SMCP, the Operator sets the value to the latest version: (2.4). Existing <literal>ServiceMeshControlPlane</literal> objects keep their version setting during upgrades of the Operator.</simpara>
</section>
<section xml:id="ossm-cr-threescale_ossm-reference">
<title>3scale configuration</title>
<simpara>The following table explains the parameters for the 3scale Istio Adapter in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Example 3scale parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  addons:
    3Scale:
      enabled: false
      PARAM_THREESCALE_LISTEN_ADDR: 3333
      PARAM_THREESCALE_LOG_LEVEL: info
      PARAM_THREESCALE_LOG_JSON: true
      PARAM_THREESCALE_LOG_GRPC: false
      PARAM_THREESCALE_REPORT_METRICS: true
      PARAM_THREESCALE_METRICS_PORT: 8080
      PARAM_THREESCALE_CACHE_TTL_SECONDS: 300
      PARAM_THREESCALE_CACHE_REFRESH_SECONDS: 180
      PARAM_THREESCALE_CACHE_ENTRIES_MAX: 1000
      PARAM_THREESCALE_CACHE_REFRESH_RETRIES: 1
      PARAM_THREESCALE_ALLOW_INSECURE_CONN: false
      PARAM_THREESCALE_CLIENT_TIMEOUT_SECONDS: 10
      PARAM_THREESCALE_GRPC_CONN_MAX_SECONDS: 60
      PARAM_USE_CACHED_BACKEND: false
      PARAM_BACKEND_CACHE_FLUSH_INTERVAL_SECONDS: 15
      PARAM_BACKEND_CACHE_POLICY_FAIL_CLOSED: true</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>3scale parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to use the 3scale adapter</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LISTEN_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the listen address for the gRPC server</simpara></entry>
<entry align="left" valign="top"><simpara>Valid port number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>3333</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_LEVEL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the minimum log output level.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>debug</literal>, <literal>info</literal>, <literal>warn</literal>, <literal>error</literal>, or <literal>none</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>info</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_JSON</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether the log is formatted as JSON</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_GRPC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether the log contains gRPC info</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_REPORT_METRICS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether 3scale system and backend metrics are collected and reported to Prometheus</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_METRICS_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the port that the 3scale <literal>/metrics</literal> endpoint can be scrapped from</simpara></entry>
<entry align="left" valign="top"><simpara>Valid port number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>8080</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_TTL_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time period, in seconds, to wait before purging expired items from the cache</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>300</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_REFRESH_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time period before expiry when cache elements are attempted to be refreshed</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>180</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_ENTRIES_MAX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Max number of items that can be stored in the cache at any time. Set to <literal>0</literal> to disable caching</simpara></entry>
<entry align="left" valign="top"><simpara>Valid number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_REFRESH_RETRIES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times unreachable hosts are retried during a cache update loop</simpara></entry>
<entry align="left" valign="top"><simpara>Valid number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_ALLOW_INSECURE_CONN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allow to skip certificate verification when calling <literal>3scale</literal> APIs. Enabling this is not recommended.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CLIENT_TIMEOUT_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the number of seconds to wait before terminating requests to 3scale System and Backend</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_GRPC_CONN_MAX_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the maximum amount of seconds (+/-10% jitter) a connection may exist before it is closed</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_USE_CACHE_BACKEND</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If true, attempt to create an in-memory apisonator cache for authorization requests</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_BACKEND_CACHE_FLUSH_INTERVAL_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the backend cache is enabled, this sets the interval in seconds for flushing the cache against 3scale</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_BACKEND_CACHE_POLICY_FAIL_CLOSED</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whenever the backend cache cannot retrieve authorization data, whether to deny (closed) or allow (open) requests</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="ossm-cr-status_ossm-reference">
<title>status parameter</title>
<simpara>The <literal>status</literal> parameter describes the current state of your service mesh. This information is generated by the Operator and is read-only.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio status parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>observedGeneration</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The generation observed by the controller during the most recent reconciliation. The information in the status pertains to this particular generation of the object. The <literal>status.conditions</literal> are not up-to-date if the <literal>status.observedGeneration</literal> field doesn&#8217;t match <literal>metadata.generation</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>annotations</literal> parameter stores additional, usually redundant status information, such as the number of components deployed by the <literal>ServiceMeshControlPlane</literal> object. These statuses are used by the command line tool, <literal>oc</literal>, which does not yet allow counting objects in JSONPath expressions.</simpara></entry>
<entry align="left" valign="top"><simpara>Not configurable</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>readiness</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The readiness status of components and owned resources.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operatorVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the Operator that last processed this resource.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>components</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shows the status of each deployed Service Mesh control plane component.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>appliedSpec</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The resulting specification of the configuration options after all profiles have been applied.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ControlPlaneSpec</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>conditions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Represents the latest available observations of the object&#8217;s current state. <literal>Reconciled</literal> indicates that the Operator has finished reconciling the actual state of deployed components with the configuration in the <literal>ServiceMeshControlPlane</literal> resource. <literal>Installed</literal> indicates that the Service Mesh control plane has been installed. <literal>Ready</literal> indicates that all Service Mesh control plane components are ready.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>chartVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the charts that were last processed for this resource.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>appliedValues</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The resulting <literal>values.yaml</literal> file that was used to generate the charts.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ControlPlaneSpec</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="additional-resources_ossm-reference" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>For more information about how to configure the features in the <literal>ServiceMeshControlPlane</literal> resource, see the following links:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-security.xml#ossm-security-mtls_ossm-security">Security</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-traffic-manage.xml#ossm-routing-bookinfo_traffic-management">Traffic management</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../service_mesh/v2x/ossm-observability.xml#ossm-observability">Metrics and traces</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="kiali-config-ref">
<title>Kiali configuration reference</title>

<simpara>When the Service Mesh Operator creates the <literal>ServiceMeshControlPlane</literal> it also processes the Kiali resource. The Kiali Operator then uses this object when creating Kiali instances.</simpara>
<section xml:id="ossm-smcp-kiali_kiali-config-ref">
<title>Specifying Kiali configuration in the SMCP</title>
<simpara>You can configure Kiali under the <literal>addons</literal> section of the <literal>ServiceMeshControlPlane</literal> resource. Kiali is enabled by default. To disable Kiali, set <literal>spec.addons.kiali.enabled</literal> to <literal>false</literal>.</simpara>
<simpara>You can specify your Kiali configuration in either of two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify the Kiali configuration in the <literal>ServiceMeshControlPlane</literal> resource under <literal>spec.addons.kiali.install</literal>. This approach has some limitations, because the complete list of Kiali configurations is not available in the SMCP.</simpara>
</listitem>
<listitem>
<simpara>Configure and deploy a Kiali instance and specify the name of the Kiali resource as the value for <literal>spec.addons.kiali.name</literal> in the <literal>ServiceMeshControlPlane</literal> resource. You must create the CR in the same namespace as the Service Mesh control plane, for example, <literal>istio-system</literal>. If a Kiali resource matching the value of <literal>name</literal> exists, the control plane will configure that Kiali resource for use with the control plane. This approach lets you fully customize your Kiali configuration in the Kiali resource. Note that with this approach, various fields in the Kiali resource are overwritten by the Service Mesh Operator, specifically, the <literal>accessible_namespaces</literal> list, as well as the endpoints for Grafana, Prometheus, and tracing.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example SMCP parameters for Kiali</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  addons:
    kiali:
      name: kiali
      enabled: true
      install:
        dashboard:
          viewOnly: false
          enableGrafana: true
          enableTracing: true
          enablePrometheus: true
        service:
          ingress:
            contextPath: /kiali</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ServiceMeshControlPlane</literal> Kiali parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  addons:
    kiali:
      name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of Kiali custom resource. If a Kiali CR matching the value of <literal>name</literal> exists, the Service Mesh Operator will use that CR for the installation. If no Kiali CR exists, the Operator will create one using this <literal>name</literal> and the configuration options specified in the SMCP.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kiali</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables or disables Kiali. Kiali is enabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:</literallayout></entry>
<entry align="left" valign="top"><simpara>Install a Kiali resource if the named Kiali resource is not present. The <literal>install</literal> section is ignored if <literal>addons.kiali.enabled</literal> is set to <literal>false</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    dashboard:</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration parameters for the dashboards shipped with Kiali.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    dashboard:
      viewOnly:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables or disables view-only mode for the Kiali console. When view-only mode is enabled, users cannot use the Kiali console to make changes to the Service Mesh.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    dashboard:
      enableGrafana:</literallayout></entry>
<entry align="left" valign="top"><simpara>Grafana endpoint configured based on <literal>spec.addons.grafana</literal> configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    dashboard:
      enablePrometheus:</literallayout></entry>
<entry align="left" valign="top"><simpara>Prometheus endpoint configured based on <literal>spec.addons.prometheus</literal> configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    dashboard:
      enableTracing:</literallayout></entry>
<entry align="left" valign="top"><simpara>Tracing endpoint configured based on Jaeger custom resource configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration parameters for the Kubernetes service associated with the Kiali installation.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      metadata:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify additional metadata to apply to resources.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      metadata:
        annotations:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify additional annotations to apply to the component&#8217;s service.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      metadata:
        labels:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify additional labels to apply to the component&#8217;s service.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      ingress:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify details for accessing the component’s service through an OpenShift Route.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      ingress:
        metadata:
          annotations:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify additional annotations to apply to the component&#8217;s service ingress.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      ingress:
        metadata:
          labels:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify additional labels to apply to the component&#8217;s service ingress.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      ingress:
        enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to customize an OpenShift Route for the service associated with a component.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      ingress:
        contextPath:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify the context path to the service.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">install:
  service:
    ingress:
      hosts:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify a single hostname per OpenShift route. An empty hostname implies a default hostname for the Route.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">install:
  service:
    ingress:
      tls:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to configure the TLS for the OpenShift route.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">kiali:
  install:
    service:
      nodePort:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify the <literal>nodePort</literal> for the component&#8217;s service <literal>Values.&lt;component&gt;.service.nodePort.port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>integer</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-specifying-external-kiali_kiali-config-ref">
<title>Specifying Kiali configuration in a Kiali custom resource</title>
<simpara>You can fully customize your Kiali deployment by configuring Kiali in the Kiali custom resource (CR) rather than in the <literal>ServiceMeshControlPlane</literal> (SMCP) resource. This configuration is sometimes called an "external Kiali" since the configuration is specified outside of the SMCP.</simpara>
<note>
<simpara>You must deploy the <literal>ServiceMeshControlPlane</literal> and Kiali custom resources in the same namespace. For example, <literal>istio-system</literal>.</simpara>
</note>
<simpara>You can configure and deploy a Kiali instance and then specify the <literal>name</literal> of the Kiali resource as the value for <literal>spec.addons.kiali.name</literal> in the SMCP resource. If a Kiali CR matching the value of <literal>name</literal> exists, the Service Mesh control plane will use the existing installation. This approach lets you fully customize your Kiali configuration.</simpara>
</section>
</section>
<section xml:id="jaeger-config-ref">
<title>Jaeger configuration reference</title>

<simpara>When the Service Mesh Operator deploys the <literal>ServiceMeshControlPlane</literal> resource, it can also create the resources for distributed tracing. Service Mesh uses Jaeger for distributed tracing.</simpara>
<important>
<simpara>Jaeger does not use FIPS validated cryptographic modules.</simpara>
</important>
<section xml:id="ossm-enabling-tracing_jaeger-config-reference">
<title>Enabling and disabling tracing</title>
<simpara>You enable distributed tracing by specifying a tracing type and a sampling rate in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Default <literal>all-in-one</literal> Jaeger parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 100
    type: Jaeger</programlisting>
</para>
</formalpara>
<simpara>Currently, the only tracing type that is supported is <literal>Jaeger</literal>.</simpara>
<simpara>Jaeger is enabled by default. To disable tracing, set <literal>type</literal> to <literal>None</literal>.</simpara>
<simpara>The sampling rate determines how often the Envoy proxy generates a trace. You can use the sampling rate option to control what percentage of requests get reported to your tracing system. You can configure this setting based upon your traffic in the mesh and the amount of tracing data you want to collect. You configure <literal>sampling</literal> as a scaled integer representing 0.01% increments. For example, setting the value to <literal>10</literal> samples 0.1% of traces, setting the value to <literal>500</literal> samples 5% of traces, and a setting of <literal>10000</literal> samples 100% of traces.</simpara>
<note>
<simpara>The SMCP sampling configuration option controls the Envoy sampling rate. You configure the Jaeger trace sampling rate in the Jaeger custom resource.</simpara>
</note>
</section>
<section xml:id="ossm-specifying-jaeger-configuration_jaeger-config-reference">
<title>Specifying Jaeger configuration in the SMCP</title>
<simpara>You configure Jaeger under the <literal>addons</literal> section of the <literal>ServiceMeshControlPlane</literal> resource. However, there are some limitations to what you can configure in the SMCP.</simpara>
<simpara>When the SMCP passes configuration information to the Red Hat OpenShift distributed tracing platform (Jaeger) Operator, it triggers one of three deployment strategies: <literal>allInOne</literal>, <literal>production</literal>, or <literal>streaming</literal>.</simpara>
</section>
<section xml:id="ossm-deploying-jaeger_jaeger-config-reference">
<title>Deploying the distributed tracing platform</title>
<simpara>The distributed tracing platform (Jaeger) has predefined deployment strategies. You specify a deployment strategy in the Jaeger custom resource (CR) file. When you create an instance of the distributed tracing platform (Jaeger), the Red Hat OpenShift distributed tracing platform (Jaeger) Operator uses this configuration file to create the objects necessary for the deployment.</simpara>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) Operator currently supports the following deployment strategies:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">allInOne</emphasis> (default) - This strategy is intended for development, testing, and demo purposes and it is not for production use. The main back-end components, Agent, Collector, and Query service, are all packaged into a single executable, which is configured (by default) to use in-memory storage. You can configure this deployment strategy in the SMCP.</simpara>
<note>
<simpara>In-memory storage is not persistent, which means that if the Jaeger instance shuts down, restarts, or is replaced, your trace data will be lost. And in-memory storage cannot be scaled, since each pod has its own memory. For persistent storage, you must use the <literal>production</literal> or <literal>streaming</literal> strategies, which use Elasticsearch as the default storage.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">production</emphasis> - The production strategy is intended for production environments, where long term storage of trace data is important, and a more scalable and highly available architecture is required. Each back-end component is therefore deployed separately. The Agent can be injected as a sidecar on the instrumented application. The Query and Collector services are configured with a supported storage type, which is currently Elasticsearch. Multiple instances of each of these components can be provisioned as required for performance and resilience purposes. You can configure this deployment strategy in the SMCP, but in order to be fully customized, you must specify your configuration in the Jaeger CR and link that to the SMCP.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">streaming</emphasis> - The streaming strategy is designed to augment the production strategy by providing a streaming capability that sits between the Collector and the Elasticsearch back-end storage. This provides the benefit of reducing the pressure on the back-end storage, under high load situations, and enables other trace post-processing capabilities to tap into the real-time span data directly from the streaming platform (<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_amq/7.6/html/using_amq_streams_on_openshift/index">AMQ Streams</link>/ <link xlink:href="https://kafka.apache.org/documentation/">Kafka</link>). You cannot configure this deployment strategy in the SMCP; you must configure a Jaeger CR and link that to the SMCP.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The streaming strategy requires an additional Red Hat subscription for AMQ Streams.</simpara>
</note>
<section xml:id="ossm-deploying-jaeger-default_jaeger-config-reference">
<title>Default distributed tracing platform (Jaeger) deployment</title>
<simpara>If you do not specify Jaeger configuration options, the <literal>ServiceMeshControlPlane</literal> resource will use the <literal>allInOne</literal> Jaeger deployment strategy by default. When using the default <literal>allInOne</literal> deployment strategy, set <literal>spec.addons.jaeger.install.storage.type</literal> to <literal>Memory</literal>. You can accept the defaults or specify additional configuration options under <literal>install</literal>.</simpara>
<formalpara>
<title>Control plane default Jaeger parameters (Memory)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 10000
    type: Jaeger
  addons:
    jaeger:
      name: jaeger
      install:
        storage:
          type: Memory</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-deploying-jaeger-production-min_jaeger-config-reference">
<title>Production distributed tracing platform (Jaeger) deployment (minimal)</title>
<simpara>To use the default settings for the <literal>production</literal> deployment strategy, set <literal>spec.addons.jaeger.install.storage.type</literal> to <literal>Elasticsearch</literal> and specify additional configuration options under <literal>install</literal>. Note that the SMCP only supports configuring Elasticsearch resources and image name.</simpara>
<formalpara>
<title>Control plane default Jaeger parameters (Elasticsearch)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 10000
    type: Jaeger
  addons:
    jaeger:
      name: jaeger  #name of Jaeger CR
      install:
        storage:
          type: Elasticsearch
        ingress:
          enabled: true
  runtime:
    components:
      tracing.jaeger.elasticsearch: # only supports resources and image name
        container:
          resources: {}</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-deploying-jaeger-production_jaeger-config-reference">
<title>Production distributed tracing platform (Jaeger) deployment (fully customized)</title>
<simpara>The SMCP supports only minimal Elasticsearch parameters. To fully customize your production environment and access all of the Elasticsearch configuration parameters, use the Jaeger custom resource (CR) to configure Jaeger.</simpara>
<simpara>Create and configure your Jaeger instance and set <literal>spec.addons.jaeger.name</literal> to the name of the Jaeger instance, in this example: <literal>MyJaegerInstance</literal>.</simpara>
<formalpara>
<title>Control plane with linked Jaeger production CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 1000
    type: Jaeger
  addons:
    jaeger:
      name: MyJaegerInstance #name of Jaeger CR
      install:
        storage:
          type: Elasticsearch
        ingress:
          enabled: true</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-deploying-jaeger-streaming_jaeger-config-reference">
<title>Streaming Jaeger deployment</title>
<simpara>To use the <literal>streaming</literal> deployment strategy, you create and configure your Jaeger instance first, then set <literal>spec.addons.jaeger.name</literal> to the name of the Jaeger instance, in this example: <literal>MyJaegerInstance</literal>.</simpara>
<formalpara>
<title>Control plane with linked Jaeger streaming CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v2
kind: ServiceMeshControlPlane
metadata:
  name: basic
spec:
  version: v2.4
  tracing:
    sampling: 1000
    type: Jaeger
  addons:
    jaeger:
      name: MyJaegerInstance  #name of Jaeger CR</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="ossm-specifying-external-jaeger_jaeger-config-reference">
<title>Specifying Jaeger configuration in a Jaeger custom resource</title>
<simpara>You can fully customize your Jaeger deployment by configuring Jaeger in the Jaeger custom resource (CR) rather than in the <literal>ServiceMeshControlPlane</literal> (SMCP) resource. This configuration is sometimes referred to as an "external Jaeger" since the configuration is specified outside of the SMCP.</simpara>
<note>
<simpara>You must deploy the SMCP and Jaeger CR in the same namespace. For example, <literal>istio-system</literal>.</simpara>
</note>
<simpara>You can configure and deploy a standalone Jaeger instance and then specify the <literal>name</literal> of the Jaeger resource as the value for <literal>spec.addons.jaeger.name</literal> in the SMCP resource. If a Jaeger CR matching the value of <literal>name</literal> exists, the Service Mesh control plane will use the existing installation. This approach lets you fully customize your Jaeger configuration.</simpara>
<section xml:id="distr-tracing-deployment-best-practices_jaeger-config-reference">
<title>Deployment best practices</title>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform instance names must be unique. If you want to have multiple Red Hat OpenShift distributed tracing platform (Jaeger) instances and are using sidecar injected agents, then the Red Hat OpenShift distributed tracing platform (Jaeger) instances should have unique names, and the injection annotation should explicitly specify the Red Hat OpenShift distributed tracing platform (Jaeger) instance name the tracing data should be reported to.</simpara>
</listitem>
<listitem>
<simpara>If you have a multitenant implementation and tenants are separated by namespaces, deploy a Red Hat OpenShift distributed tracing platform (Jaeger) instance to each tenant namespace.</simpara>
</listitem>
</itemizedlist>
<simpara>For information about configuring persistent storage, see <link xlink:href="../../storage/understanding-persistent-storage.xml">Understanding persistent storage</link> and the appropriate configuration topic for your chosen storage option.</simpara>
</section>
<section xml:id="distr-tracing-config-security-ossm_jaeger-config-reference">
<title>Configuring distributed tracing security for service mesh</title>
<simpara>The distributed tracing platform (Jaeger) uses OAuth for default authentication. However Red Hat OpenShift Service Mesh uses a secret called <literal>htpasswd</literal> to facilitate communication between dependent services such as Grafana, Kiali, and the distributed tracing platform (Jaeger). When you configure your distributed tracing platform (Jaeger) in the <literal>ServiceMeshControlPlane</literal> the Service Mesh automatically configures security settings to use <literal>htpasswd</literal>.</simpara>
<simpara>If you are specifying your distributed tracing platform (Jaeger) configuration in a Jaeger custom resource, you must manually configure the <literal>htpasswd</literal> settings and ensure the <literal>htpasswd</literal> secret is mounted into your Jaeger instance so that Kiali can communicate with it.</simpara>
<section xml:id="distr-tracing-config-security-ossm-web_jaeger-config-reference">
<title>Configuring distributed tracing security for service mesh from the web console</title>
<simpara>You can modify the Jaeger resource to configure distributed tracing platform (Jaeger) security for use with Service Mesh in the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ServiceMeshControlPlane</literal> deployed to the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to Operators → Installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where your <literal>ServiceMeshControlPlane</literal> resource is deployed from the list, for example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger) Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Details</emphasis> page, click the <emphasis role="strong">Jaeger</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your Jaeger instance.</simpara>
</listitem>
<listitem>
<simpara>On the Jaeger details page, click the <emphasis role="strong">YAML</emphasis> tab to modify your configuration.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>Jaeger</literal> custom resource file to add the <literal>htpasswd</literal> configuration as shown in the following example.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.ingress.openshift.htpasswdFile</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.volumes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.volumeMounts</literal></simpara>
<formalpara>
<title>Example Jaeger resource showing <literal>htpasswd</literal> configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
spec:
  ingress:
    enabled: true
    openshift:
      htpasswdFile: /etc/proxy/htpasswd/auth
      sar: '{"namespace": "istio-system", "resource": "pods", "verb": "get"}'
    options: {}
    resources: {}
    security: oauth-proxy
  volumes:
    - name: secret-htpasswd
      secret:
        secretName: htpasswd
    - configMap:
        defaultMode: 420
        items:
          - key: ca-bundle.crt
            path: tls-ca-bundle.pem
        name: trusted-ca-bundle
        optional: true
      name: trusted-ca-bundle
  volumeMounts:
    - mountPath: /etc/proxy/htpasswd
      name: secret-htpasswd
    - mountPath: /etc/pki/ca-trust/extracted/pem/
      name: trusted-ca-bundle
      readOnly: true</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="distr-tracing-config-security-ossm-cli_jaeger-config-reference">
<title>Configuring distributed tracing security for service mesh from the command line</title>
<simpara>You can modify the Jaeger resource to configure distributed tracing platform (Jaeger) security for use with Service Mesh from the command line by running the OpenShift CLI (<literal>oc</literal>).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ServiceMeshControlPlane</literal> deployed to the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift CLI (<literal>oc</literal>) that matches your OpenShift Container Platform version.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift CLI (<literal>oc</literal>) as a user with the <literal>cluster-admin</literal> role by running the following command. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Change to the project where you installed the control plane, for example <literal>istio-system</literal>, by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to edit the Jaeger custom resource file, where <literal>jaeger.yaml</literal> is the name of your Jaeger custom resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -n tracing-system -f jaeger.yaml</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>Jaeger</literal> custom resource file to add the <literal>htpasswd</literal> configuration as shown in the following example.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.ingress.openshift.htpasswdFile</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.volumes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.volumeMounts</literal></simpara>
<formalpara>
<title>Example Jaeger resource showing <literal>htpasswd</literal> configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
spec:
  ingress:
    enabled: true
    openshift:
      htpasswdFile: /etc/proxy/htpasswd/auth
      sar: '{"namespace": "istio-system", "resource": "pods", "verb": "get"}'
    options: {}
    resources: {}
    security: oauth-proxy
  volumes:
    - name: secret-htpasswd
      secret:
        secretName: htpasswd
    - configMap:
        defaultMode: 420
        items:
          - key: ca-bundle.crt
            path: tls-ca-bundle.pem
        name: trusted-ca-bundle
        optional: true
      name: trusted-ca-bundle
  volumeMounts:
    - mountPath: /etc/proxy/htpasswd
      name: secret-htpasswd
    - mountPath: /etc/pki/ca-trust/extracted/pem/
      name: trusted-ca-bundle
      readOnly: true</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Run the following command to apply your changes, where &lt;jaeger.yaml&gt; is the name of your Jaeger custom resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n tracing-system -f &lt;jaeger.yaml&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to watch the progress of the pod deployment:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n tracing-system -w</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="distr-tracing-config-default_jaeger-config-reference">
<title>Distributed tracing default configuration options</title>
<simpara>The Jaeger custom resource (CR) defines the architecture and settings to be used when creating the distributed tracing platform (Jaeger) resources. You can modify these parameters to customize your distributed tracing platform (Jaeger) implementation to your business needs.</simpara>
<formalpara>
<title>Generic YAML example of the Jaeger CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: name
spec:
  strategy: &lt;deployment_strategy&gt;
  allInOne:
    options: {}
    resources: {}
  agent:
    options: {}
    resources: {}
  collector:
    options: {}
    resources: {}
  sampling:
    options: {}
  storage:
    type:
    options: {}
  query:
    options: {}
    resources: {}
  ingester:
    options: {}
    resources: {}
  options: {}</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Jaeger parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>API version to use when creating the object.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>jaegertracing.io/v1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>jaegertracing.io/v1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>kind:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines the kind of Kubernetes object to create.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>jaeger</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Data that helps uniquely identify the object, including a <literal>name</literal> string, <literal>UID</literal>, and optional <literal>namespace</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>OpenShift Container Platform automatically generates the <literal>UID</literal> and completes the <literal>namespace</literal> with the name of the project where the object is created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>name:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name for the object.</simpara></entry>
<entry align="left" valign="top"><simpara>The name of your distributed tracing platform (Jaeger) instance.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>jaeger-all-in-one-inmemory</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specification for the object to be created.</simpara></entry>
<entry align="left" valign="top"><simpara>Contains all of the configuration parameters for your distributed tracing platform (Jaeger) instance. When a common definition for all Jaeger components is required, it is defined under the <literal>spec</literal> node. When the definition relates to an individual component, it is placed under the <literal>spec/&lt;component&gt;</literal> node.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>strategy:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Jaeger deployment strategy</simpara></entry>
<entry align="left" valign="top"><simpara><literal>allInOne</literal>, <literal>production</literal>, or <literal>streaming</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>allInOne</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>allInOne:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Because the <literal>allInOne</literal> image deploys the Agent, Collector, Query, Ingester, and Jaeger UI in a single pod, configuration for this deployment must nest component configuration under the <literal>allInOne</literal> parameter.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>agent:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Agent.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>collector:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Jaeger Collector.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sampling:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the sampling strategies for tracing.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storage:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the storage. All storage-related options must be placed under <literal>storage</literal>, rather than under the <literal>allInOne</literal> or other component options.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>query:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Query service.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ingester:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Ingester service.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following example YAML is the minimum required to create a Red Hat OpenShift distributed tracing platform (Jaeger) deployment using the default settings.</simpara>
<formalpara>
<title>Example minimum required dist-tracing-all-in-one.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: jaeger-all-in-one-inmemory</programlisting>
</para>
</formalpara>
</section>
<section xml:id="distr-tracing-config-jaeger-collector_jaeger-config-reference">
<title>Jaeger Collector configuration options</title>
<simpara>The Jaeger Collector is the component responsible for receiving the spans that were captured by the tracer and writing them to persistent Elasticsearch storage when using the <literal>production</literal> strategy, or to AMQ Streams when using the <literal>streaming</literal> strategy.</simpara>
<simpara>The Collectors are stateless and thus many instances of Jaeger Collector can be run in parallel. Collectors require almost no configuration, except for the location of the Elasticsearch cluster.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters used by the Operator to define the Jaeger Collector</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">collector:
  replicas:</literallayout></entry>
<entry align="left" valign="top"><simpara>Specifies the number of Collector replicas to create.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer, for example, <literal>5</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration parameters passed to the Collector</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
 collector:
  options: {}</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Jaeger Collector.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  collector:
    num-workers:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of workers pulling from the queue.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer, for example, <literal>50</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  collector:
    queue-size:</literallayout></entry>
<entry align="left" valign="top"><simpara>The size of the Collector queue.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer, for example, <literal>2000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  kafka:
    producer:
      topic: jaeger-spans</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>topic</literal> parameter identifies the Kafka configuration used by the Collector to produce the messages, and the Ingester to consume the messages.</simpara></entry>
<entry align="left" valign="top"><simpara>Label for the producer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  kafka:
    producer:
      brokers: my-cluster-kafka-brokers.kafka:9092</literallayout></entry>
<entry align="left" valign="top"><simpara>Identifies the Kafka configuration used by the Collector to produce the messages. If brokers are not specified, and you have AMQ Streams 1.4.0+ installed, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator will self-provision Kafka.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  log-level:</literallayout></entry>
<entry align="left" valign="top"><simpara>Logging level for the Collector.</simpara></entry>
<entry align="left" valign="top"><simpara>Possible values: <literal>debug</literal>, <literal>info</literal>, <literal>warn</literal>, <literal>error</literal>, <literal>fatal</literal>, <literal>panic</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  otlp:
    enabled: true
    grpc:
      host-port: 4317
      max-connection-age: 0s
      max-connection-age-grace: 0s
      max-message-size: 4194304
      tls:
        enabled: false
        cert: /path/to/cert.crt
        cipher-suites: "TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256"
        client-ca: /path/to/cert.ca
        reload-interval: 0s
        min-version: 1.2
        max-version: 1.3</literallayout></entry>
<entry align="left" valign="top"><simpara>To accept OTLP/gRPC, explicitly enable the <literal>otlp</literal>. All the other options are optional.</simpara></entry>
<entry align="left" valign="top"><simpara>options:
  otlp:
    enabled: true
    http:
      cors:
        allowed-headers: [&lt;header-name&gt;[, &lt;header-name&gt;]*]
        allowed-origins: *
      host-port: 4318
      max-connection-age: 0s
      max-connection-age-grace: 0s
      max-message-size: 4194304
      read-timeout: 0s
      read-header-timeout: 2s
      idle-timeout: 0s
      tls:
        enabled: false
        cert: /path/to/cert.crt
        cipher-suites: "TLS_AES_256_GCM_SHA384,TLS_CHACHA20_POLY1305_SHA256"
        client-ca: /path/to/cert.ca
        reload-interval: 0s
        min-version: 1.2
        max-version: 1.3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="distr-tracing-config-sampling_jaeger-config-reference">
<title>Distributed tracing sampling configuration options</title>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) Operator can be used to define sampling strategies that will be supplied to tracers that have been configured to use a remote sampler.</simpara>
<simpara>While all traces are generated, only a few are sampled. Sampling a trace marks the trace for further processing and storage.</simpara>
<note>
<simpara>This is not relevant if a trace was started by the Envoy proxy, as the sampling decision is made there. The Jaeger sampling decision is only relevant when the trace is started by an application using the client.</simpara>
</note>
<simpara>When a service receives a request that contains no trace context, the client starts a new trace, assigns it a random trace ID, and makes a sampling decision based on the currently installed sampling strategy. The sampling decision propagates to all subsequent requests in the trace so that other services are not making the sampling decision again.</simpara>
<simpara>distributed tracing platform (Jaeger) libraries support the following samplers:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Probabilistic</emphasis> - The sampler makes a random sampling decision with the probability of sampling equal to the value of the <literal>sampling.param</literal> property. For example, using <literal>sampling.param=0.1</literal> samples approximately 1 in 10 traces.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Rate Limiting</emphasis> - The sampler uses a leaky bucket rate limiter to ensure that traces are sampled with a certain constant rate. For example, using <literal>sampling.param=2.0</literal> samples requests with the rate of 2 traces per second.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Jaeger sampling options</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
 sampling:
  options: {}
    default_strategy:
    service_strategy:</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the sampling strategies for tracing.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>If you do not provide configuration, the Collectors will return the default probabilistic sampling policy with 0.001 (0.1%) probability for all services.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">default_strategy:
  type:
service_strategy:
  type:</literallayout></entry>
<entry align="left" valign="top"><simpara>Sampling strategy to use. See descriptions above.</simpara></entry>
<entry align="left" valign="top"><simpara>Valid values are <literal>probabilistic</literal>, and <literal>ratelimiting</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>probabilistic</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">default_strategy:
  param:
service_strategy:
  param:</literallayout></entry>
<entry align="left" valign="top"><simpara>Parameters for the selected sampling strategy.</simpara></entry>
<entry align="left" valign="top"><simpara>Decimal and integer values (0, .1, 1, 10)</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>This example defines a default sampling strategy that is probabilistic, with a 50% chance of the trace instances being sampled.</simpara>
<formalpara>
<title>Probabilistic sampling example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: with-sampling
spec:
  sampling:
    options:
      default_strategy:
        type: probabilistic
        param: 0.5
      service_strategies:
        - service: alpha
          type: probabilistic
          param: 0.8
          operation_strategies:
            - operation: op1
              type: probabilistic
              param: 0.2
            - operation: op2
              type: probabilistic
              param: 0.4
        - service: beta
          type: ratelimiting
          param: 5</programlisting>
</para>
</formalpara>
<simpara>If there are no user-supplied configurations, the distributed tracing platform (Jaeger) uses the following settings:</simpara>
<formalpara>
<title>Default sampling</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  sampling:
    options:
      default_strategy:
        type: probabilistic
        param: 1</programlisting>
</para>
</formalpara>
</section>
<section xml:id="distr-tracing-config-storage_jaeger-config-reference">
<title>Distributed tracing storage configuration options</title>
<simpara>You configure storage for the Collector, Ingester, and Query services under <literal>spec.storage</literal>. Multiple instances of each of these components can be provisioned as required for performance and resilience purposes.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>General storage parameters used by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator to define distributed tracing storage</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  storage:
    type:</literallayout></entry>
<entry align="left" valign="top"><simpara>Type of storage to use for the deployment.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal> or <literal>elasticsearch</literal>.
Memory storage is only appropriate for development, testing, demonstrations, and proof of concept environments as the data does not persist if the pod is shut down. For production environments distributed tracing platform (Jaeger) supports Elasticsearch for persistent storage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">storage:
  secretname:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the secret, for example <literal>tracing-secret</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">storage:
  options: {}</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the storage.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Elasticsearch index cleaner parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">storage:
  esIndexCleaner:
    enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>When using Elasticsearch storage, by default a job is created to clean old traces from the index. This parameter enables or disables the index cleaner job.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">storage:
  esIndexCleaner:
    numberOfDays:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of days to wait before deleting an index.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer value</simpara></entry>
<entry align="left" valign="top"><simpara><literal>7</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">storage:
  esIndexCleaner:
    schedule:</literallayout></entry>
<entry align="left" valign="top"><simpara>Defines the schedule for how often to clean the Elasticsearch index.</simpara></entry>
<entry align="left" valign="top"><simpara>Cron expression</simpara></entry>
<entry align="left" valign="top"><simpara>"55 23 * * *"</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="distributed-tracing-config-auto-provisioning-es_jaeger-config-reference">
<title>Auto-provisioning an Elasticsearch instance</title>
<simpara>When you deploy a Jaeger custom resource, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator uses the OpenShift Elasticsearch Operator to create an Elasticsearch cluster based on the configuration provided in the <literal>storage</literal> section of the custom resource file. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator will provision Elasticsearch if the following configurations are set:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.storage:type</literal> is set to <literal>elasticsearch</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.storage.elasticsearch.doNotProvision</literal> set to <literal>false</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.storage.options.es.server-urls</literal> is not defined, that is, there is no connection to an Elasticsearch instance that was not provisioned by the Red Hat Elasticsearch Operator.</simpara>
</listitem>
</itemizedlist>
<simpara>When provisioning Elasticsearch, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator sets the Elasticsearch custom resource <literal>name</literal> to the value of <literal>spec.storage.elasticsearch.name</literal> from the Jaeger custom resource.  If you do not specify a value for <literal>spec.storage.elasticsearch.name</literal>, the Operator uses <literal>elasticsearch</literal>.</simpara>
<itemizedlist>
<title>Restrictions</title>
<listitem>
<simpara>You can have only one distributed tracing platform (Jaeger) with self-provisioned Elasticsearch instance per namespace. The Elasticsearch cluster is meant to be dedicated for a single distributed tracing platform (Jaeger) instance.</simpara>
</listitem>
<listitem>
<simpara>There can be only one Elasticsearch per namespace.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you already have installed Elasticsearch as part of OpenShift Logging, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator can use the installed OpenShift Elasticsearch Operator to provision storage.</simpara>
</note>
<simpara>The following configuration parameters are for a <emphasis>self-provisioned</emphasis> Elasticsearch instance, that is an instance created by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator using the OpenShift Elasticsearch Operator. You specify configuration options for self-provisioned Elasticsearch under <literal>spec:storage:elasticsearch</literal> in your configuration file.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Elasticsearch resource configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  properties:
    doNotProvision:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify whether or not an Elasticsearch instance should be provisioned by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  properties:
    name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Name of the Elasticsearch instance. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator uses the Elasticsearch instance specified in this parameter to connect to Elasticsearch.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>elasticsearch</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  nodeCount:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of Elasticsearch nodes. For high availability use at least 3 nodes. Do not use 2 nodes as “split brain” problem can happen.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer value. For example, Proof of concept = 1,
Minimum deployment =3</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  resources:
    requests:
      cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of central processing units for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores, for example, 200m, 0.5, 1. For example, Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  resources:
    requests:
      memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes, for example, 200Ki, 50Mi, 5Gi. For example, Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
<entry align="left" valign="top"><simpara>16Gi</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  resources:
    limits:
      cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Limit on number of central processing units, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores, for example, 200m, 0.5, 1. For example, Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  resources:
    limits:
      memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory limit based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes, for example, 200Ki, 50Mi, 5Gi. For example, Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  redundancyPolicy:</literallayout></entry>
<entry align="left" valign="top"><simpara>Data replication policy defines how Elasticsearch shards are replicated across data nodes in the cluster. If not specified, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator automatically determines the most appropriate replication based on number of nodes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ZeroRedundancy</literal>(no replica shards), <literal>SingleRedundancy</literal>(one replica shard), <literal>MultipleRedundancy</literal>(each index is spread over half of the Data nodes), <literal>FullRedundancy</literal> (each index is fully replicated on every Data node in the cluster).</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  useCertManagement:</literallayout></entry>
<entry align="left" valign="top"><simpara>Use to specify whether or not distributed tracing platform (Jaeger) should use the certificate management feature of the Red Hat Elasticsearch Operator.  This feature was added to {logging-title} 5.2 in OpenShift Container Platform 4.7 and is the preferred setting for new Jaeger deployments.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Each Elasticsearch node can operate with a lower memory setting though this is NOT recommended for production deployments. For production use, you must have no less than 16 Gi allocated to each pod by default, but preferably allocate as much as you can, up to 64 Gi per pod.</simpara>
<formalpara>
<title>Production storage example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simple-prod
spec:
  strategy: production
  storage:
    type: elasticsearch
    elasticsearch:
      nodeCount: 3
      resources:
        requests:
          cpu: 1
          memory: 16Gi
        limits:
          memory: 16Gi</programlisting>
</para>
</formalpara>
<formalpara>
<title>Storage example with persistent storage:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simple-prod
spec:
  strategy: production
  storage:
    type: elasticsearch
    elasticsearch:
      nodeCount: 1
      storage: <co xml:id="CO22-1"/>
        storageClassName: gp2
        size: 5Gi
      resources:
        requests:
          cpu: 200m
          memory: 4Gi
        limits:
          memory: 4Gi
      redundancyPolicy: ZeroRedundancy</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para>Persistent storage configuration. In this case AWS <literal>gp2</literal> with <literal>5Gi</literal> size. When no value is specified, distributed tracing platform (Jaeger) uses <literal>emptyDir</literal>. The OpenShift Elasticsearch Operator provisions <literal>PersistentVolumeClaim</literal> and <literal>PersistentVolume</literal> which are not removed with distributed tracing platform (Jaeger) instance. You can mount the same volumes if you create a distributed tracing platform (Jaeger) instance with the same name and namespace.</para>
</callout>
</calloutlist>
</section>
<section xml:id="distributed-tracing-config-external-es_jaeger-config-reference">
<title>Connecting to an existing Elasticsearch instance</title>
<simpara>You can use an existing Elasticsearch cluster for storage with distributed tracing platform. An existing Elasticsearch cluster, also known as an <emphasis>external</emphasis> Elasticsearch instance, is an instance that was not installed by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator or by the Red Hat Elasticsearch Operator.</simpara>
<simpara>When you deploy a Jaeger custom resource, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator will not provision Elasticsearch if the following configurations are set:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.storage.elasticsearch.doNotProvision</literal> set to <literal>true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.storage.options.es.server-urls</literal> has a value</simpara>
</listitem>
<listitem>
<simpara><literal>spec.storage.elasticsearch.name</literal> has a value, or if the Elasticsearch instance name is <literal>elasticsearch</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) Operator uses the Elasticsearch instance specified in <literal>spec.storage.elasticsearch.name</literal> to connect to Elasticsearch.</simpara>
<itemizedlist>
<title>Restrictions</title>
<listitem>
<simpara>You cannot share or reuse a OpenShift Container Platform logging Elasticsearch instance with distributed tracing platform (Jaeger). The Elasticsearch cluster is meant to be dedicated for a single distributed tracing platform (Jaeger) instance.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Red Hat does not provide support for your external Elasticsearch instance. You can review the tested integrations matrix on the <link xlink:href="https://access.redhat.com/articles/5381021">Customer Portal</link>.</simpara>
</note>
<simpara>The following configuration parameters are for an already existing Elasticsearch instance, also known as an <emphasis>external</emphasis> Elasticsearch instance. In this case, you specify configuration options for Elasticsearch under <literal>spec:storage:options:es</literal> in your custom resource file.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>General ES configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  server-urls:</literallayout></entry>
<entry align="left" valign="top"><simpara>URL of the Elasticsearch instance.</simpara></entry>
<entry align="left" valign="top"><simpara>The fully-qualified domain name of the Elasticsearch server.</simpara></entry>
<entry align="left" valign="top"><simpara><literal><link xlink:href="http://elasticsearch.&lt;namespace&gt;.svc:9200">http://elasticsearch.&lt;namespace&gt;.svc:9200</link></literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  max-doc-count:</literallayout></entry>
<entry align="left" valign="top"><simpara>The maximum document count to return from an Elasticsearch query. This will also apply to aggregations. If you set both <literal>es.max-doc-count</literal> and <literal>es.max-num-spans</literal>, Elasticsearch will use the smaller value of the two.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  max-num-spans:</literallayout></entry>
<entry align="left" valign="top"><simpara>[<emphasis role="strong">Deprecated</emphasis> - Will be removed in a future release, use <literal>es.max-doc-count</literal> instead.] The maximum number of spans to fetch at a time, per query, in Elasticsearch. If you set both <literal>es.max-num-spans</literal> and <literal>es.max-doc-count</literal>, Elasticsearch will use the smaller value of the two.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>10000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  max-span-age:</literallayout></entry>
<entry align="left" valign="top"><simpara>The maximum lookback for spans in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>72h0m0s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  sniffer:</literallayout></entry>
<entry align="left" valign="top"><simpara>The sniffer configuration for Elasticsearch. The client uses the sniffing process to find all nodes automatically. Disabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  sniffer-tls-enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Option to enable TLS when sniffing an Elasticsearch Cluster. The client uses the sniffing process to find all nodes automatically. Disabled by default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  timeout:</literallayout></entry>
<entry align="left" valign="top"><simpara>Timeout used for queries. When set to zero there is no timeout.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  username:</literallayout></entry>
<entry align="left" valign="top"><simpara>The username required by Elasticsearch. The basic authentication also loads CA if it is specified. See also <literal>es.password</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  password:</literallayout></entry>
<entry align="left" valign="top"><simpara>The password required by Elasticsearch. See also, <literal>es.username</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  version:</literallayout></entry>
<entry align="left" valign="top"><simpara>The major Elasticsearch version. If not specified, the value will be auto-detected from Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ES data replication parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  num-replicas:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of replicas per index in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  num-shards:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of shards per index in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ES index configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  create-index-templates:</literallayout></entry>
<entry align="left" valign="top"><simpara>Automatically create index templates at application startup when set to <literal>true</literal>. When templates are installed manually, set to <literal>false</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  index-prefix:</literallayout></entry>
<entry align="left" valign="top"><simpara>Optional prefix for distributed tracing platform (Jaeger) indices. For example, setting this to "production" creates indices named "production-tracing-*".</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ES bulk processor configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  bulk:
    actions:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of requests that can be added to the queue before the bulk processor decides to commit updates to disk.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>1000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  bulk:
    flush-interval:</literallayout></entry>
<entry align="left" valign="top"><simpara>A <literal>time.Duration</literal> after which bulk requests are committed, regardless of other thresholds. To disable the bulk processor flush interval, set this to zero.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>200ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  bulk:
    size:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of bytes that the bulk requests can take up before the bulk processor decides to commit updates to disk.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>5000000</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  bulk:
    workers:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of workers that are able to receive and commit bulk requests to Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ES TLS configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  tls:
    ca:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Certification Authority (CA) file used to verify the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Will use the system truststore by default.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  tls:
    cert:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Certificate file, used to identify this process to the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  tls:
    enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Enable transport layer security (TLS) when talking to the remote servers. Disabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  tls:
    key:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Private Key file, used to identify this process to the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  tls:
    server-name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Override the expected TLS server name in the certificate of the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es:
  token-file:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a file containing the bearer token. This flag also loads the Certification Authority (CA) file if it is specified.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>ES archive configuration parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  bulk:
    actions:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of requests that can be added to the queue before the bulk processor decides to commit updates to disk.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  bulk:
    flush-interval:</literallayout></entry>
<entry align="left" valign="top"><simpara>A <literal>time.Duration</literal> after which bulk requests are committed, regardless of other thresholds. To disable the bulk processor flush interval, set this to zero.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  bulk:
    size:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of bytes that the bulk requests can take up before the bulk processor decides to commit updates to disk.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  bulk:
    workers:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of workers that are able to receive and commit bulk requests to Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  create-index-templates:</literallayout></entry>
<entry align="left" valign="top"><simpara>Automatically create index templates at application startup when set to <literal>true</literal>. When templates are installed manually, set to <literal>false</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Enable extra storage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  index-prefix:</literallayout></entry>
<entry align="left" valign="top"><simpara>Optional prefix for distributed tracing platform (Jaeger) indices. For example, setting this to "production" creates indices named "production-tracing-*".</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  max-doc-count:</literallayout></entry>
<entry align="left" valign="top"><simpara>The maximum document count to return from an Elasticsearch query. This will also apply to aggregations.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  max-num-spans:</literallayout></entry>
<entry align="left" valign="top"><simpara>[<emphasis role="strong">Deprecated</emphasis> - Will be removed in a future release, use <literal>es-archive.max-doc-count</literal> instead.] The maximum number of spans to fetch at a time, per query, in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  max-span-age:</literallayout></entry>
<entry align="left" valign="top"><simpara>The maximum lookback for spans in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  num-replicas:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of replicas per index in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  num-shards:</literallayout></entry>
<entry align="left" valign="top"><simpara>The number of shards per index in Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  password:</literallayout></entry>
<entry align="left" valign="top"><simpara>The password required by Elasticsearch. See also, <literal>es.username</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  server-urls:</literallayout></entry>
<entry align="left" valign="top"><simpara>The comma-separated list of Elasticsearch servers. Must be specified as fully qualified URLs, for example, <literal>http://localhost:9200</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  sniffer:</literallayout></entry>
<entry align="left" valign="top"><simpara>The sniffer configuration for Elasticsearch. The client uses the sniffing process to find all nodes automatically. Disabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  sniffer-tls-enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Option to enable TLS when sniffing an Elasticsearch Cluster. The client uses the sniffing process to find all nodes automatically. Disabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  timeout:</literallayout></entry>
<entry align="left" valign="top"><simpara>Timeout used for queries. When set to zero there is no timeout.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  tls:
    ca:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Certification Authority (CA) file used to verify the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Will use the system truststore by default.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  tls:
    cert:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Certificate file, used to identify this process to the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  tls:
    enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>Enable transport layer security (TLS) when talking to the remote servers. Disabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/ <literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  tls:
    key:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a TLS Private Key file, used to identify this process to the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  tls:
    server-name:</literallayout></entry>
<entry align="left" valign="top"><simpara>Override the expected TLS server name in the certificate of the remote servers.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  token-file:</literallayout></entry>
<entry align="left" valign="top"><simpara>Path to a file containing the bearer token. This flag also loads the Certification Authority (CA) file if it is specified.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  username:</literallayout></entry>
<entry align="left" valign="top"><simpara>The username required by Elasticsearch. The basic authentication also loads CA if it is specified. See also <literal>es-archive.password</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">es-archive:
  version:</literallayout></entry>
<entry align="left" valign="top"><simpara>The major Elasticsearch version. If not specified, the value will be auto-detected from Elasticsearch.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Storage example with volume mounts</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simple-prod
spec:
  strategy: production
  storage:
    type: elasticsearch
    options:
      es:
        server-urls: https://quickstart-es-http.default.svc:9200
        index-prefix: my-prefix
        tls:
          ca: /es/certificates/ca.crt
    secretName: tracing-secret
  volumeMounts:
    - name: certificates
      mountPath: /es/certificates/
      readOnly: true
  volumes:
    - name: certificates
      secret:
        secretName: quickstart-es-http-certs-public</programlisting>
</para>
</formalpara>
<simpara>The following example shows a Jaeger CR using an external Elasticsearch cluster with TLS CA certificate mounted from a volume and user/password stored in a secret.</simpara>
<formalpara>
<title>External Elasticsearch example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simple-prod
spec:
  strategy: production
  storage:
    type: elasticsearch
    options:
      es:
        server-urls: https://quickstart-es-http.default.svc:9200 <co xml:id="CO23-1"/>
        index-prefix: my-prefix
        tls: <co xml:id="CO23-2"/>
          ca: /es/certificates/ca.crt
    secretName: tracing-secret <co xml:id="CO23-3"/>
  volumeMounts: <co xml:id="CO23-4"/>
    - name: certificates
      mountPath: /es/certificates/
      readOnly: true
  volumes:
    - name: certificates
      secret:
        secretName: quickstart-es-http-certs-public</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para>URL to Elasticsearch service running in default namespace.</para>
</callout>
<callout arearefs="CO23-2">
<para>TLS configuration. In this case only CA certificate, but it can also contain es.tls.key and es.tls.cert when using mutual TLS.</para>
</callout>
<callout arearefs="CO23-3">
<para>Secret which defines environment variables ES_PASSWORD and ES_USERNAME. Created by kubectl create secret generic tracing-secret --from-literal=ES_PASSWORD=changeme --from-literal=ES_USERNAME=elastic</para>
</callout>
<callout arearefs="CO23-4">
<para>Volume mounts and volumes which are mounted into all storage components.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="distr-tracing-manage-es-certificates_jaeger-config-reference">
<title>Managing certificates with Elasticsearch</title>
<simpara>You can create and manage certificates using the Red Hat Elasticsearch Operator. Managing certificates using the Red Hat Elasticsearch Operator also lets you use a single Elasticsearch cluster with multiple Jaeger Collectors.</simpara>
<important>
<simpara>Managing certificates with Elasticsearch is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Starting with version 2.4, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator delegates certificate creation to the Red Hat Elasticsearch Operator by using the following annotations in the Elasticsearch custom resource:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>logging.openshift.io/elasticsearch-cert-management: "true"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>logging.openshift.io/elasticsearch-cert.jaeger-&lt;shared-es-node-name&gt;: "user.jaeger"</literal></simpara>
</listitem>
<listitem>
<simpara><literal>logging.openshift.io/elasticsearch-cert.curator-&lt;shared-es-node-name&gt;: "system.logging.curator"</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Where the <literal>&lt;shared-es-node-name&gt;</literal> is the name of the Elasticsearch node. For example, if you create an Elasticsearch node named <literal>custom-es</literal>, your custom resource might look like the following example.</simpara>
<formalpara>
<title>Example Elasticsearch CR showing annotations</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: Elasticsearch
metadata:
  annotations:
    logging.openshift.io/elasticsearch-cert-management: "true"
    logging.openshift.io/elasticsearch-cert.jaeger-custom-es: "user.jaeger"
    logging.openshift.io/elasticsearch-cert.curator-custom-es: "system.logging.curator"
  name: custom-es
spec:
  managementState: Managed
  nodeSpec:
    resources:
      limits:
        memory: 16Gi
      requests:
        cpu: 1
        memory: 16Gi
  nodes:
    - nodeCount: 3
      proxyResources: {}
      resources: {}
      roles:
        - master
        - client
        - data
      storage: {}
  redundancyPolicy: ZeroRedundancy</programlisting>
</para>
</formalpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>OpenShift Container Platform 4.7</simpara>
</listitem>
<listitem>
<simpara>{logging-title} 5.2</simpara>
</listitem>
<listitem>
<simpara>The Elasticsearch node and the Jaeger instances must be deployed in the same namespace.  For example, <literal>tracing-system</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>You enable certificate management by setting <literal>spec.storage.elasticsearch.useCertManagement</literal> to <literal>true</literal> in the Jaeger custom resource.</simpara>
<formalpara>
<title>Example showing <literal>useCertManagement</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: jaeger-prod
spec:
  strategy: production
  storage:
    type: elasticsearch
    elasticsearch:
      name: custom-es
      doNotProvision: true
      useCertManagement: true</programlisting>
</para>
</formalpara>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) Operator sets the Elasticsearch custom resource <literal>name</literal> to the value of <literal>spec.storage.elasticsearch.name</literal> from the Jaeger custom resource when provisioning Elasticsearch.</simpara>
<simpara>The certificates are provisioned by the Red Hat Elasticsearch Operator and the Red Hat OpenShift distributed tracing platform (Jaeger) Operator injects the certificates.</simpara>
<simpara>For more information about configuring Elasticsearch with OpenShift Container Platform, see <link xlink:href="../../logging/log_storage/logging-config-es-store.xml#logging-config-es-store">Configuring the Elasticsearch log store</link> or <link xlink:href="../../distr_tracing/distr_tracing_jaeger/distr-tracing-jaeger-configuring.xml">Configuring and deploying distributed tracing</link>.</simpara>
</section>
<section xml:id="distr-tracing-config-query_jaeger-config-reference">
<title>Query configuration options</title>
<simpara>Query is a service that retrieves traces from storage and hosts the user interface to display them.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Parameters used by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator to define Query</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  query:
    replicas:</literallayout></entry>
<entry align="left" valign="top"><simpara>Specifies the number of Query replicas to create.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer, for example, <literal>2</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration parameters passed to Query</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  query:
    options: {}</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Query service.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  log-level:</literallayout></entry>
<entry align="left" valign="top"><simpara>Logging level for Query.</simpara></entry>
<entry align="left" valign="top"><simpara>Possible values: <literal>debug</literal>, <literal>info</literal>, <literal>warn</literal>, <literal>error</literal>, <literal>fatal</literal>, <literal>panic</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  query:
    base-path:</literallayout></entry>
<entry align="left" valign="top"><simpara>The base path for all jaeger-query HTTP routes can be set to a non-root value, for example, <literal>/jaeger</literal> would cause all UI URLs to start with <literal>/jaeger</literal>. This can be useful when running jaeger-query behind a reverse proxy.</simpara></entry>
<entry align="left" valign="top"><simpara>/&lt;path&gt;</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Sample Query configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: "Jaeger"
metadata:
  name: "my-jaeger"
spec:
  strategy: allInOne
  allInOne:
    options:
      log-level: debug
      query:
        base-path: /jaeger</programlisting>
</para>
</formalpara>
</section>
<section xml:id="distr-tracing-config-ingester_jaeger-config-reference">
<title>Ingester configuration options</title>
<simpara>Ingester is a service that reads from a Kafka topic and writes to the Elasticsearch storage backend. If you are using the <literal>allInOne</literal> or <literal>production</literal> deployment strategies, you do not need to configure the Ingester service.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Jaeger parameters passed to the Ingester</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  ingester:
    options: {}</literallayout></entry>
<entry align="left" valign="top"><simpara>Configuration options that define the Ingester service.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  deadlockInterval:</literallayout></entry>
<entry align="left" valign="top"><simpara>Specifies the interval, in seconds or minutes, that the Ingester must wait for a message before terminating.
The deadlock interval is disabled by default (set to <literal>0</literal>), to avoid terminating the Ingester when no messages arrive during system initialization.</simpara></entry>
<entry align="left" valign="top"><simpara>Minutes and seconds, for example, <literal>1m0s</literal>. Default value is <literal>0</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  kafka:
    consumer:
      topic:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>topic</literal> parameter identifies the Kafka configuration used by the collector to produce the messages, and the Ingester to consume the messages.</simpara></entry>
<entry align="left" valign="top"><simpara>Label for the consumer. For example, <literal>jaeger-spans</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  kafka:
    consumer:
      brokers:</literallayout></entry>
<entry align="left" valign="top"><simpara>Identifies the Kafka configuration used by the Ingester to consume the messages.</simpara></entry>
<entry align="left" valign="top"><simpara>Label for the broker, for example, <literal>my-cluster-kafka-brokers.kafka:9092</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">options:
  log-level:</literallayout></entry>
<entry align="left" valign="top"><simpara>Logging level for the Ingester.</simpara></entry>
<entry align="left" valign="top"><simpara>Possible values: <literal>debug</literal>, <literal>info</literal>, <literal>warn</literal>, <literal>error</literal>, <literal>fatal</literal>, <literal>dpanic</literal>, <literal>panic</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Streaming Collector and Ingester example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: simple-streaming
spec:
  strategy: streaming
  collector:
    options:
      kafka:
        producer:
          topic: jaeger-spans
          brokers: my-cluster-kafka-brokers.kafka:9092
  ingester:
    options:
      kafka:
        consumer:
          topic: jaeger-spans
          brokers: my-cluster-kafka-brokers.kafka:9092
      ingester:
        deadlockInterval: 5
  storage:
    type: elasticsearch
    options:
      es:
        server-urls: http://elasticsearch:9200</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="removing-ossm">
<title>Uninstalling Service Mesh</title>

<simpara>To uninstall Red Hat OpenShift Service Mesh from an existing OpenShift Container Platform instance and remove its resources, you must delete the control plane, delete the Operators, and run commands to manually remove some resources.</simpara>
<section xml:id="ossm-control-plane-remove_removing-ossm">
<title>Removing the Red Hat OpenShift Service Mesh control plane</title>
<simpara>To uninstall Service Mesh from an existing OpenShift Container Platform instance, first you delete the Service Mesh control plane and the Operators. Then, you run commands to remove residual resources.</simpara>
<section xml:id="ossm-control-plane-remove-operatorhub_removing-ossm">
<title>Removing the Service Mesh control plane using the web console</title>
<simpara>You can remove the Red Hat OpenShift Service Mesh control plane by using the web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Service Mesh Control Plane</emphasis> under <emphasis role="strong">Provided APIs</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>ServiceMeshControlPlane</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Delete Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Delete</emphasis> on the confirmation dialog window to remove the <literal>ServiceMeshControlPlane</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-control-plane-remove-cli_removing-ossm">
<title>Removing the Service Mesh control plane using the CLI</title>
<simpara>You can remove the Red Hat OpenShift Service Mesh control plane by using the CLI.  In this example, <literal>istio-system</literal> is the name of the control plane project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to delete the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete smmr -n istio-system default</programlisting>
</listitem>
<listitem>
<simpara>Run this command to retrieve the name of the installed <literal>ServiceMeshControlPlane</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Replace <literal>&lt;name_of_custom_resource&gt;</literal> with the output from the previous command, and run this command to remove the custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete smcp -n istio-system &lt;name_of_custom_resource&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-operatorhub-remove-operators_removing-ossm">
<title>Removing the installed Operators</title>
<simpara>You must remove the Operators to successfully remove Red Hat OpenShift Service Mesh. After you remove the Red Hat OpenShift Service Mesh Operator, you must remove the Kiali Operator, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator, and the OpenShift Elasticsearch Operator.</simpara>
<section xml:id="ossm-remove-operator-servicemesh_removing-ossm">
<title>Removing the Operators</title>
<simpara>Follow this procedure to remove the Operators that make up Red Hat OpenShift Service Mesh. Repeat the steps for each of the following Operators.</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Service Mesh</simpara>
</listitem>
<listitem>
<simpara>Kiali</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform (Jaeger)</simpara>
</listitem>
<listitem>
<simpara>OpenShift Elasticsearch</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis> page, scroll or type a keyword into the <emphasis role="strong">Filter by name</emphasis> to find each Operator. Then, click the Operator name.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Details</emphasis> page, select <emphasis role="strong">Uninstall Operator</emphasis> from the <emphasis role="strong">Actions</emphasis> menu. Follow the prompts to uninstall each Operator.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-remove-cleanup_removing-ossm">
<title>Clean up Operator resources</title>
<simpara>You can manually remove resources left behind after removing the Red Hat OpenShift Service Mesh Operator using the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An account with cluster administration access. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a cluster administrator.</simpara>
</listitem>
<listitem>
<simpara>Run the following commands to clean up resources after uninstalling the Operators. If you intend to keep using distributed tracing platform (Jaeger) as a stand-alone service without service mesh, do not delete the Jaeger resources.</simpara>
<note>
<simpara>The OpenShift Elasticsearch Operator is installed in <literal>openshift-operators-redhat</literal> by default. The other Operators are installed in the <literal>openshift-operators</literal> namespace by default. If you installed the Operators in another namespace, replace <literal>openshift-operators</literal> with the name of the project where the Red Hat OpenShift Service Mesh Operator was installed.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete validatingwebhookconfiguration/openshift-operators.servicemesh-resources.maistra.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete mutatingwebhookconfiguration/openshift-operators.servicemesh-resources.maistra.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete svc maistra-admission-controller -n openshift-operators</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-operators delete ds -lmaistra-version</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole/istio-admin clusterrole/istio-cni clusterrolebinding/istio-cni clusterrole/ossm-cni clusterrolebinding/ossm-cni</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole istio-view istio-edit</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole jaegers.jaegertracing.io-v1-admin jaegers.jaegertracing.io-v1-crdview jaegers.jaegertracing.io-v1-edit jaegers.jaegertracing.io-v1-view</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.istio\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.maistra\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.kiali\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crds jaegers.jaegertracing.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete cm -n openshift-operators maistra-operator-cabundle</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete cm -n openshift-operators -lmaistra-version</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete sa -n openshift-operators -lmaistra-version</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="_service_mesh_1_x">
<title>Service Mesh 1.x</title>
<section xml:id="service-mesh-release-notes-v1x">
<title>Service Mesh Release Notes</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<section xml:id="_making_open_source_more_inclusive">
<title>Making open source more inclusive</title>
<simpara>Red Hat is committed to replacing problematic language in our code, documentation, and web properties. We are beginning with these four terms: master, slave, blacklist, and whitelist. Because of the enormity of this endeavor, these changes will be implemented gradually over several upcoming releases. For more details, see <link xlink:href="https://www.redhat.com/en/blog/making-open-source-more-inclusive-eradicating-problematic-language">our CTO Chris Wright&#8217;s message</link>.</simpara>
</section>
<section xml:id="ossm-servicemesh-overview_ossm-release-notes-v1x">
<title>Introduction to Red Hat OpenShift Service Mesh</title>
<simpara>Red Hat OpenShift Service Mesh addresses a variety of problems in a microservice architecture by creating a centralized point of control in an application. It adds a transparent layer on existing distributed applications without requiring any changes to the application code.</simpara>
<simpara>Microservice architectures split the work of enterprise applications into modular services, which can make scaling and maintenance easier. However, as an enterprise application built on a microservice architecture grows in size and complexity, it becomes difficult to understand and manage. Service Mesh can address those architecture problems by capturing or intercepting traffic between services and can modify, redirect, or create new requests to other services.</simpara>
<simpara>Service Mesh, which is based on the open source <link xlink:href="https://istio.io/">Istio project</link>, provides an easy way to create a network of deployed services that provides discovery, load balancing, service-to-service authentication, failure recovery, metrics, and monitoring. A service mesh also provides more complex operational functionality, including A/B testing, canary releases, access control, and end-to-end authentication.</simpara>
</section>
<section xml:id="support_ossm-release-notes-v1x">
<title>Getting support</title>
<simpara>If you experience difficulty with a procedure described in this documentation, or with OpenShift Container Platform in general, visit the <link xlink:href="http://access.redhat.com">Red Hat Customer Portal</link>.</simpara>
<simpara>From the Customer Portal, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Search or browse through the Red Hat Knowledgebase of articles and solutions relating to Red Hat products.</simpara>
</listitem>
<listitem>
<simpara>Submit a support case to Red Hat Support.</simpara>
</listitem>
<listitem>
<simpara>Access other product documentation.</simpara>
</listitem>
</itemizedlist>
<simpara>To identify issues with your cluster, you can use Insights in <link xlink:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link>. Insights provides details about issues and, if available, information on how to solve a problem.</simpara>
<simpara>If you have a suggestion for improving this documentation or have found an
error, submit a <link xlink:href="https://issues.redhat.com/secure/CreateIssueDetails!init.jspa?pid=12332330&amp;summary=Documentation_issue&amp;issuetype=1&amp;components=12367614&amp;priority=10200&amp;versions=12385624">Jira issue</link> for the most relevant documentation component. Please provide specific details, such as the section name and OpenShift Container Platform version.</simpara>
<simpara>When opening a support case, it is helpful to provide debugging
information about your cluster to Red Hat Support.</simpara>
<simpara>The <literal>must-gather</literal> tool enables you to collect diagnostic information about your
OpenShift Container Platform cluster, including virtual machines and other data related to
Red Hat OpenShift Service Mesh.</simpara>
<simpara>For prompt support, supply diagnostic information for both OpenShift Container Platform
and Red Hat OpenShift Service Mesh.</simpara>
<section xml:id="about-must-gather_ossm-release-notes-v1x">
<title>About the must-gather tool</title>
<simpara>The <literal>oc adm must-gather</literal> CLI command collects the information from your cluster that is most likely needed for debugging issues, including:</simpara>
<itemizedlist>
<listitem>
<simpara>Resource definitions</simpara>
</listitem>
<listitem>
<simpara>Service logs</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the <literal>oc adm must-gather</literal> command uses the default plugin image and writes into <literal>./must-gather.local</literal>.</simpara>
<simpara>Alternatively, you can collect specific information by running the command with the appropriate arguments as described in the following sections:</simpara>
<itemizedlist>
<listitem>
<simpara>To collect data related to one or more specific features, use the <literal>--image</literal> argument with an image, as listed in a following section.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather \
  --image=registry.redhat.io/container-native-virtualization/cnv-must-gather-rhel9:v4.15.0</programlisting>
</listitem>
<listitem>
<simpara>To collect the audit logs, use the <literal>-- /usr/bin/gather_audit_logs</literal> argument, as described in a following section.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather -- /usr/bin/gather_audit_logs</programlisting>
<note>
<simpara>Audit logs are not collected as part of the default set of information to reduce the size of the files.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>When you run <literal>oc adm must-gather</literal>, a new pod with a random name is created in a new project on the cluster. The data is collected on that pod and saved in a new directory that starts with <literal>must-gather.local</literal> in the current working directory.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE                      NAME                 READY   STATUS      RESTARTS      AGE
...
openshift-must-gather-5drcj    must-gather-bklx4    2/2     Running     0             72s
openshift-must-gather-5drcj    must-gather-s8sdh    2/2     Running     0             72s
...</programlisting>
<simpara>Optionally, you can run the <literal>oc adm must-gather</literal> command in a specific namespace by using the <literal>--run-namespace</literal> option.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --run-namespace &lt;namespace&gt; \
  --image=registry.redhat.io/container-native-virtualization/cnv-must-gather-rhel9:v4.15.0</programlisting>
</section>
<section xml:id="_prerequisites_3">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Container Platform CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-about-collecting-ossm-data_ossm-release-notes-v1x">
<title>About collecting service mesh data</title>
<simpara>You can use the <literal>oc adm must-gather</literal> CLI command to collect information about your cluster, including features and objects associated with Red Hat OpenShift Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Container Platform CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To collect Red Hat OpenShift Service Mesh data with <literal>must-gather</literal>, you must specify the Red Hat OpenShift Service Mesh image.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/openshift-service-mesh/istio-must-gather-rhel8:2.4</programlisting>
</listitem>
<listitem>
<simpara>To collect Red Hat OpenShift Service Mesh data for a specific Service Mesh control plane namespace with <literal>must-gather</literal>, you must specify the Red Hat OpenShift Service Mesh image and namespace. In this example, after <literal>gather,</literal> replace <literal>&lt;namespace&gt;</literal> with your Service Mesh control plane namespace, such as <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/openshift-service-mesh/istio-must-gather-rhel8:2.4 gather &lt;namespace&gt;</programlisting>
<simpara>This creates a local directory that contains the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>The Istio Operator namespace and its child objects</simpara>
</listitem>
<listitem>
<simpara>All control plane namespaces and their children objects</simpara>
</listitem>
<listitem>
<simpara>All namespaces and their children objects that belong to any service mesh</simpara>
</listitem>
<listitem>
<simpara>All Istio custom resource definitions (CRD)</simpara>
</listitem>
<listitem>
<simpara>All Istio CRD objects, such as VirtualServices, in a given namespace</simpara>
</listitem>
<listitem>
<simpara>All Istio webhooks</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-supported-configurations-v1x_ossm-release-notes-v1x">
<title>Red Hat OpenShift Service Mesh supported configurations</title>
<simpara>The following are the only supported configurations for the Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform version 4.6 or later.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>OpenShift Online and Red Hat OpenShift Dedicated are not supported for Red Hat OpenShift Service Mesh.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>The deployment must be contained within a single OpenShift Container Platform cluster that is not federated.</simpara>
</listitem>
<listitem>
<simpara>This release of Red Hat OpenShift Service Mesh is only available on OpenShift Container Platform x86_64.</simpara>
</listitem>
<listitem>
<simpara>This release only supports configurations where all Service Mesh components are contained in the OpenShift Container Platform cluster in which it operates. It does not support management of microservices that reside outside of the cluster, or in a multi-cluster scenario.</simpara>
</listitem>
<listitem>
<simpara>This release only supports configurations that do not integrate external services such as virtual machines.</simpara>
</listitem>
</itemizedlist>
<simpara>For additional information about Red Hat OpenShift Service Mesh lifecycle and supported configurations, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Support Policy</link>.</simpara>
<section xml:id="ossm-supported-configurations-kiali_ossm-release-notes-v1x">
<title>Supported configurations for Kiali on Red Hat OpenShift Service Mesh</title>
<itemizedlist>
<listitem>
<simpara>The Kiali observability console is only supported on the two most recent releases of the Chrome, Edge, Firefox, or Safari browsers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-adapters_ossm-release-notes-v1x">
<title>Supported Mixer adapters</title>
<itemizedlist>
<listitem>
<simpara>This release only supports the following Mixer adapter:</simpara>
<itemizedlist>
<listitem>
<simpara>3scale Istio Adapter</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-new-features-1x_ossm-release-notes-v1x">
<title>New Features</title>
<simpara>Red Hat OpenShift Service Mesh provides a number of key capabilities uniformly across a network of services:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Traffic Management</emphasis> - Control the flow of traffic and API calls between services, make calls more reliable, and make the network more robust in the face of adverse conditions.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Service Identity and Security</emphasis> - Provide services in the mesh with a verifiable identity and provide the ability to protect service traffic as it flows over networks of varying degrees of trustworthiness.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Policy Enforcement</emphasis> - Apply organizational policy to the interaction between services, ensure access policies are enforced and resources are fairly distributed among consumers. Policy changes are made by configuring the mesh, not by changing application code.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Telemetry</emphasis> - Gain understanding of the dependencies between services and the nature and flow of traffic between them, providing the ability to quickly identify issues.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_18_2">
<title>New features Red Hat OpenShift Service Mesh 1.1.18.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs).</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_1_1_18_2">
<title>Component versions included in Red Hat OpenShift Service Mesh version 1.1.18.2</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.4.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.21.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3scale Istio Adapter</simpara></entry>
<entry align="left" valign="top"><simpara>1.0.0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_18_1">
<title>New features Red Hat OpenShift Service Mesh 1.1.18.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs).</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_1_1_18_1">
<title>Component versions included in Red Hat OpenShift Service Mesh version 1.1.18.1</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.4.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.30.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.20.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3scale Istio Adapter</simpara></entry>
<entry align="left" valign="top"><simpara>1.0.0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_18">
<title>New features Red Hat OpenShift Service Mesh 1.1.18</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs).</simpara>
<section xml:id="_component_versions_included_in_red_hat_openshift_service_mesh_version_1_1_18">
<title>Component versions included in Red Hat OpenShift Service Mesh version 1.1.18</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Istio</simpara></entry>
<entry align="left" valign="top"><simpara>1.4.10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Jaeger</simpara></entry>
<entry align="left" valign="top"><simpara>1.24.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kiali</simpara></entry>
<entry align="left" valign="top"><simpara>1.12.18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3scale Istio Adapter</simpara></entry>
<entry align="left" valign="top"><simpara>1.0.0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_17_1">
<title>New features Red Hat OpenShift Service Mesh 1.1.17.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs).</simpara>
<section xml:id="_change_in_how_red_hat_openshift_service_mesh_handles_uri_fragments_2">
<title>Change in how Red Hat OpenShift Service Mesh handles URI fragments</title>
<simpara>Red Hat OpenShift Service Mesh contains a remotely exploitable vulnerability, <link xlink:href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-39156">CVE-2021-39156</link>, where an HTTP request with a fragment (a section in the end of a URI that begins with a # character) in the URI path could bypass the Istio URI path-based authorization policies. For instance, an Istio authorization policy denies requests sent to the URI path <literal>/user/profile</literal>. In the vulnerable versions, a request with URI path <literal>/user/profile#section1</literal> bypasses the deny policy and routes to the backend (with the normalized URI <literal>path /user/profile%23section1</literal>), possibly leading to a security incident.</simpara>
<simpara>You are impacted by this vulnerability if you use authorization policies with DENY actions and <literal>operation.paths</literal>, or ALLOW actions and <literal>operation.notPaths</literal>.</simpara>
<simpara>With the mitigation, the fragment part of the request’s URI is removed before the authorization and routing. This prevents a request with a fragment in its URI from bypassing authorization policies which are based on the URI without the fragment part.</simpara>
</section>
<section xml:id="_required_update_for_authorization_policies_2">
<title>Required update for authorization policies</title>
<simpara>Istio generates hostnames for both the hostname itself and all matching ports. For instance, a virtual service or Gateway for a host of "httpbin.foo" generates a config matching "httpbin.foo and httpbin.foo:*". However, exact match authorization policies only match the exact string given for the <literal>hosts</literal> or <literal>notHosts</literal> fields.</simpara>
<simpara>Your cluster is impacted if you have <literal>AuthorizationPolicy</literal> resources using exact string comparison for the rule to determine <link xlink:href="https://istio.io/latest/docs/reference/config/security/authorization-policy/#Operation">hosts or notHosts</link>.</simpara>
<simpara>You must update your authorization policy <link xlink:href="https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule">rules</link> to use prefix match instead of exact match.  For example, replacing <literal>hosts: ["httpbin.com"]</literal> with <literal>hosts: ["httpbin.com:*"]</literal> in the first <literal>AuthorizationPolicy</literal> example.</simpara>
<formalpara>
<title>First example AuthorizationPolicy using prefix match</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: httpbin
  namespace: foo
spec:
  action: DENY
  rules:
  - from:
    - source:
        namespaces: ["dev"]
    to:
    - operation:
        hosts: [“httpbin.com”,"httpbin.com:*"]</programlisting>
</para>
</formalpara>
<formalpara>
<title>Second example AuthorizationPolicy using prefix match</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: httpbin
  namespace: default
spec:
  action: DENY
  rules:
  - to:
    - operation:
        hosts: ["httpbin.example.com:*"]</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_17">
<title>New features Red Hat OpenShift Service Mesh 1.1.17</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_16">
<title>New features Red Hat OpenShift Service Mesh 1.1.16</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_15">
<title>New features Red Hat OpenShift Service Mesh 1.1.15</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_14">
<title>New features Red Hat OpenShift Service Mesh 1.1.14</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<important>
<simpara>There are manual steps that must be completed to address CVE-2021-29492 and CVE-2021-31920.</simpara>
</important>
<section xml:id="manual-updates-cve-2021-29492_ossm-release-notes-v1x">
<title>Manual updates required by CVE-2021-29492 and CVE-2021-31920</title>
<simpara>Istio contains a remotely exploitable vulnerability where an HTTP request path with multiple slashes or escaped slash characters (<literal>%2F` or </literal>%5C`) could potentially bypass an Istio authorization policy when path-based authorization rules are used.</simpara>
<simpara>For example, assume an Istio cluster administrator defines an authorization DENY policy to reject the request at path <literal>/admin</literal>. A request sent to the URL path <literal>//admin</literal> will NOT be rejected by the authorization policy.</simpara>
<simpara>According to <link xlink:href="https://tools.ietf.org/html/rfc3986#section-6">RFC 3986</link>, the path <literal>//admin</literal> with multiple slashes should technically be treated as a different path from the <literal>/admin</literal>. However, some backend services choose to normalize the URL paths by merging multiple slashes into a single slash. This can result in a bypass of the authorization policy (<literal>//admin</literal> does not match <literal>/admin</literal>), and a user can access the resource at path <literal>/admin</literal> in the backend; this would represent a security incident.</simpara>
<simpara>Your cluster is impacted by this vulnerability if you have authorization policies using <literal>ALLOW action + notPaths</literal> field or <literal>DENY action + paths field</literal> patterns. These patterns are vulnerable to unexpected policy bypasses.</simpara>
<simpara>Your cluster is NOT impacted by this vulnerability if:</simpara>
<itemizedlist>
<listitem>
<simpara>You don’t have authorization policies.</simpara>
</listitem>
<listitem>
<simpara>Your authorization policies don’t define <literal>paths</literal> or <literal>notPaths</literal> fields.</simpara>
</listitem>
<listitem>
<simpara>Your authorization policies use <literal>ALLOW action + paths</literal> field or <literal>DENY action + notPaths</literal> field patterns. These patterns could only cause unexpected rejection instead of policy bypasses. The upgrade is optional for these cases.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Red Hat OpenShift Service Mesh configuration location for path normalization is different from the Istio configuration.</simpara>
</note>
</section>
<section xml:id="_updating_the_path_normalization_configuration_2">
<title>Updating the path normalization configuration</title>
<simpara>Istio authorization policies can be based on the URL paths in the HTTP request.
<link xlink:href="https://en.wikipedia.org/wiki/URI_normalization">Path normalization</link>, also known as URI normalization, modifies and standardizes the incoming requests' paths so that the normalized paths can be processed in a standard way.
Syntactically different paths may be equivalent after path normalization.</simpara>
<simpara>Istio supports the following normalization schemes on the request paths before evaluating against the authorization policies and routing the requests:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Normalization schemes</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>NONE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No normalization is done. Anything received by Envoy will be forwarded exactly as-is to any backend service.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>../%2Fa../b</literal> is evaluated by the authorization policies and sent to your service.</simpara></entry>
<entry align="left" valign="top"><simpara>This setting is vulnerable to CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BASE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is currently the option used in the <emphasis role="strong">default</emphasis> installation of Istio. This applies the <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path"><literal>normalize_path</literal></link> option on Envoy proxies, which follows <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> with extra normalization to convert backslashes to forward slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a/../b</literal> is normalized to <literal>/b</literal>. <literal>\da</literal> is normalized to <literal>/da</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>This setting is vulnerable to CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MERGE_SLASHES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slashes are merged after the <emphasis>BASE</emphasis> normalization.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a//b</literal> is normalized to <literal>/a/b</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Update to this setting to mitigate CVE-2021-31920.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The strictest setting when you allow all traffic by default. This setting is recommended, with the caveat that you must thoroughly test your authorization policies routes. <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">Percent-encoded</link> slash and backslash characters (<literal>%2F</literal>, <literal>%2f</literal>, <literal>%5C</literal> and <literal>%5c</literal>) are decoded to <literal>/</literal> or <literal>\</literal>, before the <literal>MERGE_SLASHES</literal> normalization.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>/a%2fb</literal> is normalized to <literal>/a/b</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Update to this setting to mitigate CVE-2021-31920.  This setting is more secure, but also has the potential to break applications.  Test your applications before deploying to production.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The normalization algorithms are conducted in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Percent-decode <literal>%2F</literal>, <literal>%2f</literal>, <literal>%5C</literal> and <literal>%5c</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and other normalization implemented by the <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path"><literal>normalize_path</literal></link> option in Envoy.</simpara>
</listitem>
<listitem>
<simpara>Merge slashes.</simpara>
</listitem>
</orderedlist>
<warning>
<simpara>While these normalization options represent recommendations from HTTP standards and common industry practices, applications may interpret a URL in any way it chooses to. When using denial policies, ensure that you understand how your application behaves.</simpara>
</warning>
</section>
<section xml:id="_path_normalization_configuration_examples_2">
<title>Path normalization configuration examples</title>
<simpara>Ensuring Envoy normalizes request paths to match your backend services' expectations is critical to the security of your system.
The following examples can be used as a reference for you to configure your system.
The normalized URL paths, or the original URL paths if <literal>NONE</literal> is selected, will be:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Used to check against the authorization policies.</simpara>
</listitem>
<listitem>
<simpara>Forwarded to the backend application.</simpara>
</listitem>
</orderedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration examples</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">If your application&#8230;&#8203;</entry>
<entry align="left" valign="top">Choose&#8230;&#8203;</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Relies on the proxy to do normalization</simpara></entry>
<entry align="left" valign="top"><simpara><literal>BASE</literal>, <literal>MERGE_SLASHES</literal> or <literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and does not merge slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>BASE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link> and merges slashes, but does not decode <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">percent-encoded</link> slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Normalizes request paths based on <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link>, decodes <link xlink:href="https://tools.ietf.org/html/rfc3986#section-2.1">percent-encoded</link> slashes, and merges slashes.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DECODE_AND_MERGE_SLASHES</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Processes request paths in a way that is incompatible with <link xlink:href="https://tools.ietf.org/html/rfc3986">RFC 3986</link>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>NONE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="_configuring_your_smcp_for_path_normalization_2">
<title>Configuring your SMCP for path normalization</title>
<simpara>To configure path normalization for Red Hat OpenShift Service Mesh, specify the following in your <literal>ServiceMeshControlPlane</literal>.  Use the configuration examples to help determine the settings for your system.</simpara>
<formalpara>
<title>SMCP v1 pathNormalization</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  global:
    pathNormalization: &lt;option&gt;</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_13">
<title>New features Red Hat OpenShift Service Mesh 1.1.13</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_12">
<title>New features Red Hat OpenShift Service Mesh 1.1.12</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_11">
<title>New features Red Hat OpenShift Service Mesh 1.1.11</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_10">
<title>New features Red Hat OpenShift Service Mesh 1.1.10</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_9">
<title>New features Red Hat OpenShift Service Mesh 1.1.9</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_8">
<title>New features Red Hat OpenShift Service Mesh 1.1.8</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_7">
<title>New features Red Hat OpenShift Service Mesh 1.1.7</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_6">
<title>New features Red Hat OpenShift Service Mesh 1.1.6</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_5">
<title>New features Red Hat OpenShift Service Mesh 1.1.5</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<simpara>This release also added support for configuring cipher suites.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_4">
<title>New features Red Hat OpenShift Service Mesh 1.1.4</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
<note>
<simpara>There are manual steps that must be completed to address CVE-2020-8663.</simpara>
</note>
<section xml:id="manual-updates-cve-2020-8663_ossm-release-notes-v1x">
<title>Manual updates required by CVE-2020-8663</title>
<simpara>The fix for <link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1844254">CVE-2020-8663</link><literal>: envoy: Resource exhaustion when accepting too many connections</literal> added a configurable limit on downstream connections. The configuration option for this limit must be configured to mitigate this vulnerability.</simpara>
<important>
<simpara>These manual steps are required to mitigate this CVE whether you are using the 1.1 version or the 1.0 version of Red Hat OpenShift Service Mesh.</simpara>
</important>
<simpara>This new configuration option is called <literal>overload.global_downstream_max_connections</literal>, and it is configurable as a proxy <literal>runtime</literal> setting.  Perform the following steps to configure limits at the Ingress Gateway.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a file named <literal>bootstrap-override.json</literal> with the following text to force the proxy to override the bootstrap template and load runtime configuration from disk:</simpara>
<literallayout class="monospaced">  {
    "runtime": {
      "symlink_root": "/var/lib/istio/envoy/runtime"
    }
  }</literallayout>
</listitem>
<listitem>
<simpara>Create a secret from the <literal>bootstrap-override.json</literal> file, replacing &lt;SMCPnamespace&gt; with the namespace where you created the service mesh control plane (SMCP):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc create secret generic -n &lt;SMCPnamespace&gt; gateway-bootstrap --from-file=bootstrap-override.json</programlisting>
</listitem>
<listitem>
<simpara>Update the SMCP configuration to activate the override.</simpara>
<formalpara>
<title>Updated SMCP configuration example #1</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    gateways:
      istio-ingressgateway:
        env:
          ISTIO_BOOTSTRAP_OVERRIDE: /var/lib/istio/envoy/custom-bootstrap/bootstrap-override.json
        secretVolumes:
        - mountPath: /var/lib/istio/envoy/custom-bootstrap
          name: custom-bootstrap
          secretName: gateway-bootstrap</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To set the new configuration option, create a secret that has the desired value for the <literal>overload.global_downstream_max_connections</literal> setting.  The following example uses a value of <literal>10000</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc create secret generic -n &lt;SMCPnamespace&gt; gateway-settings --from-literal=overload.global_downstream_max_connections=10000</programlisting>
</listitem>
<listitem>
<simpara>Update the SMCP again to mount the secret in the location where Envoy is looking for runtime configuration:</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Updated SMCP configuration example #2</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  template: default
#Change the version to "v1.0" if you are on the 1.0 stream.
  version: v1.1
  istio:
    gateways:
      istio-ingressgateway:
        env:
          ISTIO_BOOTSTRAP_OVERRIDE: /var/lib/istio/envoy/custom-bootstrap/bootstrap-override.json
        secretVolumes:
        - mountPath: /var/lib/istio/envoy/custom-bootstrap
          name: custom-bootstrap
          secretName: gateway-bootstrap
        # below is the new secret mount
        - mountPath: /var/lib/istio/envoy/runtime
          name: gateway-settings
          secretName: gateway-settings</programlisting>
</para>
</formalpara>
</section>
<section xml:id="upgrading_es5_es6_ossm-release-notes-v1x">
<title>Upgrading from Elasticsearch 5 to Elasticsearch 6</title>
<simpara>When updating from Elasticsearch 5 to Elasticsearch 6, you must delete your Jaeger instance, then recreate the Jaeger instance because of an issue with certificates. Re-creating the Jaeger instance triggers creating a new set of certificates.   If you are using persistent storage the same volumes can be mounted for the new Jaeger instance as long as the Jaeger name and namespace for the new Jaeger instance are the same as the deleted Jaeger instance.</simpara>
<orderedlist numeration="arabic">
<title>Procedure if Jaeger is installed as part of Red Hat Service Mesh</title>
<listitem>
<simpara>Determine the name of your Jaeger custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jaeger -n istio-system</programlisting>
<simpara>You should see something like the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME     AGE
jaeger   3d21h</programlisting>
</listitem>
<listitem>
<simpara>Copy the generated custom resource file into a temporary directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get jaeger jaeger -oyaml -n istio-system &gt; /tmp/jaeger-cr.yaml</programlisting>
</listitem>
<listitem>
<simpara>Delete the Jaeger instance:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete jaeger jaeger -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Recreate the Jaeger instance from your copy of the custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f /tmp/jaeger-cr.yaml -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Delete the copy of the generated custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rm /tmp/jaeger-cr.yaml</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Procedure if Jaeger not installed as part of Red Hat Service Mesh</title>
<para>Before you begin, create a copy of your Jaeger custom resource file.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Delete the Jaeger instance by deleting the custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f &lt;jaeger-cr-file&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f jaeger-prod-elasticsearch.yaml</programlisting>
</listitem>
<listitem>
<simpara>Recreate your Jaeger instance from the backup copy of your custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;jaeger-cr-file&gt;</programlisting>
</listitem>
<listitem>
<simpara>Validate that your Pods have restarted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n jaeger-system -w</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_3">
<title>New features Red Hat OpenShift Service Mesh 1.1.3</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses Common Vulnerabilities and Exposures (CVEs) and bug fixes.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_2">
<title>New features Red Hat OpenShift Service Mesh 1.1.2</title>
<simpara>This release of Red Hat OpenShift Service Mesh addresses a security vulnerability.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_1">
<title>New features Red Hat OpenShift Service Mesh 1.1.1</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds support for a disconnected installation.</simpara>
</section>
<section xml:id="_new_features_red_hat_openshift_service_mesh_1_1_0">
<title>New features Red Hat OpenShift Service Mesh 1.1.0</title>
<simpara>This release of Red Hat OpenShift Service Mesh adds support for Istio 1.4.6 and Jaeger 1.17.1.</simpara>
<section xml:id="ossm-manual-updates-1.0-1.1_ossm-release-notes-v1x">
<title>Manual updates from 1.0 to 1.1</title>
<simpara>If you are updating from Red Hat OpenShift Service Mesh 1.0 to 1.1, you must update the <literal>ServiceMeshControlPlane</literal> resource to update the control plane components to the new version.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the web console, click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project where your <literal>ServiceMeshControlPlane</literal> is deployed from the list, for example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your control plane, for example <literal>basic-install</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click YAML and add a version field to the <literal>spec:</literal> of your <literal>ServiceMeshControlPlane</literal> resource. For example, to update to Red Hat OpenShift Service Mesh 1.1.0, add <literal>version: v1.1</literal>.</simpara>
</listitem>
</orderedlist>
<screen>spec:
  version: v1.1
  ...</screen>
<simpara>The version field specifies the version of Service Mesh to install and defaults to the latest available version.</simpara>
<note>
<simpara>Note that support for Red Hat OpenShift Service Mesh v1.0 ended in October, 2020.  You must upgrade to either v1.1 or v2.0.</simpara>
</note>
</section>
</section>
</section>
<section xml:id="ossm-deprecated-features-1x_ossm-release-notes-v1x">
<title>Deprecated features</title>
<simpara>Some features available in previous releases have been deprecated or removed.</simpara>
<simpara>Deprecated functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<section xml:id="_deprecated_features_red_hat_openshift_service_mesh_1_1_5">
<title>Deprecated features Red Hat OpenShift Service Mesh 1.1.5</title>
<simpara>The following custom resources were deprecated in release 1.1.5 and were removed in release 1.1.12</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Policy</literal> - The <literal>Policy</literal> resource is deprecated and will be replaced by the <literal>PeerAuthentication</literal> resource in a future release.</simpara>
</listitem>
<listitem>
<simpara><literal>MeshPolicy</literal> - The <literal>MeshPolicy</literal> resource is deprecated and will be replaced by the <literal>PeerAuthentication</literal> resource in a future release.</simpara>
</listitem>
<listitem>
<simpara><literal>v1alpha1</literal> RBAC API -The v1alpha1 RBAC policy is deprecated by the v1beta1 <literal>AuthorizationPolicy</literal>. RBAC (Role Based Access Control) defines <literal>ServiceRole</literal> and <literal>ServiceRoleBinding</literal> objects.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ServiceRole</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceRoleBinding</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>RbacConfig</literal> - <literal>RbacConfig</literal> implements the Custom Resource Definition for controlling Istio RBAC behavior.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ClusterRbacConfig</literal>(versions prior to Red Hat OpenShift Service Mesh 1.0)</simpara>
</listitem>
<listitem>
<simpara><literal>ServiceMeshRbacConfig</literal> (Red Hat OpenShift Service Mesh version 1.0 and later)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In Kiali, the <literal>login</literal> and <literal>LDAP</literal> strategies are deprecated. A future version will introduce authentication using OpenID providers.</simpara>
</listitem>
</itemizedlist>
<simpara>The following components are also deprecated in this release and will be replaced by the <emphasis role="strong">Istiod</emphasis> component in a future release.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Mixer</emphasis> - access control and usage policies</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pilot</emphasis> - service discovery and proxy configuration</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Citadel</emphasis> - certificate generation</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Galley</emphasis> - configuration validation and distribution</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-known-issues-1x_ossm-release-notes-v1x">
<title>Known issues</title>
<simpara>These limitations exist in Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://github.com/istio/old_issues_repo/issues/115">Red Hat OpenShift Service Mesh does not support IPv6</link>, as it is not supported by the upstream Istio project, nor fully supported by OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Graph layout - The layout for the Kiali graph can render differently, depending on your application architecture and the data to display (number of graph nodes and their interactions). Because it is difficult if not impossible to create a single layout that renders nicely for every situation, Kiali offers a choice of several different layouts. To choose a different layout, you can choose a different <emphasis role="strong">Layout Schema</emphasis> from the <emphasis role="strong">Graph Settings</emphasis> menu.</simpara>
</listitem>
<listitem>
<simpara>The first time you access related services such as Jaeger and Grafana, from the Kiali console, you must accept the certificate and re-authenticate using your OpenShift Container Platform login credentials. This happens due to an issue with how the framework displays embedded pages in the console.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-rn-known-issues-ossm_ossm-release-notes-v1x">
<title>Service Mesh known issues</title>
<simpara>These are the known issues in Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/solutions/4970771">Jaeger/Kiali Operator upgrade blocked with operator pending</link> When upgrading the Jaeger or Kiali Operators with Service Mesh 1.0.x installed, the operator status shows as Pending.</simpara>
<simpara>Workaround: See the linked Knowledge Base article for more information.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/istio/istio/issues/14743">Istio-14743</link> Due to limitations in the version of Istio that this release of Red Hat OpenShift Service Mesh is based on, there are several applications that are currently incompatible with Service Mesh. See the linked community issue for details.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-858">MAISTRA-858</link> The following Envoy log messages describing <link xlink:href="https://www.envoyproxy.io/docs/envoy/latest/intro/deprecated">deprecated options and configurations associated with Istio 1.1.x</link> are expected:</simpara>
<itemizedlist>
<listitem>
<simpara>[2019-06-03 07:03:28.943][19][warning][misc] [external/envoy/source/common/protobuf/utility.cc:129] Using deprecated option 'envoy.api.v2.listener.Filter.config'. This configuration will be removed from Envoy soon.</simpara>
</listitem>
<listitem>
<simpara>[2019-08-12 22:12:59.001][13][warning][misc] [external/envoy/source/common/protobuf/utility.cc:174] Using deprecated option 'envoy.api.v2.Listener.use_original_dst' from file lds.proto. This configuration will be removed from Envoy soon.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-806">MAISTRA-806</link> Evicted Istio Operator Pod causes mesh and CNI not to deploy.</simpara>
<simpara>Workaround: If the <literal>istio-operator</literal> pod is evicted while deploying the control pane, delete the evicted <literal>istio-operator</literal> pod.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-681">MAISTRA-681</link> When the control plane has many namespaces, it can lead to performance issues.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-465">MAISTRA-465</link> The Maistra Operator fails to create a service for operator metrics.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-453">MAISTRA-453</link> If you create a new project and deploy pods immediately, sidecar injection does not occur. The operator fails to add the <literal>maistra.io/member-of</literal> before the pods are created, therefore the pods must be deleted and recreated for sidecar injection to occur.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-158">MAISTRA-158</link> Applying multiple gateways referencing the same hostname will cause all gateways to stop functioning.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-rn-known-issues-kiali_ossm-release-notes-v1x">
<title>Kiali known issues</title>
<note>
<simpara>New issues for Kiali should be created in the <link xlink:href="https://issues.redhat.com/projects/OSSM/">OpenShift Service Mesh</link>  project with the <literal>Component</literal> set to <literal>Kiali</literal>.</simpara>
</note>
<simpara>These are the known issues in Kiali:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-2206">KIALI-2206</link> When you are accessing the Kiali console for the first time, and there is no cached browser data for Kiali, the “View in Grafana” link on the Metrics tab of the Kiali Service Details page redirects to the wrong location. The only way you would encounter this issue is if you are accessing Kiali for the first time.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/kiali/kiali/issues/507">KIALI-507</link> Kiali does not support Internet Explorer 11. This is because the underlying frameworks do not support Internet Explorer. To access the Kiali console, use one of the two most recent versions of the Chrome, Edge, Firefox or Safari browser.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-rn-fixed-issues-1x_ossm-release-notes-v1x">
<title>Fixed issues</title>
<simpara>The following issues been resolved in the current release:</simpara>
<section xml:id="ossm-rn-fixed-issues-ossm_ossm-release-notes-v1x">
<title>Service Mesh fixed issues</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-2371">MAISTRA-2371</link> Handle tombstones in listerInformer. The updated cache codebase was not handling tombstones when translating the events from the namespace caches to the aggregated cache, leading to a panic in the go routine.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/OSSM-542">OSSM-542</link> Galley is not using the new certificate after rotation.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/OSSM-99">OSSM-99</link> Workloads generated from direct pod without labels may crash Kiali.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/OSSM-93">OSSM-93</link> IstioConfigList can&#8217;t filter by two or more names.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/OSSM-92">OSSM-92</link> Cancelling unsaved changes on the VS/DR YAML edit page does not cancel the changes.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/OSSM-90">OSSM-90</link> Traces not available on the service details page.</simpara>
</listitem>
</itemizedlist>
<itemizedlist xml:id="ossm-rn-fixed-issues-maistra_ossm-release-notes-v1x">
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/projects/MAISTRA/issues/MAISTRA-1649">MAISTRA-1649</link> Headless services conflict when in different namespaces. When deploying headless services within different namespaces the endpoint configuration is merged and results in invalid Envoy configurations being pushed to the sidecars.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-1541">MAISTRA-1541</link> Panic in kubernetesenv when the controller is not set on owner reference. If a pod has an ownerReference which does not specify the controller, this will cause a panic within the <literal>kubernetesenv cache.go</literal> code.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.redhat.com/browse/MAISTRA-1352">MAISTRA-1352</link> Cert-manager Custom Resource Definitions (CRD) from the control plane installation have been removed for this release and future releases. If you have already installed Red Hat OpenShift Service Mesh, the CRDs must be removed manually if cert-manager is not being used.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-1001">MAISTRA-1001</link> Closing HTTP/2 connections could lead to segmentation faults in <literal>istio-proxy</literal>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-932">MAISTRA-932</link> Added the <literal>requires</literal> metadata to add dependency relationship between Jaeger Operator and OpenShift Elasticsearch Operator. Ensures that when the Jaeger Operator is installed, it automatically deploys the OpenShift Elasticsearch Operator if it is not available.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-862">MAISTRA-862</link> Galley dropped watches and stopped providing configuration to other components after many namespace deletions and re-creations.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-833">MAISTRA-833</link> Pilot stopped delivering configuration after many namespace deletions and re-creations.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-684">MAISTRA-684</link> The default Jaeger version in the <literal>istio-operator</literal> is 1.12.0, which does not match Jaeger version 1.13.1 that shipped in Red Hat OpenShift Service Mesh 0.12.TechPreview.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-622">MAISTRA-622</link> In Maistra 0.12.0/TP12, permissive mode does not work. The user has the option to use Plain text mode or Mutual TLS mode, but not permissive.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-572">MAISTRA-572</link> Jaeger cannot be used with Kiali. In this release Jaeger is configured to use the OAuth proxy, but is also only configured to work through a browser and does not allow service access. Kiali cannot properly communicate with the Jaeger endpoint and it considers Jaeger to be disabled. See also <link xlink:href="https://issues.jboss.org/browse/TRACING-591">TRACING-591</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-357">MAISTRA-357</link> In OpenShift 4 Beta on AWS, it is not possible, by default, to access a TCP or HTTPS service through the ingress gateway on a port other than port 80. The AWS load balancer has a health check that verifies if port 80 on the service endpoint is active. Without a service running on port 80, the load balancer health check fails.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-348">MAISTRA-348</link> OpenShift 4 Beta on AWS does not support ingress gateway traffic on ports other than 80 or 443.  If you configure your ingress gateway to handle TCP traffic with a port number other than 80 or 443, you have to use the service hostname provided by the AWS load balancer rather than the OpenShift router as a workaround.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/MAISTRA-193">MAISTRA-193</link> Unexpected console info messages are visible when health checking is enabled for citadel.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1821432">Bug 1821432</link> Toggle controls in OpenShift Container Platform Control Resource details page do not update the CR correctly. UI Toggle controls in the Service Mesh Control Plane (SMCP) Overview page in the OpenShift Container Platform web console sometimes update the wrong field in the resource. To update a ServiceMeshControlPlane resource, edit the YAML content directly or update the resource from the command line instead of clicking the toggle controls.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-rn-fixed-issues-kiali_ossm-release-notes-v1x">
<title>Kiali fixed issues</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-3239">KIALI-3239</link> If a Kiali Operator pod has failed with a status of “Evicted” it blocks the Kiali operator from deploying. The workaround is to delete the Evicted pod and redeploy the Kiali operator.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-3118">KIALI-3118</link> After changes to the ServiceMeshMemberRoll, for example adding or removing projects, the Kiali pod restarts and then displays errors on the Graph page while the Kiali pod is restarting.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-3096">KIALI-3096</link> Runtime metrics fail in Service Mesh. There is an OAuth filter between the Service Mesh and Prometheus, requiring a bearer token to be passed to Prometheus before access is granted. Kiali has been updated to use this token when communicating to the Prometheus server, but the application metrics are currently failing with 403 errors.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://issues.jboss.org/browse/KIALI-3070">KIALI-3070</link> This bug only affects custom dashboards, not the default dashboards. When you select labels in metrics settings and refresh the page, your selections are retained in the menu but your selections are not displayed on the charts.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/kiali/kiali/issues/1603">KIALI-2686</link> When the control plane has many namespaces, it can lead to performance issues.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ossm-architecture-v1x">
<title>Understanding Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>Red Hat OpenShift Service Mesh provides a platform for behavioral insight and operational control over your networked microservices in a service mesh. With Red Hat OpenShift Service Mesh, you can connect, secure, and monitor microservices in your OpenShift Container Platform environment.</simpara>
<section xml:id="ossm-understanding-service-mesh_ossm-architecture-v1x">
<title>Understanding service mesh</title>
<simpara>A <emphasis>service mesh</emphasis> is the network of microservices that make up applications in a distributed microservice architecture and the interactions between those microservices. When a Service Mesh grows in size and complexity, it can become harder to understand and manage.</simpara>
<simpara>Based on the open source <link xlink:href="https://istio.io/">Istio</link> project, Red Hat OpenShift Service Mesh adds a transparent layer on existing distributed applications without requiring any changes to the service code. You add Red Hat OpenShift Service Mesh support to services by deploying a special sidecar proxy to relevant services in the mesh that intercepts all network communication between microservices. You configure and manage the Service Mesh using the Service Mesh control plane features.</simpara>
<simpara>Red Hat OpenShift Service Mesh gives you an easy way to create a network of deployed services that provide:</simpara>
<itemizedlist>
<listitem>
<simpara>Discovery</simpara>
</listitem>
<listitem>
<simpara>Load balancing</simpara>
</listitem>
<listitem>
<simpara>Service-to-service authentication</simpara>
</listitem>
<listitem>
<simpara>Failure recovery</simpara>
</listitem>
<listitem>
<simpara>Metrics</simpara>
</listitem>
<listitem>
<simpara>Monitoring</simpara>
</listitem>
</itemizedlist>
<simpara>Red Hat OpenShift Service Mesh also provides more complex operational functions including:</simpara>
<itemizedlist>
<listitem>
<simpara>A/B testing</simpara>
</listitem>
<listitem>
<simpara>Canary releases</simpara>
</listitem>
<listitem>
<simpara>Access control</simpara>
</listitem>
<listitem>
<simpara>End-to-end authentication</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-architecture-1x_ossm-architecture-v1x">
<title>Red Hat OpenShift Service Mesh Architecture</title>
<simpara>Red Hat OpenShift Service Mesh is logically split into a data plane and a control plane:</simpara>
<simpara>The <emphasis role="strong">data plane</emphasis> is a set of intelligent proxies deployed as sidecars. These proxies intercept and control all inbound and outbound network communication between microservices in the service mesh. Sidecar proxies also communicate with Mixer, the general-purpose policy and telemetry hub.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Envoy proxy</emphasis> intercepts all inbound and outbound traffic for all services in the service mesh. Envoy is deployed as a sidecar to the relevant service in the same pod.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis role="strong">control plane</emphasis> manages and configures proxies to route traffic, and configures Mixers to enforce policies and collect telemetry.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Mixer</emphasis> enforces access control and usage policies (such as authorization, rate limits, quotas, authentication, and request tracing) and collects telemetry data from the Envoy proxy and other services.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pilot</emphasis> configures the proxies at runtime. Pilot provides service discovery for the Envoy sidecars, traffic management capabilities for intelligent routing (for example, A/B tests or canary deployments), and resiliency (timeouts, retries, and circuit breakers).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Citadel</emphasis> issues and rotates certificates. Citadel provides strong service-to-service and end-user authentication with built-in identity and credential management. You can use Citadel to upgrade unencrypted traffic in the service mesh. Operators can enforce policies based on service identity rather than on network controls using Citadel.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Galley</emphasis> ingests the service mesh configuration, then validates, processes, and distributes the configuration. Galley protects the other service mesh components from obtaining user configuration details from OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<simpara>Red Hat OpenShift Service Mesh also uses the <emphasis role="strong">istio-operator</emphasis> to manage the installation of the control plane. An <emphasis>Operator</emphasis> is a piece of software that enables you to implement and automate common activities in your OpenShift Container Platform cluster. It acts as a controller, allowing you to set or change the desired state of objects in your cluster.</simpara>
</section>
<section xml:id="_understanding_kiali_2">
<title>Understanding Kiali</title>
<simpara>Kiali provides visibility into your service mesh by showing you the microservices in your service mesh, and how they are connected.</simpara>
<section xml:id="ossm-kiali-overview_ossm-architecture-v1x">
<title>Kiali overview</title>
<simpara>Kiali provides observability into the Service Mesh running on OpenShift Container Platform. Kiali helps you define, validate, and observe your Istio service mesh. It helps you to understand the structure of your service mesh by inferring the topology, and also provides information about the health of your service mesh.</simpara>
<simpara>Kiali provides an interactive graph view of your namespace in real time that provides visibility into features like circuit breakers, request rates, latency, and even graphs of traffic flows. Kiali offers insights about components at different levels, from Applications to Services and Workloads, and can display the interactions with contextual information and charts on the selected graph node or edge. Kiali also provides the ability to validate your Istio configurations, such as gateways, destination rules, virtual services, mesh policies, and more. Kiali provides detailed metrics, and a basic Grafana integration is available for advanced queries. Distributed tracing is provided by integrating Jaeger into the Kiali console.</simpara>
<simpara>Kiali is installed by default as part of the Red Hat OpenShift Service Mesh.</simpara>
</section>
<section xml:id="ossm-kiali-architecture_ossm-architecture-v1x">
<title>Kiali architecture</title>
<simpara>Kiali is based on the open source <link xlink:href="https://kiali.io/">Kiali project</link>. Kiali is composed of two components: the Kiali application and the Kiali console.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kiali application</emphasis> (back end) – This component runs in the container application platform and communicates with the service mesh components, retrieves and processes data, and exposes this data to the console. The Kiali application does not need storage. When deploying the application to a cluster, configurations are set in ConfigMaps and secrets.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Kiali console</emphasis> (front end) – The Kiali console is a web application. 	The Kiali application serves the Kiali console, which then queries the back end for data to present it to the user.</simpara>
</listitem>
</itemizedlist>
<simpara>In addition, Kiali depends on external services and components provided by the container application platform and Istio.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Red Hat Service Mesh</emphasis> (Istio) - Istio is a Kiali requirement. Istio is the component that provides and controls the service mesh. Although Kiali and Istio can be installed separately, Kiali depends on Istio and will not work if it is not present. Kiali needs to retrieve Istio data and configurations, which are exposed through Prometheus and the cluster API.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Prometheus</emphasis> - A dedicated Prometheus instance is included as part of the Red Hat OpenShift Service Mesh installation. When Istio telemetry is enabled, metrics data are stored in Prometheus. Kiali uses this Prometheus data to determine the mesh topology, display metrics, calculate health, show possible problems, and so on. Kiali communicates directly with Prometheus and assumes the data schema used by Istio Telemetry. Prometheus is an Istio dependency and a hard dependency for Kiali, and many of Kiali&#8217;s features will not work without Prometheus.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cluster API</emphasis> - Kiali uses the API of the OpenShift Container Platform (cluster API) to fetch and resolve service mesh configurations. Kiali queries the cluster API to retrieve, for example, definitions for namespaces, services, deployments, pods, and other entities. Kiali also makes queries to resolve relationships between the different cluster entities. The cluster API is also queried to retrieve Istio configurations like virtual services, destination rules, route rules, gateways, quotas, and so on.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger</emphasis> - Jaeger is optional, but is installed by default as part of the Red Hat OpenShift Service Mesh installation. When you install the distributed tracing platform (Jaeger) as part of the default Red Hat OpenShift Service Mesh installation, the Kiali console includes a tab to display distributed tracing data. Note that tracing data will not be available if you disable Istio&#8217;s distributed tracing feature. Also note that user must have access to the namespace where the Service Mesh control plane is installed to view tracing data.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Grafana</emphasis> - Grafana is optional, but is installed by default as part of the Red Hat OpenShift Service Mesh installation. When available, the metrics pages of Kiali display links to direct the user to the same metric in Grafana. Note that user must have access to the namespace where the Service Mesh control plane is installed to view links to the Grafana dashboard and view Grafana data.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-kiali-features_ossm-architecture-v1x">
<title>Kiali features</title>
<simpara>The Kiali console is integrated with Red Hat Service Mesh and provides the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Health</emphasis> – Quickly identify issues with applications, services, or workloads.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Topology</emphasis> – Visualize how your applications, services, or workloads communicate via the Kiali graph.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Metrics</emphasis> – Predefined metrics dashboards let you chart service mesh and application performance for Go, Node.js. Quarkus, Spring Boot, Thorntail and Vert.x. You can also create your own custom dashboards.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Tracing</emphasis> – Integration with Jaeger lets you follow the path of a request through various microservices that make up an application.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Validations</emphasis> – Perform advanced validations on the most common Istio objects (Destination Rules, Service Entries, Virtual Services, and so on).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Configuration</emphasis> – Optional ability to create, update and delete Istio routing configuration using wizards or directly in the YAML editor in the Kiali Console.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_understanding_jaeger">
<title>Understanding Jaeger</title>
<simpara>Every time a user takes an action in an application, a request is executed by the architecture that may require dozens of different services to participate to produce a response.
The path of this request is a distributed transaction.
Jaeger lets you perform distributed tracing, which follows the path of a request through various microservices that make up an application.</simpara>
<simpara><emphasis role="strong">Distributed tracing</emphasis> is a technique that is used to tie the information about different units of work together—usually executed in different processes or hosts—to understand a whole chain of events in a distributed transaction.
Distributed tracing lets developers visualize call flows in large service oriented architectures.
It can be invaluable in understanding serialization, parallelism, and sources of latency.</simpara>
<simpara>Jaeger records the execution of individual requests across the whole stack of microservices, and presents them as traces. A <emphasis role="strong">trace</emphasis> is a data/execution path through the system. An end-to-end trace is comprised of one or more spans.</simpara>
<simpara>A <emphasis role="strong">span</emphasis> represents a logical unit of work in Jaeger that has an operation name, the start time of the operation, and the duration. Spans may be nested and ordered to model causal relationships.</simpara>
<section xml:id="distr-tracing-product-overview_ossm-architecture-v1x">
<title>Distributed tracing overview</title>
<simpara>As a service owner, you can use distributed tracing to instrument your services to gather insights into your service architecture.
You can use the Red Hat OpenShift distributed tracing platform for monitoring, network profiling, and troubleshooting the interaction between components in modern, cloud-native, microservices-based applications.</simpara>
<simpara>With the distributed tracing platform, you can perform the following functions:</simpara>
<itemizedlist>
<listitem>
<simpara>Monitor distributed transactions</simpara>
</listitem>
<listitem>
<simpara>Optimize performance and latency</simpara>
</listitem>
<listitem>
<simpara>Perform root cause analysis</simpara>
</listitem>
</itemizedlist>
<simpara>The distributed tracing platform consists of three components:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger)</emphasis>, which is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger project</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Tempo)</emphasis>, which is based on the open source <link xlink:href="https://grafana.com/oss/tempo/">Grafana Tempo project</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat build of OpenTelemetry</emphasis>, which is based on the open source <link xlink:href="https://opentelemetry.io/">OpenTelemetry project</link>.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Jaeger does not use FIPS validated cryptographic modules.</simpara>
</important>
</section>
<section xml:id="jaeger-architecture_ossm-architecture-v1x">
<title>Distributed tracing architecture</title>
<simpara>The distributed tracing platform (Jaeger) is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger project</link>. The distributed tracing platform (Jaeger) is made up of several components that work together to collect, store, and display tracing data.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Jaeger Client</emphasis> (Tracer, Reporter, instrumented application, client libraries)- Jaeger clients are language specific implementations of the OpenTracing API. They can be used to instrument applications for distributed tracing either manually or with a variety of existing open source frameworks, such as Camel (Fuse), Spring Boot (RHOAR), MicroProfile (RHOAR/Thorntail), Wildfly (EAP), and many more, that are already integrated with OpenTracing.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger Agent</emphasis> (Server Queue, Processor Workers) - The Jaeger agent is a network daemon that listens for spans sent over User Datagram Protocol (UDP), which it batches and sends to the collector. The agent is meant to be placed on the same host as the instrumented application. This is typically accomplished by having a sidecar in container environments like Kubernetes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger Collector</emphasis> (Queue, Workers) - Similar to the Agent, the Collector is able to receive spans and place them in an internal queue for processing. This allows the collector to return immediately to the client/agent instead of waiting for the span to make its way to the storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Storage</emphasis> (Data Store) - Collectors require a persistent storage backend. Jaeger has a pluggable mechanism for span storage. Note that for this release, the only supported storage is Elasticsearch.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Query</emphasis> (Query Service) - Query is a service that retrieves traces from storage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Ingester</emphasis> (Ingester Service) - Jaeger can use Apache Kafka as a buffer between the collector and the actual backing storage (Elasticsearch). Ingester is a service that reads data from Kafka and writes to another storage backend (Elasticsearch).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Jaeger Console</emphasis> – Jaeger provides a user interface that lets you visualize your distributed tracing data. On the Search page, you can find traces and explore details of the spans that make up an individual trace.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="distr-tracing-features_ossm-architecture-v1x">
<title>Red Hat OpenShift distributed tracing platform features</title>
<simpara>Red Hat OpenShift distributed tracing platform provides the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Integration with Kiali – When properly configured, you can view distributed tracing platform data from the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>High scalability – The distributed tracing platform back end is designed to have no single points of failure and to scale with the business needs.</simpara>
</listitem>
<listitem>
<simpara>Distributed Context Propagation – Enables you to connect data from different components together to create a complete end-to-end trace.</simpara>
</listitem>
<listitem>
<simpara>Backwards compatibility with Zipkin – Red Hat OpenShift distributed tracing platform has APIs that enable it to be used as a drop-in replacement for Zipkin, but Red Hat is not supporting Zipkin compatibility in this release.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_next_steps_7">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v1x/preparing-ossm-installation.xml#preparing-ossm-installation-v1x">Prepare to install Red Hat OpenShift Service Mesh</link> in your OpenShift Container Platform environment.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-vs-community-v1x">
<title>Service Mesh and Istio differences</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>An installation of Red Hat OpenShift Service Mesh differs from upstream Istio community installations in multiple ways. The modifications to Red Hat OpenShift Service Mesh are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<simpara>The current release of Red Hat OpenShift Service Mesh differs from the current upstream Istio community release in the following ways:</simpara>
<section xml:id="ossm-multitenant-install_ossm-vs-istio-v1x">
<title>Multitenant installations</title>
<simpara>Whereas upstream Istio takes a single tenant approach, Red Hat OpenShift Service Mesh supports multiple independent control planes within the cluster. Red Hat OpenShift Service Mesh uses a multitenant operator to manage the control plane lifecycle.</simpara>
<simpara>Red Hat OpenShift Service Mesh installs a multitenant control plane by default. You specify the projects that can access the Service Mesh, and isolate the Service Mesh from other control plane instances.</simpara>
<section xml:id="ossm-mt-vs-clusterwide_ossm-vs-istio-v1x">
<title>Multitenancy versus cluster-wide installations</title>
<simpara>The main difference between a multitenant installation and a cluster-wide installation is the scope of privileges used by istod. The components no longer use cluster-scoped Role Based Access Control (RBAC) resource <literal>ClusterRoleBinding</literal>.</simpara>
<simpara>Every project in the <literal>ServiceMeshMemberRoll</literal> <literal>members</literal> list will have a <literal>RoleBinding</literal> for each service account associated with the control plane deployment and each control plane deployment will only watch those member projects. Each member project has a <literal>maistra.io/member-of</literal> label added to it, where the <literal>member-of</literal> value is the project containing the control plane installation.</simpara>
<simpara>Red Hat OpenShift Service Mesh configures each member project to ensure network access between itself, the control plane, and other member projects. The exact configuration differs depending on how OpenShift Container Platform software-defined networking (SDN) is configured. See About OpenShift SDN for additional details.</simpara>
<simpara>If the OpenShift Container Platform cluster is configured to use the SDN plugin:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>NetworkPolicy</literal></emphasis>: Red Hat OpenShift Service Mesh creates a <literal>NetworkPolicy</literal> resource in each member project allowing ingress to all pods from the other members and the control plane. If you remove a member from Service Mesh, this <literal>NetworkPolicy</literal> resource is deleted from the project.</simpara>
<note>
<simpara>This also restricts ingress to only member projects. If you require ingress from non-member projects, you need to create a <literal>NetworkPolicy</literal> to allow that traffic through.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">Multitenant</emphasis>: Red Hat OpenShift Service Mesh joins the <literal>NetNamespace</literal> for each member project to the <literal>NetNamespace</literal> of the control plane project (the equivalent of running <literal>oc adm pod-network join-projects --to control-plane-project member-project</literal>). If you remove a member from the Service Mesh, its <literal>NetNamespace</literal> is isolated from the control plane (the equivalent of running <literal>oc adm pod-network isolate-projects member-project</literal>).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Subnet</emphasis>: No additional configuration is performed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-cluster-scoped-resources_ossm-vs-istio-v1x">
<title>Cluster scoped resources</title>
<simpara>Upstream Istio has two cluster scoped resources that it relies on. The <literal>MeshPolicy</literal> and the <literal>ClusterRbacConfig</literal>. These are not compatible with a multitenant cluster and have been replaced as described below.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>ServiceMeshPolicy</emphasis> replaces MeshPolicy for configuration of control-plane-wide authentication policies. This must be created in the same project as the control plane.</simpara>
</listitem>
<listitem>
<simpara><emphasis>ServicemeshRbacConfig</emphasis> replaces ClusterRbacConfig for configuration of control-plane-wide role based access control. This must be created in the same project as the control plane.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-vs-istio_ossm-vs-istio-v1x">
<title>Differences between Istio and Red Hat OpenShift Service Mesh</title>
<simpara>An installation of Red Hat OpenShift Service Mesh differs from an installation of Istio in multiple ways. The modifications to Red Hat OpenShift Service Mesh are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<section xml:id="ossm-cli-tool_ossm-vs-istio-v1x">
<title>Command line tool</title>
<simpara>The command line tool for Red Hat OpenShift Service Mesh is oc.  Red Hat OpenShift Service Mesh  does not support istioctl.</simpara>
</section>
<section xml:id="ossm-automatic-injection_ossm-vs-istio-v1x">
<title>Automatic injection</title>
<simpara>The upstream Istio community installation automatically injects the sidecar into pods within the projects you have labeled.</simpara>
<simpara>Red Hat OpenShift Service Mesh does not automatically inject the sidecar to any pods, but requires you to opt in to injection using an annotation without labeling projects. This method requires fewer privileges and does not conflict with other OpenShift capabilities such as builder pods. To enable automatic injection you specify the <literal>sidecar.istio.io/inject</literal> annotation as described in the Automatic sidecar injection section.</simpara>
</section>
<section xml:id="ossm-rbac_ossm-vs-istio-v1x">
<title>Istio Role Based Access Control features</title>
<simpara>Istio Role Based Access Control (RBAC) provides a mechanism you can use to control access to a service. You can identify subjects by user name or by specifying a set of properties and apply access controls accordingly.</simpara>
<simpara>The upstream Istio community installation includes options to perform exact header matches, match wildcards in headers, or check for a header containing a specific prefix or suffix.</simpara>
<simpara>Red Hat OpenShift Service Mesh extends the ability to match request headers by using a regular expression. Specify a property key of <literal>request.regex.headers</literal> with a regular expression.</simpara>
<formalpara>
<title>Upstream Istio community matching request headers example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "rbac.istio.io/v1alpha1"
kind: ServiceRoleBinding
metadata:
  name: httpbin-client-binding
  namespace: httpbin
spec:
  subjects:
  - user: "cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account"
    properties:
      request.headers[&lt;header&gt;]: "value"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Red Hat OpenShift Service Mesh matching request headers by using regular expressions</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "rbac.istio.io/v1alpha1"
kind: ServiceRoleBinding
metadata:
  name: httpbin-client-binding
  namespace: httpbin
spec:
  subjects:
  - user: "cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account"
    properties:
      request.regex.headers[&lt;header&gt;]: "&lt;regular expression&gt;"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-openssl_ossm-vs-istio-v1x">
<title>OpenSSL</title>
<simpara>Red Hat OpenShift Service Mesh replaces BoringSSL with OpenSSL. OpenSSL is a software library that contains an open source implementation of the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols. The Red Hat OpenShift Service Mesh Proxy binary dynamically links the OpenSSL libraries (libssl and libcrypto) from the underlying Red Hat Enterprise Linux operating system.</simpara>
</section>
<section xml:id="ossm-component-modifications_ossm-vs-istio-v1x">
<title>Component modifications</title>
<itemizedlist>
<listitem>
<simpara>A <emphasis>maistra-version</emphasis> label has been added to all resources.</simpara>
</listitem>
<listitem>
<simpara>All Ingress resources have been converted to OpenShift Route resources.</simpara>
</listitem>
<listitem>
<simpara>Grafana, Tracing (Jaeger), and Kiali are enabled by default and exposed through OpenShift routes.</simpara>
</listitem>
<listitem>
<simpara>Godebug has been removed from all templates</simpara>
</listitem>
<listitem>
<simpara>The <literal>istio-multi</literal> ServiceAccount and ClusterRoleBinding have been removed, as well as the <literal>istio-reader</literal> ClusterRole.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-envoy-sds-ca_ossm-vs-istio-v1x">
<title>Envoy, Secret Discovery Service, and certificates</title>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Service Mesh does not support QUIC-based services.</simpara>
</listitem>
<listitem>
<simpara>Deployment of TLS certificates using the Secret Discovery Service (SDS) functionality of Istio is not currently supported in Red Hat OpenShift Service Mesh. The Istio implementation depends on a nodeagent container that uses hostPath mounts.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-cni_ossm-vs-istio-v1x">
<title>Istio Container Network Interface (CNI) plugin</title>
<simpara>Red Hat OpenShift Service Mesh includes CNI plugin, which provides you with an alternate way to configure application pod networking. The CNI plugin replaces the <literal>init-container</literal> network configuration eliminating the need to grant service accounts and projects access to Security Context Constraints (SCCs) with elevated privileges.</simpara>
</section>
<section xml:id="ossm-routes-gateways_ossm-vs-istio-v1x">
<title>Routes for Istio Gateways</title>
<simpara>OpenShift routes for Istio Gateways are automatically managed in Red Hat OpenShift Service Mesh. Every time an Istio Gateway is created, updated or deleted inside the service mesh, an OpenShift route is created, updated or deleted.</simpara>
<simpara>A Red Hat OpenShift Service Mesh control plane component called Istio OpenShift Routing (IOR) synchronizes the gateway route.  For more information, see Automatic route creation.</simpara>
<section xml:id="ossm-catch-all-domains_ossm-vs-istio-v1x">
<title>Catch-all domains</title>
<simpara>Catch-all domains ("*") are not supported. If one is found in the Gateway definition, Red Hat OpenShift Service Mesh <emphasis>will</emphasis> create the route, but will rely on OpenShift to create a default hostname. This means that the newly created route will <emphasis>not</emphasis> be a catch all ("*") route, instead it will have a hostname in the form <literal>&lt;route-name&gt;[-&lt;project&gt;].&lt;suffix&gt;</literal>. See the OpenShift documentation for more information about how default hostnames work and how a cluster administrator can customize it.</simpara>
</section>
<section xml:id="ossm-subdomains_ossm-vs-istio-v1x">
<title>Subdomains</title>
<simpara>Subdomains (e.g.: "*.domain.com") are supported. However this ability doesn&#8217;t come enabled by default in OpenShift Container Platform. This means that Red Hat OpenShift Service Mesh <emphasis>will</emphasis> create the route with the subdomain, but it will only be in effect if OpenShift Container Platform is configured to enable it.</simpara>
</section>
<section xml:id="ossm-tls_ossm-vs-istio-v1x">
<title>Transport layer security</title>
<simpara>Transport Layer Security (TLS) is supported. This means that, if the Gateway contains a <literal>tls</literal> section, the OpenShift Route will be configured to support TLS.</simpara>
<bridgehead xml:id="additional-resources_ossm-vs-istio-v1x" role="_additional-resources" renderas="sect5">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v1x/ossm-traffic-manage.xml#ossm-auto-route-1x_routing-traffic-v1x">Automatic route creation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ossm-kiali-service-mesh_ossm-vs-istio-v1x">
<title>Kiali and service mesh</title>
<simpara>Installing Kiali via the Service Mesh on OpenShift Container Platform differs from community Kiali installations in multiple ways. These modifications are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<itemizedlist>
<listitem>
<simpara>Kiali has been enabled by default.</simpara>
</listitem>
<listitem>
<simpara>Ingress has been enabled by default.</simpara>
</listitem>
<listitem>
<simpara>Updates have been made to the Kiali ConfigMap.</simpara>
</listitem>
<listitem>
<simpara>Updates have been made to the ClusterRole settings for Kiali.</simpara>
</listitem>
<listitem>
<simpara>Do not edit the ConfigMap, because your changes might be overwritten by the Service Mesh or Kiali Operators. Files that the Kiali Operator manages have a <literal>kiali.io/</literal> label or annotation. Updating the Operator files should be restricted to those users with <literal>cluster-admin</literal> privileges. If you use Red Hat OpenShift Dedicated, updating the Operator files should be restricted to those users with <literal>dedicated-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-jaeger-service-mesh_ossm-vs-istio-v1x">
<title>Distributed tracing and service mesh</title>
<simpara>Installing the distributed tracing platform (Jaeger) with the Service Mesh on OpenShift Container Platform differs from community Jaeger installations in multiple ways. These modifications are sometimes necessary to resolve issues, provide additional features, or to handle differences when deploying on OpenShift Container Platform.</simpara>
<itemizedlist>
<listitem>
<simpara>Distributed tracing has been enabled by default for Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>Ingress has been enabled by default for Service Mesh.</simpara>
</listitem>
<listitem>
<simpara>The name for the Zipkin port name has changed to <literal>jaeger-collector-zipkin</literal> (from <literal>http</literal>)</simpara>
</listitem>
<listitem>
<simpara>Jaeger uses Elasticsearch for storage by default when you select either the <literal>production</literal> or <literal>streaming</literal> deployment option.</simpara>
</listitem>
<listitem>
<simpara>The community version of Istio provides a generic "tracing" route. Red Hat OpenShift Service Mesh uses a "jaeger" route that is installed by the Red Hat OpenShift distributed tracing platform (Jaeger) Operator and is already protected by OAuth.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh uses a sidecar for the Envoy proxy, and Jaeger also uses a sidecar, for the Jaeger agent.
These two sidecars are configured separately and should not be confused with each other. The proxy sidecar creates spans related to the pod&#8217;s ingress and egress traffic. The agent sidecar receives the spans emitted by the application and sends them to the Jaeger Collector.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="preparing-ossm-installation-v1x">
<title>Preparing to install Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>Before you can install Red Hat OpenShift Service Mesh, review the installation activities, ensure that you meet the prerequisites:</simpara>
<section xml:id="_prerequisites_4">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Possess an active OpenShift Container Platform subscription on your Red Hat account. If you do not have a subscription, contact your sales representative for more information.</simpara>
</listitem>
<listitem>
<simpara>Review the <link xlink:href="../../architecture/architecture-installation.xml#installation-overview_architecture-installation">OpenShift Container Platform 4.14 overview</link>.</simpara>
</listitem>
<listitem>
<simpara>Install OpenShift Container Platform 4.14.</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-account.xml#installing-aws-account">Install OpenShift Container Platform 4.14 on AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-user-infra.xml#installing-aws-user-infra">Install OpenShift Container Platform 4.14 on user-provisioned AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installing-bare-metal">Install OpenShift Container Platform 4.14 on bare metal</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_vsphere/upi/installing-vsphere.xml#installing-vsphere">Install OpenShift Container Platform 4.14 on vSphere</link></simpara>
<note>
<simpara>If you are installing Red Hat OpenShift Service Mesh on a <link xlink:href="../../installing/installing-preparing.xml#supported-installation-methods-for-different-platforms">restricted network</link>, follow the instructions for your chosen OpenShift Container Platform infrastructure.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Install the version of the OpenShift Container Platform command line utility (the <literal>oc</literal> client tool) that matches your OpenShift Container Platform version and add it to your path.</simpara>
<itemizedlist>
<listitem>
<simpara>If you are using OpenShift Container Platform 4.14, see <link xlink:href="../../cli_reference/openshift_cli/getting-started-cli.xml#cli-about-cli_cli-developer-commands">About the OpenShift CLI</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-v1x_preparing-ossm-installation-v1x">
<title>Red Hat OpenShift Service Mesh supported configurations</title>
<simpara>The following are the only supported configurations for the Red Hat OpenShift Service Mesh:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform version 4.6 or later.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>OpenShift Online and Red Hat OpenShift Dedicated are not supported for Red Hat OpenShift Service Mesh.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>The deployment must be contained within a single OpenShift Container Platform cluster that is not federated.</simpara>
</listitem>
<listitem>
<simpara>This release of Red Hat OpenShift Service Mesh is only available on OpenShift Container Platform x86_64.</simpara>
</listitem>
<listitem>
<simpara>This release only supports configurations where all Service Mesh components are contained in the OpenShift Container Platform cluster in which it operates. It does not support management of microservices that reside outside of the cluster, or in a multi-cluster scenario.</simpara>
</listitem>
<listitem>
<simpara>This release only supports configurations that do not integrate external services such as virtual machines.</simpara>
</listitem>
</itemizedlist>
<simpara>For additional information about Red Hat OpenShift Service Mesh lifecycle and supported configurations, refer to the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Support Policy</link>.</simpara>
<section xml:id="ossm-supported-configurations-kiali_preparing-ossm-installation-v1x">
<title>Supported configurations for Kiali on Red Hat OpenShift Service Mesh</title>
<itemizedlist>
<listitem>
<simpara>The Kiali observability console is only supported on the two most recent releases of the Chrome, Edge, Firefox, or Safari browsers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-supported-configurations-adapters_preparing-ossm-installation-v1x">
<title>Supported Mixer adapters</title>
<itemizedlist>
<listitem>
<simpara>This release only supports the following Mixer adapter:</simpara>
<itemizedlist>
<listitem>
<simpara>3scale Istio Adapter</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-installation-activities_preparing-ossm-installation-v1x">
<title>Operator overview</title>
<simpara>Red Hat OpenShift Service Mesh requires the following Operators:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">OpenShift Elasticsearch</emphasis> - (Optional) Provides database storage for tracing and logging with the distributed tracing platform (Jaeger). It is based on the open source <link xlink:href="https://www.elastic.co/">Elasticsearch</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger)</emphasis> - Provides distributed tracing to monitor and troubleshoot transactions in complex distributed systems. It is based on the open source <link xlink:href="https://www.jaegertracing.io/">Jaeger</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Kiali Operator provided by Red Hat</emphasis> - Provides observability for your service mesh. You can view configurations, monitor traffic, and analyze traces in a single console. It is based on the open source <link xlink:href="https://www.kiali.io/">Kiali</link> project.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> - Allows you to connect, secure, control, and observe the microservices that comprise your applications. The Service Mesh Operator defines and monitors the <literal>ServiceMeshControlPlane</literal> resources that manage the deployment, updating, and deletion of the Service Mesh components. It is based on the open source <link xlink:href="https://istio.io/">Istio</link> project.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>See <link xlink:href="../../logging/log_storage/logging-config-es-store.xml#logging-config-es-store">Configuring the Elasticsearch log store</link> for details on configuring the default Jaeger parameters for Elasticsearch in a production environment.</simpara>
</warning>
</section>
<section xml:id="_next_steps_8">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v1x/installing-ossm.xml#installing-ossm-v1x">Install Red Hat OpenShift Service Mesh</link> in your OpenShift Container Platform environment.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="installing-ossm-v1x">
<title>Installing Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>Installing the Service Mesh involves installing the OpenShift Elasticsearch, Jaeger, Kiali and Service Mesh Operators, creating and managing a <literal>ServiceMeshControlPlane</literal> resource to deploy the control plane, and creating a <literal>ServiceMeshMemberRoll</literal> resource to specify the namespaces associated with the Service Mesh.</simpara>
<note>
<simpara>Mixer&#8217;s policy enforcement is disabled by default. You must enable it to run policy tasks. See <link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#ossm-mixer-policy-1x_deploying-applications-ossm-v1x">Update Mixer policy enforcement</link> for instructions on enabling Mixer policy enforcement.</simpara>
</note>
<note>
<simpara>Multi-tenant control plane installations are the default configuration.</simpara>
</note>
<note>
<simpara>The Service Mesh documentation uses <literal>istio-system</literal> as the example project, but you can deploy the service mesh to any project.</simpara>
</note>
<section xml:id="_prerequisites_5">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Follow the <link xlink:href="../../service_mesh/v1x/preparing-ossm-installation.xml#preparing-ossm-installation-v1x">Preparing to install Red Hat OpenShift Service Mesh</link> process.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<simpara>The Service Mesh installation process uses the <link xlink:href="https://operatorhub.io/">OperatorHub</link> to install the <literal>ServiceMeshControlPlane</literal> custom resource definition within the <literal>openshift-operators</literal> project. The Red Hat OpenShift Service Mesh defines and monitors the <literal>ServiceMeshControlPlane</literal> related to the deployment, update, and deletion of the control plane.</simpara>
<simpara>Starting with Red Hat OpenShift Service Mesh 1.1.18.2, you must install the OpenShift Elasticsearch Operator, the Jaeger Operator, and the Kiali Operator before the Red Hat OpenShift Service Mesh Operator can install the control plane.</simpara>
</section>
<section xml:id="distr-tracing-operator-install-elasticsearch_installing-ossm-v1x">
<title>Installing the OpenShift Elasticsearch Operator</title>
<simpara>The default Red Hat OpenShift distributed tracing platform (Jaeger) deployment uses in-memory storage because it is designed to be installed quickly for those evaluating Red Hat OpenShift distributed tracing platform, giving demonstrations, or using Red Hat OpenShift distributed tracing platform (Jaeger) in a test environment. If you plan to use Red Hat OpenShift distributed tracing platform (Jaeger) in production, you must install and configure a persistent storage option, in this case, Elasticsearch.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Do not install Community versions of the Operators. Community Operators are not supported.</simpara>
</warning>
<note>
<simpara>If you have already installed the OpenShift Elasticsearch Operator as part of OpenShift Logging, you do not need to install the OpenShift Elasticsearch Operator again. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator creates the Elasticsearch instance using the installed OpenShift Elasticsearch Operator.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">Elasticsearch</emphasis> into the filter box to locate the OpenShift Elasticsearch Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">OpenShift Elasticsearch Operator</emphasis> provided by Red Hat to display information about the Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, select the <emphasis role="strong">stable</emphasis> Update Channel. This automatically updates your Operator as new versions are released.</simpara>
</listitem>
<listitem>
<simpara>Accept the default <emphasis role="strong">All namespaces on the cluster (default)</emphasis>. This installs the Operator in the default <literal>openshift-operators-redhat</literal> project and makes the Operator available to all projects in the cluster.</simpara>
<note>
<simpara>The Elasticsearch installation requires the <emphasis role="strong">openshift-operators-redhat</emphasis> namespace for the OpenShift Elasticsearch Operator. The other Red Hat OpenShift distributed tracing platform Operators are installed in the <literal>openshift-operators</literal> namespace.</simpara>
</note>
</listitem>
<listitem>
<simpara>Accept the default <emphasis role="strong">Automatic</emphasis> approval strategy. By accepting the default, when a new version of this Operator is available, Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention. If you select <emphasis role="strong">Manual</emphasis> updates, when a newer version of an Operator is available, OLM creates an update request. As a cluster administrator, you must then manually approve that update request to have the Operator updated to the new version.</simpara>
<note>
<simpara>The <emphasis role="strong">Manual</emphasis> approval strategy requires a user with appropriate credentials to approve the Operator install and subscription process.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, select the <literal>openshift-operators-redhat</literal> project. Wait until you see that the OpenShift Elasticsearch Operator shows a status of "InstallSucceeded" before continuing.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="distr-tracing-jaeger-operator-install_installing-ossm-v1x">
<title>Installing the Red Hat OpenShift distributed tracing platform (Jaeger) Operator</title>
<simpara>To install Red Hat OpenShift distributed tracing platform (Jaeger), you use the <link xlink:href="https://operatorhub.io/">OperatorHub</link> to install the Red Hat OpenShift distributed tracing platform (Jaeger) Operator.</simpara>
<simpara>By default, the Operator is installed in the <literal>openshift-operators</literal> project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>If you require persistent storage, you must also install the OpenShift Elasticsearch Operator before installing the Red Hat OpenShift distributed tracing platform (Jaeger) Operator.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Do not install Community versions of the Operators. Community Operators are not supported.</simpara>
</warning>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">distributed tracing platform</emphasis> into the filter to locate the Red Hat OpenShift distributed tracing platform (Jaeger) Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Red Hat OpenShift distributed tracing platform (Jaeger) Operator</emphasis> provided by Red Hat to display information about the Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, select the <emphasis role="strong">stable</emphasis> Update Channel. This automatically updates your Operator as new versions are released.</simpara>
</listitem>
<listitem>
<simpara>Accept the default <emphasis role="strong">All namespaces on the cluster (default)</emphasis>. This installs the Operator in the default <literal>openshift-operators</literal> project and makes the Operator available to all projects in the cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>Accept the default <emphasis role="strong">Automatic</emphasis> approval strategy. By accepting the default, when a new version of this Operator is available, Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention. If you select <emphasis role="strong">Manual</emphasis> updates, when a newer version of an Operator is available, OLM creates an update request. As a cluster administrator, you must then manually approve that update request to have the Operator updated to the new version.</simpara>
<note>
<simpara>The <emphasis role="strong">Manual</emphasis> approval strategy requires a user with appropriate credentials to approve the Operator install and subscription process.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, select the <literal>openshift-operators</literal> project. Wait until you see that the Red Hat OpenShift distributed tracing platform (Jaeger) Operator shows a status of "Succeeded" before continuing.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-install-kiali_installing-ossm-v1x">
<title>Installing the Kiali Operator</title>
<simpara>You must install the Kiali Operator for the Red Hat OpenShift Service Mesh Operator to install the Service Mesh control plane.</simpara>
<warning>
<simpara>Do not install Community versions of the Operators. Community Operators are not supported.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">Kiali</emphasis> into the filter box to find the Kiali Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Kiali Operator</emphasis> provided by Red Hat to display information about the Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Installation</emphasis> page, select the <emphasis role="strong">stable</emphasis> Update Channel.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">All namespaces on the cluster (default)</emphasis>. This installs the Operator in the default <literal>openshift-operators</literal> project and makes the Operator available to all projects in the cluster.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Automatic</emphasis> Approval Strategy.</simpara>
<note>
<simpara>The Manual approval strategy requires a user with appropriate credentials to approve the Operator install and subscription process.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Installed Operators</emphasis> page displays the Kiali Operator&#8217;s installation progress.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-install-ossm-operator_installing-ossm-v1x">
<title>Installing the Operators</title>
<simpara>To install Red Hat OpenShift Service Mesh, install the following Operators in this order. Repeat the procedure for each Operator.</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Elasticsearch</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform (Jaeger)</simpara>
</listitem>
<listitem>
<simpara>Kiali Operator provided by Red Hat</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you have already installed the OpenShift Elasticsearch Operator as part of OpenShift Logging, you do not need to install the OpenShift Elasticsearch Operator again. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator will create the Elasticsearch instance using the installed OpenShift Elasticsearch Operator.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>In the OpenShift Container Platform web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type the name of the Operator into the filter box and select the Red Hat version of the Operator. Community versions of the Operators are not supported.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page for each Operator, accept  the default settings.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>. Wait until the Operator has installed before repeating the steps for the next Operator in the list.</simpara>
<itemizedlist>
<listitem>
<simpara>The OpenShift Elasticsearch Operator is installed in the <literal>openshift-operators-redhat</literal> namespace and is available for all namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>The Red Hat OpenShift distributed tracing platform (Jaeger) is installed in the <literal>openshift-distributed-tracing</literal> namespace and is available for all namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>The Kiali Operator provided by Red Hat and the Red Hat OpenShift Service Mesh Operator are installed in the <literal>openshift-operators</literal> namespace and are available for all namespaces in the cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all you have installed all four Operators, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> to verify that your Operators installed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-control-plane-deploy-1x_installing-ossm-v1x">
<title>Deploying the Red Hat OpenShift Service Mesh control plane</title>
<simpara>The <literal>ServiceMeshControlPlane</literal> resource defines the configuration to be used during installation. You can deploy the default configuration provided by Red Hat or customize the <literal>ServiceMeshControlPlane</literal> file to fit your business needs.</simpara>
<simpara>You can deploy the Service Mesh control plane by using the OpenShift Container Platform web console or from the command line using the <literal>oc</literal> client tool.</simpara>
<section xml:id="ossm-control-plane-deploy-operatorhub_installing-ossm-v1x">
<title>Deploying the control plane from the web console</title>
<simpara>Follow this procedure to deploy the Red Hat OpenShift Service Mesh control plane by using the web console.  In this example, <literal>istio-system</literal> is the name of the control plane project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>Review the instructions for how to customize the Red Hat OpenShift Service Mesh installation.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>istio-system</literal> in the <emphasis role="strong">Name</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If necessary, select <literal>istio-system</literal> from the Project menu.  You may have to wait a few moments for the Operators to be copied to the new project.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.  Under <emphasis role="strong">Provided APIs</emphasis>, the Operator provides links to create two resource types:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>ServiceMeshControlPlane</literal> resource</simpara>
</listitem>
<listitem>
<simpara>A <literal>ServiceMeshMemberRoll</literal> resource</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> click <emphasis role="strong">Create ServiceMeshControlPlane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create Service Mesh Control Plane</emphasis> page, modify the YAML for the default <literal>ServiceMeshControlPlane</literal> template as needed.</simpara>
<note>
<simpara>For additional information about customizing the control plane, see customizing the Red Hat OpenShift Service Mesh installation. For production, you <emphasis>must</emphasis> change the default Jaeger template.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the control plane.  The Operator creates pods, services, and Service Mesh control plane components based on your configuration parameters.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the new control plane.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Resources</emphasis> tab to see the Red Hat OpenShift Service Mesh control plane resources the Operator created and configured.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-control-plane-deploy-cli_installing-ossm-v1x">
<title>Deploying the control plane from the CLI</title>
<simpara>Follow this procedure to deploy the Red Hat OpenShift Service Mesh control plane the command line.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Red Hat OpenShift Service Mesh Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>Review the instructions for how to customize the Red Hat OpenShift Service Mesh installation.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>Create a project named <literal>istio-system</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project istio-system</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ServiceMeshControlPlane</literal> file named <literal>istio-installation.yaml</literal> using the example found in "Customize the Red Hat OpenShift Service Mesh installation". You can customize the values as needed to match your use case.  For production deployments you <emphasis>must</emphasis> change the default Jaeger template.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to deploy the control plane:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f istio-installation.yaml</programlisting>
</listitem>
<listitem>
<simpara>Execute the following command to see the status of the control plane installation.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n istio-system</programlisting>
<simpara>The installation has finished successfully when the STATUS column is <literal>ComponentsReady</literal>.</simpara>
<screen>NAME            READY   STATUS            PROFILES      VERSION   AGE
basic-install   11/11   ComponentsReady   ["default"]   v1.1.18   4m25s</screen>
</listitem>
<listitem>
<simpara>Run the following command to watch the progress of the Pods during the installation process:</simpara>
<screen>$ oc get pods -n istio-system -w</screen>
<simpara>You should see output similar to the following:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                     READY   STATUS             RESTARTS   AGE
grafana-7bf5764d9d-2b2f6                 2/2     Running            0          28h
istio-citadel-576b9c5bbd-z84z4           1/1     Running            0          28h
istio-egressgateway-5476bc4656-r4zdv     1/1     Running            0          28h
istio-galley-7d57b47bb7-lqdxv            1/1     Running            0          28h
istio-ingressgateway-dbb8f7f46-ct6n5     1/1     Running            0          28h
istio-pilot-546bf69578-ccg5x             2/2     Running            0          28h
istio-policy-77fd498655-7pvjw            2/2     Running            0          28h
istio-sidecar-injector-df45bd899-ctxdt   1/1     Running            0          28h
istio-telemetry-66f697d6d5-cj28l         2/2     Running            0          28h
jaeger-896945cbc-7lqrr                   2/2     Running            0          11h
kiali-78d9c5b87c-snjzh                   1/1     Running            0          22h
prometheus-6dff867c97-gr2n5              2/2     Running            0          28h</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>For a multitenant installation, Red Hat OpenShift Service Mesh supports multiple independent control planes within the cluster.  You can create reusable configurations with <literal>ServiceMeshControlPlane</literal> templates.  For more information, see <link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#ossm-control-plane-templates-1x_deploying-applications-ossm-v1x">Creating control plane templates</link>.</simpara>
</section>
</section>
<section xml:id="ossm-member-roll-create_installing-ossm-v1x">
<title>Creating the Red Hat OpenShift Service Mesh member roll</title>
<simpara>The <literal>ServiceMeshMemberRoll</literal> lists the projects that belong to the Service Mesh control plane. Only projects listed in the <literal>ServiceMeshMemberRoll</literal> are affected by the control plane. A project does not belong to a service mesh until you add it to the member roll for a particular control plane deployment.</simpara>
<simpara>You must create a <literal>ServiceMeshMemberRoll</literal> resource named <literal>default</literal> in the same project as the <literal>ServiceMeshControlPlane</literal>, for example <literal>istio-system</literal>.</simpara>
<section xml:id="ossm-member-roll-create-console_installing-ossm-v1x">
<title>Creating the member roll from the web console</title>
<simpara>You can add one or more projects to the Service Mesh member roll from the web console. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>List of existing projects to add to the service mesh.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>If you do not already have services for your mesh, or you are starting from scratch, create a project for your applications. It must be different from the project where you installed the Service Mesh control plane.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a name in the <emphasis role="strong">Name</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project where your <literal>ServiceMeshControlPlane</literal> resource is deployed from the list, for example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ServiceMeshMemberRoll</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Members</emphasis>, then enter the name of your project in the <emphasis role="strong">Value</emphasis> field. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-member-roll-create-cli_installing-ossm-v1x">
<title>Creating the member roll from the CLI</title>
<simpara>You can add a project to the <literal>ServiceMeshMemberRoll</literal> from the command line.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>List of projects to add to the service mesh.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --username=&lt;NAMEOFUSER&gt; https://&lt;HOSTNAME&gt;:6443</programlisting>
</listitem>
<listitem>
<simpara>If you do not already have services for your mesh, or you are starting from scratch, create a project for your applications. It must be different from the project where you installed the Service Mesh control plane.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;your-project&gt;</programlisting>
</listitem>
<listitem>
<simpara>To add your projects as members, modify the following example YAML. You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<formalpara>
<title>Example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system
spec:
  members:
    # a list of projects joined into the service mesh
    - your-project-name
    - another-project-name</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload and create the <literal>ServiceMeshMemberRoll</literal> resource in the <literal>istio-system</literal> namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f servicemeshmemberroll-default.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify the <literal>ServiceMeshMemberRoll</literal> was created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smmr -n istio-system default</programlisting>
<simpara>The installation has finished successfully when the <literal>STATUS</literal> column is <literal>Configured</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-member-roll-modify_installing-ossm-v1x">
<title>Adding or removing projects from the service mesh</title>
<simpara>You can add or remove projects from an existing Service Mesh <literal>ServiceMeshMemberRoll</literal> resource using the web console.</simpara>
<itemizedlist>
<listitem>
<simpara>You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ServiceMeshMemberRoll</literal> resource is deleted when its corresponding <literal>ServiceMeshControlPlane</literal> resource is deleted.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-member-roll-modify-console_installing-ossm-v1x">
<title>Adding or removing projects from the member roll using the web console</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Name of the project with the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Names of the projects you want to add or remove from the mesh.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose the project where your <literal>ServiceMeshControlPlane</literal> resource is deployed from the list, for example <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>default</literal> link.</simpara>
</listitem>
<listitem>
<simpara>Click the YAML tab.</simpara>
</listitem>
<listitem>
<simpara>Modify the YAML to add or remove projects as members.  You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-member-roll-modify-cli_installing-ossm-v1x">
<title>Adding or removing projects from the member roll using the CLI</title>
<simpara>You can modify an existing Service Mesh member roll using the command line.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An existing <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Name of the project with the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Names of the projects you want to add or remove from the mesh.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit smmr -n &lt;controlplane-namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Modify the YAML to add or remove projects as members.  You can add any number of projects, but a project can only belong to <emphasis role="strong">one</emphasis> <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<formalpara>
<title>Example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
  namespace: istio-system #control plane project
spec:
  members:
    # a list of projects joined into the service mesh
    - your-project-name
    - another-project-name</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_manual_updates">
<title>Manual updates</title>
<simpara>If you choose to update manually, the Operator Lifecycle Manager (OLM) controls the installation, upgrade, and role-based access control (RBAC) of Operators in a cluster. OLM runs by default in OpenShift Container Platform.
OLM uses CatalogSources, which use the Operator Registry API, to query for available Operators as well as upgrades for installed Operators.</simpara>
<itemizedlist>
<listitem>
<simpara>For more information about how OpenShift Container Platform handled upgrades, refer to the <link xlink:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-overview_olm-understanding-olm">Operator Lifecycle Manager</link> documentation.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-update-app-sidecar_installing-ossm-v1x">
<title>Updating sidecar proxies</title>
<simpara>In order to update the configuration for sidecar proxies the application administrator must restart the application pods.</simpara>
<simpara>If your deployment uses automatic sidecar injection, you can update the pod template in the deployment by adding or modifying an annotation. Run the following command to redeploy the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch deployment/&lt;deployment&gt; -p '{"spec":{"template":{"metadata":{"annotations":{"kubectl.kubernetes.io/restartedAt": "'`date -Iseconds`'"}}}}}'</programlisting>
<simpara>If your deployment does not use automatic sidecar injection, you must manually update the sidecars by modifying the sidecar container image specified in the deployment or pod, and then restart the pods.</simpara>
</section>
</section>
<section xml:id="_next_steps_9">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#deploying-applications-ossm-v1x">Prepare to deploy applications</link> on Red Hat OpenShift Service Mesh.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-security-v1x">
<title>Customizing security in a Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>If your service mesh application is constructed with a complex array of microservices, you can use Red Hat OpenShift Service Mesh to customize the security of the communication between those services. The infrastructure of OpenShift Container Platform along with the traffic management features of Service Mesh can help you manage the complexity of your applications and provide service and identity security for microservices.</simpara>
<section xml:id="ossm-security-mtls_ossm-security-v1x">
<title>Enabling mutual Transport Layer Security (mTLS)</title>
<simpara>Mutual Transport Layer Security (mTLS) is a protocol where two parties authenticate each other. It is the default mode of authentication in some protocols (IKE, SSH) and optional in others (TLS).</simpara>
<simpara>mTLS can be used without changes to the application or service code. The TLS is handled entirely by the service mesh infrastructure and between the two sidecar proxies.</simpara>
<simpara>By default, Red Hat OpenShift Service Mesh is set to permissive mode, where the sidecars in Service Mesh accept both plain-text traffic and connections that are encrypted using mTLS. If a service in your mesh is communicating with a service outside the mesh, strict mTLS could break communication between those services. Use permissive mode while you migrate your workloads to Service Mesh.</simpara>
<section xml:id="ossm-security-enabling-strict-mtls_ossm-security-v1x">
<title>Enabling strict mTLS across the mesh</title>
<simpara>If your workloads do not communicate with services outside your mesh and communication will not be interrupted by only accepting encrypted connections, you can enable mTLS across your mesh quickly. Set <literal>spec.istio.global.mtls.enabled</literal> to <literal>true</literal> in your <literal>ServiceMeshControlPlane</literal> resource. The operator creates the required resources.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    global:
      mtls:
        enabled: true</programlisting>
<section xml:id="ossm-security-mtls-sidecars-incoming-services_ossm-security-v1x">
<title>Configuring sidecars for incoming connections for specific services</title>
<simpara>You can also configure mTLS for individual services or namespaces by creating a policy.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "authentication.istio.io/v1alpha1"
kind: "Policy"
metadata:
  name: default
  namespace: &lt;NAMESPACE&gt;
spec:
  peers:
    - mtls: {}</programlisting>
</section>
</section>
<section xml:id="ossm-security-mtls-sidecars-outgoing_ossm-security-v1x">
<title>Configuring sidecars for outgoing connections</title>
<simpara>Create a destination rule to configure Service Mesh to use mTLS when sending requests to other services in the mesh.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "networking.istio.io/v1alpha3"
kind: "DestinationRule"
metadata:
  name: "default"
  namespace: &lt;CONTROL_PLANE_NAMESPACE&gt;&gt;
spec:
  host: "*.local"
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL</programlisting>
</section>
<section xml:id="ossm-security-min-max-tls_ossm-security-v1x">
<title>Setting the minimum and maximum protocol versions</title>
<simpara>If your environment has specific requirements for encrypted traffic in your service mesh, you can control the cryptographic functions that are allowed by setting the <literal>spec.security.controlPlane.tls.minProtocolVersion</literal> or <literal>spec.security.controlPlane.tls.maxProtocolVersion</literal> in your <literal>ServiceMeshControlPlane</literal> resource. Those values, configured in your control plane resource, define the minimum and maximum TLS version used by mesh components when communicating securely over TLS.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    global:
      tls:
        minProtocolVersion: TLSv1_2
        maxProtocolVersion: TLSv1_3</programlisting>
<simpara>The default is <literal>TLS_AUTO</literal> and does not specify a version of TLS.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Valid values</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>TLS_AUTO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>default</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>TLSv1_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>TLS version 1.3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="ossm-security-cipher-1x_ossm-security-v1x">
<title>Configuring cipher suites and ECDH curves</title>
<simpara>Cipher suites and Elliptic-curve Diffie–Hellman (ECDH curves) can help you secure your service mesh. You can define a comma separated list of cipher suites using <literal>spec.istio.global.tls.cipherSuites</literal> and ECDH curves using <literal>spec.istio.global.tls.ecdhCurves</literal> in your <literal>ServiceMeshControlPlane</literal> resource. If either of these attributes are empty, then the default values are used.</simpara>
<simpara>The <literal>cipherSuites</literal> setting is effective if your service mesh uses TLS 1.2 or earlier. It has no effect when negotiating with TLS 1.3.</simpara>
<simpara>Set your cipher suites in the comma separated list in order of priority. For example, <literal>ecdhCurves: CurveP256, CurveP384</literal> sets <literal>CurveP256</literal> as a higher priority than <literal>CurveP384</literal>.</simpara>
<note>
<simpara>You must include either <literal>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</literal> or  <literal>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</literal> when you configure the cipher suite. HTTP/2 support requires at least one of these cipher suites.</simpara>
</note>
<simpara>The supported cipher suites are:</simpara>
<itemizedlist>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_GCM_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_256_GCM_SHA384</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_CBC_SHA256</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_128_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_AES_256_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA</simpara>
</listitem>
<listitem>
<simpara>TLS_RSA_WITH_3DES_EDE_CBC_SHA</simpara>
</listitem>
</itemizedlist>
<simpara>The supported ECDH Curves are:</simpara>
<itemizedlist>
<listitem>
<simpara>CurveP256</simpara>
</listitem>
<listitem>
<simpara>CurveP384</simpara>
</listitem>
<listitem>
<simpara>CurveP521</simpara>
</listitem>
<listitem>
<simpara>X25519</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-cert-manage-1x_ossm-security-v1x">
<title>Adding an external certificate authority key and certificate</title>
<simpara>By default, Red Hat OpenShift Service Mesh generates self-signed root certificate and key, and uses them to sign the workload certificates. You can also use the user-defined certificate and key to sign workload certificates, with user-defined root certificate. This task demonstrates an example to plug certificates and key into Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have installed Red Hat OpenShift Service Mesh with mutual TLS enabled to configure certificates.</simpara>
</listitem>
<listitem>
<simpara>This example uses the certificates from the <link xlink:href="https://github.com/maistra/istio/tree/maistra-2.0/samples/certs">Maistra repository</link>. For production, use your own certificates from your certificate authority.</simpara>
</listitem>
<listitem>
<simpara>You must deploy the Bookinfo sample application to verify the results with these instructions.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-cert-manage-add-cert-key-1x_ossm-security-v1x">
<title>Adding an existing certificate and key</title>
<simpara>To use an existing signing (CA) certificate and key, you must create a chain of trust file that includes the CA certificate, key, and root certificate. You must use the following exact file names for each of the corresponding certificates. The CA certificate is called <literal>ca-cert.pem</literal>, the key is <literal>ca-key.pem</literal>, and the root certificate, which signs <literal>ca-cert.pem</literal>, is called <literal>root-cert.pem</literal>. If your workload uses intermediate certificates, you must specify them in a <literal>cert-chain.pem</literal> file.</simpara>
<simpara>Add the certificates to Service Mesh by following these steps. Save the example certificates from the <link xlink:href="https://github.com/maistra/istio/tree/maistra-1.1/samples/certs">Maistra repo</link> locally and replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a secret <literal>cacert</literal> that includes the input files <literal>ca-cert.pem</literal>, <literal>ca-key.pem</literal>, <literal>root-cert.pem</literal> and <literal>cert-chain.pem</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic cacerts -n istio-system --from-file=&lt;path&gt;/ca-cert.pem \
    --from-file=&lt;path&gt;/ca-key.pem --from-file=&lt;path&gt;/root-cert.pem \
    --from-file=&lt;path&gt;/cert-chain.pem</programlisting>
</listitem>
<listitem>
<simpara>In the <literal>ServiceMeshControlPlane</literal> resource set <literal>global.mtls.enabled</literal> to <literal>true</literal> and <literal>security.selfSigned</literal> set to <literal>false</literal>. Service Mesh reads the certificates and key from the secret-mount files.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    global:
      mtls:
        enabled: true
    security:
      selfSigned: false</programlisting>
</listitem>
<listitem>
<simpara>To make sure the workloads add the new certificates promptly, delete the secrets generated by Service Mesh, named <literal>istio.*</literal>. In this example, <literal>istio.default</literal>. Service Mesh issues new certificates for the workloads.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret istio.default</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-cert-manage-verify-cert-1x_ossm-security-v1x">
<title>Verifying your certificates</title>
<simpara>Use the Bookinfo sample application to verify your certificates are mounted correctly. First, retrieve the mounted certificates. Then, verify the certificates mounted on the pod.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Store the pod name in the variable <literal>RATINGSPOD</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RATINGSPOD=`oc get pods -l app=ratings -o jsonpath='{.items[0].metadata.name}'`</programlisting>
</listitem>
<listitem>
<simpara>Run the following commands to retrieve the certificates mounted on the proxy.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it $RATINGSPOD -c istio-proxy -- /bin/cat /etc/certs/root-cert.pem &gt; /tmp/pod-root-cert.pem</programlisting>
<simpara>The file <literal>/tmp/pod-root-cert.pem</literal> contains the root certificate propagated to the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it $RATINGSPOD -c istio-proxy -- /bin/cat /etc/certs/cert-chain.pem &gt; /tmp/pod-cert-chain.pem</programlisting>
<simpara>The file <literal>/tmp/pod-cert-chain.pem</literal> contains the workload certificate and the CA certificate propagated to the pod.</simpara>
</listitem>
<listitem>
<simpara>Verify the root certificate is the same as the one specified by the Operator. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in &lt;path&gt;/root-cert.pem -text -noout &gt; /tmp/root-cert.crt.txt</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in /tmp/pod-root-cert.pem -text -noout &gt; /tmp/pod-root-cert.crt.txt</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ diff /tmp/root-cert.crt.txt /tmp/pod-root-cert.crt.txt</programlisting>
<simpara>Expect the output to be empty.</simpara>
</listitem>
<listitem>
<simpara>Verify the CA certificate is the same as the one specified by Operator. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sed '0,/^-----END CERTIFICATE-----/d' /tmp/pod-cert-chain.pem &gt; /tmp/pod-cert-chain-ca.pem</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in &lt;path&gt;/ca-cert.pem -text -noout &gt; /tmp/ca-cert.crt.txt</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl x509 -in /tmp/pod-cert-chain-ca.pem -text -noout &gt; /tmp/pod-cert-chain-ca.crt.txt</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ diff /tmp/ca-cert.crt.txt /tmp/pod-cert-chain-ca.crt.txt</programlisting>
<simpara>Expect the output to be empty.</simpara>
</listitem>
<listitem>
<simpara>Verify the certificate chain from the root certificate to the workload certificate. Replace <literal>&lt;path&gt;</literal> with the path to your certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ head -n 21 /tmp/pod-cert-chain.pem &gt; /tmp/pod-cert-chain-workload.pem</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ openssl verify -CAfile &lt;(cat &lt;path&gt;/ca-cert.pem &lt;path&gt;/root-cert.pem) /tmp/pod-cert-chain-workload.pem</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/tmp/pod-cert-chain-workload.pem: OK</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-cert-cleanup-1x_ossm-security-v1x">
<title>Removing the certificates</title>
<simpara>To remove the certificates you added, follow these steps.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Remove the secret <literal>cacerts</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret cacerts -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Redeploy Service Mesh with a self-signed root certificate in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    global:
      mtls:
        enabled: true
    security:
      selfSigned: true</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-routing-traffic-v1x">
<title>Traffic management</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>You can control the flow of traffic and API calls between services in Red Hat OpenShift Service Mesh. For example, some services in your service mesh may need to communicate within the mesh and others may need to be hidden. Manage the traffic to hide specific backend services, expose services, create testing or versioning deployments, or add a security layer on a set of services.</simpara>
<section xml:id="ossm-gateways_routing-traffic-v1x">
<title>Using gateways</title>
<simpara>You can use a gateway to manage inbound and outbound traffic for your mesh to specify which traffic you want to enter or leave the mesh. Gateway configurations are applied to standalone Envoy proxies that are running at the edge of the mesh, rather than sidecar Envoy proxies running alongside your service workloads.</simpara>
<simpara>Unlike other mechanisms for controlling traffic entering your systems, such as the Kubernetes Ingress APIs, Red Hat OpenShift Service Mesh gateways use the full power and flexibility of traffic routing.</simpara>
<simpara>The Red Hat OpenShift Service Mesh gateway resource can use layer 4-6 load balancing properties, such as ports, to expose and configure Red Hat OpenShift Service Mesh TLS settings. Instead of adding application-layer traffic routing (L7) to the same API resource, you can bind a regular Red Hat OpenShift Service Mesh virtual service to the gateway and manage gateway traffic like any other data plane traffic in a service mesh.</simpara>
<simpara>Gateways are primarily used to manage ingress traffic, but you can also configure egress gateways. An egress gateway lets you configure a dedicated exit node for the traffic leaving the mesh. This enables you to limit which services have access to external networks, which adds security control to your service mesh. You can also use a gateway to configure a purely internal proxy.</simpara>
<formalpara>
<title>Gateway example</title>
<para>A gateway resource describes a load balancer operating at the edge of the mesh receiving incoming or outgoing HTTP/TCP connections. The specification describes a set of ports that should be exposed, the type of protocol to use, SNI configuration for the load balancer, and so on.</para>
</formalpara>
<simpara>The following example shows a sample gateway configuration for external HTTPS ingress traffic:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: ext-host-gwy
spec:
  selector:
    istio: ingressgateway # use istio default controller
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - ext-host.example.com
    tls:
      mode: SIMPLE
      serverCertificate: /tmp/tls.crt
      privateKey: /tmp/tls.key</programlisting>
<simpara>This gateway configuration lets HTTPS traffic from <literal>ext-host.example.com</literal> into the mesh on port 443, but doesn’t specify any routing for the traffic.</simpara>
<simpara>To specify routing and for the gateway to work as intended, you must also bind the gateway to a virtual service. You do this using the virtual service&#8217;s gateways field, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: virtual-svc
spec:
  hosts:
  - ext-host.example.com
  gateways:
    - ext-host-gwy</programlisting>
<simpara>You can then configure the virtual service with routing rules for the external traffic.</simpara>
</section>
<section xml:id="ossm-routing-ingress-gateway_routing-traffic-v1x">
<title>Configuring an ingress gateway</title>
<simpara>An ingress gateway is a load balancer operating at the edge of the mesh that receives incoming HTTP/TCP connections. It configures exposed ports and protocols but does not include any traffic routing configuration. Traffic routing for ingress traffic is instead configured with routing rules, the same way as for internal service requests.</simpara>
<simpara>The following steps show how to create a gateway and configure a <literal>VirtualService</literal> to expose a service in the Bookinfo sample application to outside traffic for paths <literal>/productpage</literal> and <literal>/login</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a gateway to accept traffic.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, and copy the following YAML into it.</simpara>
<formalpara>
<title>Gateway example gateway.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: bookinfo-gateway
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - "*"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the YAML file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f gateway.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>VirtualService</literal> object to rewrite the host header.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, and copy the following YAML into it.</simpara>
<formalpara>
<title>Virtual service example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: bookinfo
spec:
  hosts:
  - "*"
  gateways:
  - bookinfo-gateway
  http:
  - match:
    - uri:
        exact: /productpage
    - uri:
        prefix: /static
    - uri:
        exact: /login
    - uri:
        exact: /logout
    - uri:
        prefix: /api/v1/products
    route:
    - destination:
        host: productpage
        port:
          number: 9080</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the YAML file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f vs.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Test that the gateway and VirtualService have been set correctly.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the Gateway URL.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Set the port number. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export TARGET_PORT=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.port.targetPort}')</programlisting>
</listitem>
<listitem>
<simpara>Test a page that has been explicitly exposed.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">curl -s -I "$GATEWAY_URL/productpage"</programlisting>
<simpara>The expected result is <literal>200</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-routing-ingress_routing-traffic-v1x">
<title>Managing ingress traffic</title>
<simpara>In Red Hat OpenShift Service Mesh, the Ingress Gateway enables features such as monitoring, security, and route rules to apply to traffic that enters the cluster. Use a Service Mesh gateway to expose a service outside of the service mesh.</simpara>
<section xml:id="ossm-routing-determine-ingress_routing-traffic-v1x">
<title>Determining the ingress IP and ports</title>
<simpara>Ingress configuration differs depending on if your environment supports an external load balancer. An external load balancer is set in the ingress IP and ports for the cluster. To determine if your cluster&#8217;s IP and ports are configured for external load balancers, run the following command. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get svc istio-ingressgateway -n istio-system</programlisting>
<simpara>That command returns the <literal>NAME</literal>, <literal>TYPE</literal>, <literal>CLUSTER-IP</literal>, <literal>EXTERNAL-IP</literal>, <literal>PORT(S)</literal>, and <literal>AGE</literal> of each item in your namespace.</simpara>
<simpara>If the <literal>EXTERNAL-IP</literal> value is set, your environment has an external load balancer that you can use for the ingress gateway.</simpara>
<simpara>If the <literal>EXTERNAL-IP</literal> value is <literal>&lt;none&gt;</literal>, or perpetually <literal>&lt;pending&gt;</literal>, your environment does not provide an external load balancer for the ingress gateway.
You can access the gateway using the service&#8217;s <link xlink:href="../../networking/configuring-node-port-service-range.xml">node port</link>.</simpara>
<section xml:id="ossm-routing-config-ig-lb_routing-traffic-v1x">
<title>Determining ingress ports with a load balancer</title>
<simpara>Follow these instructions if your environment has an external load balancer.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to set the ingress IP and ports. This command sets a variable in your terminal.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_HOST=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].port}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the secure ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export SECURE_INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].port}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the TCP ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export TCP_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="tcp")].port}')</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>In some environments, the load balancer may be exposed using a hostname instead of an IP address. For that case, the ingress gateway&#8217;s <literal>EXTERNAL-IP</literal> value is not an IP address. Instead, it&#8217;s a hostname, and the previous command fails to set the <literal>INGRESS_HOST</literal> environment variable.</simpara>
<simpara>In that case, use the following command to correct the <literal>INGRESS_HOST</literal> value:</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_HOST=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')</programlisting>
</section>
<section xml:id="ossm-routing-config-ig-no-lb_routing-traffic-v1x">
<title>Determining ingress ports without a load balancer</title>
<simpara>If your environment does not have an external load balancer, determine the ingress ports and use a node port instead.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the ingress ports.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="http2")].nodePort}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the secure ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export SECURE_INGRESS_PORT=$(oc -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="https")].nodePort}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to set the TCP ingress port.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export TCP_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name=="tcp")].nodePort}')</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-auto-route-1x_routing-traffic-v1x">
<title>Automatic route creation</title>
<simpara>OpenShift routes for Istio Gateways are automatically managed in Red Hat OpenShift Service Mesh. Every time an Istio Gateway is created, updated or deleted inside the service mesh, an OpenShift route is created, updated or deleted.</simpara>
<section xml:id="ossm-auto-route-enable_routing-traffic-v1x">
<title>Enabling Automatic Route Creation</title>
<simpara>A Red Hat OpenShift Service Mesh control plane component called Istio OpenShift Routing (IOR) synchronizes the gateway route. Enable IOR as part of the control plane deployment.</simpara>
<simpara>If the Gateway contains a TLS section, the OpenShift Route will be configured to support TLS.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <literal>ServiceMeshControlPlane</literal> resource, add the <literal>ior_enabled</literal> parameter and set it to <literal>true</literal>. For example, see the following resource snippet:</simpara>
</listitem>
</orderedlist>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  istio:
    gateways:
     istio-egressgateway:
       autoscaleEnabled: false
       autoscaleMin: 1
       autoscaleMax: 5
     istio-ingressgateway:
       autoscaleEnabled: false
       autoscaleMin: 1
       autoscaleMax: 5
       ior_enabled: true</programlisting>
</section>
<section xml:id="ossm-auto-route-subdomains_routing-traffic-v1x">
<title>Subdomains</title>
<simpara>Red Hat OpenShift Service Mesh creates the route with the subdomain, but OpenShift Container Platform must be configured to enable it. Subdomains, for example <literal>*.domain.com</literal>, are supported but not by default. Configure an OpenShift Container Platform wildcard policy before configuring a wildcard host Gateway. For more information, see the "Links" section.</simpara>
<simpara>If the following gateway is created:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
  name: gateway1
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - www.bookinfo.com
    - bookinfo.example.com</programlisting>
<simpara>Then, the following OpenShift Routes are created automatically. You can check that the routes are created with the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n &lt;control_plane_namespace&gt; get routes</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME           HOST/PORT             PATH  SERVICES               PORT  TERMINATION   WILDCARD
gateway1-lvlfn bookinfo.example.com        istio-ingressgateway   &lt;all&gt;               None
gateway1-scqhv www.bookinfo.com            istio-ingressgateway   &lt;all&gt;               None</programlisting>
</para>
</formalpara>
<simpara>If the gateway is deleted, Red Hat OpenShift Service Mesh deletes the routes. However, routes created manually are never modified by Red Hat OpenShift Service Mesh.</simpara>
</section>
</section>
<section xml:id="ossm-routing-service-entries_routing-traffic-v1x">
<title>Understanding service entries</title>
<simpara>A service entry adds an entry to the service registry that Red Hat OpenShift Service Mesh maintains internally. After you add the service entry, the Envoy proxies send traffic to the service as if it is a service in your mesh. Service entries allow you to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Manage traffic for services that run outside of the service mesh.</simpara>
</listitem>
<listitem>
<simpara>Redirect and forward traffic for external destinations (such as, APIs consumed from the web) or traffic to services in legacy infrastructure.</simpara>
</listitem>
<listitem>
<simpara>Define retry, timeout, and fault injection policies for external destinations.</simpara>
</listitem>
<listitem>
<simpara>Run a mesh service in a Virtual Machine (VM) by adding VMs to your mesh.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Add services from a different cluster to the mesh to configure a multicluster Red Hat OpenShift Service Mesh mesh on Kubernetes.</simpara>
</note>
<formalpara>
<title>Service entry examples</title>
<para>The following example is a mesh-external service entry that adds the <literal>ext-resource</literal> external dependency to the Red Hat OpenShift Service Mesh service registry:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
  name: svc-entry
spec:
  hosts:
  - ext-svc.example.com
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  location: MESH_EXTERNAL
  resolution: DNS</programlisting>
<simpara>Specify the external resource using the <literal>hosts</literal> field. You can qualify it fully or use a wildcard prefixed domain name.</simpara>
<simpara>You can configure virtual services and destination rules to control traffic to a service entry in the same way you configure traffic for any other service in the mesh. For example, the following destination rule configures the traffic route to use mutual TLS to secure the connection to the <literal>ext-svc.example.com</literal> external service that is configured using the service entry:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ext-res-dr
spec:
  host: ext-svc.example.com
  trafficPolicy:
    tls:
      mode: MUTUAL
      clientCertificate: /etc/certs/myclientcert.pem
      privateKey: /etc/certs/client_private_key.pem
      caCertificates: /etc/certs/rootcacerts.pem</programlisting>
</section>
<section xml:id="ossm-routing-virtual-services_routing-traffic-v1x">
<title>Using VirtualServices</title>
<simpara>You can route requests dynamically to multiple versions of a microservice through Red Hat OpenShift Service Mesh with a virtual service. With virtual services, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Address multiple application services through a single virtual service. If your mesh uses Kubernetes, for example, you can configure a virtual service to handle all services in a specific namespace. A virtual service enables you to turn a monolithic application into a service consisting of distinct microservices with a seamless consumer experience.</simpara>
</listitem>
<listitem>
<simpara>Configure traffic rules in combination with gateways to control ingress and egress traffic.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-routing-vs_routing-traffic-v1x">
<title>Configuring VirtualServices</title>
<simpara>Requests are routed to services within a service mesh with virtual services. Each virtual service consists of a set of routing rules that are evaluated in order. Red Hat OpenShift Service Mesh matches each given request to the virtual service to a specific real destination within the mesh.</simpara>
<simpara>Without virtual services, Red Hat OpenShift Service Mesh distributes traffic using least requests load balancing between all service instances. With a virtual service, you can specify traffic behavior for one or more hostnames. Routing rules in the virtual service tell Red Hat OpenShift Service Mesh how to send the traffic for the virtual service to appropriate destinations. Route destinations can be versions of the same service or entirely different services.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following example to route requests to different versions of the Bookinfo sample application service depending on which user connects to the application.</simpara>
<formalpara>
<title>Example VirtualService.yaml</title>
<para>
<programlisting language="YAML" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
  name: reviews
spec:
  hosts:
  - reviews
  http:
  - match:
    - headers:
        end-user:
          exact: jason
    route:
    - destination:
        host: reviews
        subset: v2
  - route:
    - destination:
        host: reviews
        subset: v3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to apply <literal>VirtualService.yaml</literal>, where <literal>VirtualService.yaml</literal> is the path to the file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;VirtualService.yaml&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="_virtualservice_configuration_reference_2">
<title>VirtualService configuration reference</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  hosts:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>hosts</literal> field lists the virtual service&#8217;s destination address to which the routing rules apply. This is the address(es) that are used to send requests to the service. The virtual service hostname can be an IP address, a DNS name, or a short name that resolves to a fully qualified domain name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  http:
  - match:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>http</literal> section contains the virtual service&#8217;s routing rules which describe match conditions and actions for routing HTTP/1.1, HTTP2, and gRPC traffic sent to the destination as specified in the hosts field. A routing rule consists of the destination where you want the traffic to go and any specified match conditions.
The first routing rule in the example has a condition that begins with the match field. In this example, this routing applies to all requests from the user <literal>jason</literal>. Add the <literal>headers</literal>, <literal>end-user</literal>, and <literal>exact</literal> fields to select the appropriate requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">spec:
  http:
  - match:
    - destination:</literallayout></entry>
<entry align="left" valign="top"><simpara>The <literal>destination</literal> field in the route section specifies the actual destination for traffic that matches this condition. Unlike the virtual service&#8217;s host, the destination&#8217;s host must be a real destination that exists in the Red Hat OpenShift Service Mesh service registry. This can be a mesh service with proxies or a non-mesh service added using a service entry. In this example, the hostname is a Kubernetes service name:</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="ossm-routing-destination-rules_routing-traffic-v1x">
<title>Understanding destination rules</title>
<simpara>Destination rules are applied after virtual service routing rules are evaluated, so they apply to the traffic&#8217;s real destination. Virtual services route traffic to a destination. Destination rules configure what happens to traffic at that destination.</simpara>
<simpara>By default, Red Hat OpenShift Service Mesh uses a least requests load balancing policy, where the service instance in the pool with the least number of active connections receives the request. Red Hat OpenShift Service Mesh also supports the following models, which you can specify in destination rules for requests to a particular service or service subset.</simpara>
<itemizedlist>
<listitem>
<simpara>Random: Requests are forwarded at random to instances in the pool.</simpara>
</listitem>
<listitem>
<simpara>Weighted: Requests are forwarded to instances in the pool according to a specific percentage.</simpara>
</listitem>
<listitem>
<simpara>Least requests: Requests are forwarded to instances with the least number of requests.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Destination rule example</title>
<para>The following example destination rule configures three different subsets for the <literal>my-svc</literal> destination service, with different load balancing policies:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: my-destination-rule
spec:
  host: my-svc
  trafficPolicy:
    loadBalancer:
      simple: RANDOM
  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
  - name: v3
    labels:
      version: v3</programlisting>
<simpara>This guide references the Bookinfo sample application to provide examples of routing in an example application. Install the <link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#ossm-tutorial-bookinfo-overview_deploying-applications-ossm-v1x">Bookinfo application</link> to learn how these routing examples work.</simpara>
</section>
<section xml:id="ossm-routing-bookinfo_routing-traffic-v1x">
<title>Bookinfo routing tutorial</title>
<simpara>The Service Mesh Bookinfo sample application consists of four separate microservices, each with multiple versions. After installing the Bookinfo sample application, three different versions of the <literal>reviews</literal> microservice run concurrently.</simpara>
<simpara>When you access the Bookinfo app <literal>/product</literal> page in a browser and refresh several times, sometimes the book review output contains star ratings and other times it does not. Without an explicit default service version to route to, Service Mesh routes requests to all available versions one after the other.</simpara>
<simpara>This tutorial helps you apply rules that route all traffic to <literal>v1</literal> (version 1) of the microservices. Later, you can apply a rule to route traffic based on the value of an HTTP request header.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>Deploy the Bookinfo sample application to work with the following examples.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-routing-bookinfo-applying_routing-traffic-v1x">
<title>Applying a virtual service</title>
<simpara>In the following procedure, the virtual service routes all traffic to <literal>v1</literal> of each micro-service by applying virtual services that set the default version for the micro-services.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the virtual services.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/virtual-service-all-v1.yaml</programlisting>
</listitem>
<listitem>
<simpara>To verify that you applied the virtual services, display the defined routes with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get virtualservices -o yaml</programlisting>
<simpara>That command returns a resource of <literal>kind: VirtualService</literal> in YAML format.</simpara>
</listitem>
</orderedlist>
<simpara>You have configured Service Mesh to route to the <literal>v1</literal> version of the Bookinfo microservices including the <literal>reviews</literal> service version 1.</simpara>
</section>
<section xml:id="ossm-routing-bookinfo-test_routing-traffic-v1x">
<title>Testing the new route configuration</title>
<simpara>Test the new configuration by refreshing the <literal>/productpage</literal> of the Bookinfo application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the value for the <literal>GATEWAY_URL</literal> parameter. You can use this variable to find the URL for your Bookinfo product page later. In this example, istio-system is the name of the control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to retrieve the URL for the product page.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">echo "http://$GATEWAY_URL/productpage"</programlisting>
</listitem>
<listitem>
<simpara>Open the Bookinfo site in your browser.</simpara>
</listitem>
</orderedlist>
<simpara>The reviews part of the page displays with no rating stars, no matter how many times you refresh. This is because you configured Service Mesh to route all traffic for the reviews service to the version <literal>reviews:v1</literal> and this version of the service does not access the star ratings service.</simpara>
<simpara>Your service mesh now routes traffic to one version of a service.</simpara>
</section>
<section xml:id="ossm-routing-bookinfo-route_routing-traffic-v1x">
<title>Route based on user identity</title>
<simpara>Change the route configuration so that all traffic from a specific user is routed to a specific service version. In this case, all traffic from a user named <literal>jason</literal> will be routed to the service <literal>reviews:v2</literal>.</simpara>
<simpara>Service Mesh does not have any special, built-in understanding of user identity. This example is enabled by the fact that the <literal>productpage</literal> service adds a custom <literal>end-user</literal> header to all outbound HTTP requests to the reviews service.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to enable user-based routing in the Bookinfo sample application.</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/virtual-service-reviews-test-v2.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to confirm the rule is created. This command returns all resources of <literal>kind: VirtualService</literal> in YAML format.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get virtualservice reviews -o yaml</programlisting>
</listitem>
<listitem>
<simpara>On the <literal>/productpage</literal> of the Bookinfo app, log in as user <literal>jason</literal> with no password.</simpara>
</listitem>
<listitem>
<simpara>Refresh the browser. The star ratings appear next to each review.</simpara>
</listitem>
<listitem>
<simpara>Log in as another user (pick any name you want). Refresh the browser. Now the stars are gone. Traffic is now routed to <literal>reviews:v1</literal> for all users except Jason.</simpara>
</listitem>
</orderedlist>
<simpara>You have successfully configured the Bookinfo sample application to route traffic based on user identity.</simpara>
</section>
</section>
<section xml:id="_additional_resources_2" role="_additional-resources-traffic-management">
<title>Additional resources</title>
<simpara>For more information about configuring an OpenShift Container Platform wildcard policy, see <link xlink:href="../../networking/ingress-operator.xml#using-wildcard-routes_configuring-ingress">Using wildcard routes</link>.</simpara>
</section>
</section>
<section xml:id="deploying-applications-ossm-v1x">
<title>Deploying applications on Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>When you deploy an application into the Service Mesh, there are several differences between the behavior of applications in the upstream community version of Istio and the behavior of applications within a Red Hat OpenShift Service Mesh installation.</simpara>
<section xml:id="_prerequisites_6">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Review <link xlink:href="../../service_mesh/v1x/ossm-vs-community.xml#ossm-vs-community-v1x">Comparing Red Hat OpenShift Service Mesh and upstream Istio community installations</link></simpara>
</listitem>
<listitem>
<simpara>Review <link xlink:href="../../service_mesh/v1x/installing-ossm.xml#installing-ossm-v1x">Installing Red Hat OpenShift Service Mesh</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-control-plane-templates-1x_deploying-applications-ossm-v1x">
<title>Creating control plane templates</title>
<simpara>You can create reusable configurations with <literal>ServiceMeshControlPlane</literal> templates. Individual users can extend the templates they create with their own configurations. Templates can also inherit configuration information from other templates. For example, you can create an accounting control plane for the accounting team and a marketing control plane for the marketing team. If you create a development template and a production template, members of the marketing team and the accounting team can extend the development and production templates with team specific customization.</simpara>
<simpara>When you configure control plane templates, which follow the same syntax as the <literal>ServiceMeshControlPlane</literal>, users inherit settings in a hierarchical fashion. The Operator is delivered with a <literal>default</literal> template with default settings for Red Hat OpenShift Service Mesh. To add custom templates you must create a ConfigMap named <literal>smcp-templates</literal> in the <literal>openshift-operators</literal> project and mount the ConfigMap in the Operator container at <literal>/usr/local/share/istio-operator/templates</literal>.</simpara>
<section xml:id="ossm-create-configmap_deploying-applications-ossm-v1x">
<title>Creating the ConfigMap</title>
<simpara>Follow this procedure to create the ConfigMap.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An installed, verified Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Location of the Operator deployment.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a cluster administrator.</simpara>
</listitem>
<listitem>
<simpara>From the CLI, run this command to create the ConfigMap named <literal>smcp-templates</literal> in the <literal>openshift-operators</literal> project and replace <literal>&lt;templates-directory&gt;</literal> with the location of the <literal>ServiceMeshControlPlane</literal> files on your local disk:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap --from-file=&lt;templates-directory&gt; smcp-templates -n openshift-operators</programlisting>
</listitem>
<listitem>
<simpara>Locate the Operator ClusterServiceVersion name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterserviceversion -n openshift-operators | grep 'Service Mesh'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">maistra.v1.0.0            Red Hat OpenShift Service Mesh   1.0.0                Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit the Operator cluster service version to instruct the Operator to use the <literal>smcp-templates</literal> ConfigMap.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit clusterserviceversion -n openshift-operators maistra.v1.0.0</programlisting>
</listitem>
<listitem>
<simpara>Add a volume mount and volume to the Operator deployment.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">deployments:
  - name: istio-operator
    spec:
      template:
        spec:
          containers:
            volumeMounts:
              - name: discovery-cache
                mountPath: /home/istio-operator/.kube/cache/discovery
              - name: smcp-templates
                mountPath: /usr/local/share/istio-operator/templates/
          volumes:
            - name: discovery-cache
              emptyDir:
                medium: Memory
            - name: smcp-templates
              configMap:
                name: smcp-templates
...</programlisting>
</listitem>
<listitem>
<simpara>Save your changes and exit the editor.</simpara>
</listitem>
<listitem>
<simpara>You can now use the <literal>template</literal> parameter in the <literal>ServiceMeshControlPlane</literal> to specify a template.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
metadata:
  name: minimal-install
spec:
  template: default</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-automatic-sidecar-injection_deploying-applications-ossm-v1x">
<title>Enabling automatic sidecar injection</title>
<simpara>When deploying an application, you must opt-in to injection by configuring the annotation <literal>sidecar.istio.io/inject</literal> in <literal>spec.template.metadata.annotations</literal> to <literal>true</literal> in the <literal>deployment</literal> object. Opting in ensures that the sidecar injection does not interfere with other OpenShift Container Platform features such as builder pods used by numerous frameworks within the OpenShift Container Platform ecosystem.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Identify the namespaces that are part of your service mesh and the deployments that need automatic sidecar injection.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To find your deployments use the <literal>oc get</literal> command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;namespace&gt;</programlisting>
<simpara>For example, to view the deployment file for the 'ratings-v1' microservice in the <literal>bookinfo</literal> namespace, use the following command to see the resource in YAML format.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get deployment -n bookinfo ratings-v1 -o yaml</programlisting>
</listitem>
<listitem>
<simpara>Open the application&#8217;s deployment configuration YAML file in an editor.</simpara>
</listitem>
<listitem>
<simpara>Add <literal>spec.template.metadata.annotations.sidecar.istio/inject</literal> to your Deployment YAML and set <literal>sidecar.istio.io/inject</literal> to <literal>true</literal> as shown in the following example.</simpara>
<formalpara>
<title>Example snippet from bookinfo deployment-ratings-v1.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ratings-v1
  namespace: bookinfo
  labels:
    app: ratings
    version: v1
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/inject: 'true'</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Save the Deployment configuration file.</simpara>
</listitem>
<listitem>
<simpara>Add the file back to the project that contains your app.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n &lt;namespace&gt; -f deployment.yaml</programlisting>
<simpara>In this example, <literal>bookinfo</literal> is the name of the project that contains the <literal>ratings-v1</literal> app and <literal>deployment-ratings-v1.yaml</literal> is the file you edited.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -n bookinfo -f deployment-ratings-v1.yaml</programlisting>
</listitem>
<listitem>
<simpara>To verify that the resource uploaded successfully, run the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;namespace&gt; &lt;deploymentName&gt; -o yaml</programlisting>
<simpara>For example,</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n bookinfo ratings-v1 -o yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-sidecar-injection-env-var_deploying-applications-ossm-v1x">
<title>Setting proxy environment variables through annotations</title>
<simpara>Configuration for the Envoy sidecar proxies is managed by the <literal>ServiceMeshControlPlane</literal>.</simpara>
<simpara>You can set environment variables for the sidecar proxy for applications by adding pod annotations to the deployment in the <literal>injection-template.yaml</literal> file. The environment variables are injected to the sidecar.</simpara>
<formalpara>
<title>Example injection-template.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: resource
spec:
  replicas: 7
  selector:
    matchLabels:
      app: resource
  template:
    metadata:
      annotations:
        sidecar.maistra.io/proxyEnv: "{ \"maistra_test_env\": \"env_value\", \"maistra_test_env_2\": \"env_value_2\" }"</programlisting>
</para>
</formalpara>
<warning>
<simpara>You should never include <literal>maistra.io/</literal> labels and annotations when creating your own custom resources.  These labels and annotations indicate that the resources are generated and managed by the Operator. If you are copying content from an Operator-generated resource when creating your own resources, do not include labels or annotations that start with <literal>maistra.io/</literal>.  Resources that include these labels or annotations will be overwritten or deleted by the Operator during the next reconciliation.</simpara>
</warning>
</section>
<section xml:id="ossm-mixer-policy-1x_deploying-applications-ossm-v1x">
<title>Updating Mixer policy enforcement</title>
<simpara>In previous versions of Red Hat OpenShift Service Mesh, Mixer&#8217;s policy enforcement was enabled by default. Mixer policy enforcement is now disabled by default. You must enable it before running policy tasks.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The examples use <literal>&lt;istio-system&gt;</literal> as the control plane namespace. Replace this value with the namespace where you deployed the Service Mesh Control Plane (SMCP).</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Run this command to check the current Mixer policy enforcement status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cm -n &lt;istio-system&gt; istio -o jsonpath='{.data.mesh}' | grep disablePolicyChecks</programlisting>
</listitem>
<listitem>
<simpara>If <literal>disablePolicyChecks: true</literal>, edit the Service Mesh ConfigMap:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit cm -n &lt;istio-system&gt; istio</programlisting>
</listitem>
<listitem>
<simpara>Locate <literal>disablePolicyChecks: true</literal> within the ConfigMap and change the value to <literal>false</literal>.</simpara>
</listitem>
<listitem>
<simpara>Save the configuration and exit the editor.</simpara>
</listitem>
<listitem>
<simpara>Re-check the Mixer policy enforcement status to ensure it is set to <literal>false</literal>.</simpara>
</listitem>
</orderedlist>
<section xml:id="ossm-config-network-policy_deploying-applications-ossm-v1x">
<title>Setting the correct network policy</title>
<simpara>Service Mesh creates network policies in the Service Mesh control plane and member namespaces to allow traffic between them. Before you deploy, consider the following conditions to ensure the services in your service mesh that were previously exposed through an OpenShift Container Platform route.</simpara>
<itemizedlist>
<listitem>
<simpara>Traffic into the service mesh must always go through the ingress-gateway for Istio to work properly.</simpara>
</listitem>
<listitem>
<simpara>Deploy services external to the service mesh in separate namespaces that are not in any service mesh.</simpara>
</listitem>
<listitem>
<simpara>Non-mesh services that need to be deployed within a service mesh enlisted namespace should label their deployments <literal>maistra.io/expose-route: "true"</literal>, which ensures OpenShift Container Platform routes to these services still work.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-tutorial-bookinfo-overview_deploying-applications-ossm-v1x">
<title>Bookinfo example application</title>
<simpara>The Bookinfo example application allows you to test your Red Hat OpenShift Service Mesh 2.4.5 installation on OpenShift Container Platform.</simpara>
<simpara>The Bookinfo application displays information about a book, similar to a single catalog entry of an online book store. The application displays a page that describes the book, book details (ISBN, number of pages, and other information), and book reviews.</simpara>
<simpara>The Bookinfo application consists of these microservices:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>productpage</literal> microservice calls the <literal>details</literal> and <literal>reviews</literal> microservices to populate the page.</simpara>
</listitem>
<listitem>
<simpara>The <literal>details</literal> microservice contains book information.</simpara>
</listitem>
<listitem>
<simpara>The <literal>reviews</literal> microservice contains book reviews. It also calls the <literal>ratings</literal> microservice.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ratings</literal> microservice contains book ranking information that accompanies a book review.</simpara>
</listitem>
</itemizedlist>
<simpara>There are three versions of the reviews microservice:</simpara>
<itemizedlist>
<listitem>
<simpara>Version v1 does not call the <literal>ratings</literal> Service.</simpara>
</listitem>
<listitem>
<simpara>Version v2 calls the <literal>ratings</literal> Service and displays each rating as one to five black stars.</simpara>
</listitem>
<listitem>
<simpara>Version v3 calls the <literal>ratings</literal> Service and displays each rating as one to five red stars.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-tutorial-bookinfo-install_deploying-applications-ossm-v1x">
<title>Installing the Bookinfo application</title>
<simpara>This tutorial walks you through how to create a sample application by creating a project, deploying the Bookinfo application to that project, and viewing the running application in Service Mesh.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>OpenShift Container Platform 4.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh 2.4.5 installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The Bookinfo sample application cannot be installed on IBM Z&#174; and IBM Power&#174;.</simpara>
</note>
<note>
<simpara>The commands in this section assume the Service Mesh control plane project is <literal>istio-system</literal>.  If you installed the control plane in another namespace, edit each command before you run it.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with cluster-admin rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>bookinfo</literal> as the <emphasis role="strong">Project Name</emphasis>, enter a <emphasis role="strong">Display Name</emphasis>, and enter a <emphasis role="strong">Description</emphasis>, then click <emphasis role="strong">Create</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command from the CLI to create the <literal>bookinfo</literal> project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project bookinfo</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and use the Service Mesh control plane namespace. In this example, use <literal>istio-system</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> tab.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you have already created a Istio Service Mesh Member Roll, click the name, then click the YAML tab to open the YAML editor.</simpara>
</listitem>
<listitem>
<simpara>If you have not created a <literal>ServiceMeshMemberRoll</literal>, click <emphasis role="strong">Create ServiceMeshMemberRoll</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Members</emphasis>, then enter the name of your project in the <emphasis role="strong">Value</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to save the updated Service Mesh Member Roll.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Or, save the following example to a YAML file.</simpara>
<formalpara>
<title>Bookinfo ServiceMeshMemberRoll example servicemeshmemberroll-default.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshMemberRoll
metadata:
  name: default
spec:
  members:
  - bookinfo</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to upload that file and create the <literal>ServiceMeshMemberRoll</literal> resource in the <literal>istio-system</literal> namespace.   In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n istio-system -f servicemeshmemberroll-default.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to verify the <literal>ServiceMeshMemberRoll</literal> was created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smmr -n istio-system -o wide</programlisting>
<simpara>The installation has finished successfully when the <literal>STATUS</literal> column is <literal>Configured</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY   STATUS       AGE   MEMBERS
default   1/1     Configured   70s   ["bookinfo"]</programlisting>
</listitem>
<listitem>
<simpara>From the CLI, deploy the Bookinfo application in the <emphasis>`bookinfo`</emphasis> project by applying the <literal>bookinfo.yaml</literal> file:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/platform/kube/bookinfo.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">service/details created
serviceaccount/bookinfo-details created
deployment.apps/details-v1 created
service/ratings created
serviceaccount/bookinfo-ratings created
deployment.apps/ratings-v1 created
service/reviews created
serviceaccount/bookinfo-reviews created
deployment.apps/reviews-v1 created
deployment.apps/reviews-v2 created
deployment.apps/reviews-v3 created
service/productpage created
serviceaccount/bookinfo-productpage created
deployment.apps/productpage-v1 created</programlisting>
</listitem>
<listitem>
<simpara>Create the ingress gateway by applying the <literal>bookinfo-gateway.yaml</literal> file:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/bookinfo-gateway.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">gateway.networking.istio.io/bookinfo-gateway created
virtualservice.networking.istio.io/bookinfo created</programlisting>
</listitem>
<listitem>
<simpara>Set the value for the <literal>GATEWAY_URL</literal> parameter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export GATEWAY_URL=$(oc -n istio-system get route istio-ingressgateway -o jsonpath='{.spec.host}')</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-adding-destination-rules_deploying-applications-ossm-v1x">
<title>Adding default destination rules</title>
<simpara>Before you can use the Bookinfo application, you must first add default destination rules. There are two preconfigured YAML files, depending on whether or not you enabled mutual transport layer security (TLS) authentication.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To add destination rules, run one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>If you did not enable mutual TLS:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/destination-rule-all.yaml</programlisting>
</listitem>
<listitem>
<simpara>If you enabled mutual TLS:</simpara>
<programlisting language="bash" linenumbering="unnumbered">$ oc apply -n bookinfo -f https://raw.githubusercontent.com/Maistra/istio/maistra-2.4/samples/bookinfo/networking/destination-rule-all-mtls.yaml</programlisting>
<simpara>You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">destinationrule.networking.istio.io/productpage created
destinationrule.networking.istio.io/reviews created
destinationrule.networking.istio.io/ratings created
destinationrule.networking.istio.io/details created</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-verify-install_deploying-applications-ossm-v1x">
<title>Verifying the Bookinfo installation</title>
<simpara>To confirm that the sample Bookinfo application was successfully deployed, perform the following steps.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Red Hat OpenShift Service Mesh installed.</simpara>
</listitem>
<listitem>
<simpara>Complete the steps for installing the Bookinfo sample app.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure from CLI</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Verify that all pods are ready with this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n bookinfo</programlisting>
<simpara>All pods should have a status of <literal>Running</literal>. You should see output similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              READY   STATUS    RESTARTS   AGE
details-v1-55b869668-jh7hb        2/2     Running   0          12m
productpage-v1-6fc77ff794-nsl8r   2/2     Running   0          12m
ratings-v1-7d7d8d8b56-55scn       2/2     Running   0          12m
reviews-v1-868597db96-bdxgq       2/2     Running   0          12m
reviews-v2-5b64f47978-cvssp       2/2     Running   0          12m
reviews-v3-6dfd49b55b-vcwpf       2/2     Running   0          12m</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to retrieve the URL for the product page:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">echo "http://$GATEWAY_URL/productpage"</programlisting>
</listitem>
<listitem>
<simpara>Copy and paste the output in a web browser to verify the Bookinfo product page is deployed.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure from Kiali web console</title>
<listitem>
<simpara>Obtain the address for the Kiali web console.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with <literal>cluster-admin</literal> rights. If you use Red Hat OpenShift Dedicated, you must have an account with the <literal>dedicated-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Routes</emphasis> page, select the Service Mesh control plane project, for example <literal>istio-system</literal>, from the <emphasis role="strong">Namespace</emphasis> menu.</simpara>
<simpara>The <emphasis role="strong">Location</emphasis> column displays the linked address for each route.</simpara>
</listitem>
<listitem>
<simpara>Click the link in the <emphasis role="strong">Location</emphasis> column for Kiali.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>. The Kiali <emphasis role="strong">Overview</emphasis> screen presents tiles for each project namespace.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>In Kiali, click <emphasis role="strong">Graph</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select bookinfo from the <emphasis role="strong">Namespace</emphasis> list, and App graph from the <emphasis role="strong">Graph Type</emphasis> list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Display idle nodes</emphasis> from the <emphasis role="strong">Display</emphasis> menu.</simpara>
<simpara>This displays nodes that are defined but have not received or sent requests. It can confirm that an application is properly defined, but that no request traffic has been reported.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/ossm-kiali-graph-bookinfo.png"/>
</imageobject>
<textobject><phrase>Kiali displaying bookinfo application</phrase></textobject>
</mediaobject>
</informalfigure>
<itemizedlist>
<listitem>
<simpara>Use the <emphasis role="strong">Duration</emphasis> menu to increase the time period to help ensure older traffic is captured.</simpara>
</listitem>
<listitem>
<simpara>Use the <emphasis role="strong">Refresh Rate</emphasis> menu to refresh traffic more or less often, or not at all.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Services</emphasis>, <emphasis role="strong">Workloads</emphasis> or <emphasis role="strong">Istio Config</emphasis> to see list views of bookinfo components, and confirm that they are healthy.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-tutorial-bookinfo-removing_deploying-applications-ossm-v1x">
<title>Removing the Bookinfo application</title>
<simpara>Follow these steps to remove the Bookinfo application.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>OpenShift Container Platform 4.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh 2.4.5 installed.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-delete-bookinfo-project_deploying-applications-ossm-v1x">
<title>Delete the Bookinfo project</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>bookinfo</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject>, and then click <emphasis role="strong">Delete Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <literal>bookinfo</literal> in the confirmation dialog box, and then click <emphasis role="strong">Delete</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command using the CLI to create the <literal>bookinfo</literal> project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project bookinfo</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-remove-bookinfo-smmr_deploying-applications-ossm-v1x">
<title>Remove the Bookinfo project from the Service Mesh member roll</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and choose <literal>istio-system</literal> from the list.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Member Roll</emphasis> link under <emphasis role="strong">Provided APIS</emphasis> for the <emphasis role="strong">Red Hat OpenShift Service Mesh</emphasis> Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>ServiceMeshMemberRoll</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> and select <emphasis role="strong">Edit Service Mesh Member Roll</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Edit the default Service Mesh Member Roll YAML and remove <literal>bookinfo</literal> from the <emphasis role="strong">members</emphasis> list.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, you can run this command using the CLI to remove the <literal>bookinfo</literal> project from the <literal>ServiceMeshMemberRoll</literal>. In this example, <literal>istio-system</literal> is the name of the Service Mesh control plane project.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n istio-system patch --type='json' smmr default -p '[{"op": "remove", "path": "/spec/members", "value":["'"bookinfo"'"]}]'</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis> to update Service Mesh Member Roll.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="generating-sample-traces-analyzing-trace-data_deploying-applications-ossm-v1x">
<title>Generating example traces and analyzing trace data</title>
<simpara>Jaeger is an open source distributed tracing system. With Jaeger, you can perform a trace that follows the path of a request through various microservices which make up an application. Jaeger is installed by default as part of the Service Mesh.</simpara>
<simpara>This tutorial uses Service Mesh and the Bookinfo sample application to demonstrate how you can use Jaeger to perform distributed tracing.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>OpenShift Container Platform 4.1 or higher installed.</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh 2.4.5 installed.</simpara>
</listitem>
<listitem>
<simpara>Jaeger enabled during the installation.</simpara>
</listitem>
<listitem>
<simpara>Bookinfo example application installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>After installing the Bookinfo sample application, send traffic to the mesh. Enter the following command several times.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl "http://$GATEWAY_URL/productpage"</programlisting>
<simpara>This command simulates a user visiting the <literal>productpage</literal> microservice of the application.</simpara>
</listitem>
<listitem>
<simpara>In the OpenShift Container Platform console, navigate to <emphasis role="strong">Networking</emphasis> &#8594; <emphasis role="strong">Routes</emphasis> and search for the Jaeger route, which is the URL listed under <emphasis role="strong">Location</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Alternatively, use the CLI to query for details of the route. In this example, <literal>istio-system</literal> is the Service Mesh control plane namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export JAEGER_URL=$(oc get route -n istio-system jaeger -o jsonpath='{.spec.host}')</programlisting>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter the following command to reveal the URL for the Jaeger console. Paste the result in a browser and navigate to that URL.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">echo $JAEGER_URL</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Log in using the same user name and password as you use to access the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>In the left pane of the Jaeger dashboard, from the <emphasis role="strong">Service</emphasis> menu, select <emphasis role="strong">productpage.bookinfo</emphasis> and click <emphasis role="strong">Find Traces</emphasis> at the bottom of the pane. A list of traces is displayed.</simpara>
</listitem>
<listitem>
<simpara>Click one of the traces in the list to open a detailed view of that trace.  If you click the first one in the list, which is the most recent trace, you see the details that correspond to the latest refresh of the <literal>/productpage</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-observability-v1x">
<title>Data visualization and observability</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>You can view your application&#8217;s topology, health and metrics in the Kiali console. If your service is having issues, the Kiali console offers ways to visualize the data flow through your service. You can view insights about the mesh components at different levels, including abstract applications, services, and workloads. It also provides an interactive graph view of your namespace in real time.</simpara>
<formalpara>
<title>Before you begin</title>
<para>You can observe the data flow through your application if you have an application installed. If you don&#8217;t have your own application installed, you can see how observability works in Red Hat OpenShift Service Mesh by installing the <link xlink:href="../../service_mesh/v1x/prepare-to-deploy-applications-ossm.xml#ossm-tutorial-bookinfo-overview_deploying-applications-ossm-v1x">Bookinfo sample application</link>.</para>
</formalpara>
<section xml:id="ossm-observability-access-console_observability-v1x">
<title>Viewing service mesh data</title>
<simpara>The Kiali operator works with the telemetry data gathered in Red Hat OpenShift Service Mesh to provide graphs and real-time network diagrams of the applications, services, and workloads in your namespace.</simpara>
<simpara>To access the Kiali console you must have Red Hat OpenShift Service Mesh installed and projects configured for the service mesh.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the perspective switcher to switch to the <emphasis role="strong">Administrator</emphasis> perspective.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your project. For example, click <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Launcher</emphasis> section, click <emphasis role="strong">Kiali</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Log in to the Kiali console with the same user name and password that you use to access the OpenShift Container Platform console.</simpara>
</listitem>
</orderedlist>
<simpara>When you first log in to the Kiali Console, you see the <emphasis role="strong">Overview</emphasis> page which displays all the namespaces in your service mesh that you have permission to view.</simpara>
<simpara>If you are validating the console installation, there might not be any data to display.</simpara>
</section>
<section xml:id="ossm-observability-visual_observability-v1x">
<title>Viewing service mesh data in the Kiali console</title>
<simpara>The Kiali Graph offers a powerful visualization of your mesh traffic. The topology combines real-time request traffic with your Istio configuration information to present immediate insight into the behavior of your service mesh, letting you quickly pinpoint issues. Multiple Graph Types let you visualize traffic as a high-level service topology, a low-level workload topology, or as an application-level topology.</simpara>
<simpara>There are several graphs to choose from:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">App graph</emphasis> shows an aggregate workload for all applications that are labeled the same.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Service graph</emphasis> shows a node for each service in your mesh but excludes all applications and workloads from the graph. It provides a high level view and aggregates all traffic for defined services.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Versioned App graph</emphasis> shows a node for each version of an application. All versions of an application are grouped together.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Workload graph</emphasis> shows a node for each workload in your service mesh. This graph does not require you to use the application and version labels. If your application does not use version labels, use this the graph.</simpara>
</listitem>
</itemizedlist>
<simpara>Graph nodes are decorated with a variety of information, pointing out various route routing options like virtual services and service entries, as well as special configuration like fault-injection and circuit breakers. It can identify mTLS issues, latency issues, error traffic and more. The Graph is highly configurable, can show traffic animation, and has powerful Find and Hide abilities.</simpara>
<simpara>Click the <emphasis role="strong">Legend</emphasis> button to view information about the shapes, colors, arrows, and badges displayed in the graph.</simpara>
<simpara>To view a summary of metrics, select any node or edge in the graph to display its metric details in the summary details panel.</simpara>
<section xml:id="ossm-observability-topology_observability-v1x">
<title>Changing graph layouts in Kiali</title>
<simpara>The layout for the Kiali graph can render differently depending on your application architecture and the data to display. For example, the number of graph nodes and their interactions can determine how the Kiali graph is rendered. Because it is not possible to create a single layout that renders nicely for every situation, Kiali offers a choice of several different layouts.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>If you do not have your own application installed, install the Bookinfo sample application.  Then generate traffic for the Bookinfo application by entering the following command several times.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl "http://$GATEWAY_URL/productpage"</programlisting>
<simpara>This command simulates a user visiting the <literal>productpage</literal> microservice of the application.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Launch the Kiali console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Log In With OpenShift</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In Kiali console, click <emphasis role="strong">Graph</emphasis> to view a namespace graph.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Namespace</emphasis> menu, select your application namespace, for example, <literal>bookinfo</literal>.</simpara>
</listitem>
<listitem>
<simpara>To choose a different graph layout, do either or both of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Select different graph data groupings from the menu at the top of the graph.</simpara>
<itemizedlist>
<listitem>
<simpara>App graph</simpara>
</listitem>
<listitem>
<simpara>Service graph</simpara>
</listitem>
<listitem>
<simpara>Versioned App graph (default)</simpara>
</listitem>
<listitem>
<simpara>Workload graph</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select a different graph layout from the Legend at the bottom of the graph.</simpara>
<itemizedlist>
<listitem>
<simpara>Layout default dagre</simpara>
</listitem>
<listitem>
<simpara>Layout 1 cose-bilkent</simpara>
</listitem>
<listitem>
<simpara>Layout 2 cola</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="ossm-custom-resources-v1x">
<title>Custom resources</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>You can customize your Red Hat OpenShift Service Mesh by modifying the default Service Mesh custom resource or by creating a new custom resource.</simpara>
<section xml:id="_prerequisites_7">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>An account with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Completed the <link xlink:href="../../service_mesh/v1x/preparing-ossm-installation.xml#preparing-ossm-installation-v1x">Preparing to install Red Hat OpenShift Service Mesh</link> process.</simpara>
</listitem>
<listitem>
<simpara>Have installed the operators.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-cr-example-1x_ossm-controler-items-v1x">
<title>Red Hat OpenShift Service Mesh custom resources</title>
<note>
<simpara>The <literal>istio-system</literal> project is used as an example throughout the Service Mesh documentation, but you can use other projects as necessary.</simpara>
</note>
<simpara>A <emphasis>custom resource</emphasis> allows you to extend the API in an Red Hat OpenShift Service Mesh project or cluster. When you deploy Service Mesh it creates a default <literal>ServiceMeshControlPlane</literal> that you can modify to change the project parameters.</simpara>
<simpara>The Service Mesh operator extends the API by adding the <literal>ServiceMeshControlPlane</literal> resource type, which enables you to create <literal>ServiceMeshControlPlane</literal> objects within projects. By creating a <literal>ServiceMeshControlPlane</literal> object, you instruct the Operator to install a Service Mesh control plane into the project, configured with the parameters you set in the <literal>ServiceMeshControlPlane</literal> object.</simpara>
<simpara>This example <literal>ServiceMeshControlPlane</literal> definition contains all of the supported parameters and deploys Red Hat OpenShift Service Mesh 1.1.18.2 images based on Red Hat Enterprise Linux (RHEL).</simpara>
<important>
<simpara>The 3scale Istio Adapter is deployed and configured in the custom resource file. It also requires a working 3scale account (<link xlink:href="https://www.3scale.net/signup/">SaaS</link> or <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.4/html/infrastructure/onpremises-installation">On-Premises</link>).</simpara>
</important>
<formalpara>
<title>Example istio-installation.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
metadata:
  name: basic-install
spec:

  istio:
    global:
      proxy:
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 128Mi

    gateways:
      istio-egressgateway:
        autoscaleEnabled: false
      istio-ingressgateway:
        autoscaleEnabled: false
        ior_enabled: false

    mixer:
      policy:
        autoscaleEnabled: false

      telemetry:
        autoscaleEnabled: false
        resources:
          requests:
            cpu: 100m
            memory: 1G
          limits:
            cpu: 500m
            memory: 4G

    pilot:
      autoscaleEnabled: false
      traceSampling: 100

    kiali:
      enabled: true

    grafana:
      enabled: true

    tracing:
      enabled: true
      jaeger:
        template: all-in-one</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-cr-parameters_ossm-controler-items-v1x">
<title>ServiceMeshControlPlane parameters</title>
<simpara>The following examples illustrate use of the <literal>ServiceMeshControlPlane</literal> parameters and the tables provide additional information about supported parameters.</simpara>
<important>
<simpara>The resources you configure for Red Hat OpenShift Service Mesh with these parameters, including CPUs, memory, and the number of pods, are based on the configuration of your OpenShift Container Platform cluster. Configure these parameters based on the available resources in your current cluster configuration.</simpara>
</important>
<section xml:id="ossm-cr-istio-global_ossm-controler-items-v1x">
<title>Istio global example</title>
<simpara>Here is an example that illustrates the Istio global parameters for the <literal>ServiceMeshControlPlane</literal> and a description of the available parameters with appropriate values.</simpara>
<note>
<simpara>In order for the 3scale Istio Adapter to work, <literal>disablePolicyChecks</literal> must be <literal>false</literal>.</simpara>
</note>
<formalpara>
<title>Example global parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  istio:
    global:
      tag: 1.1.0
      hub: registry.redhat.io/openshift-service-mesh/
      proxy:
        resources:
          requests:
            cpu: 10m
            memory: 128Mi
          limits:
      mtls:
        enabled: false
      disablePolicyChecks: true
      policyCheckFailOpen: false
      imagePullSecrets:
        - MyPullSecret</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Global parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>disablePolicyChecks</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables policy checks.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>policyCheckFailOpen</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter indicates whether traffic is allowed to pass through to the Envoy sidecar when the Mixer policy service cannot be reached.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tag</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The tag that the Operator uses to pull the Istio images.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid container image tag.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1.1.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The hub that the Operator uses to pull Istio images.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid image repository.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>maistra/</literal> or <literal>registry.redhat.io/openshift-service-mesh/</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mtls</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter controls whether to enable/disable Mutual Transport Layer Security (mTLS) between services by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>imagePullSecrets</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If access to the registry providing the Istio images is secure, list an <link xlink:href="https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod">imagePullSecret</link> here.</simpara></entry>
<entry align="left" valign="top"><simpara>redhat-registry-pullsecret OR quay-pullsecret</simpara></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>These parameters are specific to the proxy subset of global parameters.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Proxy parameters</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>requests</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of CPU resources requested for Envoy proxy.</simpara></entry>
<entry align="left" valign="top"><simpara>CPU resources, specified in cores or millicores (for example, 200m, 0.5, 1) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of memory requested for Envoy proxy</simpara></entry>
<entry align="left" valign="top"><simpara>Available memory in bytes(for example, 200Ki, 50Mi, 5Gi) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128Mi</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>limits</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of CPU resources requested for Envoy proxy.</simpara></entry>
<entry align="left" valign="top"><simpara>CPU resources, specified in cores or millicores (for example, 200m, 0.5, 1) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2000m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory Envoy proxy is permitted to use.</simpara></entry>
<entry align="left" valign="top"><simpara>Available memory in bytes (for example, 200Ki, 50Mi, 5Gi) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1024Mi</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-cr-gateway_ossm-controler-items-v1x">
<title>Istio gateway configuration</title>
<simpara>Here is an example that illustrates the Istio gateway parameters for the <literal>ServiceMeshControlPlane</literal> and a description of the available parameters with appropriate values.</simpara>
<formalpara>
<title>Example gateway parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  gateways:
    egress:
      enabled: true
      runtime:
        deployment:
          autoScaling:
            enabled: true
            maxReplicas: 5
            minReplicas: 1
    enabled: true
    ingress:
      enabled: true
      runtime:
        deployment:
          autoScaling:
            enabled: true
            maxReplicas: 5
            minReplicas: 1</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio Gateway parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.egress.runtime.deployment.autoScaling.enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables autoscaling.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.egress.runtime.deployment.autoScaling.minReplicas</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum number of pods to deploy for the egress gateway based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.egress.runtime.deployment.autoScaling.maxReplicas</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of pods to deploy for the egress gateway based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.ingress.runtime.deployment.autoScaling.enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables autoscaling.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.ingress.runtime.deployment.autoScaling.minReplicas</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum number of pods to deploy for the ingress gateway based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>gateways.ingress.runtime.deployment.autoScaling.maxReplicas</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of pods to deploy for the ingress gateway based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Cluster administrators can refer to <link xlink:href="../../networking/ingress-operator.xml#using-wildcard-routes_configuring-ingress">Using wildcard routes</link> for instructions on how to enable subdomains.</simpara>
</section>
<section xml:id="ossm-cr-mixer_ossm-controler-items-v1x">
<title>Istio Mixer configuration</title>
<simpara>Here is an example that illustrates the Mixer parameters for the <literal>ServiceMeshControlPlane</literal> and a description of the available parameters with appropriate values.</simpara>
<formalpara>
<title>Example mixer parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">mixer:
  enabled: true
  policy:
    autoscaleEnabled: false
  telemetry:
    autoscaleEnabled: false
    resources:
    requests:
      cpu: 10m
      memory: 128Mi
      limits:</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio Mixer policy parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables Mixer.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>autoscaleEnabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables autoscaling. Disable this for small environments.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>autoscaleMin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum number of pods to deploy based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>autoscaleMax</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of pods to deploy based on the <literal>autoscaleEnabled</literal> setting.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid number of allocatable pods based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>5</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Istio Mixer telemetry parameters</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>requests</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The percentage of CPU resources requested for Mixer telemetry.</simpara></entry>
<entry align="left" valign="top"><simpara>CPU resources in millicores based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of memory requested for Mixer telemetry.</simpara></entry>
<entry align="left" valign="top"><simpara>Available memory in bytes (for example, 200Ki, 50Mi, 5Gi) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128Mi</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>limits</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum percentage of CPU resources Mixer telemetry is permitted to use.</simpara></entry>
<entry align="left" valign="top"><simpara>CPU resources in millicores based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>4800m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum amount of memory Mixer telemetry is permitted to use.</simpara></entry>
<entry align="left" valign="top"><simpara>Available memory in bytes (for example, 200Ki, 50Mi, 5Gi) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>4G</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="ossm-cr-pilot_ossm-controler-items-v1x">
<title>Istio Pilot configuration</title>
<simpara>You can configure Pilot to schedule or set limits on resource allocation.
The following example illustrates the Pilot parameters for the <literal>ServiceMeshControlPlane</literal> and a description of the available parameters with appropriate values.</simpara>
<formalpara>
<title>Example pilot parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  runtime:
    components:
      pilot:
        deployment:
          autoScaling:
            enabled: true
            minReplicas: 1
            maxReplicas: 5
            targetCPUUtilizationPercentage: 85
        pod:
          tolerations:
          - key: node.kubernetes.io/unreachable
            operator: Exists
            effect: NoExecute
            tolerationSeconds: 60
          affinity:
            podAntiAffinity:
              requiredDuringScheduling:
              - key: istio
                topologyKey: kubernetes.io/hostname
                operator: In
                values:
                - pilot
        container:
          resources:
            limits:
              cpu: 100m
              memory: 128M</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Istio Pilot parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The percentage of CPU resources requested for Pilot.</simpara></entry>
<entry align="left" valign="top"><simpara>CPU resources in millicores based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>memory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The amount of memory requested for Pilot.</simpara></entry>
<entry align="left" valign="top"><simpara>Available memory in bytes (for example, 200Ki, 50Mi, 5Gi) based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128Mi</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>autoscaleEnabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables autoscaling. Disable this for small environments.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>traceSampling</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This value controls how often random sampling occurs. <emphasis role="strong">Note:</emphasis> Increase for development or testing.</simpara></entry>
<entry align="left" valign="top"><simpara>A valid percentage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1.0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="configuring-kiali_ossm-controler-items-v1x">
<title>Configuring Kiali</title>
<simpara>When the Service Mesh Operator creates the <literal>ServiceMeshControlPlane</literal> it also processes the Kiali resource. The Kiali Operator then uses this object when creating Kiali instances.</simpara>
<simpara>The default Kiali parameters specified in the <literal>ServiceMeshControlPlane</literal> are as follows:</simpara>
<formalpara>
<title>Example Kiali parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
    kiali:
      enabled: true
      dashboard:
        viewOnlyMode: false
      ingress:
        enabled: true</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Kiali parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">enabled</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables Kiali. Kiali is enabled by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">dashboard
   viewOnlyMode</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables view-only mode for the Kiali console.  When view-only mode is enabled, users cannot use the console to make changes to the Service Mesh.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">ingress
   enabled</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables ingress for Kiali.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="configuring-kiali-grafana_ossm-controler-items-v1x">
<title>Configuring Kiali for Grafana</title>
<simpara>When you install Kiali and Grafana as part of Red Hat OpenShift Service Mesh the Operator configures the following by default:</simpara>
<itemizedlist>
<listitem>
<simpara>Grafana is enabled as an external service for Kiali</simpara>
</listitem>
<listitem>
<simpara>Grafana authorization for the Kiali console</simpara>
</listitem>
<listitem>
<simpara>Grafana URL for the Kiali console</simpara>
</listitem>
</itemizedlist>
<simpara>Kiali can automatically detect the Grafana URL. However if you have a custom Grafana installation that is not easily auto-detectable by Kiali, you must update the URL value in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Additional Grafana parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  kiali:
    enabled: true
    dashboard:
      viewOnlyMode: false
      grafanaURL:  "https://grafana-istio-system.127.0.0.1.nip.io"
    ingress:
      enabled: true</programlisting>
</para>
</formalpara>
</section>
<section xml:id="configuring-kiali-jaeger_ossm-controler-items-v1x">
<title>Configuring Kiali for Jaeger</title>
<simpara>When you install Kiali and Jaeger as part of Red Hat OpenShift Service Mesh the Operator configures the following by default:</simpara>
<itemizedlist>
<listitem>
<simpara>Jaeger is enabled as an external service for Kiali</simpara>
</listitem>
<listitem>
<simpara>Jaeger authorization for the Kiali console</simpara>
</listitem>
<listitem>
<simpara>Jaeger URL for the Kiali console</simpara>
</listitem>
</itemizedlist>
<simpara>Kiali can automatically detect the Jaeger URL. However if you have a custom Jaeger installation that is not easily auto-detectable by Kiali, you must update the URL value in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Additional Jaeger parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  kiali:
    enabled: true
    dashboard:
      viewOnlyMode: false
      jaegerURL: "http://jaeger-query-istio-system.127.0.0.1.nip.io"
    ingress:
      enabled: true</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="ossm-configuring-jaeger_ossm-controler-items-v1x">
<title>Configuring Jaeger</title>
<simpara>When the Service Mesh Operator creates the <literal>ServiceMeshControlPlane</literal> resource it can also create the resources for distributed tracing. Service Mesh uses Jaeger for distributed tracing.</simpara>
<simpara>You can specify your Jaeger configuration in either of two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure Jaeger in the <literal>ServiceMeshControlPlane</literal> resource. There are some limitations with this approach.</simpara>
</listitem>
<listitem>
<simpara>Configure Jaeger in a custom <literal>Jaeger</literal> resource and then reference that Jaeger instance in the  <literal>ServiceMeshControlPlane</literal> resource. If a Jaeger resource matching the value of <literal>name</literal> exists, the control plane will use the existing installation. This approach lets you fully customize your Jaeger configuration.</simpara>
</listitem>
</itemizedlist>
<simpara>The default Jaeger parameters specified in the <literal>ServiceMeshControlPlane</literal> are as follows:</simpara>
<formalpara>
<title>Default <literal>all-in-one</literal> Jaeger parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  version: v1.1
  istio:
    tracing:
      enabled: true
      jaeger:
        template: all-in-one</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Jaeger parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">tracing:
   enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables installing and deploying tracing by the Service Mesh Operator. Installing Jaeger is enabled by default.  To use an existing Jaeger deployment, set this value to <literal>false</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">jaeger:
   template:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter specifies which Jaeger deployment strategy to use.</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>all-in-one</literal>- For development, testing, demonstrations, and proof of concept.</simpara>
</listitem>
<listitem>
<simpara><literal>production-elasticsearch</literal> - For production use.</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara><literal>all-in-one</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>The default template in the <literal>ServiceMeshControlPlane</literal> resource is the <literal>all-in-one</literal> deployment strategy which uses in-memory storage. For production, the only supported storage option is Elasticsearch, therefore you must configure the <literal>ServiceMeshControlPlane</literal> to request the <literal>production-elasticsearch</literal> template when you deploy Service Mesh within a production environment.</simpara>
</note>
<section xml:id="ossm-configuring-jaeger-elasticsearch_ossm-controler-items-v1x">
<title>Configuring Elasticsearch</title>
<simpara>The default Jaeger deployment strategy uses the <literal>all-in-one</literal> template so that the installation can be completed using minimal resources.  However, because the <literal>all-in-one</literal> template uses in-memory storage, it is only recommended for development, demo, or testing purposes and should NOT be used for production environments.</simpara>
<simpara>If you are deploying Service Mesh and Jaeger in a production environment you must change the template to the <literal>production-elasticsearch</literal> template, which uses Elasticsearch for Jaeger&#8217;s storage needs.</simpara>
<simpara>Elasticsearch is a memory intensive application. The initial set of nodes specified in the default OpenShift Container Platform installation may not be large enough to support the Elasticsearch cluster.  You should modify the default Elasticsearch configuration to match your use case and the resources you have requested for your OpenShift Container Platform installation. You can adjust both the CPU and memory limits for each component by modifying the resources block with valid CPU and memory values. Additional nodes must be added to the  cluster if you want to run with the recommended amount (or more) of memory. Ensure that you do not exceed the resources requested for your OpenShift Container Platform installation.</simpara>
<formalpara>
<title>Default "production" Jaeger parameters with Elasticsearch</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    tracing:
    enabled: true
    ingress:
      enabled: true
    jaeger:
      template: production-elasticsearch
      elasticsearch:
        nodeCount: 3
        redundancyPolicy:
        resources:
          requests:
            cpu: "1"
            memory: "16Gi"
          limits:
            cpu: "1"
            memory: "16Gi"</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Elasticsearch parameters</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default Value</entry>
<entry align="left" valign="top">Examples</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">tracing:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables tracing in Service Mesh. Jaeger is installed by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">ingress:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables ingress for Jaeger.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">jaeger:
   template:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter specifies which Jaeger deployment strategy to use.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>all-in-one</literal>/<literal>production-elasticsearch</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>all-in-one</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  nodeCount:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of Elasticsearch nodes to create.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer value.</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1,
Minimum deployment =3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">requests:
  cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of central processing units for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores (for example, 200m, 0.5, 1).</simpara></entry>
<entry align="left" valign="top"><simpara>1Gi</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">requests:
  memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes (for example, 200Ki, 50Mi, 5Gi).</simpara></entry>
<entry align="left" valign="top"><simpara>500m</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">limits:
  cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Limit on number of central processing units, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores (for example, 200m, 0.5, 1).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">limits:
  memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory limit based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes (for example, 200Ki, 50Mi, 5Gi).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top" namest="col_2" nameend="col_5"><simpara>* Each Elasticsearch node can operate with a lower memory setting though this is <emphasis role="strong">not</emphasis> recommended for production deployments. For production use, you should have no less than 16Gi allocated to each pod by default, but preferably allocate as much as you can, up to 64Gi per pod.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your control plane file, for example, <literal>basic-install</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Edit the Jaeger parameters, replacing the default <literal>all-in-one</literal> template with parameters for the <literal>production-elasticsearch</literal> template, modified for your use case.  Ensure that the indentation is correct.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.
OpenShift Container Platform redeploys Jaeger and creates the Elasticsearch resources based on the specified parameters.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-configuring-jaeger-existing-v1x_ossm-controler-items-v1x">
<title>Connecting to an existing Jaeger instance</title>
<simpara>In order for the SMCP to connect to an existing Jaeger instance, the following must be true:</simpara>
<itemizedlist>
<listitem>
<simpara>The Jaeger instance is deployed in the same namespace as the control plane, for example, into the <literal>istio-system</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>To enable secure communication between services, you should enable the oauth-proxy, which secures communication to your Jaeger instance, and make sure the secret is mounted into your Jaeger instance so Kiali can communicate with it.</simpara>
</listitem>
<listitem>
<simpara>To use a custom or already existing Jaeger instance, set <literal>spec.istio.tracing.enabled</literal> to "false" to disable the deployment of a Jaeger instance.</simpara>
</listitem>
<listitem>
<simpara>Supply the correct jaeger-collector endpoint to Mixer by setting <literal>spec.istio.global.tracer.zipkin.address</literal> to the hostname and port of your jaeger-collector service. The hostname of the service is usually <literal>&lt;jaeger-instance-name&gt;-collector.&lt;namespace&gt;.svc.cluster.local</literal>.</simpara>
</listitem>
<listitem>
<simpara>Supply the correct jaeger-query endpoint to Kiali for gathering traces by setting <literal>spec.istio.kiali.jaegerInClusterURL</literal> to the hostname of your jaeger-query service - the port is normally not required, as it uses 443 by default. The hostname of the service is usually  <literal>&lt;jaeger-instance-name&gt;-query.&lt;namespace&gt;.svc.cluster.local</literal>.</simpara>
</listitem>
<listitem>
<simpara>Supply the dashboard URL of your Jaeger instance to Kiali to enable accessing Jaeger through the Kiali console. You can retrieve the URL from the OpenShift route that is created by the Jaeger Operator. If your Jaeger resource is called <literal>external-jaeger</literal> and resides in the <literal>istio-system</literal> project, you can retrieve the route using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route -n istio-system external-jaeger</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   HOST/PORT                                     PATH   SERVICES               [...]
external-jaeger        external-jaeger-istio-system.apps.test        external-jaeger-query  [...]</programlisting>
</para>
</formalpara>
<simpara>The value under <literal>HOST/PORT</literal> is the externally accessible URL of the Jaeger dashboard.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example Jaeger resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: jaegertracing.io/v1
kind: "Jaeger"
metadata:
  name: "external-jaeger"
  # Deploy to the Control Plane Namespace
  namespace: istio-system
spec:
  # Set Up Authentication
  ingress:
    enabled: true
    security: oauth-proxy
    openshift:
      # This limits user access to the Jaeger instance to users who have access
      # to the control plane namespace. Make sure to set the correct namespace here
      sar: '{"namespace": "istio-system", "resource": "pods", "verb": "get"}'
      htpasswdFile: /etc/proxy/htpasswd/auth

  volumeMounts:
  - name: secret-htpasswd
    mountPath: /etc/proxy/htpasswd
  volumes:
  - name: secret-htpasswd
    secret:
      secretName: htpasswd</programlisting>
</para>
</formalpara>
<simpara>The following <literal>ServiceMeshControlPlane</literal> example assumes that you have deployed Jaeger using the Jaeger Operator and the example Jaeger resource.</simpara>
<formalpara>
<title>Example <literal>ServiceMeshControlPlane</literal> with external Jaeger</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
metadata:
  name: external-jaeger
  namespace: istio-system
spec:
  version: v1.1
  istio:
    tracing:
      # Disable Jaeger deployment by service mesh operator
      enabled: false
    global:
      tracer:
        zipkin:
          # Set Endpoint for Trace Collection
          address: external-jaeger-collector.istio-system.svc.cluster.local:9411
    kiali:
      # Set Jaeger dashboard URL
      dashboard:
        jaegerURL: https://external-jaeger-istio-system.apps.test
      # Set Endpoint for Trace Querying
      jaegerInClusterURL: external-jaeger-query.istio-system.svc.cluster.local</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-jaeger-config-elasticsearch-v1x_ossm-controler-items-v1x">
<title>Configuring Elasticsearch</title>
<simpara>The default Jaeger deployment strategy uses the <literal>all-in-one</literal> template so that the installation can be completed using minimal resources.  However, because the <literal>all-in-one</literal> template uses in-memory storage, it is only recommended for development, demo, or testing purposes and should NOT be used for production environments.</simpara>
<simpara>If you are deploying Service Mesh and Jaeger in a production environment you must change the template to the <literal>production-elasticsearch</literal> template, which uses Elasticsearch for Jaeger&#8217;s storage needs.</simpara>
<simpara>Elasticsearch is a memory intensive application. The initial set of nodes specified in the default OpenShift Container Platform installation may not be large enough to support the Elasticsearch cluster.  You should modify the default Elasticsearch configuration to match your use case and the resources you have requested for your OpenShift Container Platform installation. You can adjust both the CPU and memory limits for each component by modifying the resources block with valid CPU and memory values. Additional nodes must be added to the  cluster if you want to run with the recommended amount (or more) of memory. Ensure that you do not exceed the resources requested for your OpenShift Container Platform installation.</simpara>
<formalpara>
<title>Default "production" Jaeger parameters with Elasticsearch</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: maistra.io/v1
kind: ServiceMeshControlPlane
spec:
  istio:
    tracing:
    enabled: true
    ingress:
      enabled: true
    jaeger:
      template: production-elasticsearch
      elasticsearch:
        nodeCount: 3
        redundancyPolicy:
        resources:
          requests:
            cpu: "1"
            memory: "16Gi"
          limits:
            cpu: "1"
            memory: "16Gi"</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Elasticsearch parameters</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default Value</entry>
<entry align="left" valign="top">Examples</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">tracing:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables tracing in Service Mesh. Jaeger is installed by default.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">ingress:
  enabled:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter enables/disables ingress for Jaeger.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">jaeger:
   template:</literallayout></entry>
<entry align="left" valign="top"><simpara>This parameter specifies which Jaeger deployment strategy to use.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>all-in-one</literal>/<literal>production-elasticsearch</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>all-in-one</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">elasticsearch:
  nodeCount:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of Elasticsearch nodes to create.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer value.</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1,
Minimum deployment =3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">requests:
  cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Number of central processing units for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores (for example, 200m, 0.5, 1).</simpara></entry>
<entry align="left" valign="top"><simpara>1Gi</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">requests:
  memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory for requests, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes (for example, 200Ki, 50Mi, 5Gi).</simpara></entry>
<entry align="left" valign="top"><simpara>500m</simpara></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">limits:
  cpu:</literallayout></entry>
<entry align="left" valign="top"><simpara>Limit on number of central processing units, based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in cores or millicores (for example, 200m, 0.5, 1).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 500m,
Minimum deployment =1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced">limits:
  memory:</literallayout></entry>
<entry align="left" valign="top"><simpara>Available memory limit based on your environment&#8217;s configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Specified in bytes (for example, 200Ki, 50Mi, 5Gi).</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Proof of concept = 1Gi,
Minimum deployment = 16Gi*</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><literallayout class="monospaced"></literallayout></entry>
<entry align="left" valign="top" namest="col_2" nameend="col_5"><simpara>* Each Elasticsearch node can operate with a lower memory setting though this is <emphasis role="strong">not</emphasis> recommended for production deployments. For production use, you should have no less than 16Gi allocated to each pod by default, but preferably allocate as much as you can, up to 64Gi per pod.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Red Hat OpenShift Service Mesh Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Istio Service Mesh Control Plane</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of your control plane file, for example, <literal>basic-install</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Edit the Jaeger parameters, replacing the default <literal>all-in-one</literal> template with parameters for the <literal>production-elasticsearch</literal> template, modified for your use case.  Ensure that the indentation is correct.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Reload</emphasis>.
OpenShift Container Platform redeploys Jaeger and creates the Elasticsearch resources based on the specified parameters.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-jaeger-config-es-cleaner-v1x_ossm-controler-items-v1x">
<title>Configuring the Elasticsearch index cleaner job</title>
<simpara>When the Service Mesh Operator creates the <literal>ServiceMeshControlPlane</literal> it also creates the custom resource (CR) for Jaeger. The Red Hat OpenShift distributed tracing platform (Jaeger) Operator then uses this CR when creating Jaeger instances.</simpara>
<simpara>When using Elasticsearch storage, by default a job is created to clean old traces from it. To configure the options for this job, you edit the Jaeger custom resource (CR), to customize it for your use case. The relevant options are listed below.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: jaegertracing.io/v1
  kind: Jaeger
  spec:
    strategy: production
    storage:
      type: elasticsearch
      esIndexCleaner:
        enabled: false
        numberOfDays: 7
        schedule: "55 23 * * *"</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Elasticsearch index cleaner parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>enabled:</simpara></entry>
<entry align="left" valign="top"><simpara>true/ false</simpara></entry>
<entry align="left" valign="top"><simpara>Enable or disable the index cleaner job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>numberOfDays:</simpara></entry>
<entry align="left" valign="top"><simpara>integer value</simpara></entry>
<entry align="left" valign="top"><simpara>Number of days to wait before deleting an index.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>schedule:</simpara></entry>
<entry align="left" valign="top"><simpara>"55 23 * * *"</simpara></entry>
<entry align="left" valign="top"><simpara>Cron expression for the job to run</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For more information about configuring Elasticsearch with OpenShift Container Platform, see  <link xlink:href="../../logging/log_storage/logging-config-es-store.xml#logging-config-es-store">Configuring the Elasticsearch log store</link>.</simpara>
</section>
</section>
<section xml:id="ossm-cr-threescale_ossm-controler-items-v1x">
<title>3scale configuration</title>
<simpara>The following table explains the parameters for the 3scale Istio Adapter in the <literal>ServiceMeshControlPlane</literal> resource.</simpara>
<formalpara>
<title>Example 3scale parameters</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  addons:
    3Scale:
      enabled: false
      PARAM_THREESCALE_LISTEN_ADDR: 3333
      PARAM_THREESCALE_LOG_LEVEL: info
      PARAM_THREESCALE_LOG_JSON: true
      PARAM_THREESCALE_LOG_GRPC: false
      PARAM_THREESCALE_REPORT_METRICS: true
      PARAM_THREESCALE_METRICS_PORT: 8080
      PARAM_THREESCALE_CACHE_TTL_SECONDS: 300
      PARAM_THREESCALE_CACHE_REFRESH_SECONDS: 180
      PARAM_THREESCALE_CACHE_ENTRIES_MAX: 1000
      PARAM_THREESCALE_CACHE_REFRESH_RETRIES: 1
      PARAM_THREESCALE_ALLOW_INSECURE_CONN: false
      PARAM_THREESCALE_CLIENT_TIMEOUT_SECONDS: 10
      PARAM_THREESCALE_GRPC_CONN_MAX_SECONDS: 60
      PARAM_USE_CACHED_BACKEND: false
      PARAM_BACKEND_CACHE_FLUSH_INTERVAL_SECONDS: 15
      PARAM_BACKEND_CACHE_POLICY_FAIL_CLOSED: true</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>3scale parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>enabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether to use the 3scale adapter</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LISTEN_ADDR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the listen address for the gRPC server</simpara></entry>
<entry align="left" valign="top"><simpara>Valid port number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>3333</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_LEVEL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the minimum log output level.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>debug</literal>, <literal>info</literal>, <literal>warn</literal>, <literal>error</literal>, or <literal>none</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>info</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_JSON</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether the log is formatted as JSON</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_LOG_GRPC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether the log contains gRPC info</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_REPORT_METRICS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controls whether 3scale system and backend metrics are collected and reported to Prometheus</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_METRICS_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the port that the 3scale <literal>/metrics</literal> endpoint can be scrapped from</simpara></entry>
<entry align="left" valign="top"><simpara>Valid port number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>8080</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_TTL_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time period, in seconds, to wait before purging expired items from the cache</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>300</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_REFRESH_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time period before expiry when cache elements are attempted to be refreshed</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>180</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_ENTRIES_MAX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Max number of items that can be stored in the cache at any time. Set to <literal>0</literal> to disable caching</simpara></entry>
<entry align="left" valign="top"><simpara>Valid number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1000</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CACHE_REFRESH_RETRIES</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of times unreachable hosts are retried during a cache update loop</simpara></entry>
<entry align="left" valign="top"><simpara>Valid number</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_ALLOW_INSECURE_CONN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allow to skip certificate verification when calling <literal>3scale</literal> APIs. Enabling this is not recommended.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_CLIENT_TIMEOUT_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the number of seconds to wait before terminating requests to 3scale System and Backend</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_THREESCALE_GRPC_CONN_MAX_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the maximum amount of seconds (+/-10% jitter) a connection may exist before it is closed</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara>60</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_USE_CACHE_BACKEND</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If true, attempt to create an in-memory apisonator cache for authorization requests</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_BACKEND_CACHE_FLUSH_INTERVAL_SECONDS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the backend cache is enabled, this sets the interval in seconds for flushing the cache against 3scale</simpara></entry>
<entry align="left" valign="top"><simpara>Time period in seconds</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PARAM_BACKEND_CACHE_POLICY_FAIL_CLOSED</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whenever the backend cache cannot retrieve authorization data, whether to deny (closed) or allow (open) requests</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal>/<literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="threescale-adapter-v1x">
<title>Using the 3scale Istio adapter</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>The 3scale Istio Adapter is an optional adapter that allows you to label a service running within the Red Hat OpenShift Service Mesh and integrate that service with the 3scale API Management solution.
It is not required for Red Hat OpenShift Service Mesh.</simpara>
<section xml:id="ossm-threescale-integrate-1x_threescale-adapter-v1x">
<title>Integrate the 3scale adapter with Red Hat OpenShift Service Mesh</title>
<simpara>You can use these examples to configure requests to your services using the 3scale Istio Adapter.</simpara>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>Red Hat OpenShift Service Mesh version 1.x</simpara>
</listitem>
<listitem>
<simpara>A working 3scale account (<link xlink:href="https://www.3scale.net/signup/">SaaS</link> or <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.5/html/installing_3scale/onpremises-installation">3scale 2.5 On-Premises</link>)</simpara>
</listitem>
<listitem>
<simpara>Enabling backend cache requires 3scale 2.9 or greater</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Service Mesh prerequisites</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>To configure the 3scale Istio Adapter, refer to Red Hat OpenShift Service Mesh custom resources for instructions on adding adapter parameters to the custom resource file.</simpara>
</note>
<note>
<simpara>Pay particular attention to the <literal>kind: handler</literal> resource. You must update this with your 3scale account credentials. You can optionally add a <literal>service_id</literal> to a handler, but this is kept for backwards compatibility only, since it would render the handler only useful for one service in your 3scale account. If you add <literal>service_id</literal> to a handler, enabling 3scale for other services requires you to create more handlers with different <literal>service_ids</literal>.</simpara>
</note>
<simpara>Use a single handler per 3scale account by following the steps below:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a handler for your 3scale account and specify your account credentials. Omit any service identifier.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: "config.istio.io/v1alpha2"
  kind: handler
  metadata:
   name: threescale
  spec:
   adapter: threescale
   params:
     system_url: "https://&lt;organization&gt;-admin.3scale.net/"
     access_token: "&lt;ACCESS_TOKEN&gt;"
   connection:
     address: "threescale-istio-adapter:3333"</programlisting>
<simpara>Optionally, you can provide a <literal>backend_url</literal> field within the <emphasis>params</emphasis> section to override the URL provided by the 3scale configuration. This may be useful if the adapter runs on the same cluster as the 3scale on-premise instance, and you wish to leverage the internal cluster DNS.</simpara>
</listitem>
<listitem>
<simpara>Edit or patch the Deployment resource of any services belonging to your 3scale account as follows:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the <literal>"service-mesh.3scale.net/service-id"</literal> label with a value corresponding to a valid <literal>service_id</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>"service-mesh.3scale.net/credentials"</literal> label with its value being the <emphasis>name of the handler resource</emphasis> from step 1.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Do step 2 to link it to your 3scale account credentials and to its service identifier, whenever you intend to add more services.</simpara>
</listitem>
<listitem>
<simpara>Modify the rule configuration with your 3scale configuration to dispatch the rule to the threescale handler.</simpara>
<formalpara>
<title>Rule configuration example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: "config.istio.io/v1alpha2"
  kind: rule
  metadata:
    name: threescale
  spec:
    match: destination.labels["service-mesh.3scale.net"] == "true"
    actions:
      - handler: threescale.handler
        instances:
          - threescale-authorization.instance</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="ossm-threescale-cr_threescale-adapter-v1x">
<title>Generating 3scale custom resources</title>
<simpara>The adapter includes a tool that allows you to generate the <literal>handler</literal>, <literal>instance</literal>, and <literal>rule</literal> custom resources.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Usage</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h, --help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Produces help output for available options</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unique name for this URL, token pair</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n, --namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Namespace to generate templates</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>istio-system</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-t, --token</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale access token</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-u, --url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale Admin Portal URL</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--backend-url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale backend URL. If set, it overrides the value that is read from system configuration</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-s, --service</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale API/Service ID</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--auth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>3scale authentication pattern to specify (1=API Key, 2=App Id/App Key, 3=OIDC)</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Hybrid</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-o, --output</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File to save produced manifests to</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Standard output</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Outputs the CLI version and exits immediately</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="ossm-threescale-templates_threescale-adapter-v1x">
<title>Generate templates from URL examples</title>
<note>
<itemizedlist>
<listitem>
<simpara>Run the following commands via <literal>oc exec</literal> from the 3scale adapter container image in <link linkend="ossm-threescale-manifests_threescale-adapter-v1x">Generating manifests from a deployed adapter</link>.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>3scale-config-gen</literal> command to help avoid YAML syntax and indentation errors.</simpara>
</listitem>
<listitem>
<simpara>You can omit the <literal>--service</literal> if you use the annotations.</simpara>
</listitem>
<listitem>
<simpara>This command must be invoked from within the container image via <literal>oc exec</literal>.</simpara>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>3scale-config-gen</literal> command to autogenerate templates files allowing the token, URL pair to be shared by multiple services as a single handler:</simpara>
<screen>$ 3scale-config-gen --name=admin-credentials --url="https://&lt;organization&gt;-admin.3scale.net:443" --token="[redacted]"</screen>
</listitem>
<listitem>
<simpara>The following example generates the templates with the service ID embedded in the handler:</simpara>
<screen>$ 3scale-config-gen --url="https://&lt;organization&gt;-admin.3scale.net" --name="my-unique-id" --service="123456789" --token="[redacted]"</screen>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.10/html-single/admin_portal_guide/index#tokens">Tokens</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ossm-threescale-manifests_threescale-adapter-v1x">
<title>Generating manifests from a deployed adapter</title>
<note>
<itemizedlist>
<listitem>
<simpara><literal>NAME</literal> is an identifier you use to identify with the service you are managing with 3scale.</simpara>
</listitem>
<listitem>
<simpara>The <literal>CREDENTIALS_NAME</literal> reference is an identifier that corresponds to the <literal>match</literal> section in the rule configuration. This is automatically set to the <literal>NAME</literal> identifier if you are using the CLI tool.</simpara>
</listitem>
<listitem>
<simpara>Its value does not need to be anything specific: the label value should just match the contents of the rule. See <link xlink:href="https://github.com/3scale/3scale-istio-adapter/blob/v2.X/README.md#routing-service-traffic-through-the-adapter">Routing service traffic through the adapter</link> for more information.</simpara>
</listitem>
</itemizedlist>
</note>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run this command to generate manifests from a deployed adapter in the <literal>istio-system</literal> namespace:</simpara>
<screen>$ export NS="istio-system" URL="https://replaceme-admin.3scale.net:443" NAME="name" TOKEN="token"
oc exec -n ${NS} $(oc get po -n ${NS} -o jsonpath='{.items[?(@.metadata.labels.app=="3scale-istio-adapter")].metadata.name}') \
-it -- ./3scale-config-gen \
--url ${URL} --name ${NAME} --token ${TOKEN} -n ${NS}</screen>
</listitem>
<listitem>
<simpara>This will produce sample output to the terminal. Edit these samples if required and create the objects using the <literal>oc create</literal> command.</simpara>
</listitem>
<listitem>
<simpara>When the request reaches the adapter, the adapter needs to know how the service maps to an API on 3scale. You can provide this information in two ways:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Label the workload (recommended)</simpara>
</listitem>
<listitem>
<simpara>Hard code the handler as <literal>service_id</literal></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the workload with the required annotations:</simpara>
<note>
<simpara>You only need to update the service ID provided in this example if it is not already embedded in the handler. <emphasis role="strong">The setting in the handler takes precedence</emphasis>.</simpara>
</note>
<screen>$ export CREDENTIALS_NAME="replace-me"
export SERVICE_ID="replace-me"
export DEPLOYMENT="replace-me"
patch="$(oc get deployment "${DEPLOYMENT}"
patch="$(oc get deployment "${DEPLOYMENT}" --template='{"spec":{"template":{"metadata":{"labels":{ {{ range $k,$v := .spec.template.metadata.labels }}"{{ $k }}":"{{ $v }}",{{ end }}"service-mesh.3scale.net/service-id":"'"${SERVICE_ID}"'","service-mesh.3scale.net/credentials":"'"${CREDENTIALS_NAME}"'"}}}}}' )"
oc patch deployment "${DEPLOYMENT}" --patch ''"${patch}"''</screen>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-threescale-routing_threescale-adapter-v1x">
<title>Routing service traffic through the adapter</title>
<simpara>Follow these steps to drive traffic for your service through the 3scale adapter.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Credentials and service ID from your 3scale administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Match the rule <literal>destination.labels["service-mesh.3scale.net/credentials"] == "threescale"</literal> that you previously created in the configuration, in the <literal>kind: rule</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>Add the above label to <literal>PodTemplateSpec</literal> on the Deployment of the target workload to integrate a service. the value, <literal>threescale</literal>, refers to the name of the generated handler. This handler stores the access token required to call 3scale.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>destination.labels["service-mesh.3scale.net/service-id"] == "replace-me"</literal> label to the workload to pass the service ID to the adapter via the instance at request time.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-threescale-integration-settings_threescale-adapter-v1x">
<title>Configure the integration settings in 3scale</title>
<simpara>Follow this procedure to configure the 3scale integration settings.</simpara>
<note>
<simpara>For 3scale SaaS customers, Red Hat OpenShift Service Mesh is enabled as part of the Early Access program.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">[your_API_name]</emphasis> &#8594; <emphasis role="strong">Integration</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Istio</emphasis> option under <emphasis>Deployment</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">API Key (user_key)</emphasis> option under <emphasis>Authentication</emphasis> is selected by default.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Update Product</emphasis> to save your selection.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Configuration</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Update Configuration</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-threescale-caching_threescale-adapter-v1x">
<title>Caching behavior</title>
<simpara>Responses from 3scale System APIs are cached by default within the adapter. Entries will be purged from the cache when they become older than the <literal>cacheTTLSeconds</literal> value. Also by default, automatic refreshing of cached entries will be attempted seconds before they expire, based on the <literal>cacheRefreshSeconds</literal> value. You can disable automatic refreshing by setting this value higher than the <literal>cacheTTLSeconds</literal> value.</simpara>
<simpara>Caching can be disabled entirely by setting <literal>cacheEntriesMax</literal> to a non-positive value.</simpara>
<simpara>By using the refreshing process, cached values whose hosts become unreachable will be retried before eventually being purged when past their expiry.</simpara>
</section>
<section xml:id="ossm-threescale-authentication_threescale-adapter-v1x">
<title>Authenticating requests</title>
<simpara>This release supports the following authentication methods:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Standard API Keys</emphasis>: single randomized strings or hashes acting as an identifier and a secret token.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Application identifier and key pairs</emphasis>: immutable identifier and mutable secret key strings.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">OpenID authentication method</emphasis>: client ID string parsed from the JSON Web Token.</simpara>
</listitem>
</itemizedlist>
<section xml:id="ossm-threescale-authentication-patterns_threescale-adapter-v1x">
<title>Applying authentication patterns</title>
<simpara>Modify the <literal>instance</literal> custom resource, as illustrated in the following authentication method examples, to configure authentication behavior. You can accept the authentication credentials from:</simpara>
<itemizedlist>
<listitem>
<simpara>Request headers</simpara>
</listitem>
<listitem>
<simpara>Request parameters</simpara>
</listitem>
<listitem>
<simpara>Both request headers and query parameters</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>When specifying values from headers, they must be lower case. For example, if you want to send a header as <literal>User-Key</literal>, this must be referenced in the configuration as <literal>request.headers["user-key"]</literal>.</simpara>
</note>
<section xml:id="ossm-threescale-apikey-authentication_threescale-adapter-v1x">
<title>API key authentication method</title>
<simpara>Service Mesh looks for the API key in query parameters and request headers as specified in the <literal>user</literal> option in the <literal>subject</literal> custom resource parameter. It checks the values in the order given in the custom resource file. You can restrict the search for the API key to either query parameters or request headers by omitting the unwanted option.</simpara>
<simpara>In this example, Service Mesh looks for the API key in the <literal>user_key</literal> query parameter. If the API key is not in the query parameter, Service Mesh then checks the <literal>user-key</literal> header.</simpara>
<formalpara>
<title>API key authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
  namespace: istio-system
spec:
  template: authorization
  params:
    subject:
      user: request.query_params["user_key"] | request.headers["user-key"] | ""
    action:
      path: request.url_path
      method: request.method | "get"</programlisting>
</para>
</formalpara>
<simpara>If you want the adapter to examine a different query parameter or request header, change the name as appropriate. For example, to check for the API key in a query parameter named “key”, change <literal>request.query_params["user_key"]</literal> to <literal>request.query_params["key"]</literal>.</simpara>
</section>
<section xml:id="ossm-threescale-appidapikey-authentication_threescale-adapter-v1x">
<title>Application ID and application key pair authentication method</title>
<simpara>Service Mesh looks for the application ID and application key in query parameters and request headers, as specified in the <literal>properties</literal> option in the <literal>subject</literal> custom resource parameter. The application key is optional. It checks the values in the order given in the custom resource file. You can restrict the search for the credentials to either query parameters or request headers by not including the unwanted option.</simpara>
<simpara>In this example, Service Mesh looks for the application ID and application key in the query parameters first, moving on to the request headers if needed.</simpara>
<formalpara>
<title>Application ID and application key pair authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
  namespace: istio-system
spec:
  template: authorization
  params:
    subject:
        app_id: request.query_params["app_id"] | request.headers["app-id"] | ""
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
    action:
      path: request.url_path
      method: request.method | "get"</programlisting>
</para>
</formalpara>
<simpara>If you want the adapter to examine a different query parameter or request header, change the name as appropriate. For example, to check for the application ID in a query parameter named <literal>identification</literal>, change <literal>request.query_params["app_id"]</literal> to <literal>request.query_params["identification"]</literal>.</simpara>
</section>
<section xml:id="ossm-threescale-openid-authentication_threescale-adapter-v1x">
<title>OpenID authentication method</title>
<simpara>To use the <emphasis>OpenID Connect (OIDC) authentication method</emphasis>, use the <literal>properties</literal> value on the <literal>subject</literal> field to set <literal>client_id</literal>, and optionally <literal>app_key</literal>.</simpara>
<simpara>You can manipulate this object using the methods described previously. In the example configuration shown below, the client identifier (application ID) is parsed from the JSON Web Token (JWT) under the label <emphasis>azp</emphasis>. You can modify this as needed.</simpara>
<formalpara>
<title>OpenID authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
spec:
  template: threescale-authorization
  params:
    subject:
      properties:
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
        client_id: request.auth.claims["azp"] | ""
      action:
        path: request.url_path
        method: request.method | "get"
        service: destination.labels["service-mesh.3scale.net/service-id"] | ""</programlisting>
</para>
</formalpara>
<simpara>For this integration to work correctly, OIDC must still be done in 3scale for the client to be created in the identity provider (IdP). You should create a <link xlink:href="https://istio.io/latest/docs/tasks/security/authorization/authz-jwt/">Request authorization</link> for the service you want to protect in the same namespace as that service. The JWT is passed in the <literal>Authorization</literal> header of the request.</simpara>
<simpara>In the sample <literal>RequestAuthentication</literal> defined below, replace <literal>issuer</literal>, <literal>jwksUri</literal>, and <literal>selector</literal> as appropriate.</simpara>
<formalpara>
<title>OpenID Policy example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: jwt-example
  namespace: bookinfo
spec:
  selector:
    matchLabels:
      app: productpage
  jwtRules:
  - issuer: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak
    jwksUri: &gt;-
      http://keycloak-keycloak.34.242.107.254.nip.io/auth/realms/3scale-keycloak/protocol/openid-connect/certs</programlisting>
</para>
</formalpara>
</section>
<section xml:id="ossm-threescale-hybrid-authentication_threescale-adapter-v1x">
<title>Hybrid authentication method</title>
<simpara>You can choose to not enforce a particular authentication method and accept any valid credentials for either method. If both an API key and an application ID/application key pair are provided, Service Mesh uses the API key.</simpara>
<simpara>In this example, Service Mesh checks for an API key in the query parameters, then the request headers. If there is no API key, it then checks for an application ID and key in the query parameters, then the request headers.</simpara>
<formalpara>
<title>Hybrid authentication method example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "config.istio.io/v1alpha2"
kind: instance
metadata:
  name: threescale-authorization
spec:
  template: authorization
  params:
    subject:
      user: request.query_params["user_key"] | request.headers["user-key"] |
      properties:
        app_id: request.query_params["app_id"] | request.headers["app-id"] | ""
        app_key: request.query_params["app_key"] | request.headers["app-key"] | ""
        client_id: request.auth.claims["azp"] | ""
    action:
      path: request.url_path
      method: request.method | "get"
      service: destination.labels["service-mesh.3scale.net/service-id"] | ""</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="ossm-threescale-metrics-1x_threescale-adapter-v1x">
<title>3scale Adapter metrics</title>
<simpara>The adapter, by default reports various Prometheus metrics that are exposed on port <literal>8080</literal> at the <literal>/metrics</literal> endpoint. These metrics provide insight into how the interactions between the adapter and 3scale are performing. The service is labeled to be automatically discovered and scraped by Prometheus.</simpara>
</section>
<section xml:id="ossm-threescale-istio-adapter-verification_threescale-adapter-v1x">
<title>3scale Istio adapter verification</title>
<simpara>You might want to check whether the 3scale Istio adapter is working as expected. If your adapter is not working, use the following steps to help troubleshoot the problem.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Ensure the <emphasis>3scale-adapter</emphasis> pod is running in the Service Mesh control plane namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;istio-system&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check that the <emphasis>3scale-adapter</emphasis> pod has printed out information about itself booting up, such as its version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs &lt;istio-system&gt;</programlisting>
</listitem>
<listitem>
<simpara>When performing requests to the services protected by the 3scale adapter integration, always try requests that lack the right credentials and ensure they fail. Check the 3scale adapter logs to gather additional information.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/container-platform/4.7/support/troubleshooting/investigating-pod-issues.html#inspecting-pod-and-container-logs_investigating-pod-issues">Inspecting pod and container logs</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ossm-threescale-istio-adapter-troubleshooting-checklist_threescale-adapter-v1x">
<title>3scale Istio adapter troubleshooting checklist</title>
<simpara>As the administrator installing the 3scale Istio adapter, there are a number of scenarios that might be causing your integration to not function properly. Use the following list to troubleshoot your installation:</simpara>
<itemizedlist>
<listitem>
<simpara>Incorrect YAML indentation.</simpara>
</listitem>
<listitem>
<simpara>Missing YAML sections.</simpara>
</listitem>
<listitem>
<simpara>Forgot to apply the changes in the YAML to the cluster.</simpara>
</listitem>
<listitem>
<simpara>Forgot to label the service workloads with the <literal>service-mesh.3scale.net/credentials</literal> key.</simpara>
</listitem>
<listitem>
<simpara>Forgot to label the service workloads with <literal>service-mesh.3scale.net/service-id</literal> when using handlers that do not contain a <literal>service_id</literal> so they are reusable per account.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Rule</emphasis> custom resource points to the wrong handler or instance custom resources, or the references lack the corresponding namespace suffix.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Rule</emphasis> custom resource <literal>match</literal> section cannot possibly match the service you are configuring, or it points to a destination workload that is not currently running or does not exist.</simpara>
</listitem>
<listitem>
<simpara>Wrong access token or URL for the 3scale Admin Portal in the handler.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Instance</emphasis> custom resource&#8217;s <literal>params/subject/properties</literal> section fails to list the right parameters for <literal>app_id</literal>, <literal>app_key</literal>, or <literal>client_id</literal>, either because they specify the wrong location such as the query parameters, headers, and authorization claims, or the parameter names do not match the requests used for testing.</simpara>
</listitem>
<listitem>
<simpara>Failing to use the configuration generator without realizing that it actually lives in the adapter container image and needs <literal>oc exec</literal> to invoke it.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="removing-ossm-v1x">
<title>Removing Service Mesh</title>

<warning>
<simpara><emphasis role="strong">You are viewing documentation for a Red Hat OpenShift Service Mesh release that is no longer supported.</emphasis></simpara>
<simpara>Service Mesh version 1.0 and 1.1 control planes are no longer supported. For information about upgrading your service mesh control plane, see <link xlink:href="../../service_mesh/v2x/upgrading-ossm.xml#ossm-versions_ossm-upgrade">Upgrading Service Mesh</link>.</simpara>
<simpara>For information about the support status of a particular Red Hat OpenShift Service Mesh release, see the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#ossm">Product lifecycle page</link>.</simpara>
</warning>
<simpara>To remove Red Hat OpenShift Service Mesh from an existing OpenShift Container Platform instance, remove the control plane before removing the operators.</simpara>
<section xml:id="ossm-control-plane-remove_removing-ossm-v1x">
<title>Removing the Red Hat OpenShift Service Mesh control plane</title>
<simpara>To uninstall Service Mesh from an existing OpenShift Container Platform instance, first you delete the Service Mesh control plane and the Operators. Then, you run commands to remove residual resources.</simpara>
<section xml:id="ossm-control-plane-remove-operatorhub_removing-ossm-v1x">
<title>Removing the Service Mesh control plane using the web console</title>
<simpara>You can remove the Red Hat OpenShift Service Mesh control plane by using the web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> menu and select the project where you installed the Service Mesh control plane, for example <emphasis role="strong">istio-system</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Service Mesh Control Plane</emphasis> under <emphasis role="strong">Provided APIs</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <literal>ServiceMeshControlPlane</literal> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Delete Service Mesh Control Plane</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Delete</emphasis> on the confirmation dialog window to remove the <literal>ServiceMeshControlPlane</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-control-plane-remove-cli_removing-ossm-v1x">
<title>Removing the Service Mesh control plane using the CLI</title>
<simpara>You can remove the Red Hat OpenShift Service Mesh control plane by using the CLI.  In this example, <literal>istio-system</literal> is the name of the control plane project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to delete the <literal>ServiceMeshMemberRoll</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete smmr -n istio-system default</programlisting>
</listitem>
<listitem>
<simpara>Run this command to retrieve the name of the installed <literal>ServiceMeshControlPlane</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get smcp -n istio-system</programlisting>
</listitem>
<listitem>
<simpara>Replace <literal>&lt;name_of_custom_resource&gt;</literal> with the output from the previous command, and run this command to remove the custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete smcp -n istio-system &lt;name_of_custom_resource&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="ossm-operatorhub-remove-operators_removing-ossm-v1x">
<title>Removing the installed Operators</title>
<simpara>You must remove the Operators to successfully remove Red Hat OpenShift Service Mesh. After you remove the Red Hat OpenShift Service Mesh Operator, you must remove the Kiali Operator, the Red Hat OpenShift distributed tracing platform (Jaeger) Operator, and the OpenShift Elasticsearch Operator.</simpara>
<section xml:id="ossm-remove-operator-servicemesh_removing-ossm-v1x">
<title>Removing the Operators</title>
<simpara>Follow this procedure to remove the Operators that make up Red Hat OpenShift Service Mesh. Repeat the steps for each of the following Operators.</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Service Mesh</simpara>
</listitem>
<listitem>
<simpara>Kiali</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift distributed tracing platform (Jaeger)</simpara>
</listitem>
<listitem>
<simpara>OpenShift Elasticsearch</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis> page, scroll or type a keyword into the <emphasis role="strong">Filter by name</emphasis> to find each Operator. Then, click the Operator name.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Details</emphasis> page, select <emphasis role="strong">Uninstall Operator</emphasis> from the <emphasis role="strong">Actions</emphasis> menu. Follow the prompts to uninstall each Operator.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ossm-remove-cleanup-1x_removing-ossm-v1x">
<title>Clean up Operator resources</title>
<simpara>Follow this procedure to manually remove resources left behind after removing the Red Hat OpenShift Service Mesh Operator using the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An account with cluster administration access.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a cluster administrator.</simpara>
</listitem>
<listitem>
<simpara>Run the following commands to clean up resources after uninstalling the Operators. If you intend to keep using Jaeger as a stand alone service without service mesh, do not delete the Jaeger resources.</simpara>
<note>
<simpara>The Operators are installed in the <literal>openshift-operators</literal> namespace by default.  If you installed the Operators in another namespace, replace <literal>openshift-operators</literal> with the name of the project where the Red Hat OpenShift Service Mesh Operator was installed.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete validatingwebhookconfiguration/openshift-operators.servicemesh-resources.maistra.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete mutatingwebhookconfiguration/openshift-operators.servicemesh-resources.maistra.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -n openshift-operators daemonset/istio-node</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole/istio-admin clusterrole/istio-cni clusterrolebinding/istio-cni</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole istio-view istio-edit</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole jaegers.jaegertracing.io-v1-admin jaegers.jaegertracing.io-v1-crdview jaegers.jaegertracing.io-v1-edit jaegers.jaegertracing.io-v1-view</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.istio\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.maistra\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds -o name | grep '.*\.kiali\.io' | xargs -r -n 1 oc delete</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crds jaegers.jaegertracing.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete svc admission-controller -n &lt;operator-project&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project &lt;istio-system-project&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
</book>