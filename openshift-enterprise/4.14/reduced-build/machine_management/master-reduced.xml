<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info>
<title>Machine management</title>
<date>2024-02-23</date>
<title>Machine management</title>
<productname>OpenShift Container Platform</productname>
<productnumber>4.14</productnumber>
<subtitle>Enter a short description here.</subtitle>
<abstract>
    <para>A short overview and summary of the book's subject and purpose, traditionally no more than one paragraph long.</para>
</abstract>
<authorgroup>
    <orgname>Red Hat OpenShift Documentation Team</orgname>
</authorgroup>
<xi:include href="Common_Content/Legal_Notice.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</info>
<chapter xml:id="overview-of-machine-management">
<title>Overview of machine management</title>

<simpara>You can use machine management to flexibly work with underlying infrastructure such as Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP), Red Hat OpenStack Platform (RHOSP), and VMware vSphere to manage the OpenShift Container Platform cluster.
You can control the cluster and perform auto-scaling, such as scaling up and down the cluster based on specific workload policies.</simpara>
<simpara>It is important to have a cluster that adapts to changing workloads. The OpenShift Container Platform cluster can horizontally scale up and down when the load increases or decreases.</simpara>
<simpara>Machine management is implemented as a <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/operators/#crd-extending-api-with-crds">custom resource definition</link> (CRD).
A CRD object defines a new unique object <literal>Kind</literal> in the cluster and enables the Kubernetes API server to handle the object&#8217;s entire lifecycle.</simpara>
<simpara>The Machine API Operator provisions the following resources:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>MachineSet</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Machine</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClusterAutoscaler</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MachineAutoscaler</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MachineHealthCheck</literal></simpara>
</listitem>
</itemizedlist>
<section xml:id="machine-api-overview_overview-of-machine-management">
<title>Machine API overview</title>
<simpara>The Machine API is a combination of primary resources that are based on the upstream Cluster API project and custom OpenShift Container Platform resources.</simpara>
<simpara>For OpenShift Container Platform 4.14 clusters, the Machine API performs all node host provisioning management actions after the cluster installation finishes. Because of this system, OpenShift Container Platform 4.14 offers an elastic, dynamic provisioning method on top of public or private cloud infrastructure.</simpara>
<simpara>The two primary resources are:</simpara>
<variablelist>
<varlistentry>
<term>Machines</term>
<listitem>
<simpara>A fundamental unit that describes the host for a node. A machine has a <literal>providerSpec</literal> specification, which describes the types of compute nodes that are offered for different cloud platforms. For example, a machine type for a compute node might define a specific machine type and required metadata.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine sets</term>
<listitem>
<simpara><literal>MachineSet</literal> resources are groups of compute machines. Compute machine sets are to compute machines as replica sets are to pods. If you need more compute machines or must scale them down, you change the <literal>replicas</literal> field on the <literal>MachineSet</literal> resource to meet your compute need.</simpara>
<warning>
<simpara>Control plane machines cannot be managed by compute machine sets.</simpara>
<simpara>Control plane machine sets provide management capabilities for supported control plane machines that are similar to what compute machine sets provide for compute machines.</simpara>
<simpara>For more information, see “Managing control plane machines".</simpara>
</warning>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following custom resources add more capabilities to your cluster:</simpara>
<variablelist>
<varlistentry>
<term>Machine autoscaler</term>
<listitem>
<simpara>The <literal>MachineAutoscaler</literal> resource automatically scales compute machines in a cloud. You can set the minimum and maximum scaling boundaries for nodes in a specified compute machine set, and the machine autoscaler maintains that range of nodes.</simpara>
<simpara>The <literal>MachineAutoscaler</literal> object takes effect after a <literal>ClusterAutoscaler</literal> object exists. Both <literal>ClusterAutoscaler</literal> and <literal>MachineAutoscaler</literal> resources are made available by the <literal>ClusterAutoscalerOperator</literal> object.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cluster autoscaler</term>
<listitem>
<simpara>This resource is based on the upstream cluster autoscaler project. In the OpenShift Container Platform implementation, it is integrated with the Machine API by extending the compute machine set API. You can use the cluster autoscaler to manage your cluster in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Set cluster-wide scaling limits for resources such as cores, nodes, memory, and GPU</simpara>
</listitem>
<listitem>
<simpara>Set the priority so that the cluster prioritizes pods and new nodes are not brought online for less important pods</simpara>
</listitem>
<listitem>
<simpara>Set the scaling policy so that you can scale up nodes but not scale them down</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine health check</term>
<listitem>
<simpara>The <literal>MachineHealthCheck</literal> resource detects when a machine is unhealthy, deletes it, and, on supported platforms, makes a new machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In OpenShift Container Platform version 3.11, you could not roll out a multi-zone architecture easily because the cluster did not manage machine provisioning. Beginning with OpenShift Container Platform version 4.1, this process is easier. Each compute machine set is scoped to a single zone, so the installation program sends out compute machine sets across availability zones on your behalf. And then because your compute is dynamic, and in the face of a zone failure, you always have a zone for when you must rebalance your machines. In global Azure regions that do not have multiple availability zones, you can use availability sets to ensure high availability. The autoscaler provides best-effort balancing over the life of a cluster.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="machine-phases-lifecycle">Machine phases and lifecycle</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-mgmt-intro-managing-compute_overview-of-machine-management">
<title>Managing compute machines</title>
<simpara>As a cluster administrator, you can perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a compute machine set for the following cloud providers:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="creating-machineset-aws">AWS</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-machineset-azure">Azure</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-machineset-gcp">GCP</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-machineset-osp">RHOSP</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-machineset-vsphere">vSphere</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create a machine set for a bare metal deployment: <link linkend="creating-machineset-bare-metal">Creating a compute machine set on bare metal</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="manually-scaling-machineset">Manually scale a compute machine set</link> by adding or removing a machine from the compute machine set.</simpara>
</listitem>
<listitem>
<simpara><link linkend="modifying-machineset">Modify a compute machine set</link> through the <literal>MachineSet</literal> YAML configuration file.</simpara>
</listitem>
<listitem>
<simpara><link linkend="deleting-machine">Delete</link> a machine.</simpara>
</listitem>
<listitem>
<simpara><link linkend="creating-infrastructure-machinesets">Create infrastructure compute machine sets</link>.</simpara>
</listitem>
<listitem>
<simpara>Configure and deploy a <link linkend="deploying-machine-health-checks">machine health check</link> to automatically fix damaged machines in a machine pool.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-mgmt-intro-managing-control-plane_overview-of-machine-management">
<title>Managing control plane machines</title>
<simpara>As a cluster administrator, you can perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="cpmso-feat-config-update_cpmso-using">Update your control plane configuration</link> with a control plane machine set for the following cloud providers:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-aws_cpmso-configuration">AWS</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-gcp_cpmso-configuration">GCP</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-azure_cpmso-configuration">Azure</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-nutanix_cpmso-configuration">Nutanix</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-vsphere_cpmso-configuration">vSphere</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Configure and deploy a <link linkend="deploying-machine-health-checks">machine health check</link> to automatically recover unhealthy control plane machines.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-mgmt-intro-autoscaling_overview-of-machine-management">
<title>Applying autoscaling to an OpenShift Container Platform cluster</title>
<simpara>You can automatically scale your OpenShift Container Platform cluster to ensure flexibility for changing workloads. To <link linkend="applying-autoscaling">autoscale</link> your cluster, you must first deploy a cluster autoscaler, and then deploy a machine autoscaler for each compute machine set.</simpara>
<itemizedlist>
<listitem>
<simpara>The <link linkend="cluster-autoscaler-about_applying-autoscaling"><emphasis>cluster autoscaler</emphasis></link> increases and decreases the size of the cluster based on deployment needs.</simpara>
</listitem>
<listitem>
<simpara>The <link linkend="machine-autoscaler-about_applying-autoscaling"><emphasis>machine autoscaler</emphasis></link> adjusts the number of machines in the compute machine sets that you deploy in your OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-mgmt-intro-add-for-upi_overview-of-machine-management">
<title>Adding compute machines on user-provisioned infrastructure</title>
<simpara>User-provisioned infrastructure is an environment where you can deploy infrastructure such as compute, network, and storage resources that host the OpenShift Container Platform. You can <link linkend="adding-compute-user-infra-general">add compute machines</link> to a cluster on user-provisioned infrastructure during or after the installation process.</simpara>
</section>
<section xml:id="machine-mgmt-intro-add-rhel_overview-of-machine-management">
<title>Adding RHEL compute machines to your cluster</title>
<simpara>As a cluster administrator, you can perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="adding-rhel-compute">Add Red Hat Enterprise Linux (RHEL) compute machines</link>, also known as worker machines, to a user-provisioned infrastructure cluster or an installation-provisioned infrastructure cluster.</simpara>
</listitem>
<listitem>
<simpara><link linkend="more-rhel-compute">Add more Red Hat Enterprise Linux (RHEL) compute machines</link> to an existing cluster.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_managing-compute-machines-with-the-machine-api">
<title>Managing compute machines with the Machine API</title>
<section xml:id="creating-machineset-alibaba">
<title>Creating a compute machine set on Alibaba Cloud</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Alibaba Cloud. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-alibaba_creating-machineset-alibaba">
<title>Sample YAML for a compute machine set custom resource on Alibaba Cloud</title>
<simpara>This sample YAML defines a compute machine set that runs in a specified Alibaba Cloud zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO1-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO1-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO1-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO1-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO1-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO1-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO1-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO1-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO1-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO1-10"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: ""
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1
          credentialsSecret:
            name: alibabacloud-credentials
          imageId: &lt;image_id&gt; <co xml:id="CO1-11"/>
          instanceType: &lt;instance_type&gt; <co xml:id="CO1-12"/>
          kind: AlibabaCloudMachineProviderConfig
          ramRoleName: &lt;infrastructure_id&gt;-role-worker <co xml:id="CO1-13"/>
          regionId: &lt;region&gt; <co xml:id="CO1-14"/>
          resourceGroup: <co xml:id="CO1-15"/>
            id: &lt;resource_group_id&gt;
            type: ID
          securityGroups:
          - tags: <co xml:id="CO1-16"/>
            - Key: Name
              Value: &lt;infrastructure_id&gt;-sg-&lt;role&gt;
            type: Tags
          systemDisk: <co xml:id="CO1-17"/>
            category: cloud_essd
            size: &lt;disk_size&gt;
          tag: <co xml:id="CO1-18"/>
          - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt;
            Value: owned
          userDataSecret:
            name: &lt;user_data_secret&gt; <co xml:id="CO1-19"/>
          vSwitch:
            tags: <co xml:id="CO1-20"/>
            - Key: Name
              Value: &lt;infrastructure_id&gt;-vswitch-&lt;zone&gt;
            type: Tags
          vpcId: ""
          zoneId: &lt;zone&gt; <co xml:id="CO1-21"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1 CO1-5 CO1-7">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO1-2 CO1-3 CO1-8 CO1-9">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO1-4 CO1-6 CO1-10">
<para>Specify the infrastructure ID, node label, and zone.</para>
</callout>
<callout arearefs="CO1-11">
<para>Specify the image to use. Use an image from an existing default compute machine set for the cluster.</para>
</callout>
<callout arearefs="CO1-12">
<para>Specify the instance type you want to use for the compute machine set.</para>
</callout>
<callout arearefs="CO1-13">
<para>Specify the name of the RAM role to use for the compute machine set. Use the value that the installer populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO1-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO1-15">
<para>Specify the resource group and type for the cluster. You can use the value that the installer populates in the default compute machine set, or specify a different one.</para>
</callout>
<callout arearefs="CO1-16 CO1-18 CO1-20">
<para>Specify the tags to use for the compute machine set. Minimally, you must include the tags shown in this example, with appropriate values for your cluster. You can include additional tags, including the tags that the installer populates in the default compute machine set it creates, as needed.</para>
</callout>
<callout arearefs="CO1-17">
<para>Specify the type and size of the root disk. Use the <literal>category</literal> value that the installer populates in the default compute machine set it creates. If required, specify a different value in gigabytes for <literal>size</literal>.</para>
</callout>
<callout arearefs="CO1-19">
<para>Specify the name of the secret in the user data YAML file that is in the <literal>openshift-machine-api</literal> namespace. Use the value that the installer populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO1-21">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
</calloutlist>
<section xml:id="machineset-yaml-alibaba-usage-stats_creating-machineset-alibaba">
<title>Machine set parameters for Alibaba Cloud usage statistics</title>
<simpara>The default compute machine sets that the installer creates for Alibaba Cloud clusters include nonessential tag values that Alibaba Cloud uses internally to track usage statistics. These tags are populated in the <literal>securityGroups</literal>, <literal>tag</literal>, and <literal>vSwitch</literal> parameters of the <literal>spec.template.spec.providerSpec.value</literal> list.</simpara>
<simpara>When creating compute machine sets to deploy additional machines, you must include the required Kubernetes tags. The usage statistics tags are applied by default, even if they are not specified in the compute machine sets you create. You can also include additional tags as needed.</simpara>
<simpara>The following YAML snippets indicate which tags in the default compute machine sets are optional and which are required.</simpara>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.securityGroups</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          securityGroups:
          - tags:
            - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO2-1"/>
              Value: owned
            - Key: GISV
              Value: ocp
            - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO2-2"/>
              Value: ocp
            - Key: Name
              Value: &lt;infrastructure_id&gt;-sg-&lt;role&gt; <co xml:id="CO2-3"/>
            type: Tags</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1 CO2-2">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO2-3">
<para>Required.</para>
<simpara>where:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;role&gt;</literal> is the node label to add.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.tag</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          tag:
          - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO3-1"/>
            Value: owned
          - Key: GISV <co xml:id="CO3-2"/>
            Value: ocp
          - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO3-3"/>
            Value: ocp</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-2 CO3-3">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO3-1">
<para>Required.</para>
<simpara>where <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</callout>
</calloutlist>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.vSwitch</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          vSwitch:
            tags:
            - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO4-1"/>
              Value: owned
            - Key: GISV <co xml:id="CO4-2"/>
              Value: ocp
            - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO4-3"/>
              Value: ocp
            - Key: Name
              Value: &lt;infrastructure_id&gt;-vswitch-&lt;zone&gt; <co xml:id="CO4-4"/>
            type: Tags</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1 CO4-2 CO4-3">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO4-4">
<para>Required.</para>
<simpara>where:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;zone&gt;</literal> is the zone within your region to place machines on.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="machineset-creating_creating-machineset-alibaba">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO5-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO5-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO5-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO5-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO5-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-aws">
<title>Creating a compute machine set on AWS</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Amazon Web Services (AWS). For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-aws_creating-machineset-aws">
<title>Sample YAML for a compute machine set custom resource on AWS</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>us-east-1a</literal> Amazon Web Services (AWS) zone and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO6-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO6-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO6-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO6-4"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO6-5"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO6-6"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO6-7"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO6-8"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: "" <co xml:id="CO6-9"/>
      providerSpec:
        value:
          ami:
            id: ami-046fe691f52a953f9 <co xml:id="CO6-10"/>
          apiVersion: machine.openshift.io/v1beta1
          blockDevices:
            - ebs:
                iops: 0
                volumeSize: 120
                volumeType: gp2
          credentialsSecret:
            name: aws-cloud-credentials
          deviceIndex: 0
          iamInstanceProfile:
            id: &lt;infrastructure_id&gt;-worker-profile <co xml:id="CO6-11"/>
          instanceType: m6i.large
          kind: AWSMachineProviderConfig
          placement:
            availabilityZone: &lt;zone&gt; <co xml:id="CO6-12"/>
            region: &lt;region&gt; <co xml:id="CO6-13"/>
          securityGroups:
            - filters:
                - name: tag:Name
                  values:
                    - &lt;infrastructure_id&gt;-worker-sg <co xml:id="CO6-14"/>
          subnet:
            filters:
              - name: tag:Name
                values:
                  - &lt;infrastructure_id&gt;-private-&lt;zone&gt; <co xml:id="CO6-15"/>
          tags:
            - name: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO6-16"/>
              value: owned
            - name: &lt;custom_tag_name&gt; <co xml:id="CO6-17"/>
              value: &lt;custom_tag_value&gt; <co xml:id="CO6-18"/>
          userDataSecret:
            name: worker-user-data</programlisting>
<calloutlist>
<callout arearefs="CO6-1 CO6-3 CO6-5 CO6-11 CO6-14 CO6-16">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO6-2 CO6-4 CO6-8">
<para>Specify the infrastructure ID, role node label, and zone.</para>
</callout>
<callout arearefs="CO6-6 CO6-7 CO6-9">
<para>Specify the role node label to add.</para>
</callout>
<callout arearefs="CO6-10">
<para>Specify a valid Red Hat Enterprise Linux CoreOS (RHCOS) Amazon
Machine Image (AMI) for your AWS zone for your OpenShift Container Platform nodes. If you want to use an AWS Marketplace image, you must complete the OpenShift Container Platform subscription from the <link xlink:href="https://aws.amazon.com/marketplace/fulfillment?productId=59ead7de-2540-4653-a8b0-fa7926d5c845">AWS Marketplace</link> to obtain an AMI ID for your region.</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.ami.id}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt;</programlisting>
</callout>
<callout arearefs="CO6-17 CO6-18">
<para>Optional: Specify custom tag data for your cluster. For example, you might add an admin contact email address by specifying a <literal>name:value</literal> pair of <literal>Email:admin-email@example.com</literal>.</para>
<note>
<simpara>Custom tags can also be specified during installation in the <literal>install-config.yml</literal> file. If the <literal>install-config.yml</literal> file and the machine set include a tag with the same <literal>name</literal> data, the value for the tag from the machine set takes priority over the value for the tag in the <literal>install-config.yml</literal> file.</simpara>
</note>
</callout>
<callout arearefs="CO6-12">
<para>Specify the zone, for example, <literal>us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO6-13">
<para>Specify the region, for example, <literal>us-east-1</literal>.</para>
</callout>
<callout arearefs="CO6-15">
<para>Specify the infrastructure ID and zone.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-aws">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO7-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO7-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO7-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO7-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO7-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>If you need compute machine sets in other availability zones, repeat this process to create more compute machine sets.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-aws-existing-placement-group_creating-machineset-aws">
<title>Assigning machines to placement groups for Elastic Fabric Adapter instances by using machine sets</title>
<simpara>You can configure a machine set to deploy machines on <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</link> (EFA) instances within an existing AWS placement group.</simpara>
<simpara>EFA instances do not require placement groups, and you can use placement groups for purposes other than configuring an EFA. This example uses both to demonstrate a configuration that can improve network performance for machines within the specified placement group.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You created a placement group in the AWS console.</simpara>
<note>
<simpara>Ensure that the <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html#limitations-placement-groups">rules and limitations</link> for the type of placement group that you create are compatible with your intended use case.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following lines under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          instanceType: &lt;supported_instance_type&gt; <co xml:id="CO8-1"/>
          networkInterfaceType: EFA <co xml:id="CO8-2"/>
          placement:
            availabilityZone: &lt;zone&gt; <co xml:id="CO8-3"/>
            region: &lt;region&gt; <co xml:id="CO8-4"/>
          placementGroupName: &lt;placement_group&gt; <co xml:id="CO8-5"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Specify an instance type that <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html#efa-instance-types">supports EFAs</link>.</para>
</callout>
<callout arearefs="CO8-2">
<para>Specify the <literal>EFA</literal> network interface type.</para>
</callout>
<callout arearefs="CO8-3">
<para>Specify the zone, for example, <literal>us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO8-4">
<para>Specify the region, for example, <literal>us-east-1</literal>.</para>
</callout>
<callout arearefs="CO8-5">
<para>Specify the name of the existing AWS placement group to deploy machines in.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>In the AWS console, find a machine that the machine set created and verify the following in the machine properties:</simpara>
<itemizedlist>
<listitem>
<simpara>The placement group field has the value that you specified for the <literal>placementGroupName</literal> parameter in the machine set.</simpara>
</listitem>
<listitem>
<simpara>The interface type field indicates that it uses an EFA.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-imds-options_creating-machineset-aws">
<title>Machine set options for the Amazon EC2 Instance Metadata Service</title>
<simpara>You can use machine sets to create machines that use a specific version of the Amazon EC2 Instance Metadata Service (IMDS). Machine sets can create machines that allow the use of both IMDSv1 and <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html">IMDSv2</link> or machines that require the use of IMDSv2.</simpara>
<note>
<simpara>Using IMDSv2 is only supported on AWS clusters that were created with OpenShift Container Platform version 4.7 or later.</simpara>
</note>
<simpara>To change the IMDS configuration for existing machines, edit the machine set YAML file that manages those machines.
To deploy new compute machines with your preferred IMDS configuration, create a compute machine set YAML file with the appropriate values.</simpara>
<important>
<simpara>Before configuring a machine set to create machines that require IMDSv2, ensure that any workloads that interact with the AWS metadata service support IMDSv2.</simpara>
</important>
<section xml:id="machineset-creating-imds-options_creating-machineset-aws">
<title>Configuring IMDS by using machine sets</title>
<simpara>You can specify whether to require the use of IMDSv2 by adding or editing the value of <literal>metadataServiceOptions.authentication</literal> in the machine set YAML file for your machines.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>To use IMDSv2, your AWS cluster must have been created with OpenShift Container Platform version 4.7 or later.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add or edit the following lines under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    metadataServiceOptions:
      authentication: Required <co xml:id="CO9-1"/></programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>To require IMDSv2, set the parameter value to <literal>Required</literal>. To allow the use of both IMDSv1 and IMDSv2, set the parameter value to <literal>Optional</literal>. If no value is specified, both IMDSv1 and IMDSv2 are allowed.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machineset-dedicated-instance_creating-machineset-aws">
<title>Machine sets that deploy machines as Dedicated Instances</title>
<simpara>You can create a machine set running on AWS that deploys machines as Dedicated Instances. Dedicated Instances run in a virtual private cloud (VPC) on hardware that is dedicated to a single customer. These Amazon EC2 instances are physically isolated at the host hardware level. The isolation of Dedicated Instances occurs even if the instances belong to different AWS accounts that are linked to a single payer account. However, other instances that are not dedicated can share hardware with Dedicated Instances if they belong to the same AWS account.</simpara>
<simpara>Instances with either public or dedicated tenancy are supported by the Machine API. Instances with public tenancy run on shared hardware. Public tenancy is the default tenancy. Instances with dedicated tenancy run on single-tenant hardware.</simpara>
<section xml:id="machineset-creating-dedicated-instance_creating-machineset-aws">
<title>Creating Dedicated Instances by using machine sets</title>
<simpara>You can run a machine that is backed by a Dedicated Instance by using Machine API integration. Set the <literal>tenancy</literal> field in your machine set YAML file to launch a Dedicated Instance on AWS.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Specify a dedicated tenancy under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  placement:
    tenancy: dedicated</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machineset-non-guaranteed-instance_creating-machineset-aws">
<title>Machine sets that deploy machines as Spot Instances</title>
<simpara>You can save on costs by creating a compute machine set running on AWS that deploys machines as non-guaranteed Spot Instances. Spot Instances utilize unused AWS EC2 capacity and are less expensive than On-Demand Instances. You can use Spot Instances for workloads that can tolerate interruptions, such as batch or stateless, horizontally scalable workloads.</simpara>
<simpara>AWS EC2 can terminate a Spot Instance at any time. AWS gives a two-minute warning to the user when an interruption occurs. OpenShift Container Platform begins to remove the workloads from the affected instances when AWS issues the termination warning.</simpara>
<simpara>Interruptions can occur when using Spot Instances for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>The instance price exceeds your maximum price</simpara>
</listitem>
<listitem>
<simpara>The demand for Spot Instances increases</simpara>
</listitem>
<listitem>
<simpara>The supply of Spot Instances decreases</simpara>
</listitem>
</itemizedlist>
<simpara>When AWS terminates an instance, a termination handler running on the Spot Instance node deletes the machine resource. To satisfy the compute machine set <literal>replicas</literal> quantity, the compute machine set creates a machine that requests a Spot Instance.</simpara>
<section xml:id="machineset-creating-non-guaranteed-instance_creating-machineset-aws">
<title>Creating Spot Instances by using compute machine sets</title>
<simpara>You can launch a Spot Instance on AWS by adding <literal>spotMarketOptions</literal> to your compute machine set YAML file.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    spotMarketOptions: {}</programlisting>
<simpara>You can optionally set the <literal>spotMarketOptions.maxPrice</literal> field to limit the cost of the Spot Instance. For example you can set <literal>maxPrice: '2.50'</literal>.</simpara>
<simpara>If the <literal>maxPrice</literal> is set, this value is used as the hourly maximum spot price. If it is not set, the maximum price defaults to charge up to the On-Demand Instance price.</simpara>
<note>
<simpara>It is strongly recommended to use the default On-Demand price as the <literal>maxPrice</literal> value and to not set the maximum price for Spot Instances.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nvidia-gpu-aws-adding-a-gpu-node_creating-machineset-aws">
<title>Adding a GPU node to an existing OpenShift Container Platform cluster</title>
<simpara>You can copy and modify a default compute machine set configuration to create a GPU-enabled machine set and machines for the AWS EC2 cloud provider.</simpara>
<simpara>For more information about the supported instance types, see the following NVIDIA documentation:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/platform-support.html">NVIDIA GPU Operator Community support matrix</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.nvidia.com/ai-enterprise/latest/product-support-matrix/index.html">NVIDIA AI Enterprise support matrix</link></simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the existing nodes, machines, and machine sets  by running the following command. Note that each node is an instance of a machine definition with a specific AWS region and OpenShift Container Platform role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                        STATUS   ROLES                  AGE     VERSION
ip-10-0-52-50.us-east-2.compute.internal    Ready    worker                 3d17h   v1.28.5
ip-10-0-58-24.us-east-2.compute.internal    Ready    control-plane,master   3d17h   v1.28.5
ip-10-0-68-148.us-east-2.compute.internal   Ready    worker                 3d17h   v1.28.5
ip-10-0-68-68.us-east-2.compute.internal    Ready    control-plane,master   3d17h   v1.28.5
ip-10-0-72-170.us-east-2.compute.internal   Ready    control-plane,master   3d17h   v1.28.5
ip-10-0-74-50.us-east-2.compute.internal    Ready    worker                 3d17h   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines and machine sets that exist in the <literal>openshift-machine-api</literal> namespace by running the following command. Each compute machine set is associated with a different availability zone within the AWS region. The installer automatically load balances compute machines across availability zones.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                        DESIRED   CURRENT   READY   AVAILABLE   AGE
preserve-dsoc12r4-ktjfc-worker-us-east-2a   1         1         1       1           3d11h
preserve-dsoc12r4-ktjfc-worker-us-east-2b   2         2         2       2           3d11h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines that exist in the <literal>openshift-machine-api</literal> namespace by running the following command. At this time, there is only one compute machine per machine set, though a compute machine set could be scaled to add a node in a particular region and zone.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines -n openshift-machine-api | grep worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">preserve-dsoc12r4-ktjfc-worker-us-east-2a-dts8r      Running   m5.xlarge   us-east-2   us-east-2a   3d11h
preserve-dsoc12r4-ktjfc-worker-us-east-2b-dkv7w      Running   m5.xlarge   us-east-2   us-east-2b   3d11h
preserve-dsoc12r4-ktjfc-worker-us-east-2b-k58cw      Running   m5.xlarge   us-east-2   us-east-2b   3d11h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Make a copy of one of the existing compute <literal>MachineSet</literal> definitions and output the result to a JSON file by running the following command. This will be the basis for the GPU-enabled compute machine set definition.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset preserve-dsoc12r4-ktjfc-worker-us-east-2a -n openshift-machine-api -o json &gt; &lt;output_file.json&gt;</programlisting>
</listitem>
<listitem>
<simpara>Edit the JSON file and make the following changes to the new <literal>MachineSet</literal> definition:</simpara>
<itemizedlist>
<listitem>
<simpara>Replace <literal>worker</literal> with <literal>gpu</literal>. This will be the name of the new machine set.</simpara>
</listitem>
<listitem>
<simpara>Change the instance type of the new <literal>MachineSet</literal> definition to <literal>g4dn</literal>, which includes an NVIDIA Tesla T4 GPU.
To learn more about AWS <literal>g4dn</literal> instance types, see <link xlink:href="https://aws.amazon.com/ec2/instance-types/#Accelerated_Computing">Accelerated Computing</link>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq .spec.template.spec.providerSpec.value.instanceType preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a.json

"g4dn.xlarge"</programlisting>
<simpara>The <literal>&lt;output_file.json&gt;</literal> file is saved as <literal>preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a.json</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Update the following fields in <literal>preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a.json</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>.metadata.name</literal> to a name containing <literal>gpu</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>.spec.selector.matchLabels["machine.openshift.io/cluster-api-machineset"]</literal> to
match the new <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>.spec.template.metadata.labels["machine.openshift.io/cluster-api-machineset"]</literal>
to match the new <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>.spec.template.spec.providerSpec.value.instanceType</literal> to <literal>g4dn.xlarge</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To verify your changes, perform a <literal>diff</literal> of the original compute definition and the new GPU-enabled node definition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get preserve-dsoc12r4-ktjfc-worker-us-east-2a -o json | diff preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a.json -</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">10c10

&lt; "name": "preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a",
---
&gt; "name": "preserve-dsoc12r4-ktjfc-worker-us-east-2a",

21c21

&lt; "machine.openshift.io/cluster-api-machineset": "preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a"
---
&gt; "machine.openshift.io/cluster-api-machineset": "preserve-dsoc12r4-ktjfc-worker-us-east-2a"

31c31

&lt; "machine.openshift.io/cluster-api-machineset": "preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a"
---
&gt; "machine.openshift.io/cluster-api-machineset": "preserve-dsoc12r4-ktjfc-worker-us-east-2a"

60c60

&lt; "instanceType": "g4dn.xlarge",
---
&gt; "instanceType": "m5.xlarge",</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the GPU-enabled compute machine set from the definition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a.json</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineset.machine.openshift.io/preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the machine set you created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get machinesets | grep gpu</programlisting>
<simpara>The MachineSet replica count is set to <literal>1</literal> so a new <literal>Machine</literal> object is created automatically.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a   1         1         1       1           4m21s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the <literal>Machine</literal> object that the machine set created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get machines | grep gpu</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">preserve-dsoc12r4-ktjfc-worker-gpu-us-east-2a    running    g4dn.xlarge   us-east-2   us-east-2a  4m36s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>Note that there is no need to specify a namespace for the node. The node definition is cluster scoped.</simpara>
</section>
<section xml:id="nvidia-gpu-aws-deploying-the-node-feature-discovery-operator_creating-machineset-aws">
<title>Deploying the Node Feature Discovery Operator</title>
<simpara>After the GPU-enabled node is created, you need to discover the GPU-enabled node so it can be scheduled. To do this, install the Node Feature Discovery (NFD) Operator. The NFD Operator identifies hardware device features in nodes. It solves the general problem of identifying and cataloging hardware resources in the infrastructure nodes so they can be made available to OpenShift Container Platform.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Node Feature Discovery Operator from <emphasis role="strong">OperatorHub</emphasis> in the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>After installing the NFD Operator into <emphasis role="strong">OperatorHub</emphasis>, select <emphasis role="strong">Node Feature Discovery</emphasis> from the installed Operators list and select <emphasis role="strong">Create instance</emphasis>. This installs the <literal>nfd-master</literal> and <literal>nfd-worker</literal> pods, one <literal>nfd-worker</literal> pod for each compute node, in the <literal>openshift-nfd</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that the Operator is installed and running by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY    STATUS     RESTARTS   AGE

nfd-controller-manager-8646fcbb65-x5qgk    2/2      Running 7  (8h ago)   1d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Browse to the installed Oerator in the console and select <emphasis role="strong">Create Node Feature Discovery</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis> to build a NFD custom resource. This creates NFD pods in the <literal>openshift-nfd</literal> namespace that poll the OpenShift Container Platform nodes for hardware resources and catalogue them.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After a successful build, verify that a NFD pod is running on each nodes by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY   STATUS      RESTARTS        AGE
nfd-controller-manager-8646fcbb65-x5qgk    2/2     Running     7 (8h ago)      12d
nfd-master-769656c4cb-w9vrv                1/1     Running     0               12d
nfd-worker-qjxb2                           1/1     Running     3 (3d14h ago)   12d
nfd-worker-xtz9b                           1/1     Running     5 (3d14h ago)   12d</programlisting>
</para>
</formalpara>
<simpara>The NFD Operator uses vendor PCI IDs to identify hardware in a node. NVIDIA uses the PCI ID <literal>10de</literal>.</simpara>
</listitem>
<listitem>
<simpara>View the NVIDIA GPU discovered by the NFD Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node ip-10-0-132-138.us-east-2.compute.internal | egrep 'Roles|pci'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Roles: worker

feature.node.kubernetes.io/pci-1013.present=true

feature.node.kubernetes.io/pci-10de.present=true

feature.node.kubernetes.io/pci-1d0f.present=true</programlisting>
</para>
</formalpara>
<simpara><literal>10de</literal> appears in the node feature list for the GPU-enabled node. This mean the NFD Operator correctly identified the node from the GPU-enabled MachineSet.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="creating-machineset-azure">
<title>Creating a compute machine set on Azure</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Microsoft Azure. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-azure_creating-machineset-azure">
<title>Sample YAML for a compute machine set custom resource on Azure</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>1</literal> Microsoft Azure zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO10-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO10-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO10-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO10-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO10-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO10-6"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO10-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO10-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO10-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO10-10"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          machine.openshift.io/cluster-api-machineset: &lt;machineset_name&gt;
          node-role.kubernetes.io/&lt;role&gt;: "" <co xml:id="CO10-11"/>
      providerSpec:
        value:
          apiVersion: azureproviderconfig.openshift.io/v1beta1
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          image: <co xml:id="CO10-12"/>
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/&lt;infrastructure_id&gt;-rg/providers/Microsoft.Compute/images/&lt;infrastructure_id&gt; <co xml:id="CO10-13"/>
            sku: ""
            version: ""
          internalLoadBalancer: ""
          kind: AzureMachineProviderSpec
          location: &lt;region&gt; <co xml:id="CO10-14"/>
          managedIdentity: &lt;infrastructure_id&gt;-identity <co xml:id="CO10-15"/>
          metadata:
            creationTimestamp: null
          natRule: null
          networkResourceGroup: ""
          osDisk:
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: ""
          resourceGroup: &lt;infrastructure_id&gt;-rg <co xml:id="CO10-16"/>
          sshPrivateKey: ""
          sshPublicKey: ""
          tags:
            - name: &lt;custom_tag_name&gt; <co xml:id="CO10-17"/>
              value: &lt;custom_tag_value&gt; <co xml:id="CO10-18"/>
          subnet: &lt;infrastructure_id&gt;-&lt;role&gt;-subnet <co xml:id="CO10-19"/> <co xml:id="CO10-20"/>
          userDataSecret:
            name: worker-user-data <co xml:id="CO10-21"/>
          vmSize: Standard_D4s_v3
          vnet: &lt;infrastructure_id&gt;-vnet <co xml:id="CO10-22"/>
          zone: "1" <co xml:id="CO10-23"/></programlisting>
<calloutlist>
<callout arearefs="CO10-1 CO10-5 CO10-7 CO10-15 CO10-16 CO10-19 CO10-22">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<simpara>You can obtain the subnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.subnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
<simpara>You can obtain the vnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.vnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
</callout>
<callout arearefs="CO10-2 CO10-3 CO10-8 CO10-9 CO10-11 CO10-20 CO10-21">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO10-4 CO10-6 CO10-10">
<para>Specify the infrastructure ID, node label, and region.</para>
</callout>
<callout arearefs="CO10-12">
<para>Specify the image details for your compute machine set. If you want to use an Azure Marketplace image, see "Selecting an Azure Marketplace image".</para>
</callout>
<callout arearefs="CO10-13">
<para>Specify an image that is compatible with your instance type. The Hyper-V generation V2 images created by the installation program have a <literal>-gen2</literal> suffix, while V1 images have the same name without the suffix.</para>
</callout>
<callout arearefs="CO10-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO10-23">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO10-17 CO10-18">
<para>Optional: Specify custom tags in your machine set. Provide the tag name in <literal>&lt;custom_tag_name&gt;</literal> field and the corresponding tag value in <literal>&lt;custom_tag_value&gt;</literal> field.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-azure">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO11-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO11-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO11-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO11-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO11-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO11-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-azure-marketplace-subscribe_creating-machineset-azure">
<title>Using the Azure Marketplace offering</title>
<simpara>You can create a machine set running on Azure that deploys machines that use the Azure Marketplace offering. To use this offering, you must first obtain the Azure Marketplace image. When obtaining your image, consider the following:</simpara>
<itemizedlist>
<listitem>
<simpara>While the images are the same, the Azure Marketplace publisher is different depending on your region. If you are located in North America, specify <literal>redhat</literal> as the publisher. If you are located in EMEA, specify <literal>redhat-limited</literal> as the publisher.</simpara>
</listitem>
<listitem>
<simpara>The offer includes a <literal>rh-ocp-worker</literal> SKU and a <literal>rh-ocp-worker-gen1</literal> SKU. The <literal>rh-ocp-worker</literal> SKU represents a Hyper-V generation version 2 VM image. The default instance types used in OpenShift Container Platform are version 2 compatible. If you plan to use an instance type that is only version 1 compatible, use the image associated with the <literal>rh-ocp-worker-gen1</literal> SKU. The <literal>rh-ocp-worker-gen1</literal> SKU represents a Hyper-V version 1 VM image.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Installing images with the Azure marketplace is not supported on clusters with 64-bit ARM instances.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Azure CLI client <literal>(az)</literal>.</simpara>
</listitem>
<listitem>
<simpara>Your Azure account is entitled for the offer and you have logged into this account with the Azure CLI client.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Display all of the available OpenShift Container Platform images by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  az vm image list --all --offer rh-ocp-worker --publisher redhat -o table</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Offer          Publisher       Sku                 Urn                                                             Version
-------------  --------------  ------------------  --------------------------------------------------------------  -----------------
rh-ocp-worker  RedHat          rh-ocp-worker       RedHat:rh-ocp-worker:rh-ocp-worker:413.92.2023101700            413.92.2023101700
rh-ocp-worker  RedHat          rh-ocp-worker-gen1  RedHat:rh-ocp-worker:rh-ocp-worker-gen1:413.92.2023101700       413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  az vm image list --all --offer rh-ocp-worker --publisher redhat-limited -o table</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Offer          Publisher       Sku                 Urn                                                                     Version
-------------  --------------  ------------------  --------------------------------------------------------------          -----------------
rh-ocp-worker  redhat-limited  rh-ocp-worker       redhat-limited:rh-ocp-worker:rh-ocp-worker:413.92.2023101700            413.92.2023101700
rh-ocp-worker  redhat-limited  rh-ocp-worker-gen1  redhat-limited:rh-ocp-worker:rh-ocp-worker-gen1:413.92.2023101700       413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<note>
<simpara>Regardless of the version of OpenShift Container Platform that you install, the correct version of the Azure Marketplace image to use is 4.13. If required, your VMs are automatically upgraded as part of the installation process.</simpara>
</note>
</listitem>
<listitem>
<simpara>Inspect the image for your offer by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image show --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image show --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Review the terms of the offer by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms show --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms show --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Accept the terms of the offering by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms accept --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms accept --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Record the image details of your offer, specifically the values for <literal>publisher</literal>, <literal>offer</literal>, <literal>sku</literal>, and <literal>version</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the following parameters to the <literal>providerSpec</literal> section of your machine set YAML file using the image details for your offer:</simpara>
<formalpara>
<title>Sample <literal>providerSpec</literal> image values for Azure Marketplace machines</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    image:
      offer: rh-ocp-worker
      publisher: redhat
      resourceID: ""
      sku: rh-ocp-worker
      type: MarketplaceWithPlan
      version: 413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machineset-azure-boot-diagnostics_creating-machineset-azure">
<title>Enabling Azure boot diagnostics</title>
<simpara>You can enable boot diagnostics on Azure machines that your machine set creates.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure
cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>diagnostics</literal> configuration that is applicable to your storage type to the <literal>providerSpec</literal> field in your machine set YAML file:</simpara>
<itemizedlist>
<listitem>
<simpara>For an Azure Managed storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: AzureManaged <co xml:id="CO12-1"/></programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>Specifies an Azure Managed storage account.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>For an Azure Unmanaged storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: CustomerManaged <co xml:id="CO13-1"/>
      customerManaged:
        storageAccountURI: https://&lt;storage-account&gt;.blob.core.windows.net <co xml:id="CO13-2"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Specifies an Azure Unmanaged storage account.</para>
</callout>
<callout arearefs="CO13-2">
<para>Replace <literal>&lt;storage-account&gt;</literal> with the name of your storage account.</para>
</callout>
</calloutlist>
<note>
<simpara>Only the Azure Blob Storage data service is supported.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Boot diagnostics</emphasis> page for a machine deployed by the machine set, and verify that you can see the serial logs for the machine.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-non-guaranteed-instance_creating-machineset-azure">
<title>Machine sets that deploy machines as Spot VMs</title>
<simpara>You can save on costs by creating a compute machine set running on Azure that deploys machines as non-guaranteed Spot VMs. Spot VMs utilize unused Azure capacity and are less expensive than standard VMs. You can use Spot VMs for workloads that can tolerate interruptions, such as batch or stateless, horizontally scalable workloads.</simpara>
<simpara>Azure can terminate a Spot VM at any time. Azure gives a 30-second warning to the user when an interruption occurs. OpenShift Container Platform begins to remove the workloads from the affected instances when Azure issues the termination warning.</simpara>
<simpara>Interruptions can occur when using Spot VMs for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>The instance price exceeds your maximum price</simpara>
</listitem>
<listitem>
<simpara>The supply of Spot VMs decreases</simpara>
</listitem>
<listitem>
<simpara>Azure needs capacity back</simpara>
</listitem>
</itemizedlist>
<simpara>When Azure terminates an instance, a termination handler running on the Spot VM node deletes the machine resource. To satisfy the compute machine set <literal>replicas</literal> quantity, the compute machine set creates a machine that requests a Spot VM.</simpara>
<section xml:id="machineset-creating-non-guaranteed-instance_creating-machineset-azure">
<title>Creating Spot VMs by using compute machine sets</title>
<simpara>You can launch a Spot VM on Azure by adding <literal>spotVMOptions</literal> to your compute machine set YAML file.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    spotVMOptions: {}</programlisting>
<simpara>You can optionally set the <literal>spotVMOptions.maxPrice</literal> field to limit the cost of the Spot VM. For example you can set <literal>maxPrice: '0.98765'</literal>. If the <literal>maxPrice</literal> is set, this value is used as the hourly maximum spot price. If it is not set, the maximum price defaults to <literal>-1</literal> and charges up to the standard VM price.</simpara>
<simpara>Azure caps Spot VM prices at the standard price. Azure will not evict an instance due to pricing if the instance is set with the default <literal>maxPrice</literal>. However, an instance can still be evicted due to capacity restrictions.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>It is strongly recommended to use the default standard VM price as the <literal>maxPrice</literal> value and to not set the maximum price for Spot VMs.</simpara>
</note>
</section>
</section>
<section xml:id="machineset-azure-ephemeral-os_creating-machineset-azure">
<title>Machine sets that deploy machines on Ephemeral OS disks</title>
<simpara>You can create a compute machine set running on Azure that deploys machines on Ephemeral OS disks. Ephemeral OS disks use local VM capacity rather than remote Azure Storage. This configuration therefore incurs no additional cost and provides lower latency for reading, writing, and reimaging.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information, see the Microsoft Azure documentation about <link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/ephemeral-os-disks">Ephemeral OS disks for Azure VMs</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-creating-azure-ephemeral-os_creating-machineset-azure">
<title>Creating machines on Ephemeral OS disks by using compute machine sets</title>
<simpara>You can launch machines on Ephemeral OS disks on Azure by editing your compute machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the custom resource (CR) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine-set-name&gt;</programlisting>
<simpara>where <literal>&lt;machine-set-name&gt;</literal> is the compute machine set that you want to provision machines on Ephemeral OS disks.</simpara>
</listitem>
<listitem>
<simpara>Add the following to the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    ...
    osDisk:
       ...
       diskSettings: <co xml:id="CO14-1"/>
         ephemeralStorageLocation: Local <co xml:id="CO14-2"/>
       cachingType: ReadOnly <co xml:id="CO14-3"/>
       managedDisk:
         storageAccountType: Standard_LRS <co xml:id="CO14-4"/>
       ...</programlisting>
<calloutlist>
<callout arearefs="CO14-1 CO14-2 CO14-3">
<para>These lines enable the use of Ephemeral OS disks.</para>
</callout>
<callout arearefs="CO14-4">
<para>Ephemeral OS disks are only supported for VMs or scale set instances that use the Standard LRS storage account type.</para>
</callout>
</calloutlist>
<important>
<simpara>The implementation of Ephemeral OS disk support in OpenShift Container Platform only supports the <literal>CacheDisk</literal> placement type. Do not change the <literal>placement</literal> configuration setting.</simpara>
</important>
</listitem>
<listitem>
<simpara>Create a compute machine set using the updated configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine-set-config&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Overview</emphasis> page for a machine deployed by the compute machine set, and verify that the <literal>Ephemeral OS disk</literal> field is set to <literal>OS cache placement</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machineset-azure-ultra-disk_creating-machineset-azure">
<title>Machine sets that deploy machines with ultra disks as data disks</title>
<simpara>You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.</simpara>
<simpara>You can also create a persistent volume claim (PVC) that dynamically binds to a storage class backed by Azure ultra disks and mounts them to pods.</simpara>
<note>
<simpara>Data disks do not support the ability to specify disk throughput or disk IOPS. You can configure these properties by using PVCs.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/storage/#machineset-azure-ultra-disk_persistent-storage-csi-azure">Machine sets that deploy machines on ultra disks using CSI PVCs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/storage/#machineset-azure-ultra-disk_persistent-storage-azure">Machine sets that deploy machines on ultra disks using in-tree PVCs</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-creating-azure-ultra-disk_creating-machineset-azure">
<title>Creating machines with ultra disks by using machine sets</title>
<simpara>You can deploy machines with ultra disks on Azure by editing your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom secret in the <literal>openshift-machine-api</literal> namespace using the <literal>worker</literal> data secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
get secret &lt;role&gt;-user-data \ <co xml:id="CO15-1"/>
--template='{{index .data.userData | base64decode}}' | jq &gt; userData.txt <co xml:id="CO15-2"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Replace <literal>&lt;role&gt;</literal> with <literal>worker</literal>.</para>
</callout>
<callout arearefs="CO15-2">
<para>Specify <literal>userData.txt</literal> as the name of the new custom secret.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>In a text editor, open the <literal>userData.txt</literal> file and locate the final <literal>}</literal> character in the file.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the immediately preceding line, add a <literal>,</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create a new line after the <literal>,</literal> and add the following configuration details:</simpara>
<programlisting language="json" linenumbering="unnumbered">"storage": {
  "disks": [ <co xml:id="CO16-1"/>
    {
      "device": "/dev/disk/azure/scsi1/lun0", <co xml:id="CO16-2"/>
      "partitions": [ <co xml:id="CO16-3"/>
        {
          "label": "lun0p1", <co xml:id="CO16-4"/>
          "sizeMiB": 1024, <co xml:id="CO16-5"/>
          "startMiB": 0
        }
      ]
    }
  ],
  "filesystems": [ <co xml:id="CO16-6"/>
    {
      "device": "/dev/disk/by-partlabel/lun0p1",
      "format": "xfs",
      "path": "/var/lib/lun0p1"
    }
  ]
},
"systemd": {
  "units": [ <co xml:id="CO16-7"/>
    {
      "contents": "[Unit]\nBefore=local-fs.target\n[Mount]\nWhere=/var/lib/lun0p1\nWhat=/dev/disk/by-partlabel/lun0p1\nOptions=defaults,pquota\n[Install]\nWantedBy=local-fs.target\n", <co xml:id="CO16-8"/>
      "enabled": true,
      "name": "var-lib-lun0p1.mount"
    }
  ]
}</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>The configuration details for the disk that you want to attach to a node as an ultra disk.</para>
</callout>
<callout arearefs="CO16-2">
<para>Specify the <literal>lun</literal> value that is defined in the <literal>dataDisks</literal> stanza of the machine set you are using. For example, if the machine set contains <literal>lun: 0</literal>, specify <literal>lun0</literal>. You can initialize multiple data disks by specifying multiple <literal>"disks"</literal> entries in this configuration file. If you specify multiple <literal>"disks"</literal> entries, ensure that the <literal>lun</literal> value for each matches the value in the machine set.</para>
</callout>
<callout arearefs="CO16-3">
<para>The configuration details for a new partition on the disk.</para>
</callout>
<callout arearefs="CO16-4">
<para>Specify a label for the partition. You might find it helpful to use hierarchical names, such as <literal>lun0p1</literal> for the first partition of <literal>lun0</literal>.</para>
</callout>
<callout arearefs="CO16-5">
<para>Specify the total size in MiB of the partition.</para>
</callout>
<callout arearefs="CO16-6">
<para>Specify the filesystem to use when formatting a partition. Use the partition label to specify the partition.</para>
</callout>
<callout arearefs="CO16-7">
<para>Specify a <literal>systemd</literal> unit to mount the partition at boot. Use the partition label to specify the partition. You can create multiple partitions by specifying multiple <literal>"partitions"</literal> entries in this configuration file. If you specify multiple <literal>"partitions"</literal> entries, you must specify a <literal>systemd</literal> unit for each.</para>
</callout>
<callout arearefs="CO16-8">
<para>For <literal>Where</literal>, specify the value of <literal>storage.filesystems.path</literal>. For <literal>What</literal>, specify the value of <literal>storage.filesystems.device</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Extract the disabling template value to a file called <literal>disableTemplating.txt</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get secret &lt;role&gt;-user-data \ <co xml:id="CO17-1"/>
--template='{{index .data.disableTemplating | base64decode}}' | jq &gt; disableTemplating.txt</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>Replace <literal>&lt;role&gt;</literal> with <literal>worker</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Combine the <literal>userData.txt</literal> file and <literal>disableTemplating.txt</literal> file to create a data secret file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api create secret generic &lt;role&gt;-user-data-x5 \ <co xml:id="CO18-1"/>
--from-file=userData=userData.txt \
--from-file=disableTemplating=disableTemplating.txt</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>For <literal>&lt;role&gt;-user-data-x5</literal>, specify the name of the secret. Replace <literal>&lt;role&gt;</literal> with <literal>worker</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Copy an existing Azure <literal>MachineSet</literal> custom resource (CR) and edit it by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine-set-name&gt;</programlisting>
<simpara>where <literal>&lt;machine-set-name&gt;</literal> is the machine set that you want to provision machines with ultra disks.</simpara>
</listitem>
<listitem>
<simpara>Add the following lines in the positions indicated:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <co xml:id="CO19-1"/>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <co xml:id="CO19-2"/>
          dataDisks: <co xml:id="CO19-3"/>
          - nameSuffix: ultrassd
            lun: 0
            diskSizeGB: 4
            deletionPolicy: Delete
            cachingType: None
            managedDisk:
              storageAccountType: UltraSSD_LRS
          userDataSecret:
            name: &lt;role&gt;-user-data-x5 <co xml:id="CO19-4"/></programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Specify a label to use to select a node that is created by this machine set. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO19-2 CO19-3">
<para>These lines enable the use of ultra disks.
For <literal>dataDisks</literal>, include the entire stanza.</para>
</callout>
<callout arearefs="CO19-4">
<para>Specify the user data secret created earlier. Replace <literal>&lt;role&gt;</literal> with <literal>worker</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a machine set using the updated configuration by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine-set-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Validate that the machines are created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines</programlisting>
<simpara>The machines should be in the <literal>Running</literal> state.</simpara>
</listitem>
<listitem>
<simpara>For a machine that is running and has a node attached, validate the partition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</programlisting>
<simpara>In this command, <literal>oc debug node/&lt;node-name&gt;</literal> starts a debugging shell on the node <literal>&lt;node-name&gt;</literal> and passes a command with <literal>--</literal>. The passed command <literal>chroot /host</literal> provides access to the underlying host OS binaries, and <literal>lsblk</literal> shows the block devices that are attached to the host OS machine.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>To use an ultra disk from within a pod, create a workload that uses the mount point. Create a YAML file similar to the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: ssd-benchmark1
spec:
  containers:
  - name: ssd-benchmark1
    image: nginx
    ports:
      - containerPort: 80
        name: "http-server"
    volumeMounts:
    - name: lun0p1
      mountPath: "/tmp"
  volumes:
    - name: lun0p1
      hostPath:
        path: /var/lib/lun0p1
        type: DirectoryOrCreate
  nodeSelector:
    disktype: ultrassd</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-troubleshooting-azure-ultra-disk_creating-machineset-azure">
<title>Troubleshooting resources for machine sets that enable ultra disks</title>
<simpara>Use the information in this section to understand and recover from issues you might encounter.</simpara>
<section xml:id="ts-mapi-attach-misconfigure_creating-machineset-azure">
<title>Incorrect ultra disk configuration</title>
<simpara>If an incorrect configuration of the <literal>ultraSSDCapability</literal> parameter is specified in the machine set, the machine provisioning fails.</simpara>
<simpara>For example, if the <literal>ultraSSDCapability</literal> parameter is set to <literal>Disabled</literal>, but an ultra disk is specified in the <literal>dataDisks</literal> parameter, the following error message appears:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, verify that your machine set configuration is correct.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ts-mapi-attach-unsupported_creating-machineset-azure">
<title>Unsupported disk parameters</title>
<simpara>If a region, availability zone, or instance size that is not compatible with ultra disks is specified in the machine set, the machine provisioning fails. Check the logs for the following error message:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">failed to create vm &lt;machine_name&gt;: failure sending request for machine &lt;machine_name&gt;: cannot create vm: compute.VirtualMachinesClient#CreateOrUpdate: Failure sending request: StatusCode=400 -- Original Error: Code="BadRequest" Message="Storage Account type 'UltraSSD_LRS' is not supported &lt;more_information_about_why&gt;."</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, verify that you are using this feature in a supported environment and that your machine set configuration is correct.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ts-mapi-delete_creating-machineset-azure">
<title>Unable to delete disks</title>
<simpara>If the deletion of ultra disks as data disks is not working as expected, the machines are deleted and the data disks are orphaned. You must delete the orphaned disks manually if desired.</simpara>
</section>
</section>
</section>
<section xml:id="machineset-enabling-customer-managed-encryption-azure_creating-machineset-azure">
<title>Enabling customer-managed encryption keys for a machine set</title>
<simpara>You can supply an encryption key to Azure to encrypt data on managed disks at rest. You can enable server-side encryption with customer-managed keys by using the Machine API.</simpara>
<simpara>An Azure Key Vault, a disk encryption set, and an encryption key are required to use a customer-managed key. The disk encryption set must be in a resource group where the Cloud Credential Operator (CCO) has granted permissions. If not, an additional reader role is required to be granted on the disk encryption set.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-azure-key-vault-instance">Create an Azure Key Vault instance</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-instance-of-a-diskencryptionset">Create an instance of a disk encryption set</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#grant-the-diskencryptionset-access-to-key-vault">Grant the disk encryption set access to key vault</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Configure the disk encryption set under the <literal>providerSpec</literal> field in your machine set YAML file. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    osDisk:
      diskSizeGB: 128
      managedDisk:
        diskEncryptionSet:
          id: /subscriptions/&lt;subscription_id&gt;/resourceGroups/&lt;resource_group_name&gt;/providers/Microsoft.Compute/diskEncryptionSets/&lt;disk_encryption_set_name&gt;
        storageAccountType: Premium_LRS</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disk-encryption#customer-managed-keys">Azure documentation about customer-managed keys</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-trusted-launch_creating-machineset-azure">
<title>Configuring trusted launch for Azure virtual machines by using machine sets</title>
<important>
<simpara>Using trusted launch for Azure virtual machines is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>OpenShift Container Platform 4.14 supports trusted launch for Azure virtual machines (VMs). By editing the machine set YAML file, you can configure the trusted launch options that a machine set uses for machines that it deploys. For example, you can configure these machines to use UEFI security features such as Secure Boot or a dedicated virtual Trusted Platform Module (vTPM) instance.</simpara>
<note>
<simpara>Some feature combinations result in an invalid configuration.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>UEFI feature combination compatibility</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Secure Boot<superscript>[1]</superscript></entry>
<entry align="left" valign="top">vTPM<superscript>[2]</superscript></entry>
<entry align="left" valign="top">Valid configuration</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Using the <literal>secureBoot</literal> field.</simpara>
</listitem>
<listitem>
<simpara>Using the <literal>virtualizedTrustedPlatformModule</literal> field.</simpara>
</listitem>
</orderedlist>
</para>
<simpara>For more information about related features and functionality, see the Microsoft Azure documentation about <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/trusted-launch">Trusted launch for Azure virtual machines</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field to provide a valid configuration:</simpara>
<formalpara>
<title>Sample valid configuration with UEFI Secure Boot and vTPM enabled</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          securityProfile:
            settings:
              securityType: TrustedLaunch <co xml:id="CO20-1"/>
              trustedLaunch:
                uefiSettings: <co xml:id="CO20-2"/>
                  secureBoot: Enabled <co xml:id="CO20-3"/>
                  virtualizedTrustedPlatformModule: Enabled <co xml:id="CO20-4"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>Enables the use of trusted launch for Azure virtual machines. This value is required for all valid configurations.</para>
</callout>
<callout arearefs="CO20-2">
<para>Specifies which UEFI security features to use. This section is required for all valid configurations.</para>
</callout>
<callout arearefs="CO20-3">
<para>Enables UEFI Secure Boot.</para>
</callout>
<callout arearefs="CO20-4">
<para>Enables the use of a vTPM.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Azure portal, review the details for a machine deployed by the machine set and verify that the trusted launch options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-confidential-vms_creating-machineset-azure">
<title>Configuring Azure confidential virtual machines by using machine sets</title>
<important>
<simpara>Using Azure confidential virtual machines is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>OpenShift Container Platform 4.14 supports Azure confidential virtual machines (VMs).</simpara>
<note>
<simpara>Confidential VMs are currently not supported on 64-bit ARM architectures.</simpara>
</note>
<simpara>By editing the machine set YAML file, you can configure the confidential VM options that a machine set uses for machines that it deploys. For example, you can configure these machines to use UEFI security features such as Secure Boot or a dedicated virtual Trusted Platform Module (vTPM) instance.</simpara>
<simpara>For more information about related features and functionality, see the Microsoft Azure documentation about <link xlink:href="https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-vm-overview">Confidential virtual machines</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<formalpara>
<title>Sample configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          osDisk:
            # ...
            managedDisk:
              securityProfile: <co xml:id="CO21-1"/>
                securityEncryptionType: VMGuestStateOnly <co xml:id="CO21-2"/>
            # ...
          securityProfile: <co xml:id="CO21-3"/>
            settings:
                securityType: ConfidentialVM <co xml:id="CO21-4"/>
                confidentialVM:
                  uefiSettings: <co xml:id="CO21-5"/>
                    secureBoot: Disabled <co xml:id="CO21-6"/>
                    virtualizedTrustedPlatformModule: Enabled <co xml:id="CO21-7"/>
          vmSize: Standard_DC16ads_v5 <co xml:id="CO21-8"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>Specifies security profile settings for the managed disk when using a confidential VM.</para>
</callout>
<callout arearefs="CO21-2">
<para>Enables encryption of the Azure VM Guest State (VMGS) blob. This setting requires the use of vTPM.</para>
</callout>
<callout arearefs="CO21-3">
<para>Specifies security profile settings for the confidential VM.</para>
</callout>
<callout arearefs="CO21-4">
<para>Enables the use of confidential VMs. This value is required for all valid configurations.</para>
</callout>
<callout arearefs="CO21-5">
<para>Specifies which UEFI security features to use. This section is required for all valid configurations.</para>
</callout>
<callout arearefs="CO21-6">
<para>Disables UEFI Secure Boot.</para>
</callout>
<callout arearefs="CO21-7">
<para>Enables the use of a vTPM.</para>
</callout>
<callout arearefs="CO21-8">
<para>Specifies an instance type that supports confidential VMs.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Azure portal, review the details for a machine deployed by the machine set and verify that the confidential VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-accelerated-networking_creating-machineset-azure">
<title>Accelerated Networking for Microsoft Azure VMs</title>
<simpara>Accelerated Networking uses single root I/O virtualization (SR-IOV) to provide Microsoft Azure VMs with a more direct path to the switch. This enhances network performance. This feature can be enabled
during or
after installation.</simpara>
<section xml:id="machineset-azure-accelerated-networking-limits_creating-machineset-azure">
<title>Limitations</title>
<simpara>Consider the following limitations when deciding whether to use Accelerated Networking:</simpara>
<itemizedlist>
<listitem>
<simpara>Accelerated Networking is only supported on clusters where the Machine API is operational.</simpara>
</listitem>
<listitem>
<simpara></simpara>
<simpara>Although the minimum requirement for an Azure worker node is two vCPUs,
Accelerated Networking requires an Azure VM size that includes at least four vCPUs. To satisfy this requirement, you can change the value of <literal>vmSize</literal> in your machine set. For information about Azure VM sizes, see <link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/sizes">Microsoft Azure documentation</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara>When this feature is enabled on an existing Azure cluster, only newly provisioned nodes are affected. Currently running nodes are not reconciled. To enable the feature on all nodes, you must replace each existing machine. This can be done for each machine individually, or by scaling the replicas down to zero, and then scaling back up to your desired number of replicas.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nvidia-gpu-aws-adding-a-gpu-node_creating-machineset-azure">
<title>Adding a GPU node to an existing OpenShift Container Platform cluster</title>
<simpara>You can copy and modify a default compute machine set configuration to create a GPU-enabled machine set and machines for the Azure cloud provider.</simpara>
<simpara>The following table lists the validated instance types:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">vmSize</entry>
<entry align="left" valign="top">NVIDIA GPU accelerator</entry>
<entry align="left" valign="top">Maximum number of GPUs</entry>
<entry align="left" valign="top">Architecture</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Standard_NC24s_v3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>V100</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>x86</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Standard_NC4as_T4_v3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>T4</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>x86</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ND A100 v4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A100</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>x86</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>By default, Azure subscriptions do not have a quota for the Azure instance types with GPU. Customers have to request a quota increase for the Azure instance families listed above.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the machines and machine sets that exist in the <literal>openshift-machine-api</literal> namespace
by running the following command. Each compute machine set is associated with a different availability zone within the Azure region.
The installer automatically load balances compute machines across availability zones.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              DESIRED   CURRENT   READY   AVAILABLE   AGE
myclustername-worker-centralus1   1         1         1       1           6h9m
myclustername-worker-centralus2   1         1         1       1           6h9m
myclustername-worker-centralus3   1         1         1       1           6h9m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Make a copy of one of the existing compute <literal>MachineSet</literal> definitions and output the result to a YAML file by running the following command.
This will be the basis for the GPU-enabled compute machine set definition.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api myclustername-worker-centralus1 -o yaml &gt; machineset-azure.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the content of the machineset:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat machineset-azure.yaml</programlisting>
<formalpara>
<title>Example <literal>machineset-azure.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  annotations:
    machine.openshift.io/GPU: "0"
    machine.openshift.io/memoryMb: "16384"
    machine.openshift.io/vCPU: "4"
  creationTimestamp: "2023-02-06T14:08:19Z"
  generation: 1
  labels:
    machine.openshift.io/cluster-api-cluster: myclustername
    machine.openshift.io/cluster-api-machine-role: worker
    machine.openshift.io/cluster-api-machine-type: worker
  name: myclustername-worker-centralus1
  namespace: openshift-machine-api
  resourceVersion: "23601"
  uid: acd56e0c-7612-473a-ae37-8704f34b80de
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: myclustername
      machine.openshift.io/cluster-api-machineset: myclustername-worker-centralus1
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: myclustername
        machine.openshift.io/cluster-api-machine-role: worker
        machine.openshift.io/cluster-api-machine-type: worker
        machine.openshift.io/cluster-api-machineset: myclustername-worker-centralus1
    spec:
      lifecycleHooks: {}
      metadata: {}
      providerSpec:
        value:
          acceleratedNetworking: true
          apiVersion: machine.openshift.io/v1beta1
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          diagnostics: {}
          image:
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/myclustername-rg/providers/Microsoft.Compute/galleries/gallery_myclustername_n6n4r/images/myclustername-gen2/versions/latest
            sku: ""
            version: ""
          kind: AzureMachineProviderSpec
          location: centralus
          managedIdentity: myclustername-identity
          metadata:
            creationTimestamp: null
          networkResourceGroup: myclustername-rg
          osDisk:
            diskSettings: {}
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: myclustername
          resourceGroup: myclustername-rg
          spotVMOptions: {}
          subnet: myclustername-worker-subnet
          userDataSecret:
            name: worker-user-data
          vmSize: Standard_D4s_v3
          vnet: myclustername-vnet
          zone: "1"
status:
  availableReplicas: 1
  fullyLabeledReplicas: 1
  observedGeneration: 1
  readyReplicas: 1
  replicas: 1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Make a copy of the <literal>machineset-azure.yaml</literal> file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cp machineset-azure.yaml machineset-azure-gpu.yaml</programlisting>
</listitem>
<listitem>
<simpara>Update the following fields in <literal>machineset-azure-gpu.yaml</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Change <literal>.metadata.name</literal> to a name containing <literal>gpu</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.selector.matchLabels["machine.openshift.io/cluster-api-machineset"]</literal> to match the new .metadata.name.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.template.metadata.labels["machine.openshift.io/cluster-api-machineset"]</literal> to match the new <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.template.spec.providerSpec.value.vmSize</literal> to <literal>Standard_NC4as_T4_v3</literal>.</simpara>
<formalpara>
<title>Example <literal>machineset-azure-gpu.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  annotations:
    machine.openshift.io/GPU: "1"
    machine.openshift.io/memoryMb: "28672"
    machine.openshift.io/vCPU: "4"
  creationTimestamp: "2023-02-06T20:27:12Z"
  generation: 1
  labels:
    machine.openshift.io/cluster-api-cluster: myclustername
    machine.openshift.io/cluster-api-machine-role: worker
    machine.openshift.io/cluster-api-machine-type: worker
  name: myclustername-nc4ast4-gpu-worker-centralus1
  namespace: openshift-machine-api
  resourceVersion: "166285"
  uid: 4eedce7f-6a57-4abe-b529-031140f02ffa
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: myclustername
      machine.openshift.io/cluster-api-machineset: myclustername-nc4ast4-gpu-worker-centralus1
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: myclustername
        machine.openshift.io/cluster-api-machine-role: worker
        machine.openshift.io/cluster-api-machine-type: worker
        machine.openshift.io/cluster-api-machineset: myclustername-nc4ast4-gpu-worker-centralus1
    spec:
      lifecycleHooks: {}
      metadata: {}
      providerSpec:
        value:
          acceleratedNetworking: true
          apiVersion: machine.openshift.io/v1beta1
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          diagnostics: {}
          image:
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/myclustername-rg/providers/Microsoft.Compute/galleries/gallery_myclustername_n6n4r/images/myclustername-gen2/versions/latest
            sku: ""
            version: ""
          kind: AzureMachineProviderSpec
          location: centralus
          managedIdentity: myclustername-identity
          metadata:
            creationTimestamp: null
          networkResourceGroup: myclustername-rg
          osDisk:
            diskSettings: {}
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: myclustername
          resourceGroup: myclustername-rg
          spotVMOptions: {}
          subnet: myclustername-worker-subnet
          userDataSecret:
            name: worker-user-data
          vmSize: Standard_NC4as_T4_v3
          vnet: myclustername-vnet
          zone: "1"
status:
  availableReplicas: 1
  fullyLabeledReplicas: 1
  observedGeneration: 1
  readyReplicas: 1
  replicas: 1</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To verify your changes, perform a <literal>diff</literal> of the original compute definition and the new GPU-enabled node definition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ diff machineset-azure.yaml machineset-azure-gpu.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">14c14
&lt;   name: myclustername-worker-centralus1
---
&gt;   name: myclustername-nc4ast4-gpu-worker-centralus1
23c23
&lt;       machine.openshift.io/cluster-api-machineset: myclustername-worker-centralus1
---
&gt;       machine.openshift.io/cluster-api-machineset: myclustername-nc4ast4-gpu-worker-centralus1
30c30
&lt;         machine.openshift.io/cluster-api-machineset: myclustername-worker-centralus1
---
&gt;         machine.openshift.io/cluster-api-machineset: myclustername-nc4ast4-gpu-worker-centralus1
67c67
&lt;           vmSize: Standard_D4s_v3
---
&gt;           vmSize: Standard_NC4as_T4_v3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the GPU-enabled compute machine set from the definition file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f machineset-azure-gpu.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineset.machine.openshift.io/myclustername-nc4ast4-gpu-worker-centralus1 created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines and machine sets that exist in the <literal>openshift-machine-api</literal> namespace
by running the following command. Each compute machine set is associated with a
different availability zone within the Azure region.
The installer automatically load balances compute machines across availability zones.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               DESIRED   CURRENT   READY   AVAILABLE   AGE
clustername-n6n4r-nc4ast4-gpu-worker-centralus1    1         1         1       1           122m
clustername-n6n4r-worker-centralus1                1         1         1       1           8h
clustername-n6n4r-worker-centralus2                1         1         1       1           8h
clustername-n6n4r-worker-centralus3                1         1         1       1           8h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines that exist in the <literal>openshift-machine-api</literal> namespace by running the following command. You can only configure one compute machine per set, although you can scale a compute machine set to add a node in a particular region and zone.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                PHASE     TYPE                   REGION      ZONE   AGE
myclustername-master-0                              Running   Standard_D8s_v3        centralus   2      6h40m
myclustername-master-1                              Running   Standard_D8s_v3        centralus   1      6h40m
myclustername-master-2                              Running   Standard_D8s_v3        centralus   3      6h40m
myclustername-nc4ast4-gpu-worker-centralus1-w9bqn   Running      centralus   1      21m
myclustername-worker-centralus1-rbh6b               Running   Standard_D4s_v3        centralus   1      6h38m
myclustername-worker-centralus2-dbz7w               Running   Standard_D4s_v3        centralus   2      6h38m
myclustername-worker-centralus3-p9b8c               Running   Standard_D4s_v3        centralus   3      6h38m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the existing nodes, machines, and machine sets by running the following command. Note that each node is an instance of a machine definition with a specific Azure region and OpenShift Container Platform role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                STATUS   ROLES                  AGE     VERSION
myclustername-master-0                              Ready    control-plane,master   6h39m   v1.28.5
myclustername-master-1                              Ready    control-plane,master   6h41m   v1.28.5
myclustername-master-2                              Ready    control-plane,master   6h39m   v1.28.5
myclustername-nc4ast4-gpu-worker-centralus1-w9bqn   Ready    worker                 14m     v1.28.5
myclustername-worker-centralus1-rbh6b               Ready    worker                 6h29m   v1.28.5
myclustername-worker-centralus2-dbz7w               Ready    worker                 6h29m   v1.28.5
myclustername-worker-centralus3-p9b8c               Ready    worker                 6h31m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the list of compute machine sets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   DESIRED   CURRENT   READY   AVAILABLE   AGE
myclustername-worker-centralus1        1         1         1       1           8h
myclustername-worker-centralus2        1         1         1       1           8h
myclustername-worker-centralus3        1         1         1       1           8h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the GPU-enabled compute machine set from the definition file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f machineset-azure-gpu.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the list of compute machine sets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                          DESIRED   CURRENT   READY   AVAILABLE   AGE
myclustername-nc4ast4-gpu-worker-centralus1   1         1         1       1           121m
myclustername-worker-centralus1               1         1         1       1           8h
myclustername-worker-centralus2               1         1         1       1           8h
myclustername-worker-centralus3               1         1         1       1           8h</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the machine set you created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api | grep gpu</programlisting>
<simpara>The MachineSet replica count is set to <literal>1</literal> so a new <literal>Machine</literal> object is created automatically.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">myclustername-nc4ast4-gpu-worker-centralus1   1         1         1       1           121m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the <literal>Machine</literal> object that the machine set created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get machines | grep gpu</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">myclustername-nc4ast4-gpu-worker-centralus1-w9bqn   Running   Standard_NC4as_T4_v3   centralus   1      21m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<note>
<simpara>There is no need to specify a namespace for the node. The node definition is cluster scoped.</simpara>
</note>
</section>
<section xml:id="nvidia-gpu-aws-deploying-the-node-feature-discovery-operator_creating-machineset-azure">
<title>Deploying the Node Feature Discovery Operator</title>
<simpara>After the GPU-enabled node is created, you need to discover the GPU-enabled node so it can be scheduled. To do this, install the Node Feature Discovery (NFD) Operator. The NFD Operator identifies hardware device features in nodes. It solves the general problem of identifying and cataloging hardware resources in the infrastructure nodes so they can be made available to OpenShift Container Platform.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Node Feature Discovery Operator from <emphasis role="strong">OperatorHub</emphasis> in the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>After installing the NFD Operator into <emphasis role="strong">OperatorHub</emphasis>, select <emphasis role="strong">Node Feature Discovery</emphasis> from the installed Operators list and select <emphasis role="strong">Create instance</emphasis>. This installs the <literal>nfd-master</literal> and <literal>nfd-worker</literal> pods, one <literal>nfd-worker</literal> pod for each compute node, in the <literal>openshift-nfd</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that the Operator is installed and running by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY    STATUS     RESTARTS   AGE

nfd-controller-manager-8646fcbb65-x5qgk    2/2      Running 7  (8h ago)   1d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Browse to the installed Oerator in the console and select <emphasis role="strong">Create Node Feature Discovery</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis> to build a NFD custom resource. This creates NFD pods in the <literal>openshift-nfd</literal> namespace that poll the OpenShift Container Platform nodes for hardware resources and catalogue them.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After a successful build, verify that a NFD pod is running on each nodes by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY   STATUS      RESTARTS        AGE
nfd-controller-manager-8646fcbb65-x5qgk    2/2     Running     7 (8h ago)      12d
nfd-master-769656c4cb-w9vrv                1/1     Running     0               12d
nfd-worker-qjxb2                           1/1     Running     3 (3d14h ago)   12d
nfd-worker-xtz9b                           1/1     Running     5 (3d14h ago)   12d</programlisting>
</para>
</formalpara>
<simpara>The NFD Operator uses vendor PCI IDs to identify hardware in a node. NVIDIA uses the PCI ID <literal>10de</literal>.</simpara>
</listitem>
<listitem>
<simpara>View the NVIDIA GPU discovered by the NFD Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node ip-10-0-132-138.us-east-2.compute.internal | egrep 'Roles|pci'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Roles: worker

feature.node.kubernetes.io/pci-1013.present=true

feature.node.kubernetes.io/pci-10de.present=true

feature.node.kubernetes.io/pci-1d0f.present=true</programlisting>
</para>
</formalpara>
<simpara><literal>10de</literal> appears in the node feature list for the GPU-enabled node. This mean the NFD Operator correctly identified the node from the GPU-enabled MachineSet.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#machineset-azure-enabling-accelerated-networking-new-install_installing-azure-customizations">Enabling Accelerated Networking during installation</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-azure-enabling-accelerated-networking-existing_creating-machineset-azure">
<title>Enabling Accelerated Networking on an existing Microsoft Azure cluster</title>
<simpara>You can enable Accelerated Networking on Azure by adding <literal>acceleratedNetworking</literal> to your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster where the Machine API is operational.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the following to the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    acceleratedNetworking: true <co xml:id="CO22-1"/>
    vmSize: &lt;azure-vm-size&gt; <co xml:id="CO22-2"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>This line enables Accelerated Networking.</para>
</callout>
<callout arearefs="CO22-2">
<para>Specify an Azure VM size that includes at least four vCPUs. For information about VM sizes, see <link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/sizes">Microsoft Azure documentation</link>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>To enable the feature on currently running nodes, you must replace each existing machine. This can be done for each machine individually, or by scaling the replicas down to zero, and then scaling back up to your desired number of replicas.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Networking</emphasis> settings page for a machine provisioned by the machine set, and verify that the <literal>Accelerated networking</literal> field is set to <literal>Enabled</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="manually-scaling-machineset">Manually scaling a compute machine set</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="creating-machineset-azure-stack-hub">
<title>Creating a compute machine set on Azure Stack Hub</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Microsoft Azure Stack Hub. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-azure-stack-hub_creating-machineset-azure-stack-hub">
<title>Sample YAML for a compute machine set custom resource on Azure Stack Hub</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>1</literal> Microsoft Azure zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO23-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO23-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO23-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO23-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO23-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO23-6"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO23-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO23-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO23-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO23-10"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/&lt;role&gt;: "" <co xml:id="CO23-11"/>
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1beta1
          availabilitySet: &lt;availability_set&gt; <co xml:id="CO23-12"/>
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          image:
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/&lt;infrastructure_id&gt;-rg/providers/Microsoft.Compute/images/&lt;infrastructure_id&gt; <co xml:id="CO23-13"/>
            sku: ""
            version: ""
          internalLoadBalancer: ""
          kind: AzureMachineProviderSpec
          location: &lt;region&gt; <co xml:id="CO23-14"/>
          managedIdentity: &lt;infrastructure_id&gt;-identity <co xml:id="CO23-15"/>
          metadata:
            creationTimestamp: null
          natRule: null
          networkResourceGroup: ""
          osDisk:
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: ""
          resourceGroup: &lt;infrastructure_id&gt;-rg <co xml:id="CO23-16"/>
          sshPrivateKey: ""
          sshPublicKey: ""
          subnet: &lt;infrastructure_id&gt;-&lt;role&gt;-subnet <co xml:id="CO23-17"/> <co xml:id="CO23-18"/>
          userDataSecret:
            name: worker-user-data <co xml:id="CO23-19"/>
          vmSize: Standard_DS4_v2
          vnet: &lt;infrastructure_id&gt;-vnet <co xml:id="CO23-20"/>
          zone: "1" <co xml:id="CO23-21"/></programlisting>
<calloutlist>
<callout arearefs="CO23-1 CO23-5 CO23-7 CO23-13 CO23-15 CO23-16 CO23-17 CO23-20">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<simpara>You can obtain the subnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.subnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
<simpara>You can obtain the vnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.vnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
</callout>
<callout arearefs="CO23-2 CO23-3 CO23-8 CO23-9 CO23-11 CO23-18 CO23-19">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO23-4 CO23-6 CO23-10">
<para>Specify the infrastructure ID, node label, and region.</para>
</callout>
<callout arearefs="CO23-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO23-21">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO23-12">
<para>Specify the availability set for the cluster.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-azure-stack-hub">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
<listitem>
<simpara>Create an availability set in which to deploy Azure Stack Hub compute machines.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;availabilitySet&gt;</literal>, <literal>&lt;clusterID&gt;</literal>, and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO24-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO24-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO24-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO24-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO24-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO24-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-boot-diagnostics_creating-machineset-azure-stack-hub">
<title>Enabling Azure boot diagnostics</title>
<simpara>You can enable boot diagnostics on Azure machines that your machine set creates.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure
Stack Hub
cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>diagnostics</literal> configuration that is applicable to your storage type to the <literal>providerSpec</literal> field in your machine set YAML file:</simpara>
<itemizedlist>
<listitem>
<simpara>For an Azure Managed storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: AzureManaged <co xml:id="CO25-1"/></programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>Specifies an Azure Managed storage account.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>For an Azure Unmanaged storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: CustomerManaged <co xml:id="CO26-1"/>
      customerManaged:
        storageAccountURI: https://&lt;storage-account&gt;.blob.core.windows.net <co xml:id="CO26-2"/></programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para>Specifies an Azure Unmanaged storage account.</para>
</callout>
<callout arearefs="CO26-2">
<para>Replace <literal>&lt;storage-account&gt;</literal> with the name of your storage account.</para>
</callout>
</calloutlist>
<note>
<simpara>Only the Azure Blob Storage data service is supported.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Boot diagnostics</emphasis> page for a machine deployed by the machine set, and verify that you can see the serial logs for the machine.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-enabling-customer-managed-encryption-azure_creating-machineset-azure-stack-hub">
<title>Enabling customer-managed encryption keys for a machine set</title>
<simpara>You can supply an encryption key to Azure to encrypt data on managed disks at rest. You can enable server-side encryption with customer-managed keys by using the Machine API.</simpara>
<simpara>An Azure Key Vault, a disk encryption set, and an encryption key are required to use a customer-managed key. The disk encryption set must be in a resource group where the Cloud Credential Operator (CCO) has granted permissions. If not, an additional reader role is required to be granted on the disk encryption set.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-azure-key-vault-instance">Create an Azure Key Vault instance</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-instance-of-a-diskencryptionset">Create an instance of a disk encryption set</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#grant-the-diskencryptionset-access-to-key-vault">Grant the disk encryption set access to key vault</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Configure the disk encryption set under the <literal>providerSpec</literal> field in your machine set YAML file. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    osDisk:
      diskSizeGB: 128
      managedDisk:
        diskEncryptionSet:
          id: /subscriptions/&lt;subscription_id&gt;/resourceGroups/&lt;resource_group_name&gt;/providers/Microsoft.Compute/diskEncryptionSets/&lt;disk_encryption_set_name&gt;
        storageAccountType: Premium_LRS</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disk-encryption#customer-managed-keys">Azure documentation about customer-managed keys</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-gcp">
<title>Creating a compute machine set on GCP</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Google Cloud Platform (GCP). For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-gcp_creating-machineset-gcp">
<title>Sample YAML for a compute machine set custom resource on GCP</title>
<simpara>This sample YAML defines a compute machine set that runs in Google Cloud Platform (GCP) and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>,
where
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<bridgehead xml:id="cpmso-yaml-provider-spec-gcp-oc_creating-machineset-gcp" renderas="sect4">Values obtained by using the  OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI.</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;infrastructure_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>Image path</term>
<listitem>
<simpara>The <literal>&lt;path_to_image&gt;</literal> string is the path to the image that was used to create the disk. If you have the OpenShift CLI installed, you can obtain the path to the image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
  -o jsonpath='{.spec.template.spec.providerSpec.value.disks[0].image}{"\n"}' \
  get machineset/&lt;infrastructure_id&gt;-worker-a</programlisting>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Sample GCP <literal>MachineSet</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO27-1"/>
  name: &lt;infrastructure_id&gt;-w-a
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-w-a
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO27-2"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-w-a
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: ""
      providerSpec:
        value:
          apiVersion: gcpprovider.openshift.io/v1beta1
          canIPForward: false
          credentialsSecret:
            name: gcp-cloud-credentials
          deletionProtection: false
          disks:
          - autoDelete: true
            boot: true
            image: &lt;path_to_image&gt; <co xml:id="CO27-3"/>
            labels: null
            sizeGb: 128
            type: pd-ssd
          gcpMetadata: <co xml:id="CO27-4"/>
          - key: &lt;custom_metadata_key&gt;
            value: &lt;custom_metadata_value&gt;
          kind: GCPMachineProviderSpec
          machineType: n1-standard-4
          metadata:
            creationTimestamp: null
          networkInterfaces:
          - network: &lt;infrastructure_id&gt;-network
            subnetwork: &lt;infrastructure_id&gt;-worker-subnet
          projectID: &lt;project_name&gt; <co xml:id="CO27-5"/>
          region: us-central1
          serviceAccounts:
          - email: &lt;infrastructure_id&gt;-w@&lt;project_name&gt;.iam.gserviceaccount.com
            scopes:
            - https://www.googleapis.com/auth/cloud-platform
          tags:
            - &lt;infrastructure_id&gt;-worker
          userDataSecret:
            name: worker-user-data
          zone: us-central1-a</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO27-1">
<para>For <literal>&lt;infrastructure_id&gt;</literal>, specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</para>
</callout>
<callout arearefs="CO27-2">
<para>For <literal>&lt;node&gt;</literal>, specify the node label to add.</para>
</callout>
<callout arearefs="CO27-3">
<para>Specify the path to the image that is used in current compute machine sets.</para>
<simpara>To use a GCP Marketplace image, specify the offer to use:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-ocp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Platform Plus: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-opp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Kubernetes Engine: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-oke-413-x86-64-202305021736</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO27-4">
<para>Optional: Specify custom metadata in the form of a <literal>key:value</literal> pair. For example use cases, see the GCP documentation for <link xlink:href="https://cloud.google.com/compute/docs/metadata/setting-custom-metadata">setting custom metadata</link>.</para>
</callout>
<callout arearefs="CO27-5">
<para>For <literal>&lt;project_name&gt;</literal>, specify the name of the GCP project that you use for your cluster.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-gcp">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO28-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO28-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO28-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO28-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO28-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO28-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-pd-disk-types_creating-machineset-gcp">
<title>Configuring persistent disk types by using machine sets</title>
<simpara>You can configure the type of persistent disk that a machine set deploys machines on by editing the machine set YAML file.</simpara>
<simpara>For more information about persistent disk types, compatibility, regional availability, and limitations, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/compute/docs/disks#pdspecs">persistent disks</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          disks:
            type: &lt;pd-disk-type&gt; <co xml:id="CO29-1"/></programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>Specify the disk persistent type. Valid values are <literal>pd-ssd</literal>, <literal>pd-standard</literal>, and <literal>pd-balanced</literal>. The default value is <literal>pd-standard</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Using the Google Cloud console, review the details for a machine deployed by the machine set and verify that the <literal>Type</literal> field matches the configured disk type.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-confidential-vm_creating-machineset-gcp">
<title>Configuring Confidential VM by using machine sets</title>
<simpara>By editing the machine set YAML file, you can configure the Confidential VM options that a machine set uses for machines that it deploys.</simpara>
<simpara>For more information about Confidential VM features, functions, and compatibility, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/confidential-computing/confidential-vm/docs/about-cvm#confidential-vm">Confidential VM</link>.</simpara>
<note>
<simpara>Confidential VMs are currently not supported on 64-bit ARM architectures.</simpara>
</note>
<important>
<simpara>OpenShift Container Platform 4.14 does not support some Confidential Compute features, such as Confidential VMs with AMD Secure Encrypted Virtualization Secure Nested Paging (SEV-SNP).</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          confidentialCompute: Enabled <co xml:id="CO30-1"/>
          onHostMaintenance: Terminate <co xml:id="CO30-2"/>
          machineType: n2d-standard-8 <co xml:id="CO30-3"/>
...</programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>Specify whether Confidential VM is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
<callout arearefs="CO30-2">
<para>Specify the behavior of the VM during a host maintenance event, such as a hardware or software update. For a machine that uses Confidential VM, this value must be set to <literal>Terminate</literal>, which stops the VM. Confidential VM does not support live VM migration.</para>
</callout>
<callout arearefs="CO30-3">
<para>Specify a machine type that supports Confidential VM. Confidential VM supports the N2D and C2D series of machine types.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Google Cloud console, review the details for a machine deployed by the machine set and verify that the Confidential VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-non-guaranteed-instance_creating-machineset-gcp">
<title>Machine sets that deploy machines as preemptible VM instances</title>
<simpara>You can save on costs by creating a compute machine set running on GCP that deploys machines as non-guaranteed preemptible VM instances. Preemptible VM instances utilize excess Compute Engine capacity and are less expensive than normal instances. You can use preemptible VM instances for workloads that can tolerate interruptions, such as batch or stateless, horizontally scalable workloads.</simpara>
<simpara>GCP Compute Engine can terminate a preemptible VM instance at any time. Compute Engine sends a preemption notice to the user indicating that an interruption will occur in 30 seconds. OpenShift Container Platform begins to remove the workloads from the affected instances when Compute Engine issues the preemption notice. An ACPI G3 Mechanical Off signal is sent to the operating system after 30 seconds if the instance is not stopped. The preemptible VM instance is then transitioned to a <literal>TERMINATED</literal> state by Compute Engine.</simpara>
<simpara>Interruptions can occur when using preemptible VM instances for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>There is a system or maintenance event</simpara>
</listitem>
<listitem>
<simpara>The supply of preemptible VM instances decreases</simpara>
</listitem>
<listitem>
<simpara>The instance reaches the end of the allotted 24-hour period for preemptible VM instances</simpara>
</listitem>
</itemizedlist>
<simpara>When GCP terminates an instance, a termination handler running on the preemptible VM instance node deletes the machine resource. To satisfy the compute machine set <literal>replicas</literal> quantity, the compute machine set creates a machine that requests a preemptible VM instance.</simpara>
<section xml:id="machineset-creating-non-guaranteed-instance_creating-machineset-gcp">
<title>Creating preemptible VM instances by using compute machine sets</title>
<simpara>You can launch a preemptible VM instance on GCP by adding <literal>preemptible</literal> to your compute machine set YAML file.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    preemptible: true</programlisting>
<simpara>If <literal>preemptible</literal> is set to <literal>true</literal>, the machine is labelled as an <literal>interruptable-instance</literal> after the instance is launched.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machineset-gcp-shielded-vms_creating-machineset-gcp">
<title>Configuring Shielded VM options by using machine sets</title>
<simpara>By editing the machine set YAML file, you can configure the Shielded VM options that a machine set uses for machines that it deploys.</simpara>
<simpara>For more information about Shielded VM features and functionality, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm">Shielded VM</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          shieldedInstanceConfig: <co xml:id="CO31-1"/>
            integrityMonitoring: Enabled <co xml:id="CO31-2"/>
            secureBoot: Disabled <co xml:id="CO31-3"/>
            virtualizedTrustedPlatformModule: Enabled <co xml:id="CO31-4"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>In this section, specify any Shielded VM options that you want.</para>
</callout>
<callout arearefs="CO31-2">
<para>Specify whether integrity monitoring is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
<note>
<simpara>When integrity monitoring is enabled, you must not disable virtual trusted platform module (vTPM).</simpara>
</note>
</callout>
<callout arearefs="CO31-3">
<para>Specify whether UEFI Secure Boot is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
<callout arearefs="CO31-4">
<para>Specify whether vTPM is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Using the Google Cloud console, review the details for a machine deployed by the machine set and verify that the Shielded VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm">What is Shielded VM?</link></simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot">Secure Boot</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#vtpm">Virtual Trusted Platform Module (vTPM)</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#integrity-monitoring">Integrity monitoring</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-enabling-customer-managed-encryption_creating-machineset-gcp">
<title>Enabling customer-managed encryption keys for a machine set</title>
<simpara>Google Cloud Platform (GCP) Compute Engine allows users to supply an encryption key to encrypt data on disks at rest. The key is used to encrypt the data encryption key, not to encrypt the customer&#8217;s data. By default, Compute Engine encrypts this data by using Compute Engine keys.</simpara>
<simpara>You can enable encryption with a customer-managed key in clusters that use the Machine API. You must first <link xlink:href="https://cloud.google.com/compute/docs/disks/customer-managed-encryption#before_you_begin">create a KMS key</link> and assign the correct permissions to a service account. The KMS key name, key ring name, and location are required to allow a service account to use your key.</simpara>
<note>
<simpara>If you do not want to use a dedicated service account for the KMS encryption, the Compute Engine default service account is used instead. You must grant the default service account permission to access the keys if you do not use a dedicated service account. The Compute Engine default service account name follows the <literal>service-&lt;project_number&gt;@compute-system.iam.gserviceaccount.com</literal> pattern.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To allow a specific service account to use your KMS key and to grant the service account the correct IAM role, run the following command with your KMS key name, key ring name, and location:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ gcloud kms keys add-iam-policy-binding &lt;key_name&gt; \
  --keyring &lt;key_ring_name&gt; \
  --location &lt;key_ring_location&gt; \
  --member "serviceAccount:service-&lt;project_number&gt;@compute-system.iam.gserviceaccount.com” \
  --role roles/cloudkms.cryptoKeyEncrypterDecrypter</programlisting>
</listitem>
<listitem>
<simpara>Configure the encryption key under the <literal>providerSpec</literal> field in your machine set YAML file. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          disks:
          - type:
            encryptionKey:
              kmsKey:
                name: machine-encryption-key <co xml:id="CO32-1"/>
                keyRing: openshift-encrpytion-ring <co xml:id="CO32-2"/>
                location: global <co xml:id="CO32-3"/>
                projectID: openshift-gcp-project <co xml:id="CO32-4"/>
              kmsKeyServiceAccount: openshift-service-account@openshift-gcp-project.iam.gserviceaccount.com <co xml:id="CO32-5"/></programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>The name of the customer-managed encryption key that is used for the disk encryption.</para>
</callout>
<callout arearefs="CO32-2">
<para>The name of the KMS key ring that the KMS key belongs to.</para>
</callout>
<callout arearefs="CO32-3">
<para>The GCP location in which the KMS key ring exists.</para>
</callout>
<callout arearefs="CO32-4">
<para>Optional: The ID of the project in which the KMS key ring exists. If a project ID is not set, the machine set <literal>projectID</literal> in which the machine set was created is used.</para>
</callout>
<callout arearefs="CO32-5">
<para>Optional: The service account that is used for the encryption request for the given KMS key. If a service account is not set, the Compute Engine default service account is used.</para>
</callout>
</calloutlist>
<simpara>When a new machine is created by using the updated <literal>providerSpec</literal> object configuration, the disk encryption key is encrypted with the KMS key.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machineset-gcp-enabling-gpu-support_creating-machineset-gcp">
<title>Enabling GPU support for a compute machine set</title>
<simpara>Google Cloud Platform (GCP) Compute Engine enables users to add GPUs to VM instances. Workloads that benefit from access to GPU resources can perform better on compute machines with this feature enabled. OpenShift Container Platform on GCP supports NVIDIA GPU models in the A2 and N1 machine series.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported GPU configurations</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Model name</entry>
<entry align="left" valign="top">GPU type</entry>
<entry align="left" valign="top">Machine types <superscript>[1]</superscript></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>NVIDIA A100</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-a100</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>a2-highgpu-1g</literal></simpara>
</listitem>
<listitem>
<simpara><literal>a2-highgpu-2g</literal></simpara>
</listitem>
<listitem>
<simpara><literal>a2-highgpu-4g</literal></simpara>
</listitem>
<listitem>
<simpara><literal>a2-highgpu-8g</literal></simpara>
</listitem>
<listitem>
<simpara><literal>a2-megagpu-16g</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVIDIA K80</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-k80</literal></simpara></entry>
<entry align="left" valign="top" morerows="4"><itemizedlist>
<listitem>
<simpara><literal>n1-standard-1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-4</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-8</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-16</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-32</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-64</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-standard-96</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-4</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-8</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-16</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-32</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-64</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highmem-96</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-2</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-4</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-8</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-16</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-32</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-64</literal></simpara>
</listitem>
<listitem>
<simpara><literal>n1-highcpu-96</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVIDIA P100</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-p100</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVIDIA P4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-p4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVIDIA T4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-t4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NVIDIA V100</simpara></entry>
<entry align="left" valign="top"><simpara><literal>nvidia-tesla-v100</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>For more information about machine types, including specifications, compatibility, regional availability, and limitations, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/compute/docs/general-purpose-machines#n1_machines">N1 machine series</link>, <link xlink:href="https://cloud.google.com/compute/docs/accelerator-optimized-machines#a2_vms">A2 machine series</link>, and <link xlink:href="https://cloud.google.com/compute/docs/gpus/gpu-regions-zones#gpu_regions_and_zones">GPU regions and zones availability</link>.</simpara>
</listitem>
</orderedlist>
</para>
<simpara>You can define which supported GPU to use for an instance by using the Machine API.</simpara>
<simpara>You can configure machines in the N1 machine series to deploy with one of the supported GPU types. Machines in the A2 machine series come with associated GPUs, and cannot use guest accelerators.</simpara>
<note>
<simpara>GPUs for graphics workloads are not supported.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing compute machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Specify a GPU configuration under the <literal>providerSpec</literal> field in your compute machine set YAML file. See the following examples of valid configurations:</simpara>
<formalpara>
<title>Example configuration for the A2 machine series:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  providerSpec:
    value:
      machineType: a2-highgpu-1g <co xml:id="CO33-1"/>
      onHostMaintenance: Terminate <co xml:id="CO33-2"/>
      restartPolicy: Always <co xml:id="CO33-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO33-1">
<para>Specify the machine type. Ensure that the machine type is included in the A2 machine series.</para>
</callout>
<callout arearefs="CO33-2">
<para>When using GPU support, you must set <literal>onHostMaintenance</literal> to <literal>Terminate</literal>.</para>
</callout>
<callout arearefs="CO33-3">
<para>Specify the restart policy for machines deployed by the compute machine set. Allowed values are <literal>Always</literal> or <literal>Never</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example configuration for the N1 machine series:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    gpus:
    - count: 1 <co xml:id="CO34-1"/>
      type: nvidia-tesla-p100 <co xml:id="CO34-2"/>
    machineType: n1-standard-1 <co xml:id="CO34-3"/>
    onHostMaintenance: Terminate <co xml:id="CO34-4"/>
    restartPolicy: Always <co xml:id="CO34-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>Specify the number of GPUs to attach to the machine.</para>
</callout>
<callout arearefs="CO34-2">
<para>Specify the type of GPUs to attach to the machine. Ensure that the machine type and GPU type are compatible.</para>
</callout>
<callout arearefs="CO34-3">
<para>Specify the machine type. Ensure that the machine type and GPU type are compatible.</para>
</callout>
<callout arearefs="CO34-4">
<para>When using GPU support, you must set <literal>onHostMaintenance</literal> to <literal>Terminate</literal>.</para>
</callout>
<callout arearefs="CO34-5">
<para>Specify the restart policy for machines deployed by the compute machine set. Allowed values are <literal>Always</literal> or <literal>Never</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nvidia-gpu-gcp-adding-a-gpu-node_creating-machineset-gcp">
<title>Adding a GPU node to an existing OpenShift Container Platform cluster</title>
<simpara>You can copy and modify a default compute machine set configuration to create a GPU-enabled machine set and machines for the GCP cloud provider.</simpara>
<simpara>The following table lists the validated instance types:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Instance type</entry>
<entry align="left" valign="top">NVIDIA GPU accelerator</entry>
<entry align="left" valign="top">Maximum number of GPUs</entry>
<entry align="left" valign="top">Architecture</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>a2-highgpu-1g</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A100</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>x86</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>n1-standard-4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>T4</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>x86</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Make a copy of an existing <literal>MachineSet</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the new copy, change the machine set <literal>name</literal> in <literal>metadata.name</literal> and in both instances of <literal>machine.openshift.io/cluster-api-machineset</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change the instance type to add the following two lines to the newly copied <literal>MachineSet</literal>:</simpara>
<screen>machineType: a2-highgpu-1g
onHostMaintenance: Terminate</screen>
<formalpara>
<title>Example <literal>a2-highgpu-1g.json</literal> file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "apiVersion": "machine.openshift.io/v1beta1",
    "kind": "MachineSet",
    "metadata": {
        "annotations": {
            "machine.openshift.io/GPU": "0",
            "machine.openshift.io/memoryMb": "16384",
            "machine.openshift.io/vCPU": "4"
        },
        "creationTimestamp": "2023-01-13T17:11:02Z",
        "generation": 1,
        "labels": {
            "machine.openshift.io/cluster-api-cluster": "myclustername-2pt9p"
        },
        "name": "myclustername-2pt9p-worker-gpu-a",
        "namespace": "openshift-machine-api",
        "resourceVersion": "20185",
        "uid": "2daf4712-733e-4399-b4b4-d43cb1ed32bd"
    },
    "spec": {
        "replicas": 1,
        "selector": {
            "matchLabels": {
                "machine.openshift.io/cluster-api-cluster": "myclustername-2pt9p",
                "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-gpu-a"
            }
        },
        "template": {
            "metadata": {
                "labels": {
                    "machine.openshift.io/cluster-api-cluster": "myclustername-2pt9p",
                    "machine.openshift.io/cluster-api-machine-role": "worker",
                    "machine.openshift.io/cluster-api-machine-type": "worker",
                    "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-gpu-a"
                }
            },
            "spec": {
                "lifecycleHooks": {},
                "metadata": {},
                "providerSpec": {
                    "value": {
                        "apiVersion": "machine.openshift.io/v1beta1",
                        "canIPForward": false,
                        "credentialsSecret": {
                            "name": "gcp-cloud-credentials"
                        },
                        "deletionProtection": false,
                        "disks": [
                            {
                                "autoDelete": true,
                                "boot": true,
                                "image": "projects/rhcos-cloud/global/images/rhcos-412-86-202212081411-0-gcp-x86-64",
                                "labels": null,
                                "sizeGb": 128,
                                "type": "pd-ssd"
                            }
                        ],
                        "kind": "GCPMachineProviderSpec",
                        "machineType": "a2-highgpu-1g",
                        "onHostMaintenance": "Terminate",
                        "metadata": {
                            "creationTimestamp": null
                        },
                        "networkInterfaces": [
                            {
                                "network": "myclustername-2pt9p-network",
                                "subnetwork": "myclustername-2pt9p-worker-subnet"
                            }
                        ],
                        "preemptible": true,
                        "projectID": "myteam",
                        "region": "us-central1",
                        "serviceAccounts": [
                            {
                                "email": "myclustername-2pt9p-w@myteam.iam.gserviceaccount.com",
                                "scopes": [
                                    "https://www.googleapis.com/auth/cloud-platform"
                                ]
                            }
                        ],
                        "tags": [
                            "myclustername-2pt9p-worker"
                        ],
                        "userDataSecret": {
                            "name": "worker-user-data"
                        },
                        "zone": "us-central1-a"
                    }
                }
            }
        }
    },
    "status": {
        "availableReplicas": 1,
        "fullyLabeledReplicas": 1,
        "observedGeneration": 1,
        "readyReplicas": 1,
        "replicas": 1
    }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the existing nodes, machines, and machine sets by running the following command. Note that each node is an instance of a machine definition with a specific GCP region and OpenShift Container Platform role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                             STATUS     ROLES                  AGE     VERSION
myclustername-2pt9p-master-0.c.openshift-qe.internal             Ready      control-plane,master   8h      v1.28.5
myclustername-2pt9p-master-1.c.openshift-qe.internal             Ready      control-plane,master   8h      v1.28.5
myclustername-2pt9p-master-2.c.openshift-qe.internal             Ready      control-plane,master   8h      v1.28.5
myclustername-2pt9p-worker-a-mxtnz.c.openshift-qe.internal       Ready      worker                 8h      v1.28.5
myclustername-2pt9p-worker-b-9pzzn.c.openshift-qe.internal       Ready      worker                 8h      v1.28.5
myclustername-2pt9p-worker-c-6pbg6.c.openshift-qe.internal       Ready      worker                 8h      v1.28.5
myclustername-2pt9p-worker-gpu-a-wxcr6.c.openshift-qe.internal   Ready      worker                 4h35m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines and machine sets that exist in the <literal>openshift-machine-api</literal> namespace by running the following command. Each compute machine set is associated with a different availability zone within the GCP region. The installer automatically load balances compute machines across availability zones.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                               DESIRED   CURRENT   READY   AVAILABLE   AGE
myclustername-2pt9p-worker-a       1         1         1       1           8h
myclustername-2pt9p-worker-b       1         1         1       1           8h
myclustername-2pt9p-worker-c       1         1                             8h
myclustername-2pt9p-worker-f       0         0                             8h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the machines that exist in the <literal>openshift-machine-api</literal> namespace by running the following command. You can only configure one compute machine per set, although you can scale a compute machine set to add a node in a particular region and zone.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines -n openshift-machine-api | grep worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">myclustername-2pt9p-worker-a-mxtnz       Running   n2-standard-4   us-central1   us-central1-a   8h
myclustername-2pt9p-worker-b-9pzzn       Running   n2-standard-4   us-central1   us-central1-b   8h
myclustername-2pt9p-worker-c-6pbg6       Running   n2-standard-4   us-central1   us-central1-c   8h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Make a copy of one of the existing compute <literal>MachineSet</literal> definitions and output the result to a JSON file by running the following command. This will be the basis for the GPU-enabled compute machine set definition.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset myclustername-2pt9p-worker-a -n openshift-machine-api -o json  &gt; &lt;output_file.json&gt;</programlisting>
</listitem>
<listitem>
<simpara>Edit the JSON file to make the following changes to the new <literal>MachineSet</literal> definition:</simpara>
<itemizedlist>
<listitem>
<simpara>Rename the machine set <literal>name</literal> by inserting the substring <literal>gpu</literal> in <literal>metadata.name</literal> and in both instances of <literal>machine.openshift.io/cluster-api-machineset</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change the <literal>machineType</literal> of the new <literal>MachineSet</literal> definition to <literal>a2-highgpu-1g</literal>, which includes an NVIDIA A100 GPU.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">jq .spec.template.spec.providerSpec.value.machineType ocp_4.14_machineset-a2-highgpu-1g.json

"a2-highgpu-1g"</programlisting>
<simpara>The <literal>&lt;output_file.json&gt;</literal> file is saved as <literal>ocp_4.14_machineset-a2-highgpu-1g.json</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Update the following fields in <literal>ocp_4.14_machineset-a2-highgpu-1g.json</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Change <literal>.metadata.name</literal> to a name containing <literal>gpu</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.selector.matchLabels["machine.openshift.io/cluster-api-machineset"]</literal> to
match the new <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.template.metadata.labels["machine.openshift.io/cluster-api-machineset"]</literal>
to match the new <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara>Change <literal>.spec.template.spec.providerSpec.value.MachineType</literal> to <literal>a2-highgpu-1g</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the following line under <literal>machineType</literal>: `"onHostMaintenance": "Terminate". For example:</simpara>
<programlisting language="json" linenumbering="unnumbered">"machineType": "a2-highgpu-1g",
"onHostMaintenance": "Terminate",</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To verify your changes, perform a <literal>diff</literal> of the original compute definition and the new GPU-enabled node definition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset/myclustername-2pt9p-worker-a -n openshift-machine-api -o json | diff ocp_4.14_machineset-a2-highgpu-1g.json -</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">15c15
&lt;         "name": "myclustername-2pt9p-worker-gpu-a",
---
&gt;         "name": "myclustername-2pt9p-worker-a",
25c25
&lt;                 "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-gpu-a"
---
&gt;                 "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-a"
34c34
&lt;                     "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-gpu-a"
---
&gt;                     "machine.openshift.io/cluster-api-machineset": "myclustername-2pt9p-worker-a"
59,60c59
&lt;                         "machineType": "a2-highgpu-1g",
&lt;                         "onHostMaintenance": "Terminate",
---
&gt;                         "machineType": "n2-standard-4",</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the GPU-enabled compute machine set from the definition file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ocp_4.14_machineset-a2-highgpu-1g.json</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineset.machine.openshift.io/myclustername-2pt9p-worker-gpu-a created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the machine set you created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get machinesets | grep gpu</programlisting>
<simpara>The MachineSet replica count is set to <literal>1</literal> so a new <literal>Machine</literal> object is created automatically.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">myclustername-2pt9p-worker-gpu-a   1         1         1       1           5h24m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the <literal>Machine</literal> object that the machine set created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get machines | grep gpu</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">myclustername-2pt9p-worker-gpu-a-wxcr6   Running   a2-highgpu-1g   us-central1   us-central1-a   5h25m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<note>
<simpara>Note that there is no need to specify a namespace for the node. The node definition is cluster scoped.</simpara>
</note>
</section>
<section xml:id="nvidia-gpu-aws-deploying-the-node-feature-discovery-operator_creating-machineset-gcp">
<title>Deploying the Node Feature Discovery Operator</title>
<simpara>After the GPU-enabled node is created, you need to discover the GPU-enabled node so it can be scheduled. To do this, install the Node Feature Discovery (NFD) Operator. The NFD Operator identifies hardware device features in nodes. It solves the general problem of identifying and cataloging hardware resources in the infrastructure nodes so they can be made available to OpenShift Container Platform.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Node Feature Discovery Operator from <emphasis role="strong">OperatorHub</emphasis> in the OpenShift Container Platform console.</simpara>
</listitem>
<listitem>
<simpara>After installing the NFD Operator into <emphasis role="strong">OperatorHub</emphasis>, select <emphasis role="strong">Node Feature Discovery</emphasis> from the installed Operators list and select <emphasis role="strong">Create instance</emphasis>. This installs the <literal>nfd-master</literal> and <literal>nfd-worker</literal> pods, one <literal>nfd-worker</literal> pod for each compute node, in the <literal>openshift-nfd</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that the Operator is installed and running by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY    STATUS     RESTARTS   AGE

nfd-controller-manager-8646fcbb65-x5qgk    2/2      Running 7  (8h ago)   1d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Browse to the installed Oerator in the console and select <emphasis role="strong">Create Node Feature Discovery</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis> to build a NFD custom resource. This creates NFD pods in the <literal>openshift-nfd</literal> namespace that poll the OpenShift Container Platform nodes for hardware resources and catalogue them.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After a successful build, verify that a NFD pod is running on each nodes by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-nfd</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY   STATUS      RESTARTS        AGE
nfd-controller-manager-8646fcbb65-x5qgk    2/2     Running     7 (8h ago)      12d
nfd-master-769656c4cb-w9vrv                1/1     Running     0               12d
nfd-worker-qjxb2                           1/1     Running     3 (3d14h ago)   12d
nfd-worker-xtz9b                           1/1     Running     5 (3d14h ago)   12d</programlisting>
</para>
</formalpara>
<simpara>The NFD Operator uses vendor PCI IDs to identify hardware in a node. NVIDIA uses the PCI ID <literal>10de</literal>.</simpara>
</listitem>
<listitem>
<simpara>View the NVIDIA GPU discovered by the NFD Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node ip-10-0-132-138.us-east-2.compute.internal | egrep 'Roles|pci'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Roles: worker

feature.node.kubernetes.io/pci-1013.present=true

feature.node.kubernetes.io/pci-10de.present=true

feature.node.kubernetes.io/pci-1d0f.present=true</programlisting>
</para>
</formalpara>
<simpara><literal>10de</literal> appears in the node feature list for the GPU-enabled node. This mean the NFD Operator correctly identified the node from the GPU-enabled MachineSet.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="creating-machineset-ibm-cloud">
<title>Creating a compute machine set on IBM Cloud</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on IBM Cloud&#174;. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-ibm-cloud_creating-machineset-ibm-cloud">
<title>Sample YAML for a compute machine set custom resource on IBM Cloud</title>
<simpara>This sample YAML defines a compute machine set that runs in a specified IBM Cloud&#174; zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO35-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO35-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO35-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO35-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO35-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO35-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO35-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO35-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO35-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO35-10"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: ""
      providerSpec:
        value:
          apiVersion: ibmcloudproviderconfig.openshift.io/v1beta1
          credentialsSecret:
            name: ibmcloud-credentials
          image: &lt;infrastructure_id&gt;-rhcos <co xml:id="CO35-11"/>
          kind: IBMCloudMachineProviderSpec
          primaryNetworkInterface:
              securityGroups:
              - &lt;infrastructure_id&gt;-sg-cluster-wide
              - &lt;infrastructure_id&gt;-sg-openshift-net
              subnet: &lt;infrastructure_id&gt;-subnet-compute-&lt;zone&gt; <co xml:id="CO35-12"/>
          profile: &lt;instance_profile&gt; <co xml:id="CO35-13"/>
          region: &lt;region&gt; <co xml:id="CO35-14"/>
          resourceGroup: &lt;resource_group&gt; <co xml:id="CO35-15"/>
          userDataSecret:
              name: &lt;role&gt;-user-data <co xml:id="CO35-16"/>
          vpc: &lt;vpc_name&gt; <co xml:id="CO35-17"/>
          zone: &lt;zone&gt; <co xml:id="CO35-18"/></programlisting>
<calloutlist>
<callout arearefs="CO35-1 CO35-5 CO35-7">
<para>The infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO35-2 CO35-3 CO35-8 CO35-9 CO35-16">
<para>The node label to add.</para>
</callout>
<callout arearefs="CO35-4 CO35-6 CO35-10">
<para>The infrastructure ID, node label, and region.</para>
</callout>
<callout arearefs="CO35-11">
<para>The custom Red Hat Enterprise Linux CoreOS (RHCOS) image that was used for cluster installation.</para>
</callout>
<callout arearefs="CO35-12">
<para>The infrastructure ID and zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO35-13">
<para>Specify the <link xlink:href="https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&amp;interface=ui">IBM Cloud&#174; instance profile</link>.</para>
</callout>
<callout arearefs="CO35-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO35-15">
<para>The resource group that machine resources are placed in. This is either an existing resource group specified at installation time, or an installer-created resource group named based on the infrastructure ID.</para>
</callout>
<callout arearefs="CO35-17">
<para>The VPC name.</para>
</callout>
<callout arearefs="CO35-18">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-ibm-cloud">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO36-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO36-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO36-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO36-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO36-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO36-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-ibm-power-vs">
<title>Creating a compute machine set on IBM Power Virtual Server</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on IBM Power&#174; Virtual Server. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-ibm-power-vs_creating-machineset-ibm-power-vs">
<title>Sample YAML for a compute machine set custom resource on IBM Power Virtual Server</title>
<simpara>This sample YAML file defines a compute machine set that runs in a specified IBM Power&#174; Virtual Server zone in a region and creates nodes that are labeled with <literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and <literal>&lt;role&gt;</literal> is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO37-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO37-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO37-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO37-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO37-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO37-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO37-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO37-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO37-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;region&gt; <co xml:id="CO37-10"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: ""
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1
          credentialsSecret:
            name: powervs-credentials
          image:
            name: rhcos-&lt;infrastructure_id&gt; <co xml:id="CO37-11"/>
            type: Name
          keyPairName: &lt;infrastructure_id&gt;-key
          kind: PowerVSMachineProviderConfig
          memoryGiB: 32
          network:
            regex: ^DHCPSERVER[0-9a-z]{32}_Private$
            type: RegEx
          processorType: Shared
          processors: "0.5"
          serviceInstance:
            id: &lt;ibm_power_vs_service_instance_id&gt;
            type: ID <co xml:id="CO37-12"/>
          systemType: s922
          userDataSecret:
            name: &lt;role&gt;-user-data</programlisting>
<calloutlist>
<callout arearefs="CO37-1 CO37-5 CO37-7">
<para>The infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO37-2 CO37-3 CO37-8 CO37-9">
<para>The node label to add.</para>
</callout>
<callout arearefs="CO37-4 CO37-6 CO37-10">
<para>The infrastructure ID, node label, and region.</para>
</callout>
<callout arearefs="CO37-11">
<para>The custom Red Hat Enterprise Linux CoreOS (RHCOS) image that was used for cluster installation.</para>
</callout>
<callout arearefs="CO37-12">
<para>The infrastructure ID within your region to place machines on.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-ibm-power-vs">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO38-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO38-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO38-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO38-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO38-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO38-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-nutanix">
<title>Creating a compute machine set on Nutanix</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Nutanix. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-nutanix_creating-machineset-nutanix">
<title>Sample YAML for a compute machine set custom resource on Nutanix</title>
<simpara>This sample YAML defines a Nutanix compute machine set that creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<bridgehead xml:id="machineset-yaml-nutanix-oc_creating-machineset-nutanix" renderas="sect4">Values obtained by using the OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;infrastructure_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO39-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO39-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
  name: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt; <co xml:id="CO39-3"/>
  namespace: openshift-machine-api
  annotations: <co xml:id="CO39-4"/>
    machine.openshift.io/memoryMb: "16384"
    machine.openshift.io/vCPU: "4"
spec:
  replicas: 3
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt;
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/&lt;role&gt;: ""
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1
          bootType: "" <co xml:id="CO39-5"/>
          categories: <co xml:id="CO39-6"/>
          - key: &lt;category_name&gt;
            value: &lt;category_value&gt;
          cluster: <co xml:id="CO39-7"/>
            type: uuid
            uuid: &lt;cluster_uuid&gt;
          credentialsSecret:
            name: nutanix-credentials
          image:
            name: &lt;infrastructure_id&gt;-rhcos <co xml:id="CO39-8"/>
            type: name
          kind: NutanixMachineProviderConfig
          memorySize: 16Gi <co xml:id="CO39-9"/>
          project: <co xml:id="CO39-10"/>
            type: name
            name: &lt;project_name&gt;
          subnets:
          - type: uuid
            uuid: &lt;subnet_uuid&gt;
          systemDiskSize: 120Gi <co xml:id="CO39-11"/>
          userDataSecret:
            name: &lt;user_data_secret&gt; <co xml:id="CO39-12"/>
          vcpuSockets: 4 <co xml:id="CO39-13"/>
          vcpusPerSocket: 1 <co xml:id="CO39-14"/></programlisting>
<calloutlist>
<callout arearefs="CO39-1">
<para>For <literal>&lt;infrastructure_id&gt;</literal>, specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</para>
</callout>
<callout arearefs="CO39-2">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO39-3">
<para>Specify the infrastructure ID, node label, and zone.</para>
</callout>
<callout arearefs="CO39-4">
<para>Annotations for the cluster autoscaler.</para>
</callout>
<callout arearefs="CO39-5">
<para>Specifies the boot type that the compute machines use. For more information about boot types, see <link xlink:href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA07V000000H3K9SAK">Understanding UEFI, Secure Boot, and TPM in the Virtualized Environment</link>. Valid values are <literal>Legacy</literal>, <literal>SecureBoot</literal>, or <literal>UEFI</literal>. The default is <literal>Legacy</literal>.</para>
<note>
<simpara>You must use the <literal>Legacy</literal> boot type in OpenShift Container Platform 4.14.</simpara>
</note>
</callout>
<callout arearefs="CO39-6">
<para>Specify one or more Nutanix Prism categories to apply to compute machines. This stanza requires <literal>key</literal> and <literal>value</literal> parameters for a category key-value pair that exists in Prism Central. For more information about categories, see <link xlink:href="https://portal.nutanix.com/page/documents/details?targetId=Prism-Central-Guide-vpc_2022_6:ssp-ssp-categories-manage-pc-c.html">Category management</link>.</para>
</callout>
<callout arearefs="CO39-7">
<para>Specify a Nutanix Prism Element cluster configuration. In this example, the cluster type is <literal>uuid</literal>, so there is a <literal>uuid</literal> stanza.</para>
</callout>
<callout arearefs="CO39-8">
<para>Specify the image to use. Use an image from an existing default compute machine set for the cluster.</para>
</callout>
<callout arearefs="CO39-9">
<para>Specify the amount of memory for the cluster in Gi.</para>
</callout>
<callout arearefs="CO39-10">
<para>Specify the Nutanix project that you use for your cluster. In this example, the project type is <literal>name</literal>, so there is a <literal>name</literal> stanza.</para>
</callout>
<callout arearefs="CO39-11">
<para>Specify the size of the system disk in Gi.</para>
</callout>
<callout arearefs="CO39-12">
<para>Specify the name of the secret in the user data YAML file that is in the <literal>openshift-machine-api</literal> namespace. Use the value that installation program populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO39-13">
<para>Specify the number of vCPU sockets.</para>
</callout>
<callout arearefs="CO39-14">
<para>Specify the number of vCPUs per socket.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-nutanix">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO40-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO40-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO40-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO40-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO40-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO40-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-osp">
<title>Creating a compute machine set on OpenStack</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on Red Hat OpenStack Platform (RHOSP). For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-osp_creating-machineset-osp">
<title>Sample YAML for a compute machine set custom resource on RHOSP</title>
<simpara>This sample YAML defines a compute machine set that runs on Red Hat OpenStack Platform (RHOSP) and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO41-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO41-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO41-3"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO41-4"/>
  namespace: openshift-machine-api
spec:
  replicas: &lt;number_of_replicas&gt;
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO41-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO41-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO41-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO41-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO41-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO41-10"/>
    spec:
      providerSpec:
        value:
          apiVersion: openstackproviderconfig.openshift.io/v1alpha1
          cloudName: openstack
          cloudsSecret:
            name: openstack-cloud-credentials
            namespace: openshift-machine-api
          flavor: &lt;nova_flavor&gt;
          image: &lt;glance_image_name_or_location&gt;
          serverGroupID: &lt;optional_UUID_of_server_group&gt; <co xml:id="CO41-11"/>
          kind: OpenstackProviderSpec
          networks: <co xml:id="CO41-12"/>
          - filter: {}
            subnets:
            - filter:
                name: &lt;subnet_name&gt;
                tags: openshiftClusterID=&lt;infrastructure_id&gt; <co xml:id="CO41-13"/>
          primarySubnet: &lt;rhosp_subnet_UUID&gt; <co xml:id="CO41-14"/>
          securityGroups:
          - filter: {}
            name: &lt;infrastructure_id&gt;-worker <co xml:id="CO41-15"/>
          serverMetadata:
            Name: &lt;infrastructure_id&gt;-worker <co xml:id="CO41-16"/>
            openshiftClusterID: &lt;infrastructure_id&gt; <co xml:id="CO41-17"/>
          tags:
          - openshiftClusterID=&lt;infrastructure_id&gt; <co xml:id="CO41-18"/>
          trunk: true
          userDataSecret:
            name: worker-user-data <co xml:id="CO41-19"/>
          availabilityZone: &lt;optional_openstack_availability_zone&gt;</programlisting>
<calloutlist>
<callout arearefs="CO41-1 CO41-5 CO41-7 CO41-13 CO41-15 CO41-16 CO41-17 CO41-18">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO41-2 CO41-3 CO41-8 CO41-9 CO41-19">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO41-4 CO41-6 CO41-10">
<para>Specify the infrastructure ID and node label.</para>
</callout>
<callout arearefs="CO41-11">
<para>To set a server group policy for the MachineSet, enter the value that is returned from
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/16.0/html/command_line_interface_reference/server#server_group_create">creating a server group</link>. For most deployments, <literal>anti-affinity</literal> or <literal>soft-anti-affinity</literal> policies are recommended.</para>
</callout>
<callout arearefs="CO41-12">
<para>Required for deployments to multiple networks. To specify multiple networks, add another entry in the networks array. Also, you must include the network that is used as the <literal>primarySubnet</literal> value.</para>
</callout>
<callout arearefs="CO41-14">
<para>Specify the RHOSP subnet that you want the endpoints of nodes to be published on. Usually, this is the same subnet that is used as the value of <literal>machinesSubnet</literal> in the <literal>install-config.yaml</literal> file.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-yaml-osp-sr-iov_creating-machineset-osp">
<title>Sample YAML for a compute machine set custom resource that uses SR-IOV on RHOSP</title>
<simpara>If you configured your cluster for single-root I/O virtualization (SR-IOV), you can create compute machine sets that use that technology.</simpara>
<simpara>This sample YAML defines a compute machine set that uses SR-IOV networks. The nodes that it creates are labeled with <literal>node-role.openshift.io/&lt;node_role&gt;: ""</literal></simpara>
<simpara>In this sample, <literal>infrastructure_id</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and <literal>node_role</literal> is the node label to add.</simpara>
<simpara>The sample assumes two SR-IOV networks that are named "radio" and "uplink". The networks are used in port definitions in the <literal>spec.template.spec.providerSpec.value.ports</literal> list.</simpara>
<note>
<simpara>Only parameters that are specific to SR-IOV deployments are described in this sample. To review a more general sample, see "Sample YAML for a compute machine set custom resource on RHOSP".</simpara>
</note>
<formalpara>
<title>An example compute machine set that uses SR-IOV networks</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
    machine.openshift.io/cluster-api-machine-role: &lt;node_role&gt;
    machine.openshift.io/cluster-api-machine-type: &lt;node_role&gt;
  name: &lt;infrastructure_id&gt;-&lt;node_role&gt;
  namespace: openshift-machine-api
spec:
  replicas: &lt;number_of_replicas&gt;
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;node_role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;node_role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;node_role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;node_role&gt;
    spec:
      metadata:
      providerSpec:
        value:
          apiVersion: openstackproviderconfig.openshift.io/v1alpha1
          cloudName: openstack
          cloudsSecret:
            name: openstack-cloud-credentials
            namespace: openshift-machine-api
          flavor: &lt;nova_flavor&gt;
          image: &lt;glance_image_name_or_location&gt;
          serverGroupID: &lt;optional_UUID_of_server_group&gt;
          kind: OpenstackProviderSpec
          networks:
            - subnets:
              - UUID: &lt;machines_subnet_UUID&gt;
          ports:
            - networkID: &lt;radio_network_UUID&gt; <co xml:id="CO42-1"/>
              nameSuffix: radio
              fixedIPs:
                - subnetID: &lt;radio_subnet_UUID&gt; <co xml:id="CO42-2"/>
              tags:
                - sriov
                - radio
              vnicType: direct <co xml:id="CO42-3"/>
              portSecurity: false <co xml:id="CO42-4"/>
            - networkID: &lt;uplink_network_UUID&gt; <co xml:id="CO42-5"/>
              nameSuffix: uplink
              fixedIPs:
                - subnetID: &lt;uplink_subnet_UUID&gt; <co xml:id="CO42-6"/>
              tags:
                - sriov
                - uplink
              vnicType: direct <co xml:id="CO42-7"/>
              portSecurity: false <co xml:id="CO42-8"/>
          primarySubnet: &lt;machines_subnet_UUID&gt;
          securityGroups:
          - filter: {}
            name: &lt;infrastructure_id&gt;-&lt;node_role&gt;
          serverMetadata:
            Name: &lt;infrastructure_id&gt;-&lt;node_role&gt;
            openshiftClusterID: &lt;infrastructure_id&gt;
          tags:
          - openshiftClusterID=&lt;infrastructure_id&gt;
          trunk: true
          userDataSecret:
            name: &lt;node_role&gt;-user-data
          availabilityZone: &lt;optional_openstack_availability_zone&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO42-1 CO42-5">
<para>Enter a network UUID for each port.</para>
</callout>
<callout arearefs="CO42-2 CO42-6">
<para>Enter a subnet UUID for each port.</para>
</callout>
<callout arearefs="CO42-3 CO42-7">
<para>The value of the <literal>vnicType</literal> parameter must be <literal>direct</literal> for each port.</para>
</callout>
<callout arearefs="CO42-4 CO42-8">
<para>The value of the <literal>portSecurity</literal> parameter must be <literal>false</literal> for each port.</para>
<simpara>You cannot set security groups and allowed address pairs for ports when port security is disabled. Setting security groups on the instance applies the groups to all ports that are attached to it.</simpara>
</callout>
</calloutlist>
<important>
<simpara>After you deploy compute machines that are SR-IOV-capable, you must label them as such. For example, from a command line, enter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;NODE_NAME&gt; feature.node.kubernetes.io/network-sriov.capable="true"</programlisting>
</important>
<note>
<simpara>Trunking is enabled for ports that are created by entries in the networks and subnets lists. The names of ports that are created from these lists follow the pattern <literal>&lt;machine_name&gt;-&lt;nameSuffix&gt;</literal>. The <literal>nameSuffix</literal> field is required in port definitions.</simpara>
<simpara>You can enable trunking for each port.</simpara>
<simpara>Optionally, you can add tags to ports as part of their <literal>tags</literal> lists.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-openstack-nfv-preparing">Preparing to install a cluster that uses SR-IOV or OVS-DPDK on OpenStack</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-yaml-osp-sr-iov-port-security_creating-machineset-osp">
<title>Sample YAML for SR-IOV deployments where port security is disabled</title>
<simpara>To create single-root I/O virtualization (SR-IOV) ports on a network that has port security disabled, define a compute machine set that includes the ports as items in the <literal>spec.template.spec.providerSpec.value.ports</literal> list. This difference from the standard SR-IOV compute machine set is due to the automatic security group and allowed address pair configuration that occurs for ports that are created by using the network and subnet interfaces.</simpara>
<simpara>Ports that you define for machines subnets require:</simpara>
<itemizedlist>
<listitem>
<simpara>Allowed address pairs for the API and ingress virtual IP ports</simpara>
</listitem>
<listitem>
<simpara>The compute security group</simpara>
</listitem>
<listitem>
<simpara>Attachment to the machines network and subnet</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Only parameters that are specific to SR-IOV deployments where port security is disabled are described in this sample. To review a more general sample, see Sample YAML for a compute machine set custom resource that uses SR-IOV on RHOSP".</simpara>
</note>
<formalpara>
<title>An example compute machine set that uses SR-IOV networks and has port security disabled</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
    machine.openshift.io/cluster-api-machine-role: &lt;node_role&gt;
    machine.openshift.io/cluster-api-machine-type: &lt;node_role&gt;
  name: &lt;infrastructure_id&gt;-&lt;node_role&gt;
  namespace: openshift-machine-api
spec:
  replicas: &lt;number_of_replicas&gt;
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;node_role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;node_role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;node_role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;node_role&gt;
    spec:
      metadata: {}
      providerSpec:
        value:
          apiVersion: openstackproviderconfig.openshift.io/v1alpha1
          cloudName: openstack
          cloudsSecret:
            name: openstack-cloud-credentials
            namespace: openshift-machine-api
          flavor: &lt;nova_flavor&gt;
          image: &lt;glance_image_name_or_location&gt;
          kind: OpenstackProviderSpec
          ports:
            - allowedAddressPairs: <co xml:id="CO43-1"/>
              - ipAddress: &lt;API_VIP_port_IP&gt;
              - ipAddress: &lt;ingress_VIP_port_IP&gt;
              fixedIPs:
                - subnetID: &lt;machines_subnet_UUID&gt; <co xml:id="CO43-2"/>
              nameSuffix: nodes
              networkID: &lt;machines_network_UUID&gt; <co xml:id="CO43-3"/>
              securityGroups:
                  - &lt;compute_security_group_UUID&gt; <co xml:id="CO43-4"/>
            - networkID: &lt;SRIOV_network_UUID&gt;
              nameSuffix: sriov
              fixedIPs:
                - subnetID: &lt;SRIOV_subnet_UUID&gt;
              tags:
                - sriov
              vnicType: direct
              portSecurity: False
          primarySubnet: &lt;machines_subnet_UUID&gt;
          serverMetadata:
            Name: &lt;infrastructure_ID&gt;-&lt;node_role&gt;
            openshiftClusterID: &lt;infrastructure_id&gt;
          tags:
          - openshiftClusterID=&lt;infrastructure_id&gt;
          trunk: false
          userDataSecret:
            name: worker-user-data</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO43-1">
<para>Specify allowed address pairs for the API and ingress ports.</para>
</callout>
<callout arearefs="CO43-2 CO43-3">
<para>Specify the machines network and subnet.</para>
</callout>
<callout arearefs="CO43-4">
<para>Specify the compute machines security group.</para>
</callout>
</calloutlist>
<note>
<simpara>Trunking is enabled for ports that are created by entries in the networks and subnets lists. The names of ports that are created from these lists follow the pattern <literal>&lt;machine_name&gt;-&lt;nameSuffix&gt;</literal>. The <literal>nameSuffix</literal> field is required in port definitions.</simpara>
<simpara>You can enable trunking for each port.</simpara>
<simpara>Optionally, you can add tags to ports as part of their <literal>tags</literal> lists.</simpara>
</note>
</section>
<section xml:id="machineset-creating_creating-machineset-osp">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO44-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO44-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO44-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO44-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO44-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-vsphere">
<title>Creating a compute machine set on vSphere</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on VMware vSphere. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-vsphere_creating-machineset-vsphere">
<title>Sample YAML for a compute machine set custom resource on vSphere</title>
<simpara>This sample YAML defines a compute machine set that runs on VMware vSphere and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  creationTimestamp: null
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO45-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO45-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO45-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO45-4"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO45-5"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO45-6"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO45-7"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO45-8"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/&lt;role&gt;: "" <co xml:id="CO45-9"/>
      providerSpec:
        value:
          apiVersion: vsphereprovider.openshift.io/v1beta1
          credentialsSecret:
            name: vsphere-cloud-credentials
          diskGiB: 120
          kind: VSphereMachineProviderSpec
          memoryMiB: 8192
          metadata:
            creationTimestamp: null
          network:
            devices:
            - networkName: "&lt;vm_network_name&gt;" <co xml:id="CO45-10"/>
          numCPUs: 4
          numCoresPerSocket: 1
          snapshot: ""
          template: &lt;vm_template_name&gt; <co xml:id="CO45-11"/>
          userDataSecret:
            name: worker-user-data
          workspace:
            datacenter: &lt;vcenter_datacenter_name&gt; <co xml:id="CO45-12"/>
            datastore: &lt;vcenter_datastore_name&gt; <co xml:id="CO45-13"/>
            folder: &lt;vcenter_vm_folder_path&gt; <co xml:id="CO45-14"/>
            resourcepool: &lt;vsphere_resource_pool&gt; <co xml:id="CO45-15"/>
            server: &lt;vcenter_server_ip&gt; <co xml:id="CO45-16"/></programlisting>
<calloutlist>
<callout arearefs="CO45-1 CO45-3 CO45-5">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO45-2 CO45-4 CO45-8">
<para>Specify the infrastructure ID and node label.</para>
</callout>
<callout arearefs="CO45-6 CO45-7 CO45-9">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO45-10">
<para>Specify the vSphere VM network to deploy the compute machine set to. This VM network must be where other compute machines reside in the cluster.</para>
</callout>
<callout arearefs="CO45-11">
<para>Specify the vSphere VM template to use, such as <literal>user-5ddjd-rhcos</literal>.</para>
</callout>
<callout arearefs="CO45-12">
<para>Specify the vCenter Datacenter to deploy the compute machine set on.</para>
</callout>
<callout arearefs="CO45-13">
<para>Specify the vCenter Datastore to deploy the compute machine set on.</para>
</callout>
<callout arearefs="CO45-14">
<para>Specify the path to the vSphere VM folder in vCenter, such as <literal>/dc1/vm/user-inst-5ddjd</literal>.</para>
</callout>
<callout arearefs="CO45-15">
<para>Specify the vSphere resource pool for your VMs.</para>
</callout>
<callout arearefs="CO45-16">
<para>Specify the vCenter server IP or fully qualified domain name.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-vsphere-requirements-user-provisioned-machine-sets_creating-machineset-vsphere">
<title>Minimum required vCenter privileges for compute machine set management</title>
<simpara>To manage compute machine sets in an OpenShift Container Platform cluster on vCenter, you must use an account with privileges to read, create, and delete the required resources. Using an account that has global administrative privileges is the simplest way to access all of the necessary permissions.</simpara>
<simpara>If you cannot use an account with global administrative privileges, you must create roles to grant the minimum required privileges. The following table lists the minimum vCenter roles and privileges that are required to create, scale, and delete compute machine sets and to delete machines in your OpenShift Container Platform cluster.</simpara>
<example>
<title>Minimum vCenter roles and privileges required for compute machine set management</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">vSphere object for role</entry>
<entry align="left" valign="top">When required</entry>
<entry align="left" valign="top">Required privileges</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara><literal>InventoryService.Tagging.AttachTag</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.CreateCategory</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.CreateTag</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.DeleteCategory</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.DeleteTag</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.EditCategory</literal><?asciidoc-br?>
<literal>InventoryService.Tagging.EditTag</literal><?asciidoc-br?>
<literal>Sessions.ValidateSession</literal><?asciidoc-br?>
<literal>StorageProfile.Update</literal><superscript>1</superscript><?asciidoc-br?>
<literal>StorageProfile.View</literal><superscript>1</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter Cluster</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Resource.AssignVMToPool</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere Datastore</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Datastore.AllocateSpace</literal><?asciidoc-br?>
<literal>Datastore.Browse</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere Port Group</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Network.Assign</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Virtual Machine Folder</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara><literal>VirtualMachine.Config.AddRemoveDevice</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.AdvancedConfig</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.Annotation</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.CPUCount</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.DiskExtend</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.Memory</literal><?asciidoc-br?>
<literal>VirtualMachine.Config.Settings</literal><?asciidoc-br?>
<literal>VirtualMachine.Interact.PowerOff</literal><?asciidoc-br?>
<literal>VirtualMachine.Interact.PowerOn</literal><?asciidoc-br?>
<literal>VirtualMachine.Inventory.CreateFromExisting</literal><?asciidoc-br?>
<literal>VirtualMachine.Inventory.Delete</literal><?asciidoc-br?>
<literal>VirtualMachine.Provisioning.Clone</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter Datacenter</simpara></entry>
<entry align="left" valign="top"><simpara>If the installation program creates the virtual machine folder</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Resource.AssignVMToPool</literal><?asciidoc-br?>
<literal>VirtualMachine.Provisioning.DeployTemplate</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_3"><simpara><superscript>1</superscript> The <literal>StorageProfile.Update</literal> and <literal>StorageProfile.View</literal> permissions are required only for storage backends that use the Container Storage Interface (CSI).</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara>The following table details the permissions and propagation settings that are required for compute machine set management.</simpara>
<example>
<title>Required permissions and propagation settings</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">vSphere object</entry>
<entry align="left" valign="top">Folder type</entry>
<entry align="left" valign="top">Propagate to children</entry>
<entry align="left" valign="top">Permissions required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Not required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>vSphere vCenter Datacenter</simpara></entry>
<entry align="left" valign="top"><simpara>Existing folder</simpara></entry>
<entry align="left" valign="top"><simpara>Not required</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ReadOnly</literal> permission</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Installation program creates the folder</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter Cluster</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter Datastore</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Not required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere Switch</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Not required</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ReadOnly</literal> permission</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere Port Group</simpara></entry>
<entry align="left" valign="top"><simpara>Always</simpara></entry>
<entry align="left" valign="top"><simpara>Not required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere vCenter Virtual Machine Folder</simpara></entry>
<entry align="left" valign="top"><simpara>Existing folder</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
<entry align="left" valign="top"><simpara>Listed required privileges</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<simpara>For more information about creating an account with only the required privileges, see <link xlink:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.security.doc/GUID-5372F580-5C23-4E9C-8A4E-EF1B4DD9033E.html">vSphere Permissions and User Management Tasks</link> in the vSphere documentation.</simpara>
</section>
<section xml:id="compute-machineset-upi-reqs_creating-machineset-vsphere">
<title>Requirements for clusters with user-provisioned infrastructure to use compute machine sets</title>
<simpara>To use compute machine sets on clusters that have user-provisioned infrastructure, you must ensure that you cluster configuration supports using the Machine API.</simpara>
<bridgehead xml:id="machineset-upi-reqs-infra-id_creating-machineset-vsphere" renderas="sect4">Obtaining the infrastructure ID</bridgehead>
<simpara>To create compute machine sets, you must be able to supply the infrastructure ID for your cluster.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To obtain the infrastructure ID for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.infrastructureName}'</programlisting>
</listitem>
</itemizedlist>
<bridgehead xml:id="machineset-upi-reqs-vsphere-creds_creating-machineset-vsphere" renderas="sect4">Satisfying vSphere credentials requirements</bridgehead>
<simpara>To use compute machine sets, the Machine API must be able to interact with vCenter. Credentials that authorize the Machine API components to interact with vCenter must exist in a secret in the <literal>openshift-machine-api</literal> namespace.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To determine whether the required credentials exist, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret \
  -n openshift-machine-api vsphere-cloud-credentials \
  -o go-template='{{range $k,$v := .data}}{{printf "%s: " $k}}{{if not $v}}{{$v}}{{else}}{{$v | base64decode}}{{end}}{{"\n"}}{{end}}'</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">&lt;vcenter-server&gt;.password=&lt;openshift-user-password&gt;
&lt;vcenter-server&gt;.username=&lt;openshift-user&gt;</programlisting>
</para>
</formalpara>
<simpara>where <literal>&lt;vcenter-server&gt;</literal> is the IP address or fully qualified domain name (FQDN) of the vCenter server and <literal>&lt;openshift-user&gt;</literal> and <literal>&lt;openshift-user-password&gt;</literal> are the OpenShift Container Platform administrator credentials to use.</simpara>
</listitem>
<listitem>
<simpara>If the secret does not exist, create it by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic vsphere-cloud-credentials \
  -n openshift-machine-api \
  --from-literal=&lt;vcenter-server&gt;.username=&lt;openshift-user&gt; --from-literal=&lt;vcenter-server&gt;.password=&lt;openshift-user-password&gt;</programlisting>
</listitem>
</orderedlist>
<bridgehead xml:id="machineset-upi-reqs-ignition-config_creating-machineset-vsphere" renderas="sect4">Satisfying Ignition configuration requirements</bridgehead>
<simpara>Provisioning virtual machines (VMs) requires a valid Ignition configuration. The Ignition configuration contains the <literal>machine-config-server</literal> address and a system trust bundle for obtaining further Ignition configurations from the Machine Config Operator.</simpara>
<simpara>By default, this configuration is stored in the <literal>worker-user-data</literal> secret in the <literal>machine-api-operator</literal> namespace. Compute machine sets reference the secret during the machine creation process.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To determine whether the required secret exists, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret \
  -n openshift-machine-api worker-user-data \
  -o go-template='{{range $k,$v := .data}}{{printf "%s: " $k}}{{if not $v}}{{$v}}{{else}}{{$v | base64decode}}{{end}}{{"\n"}}{{end}}'</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">disableTemplating: false
userData: <co xml:id="CO46-1"/>
  {
    "ignition": {
      ...
      },
    ...
  }</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO46-1">
<para>The full output is omitted here, but should have this format.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If the secret does not exist, create it by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic worker-user-data \
  -n openshift-machine-api \
  --from-file=&lt;installation_directory&gt;/worker.ign</programlisting>
<simpara>where <literal>&lt;installation_directory&gt;</literal> is the directory that was used to store your installation assets during cluster installation.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/postinstallation_configuration/#understanding-the-machine-config-operator">Understanding the Machine Config Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-vsphere-machines_installing-vsphere">Installing RHCOS and starting the OpenShift Container Platform bootstrap process</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-creating_creating-machineset-vsphere">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<note>
<simpara>Clusters that are installed with user-provisioned infrastructure have a different networking stack than clusters with infrastructure that is provisioned by the installation program. As a result of this difference, automatic load balancer management is unsupported on clusters that have user-provisioned infrastructure. For these clusters, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
<listitem>
<simpara>Have the necessary permissions to deploy VMs in your vCenter instance and have the required access to the datastore specified.</simpara>
</listitem>
<listitem>
<simpara>If your cluster uses user-provisioned infrastructure, you have satisfied the specific Machine API requirements for that configuration.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO47-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO47-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO47-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO47-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO47-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO47-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If you are creating a compute machine set for a cluster that has user-provisioned infrastructure, note the following important values:</simpara>
<formalpara>
<title>Example vSphere <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
...
template:
  ...
  spec:
    providerSpec:
      value:
        apiVersion: machine.openshift.io/v1beta1
        credentialsSecret:
          name: vsphere-cloud-credentials <co xml:id="CO48-1"/>
        diskGiB: 120
        kind: VSphereMachineProviderSpec
        memoryMiB: 16384
        network:
          devices:
            - networkName: "&lt;vm_network_name&gt;"
        numCPUs: 4
        numCoresPerSocket: 4
        snapshot: ""
        template: &lt;vm_template_name&gt; <co xml:id="CO48-2"/>
        userDataSecret:
          name: worker-user-data <co xml:id="CO48-3"/>
        workspace:
          datacenter: &lt;vcenter_datacenter_name&gt;
          datastore: &lt;vcenter_datastore_name&gt;
          folder: &lt;vcenter_vm_folder_path&gt;
          resourcepool: &lt;vsphere_resource_pool&gt;
          server: &lt;vcenter_server_address&gt; <co xml:id="CO48-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO48-1">
<para>The name of the secret in the <literal>openshift-machine-api</literal> namespace that contains the required vCenter credentials.</para>
</callout>
<callout arearefs="CO48-2">
<para>The name of the RHCOS VM template for your cluster that was created during installation.</para>
</callout>
<callout arearefs="CO48-3">
<para>The name of the secret in the <literal>openshift-machine-api</literal> namespace that contains the required Ignition configuration credentials.</para>
</callout>
<callout arearefs="CO48-4">
<para>The IP address or fully qualified domain name (FQDN) of the vCenter server.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="creating-machineset-bare-metal">
<title>Creating a compute machine set on bare metal</title>

<simpara>You can create a different compute machine set to serve a specific purpose in your OpenShift Container Platform cluster on bare metal. For example, you might create infrastructure machine sets and related machines so that you can move supporting workloads to the new machines.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machineset-yaml-vsphere_creating-machineset-bare-metal">
<title>Sample YAML for a compute machine set custom resource on bare metal</title>
<simpara>This sample YAML defines a compute machine set that runs on bare metal and creates nodes that are labeled with
<literal>node-role.kubernetes.io/&lt;role&gt;: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;role&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  creationTimestamp: null
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO49-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO49-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO49-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO49-4"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO49-5"/>
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO49-6"/>
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO49-7"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO49-8"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/&lt;role&gt;: "" <co xml:id="CO49-9"/>
      providerSpec:
        value:
          apiVersion: baremetal.cluster.k8s.io/v1alpha1
          hostSelector: {}
          image:
            checksum: http:/172.22.0.3:6181/images/rhcos-&lt;version&gt;.&lt;architecture&gt;.qcow2.&lt;md5sum&gt; <co xml:id="CO49-10"/>
            url: http://172.22.0.3:6181/images/rhcos-&lt;version&gt;.&lt;architecture&gt;.qcow2 <co xml:id="CO49-11"/>
          kind: BareMetalMachineProviderSpec
          metadata:
            creationTimestamp: null
          userData:
            name: worker-user-data</programlisting>
<calloutlist>
<callout arearefs="CO49-1 CO49-3 CO49-5">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO49-2 CO49-4 CO49-8">
<para>Specify the infrastructure ID and node label.</para>
</callout>
<callout arearefs="CO49-6 CO49-7 CO49-9">
<para>Specify the node label to add.</para>
</callout>
<callout arearefs="CO49-10">
<para>Edit the <literal>checksum</literal> URL to use the API VIP address.</para>
</callout>
<callout arearefs="CO49-11">
<para>Edit the <literal>url</literal> URL to use the API VIP address.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-creating_creating-machineset-bare-metal">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO50-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO50-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO50-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO50-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO50-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO50-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="manually-scaling-machineset">
<title>Manually scaling a compute machine set</title>

<simpara>You can add or remove an instance of a machine in a compute machine set.</simpara>
<note>
<simpara>If you need to modify aspects of a compute machine set outside of scaling, see <link linkend="modifying-machineset">Modifying a compute machine set</link>.</simpara>
</note>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>If you enabled the cluster-wide proxy and scale up compute machines not included in <literal>networking.machineNetwork[].cidr</literal> from the installation configuration, you must <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/networking/#nw-proxy-configure-object_config-cluster-wide-proxy">add the compute machines to the Proxy object&#8217;s <literal>noProxy</literal> field</link> to prevent connection issues.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
</section>
<section xml:id="machineset-manually-scaling_manually-scaling-machineset">
<title>Scaling a compute machine set manually</title>
<simpara>To add or remove an instance of a machine in a compute machine set, you can manually scale the compute machine set.</simpara>
<simpara>This guidance is relevant to fully automated, installer-provisioned infrastructure installations. Customized, user-provisioned infrastructure installations do not have compute machine sets.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install an OpenShift Container Platform cluster and the <literal>oc</literal> command line.</simpara>
</listitem>
<listitem>
<simpara>Log in to  <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the compute machine sets that are in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<simpara>The compute machine sets are listed in the form of <literal>&lt;clusterid&gt;-worker-&lt;aws-region-az&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>View the compute machines that are in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machine -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Set the annotation on the compute machine that you want to delete by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate machine/&lt;machine_name&gt; -n openshift-machine-api machine.openshift.io/delete-machine="true"</programlisting>
</listitem>
<listitem>
<simpara>Scale the compute machine set by running one of the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=2 machineset &lt;machineset&gt; -n openshift-machine-api</programlisting>
<simpara>Or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machineset&gt; -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to scale the compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machineset&gt;
  namespace: openshift-machine-api
spec:
  replicas: 2</programlisting>
</tip>
<simpara>You can scale the compute machine set up or down. It takes several minutes for the new machines to be available.</simpara>
<important>
<simpara>By default, the machine controller tries to drain the node that is backed by the machine until it succeeds. In some situations, such as with a misconfigured pod disruption budget, the drain operation might not be able to succeed. If the drain operation fails, the machine controller cannot proceed removing the machine.</simpara>
<simpara>You can skip draining the node by annotating <literal>machine.openshift.io/exclude-node-draining</literal> in a specific machine.</simpara>
</important>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify the deletion of the intended machine by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-delete-policy_manually-scaling-machineset">
<title>The compute machine set deletion policy</title>
<simpara><literal>Random</literal>, <literal>Newest</literal>, and <literal>Oldest</literal> are the three supported deletion options. The default is <literal>Random</literal>, meaning that random machines are chosen and deleted when scaling compute machine sets down. The deletion policy can be set according to the use case by modifying the particular compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  deletePolicy: &lt;delete_policy&gt;
  replicas: &lt;desired_replica_count&gt;</programlisting>
<simpara>Specific machines can also be prioritized for deletion by adding the annotation <literal>machine.openshift.io/delete-machine=true</literal> to the machine of interest, regardless of the deletion policy.</simpara>
<important>
<simpara>By default, the OpenShift Container Platform router pods are deployed on workers. Because the router is required to access some cluster resources, including the web console, do not scale the worker compute machine set to <literal>0</literal> unless you first relocate the router pods.</simpara>
</important>
<note>
<simpara>Custom compute machine sets can be used for use cases requiring that services run on specific nodes and that those services are ignored by the controller when the worker compute machine sets are scaling down. This prevents service disruption.</simpara>
</note>
</section>
<section xml:id="additional-resources_manually-scaling-machineset" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="machine-lifecycle-hook-deletion_deleting-machine">Lifecycle hooks for the machine deletion phase</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="modifying-machineset">
<title>Modifying a compute machine set</title>

<simpara>You can modify a compute machine set, such as adding labels, changing the instance type, or changing block storage.</simpara>
<note>
<simpara>If you need to scale a compute machine set without making other changes, see <link linkend="manually-scaling-machineset">Manually scaling a compute machine set</link>.</simpara>
</note>
<section xml:id="machineset-modifying_modifying-machineset">
<title>Modifying a compute machine set by using the CLI</title>
<simpara>When you modify a compute machine set, your changes only apply to compute machines that are created after you save the updated <literal>MachineSet</literal> custom resource (CR).
The changes do not affect existing machines.
You can replace the existing machines with new ones that reflect the updated configuration by scaling the compute machine set.</simpara>
<simpara>If you need to scale a compute machine set without making other changes, you do not need to delete the machines.</simpara>
<note>
<simpara>By default, the OpenShift Container Platform router pods are deployed on compute machines.
Because the router is required to access some cluster resources, including the web console, do not scale the compute machine set to <literal>0</literal> unless you first relocate the router pods.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your OpenShift Container Platform cluster uses the Machine API.</simpara>
</listitem>
<listitem>
<simpara>You are logged in to the cluster as an administrator by using the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the compute machine set by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine_set_name&gt; -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Note the value of the <literal>spec.replicas</literal> field, as you need it when scaling the machine set to apply the changes.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machine_set_name&gt;
  namespace: openshift-machine-api
spec:
  replicas: 2 <co xml:id="CO51-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO51-1">
<para>The examples in this procedure show a compute machine set that has a <literal>replicas</literal> value of <literal>2</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the compute machine set CR with the configuration options that you want and save your changes.</simpara>
</listitem>
<listitem>
<simpara>List the machines that are managed by the updated compute machine set by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-machine-api machines -l machine.openshift.io/cluster-api-machineset=&lt;machine_set_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                        PHASE     TYPE         REGION      ZONE         AGE
&lt;machine_name_original_1&gt;   Running   m6i.xlarge   us-west-1   us-west-1a   4h
&lt;machine_name_original_2&gt;   Running   m6i.xlarge   us-west-1   us-west-1a   4h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>For each machine that is managed by the updated compute machine set, set the <literal>delete</literal> annotation by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate machine/&lt;machine_name_original_1&gt; \
  -n openshift-machine-api \
  machine.openshift.io/delete-machine="true"</programlisting>
</listitem>
<listitem>
<simpara>Scale the compute machine set to twice the number of replicas by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=4 \<co xml:id="CO52-1"/>
  machineset &lt;machine_set_name&gt; \
  -n openshift-machine-api</programlisting>
<calloutlist>
<callout arearefs="CO52-1">
<para>The original example value of <literal>2</literal> is doubled to <literal>4</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>List the machines that are managed by the updated compute machine set by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-machine-api machines -l machine.openshift.io/cluster-api-machineset=&lt;machine_set_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                        PHASE          TYPE         REGION      ZONE         AGE
&lt;machine_name_original_1&gt;   Running        m6i.xlarge   us-west-1   us-west-1a   4h
&lt;machine_name_original_2&gt;   Running        m6i.xlarge   us-west-1   us-west-1a   4h
&lt;machine_name_updated_1&gt;    Provisioned    m6i.xlarge   us-west-1   us-west-1a   55s
&lt;machine_name_updated_2&gt;    Provisioning   m6i.xlarge   us-west-1   us-west-1a   55s</programlisting>
</para>
</formalpara>
<simpara>When the new machines are in the <literal>Running</literal> phase, you can scale the compute machine set to the original number of replicas.</simpara>
</listitem>
<listitem>
<simpara>Scale the compute machine set to the original number of replicas by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=2 \<co xml:id="CO53-1"/>
  machineset &lt;machine_set_name&gt; \
  -n openshift-machine-api</programlisting>
<calloutlist>
<callout arearefs="CO53-1">
<para>The original example value of <literal>2</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the compute machines without the updated configuration are deleted, list the machines that are managed by the updated compute machine set by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-machine-api machines -l machine.openshift.io/cluster-api-machineset=&lt;machine_set_name&gt;</programlisting>
<formalpara>
<title>Example output while deletion is in progress</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                        PHASE           TYPE         REGION      ZONE         AGE
&lt;machine_name_original_1&gt;   Deleting        m6i.xlarge   us-west-1   us-west-1a   4h
&lt;machine_name_original_2&gt;   Deleting        m6i.xlarge   us-west-1   us-west-1a   4h
&lt;machine_name_updated_1&gt;    Running         m6i.xlarge   us-west-1   us-west-1a   5m41s
&lt;machine_name_updated_2&gt;    Running         m6i.xlarge   us-west-1   us-west-1a   5m41s</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output when deletion is complete</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                        PHASE           TYPE         REGION      ZONE         AGE
&lt;machine_name_updated_1&gt;    Running         m6i.xlarge   us-west-1   us-west-1a   6m30s
&lt;machine_name_updated_2&gt;    Running         m6i.xlarge   us-west-1   us-west-1a   6m30s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To verify that a machine created by the updated machine set has the correct configuration, examine the relevant fields in the CR for one of the new machines by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machine &lt;machine_name_updated_1&gt; -n openshift-machine-api</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="machine-lifecycle-hook-deletion_deleting-machine">Lifecycle hooks for the machine deletion phase</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="machineset-manually-scaling_manually-scaling-machineset">Scaling a compute machine set manually</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-scheduler-about">Controlling pod placement using the scheduler</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="machine-phases-lifecycle">
<title>Machine phases and lifecycle</title>

<simpara>Machines move through a <emphasis>lifecycle</emphasis> that has several defined phases. Understanding the machine lifecycle and its phases can help you verify whether a procedure is complete or troubleshoot undesired behavior. In OpenShift Container Platform, the machine lifecycle is consistent across all supported cloud providers.</simpara>
<section xml:id="machine-about-phases_machine-phases-lifecycle">
<title>Machine phases</title>
<simpara>As a machine moves through its lifecycle, it passes through different phases. Each phase is a basic representation of the state of the machine.</simpara>
<variablelist>
<varlistentry>
<term><literal>Provisioning</literal></term>
<listitem>
<simpara>There is a request to provision a new machine. The machine does not yet exist and does not have an instance, a provider ID, or an address.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Provisioned</literal></term>
<listitem>
<simpara>The machine exists and has a provider ID or an address. The cloud provider has created an instance for the machine. The machine has not yet become a node and the <literal>status.nodeRef</literal> section of the machine object is not yet populated.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Running</literal></term>
<listitem>
<simpara>The machine exists and has a provider ID or address. Ignition has run successfully and the cluster machine approver has approved a certificate signing request (CSR). The machine has become a node and the <literal>status.nodeRef</literal> section of the machine object contains node details.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Deleting</literal></term>
<listitem>
<simpara>There is a request to delete the machine. The machine object has a <literal>DeletionTimestamp</literal> field that indicates the time of the deletion request.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Failed</literal></term>
<listitem>
<simpara>There is an unrecoverable problem with the machine. This can happen, for example, if the cloud provider deletes the instance for the machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="machine-about-lifecycle_machine-phases-lifecycle">
<title>The machine lifecycle</title>
<simpara>The lifecycle begins with the request to provision a machine and continues until the machine no longer exists.</simpara>
<simpara>The machine lifecycle proceeds in the following order. Interruptions due to errors or lifecycle hooks are not included in this overview.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>There is a request to provision a new machine for one of the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>A cluster administrator scales a machine set such that it requires additional machines.</simpara>
</listitem>
<listitem>
<simpara>An autoscaling policy scales machine set such that it requires additional machines.</simpara>
</listitem>
<listitem>
<simpara>A machine that is managed by a machine set fails or is deleted and the machine set creates a replacement to maintain the required number of machines.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The machine enters the <literal>Provisioning</literal> phase.</simpara>
</listitem>
<listitem>
<simpara>The infrastructure provider creates an instance for the machine.</simpara>
</listitem>
<listitem>
<simpara>The machine has a provider ID or address and enters the <literal>Provisioned</literal> phase.</simpara>
</listitem>
<listitem>
<simpara>The Ignition configuration file is processed.</simpara>
</listitem>
<listitem>
<simpara>The kubelet issues a certificate signing request (CSR).</simpara>
</listitem>
<listitem>
<simpara>The cluster machine approver approves the CSR.</simpara>
</listitem>
<listitem>
<simpara>The machine becomes a node and enters the <literal>Running</literal> phase.</simpara>
</listitem>
<listitem>
<simpara>An existing machine is slated for deletion for one of the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>A user with <literal>cluster-admin</literal> permissions uses the <literal>oc delete machine</literal> command.</simpara>
</listitem>
<listitem>
<simpara>The machine gets a <literal>machine.openshift.io/delete-machine</literal> annotation.</simpara>
</listitem>
<listitem>
<simpara>The machine set that manages the machine marks it for deletion to reduce the replica count as part of reconciliation.</simpara>
</listitem>
<listitem>
<simpara>The cluster autoscaler identifies a node that is unnecessary to meet the deployment needs of the cluster.</simpara>
</listitem>
<listitem>
<simpara>A machine health check is configured to replace an unhealthy machine.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The machine enters the <literal>Deleting</literal> phase, in which it is marked for deletion but is still present in the API.</simpara>
</listitem>
<listitem>
<simpara>The machine controller removes the instance from the infrastructure provider.</simpara>
</listitem>
<listitem>
<simpara>The machine controller deletes the <literal>Node</literal> object.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machine-determine-phase_machine-phases-lifecycle">
<title>Determining the phase of a machine</title>
<simpara>You can find the phase of a machine by using the OpenShift CLI (<literal>oc</literal>) or by using the web console. You can use this information to verify whether a procedure is complete or to troubleshoot undesired behavior.</simpara>
<section xml:id="machine-determine-phase-cli_machine-phases-lifecycle">
<title>Determining the phase of a machine by using the CLI</title>
<simpara>You can find the phase of a machine by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an OpenShift Container Platform cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc</literal> CLI.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>List the machines on the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machine -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                                      PHASE     TYPE         REGION      ZONE         AGE
mycluster-5kbsp-master-0                  Running   m6i.xlarge   us-west-1   us-west-1a   4h55m
mycluster-5kbsp-master-1                  Running   m6i.xlarge   us-west-1   us-west-1b   4h55m
mycluster-5kbsp-master-2                  Running   m6i.xlarge   us-west-1   us-west-1a   4h55m
mycluster-5kbsp-worker-us-west-1a-fmx8t   Running   m6i.xlarge   us-west-1   us-west-1a   4h51m
mycluster-5kbsp-worker-us-west-1a-m889l   Running   m6i.xlarge   us-west-1   us-west-1a   4h51m
mycluster-5kbsp-worker-us-west-1b-c8qzm   Running   m6i.xlarge   us-west-1   us-west-1b   4h51m</programlisting>
</para>
</formalpara>
<simpara>The <literal>PHASE</literal> column of the output contains the phase of each machine.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-determine-phase-gui_machine-phases-lifecycle">
<title>Determining the phase of a machine by using the web console</title>
<simpara>You can find the phase of a machine by using the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an OpenShift Container Platform cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Machines</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Machines</emphasis> page, select the name of the machine that you want to find the phase of.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Machine details</emphasis> page, select the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>In the YAML block, find the value of the <literal>status.phase</literal> field.</simpara>
<formalpara>
<title>Example YAML snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  name: mycluster-5kbsp-worker-us-west-1a-fmx8t
# ...
status:
  phase: Running <co xml:id="CO54-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>In this example, the phase is <literal>Running</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="machine-lifecycle-hook-deletion_deleting-machine">Lifecycle hooks for the machine deletion phase</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="deleting-machine">
<title>Deleting a machine</title>

<simpara>You can delete a specific machine.</simpara>
<section xml:id="machine-delete_deleting-machine">
<title>Deleting a specific machine</title>
<simpara>You can delete a specific machine.</simpara>
<important>
<simpara>Do not delete a control plane machine unless your cluster uses a control plane machine set.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the machines that are in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machine -n openshift-machine-api</programlisting>
<simpara>The command output contains a list of machines in the <literal>&lt;clusterid&gt;-&lt;role&gt;-&lt;cloud_region&gt;</literal> format.</simpara>
</listitem>
<listitem>
<simpara>Identify the machine that you want to delete.</simpara>
</listitem>
<listitem>
<simpara>Delete the machine by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete machine &lt;machine&gt; -n openshift-machine-api</programlisting>
<important>
<simpara>By default, the machine controller tries to drain the node that is backed by the machine until it succeeds. In some situations, such as with a misconfigured pod disruption budget, the drain operation might not be able to succeed. If the drain operation fails, the machine controller cannot proceed removing the machine.</simpara>
<simpara>You can skip draining the node by annotating <literal>machine.openshift.io/exclude-node-draining</literal> in a specific machine.</simpara>
</important>
<simpara>If the machine that you delete belongs to a machine set, a new machine is immediately created to satisfy the specified number of replicas.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machine-lifecycle-hook-deletion_deleting-machine">
<title>Lifecycle hooks for the machine deletion phase</title>
<simpara>Machine lifecycle hooks are points in the reconciliation lifecycle of a machine where the normal lifecycle process can be interrupted. In the machine <literal>Deleting</literal> phase, these interruptions provide the opportunity for components to modify the machine deletion process.</simpara>
<section xml:id="machine-lifecycle-hook-deletion-terms_deleting-machine">
<title>Terminology and definitions</title>
<simpara>To understand the behavior of lifecycle hooks for the machine deletion phase, you must understand the following concepts:</simpara>
<variablelist>
<varlistentry>
<term>Reconciliation</term>
<listitem>
<simpara>Reconciliation is the process by which a controller attempts to make the real state of the cluster and the objects that it comprises match the requirements in an object specification.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine controller</term>
<listitem>
<simpara>The machine controller manages the reconciliation lifecycle for a machine. For machines on cloud platforms, the machine controller is the combination of an OpenShift Container Platform controller and a platform-specific actuator from the cloud provider.</simpara>
<simpara>In the context of machine deletion, the machine controller performs the following actions:</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<listitem>
<simpara>Drain the node that is backed by the machine.</simpara>
</listitem>
<listitem>
<simpara>Delete the machine instance from the cloud provider.</simpara>
</listitem>
<listitem>
<simpara>Delete the <literal>Node</literal> object.</simpara>
</listitem>
</itemizedlist>
<variablelist>
<varlistentry>
<term>Lifecycle hook</term>
<listitem>
<simpara>A lifecycle hook is a defined point in the reconciliation lifecycle of an object where the normal lifecycle process can be interrupted. Components can use a lifecycle hook to inject changes into the process to accomplish a desired outcome.</simpara>
<simpara>There are two lifecycle hooks in the machine <literal>Deleting</literal> phase:</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<listitem>
<simpara><literal>preDrain</literal> lifecycle hooks must be resolved before the node that is backed by the machine can be drained.</simpara>
</listitem>
<listitem>
<simpara><literal>preTerminate</literal> lifecycle hooks must be resolved before the instance can be removed from the infrastructure provider.</simpara>
</listitem>
</itemizedlist>
<variablelist>
<varlistentry>
<term>Hook-implementing controller</term>
<listitem>
<simpara>A hook-implementing controller is a controller, other than the machine controller, that can interact with a lifecycle hook. A hook-implementing controller can do one or more of the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Add a lifecycle hook.</simpara>
</listitem>
<listitem>
<simpara>Respond to a lifecycle hook.</simpara>
</listitem>
<listitem>
<simpara>Remove a lifecycle hook.</simpara>
</listitem>
</itemizedlist>
<simpara>Each lifecycle hook has a single hook-implementing controller, but a hook-implementing controller can manage one or more hooks.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="machine-lifecycle-hook-deletion-order_deleting-machine">
<title>Machine deletion processing order</title>
<simpara>In OpenShift Container Platform 4.14, there are two lifecycle hooks for the machine deletion phase: <literal>preDrain</literal> and <literal>preTerminate</literal>. When all hooks for a given lifecycle point are removed, reconciliation continues as normal.</simpara>
<figure>
<title>Machine deletion flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/310_OpenShift_machine_deletion_hooks_0223.png"/>
</imageobject>
<textobject><phrase>The sequence of events in the machine `Deleting` phase.</phrase></textobject>
</mediaobject>
</figure>
<simpara>The machine <literal>Deleting</literal> phase proceeds in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>An existing machine is slated for deletion for one of the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>A user with <literal>cluster-admin</literal> permissions uses the <literal>oc delete machine</literal> command.</simpara>
</listitem>
<listitem>
<simpara>The machine gets a <literal>machine.openshift.io/delete-machine</literal> annotation.</simpara>
</listitem>
<listitem>
<simpara>The machine set that manages the machine marks it for deletion to reduce the replica count as part of reconciliation.</simpara>
</listitem>
<listitem>
<simpara>The cluster autoscaler identifies a node that is unnecessary to meet the deployment needs of the cluster.</simpara>
</listitem>
<listitem>
<simpara>A machine health check is configured to replace an unhealthy machine.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The machine enters the <literal>Deleting</literal> phase, in which it is marked for deletion but is still present in the API.</simpara>
</listitem>
<listitem>
<simpara>If a <literal>preDrain</literal> lifecycle hook exists, the hook-implementing controller that manages it does a specified action.</simpara>
<simpara>Until all <literal>preDrain</literal> lifecycle hooks are satisfied, the machine status condition <literal>Drainable</literal> is set to <literal>False</literal>.</simpara>
</listitem>
<listitem>
<simpara>There are no unresolved <literal>preDrain</literal> lifecycle hooks and the machine status condition <literal>Drainable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller attempts to drain the node that is backed by the machine.</simpara>
<itemizedlist>
<listitem>
<simpara>If draining fails, <literal>Drained</literal> is set to <literal>False</literal> and the machine controller attempts to drain the node again.</simpara>
</listitem>
<listitem>
<simpara>If draining succeeds, <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The machine status condition <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>If a <literal>preTerminate</literal>  lifecycle hook exists, the hook-implementing controller that manages it does a specified action.</simpara>
<simpara>Until all <literal>preTerminate</literal> lifecycle hooks are satisfied, the machine status condition <literal>Terminable</literal> is set to <literal>False</literal>.</simpara>
</listitem>
<listitem>
<simpara>There are no unresolved <literal>preTerminate</literal> lifecycle hooks and the machine status condition <literal>Terminable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller removes the instance from the infrastructure provider.</simpara>
</listitem>
<listitem>
<simpara>The machine controller deletes the <literal>Node</literal> object.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machine-lifecycle-hook-deletion-format_deleting-machine">
<title>Deletion lifecycle hook configuration</title>
<simpara>The following YAML snippets demonstrate the format and placement of deletion lifecycle hook configurations within a machine set:</simpara>
<formalpara>
<title>YAML snippet demonstrating a <literal>preDrain</literal> lifecycle hook</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  ...
spec:
  lifecycleHooks:
    preDrain:
    - name: &lt;hook_name&gt; <co xml:id="CO55-1"/>
      owner: &lt;hook_owner&gt; <co xml:id="CO55-2"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO55-1">
<para>The name of the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
<callout arearefs="CO55-2">
<para>The hook-implementing controller that manages the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
</calloutlist>
<formalpara>
<title>YAML snippet demonstrating a <literal>preTerminate</literal> lifecycle hook</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  ...
spec:
  lifecycleHooks:
    preTerminate:
    - name: &lt;hook_name&gt; <co xml:id="CO56-1"/>
      owner: &lt;hook_owner&gt; <co xml:id="CO56-2"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO56-1">
<para>The name of the <literal>preTerminate</literal> lifecycle hook.</para>
</callout>
<callout arearefs="CO56-2">
<para>The hook-implementing controller that manages the <literal>preTerminate</literal> lifecycle hook.</para>
</callout>
</calloutlist>
<bridgehead xml:id="machine-lifecycle-hook-deletion-example_deleting-machine" renderas="sect4">Example lifecycle hook configuration</bridgehead>
<simpara>The following example demonstrates the implementation of multiple fictional lifecycle hooks that interrupt the machine deletion process:</simpara>
<formalpara>
<title>Example configuration for lifecycle hooks</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  ...
spec:
  lifecycleHooks:
    preDrain: <co xml:id="CO57-1"/>
    - name: MigrateImportantApp
      owner: my-app-migration-controller
    preTerminate: <co xml:id="CO57-2"/>
    - name: BackupFileSystem
      owner: my-backup-controller
    - name: CloudProviderSpecialCase
      owner: my-custom-storage-detach-controller <co xml:id="CO57-3"/>
    - name: WaitForStorageDetach
      owner: my-custom-storage-detach-controller
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO57-1">
<para>A <literal>preDrain</literal> lifecycle hook stanza that contains a single lifecycle hook.</para>
</callout>
<callout arearefs="CO57-2">
<para>A <literal>preTerminate</literal> lifecycle hook stanza that contains three lifecycle hooks.</para>
</callout>
<callout arearefs="CO57-3">
<para>A hook-implementing controller that manages two <literal>preTerminate</literal> lifecycle hooks: <literal>CloudProviderSpecialCase</literal> and <literal>WaitForStorageDetach</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machine-lifecycle-hook-deletion-uses_deleting-machine">
<title>Machine deletion lifecycle hook examples for Operator developers</title>
<simpara>Operators can use lifecycle hooks for the machine deletion phase to modify the machine deletion process. The following examples demonstrate possible ways that an Operator can use this functionality.</simpara>
<bridgehead xml:id="machine-lifecycle-hook-deletion-uses-predrain_deleting-machine" renderas="sect4">Example use cases for <literal>preDrain</literal> lifecycle hooks</bridgehead>
<variablelist>
<varlistentry>
<term>Proactively replacing machines</term>
<listitem>
<simpara>An Operator can use a <literal>preDrain</literal> lifecycle hook to ensure that a replacement machine is successfully created and joined to the cluster before removing the instance of a deleted machine. This can mitigate the impact of disruptions during machine replacement or of replacement instances that do not initialize promptly.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Implementing custom draining logic</term>
<listitem>
<simpara>An Operator can use a <literal>preDrain</literal> lifecycle hook to replace the machine controller draining logic with a different draining controller. By replacing the draining logic, the Operator would have more flexibility and control over the lifecycle of the workloads on each node.</simpara>
<simpara>For example, the machine controller drain libraries do not support ordering, but a custom drain provider could provide this functionality. By using a custom drain provider, an Operator could prioritize moving mission-critical applications before draining the node to ensure that service interruptions are minimized in cases where cluster capacity is limited.</simpara>
</listitem>
</varlistentry>
</variablelist>
<bridgehead xml:id="machine-lifecycle-hook-deletion-uses-preterminate_deleting-machine" renderas="sect4">Example use cases for <literal>preTerminate</literal> lifecycle hooks</bridgehead>
<variablelist>
<varlistentry>
<term>Verifying storage detachment</term>
<listitem>
<simpara>An Operator can use a <literal>preTerminate</literal> lifecycle hook to ensure that storage that is attached to a machine is detached before the machine is removed from the infrastructure provider.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Improving log reliability</term>
<listitem>
<simpara>After a node is drained, the log exporter daemon requires some time to synchronize logs to the centralized logging system.</simpara>
<simpara>A logging Operator can use a <literal>preTerminate</literal> lifecycle hook to add a delay between when the node drains and when the machine is removed from the infrastructure provider. This delay would provide time for the Operator to ensure that the main workloads are removed and no longer adding to the log backlog. When no new data is being added to the log backlog, the log exporter can catch up on the synchronization process, thus ensuring that all application logs are captured.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="machine-lifecycle-hook-deletion-etcd_deleting-machine">
<title>Quorum protection with machine lifecycle hooks</title>
<simpara>For OpenShift Container Platform clusters that use the Machine API Operator, the etcd Operator uses lifecycle hooks for the machine deletion phase to implement a quorum protection mechanism.</simpara>
<simpara>By using a <literal>preDrain</literal> lifecycle hook, the etcd Operator can control when the pods on a control plane machine are drained and removed. To protect etcd quorum, the etcd Operator prevents the removal of an etcd member until it migrates that member onto a new node within the cluster.</simpara>
<simpara>This mechanism allows the etcd Operator precise control over the members of the etcd quorum and allows the Machine API Operator to safely create and remove control plane machines without specific operational knowledge of the etcd cluster.</simpara>
<section xml:id="machine-lifecycle-hook-deletion-etcd-order_deleting-machine">
<title>Control plane deletion with quorum protection processing order</title>
<simpara>When a control plane machine is replaced on a cluster that uses a control plane machine set, the cluster temporarily has four control plane machines. When the fourth control plane node joins the cluster, the etcd Operator starts a new etcd member on the replacement node. When the etcd Operator observes that the old control plane machine is marked for deletion, it stops the etcd member on the old node and promotes the replacement etcd member to join the quorum of the cluster.</simpara>
<simpara>The control plane machine <literal>Deleting</literal> phase proceeds in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A control plane machine is slated for deletion.</simpara>
</listitem>
<listitem>
<simpara>The control plane machine enters the <literal>Deleting</literal> phase.</simpara>
</listitem>
<listitem>
<simpara>To satisfy the <literal>preDrain</literal> lifecycle hook, the etcd Operator takes the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>The etcd Operator waits until a fourth control plane machine is added to the cluster as an etcd member. This new etcd member has a state of <literal>Running</literal> but not <literal>ready</literal> until it receives the full database update from the etcd leader.</simpara>
</listitem>
<listitem>
<simpara>When the new etcd member receives the full database update, the etcd Operator promotes the new etcd member to a voting member and removes the old etcd member from the cluster.</simpara>
</listitem>
</orderedlist>
<simpara>After this transition is complete, it is safe for the old etcd pod and its data to be removed, so the <literal>preDrain</literal> lifecycle hook is removed.</simpara>
</listitem>
<listitem>
<simpara>The control plane machine status condition <literal>Drainable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller attempts to drain the node that is backed by the control plane machine.</simpara>
<itemizedlist>
<listitem>
<simpara>If draining fails, <literal>Drained</literal> is set to <literal>False</literal> and the machine controller attempts to drain the node again.</simpara>
</listitem>
<listitem>
<simpara>If draining succeeds, <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The control plane machine status condition <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>If no other Operators have added a <literal>preTerminate</literal> lifecycle hook, the control plane machine status condition <literal>Terminable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller removes the instance from the infrastructure provider.</simpara>
</listitem>
<listitem>
<simpara>The machine controller deletes the <literal>Node</literal> object.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>YAML snippet demonstrating the etcd quorum protection <literal>preDrain</literal> lifecycle hook</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  ...
spec:
  lifecycleHooks:
    preDrain:
    - name: EtcdQuorumOperator <co xml:id="CO58-1"/>
      owner: clusteroperator/etcd <co xml:id="CO58-2"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO58-1">
<para>The name of the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
<callout arearefs="CO58-2">
<para>The hook-implementing controller that manages the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
</calloutlist>
</section>
</section>
</section>
<section xml:id="additional-resources_unhealthy-etcd-member" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="machine-phases-lifecycle">Machine phases and lifecycle</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/backup_and_restore/#replacing-unhealthy-etcd-member">Replacing an unhealthy etcd member</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-using">Managing control plane machines with control plane machine sets</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="applying-autoscaling">
<title>Applying autoscaling to an OpenShift Container Platform cluster</title>

<simpara>Applying autoscaling to an OpenShift Container Platform cluster involves deploying a cluster autoscaler and then deploying machine autoscalers for each machine type in your cluster.</simpara>
<important>
<simpara>You can configure the cluster autoscaler only in clusters where the Machine API Operator is operational.</simpara>
</important>
<section xml:id="cluster-autoscaler-about_applying-autoscaling">
<title>About the cluster autoscaler</title>
<simpara>The cluster autoscaler adjusts the size of an OpenShift Container Platform cluster to meet its current deployment needs. It uses declarative, Kubernetes-style arguments to provide infrastructure management that does not rely on objects of a specific cloud provider. The cluster autoscaler has a cluster scope, and is not associated with a particular namespace.</simpara>
<simpara>The cluster autoscaler increases the size of the cluster when there are pods that fail to schedule on any of the current worker nodes due to insufficient resources or when another node is necessary to meet deployment needs. The cluster autoscaler does not increase the cluster resources beyond the limits that you specify.</simpara>
<simpara>The cluster autoscaler computes the total
memory, CPU, and GPU
on all nodes the cluster, even though it does not manage the control plane nodes. These values are not single-machine oriented. They are an aggregation of all the resources in the entire cluster. For example, if you set the maximum memory resource limit, the cluster autoscaler includes all the nodes in the cluster when calculating the current memory usage. That calculation is then used to determine if the cluster autoscaler has the capacity to add more worker resources.</simpara>
<important>
<simpara>Ensure that the <literal>maxNodesTotal</literal> value in the <literal>ClusterAutoscaler</literal> resource definition that you create is large enough to account for the total possible number of machines in your cluster. This value must encompass the number of control plane machines and the possible number of compute machines that you might scale to.</simpara>
</important>
<simpara>Every 10 seconds, the cluster autoscaler checks which nodes are unnecessary in the cluster and removes them. The cluster autoscaler considers a node for removal if the following conditions apply:</simpara>
<itemizedlist>
<listitem>
<simpara>The node utilization is less than the <emphasis>node utilization level</emphasis> threshold for the cluster. The node utilization level is the sum of the requested resources divided by the allocated resources for the node. If you do not specify a value in the <literal>ClusterAutoscaler</literal> custom resource, the cluster autoscaler uses a default value of <literal>0.5</literal>, which corresponds to 50% utilization.</simpara>
</listitem>
<listitem>
<simpara>The cluster autoscaler can move all pods running on the node to the other nodes. The Kubernetes scheduler is responsible for scheduling pods on the nodes.</simpara>
</listitem>
<listitem>
<simpara>The cluster autoscaler does not have scale down disabled annotation.</simpara>
</listitem>
</itemizedlist>
<simpara>If the following types of pods are present on a node, the cluster autoscaler will not remove the node:</simpara>
<itemizedlist>
<listitem>
<simpara>Pods with restrictive pod disruption budgets (PDBs).</simpara>
</listitem>
<listitem>
<simpara>Kube-system pods that do not run on the node by default.</simpara>
</listitem>
<listitem>
<simpara>Kube-system pods that do not have a PDB or have a PDB that is too restrictive.</simpara>
</listitem>
<listitem>
<simpara>Pods that are not backed by a controller object such as a deployment, replica set, or stateful set.</simpara>
</listitem>
<listitem>
<simpara>Pods with local storage.</simpara>
</listitem>
<listitem>
<simpara>Pods that cannot be moved elsewhere because of a lack of resources, incompatible node selectors or affinity, matching anti-affinity, and so on.</simpara>
</listitem>
<listitem>
<simpara>Unless they also have a <literal>"cluster-autoscaler.kubernetes.io/safe-to-evict": "true"</literal> annotation, pods that have a <literal>"cluster-autoscaler.kubernetes.io/safe-to-evict": "false"</literal> annotation.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, you set the maximum CPU limit to 64 cores and configure the cluster autoscaler to only create machines that have 8 cores each. If your cluster starts with 30 cores, the cluster autoscaler can add up to 4 more nodes with 32 cores, for a total of 62.</simpara>
<simpara>If you configure the cluster autoscaler, additional usage restrictions apply:</simpara>
<itemizedlist>
<listitem>
<simpara>Do not modify the nodes that are in autoscaled node groups directly. All nodes within the same node group have the same capacity and labels and run the same system pods.</simpara>
</listitem>
<listitem>
<simpara>Specify requests for your pods.</simpara>
</listitem>
<listitem>
<simpara>If you have to prevent pods from being deleted too quickly, configure appropriate PDBs.</simpara>
</listitem>
<listitem>
<simpara>Confirm that your cloud provider quota is large enough to support the maximum node pools that you configure.</simpara>
</listitem>
<listitem>
<simpara>Do not run additional node group autoscalers, especially the ones offered by your cloud provider.</simpara>
</listitem>
</itemizedlist>
<simpara>The horizontal pod autoscaler (HPA) and the cluster autoscaler modify cluster resources in different ways. The HPA changes the deployment&#8217;s or replica set&#8217;s number of replicas based on the current CPU load. If the load increases, the HPA creates new replicas, regardless of the amount of resources available to the cluster. If there are not enough resources, the cluster autoscaler adds resources so that the HPA-created pods can run. If the load decreases, the HPA stops some replicas. If this action causes some nodes to be underutilized or completely empty, the cluster autoscaler deletes the unnecessary nodes.</simpara>
<simpara>The cluster autoscaler takes pod priorities into account. The Pod Priority and Preemption feature enables scheduling pods based on priorities if the cluster does not have enough resources, but the cluster autoscaler ensures that the cluster has resources to run all pods. To honor the intention of both features, the cluster autoscaler includes a priority cutoff function. You can use this cutoff to schedule "best-effort" pods, which do not cause the cluster autoscaler to increase resources but instead run only when spare resources are available.</simpara>
<simpara>Pods with priority lower than the cutoff value do not cause the cluster to scale up or prevent the cluster from scaling down. No new nodes are added to run the pods, and nodes running these pods might be deleted to free resources.</simpara>
<simpara>Cluster autoscaling is supported for the platforms that have machine API available on it.</simpara>
</section>
<section xml:id="configuring-clusterautoscaler_applying-autoscaling">
<title>Configuring the cluster autoscaler</title>
<simpara>First, deploy the cluster autoscaler to manage automatic resource scaling in your OpenShift Container Platform cluster.</simpara>
<note>
<simpara>Because the cluster autoscaler is scoped to the entire cluster, you can make only one cluster autoscaler for the cluster.</simpara>
</note>
<section xml:id="cluster-autoscaler-cr_applying-autoscaling">
<title>Cluster autoscaler resource definition</title>
<simpara>This <literal>ClusterAutoscaler</literal> resource definition shows the parameters and sample values for the cluster autoscaler.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "autoscaling.openshift.io/v1"
kind: "ClusterAutoscaler"
metadata:
  name: "default"
spec:
  podPriorityThreshold: -10 <co xml:id="CO59-1"/>
  resourceLimits:
    maxNodesTotal: 24 <co xml:id="CO59-2"/>
    cores:
      min: 8 <co xml:id="CO59-3"/>
      max: 128 <co xml:id="CO59-4"/>
    memory:
      min: 4 <co xml:id="CO59-5"/>
      max: 256 <co xml:id="CO59-6"/>
    gpus:
      - type: nvidia.com/gpu <co xml:id="CO59-7"/>
        min: 0 <co xml:id="CO59-8"/>
        max: 16 <co xml:id="CO59-9"/>
      - type: amd.com/gpu
        min: 0
        max: 4
  logVerbosity: 4 <co xml:id="CO59-10"/>
  scaleDown: <co xml:id="CO59-11"/>
    enabled: true <co xml:id="CO59-12"/>
    delayAfterAdd: 10m <co xml:id="CO59-13"/>
    delayAfterDelete: 5m <co xml:id="CO59-14"/>
    delayAfterFailure: 30s <co xml:id="CO59-15"/>
    unneededTime: 5m <co xml:id="CO59-16"/>
    utilizationThreshold: "0.4" <co xml:id="CO59-17"/></programlisting>
<calloutlist>
<callout arearefs="CO59-1">
<para>Specify the priority that a pod must exceed to cause the cluster autoscaler to deploy additional nodes. Enter a 32-bit integer value. The <literal>podPriorityThreshold</literal> value is compared to the value of the <literal>PriorityClass</literal> that you assign to each pod.</para>
</callout>
<callout arearefs="CO59-2">
<para>Specify the maximum number of nodes to deploy. This value is the total number of machines that are deployed in your cluster, not just the ones that the autoscaler controls. Ensure that this value is large enough to account for all of your control plane and compute machines and the total number of replicas that you specify in your <literal>MachineAutoscaler</literal> resources.</para>
</callout>
<callout arearefs="CO59-3">
<para>Specify the minimum number of cores to deploy in the cluster.</para>
</callout>
<callout arearefs="CO59-4">
<para>Specify the maximum number of cores to deploy in the cluster.</para>
</callout>
<callout arearefs="CO59-5">
<para>Specify the minimum amount of memory, in GiB, in the cluster.</para>
</callout>
<callout arearefs="CO59-6">
<para>Specify the maximum amount of memory, in GiB, in the cluster.</para>
</callout>
<callout arearefs="CO59-7">
<para>Optional: Specify the type of GPU node to deploy. Only <literal>nvidia.com/gpu</literal> and <literal>amd.com/gpu</literal> are valid types.</para>
</callout>
<callout arearefs="CO59-8">
<para>Specify the minimum number of GPUs to deploy in the cluster.</para>
</callout>
<callout arearefs="CO59-9">
<para>Specify the maximum number of GPUs to deploy in the cluster.</para>
</callout>
<callout arearefs="CO59-10">
<para>Specify the logging verbosity level between <literal>0</literal> and <literal>10</literal>. The following log level thresholds are provided for guidance:</para>
<itemizedlist>
<listitem>
<simpara><literal>1</literal>: (Default) Basic information about changes.</simpara>
</listitem>
<listitem>
<simpara><literal>4</literal>: Debug-level verbosity for troubleshooting typical issues.</simpara>
</listitem>
<listitem>
<simpara><literal>9</literal>: Extensive, protocol-level debugging information.</simpara>
</listitem>
</itemizedlist>
<simpara>If you do not specify a value, the default value of <literal>1</literal> is used.</simpara>
</callout>
<callout arearefs="CO59-11">
<para>In this section, you can specify the period to wait for each action by using any valid <link xlink:href="https://golang.org/pkg/time/#ParseDuration">ParseDuration</link> interval, including <literal>ns</literal>, <literal>us</literal>, <literal>ms</literal>, <literal>s</literal>, <literal>m</literal>, and <literal>h</literal>.</para>
</callout>
<callout arearefs="CO59-12">
<para>Specify whether the cluster autoscaler can remove unnecessary nodes.</para>
</callout>
<callout arearefs="CO59-13">
<para>Optional: Specify the period to wait before deleting a node after a node has recently been <emphasis>added</emphasis>. If you do not specify a value, the default value of <literal>10m</literal> is used.</para>
</callout>
<callout arearefs="CO59-14">
<para>Optional: Specify the period to wait before deleting a node after a node has recently been <emphasis>deleted</emphasis>. If you do not specify a value, the default value of <literal>0s</literal> is used.</para>
</callout>
<callout arearefs="CO59-15">
<para>Optional: Specify the period to wait before deleting a node after a scale down failure occurred. If you do not specify a value, the default value of <literal>3m</literal> is used.</para>
</callout>
<callout arearefs="CO59-16">
<para>Optional: Specify a period of time before an unnecessary node is eligible for deletion. If you do not specify a value, the default value of <literal>10m</literal> is used.</para>
</callout>
<callout arearefs="CO59-17">
<para>Optional:  Specify the <emphasis>node utilization level</emphasis>. Nodes below this utilization level are eligible for deletion. If you do not specify a value, the default value of <literal>10m</literal> is used.. The node utilization level is the sum of the requested resources divided by the allocated resources for the node, and must be a value greater than <literal>"0"</literal> but less than <literal>"1"</literal>. If you do not specify a value, the cluster autoscaler uses a default value of <literal>"0.5"</literal>, which corresponds to 50% utilization. This value must be expressed as a string.</para>
</callout>
</calloutlist>
<note>
<simpara>When performing a scaling operation, the cluster autoscaler remains within the ranges set in the <literal>ClusterAutoscaler</literal> resource definition, such as the minimum and maximum number of cores to deploy or the amount of memory in the cluster. However, the cluster autoscaler does not correct the current values in your cluster to be within those ranges.</simpara>
<simpara>The minimum and maximum CPUs, memory, and GPU values are determined by calculating those resources on all nodes in the cluster, even if the cluster autoscaler does not manage the nodes. For example, the control plane nodes are considered in the total memory in the cluster, even though the cluster autoscaler does not manage the control plane nodes.</simpara>
</note>
</section>
<section xml:id="ClusterAutoscaler-deploying_applying-autoscaling">
<title>Deploying a cluster autoscaler</title>
<simpara>To deploy a cluster autoscaler, you create an instance of the <literal>ClusterAutoscaler</literal> resource.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file for a <literal>ClusterAutoscaler</literal> resource that contains the custom resource definition.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml <co xml:id="CO60-1"/></programlisting>
<calloutlist>
<callout arearefs="CO60-1">
<para><literal>&lt;filename&gt;</literal> is the name of the custom resource file.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>After you configure the cluster autoscaler, you must <link linkend="configuring-machineautoscaler_applying-autoscaling">configure at least one machine autoscaler</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machine-autoscaler-about_applying-autoscaling">
<title>About the machine autoscaler</title>
<simpara>The machine autoscaler adjusts the number of Machines in the compute machine sets that you deploy in an OpenShift Container Platform cluster. You can scale both the default <literal>worker</literal> compute machine set and any other compute machine sets that you create. The machine autoscaler makes more Machines when the cluster runs out of resources to support more deployments. Any changes to the values in <literal>MachineAutoscaler</literal> resources, such as the minimum or maximum number of instances, are immediately applied to the compute machine set they target.</simpara>
<important>
<simpara>You must deploy a machine autoscaler for the cluster autoscaler to scale your machines. The cluster autoscaler uses the annotations on compute machine sets that the machine autoscaler sets to determine the resources that it can scale. If you define a cluster autoscaler without also defining machine autoscalers, the cluster autoscaler will never scale your cluster.</simpara>
</important>
</section>
<section xml:id="configuring-machineautoscaler_applying-autoscaling">
<title>Configuring machine autoscalers</title>
<simpara>After you deploy the cluster autoscaler, deploy <literal>MachineAutoscaler</literal> resources that reference the compute machine sets that are used to scale the cluster.</simpara>
<important>
<simpara>You must deploy at least one <literal>MachineAutoscaler</literal> resource after you deploy the <literal>ClusterAutoscaler</literal> resource.</simpara>
</important>
<note>
<simpara>You must configure separate resources for each compute machine set. Remember that compute machine sets are different in each region, so consider whether you want to enable machine scaling in multiple regions. The compute machine set that you scale must have at least one machine in it.</simpara>
</note>
<section xml:id="machine-autoscaler-cr_applying-autoscaling">
<title>Machine autoscaler resource definition</title>
<simpara>This <literal>MachineAutoscaler</literal> resource definition shows the parameters and sample values for the machine autoscaler.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "autoscaling.openshift.io/v1beta1"
kind: "MachineAutoscaler"
metadata:
  name: "worker-us-east-1a" <co xml:id="CO61-1"/>
  namespace: "openshift-machine-api"
spec:
  minReplicas: 1 <co xml:id="CO61-2"/>
  maxReplicas: 12 <co xml:id="CO61-3"/>
  scaleTargetRef: <co xml:id="CO61-4"/>
    apiVersion: machine.openshift.io/v1beta1
    kind: MachineSet <co xml:id="CO61-5"/>
    name: worker-us-east-1a <co xml:id="CO61-6"/></programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>Specify the machine autoscaler name. To make it easier to identify which compute machine set this machine autoscaler scales, specify or include the name of the compute machine set to scale. The compute machine set name takes the following form: <literal>&lt;clusterid&gt;-&lt;machineset&gt;-&lt;region&gt;</literal>.</para>
</callout>
<callout arearefs="CO61-2">
<para>Specify the minimum number machines of the specified type that must remain in the specified zone after the cluster autoscaler initiates cluster scaling. If running in AWS, GCP, Azure, RHOSP, or vSphere, this value can be set to <literal>0</literal>. For other providers, do not set this value to <literal>0</literal>.</para>
<simpara>You can save on costs by setting this value to <literal>0</literal> for use cases such as running expensive or limited-usage hardware that is used for specialized workloads, or by scaling a compute machine set with extra large machines. The cluster autoscaler scales the compute machine set down to zero if the machines are not in use.</simpara>
<important>
<simpara>Do not set the <literal>spec.minReplicas</literal> value to <literal>0</literal> for the three compute machine sets that are created during the OpenShift Container Platform installation process for an installer provisioned infrastructure.</simpara>
</important>
</callout>
<callout arearefs="CO61-3">
<para>Specify the maximum number machines of the specified type that the cluster autoscaler can deploy in the specified zone after it initiates cluster scaling. Ensure that the <literal>maxNodesTotal</literal> value in the <literal>ClusterAutoscaler</literal> resource definition is large enough to allow the machine autoscaler to deploy this number of machines.</para>
</callout>
<callout arearefs="CO61-4">
<para>In this section, provide values that describe the existing compute machine set to scale.</para>
</callout>
<callout arearefs="CO61-5">
<para>The <literal>kind</literal> parameter value is always <literal>MachineSet</literal>.</para>
</callout>
<callout arearefs="CO61-6">
<para>The <literal>name</literal> value must match the name of an existing compute machine set, as shown in the <literal>metadata.name</literal> parameter value.</para>
</callout>
</calloutlist>
</section>
<section xml:id="MachineAutoscaler-deploying_applying-autoscaling">
<title>Deploying a machine autoscaler</title>
<simpara>To deploy a machine autoscaler, you create an instance of the <literal>MachineAutoscaler</literal> resource.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file for a <literal>MachineAutoscaler</literal> resource that contains the custom resource definition.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml <co xml:id="CO62-1"/></programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para><literal>&lt;filename&gt;</literal> is the name of the custom resource file.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="disabling-autoscaling_applying-autoscaling">
<title>Disabling autoscaling</title>
<simpara>You can disable an individual machine autoscaler in your cluster or disable autoscaling on the cluster entirely.</simpara>
<section xml:id="deleting-machine-autoscaler_applying-autoscaling">
<title>Disabling a machine autoscaler</title>
<simpara>To disable a machine autoscaler, you delete the corresponding <literal>MachineAutoscaler</literal> custom resource (CR).</simpara>
<note>
<simpara>Disabling a machine autoscaler does not disable the cluster autoscaler. To disable the cluster autoscaler, follow the instructions in "Disabling the cluster autoscaler".</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the <literal>MachineAutoscaler</literal> CRs for the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MachineAutoscaler -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 REF KIND     REF NAME             MIN   MAX   AGE
compute-us-east-1a   MachineSet   compute-us-east-1a   1     12    39m
compute-us-west-1a   MachineSet   compute-us-west-1a   2     4     37m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Create a YAML file backup of the <literal>MachineAutoscaler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MachineAutoscaler/&lt;machine_autoscaler_name&gt; \<co xml:id="CO63-1"/>
  -n openshift-machine-api \
  -o yaml&gt; &lt;machine_autoscaler_name_backup&gt;.yaml <co xml:id="CO63-2"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para><literal>&lt;machine_autoscaler_name&gt;</literal> is the name of the CR that you want to delete.</para>
</callout>
<callout arearefs="CO63-2">
<para><literal>&lt;machine_autoscaler_name_backup&gt;</literal> is the name for the backup of the CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Delete the <literal>MachineAutoscaler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete MachineAutoscaler/&lt;machine_autoscaler_name&gt; -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineautoscaler.autoscaling.openshift.io "compute-us-east-1a" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the machine autoscaler is disabled, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MachineAutoscaler -n openshift-machine-api</programlisting>
<simpara>The disabled machine autoscaler does not appear in the list of machine autoscalers.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>If you need to re-enable the machine autoscaler, use the <literal>&lt;machine_autoscaler_name_backup&gt;.yaml</literal> backup file and follow the instructions in "Deploying a machine autoscaler".</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="deleting-cluster-autoscaler_applying-autoscaling">Disabling the cluster autoscaler</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="MachineAutoscaler-deploying_applying-autoscaling">Deploying a machine autoscaler</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="deleting-cluster-autoscaler_applying-autoscaling">
<title>Disabling the cluster autoscaler</title>
<simpara>To disable the cluster autoscaler, you delete the corresponding <literal>ClusterAutoscaler</literal> resource.</simpara>
<note>
<simpara>Disabling the cluster autoscaler disables autoscaling on the cluster, even if the cluster has existing machine autoscalers.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the <literal>ClusterAutoscaler</literal> resource for the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ClusterAutoscaler</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      AGE
default   42m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Create a YAML file backup of the <literal>ClusterAutoscaler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ClusterAutoscaler/default \<co xml:id="CO64-1"/>
  -o yaml&gt; &lt;cluster_autoscaler_backup_name&gt;.yaml <co xml:id="CO64-2"/></programlisting>
<calloutlist>
<callout arearefs="CO64-1">
<para><literal>default</literal> is the name of the <literal>ClusterAutoscaler</literal> CR.</para>
</callout>
<callout arearefs="CO64-2">
<para><literal>&lt;cluster_autoscaler_backup_name&gt;</literal> is the name for the backup of the CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Delete the <literal>ClusterAutoscaler</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete ClusterAutoscaler/default</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">clusterautoscaler.autoscaling.openshift.io "default" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the cluster autoscaler is disabled, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ClusterAutoscaler</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">No resources found</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Disabling the cluster autoscaler by deleting the <literal>ClusterAutoscaler</literal> CR prevents the cluster from autoscaling but does not delete any existing machine autoscalers on the cluster. To clean up unneeded machine autoscalers, see "Disabling a machine autoscaler".</simpara>
</listitem>
<listitem>
<simpara>If you need to re-enable the cluster autoscaler, use the <literal>&lt;cluster_autoscaler_name_backup&gt;.yaml</literal> backup file and follow the instructions in "Deploying a cluster autoscaler".</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="deleting-machine-autoscaler_applying-autoscaling">Disabling the machine autoscaler</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="ClusterAutoscaler-deploying_applying-autoscaling">Deploying a cluster autoscaler</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_additional-resources-2" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-pods-priority">Including pod priority in pod scheduling decisions in OpenShift Container Platform</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="creating-infrastructure-machinesets">
<title>Creating infrastructure machine sets</title>

<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<simpara>You can use infrastructure machine sets to create machines that host only infrastructure components, such as the default router, the integrated container image registry, and the components for cluster metrics and monitoring. These infrastructure machines are not counted toward the total number of subscriptions that are required to run the environment.</simpara>
<simpara>In a production deployment, it is recommended that you deploy at least three machine sets to hold infrastructure components. Both OpenShift Logging and Red Hat OpenShift Service Mesh deploy Elasticsearch, which requires three instances to be installed on different nodes. Each of these nodes can be deployed to different availability zones for high availability. This configuration requires three different machine sets, one for each availability zone. In global Azure regions that do not have multiple availability zones, you can use availability sets to ensure high availability.</simpara>
<section xml:id="infrastructure-components_creating-infrastructure-machinesets">
<title>OpenShift Container Platform infrastructure components</title>
<simpara>The following infrastructure workloads do not incur OpenShift Container Platform worker subscriptions:</simpara>
<itemizedlist>
<listitem>
<simpara>Kubernetes and OpenShift Container Platform control plane services that run on masters</simpara>
</listitem>
<listitem>
<simpara>The default router</simpara>
</listitem>
<listitem>
<simpara>The integrated container image registry</simpara>
</listitem>
<listitem>
<simpara>The HAProxy-based Ingress Controller</simpara>
</listitem>
<listitem>
<simpara>The cluster metrics collection, or monitoring service, including components for monitoring user-defined projects</simpara>
</listitem>
<listitem>
<simpara>Cluster aggregated logging</simpara>
</listitem>
<listitem>
<simpara>Service brokers</simpara>
</listitem>
<listitem>
<simpara>Red Hat Quay</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Data Foundation</simpara>
</listitem>
<listitem>
<simpara>Red Hat Advanced Cluster Manager</simpara>
</listitem>
<listitem>
<simpara>Red Hat Advanced Cluster Security for Kubernetes</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift GitOps</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Pipelines</simpara>
</listitem>
</itemizedlist>
<simpara>Any node that runs any other container, pod, or component is a worker node that your subscription must cover.</simpara>
<simpara>For information about infrastructure nodes and which components can run on infrastructure nodes, see the "Red Hat OpenShift control plane and infrastructure nodes" section in the <link xlink:href="https://www.redhat.com/en/resources/openshift-subscription-sizing-guide">OpenShift sizing and subscription guide for enterprise Kubernetes</link> document.</simpara>
<simpara>To create an infrastructure node, you can <link linkend="machineset-creating_creating-infrastructure-machinesets">use a machine set</link>, <link linkend="creating-an-infra-node_creating-infrastructure-machinesets">label the node</link>, or <link linkend="creating-infra-machines_creating-infrastructure-machinesets">use a machine config pool</link>.</simpara>
</section>
<section xml:id="creating-infrastructure-machinesets-production">
<title>Creating infrastructure machine sets for production environments</title>
<simpara>In a production deployment, it is recommended that you deploy at least three compute machine sets to hold infrastructure components. Both OpenShift Logging and Red Hat OpenShift Service Mesh deploy Elasticsearch, which requires three instances to be installed on different nodes. Each of these nodes can be deployed to different availability zones for high availability. A configuration like this requires three different compute machine sets, one for each availability zone. In global Azure regions that do not have multiple availability zones, you can use availability sets to ensure high availability.</simpara>
<section xml:id="creating-infrastructure-machinesets-clouds">
<title>Creating infrastructure machine sets for different clouds</title>
<simpara>Use the sample compute machine set for your cloud.</simpara>
<section xml:id="machineset-yaml-alibaba_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on Alibaba Cloud</title>
<simpara>This sample YAML defines a compute machine set that runs in a specified Alibaba Cloud zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO65-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO65-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO65-3"/>
  name: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt; <co xml:id="CO65-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO65-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt; <co xml:id="CO65-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO65-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO65-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO65-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt; <co xml:id="CO65-10"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/infra: ""
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1
          credentialsSecret:
            name: alibabacloud-credentials
          imageId: &lt;image_id&gt; <co xml:id="CO65-11"/>
          instanceType: &lt;instance_type&gt; <co xml:id="CO65-12"/>
          kind: AlibabaCloudMachineProviderConfig
          ramRoleName: &lt;infrastructure_id&gt;-role-worker <co xml:id="CO65-13"/>
          regionId: &lt;region&gt; <co xml:id="CO65-14"/>
          resourceGroup: <co xml:id="CO65-15"/>
            id: &lt;resource_group_id&gt;
            type: ID
          securityGroups:
          - tags: <co xml:id="CO65-16"/>
            - Key: Name
              Value: &lt;infrastructure_id&gt;-sg-&lt;role&gt;
            type: Tags
          systemDisk: <co xml:id="CO65-17"/>
            category: cloud_essd
            size: &lt;disk_size&gt;
          tag: <co xml:id="CO65-18"/>
          - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt;
            Value: owned
          userDataSecret:
            name: &lt;user_data_secret&gt; <co xml:id="CO65-19"/>
          vSwitch:
            tags: <co xml:id="CO65-20"/>
            - Key: Name
              Value: &lt;infrastructure_id&gt;-vswitch-&lt;zone&gt;
            type: Tags
          vpcId: ""
          zoneId: &lt;zone&gt; <co xml:id="CO65-21"/>
      taints: <co xml:id="CO65-22"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule</programlisting>
<calloutlist>
<callout arearefs="CO65-1 CO65-5 CO65-7">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO65-2 CO65-3 CO65-8 CO65-9">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO65-4 CO65-6 CO65-10">
<para>Specify the infrastructure ID, <literal>&lt;infra&gt;</literal> node label, and zone.</para>
</callout>
<callout arearefs="CO65-11">
<para>Specify the image to use. Use an image from an existing default compute machine set for the cluster.</para>
</callout>
<callout arearefs="CO65-12">
<para>Specify the instance type you want to use for the compute machine set.</para>
</callout>
<callout arearefs="CO65-13">
<para>Specify the name of the RAM role to use for the compute machine set. Use the value that the installer populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO65-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO65-15">
<para>Specify the resource group and type for the cluster. You can use the value that the installer populates in the default compute machine set, or specify a different one.</para>
</callout>
<callout arearefs="CO65-16 CO65-18 CO65-20">
<para>Specify the tags to use for the compute machine set. Minimally, you must include the tags shown in this example, with appropriate values for your cluster. You can include additional tags, including the tags that the installer populates in the default compute machine set it creates, as needed.</para>
</callout>
<callout arearefs="CO65-17">
<para>Specify the type and size of the root disk. Use the <literal>category</literal> value that the installer populates in the default compute machine set it creates. If required, specify a different value in gigabytes for <literal>size</literal>.</para>
</callout>
<callout arearefs="CO65-19">
<para>Specify the name of the secret in the user data YAML file that is in the <literal>openshift-machine-api</literal> namespace. Use the value that the installer populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO65-21">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO65-22">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
<bridgehead xml:id="machineset-yaml-alibaba-usage-stats_creating-infrastructure-machinesets" renderas="sect5">Machine set parameters for Alibaba Cloud usage statistics</bridgehead>
<simpara>The default compute machine sets that the installer creates for Alibaba Cloud clusters include nonessential tag values that Alibaba Cloud uses internally to track usage statistics. These tags are populated in the <literal>securityGroups</literal>, <literal>tag</literal>, and <literal>vSwitch</literal> parameters of the <literal>spec.template.spec.providerSpec.value</literal> list.</simpara>
<simpara>When creating compute machine sets to deploy additional machines, you must include the required Kubernetes tags. The usage statistics tags are applied by default, even if they are not specified in the compute machine sets you create. You can also include additional tags as needed.</simpara>
<simpara>The following YAML snippets indicate which tags in the default compute machine sets are optional and which are required.</simpara>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.securityGroups</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          securityGroups:
          - tags:
            - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO66-1"/>
              Value: owned
            - Key: GISV
              Value: ocp
            - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO66-2"/>
              Value: ocp
            - Key: Name
              Value: &lt;infrastructure_id&gt;-sg-&lt;role&gt; <co xml:id="CO66-3"/>
            type: Tags</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1 CO66-2">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO66-3">
<para>Required.</para>
<simpara>where:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;role&gt;</literal> is the node label to add.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.tag</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          tag:
          - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO67-1"/>
            Value: owned
          - Key: GISV <co xml:id="CO67-2"/>
            Value: ocp
          - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO67-3"/>
            Value: ocp</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO67-2 CO67-3">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO67-1">
<para>Required.</para>
<simpara>where <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</callout>
</calloutlist>
<formalpara>
<title>Tags in <literal>spec.template.spec.providerSpec.value.vSwitch</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      providerSpec:
        value:
          vSwitch:
            tags:
            - Key: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO68-1"/>
              Value: owned
            - Key: GISV <co xml:id="CO68-2"/>
              Value: ocp
            - Key: sigs.k8s.io/cloud-provider-alibaba/origin <co xml:id="CO68-3"/>
              Value: ocp
            - Key: Name
              Value: &lt;infrastructure_id&gt;-vswitch-&lt;zone&gt; <co xml:id="CO68-4"/>
            type: Tags</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO68-1 CO68-2 CO68-3">
<para>Optional: This tag is applied even when not specified in the compute machine set.</para>
</callout>
<callout arearefs="CO68-4">
<para>Required.</para>
<simpara>where:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;zone&gt;</literal> is the zone within your region to place machines on.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-yaml-aws_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on AWS</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>us-east-1a</literal> Amazon Web Services (AWS) zone and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO69-1"/>
  name: &lt;infrastructure_id&gt;-infra-&lt;zone&gt; <co xml:id="CO69-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO69-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;zone&gt; <co xml:id="CO69-4"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO69-5"/>
        machine.openshift.io/cluster-api-machine-role: infra <co xml:id="CO69-6"/>
        machine.openshift.io/cluster-api-machine-type: infra <co xml:id="CO69-7"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;zone&gt; <co xml:id="CO69-8"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/infra: "" <co xml:id="CO69-9"/>
      providerSpec:
        value:
          ami:
            id: ami-046fe691f52a953f9 <co xml:id="CO69-10"/>
          apiVersion: machine.openshift.io/v1beta1
          blockDevices:
            - ebs:
                iops: 0
                volumeSize: 120
                volumeType: gp2
          credentialsSecret:
            name: aws-cloud-credentials
          deviceIndex: 0
          iamInstanceProfile:
            id: &lt;infrastructure_id&gt;-worker-profile <co xml:id="CO69-11"/>
          instanceType: m6i.large
          kind: AWSMachineProviderConfig
          placement:
            availabilityZone: &lt;zone&gt; <co xml:id="CO69-12"/>
            region: &lt;region&gt; <co xml:id="CO69-13"/>
          securityGroups:
            - filters:
                - name: tag:Name
                  values:
                    - &lt;infrastructure_id&gt;-worker-sg <co xml:id="CO69-14"/>
          subnet:
            filters:
              - name: tag:Name
                values:
                  - &lt;infrastructure_id&gt;-private-&lt;zone&gt; <co xml:id="CO69-15"/>
          tags:
            - name: kubernetes.io/cluster/&lt;infrastructure_id&gt; <co xml:id="CO69-16"/>
              value: owned
            - name: &lt;custom_tag_name&gt; <co xml:id="CO69-17"/>
              value: &lt;custom_tag_value&gt; <co xml:id="CO69-18"/>
          userDataSecret:
            name: worker-user-data
      taints: <co xml:id="CO69-19"/>
        - key: node-role.kubernetes.io/infra
          effect: NoSchedule</programlisting>
<calloutlist>
<callout arearefs="CO69-1 CO69-3 CO69-5 CO69-11 CO69-14 CO69-16">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO69-2 CO69-4 CO69-8">
<para>Specify the infrastructure ID, <literal>infra</literal> role node label, and zone.</para>
</callout>
<callout arearefs="CO69-6 CO69-7 CO69-9">
<para>Specify the <literal>infra</literal> role node label.</para>
</callout>
<callout arearefs="CO69-10">
<para>Specify a valid Red Hat Enterprise Linux CoreOS (RHCOS) Amazon
Machine Image (AMI) for your AWS zone for your OpenShift Container Platform nodes. If you want to use an AWS Marketplace image, you must complete the OpenShift Container Platform subscription from the <link xlink:href="https://aws.amazon.com/marketplace/fulfillment?productId=59ead7de-2540-4653-a8b0-fa7926d5c845">AWS Marketplace</link> to obtain an AMI ID for your region.</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.ami.id}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-&lt;role&gt;-&lt;zone&gt;</programlisting>
</callout>
<callout arearefs="CO69-17 CO69-18">
<para>Optional: Specify custom tag data for your cluster. For example, you might add an admin contact email address by specifying a <literal>name:value</literal> pair of <literal>Email:admin-email@example.com</literal>.</para>
<note>
<simpara>Custom tags can also be specified during installation in the <literal>install-config.yml</literal> file. If the <literal>install-config.yml</literal> file and the machine set include a tag with the same <literal>name</literal> data, the value for the tag from the machine set takes priority over the value for the tag in the <literal>install-config.yml</literal> file.</simpara>
</note>
</callout>
<callout arearefs="CO69-12">
<para>Specify the zone, for example, <literal>us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO69-13">
<para>Specify the region, for example, <literal>us-east-1</literal>.</para>
</callout>
<callout arearefs="CO69-15">
<para>Specify the infrastructure ID and zone.</para>
</callout>
<callout arearefs="CO69-19">
<para>Specify a taint to prevent user workloads from being scheduled on
<literal>infra</literal>
nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
<simpara>Machine sets running on AWS support non-guaranteed <link linkend="machineset-non-guaranteed-instance_creating-machineset-aws">Spot Instances</link>. You can save on costs by using Spot Instances at a lower price compared to
On-Demand Instances on AWS. <link linkend="machineset-creating-non-guaranteed-instance_creating-machineset-aws">Configure Spot Instances</link> by adding <literal>spotMarketOptions</literal> to the <literal>MachineSet</literal> YAML file.</simpara>
</section>
<section xml:id="machineset-yaml-azure_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on Azure</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>1</literal> Microsoft Azure zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO70-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO70-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO70-3"/>
  name: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO70-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO70-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO70-6"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO70-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO70-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO70-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO70-10"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          machine.openshift.io/cluster-api-machineset: &lt;machineset_name&gt;
          node-role.kubernetes.io/infra: "" <co xml:id="CO70-11"/>
      providerSpec:
        value:
          apiVersion: azureproviderconfig.openshift.io/v1beta1
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          image: <co xml:id="CO70-12"/>
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/&lt;infrastructure_id&gt;-rg/providers/Microsoft.Compute/images/&lt;infrastructure_id&gt; <co xml:id="CO70-13"/>
            sku: ""
            version: ""
          internalLoadBalancer: ""
          kind: AzureMachineProviderSpec
          location: &lt;region&gt; <co xml:id="CO70-14"/>
          managedIdentity: &lt;infrastructure_id&gt;-identity <co xml:id="CO70-15"/>
          metadata:
            creationTimestamp: null
          natRule: null
          networkResourceGroup: ""
          osDisk:
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: ""
          resourceGroup: &lt;infrastructure_id&gt;-rg <co xml:id="CO70-16"/>
          sshPrivateKey: ""
          sshPublicKey: ""
          tags:
            - name: &lt;custom_tag_name&gt; <co xml:id="CO70-17"/>
              value: &lt;custom_tag_value&gt; <co xml:id="CO70-18"/>
          subnet: &lt;infrastructure_id&gt;-&lt;role&gt;-subnet <co xml:id="CO70-19"/> <co xml:id="CO70-20"/>
          userDataSecret:
            name: worker-user-data <co xml:id="CO70-21"/>
          vmSize: Standard_D4s_v3
          vnet: &lt;infrastructure_id&gt;-vnet <co xml:id="CO70-22"/>
          zone: "1" <co xml:id="CO70-23"/>
      taints: <co xml:id="CO70-24"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule</programlisting>
<calloutlist>
<callout arearefs="CO70-1 CO70-5 CO70-7 CO70-15 CO70-16 CO70-19 CO70-22">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<simpara>You can obtain the subnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.subnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
<simpara>You can obtain the vnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.vnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
</callout>
<callout arearefs="CO70-2 CO70-3 CO70-8 CO70-9 CO70-11 CO70-20 CO70-21">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO70-4 CO70-6 CO70-10">
<para>Specify the infrastructure ID, <literal>&lt;infra&gt;</literal> node label, and region.</para>
</callout>
<callout arearefs="CO70-12">
<para>Specify the image details for your compute machine set. If you want to use an Azure Marketplace image, see "Selecting an Azure Marketplace image".</para>
</callout>
<callout arearefs="CO70-13">
<para>Specify an image that is compatible with your instance type. The Hyper-V generation V2 images created by the installation program have a <literal>-gen2</literal> suffix, while V1 images have the same name without the suffix.</para>
</callout>
<callout arearefs="CO70-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO70-23">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO70-17 CO70-18">
<para>Optional: Specify custom tags in your machine set. Provide the tag name in <literal>&lt;custom_tag_name&gt;</literal> field and the corresponding tag value in <literal>&lt;custom_tag_value&gt;</literal> field.</para>
</callout>
<callout arearefs="CO70-24">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
<simpara>Machine sets running on Azure support non-guaranteed <link linkend="machineset-non-guaranteed-instance_creating-machineset-azure">Spot VMs</link>. You can save on costs by using Spot VMs at a lower price compared to standard VMs on Azure. You can <link linkend="machineset-creating-non-guaranteed-instance_creating-machineset-azure">configure Spot VMs</link> by adding <literal>spotVMOptions</literal> to the <literal>MachineSet</literal> YAML file.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="installation-azure-marketplace-subscribe_creating-machineset-azure">Selecting an Azure Marketplace image</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-yaml-azure-stack-hub_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on Azure Stack Hub</title>
<simpara>This sample YAML defines a compute machine set that runs in the <literal>1</literal> Microsoft Azure zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO71-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO71-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO71-3"/>
  name: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO71-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO71-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO71-6"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO71-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO71-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO71-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra-&lt;region&gt; <co xml:id="CO71-10"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/infra: "" <co xml:id="CO71-11"/>
      taints: <co xml:id="CO71-12"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1beta1
          availabilitySet: &lt;availability_set&gt; <co xml:id="CO71-13"/>
          credentialsSecret:
            name: azure-cloud-credentials
            namespace: openshift-machine-api
          image:
            offer: ""
            publisher: ""
            resourceID: /resourceGroups/&lt;infrastructure_id&gt;-rg/providers/Microsoft.Compute/images/&lt;infrastructure_id&gt; <co xml:id="CO71-14"/>
            sku: ""
            version: ""
          internalLoadBalancer: ""
          kind: AzureMachineProviderSpec
          location: &lt;region&gt; <co xml:id="CO71-15"/>
          managedIdentity: &lt;infrastructure_id&gt;-identity <co xml:id="CO71-16"/>
          metadata:
            creationTimestamp: null
          natRule: null
          networkResourceGroup: ""
          osDisk:
            diskSizeGB: 128
            managedDisk:
              storageAccountType: Premium_LRS
            osType: Linux
          publicIP: false
          publicLoadBalancer: ""
          resourceGroup: &lt;infrastructure_id&gt;-rg <co xml:id="CO71-17"/>
          sshPrivateKey: ""
          sshPublicKey: ""
          subnet: &lt;infrastructure_id&gt;-&lt;role&gt;-subnet <co xml:id="CO71-18"/> <co xml:id="CO71-19"/>
          userDataSecret:
            name: worker-user-data <co xml:id="CO71-20"/>
          vmSize: Standard_DS4_v2
          vnet: &lt;infrastructure_id&gt;-vnet <co xml:id="CO71-21"/>
          zone: "1" <co xml:id="CO71-22"/></programlisting>
<calloutlist>
<callout arearefs="CO71-1 CO71-5 CO71-7 CO71-14 CO71-16 CO71-17 CO71-18 CO71-21">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<simpara>You can obtain the subnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.subnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
<simpara>You can obtain the vnet by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc -n openshift-machine-api \
    -o jsonpath='{.spec.template.spec.providerSpec.value.vnet}{"\n"}' \
    get machineset/&lt;infrastructure_id&gt;-worker-centralus1</programlisting>
</callout>
<callout arearefs="CO71-2 CO71-3 CO71-8 CO71-9 CO71-11 CO71-19 CO71-20">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO71-4 CO71-6 CO71-10">
<para>Specify the infrastructure ID, <literal>&lt;infra&gt;</literal> node label, and region.</para>
</callout>
<callout arearefs="CO71-12">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
<callout arearefs="CO71-15">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO71-13">
<para>Specify the availability set for the cluster.</para>
</callout>
<callout arearefs="CO71-22">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
</calloutlist>
<note>
<simpara>Machine sets running on Azure Stack Hub do not support non-guaranteed Spot VMs.</simpara>
</note>
</section>
<section xml:id="machineset-yaml-ibm-cloud_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on IBM Cloud</title>
<simpara>This sample YAML defines a compute machine set that runs in a specified IBM Cloud&#174; zone in a region and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO72-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO72-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO72-3"/>
  name: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;region&gt; <co xml:id="CO72-4"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO72-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;region&gt; <co xml:id="CO72-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO72-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO72-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO72-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;region&gt; <co xml:id="CO72-10"/>
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/infra: ""
      providerSpec:
        value:
          apiVersion: ibmcloudproviderconfig.openshift.io/v1beta1
          credentialsSecret:
            name: ibmcloud-credentials
          image: &lt;infrastructure_id&gt;-rhcos <co xml:id="CO72-11"/>
          kind: IBMCloudMachineProviderSpec
          primaryNetworkInterface:
              securityGroups:
              - &lt;infrastructure_id&gt;-sg-cluster-wide
              - &lt;infrastructure_id&gt;-sg-openshift-net
              subnet: &lt;infrastructure_id&gt;-subnet-compute-&lt;zone&gt; <co xml:id="CO72-12"/>
          profile: &lt;instance_profile&gt; <co xml:id="CO72-13"/>
          region: &lt;region&gt; <co xml:id="CO72-14"/>
          resourceGroup: &lt;resource_group&gt; <co xml:id="CO72-15"/>
          userDataSecret:
              name: &lt;role&gt;-user-data <co xml:id="CO72-16"/>
          vpc: &lt;vpc_name&gt; <co xml:id="CO72-17"/>
          zone: &lt;zone&gt; <co xml:id="CO72-18"/>
        taints: <co xml:id="CO72-19"/>
        - key: node-role.kubernetes.io/infra
          effect: NoSchedule</programlisting>
<calloutlist>
<callout arearefs="CO72-1 CO72-5 CO72-7">
<para>The infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO72-2 CO72-3 CO72-8 CO72-9 CO72-16">
<para>The <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO72-4 CO72-6 CO72-10">
<para>The infrastructure ID, <literal>&lt;infra&gt;</literal> node label, and region.</para>
</callout>
<callout arearefs="CO72-11">
<para>The custom Red Hat Enterprise Linux CoreOS (RHCOS) image that was used for cluster installation.</para>
</callout>
<callout arearefs="CO72-12">
<para>The infrastructure ID and zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO72-13">
<para>Specify the <link xlink:href="https://cloud.ibm.com/docs/vpc?topic=vpc-profiles&amp;interface=ui">IBM Cloud&#174; instance profile</link>.</para>
</callout>
<callout arearefs="CO72-14">
<para>Specify the region to place machines on.</para>
</callout>
<callout arearefs="CO72-15">
<para>The resource group that machine resources are placed in. This is either an existing resource group specified at installation time, or an installer-created resource group named based on the infrastructure ID.</para>
</callout>
<callout arearefs="CO72-17">
<para>The VPC name.</para>
</callout>
<callout arearefs="CO72-18">
<para>Specify the zone within your region to place machines on. Be sure that your region supports the zone that you specify.</para>
</callout>
<callout arearefs="CO72-19">
<para>The taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-yaml-gcp_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on GCP</title>
<simpara>This sample YAML defines a compute machine set that runs in Google Cloud Platform (GCP) and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>,
where
<literal>infra</literal>
is the node label to add.</simpara>
<bridgehead xml:id="cpmso-yaml-provider-spec-gcp-oc_creating-infrastructure-machinesets" renderas="sect5">Values obtained by using the  OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI.</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;infrastructure_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>Image path</term>
<listitem>
<simpara>The <literal>&lt;path_to_image&gt;</literal> string is the path to the image that was used to create the disk. If you have the OpenShift CLI installed, you can obtain the path to the image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
  -o jsonpath='{.spec.template.spec.providerSpec.value.disks[0].image}{"\n"}' \
  get machineset/&lt;infrastructure_id&gt;-worker-a</programlisting>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Sample GCP <literal>MachineSet</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO73-1"/>
  name: &lt;infrastructure_id&gt;-w-a
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-w-a
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO73-2"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-w-a
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/infra: ""
      providerSpec:
        value:
          apiVersion: gcpprovider.openshift.io/v1beta1
          canIPForward: false
          credentialsSecret:
            name: gcp-cloud-credentials
          deletionProtection: false
          disks:
          - autoDelete: true
            boot: true
            image: &lt;path_to_image&gt; <co xml:id="CO73-3"/>
            labels: null
            sizeGb: 128
            type: pd-ssd
          gcpMetadata: <co xml:id="CO73-4"/>
          - key: &lt;custom_metadata_key&gt;
            value: &lt;custom_metadata_value&gt;
          kind: GCPMachineProviderSpec
          machineType: n1-standard-4
          metadata:
            creationTimestamp: null
          networkInterfaces:
          - network: &lt;infrastructure_id&gt;-network
            subnetwork: &lt;infrastructure_id&gt;-worker-subnet
          projectID: &lt;project_name&gt; <co xml:id="CO73-5"/>
          region: us-central1
          serviceAccounts:
          - email: &lt;infrastructure_id&gt;-w@&lt;project_name&gt;.iam.gserviceaccount.com
            scopes:
            - https://www.googleapis.com/auth/cloud-platform
          tags:
            - &lt;infrastructure_id&gt;-worker
          userDataSecret:
            name: worker-user-data
          zone: us-central1-a
      taints: <co xml:id="CO73-6"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO73-1">
<para>For <literal>&lt;infrastructure_id&gt;</literal>, specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</para>
</callout>
<callout arearefs="CO73-2">
<para>For <literal>&lt;infra&gt;</literal>, specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO73-3">
<para>Specify the path to the image that is used in current compute machine sets.</para>
<simpara>To use a GCP Marketplace image, specify the offer to use:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-ocp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Platform Plus: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-opp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Kubernetes Engine: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-oke-413-x86-64-202305021736</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO73-4">
<para>Optional: Specify custom metadata in the form of a <literal>key:value</literal> pair. For example use cases, see the GCP documentation for <link xlink:href="https://cloud.google.com/compute/docs/metadata/setting-custom-metadata">setting custom metadata</link>.</para>
</callout>
<callout arearefs="CO73-5">
<para>For <literal>&lt;project_name&gt;</literal>, specify the name of the GCP project that you use for your cluster.</para>
</callout>
<callout arearefs="CO73-6">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
<simpara>Machine sets running on GCP support non-guaranteed <link linkend="machineset-non-guaranteed-instance_creating-machineset-gcp">preemptible VM instances</link>. You can save on costs by using preemptible VM instances at a lower price
compared to normal instances on GCP. You can <link linkend="machineset-creating-non-guaranteed-instance_creating-machineset-gcp">configure preemptible VM instances</link> by adding <literal>preemptible</literal> to the <literal>MachineSet</literal> YAML file.</simpara>
</section>
<section xml:id="machineset-yaml-nutanix_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on Nutanix</title>
<simpara>This sample YAML defines a Nutanix compute machine set that creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<bridgehead xml:id="machineset-yaml-nutanix-oc_creating-infrastructure-machinesets" renderas="sect5">Values obtained by using the OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;infrastructure_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
</variablelist>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO74-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO74-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt;
  name: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt; <co xml:id="CO74-3"/>
  namespace: openshift-machine-api
  annotations: <co xml:id="CO74-4"/>
    machine.openshift.io/memoryMb: "16384"
    machine.openshift.io/vCPU: "4"
spec:
  replicas: 3
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;infra&gt;-&lt;zone&gt;
    spec:
      metadata:
        labels:
          node-role.kubernetes.io/infra: ""
      providerSpec:
        value:
          apiVersion: machine.openshift.io/v1
          bootType: "" <co xml:id="CO74-5"/>
          categories: <co xml:id="CO74-6"/>
          - key: &lt;category_name&gt;
            value: &lt;category_value&gt;
          cluster: <co xml:id="CO74-7"/>
            type: uuid
            uuid: &lt;cluster_uuid&gt;
          credentialsSecret:
            name: nutanix-credentials
          image:
            name: &lt;infrastructure_id&gt;-rhcos <co xml:id="CO74-8"/>
            type: name
          kind: NutanixMachineProviderConfig
          memorySize: 16Gi <co xml:id="CO74-9"/>
          project: <co xml:id="CO74-10"/>
            type: name
            name: &lt;project_name&gt;
          subnets:
          - type: uuid
            uuid: &lt;subnet_uuid&gt;
          systemDiskSize: 120Gi <co xml:id="CO74-11"/>
          userDataSecret:
            name: &lt;user_data_secret&gt; <co xml:id="CO74-12"/>
          vcpuSockets: 4 <co xml:id="CO74-13"/>
          vcpusPerSocket: 1 <co xml:id="CO74-14"/>
      taints: <co xml:id="CO74-15"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule</programlisting>
<calloutlist>
<callout arearefs="CO74-1">
<para>For <literal>&lt;infrastructure_id&gt;</literal>, specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster.</para>
</callout>
<callout arearefs="CO74-2">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO74-3">
<para>Specify the infrastructure ID, <literal>&lt;infra&gt;</literal> node label, and zone.</para>
</callout>
<callout arearefs="CO74-4">
<para>Annotations for the cluster autoscaler.</para>
</callout>
<callout arearefs="CO74-5">
<para>Specifies the boot type that the compute machines use. For more information about boot types, see <link xlink:href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA07V000000H3K9SAK">Understanding UEFI, Secure Boot, and TPM in the Virtualized Environment</link>. Valid values are <literal>Legacy</literal>, <literal>SecureBoot</literal>, or <literal>UEFI</literal>. The default is <literal>Legacy</literal>.</para>
<note>
<simpara>You must use the <literal>Legacy</literal> boot type in OpenShift Container Platform 4.14.</simpara>
</note>
</callout>
<callout arearefs="CO74-6">
<para>Specify one or more Nutanix Prism categories to apply to compute machines. This stanza requires <literal>key</literal> and <literal>value</literal> parameters for a category key-value pair that exists in Prism Central. For more information about categories, see <link xlink:href="https://portal.nutanix.com/page/documents/details?targetId=Prism-Central-Guide-vpc_2022_6:ssp-ssp-categories-manage-pc-c.html">Category management</link>.</para>
</callout>
<callout arearefs="CO74-7">
<para>Specify a Nutanix Prism Element cluster configuration. In this example, the cluster type is <literal>uuid</literal>, so there is a <literal>uuid</literal> stanza.</para>
</callout>
<callout arearefs="CO74-8">
<para>Specify the image to use. Use an image from an existing default compute machine set for the cluster.</para>
</callout>
<callout arearefs="CO74-9">
<para>Specify the amount of memory for the cluster in Gi.</para>
</callout>
<callout arearefs="CO74-10">
<para>Specify the Nutanix project that you use for your cluster. In this example, the project type is <literal>name</literal>, so there is a <literal>name</literal> stanza.</para>
</callout>
<callout arearefs="CO74-11">
<para>Specify the size of the system disk in Gi.</para>
</callout>
<callout arearefs="CO74-12">
<para>Specify the name of the secret in the user data YAML file that is in the <literal>openshift-machine-api</literal> namespace. Use the value that installation program populates in the default compute machine set.</para>
</callout>
<callout arearefs="CO74-13">
<para>Specify the number of vCPU sockets.</para>
</callout>
<callout arearefs="CO74-14">
<para>Specify the number of vCPUs per socket.</para>
</callout>
<callout arearefs="CO74-15">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-yaml-osp_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on RHOSP</title>
<simpara>This sample YAML defines a compute machine set that runs on Red Hat OpenStack Platform (RHOSP) and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO75-1"/>
    machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO75-2"/>
    machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO75-3"/>
  name: &lt;infrastructure_id&gt;-infra <co xml:id="CO75-4"/>
  namespace: openshift-machine-api
spec:
  replicas: &lt;number_of_replicas&gt;
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO75-5"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra <co xml:id="CO75-6"/>
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO75-7"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO75-8"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO75-9"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra <co xml:id="CO75-10"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/infra: ""
      taints: <co xml:id="CO75-11"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule
      providerSpec:
        value:
          apiVersion: openstackproviderconfig.openshift.io/v1alpha1
          cloudName: openstack
          cloudsSecret:
            name: openstack-cloud-credentials
            namespace: openshift-machine-api
          flavor: &lt;nova_flavor&gt;
          image: &lt;glance_image_name_or_location&gt;
          serverGroupID: &lt;optional_UUID_of_server_group&gt; <co xml:id="CO75-12"/>
          kind: OpenstackProviderSpec
          networks: <co xml:id="CO75-13"/>
          - filter: {}
            subnets:
            - filter:
                name: &lt;subnet_name&gt;
                tags: openshiftClusterID=&lt;infrastructure_id&gt; <co xml:id="CO75-14"/>
          primarySubnet: &lt;rhosp_subnet_UUID&gt; <co xml:id="CO75-15"/>
          securityGroups:
          - filter: {}
            name: &lt;infrastructure_id&gt;-worker <co xml:id="CO75-16"/>
          serverMetadata:
            Name: &lt;infrastructure_id&gt;-worker <co xml:id="CO75-17"/>
            openshiftClusterID: &lt;infrastructure_id&gt; <co xml:id="CO75-18"/>
          tags:
          - openshiftClusterID=&lt;infrastructure_id&gt; <co xml:id="CO75-19"/>
          trunk: true
          userDataSecret:
            name: worker-user-data <co xml:id="CO75-20"/>
          availabilityZone: &lt;optional_openstack_availability_zone&gt;</programlisting>
<calloutlist>
<callout arearefs="CO75-1 CO75-5 CO75-7 CO75-14 CO75-16 CO75-17 CO75-18 CO75-19">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO75-2 CO75-3 CO75-8 CO75-9 CO75-20">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO75-4 CO75-6 CO75-10">
<para>Specify the infrastructure ID and <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO75-11">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
<callout arearefs="CO75-12">
<para>To set a server group policy for the MachineSet, enter the value that is returned from
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/16.0/html/command_line_interface_reference/server#server_group_create">creating a server group</link>. For most deployments, <literal>anti-affinity</literal> or <literal>soft-anti-affinity</literal> policies are recommended.</para>
</callout>
<callout arearefs="CO75-13">
<para>Required for deployments to multiple networks. If deploying to multiple networks, this list must include the network that is used as the <literal>primarySubnet</literal> value.</para>
</callout>
<callout arearefs="CO75-15">
<para>Specify the RHOSP subnet that you want the endpoints of nodes to be published on. Usually, this is the same subnet that is used as the value of <literal>machinesSubnet</literal> in the <literal>install-config.yaml</literal> file.</para>
</callout>
</calloutlist>
</section>
<section xml:id="machineset-yaml-vsphere_creating-infrastructure-machinesets">
<title>Sample YAML for a compute machine set custom resource on vSphere</title>
<simpara>This sample YAML defines a compute machine set that runs on VMware vSphere and creates nodes that are labeled with
<literal>node-role.kubernetes.io/infra: ""</literal>.</simpara>
<simpara>In this sample, <literal>&lt;infrastructure_id&gt;</literal> is the infrastructure ID label that is based on the cluster ID that you set when you provisioned the cluster, and
<literal>&lt;infra&gt;</literal>
is the node label to add.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  creationTimestamp: null
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO76-1"/>
  name: &lt;infrastructure_id&gt;-infra <co xml:id="CO76-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO76-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra <co xml:id="CO76-4"/>
  template:
    metadata:
      creationTimestamp: null
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO76-5"/>
        machine.openshift.io/cluster-api-machine-role: &lt;infra&gt; <co xml:id="CO76-6"/>
        machine.openshift.io/cluster-api-machine-type: &lt;infra&gt; <co xml:id="CO76-7"/>
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-infra <co xml:id="CO76-8"/>
    spec:
      metadata:
        creationTimestamp: null
        labels:
          node-role.kubernetes.io/infra: "" <co xml:id="CO76-9"/>
      taints: <co xml:id="CO76-10"/>
      - key: node-role.kubernetes.io/infra
        effect: NoSchedule
      providerSpec:
        value:
          apiVersion: vsphereprovider.openshift.io/v1beta1
          credentialsSecret:
            name: vsphere-cloud-credentials
          diskGiB: 120
          kind: VSphereMachineProviderSpec
          memoryMiB: 8192
          metadata:
            creationTimestamp: null
          network:
            devices:
            - networkName: "&lt;vm_network_name&gt;" <co xml:id="CO76-11"/>
          numCPUs: 4
          numCoresPerSocket: 1
          snapshot: ""
          template: &lt;vm_template_name&gt; <co xml:id="CO76-12"/>
          userDataSecret:
            name: worker-user-data
          workspace:
            datacenter: &lt;vcenter_datacenter_name&gt; <co xml:id="CO76-13"/>
            datastore: &lt;vcenter_datastore_name&gt; <co xml:id="CO76-14"/>
            folder: &lt;vcenter_vm_folder_path&gt; <co xml:id="CO76-15"/>
            resourcepool: &lt;vsphere_resource_pool&gt; <co xml:id="CO76-16"/>
            server: &lt;vcenter_server_ip&gt; <co xml:id="CO76-17"/></programlisting>
<calloutlist>
<callout arearefs="CO76-1 CO76-3 CO76-5">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO76-2 CO76-4 CO76-8">
<para>Specify the infrastructure ID and <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO76-6 CO76-7 CO76-9">
<para>Specify the <literal>&lt;infra&gt;</literal> node label.</para>
</callout>
<callout arearefs="CO76-10">
<para>Specify a taint to prevent user workloads from being scheduled on infra nodes.</para>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xlink:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
</callout>
<callout arearefs="CO76-11">
<para>Specify the vSphere VM network to deploy the compute machine set to. This VM network must be where other compute machines reside in the cluster.</para>
</callout>
<callout arearefs="CO76-12">
<para>Specify the vSphere VM template to use, such as <literal>user-5ddjd-rhcos</literal>.</para>
</callout>
<callout arearefs="CO76-13">
<para>Specify the vCenter Datacenter to deploy the compute machine set on.</para>
</callout>
<callout arearefs="CO76-14">
<para>Specify the vCenter Datastore to deploy the compute machine set on.</para>
</callout>
<callout arearefs="CO76-15">
<para>Specify the path to the vSphere VM folder in vCenter, such as <literal>/dc1/vm/user-inst-5ddjd</literal>.</para>
</callout>
<callout arearefs="CO76-16">
<para>Specify the vSphere resource pool for your VMs.</para>
</callout>
<callout arearefs="CO76-17">
<para>Specify the vCenter server IP or fully qualified domain name.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="machineset-creating_creating-infrastructure-machinesets">
<title>Creating a compute machine set</title>
<simpara>In addition to the compute machine sets created by the installation program, you can create your own to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file that contains the compute machine set custom resource (CR) sample and is named <literal>&lt;file_name&gt;.yaml</literal>.</simpara>
<simpara>Ensure that you set the <literal>&lt;clusterID&gt;</literal> and <literal>&lt;role&gt;</literal> parameter values.</simpara>
</listitem>
<listitem>
<simpara>Optional: If you are not sure which value to set for a specific field, you can check an existing compute machine set from your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the compute machine sets in your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view values of a specific compute machine set custom resource (CR), run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
  -n openshift-machine-api -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  labels:
    machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt; <co xml:id="CO77-1"/>
  name: &lt;infrastructure_id&gt;-&lt;role&gt; <co xml:id="CO77-2"/>
  namespace: openshift-machine-api
spec:
  replicas: 1
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
      machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
  template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: &lt;infrastructure_id&gt;
        machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
        machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
        machine.openshift.io/cluster-api-machineset: &lt;infrastructure_id&gt;-&lt;role&gt;
    spec:
      providerSpec: <co xml:id="CO77-3"/>
        ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO77-1">
<para>The cluster infrastructure ID.</para>
</callout>
<callout arearefs="CO77-2">
<para>A default node label.</para>
<note>
<simpara>For clusters that have user-provisioned infrastructure, a compute machine set can only create <literal>worker</literal> and <literal>infra</literal> type machines.</simpara>
</note>
</callout>
<callout arearefs="CO77-3">
<para>The values in the <literal>&lt;providerSpec&gt;</literal> section of the compute machine set CR are platform-specific. For more information about <literal>&lt;providerSpec&gt;</literal> parameters in the CR, see the sample compute machine set CR configuration for your provider.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>MachineSet</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the list of compute machine sets by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-infra-us-east-1a    1         1         1       1           11m
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>DESIRED</literal> and <literal>CURRENT</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="creating-an-infra-node_creating-infrastructure-machinesets">
<title>Creating an infrastructure node</title>
<important>
<simpara>See Creating infrastructure machine sets for installer-provisioned infrastructure environments or for any cluster where the control plane nodes are managed by the machine API.</simpara>
</important>
<simpara>Requirements of the cluster dictate that infrastructure, also called <literal>infra</literal> nodes, be provisioned. The installer only provides provisions for control plane and worker nodes. Worker nodes can be designated as infrastructure nodes or application, also called <literal>app</literal>, nodes through labeling.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a label to the worker node that you want to act as application node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node-name&gt; node-role.kubernetes.io/app=""</programlisting>
</listitem>
<listitem>
<simpara>Add a label to the worker nodes that you want to act as infrastructure nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node-name&gt; node-role.kubernetes.io/infra=""</programlisting>
</listitem>
<listitem>
<simpara>Check to see if applicable nodes now have the <literal>infra</literal> role and <literal>app</literal> roles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
</listitem>
<listitem>
<simpara>Create a default cluster-wide node selector. The default node selector is applied to pods created in all namespaces. This creates an intersection with any existing node selectors on a pod, which additionally constrains the pod&#8217;s selector.</simpara>
<important>
<simpara>If the default node selector key conflicts with the key of a pod&#8217;s label, then the default node selector is not applied.</simpara>
<simpara>However, do not set a default node selector that might cause a pod to become unschedulable. For example, setting the default node selector to a specific node role, such as <literal>node-role.kubernetes.io/infra=""</literal>, when a pod&#8217;s label is set to a different node role, such as <literal>node-role.kubernetes.io/master=""</literal>, can cause the pod to become unschedulable. For this reason, use caution when setting the default node selector to specific node roles.</simpara>
<simpara>You can alternatively use a project node selector to avoid cluster-wide node selector key conflicts.</simpara>
</important>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Scheduler</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit scheduler cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>defaultNodeSelector</literal> field with the appropriate node selector:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  name: cluster
spec:
  defaultNodeSelector: topology.kubernetes.io/region=us-east-1 <co xml:id="CO78-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO78-1">
<para>This example node selector deploys pods on nodes in the <literal>us-east-1</literal> region by default.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now move infrastructure resources to the newly labeled <literal>infra</literal> nodes.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="moving-resources-to-infrastructure-machinesets">Moving resources to infrastructure machine sets</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="creating-infra-machines_creating-infrastructure-machinesets">
<title>Creating a machine config pool for infrastructure machines</title>
<simpara>If you need infrastructure machines to have dedicated configurations, you must create an infra pool.</simpara>
<important>
<simpara>Creating a custom machine configuration pool overrides default worker pool configurations if they refer to the same file or unit.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a label to the node you want to assign as the infra node with a specific label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node_name&gt; &lt;label&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node ci-ln-n8mqwr2-f76d1-xscn2-worker-c-6fmtx node-role.kubernetes.io/infra=</programlisting>
</listitem>
<listitem>
<simpara>Create a machine config pool that contains both the worker role and your custom role as machine config selector:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat infra.mcp.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: infra
spec:
  machineConfigSelector:
    matchExpressions:
      - {key: machineconfiguration.openshift.io/role, operator: In, values: [worker,infra]} <co xml:id="CO79-1"/>
  nodeSelector:
    matchLabels:
      node-role.kubernetes.io/infra: "" <co xml:id="CO79-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO79-1">
<para>Add the worker role and your custom role.</para>
</callout>
<callout arearefs="CO79-2">
<para>Add the label you added to the node as a <literal>nodeSelector</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>Custom machine config pools inherit machine configs from the worker pool. Custom pools use any machine config targeted for the worker pool, but add the ability to also deploy changes that are targeted at only the custom pool. Because a custom pool inherits resources from the worker pool, any change to the worker pool also affects the custom pool.</simpara>
</note>
</listitem>
<listitem>
<simpara>After you have the YAML file, you can create the machine config pool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f infra.mcp.yaml</programlisting>
</listitem>
<listitem>
<simpara>Check the machine configs to ensure that the infrastructure configuration rendered successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfig</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                        GENERATEDBYCONTROLLER                      IGNITIONVERSION   CREATED
00-master                                                   365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
00-worker                                                   365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
01-master-container-runtime                                 365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
01-master-kubelet                                           365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
01-worker-container-runtime                                 365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
01-worker-kubelet                                           365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
99-master-1ae2a1e0-a115-11e9-8f14-005056899d54-registries   365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
99-master-ssh                                                                                          3.2.0             31d
99-worker-1ae64748-a115-11e9-8f14-005056899d54-registries   365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             31d
99-worker-ssh                                                                                          3.2.0             31d
rendered-infra-4e48906dca84ee702959c71a53ee80e7             365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             23m
rendered-master-072d4b2da7f88162636902b074e9e28e            5b6fb8349a29735e48446d435962dec4547d3090   3.2.0             31d
rendered-master-3e88ec72aed3886dec061df60d16d1af            02c07496ba0417b3e12b78fb32baf6293d314f79   3.2.0             31d
rendered-master-419bee7de96134963a15fdf9dd473b25            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             17d
rendered-master-53f5c91c7661708adce18739cc0f40fb            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             13d
rendered-master-a6a357ec18e5bce7f5ac426fc7c5ffcd            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             7d3h
rendered-master-dc7f874ec77fc4b969674204332da037            5b6fb8349a29735e48446d435962dec4547d3090   3.2.0             31d
rendered-worker-1a75960c52ad18ff5dfa6674eb7e533d            5b6fb8349a29735e48446d435962dec4547d3090   3.2.0             31d
rendered-worker-2640531be11ba43c61d72e82dc634ce6            5b6fb8349a29735e48446d435962dec4547d3090   3.2.0             31d
rendered-worker-4e48906dca84ee702959c71a53ee80e7            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             7d3h
rendered-worker-4f110718fe88e5f349987854a1147755            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             17d
rendered-worker-afc758e194d6188677eb837842d3b379            02c07496ba0417b3e12b78fb32baf6293d314f79   3.2.0             31d
rendered-worker-daa08cc1e8f5fcdeba24de60cd955cc3            365c1cfd14de5b0e3b85e0fc815b0060f36ab955   3.2.0             13d</programlisting>
</para>
</formalpara>
<simpara>You should see a new machine config, with the <literal>rendered-infra-*</literal> prefix.</simpara>
</listitem>
<listitem>
<simpara>Optional: To deploy changes to a custom pool, create a machine config that uses the custom pool name as the label, such as <literal>infra</literal>. Note that this is not required and only shown for instructional purposes. In this manner, you can apply any custom configurations specific to only your infra nodes.</simpara>
<note>
<simpara>After you create the new machine config pool, the MCO generates a new rendered config for that pool, and associated nodes of that pool reboot to apply the new configuration.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat infra.mc.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  name: 51-infra
  labels:
    machineconfiguration.openshift.io/role: infra <co xml:id="CO80-1"/>
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
      - path: /etc/infratest
        mode: 0644
        contents:
          source: data:,infra</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO80-1">
<para>Add the label you added to the node as a <literal>nodeSelector</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the machine config to the infra-labeled nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f infra.mc.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Confirm that your new machine config pool is available:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                             UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
infra    rendered-infra-60e35c2e99f42d976e084fa94da4d0fc    True      False      False      1              1                   1                     0                      4m20s
master   rendered-master-9360fdb895d4c131c7c4bebbae099c90   True      False      False      3              3                   3                     0                      91m
worker   rendered-worker-60e35c2e99f42d976e084fa94da4d0fc   True      False      False      2              2                   2                     0                      91m</programlisting>
</para>
</formalpara>
<simpara>In this example, a worker node was changed to an infra node.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/architecture/#architecture-machine-config-pools_control-plane">Node configuration management with machine config pools</link> for more information on grouping infra machines in a custom pool.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="assigning-machineset-resources-to-infra-nodes">
<title>Assigning machine set resources to infrastructure nodes</title>
<simpara>After creating an infrastructure machine set, the <literal>worker</literal> and <literal>infra</literal> roles are applied to new infra nodes. Nodes with the <literal>infra</literal> role applied are not counted toward the total number of subscriptions that are required to run the environment, even when the <literal>worker</literal> role is also applied.</simpara>
<simpara>However, with an infra node being assigned as a worker, there is a chance user workloads could get inadvertently assigned to an infra node. To avoid this, you can apply a taint to the infra node and tolerations for the pods you want to control.</simpara>
<section xml:id="binding-infra-node-workloads-using-taints-tolerations_creating-infrastructure-machinesets">
<title>Binding infrastructure node workloads using taints and tolerations</title>
<simpara>If you have an infra node that has the <literal>infra</literal> and <literal>worker</literal> roles assigned, you must configure the node so that user workloads are not assigned to it.</simpara>
<important>
<simpara>It is recommended that you preserve the dual <literal>infra,worker</literal> label that is created for infra nodes and use taints and tolerations to manage nodes that user workloads are scheduled on. If you remove the <literal>worker</literal> label from the node, you must create a custom pool to manage it. A node with a label other than <literal>master</literal> or <literal>worker</literal> is not recognized by the MCO without a custom pool. Maintaining the <literal>worker</literal> label allows the node to be managed by the default worker machine config pool, if no custom pools that select the custom label exists. The <literal>infra</literal> label communicates to the cluster that it does not count toward the total number of subscriptions.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Configure additional <literal>MachineSet</literal> objects in your OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a taint to the infra node to prevent scheduling user workloads on it:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Determine if the node has the taint:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe nodes &lt;node_name&gt;</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">oc describe node ci-ln-iyhx092-f76d1-nvdfm-worker-b-wln2l
Name:               ci-ln-iyhx092-f76d1-nvdfm-worker-b-wln2l
Roles:              worker
 ...
Taints:             node-role.kubernetes.io/infra:NoSchedule
 ...</programlisting>
</para>
</formalpara>
<simpara>This example shows that the node has a taint. You can proceed with adding a toleration to your pod in the next step.</simpara>
</listitem>
<listitem>
<simpara>If you have not configured a taint to prevent scheduling user workloads on it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes &lt;node_name&gt; &lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 node-role.kubernetes.io/infra=reserved:NoExecute</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the taint:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    ...
spec:
  taints:
    - key: node-role.kubernetes.io/infra
      effect: NoExecute
      value: reserved
  ...</programlisting>
</tip>
<simpara>This example places a taint on <literal>node1</literal> that has key <literal>node-role.kubernetes.io/infra</literal> and taint effect <literal>NoSchedule</literal>. Nodes with the <literal>NoSchedule</literal> effect schedule only pods that tolerate the taint, but allow existing pods to remain scheduled on the node.</simpara>
<note>
<simpara>If a descheduler is used, pods violating node taints could be evicted from the cluster.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add tolerations for the pod configurations you want to schedule on the infra node, like router, registry, and monitoring workloads. Add the following code to the <literal>Pod</literal> object specification:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">tolerations:
  - effect: NoExecute <co xml:id="CO81-1"/>
    key: node-role.kubernetes.io/infra <co xml:id="CO81-2"/>
    operator: Exists <co xml:id="CO81-3"/>
    value: reserved <co xml:id="CO81-4"/></programlisting>
<calloutlist>
<callout arearefs="CO81-1">
<para>Specify the effect that you added to the node.</para>
</callout>
<callout arearefs="CO81-2">
<para>Specify the key that you added to the node.</para>
</callout>
<callout arearefs="CO81-3">
<para>Specify the <literal>Exists</literal> Operator to require a taint with the key <literal>node-role.kubernetes.io/infra</literal> to be present on the node.</para>
</callout>
<callout arearefs="CO81-4">
<para>Specify the value of the key-value pair taint that you added to the node.</para>
</callout>
</calloutlist>
<simpara>This toleration matches the taint created by the <literal>oc adm taint</literal> command. A pod with this toleration can be scheduled onto the infra node.</simpara>
<note>
<simpara>Moving pods for an Operator installed via OLM to an infra node is not always possible. The capability to move Operator pods depends on the configuration of each Operator.</simpara>
</note>
</listitem>
<listitem>
<simpara>Schedule the pod to the infra node using a scheduler. See the documentation for <emphasis>Controlling pod placement onto nodes</emphasis> for details.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-scheduler-about">Controlling pod placement using the scheduler</link> for general information on scheduling a pod to a node.</simpara>
</listitem>
<listitem>
<simpara>See <link linkend="moving-resources-to-infrastructure-machinesets">Moving resources to infrastructure machine sets</link> for instructions on scheduling pods to infra nodes.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="moving-resources-to-infrastructure-machinesets">
<title>Moving resources to infrastructure machine sets</title>
<simpara>Some of the infrastructure resources are deployed in your cluster by default. You can move them to the infrastructure machine sets that you created by adding the infrastructure node selector, as shown:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  nodePlacement: <co xml:id="CO82-1"/>
    nodeSelector:
      matchLabels:
        node-role.kubernetes.io/infra: ""
    tolerations:
    - effect: NoSchedule
      key: node-role.kubernetes.io/infra
      value: reserved
    - effect: NoExecute
      key: node-role.kubernetes.io/infra
      value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>Add a <literal>nodeSelector</literal> parameter with the appropriate value to the component you want to move. You can use a <literal>nodeSelector</literal> in the format shown or use <literal>&lt;key&gt;: &lt;value&gt;</literal> pairs, based on the value specified for the node.  If you added a taint to the infrasructure node, also add a matching toleration.</para>
</callout>
</calloutlist>
<simpara>Applying a specific node selector to all infrastructure components causes OpenShift Container Platform to <link linkend="moving-resources-to-infrastructure-machinesets">schedule those workloads on nodes with that label</link>.</simpara>
<section xml:id="infrastructure-moving-router_creating-infrastructure-machinesets">
<title>Moving the router</title>
<simpara>You can deploy the router pod to a different compute machine set. By default, the pod is deployed to a worker node.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Configure additional compute machine sets in your OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the <literal>IngressController</literal> custom resource for the router Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ingresscontroller default -n openshift-ingress-operator -o yaml</programlisting>
<simpara>The command output resembles the following text:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: IngressController
metadata:
  creationTimestamp: 2019-04-18T12:35:39Z
  finalizers:
  - ingresscontroller.operator.openshift.io/finalizer-ingresscontroller
  generation: 1
  name: default
  namespace: openshift-ingress-operator
  resourceVersion: "11341"
  selfLink: /apis/operator.openshift.io/v1/namespaces/openshift-ingress-operator/ingresscontrollers/default
  uid: 79509e05-61d6-11e9-bc55-02ce4781844a
spec: {}
status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2019-04-18T12:36:15Z
    status: "True"
    type: Available
  domain: apps.&lt;cluster&gt;.example.com
  endpointPublishingStrategy:
    type: LoadBalancerService
  selector: ingresscontroller.operator.openshift.io/deployment-ingresscontroller=default</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>ingresscontroller</literal> resource and change the <literal>nodeSelector</literal> to use the <literal>infra</literal> label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit ingresscontroller default -n openshift-ingress-operator</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">  spec:
    nodePlacement:
      nodeSelector: <co xml:id="CO83-1"/>
        matchLabels:
          node-role.kubernetes.io/infra: ""
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/infra
        value: reserved
      - effect: NoExecute
        key: node-role.kubernetes.io/infra
        value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para>Add a <literal>nodeSelector</literal> parameter with the appropriate value to the component you want to move. You can use a <literal>nodeSelector</literal> in the format shown or use <literal>&lt;key&gt;: &lt;value&gt;</literal> pairs, based on the value specified for the node. If you added a taint to the infrastructure node, also add a matching toleration.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Confirm that the router pod is running on the <literal>infra</literal> node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>View the list of router pods and note the node name of the running pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod -n openshift-ingress -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              READY     STATUS        RESTARTS   AGE       IP           NODE                           NOMINATED NODE   READINESS GATES
router-default-86798b4b5d-bdlvd   1/1      Running       0          28s       10.130.2.4   ip-10-0-217-226.ec2.internal   &lt;none&gt;           &lt;none&gt;
router-default-955d875f4-255g8    0/1      Terminating   0          19h       10.129.2.4   ip-10-0-148-172.ec2.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
<simpara>In this example, the running pod is on the <literal>ip-10-0-217-226.ec2.internal</literal> node.</simpara>
</listitem>
<listitem>
<simpara>View the node status of the running pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node &lt;node_name&gt; <co xml:id="CO84-1"/></programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para>Specify the <literal>&lt;node_name&gt;</literal> that you obtained from the pod list.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          STATUS  ROLES         AGE   VERSION
ip-10-0-217-226.ec2.internal  Ready   infra,worker  17h   v1.28.5</programlisting>
</para>
</formalpara>
<simpara>Because the role list includes <literal>infra</literal>, the pod is running on the correct node.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="infrastructure-moving-registry_creating-infrastructure-machinesets">
<title>Moving the default registry</title>
<simpara>You configure the registry Operator to deploy its pods to different nodes.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Configure additional compute machine sets in your OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the <literal>config/instance</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configs.imageregistry.operator.openshift.io/cluster -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: imageregistry.operator.openshift.io/v1
kind: Config
metadata:
  creationTimestamp: 2019-02-05T13:52:05Z
  finalizers:
  - imageregistry.operator.openshift.io/finalizer
  generation: 1
  name: cluster
  resourceVersion: "56174"
  selfLink: /apis/imageregistry.operator.openshift.io/v1/configs/cluster
  uid: 36fd3724-294d-11e9-a524-12ffeee2931b
spec:
  httpSecret: d9a012ccd117b1e6616ceccb2c3bb66a5fed1b5e481623
  logging: 2
  managementState: Managed
  proxy: {}
  replicas: 1
  requests:
    read: {}
    write: {}
  storage:
    s3:
      bucket: image-registry-us-east-1-c92e88cad85b48ec8b312344dff03c82-392c
      region: us-east-1
status:
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit the <literal>config/instance</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit configs.imageregistry.operator.openshift.io/cluster</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  affinity:
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
      - podAffinityTerm:
          namespaces:
          - openshift-image-registry
          topologyKey: kubernetes.io/hostname
        weight: 100
  logLevel: Normal
  managementState: Managed
  nodeSelector: <co xml:id="CO85-1"/>
    node-role.kubernetes.io/infra: ""
  tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/infra
    value: reserved
  - effect: NoExecute
    key: node-role.kubernetes.io/infra
    value: reserved</programlisting>
<calloutlist>
<callout arearefs="CO85-1">
<para>Add a <literal>nodeSelector</literal> parameter with the appropriate value to the component you want to move. You can use a <literal>nodeSelector</literal> in the format shown or use <literal>&lt;key&gt;: &lt;value&gt;</literal> pairs, based on the value specified for the node.  If you added a taint to the infrasructure node, also add a matching toleration.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify the registry pod has been moved to the infrastructure node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to identify the node where the registry pod is located:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -o wide -n openshift-image-registry</programlisting>
</listitem>
<listitem>
<simpara>Confirm the node has the label you specified:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node &lt;node_name&gt;</programlisting>
<simpara>Review the command output and confirm that <literal>node-role.kubernetes.io/infra</literal> is in the <literal>LABELS</literal> list.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="infrastructure-moving-monitoring_creating-infrastructure-machinesets">
<title>Moving the monitoring solution</title>
<simpara>The monitoring stack includes multiple components, including Prometheus, Thanos Querier, and Alertmanager.
The Cluster Monitoring Operator manages this stack. To redeploy the monitoring stack to infrastructure nodes, you can create and apply a custom config map.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>cluster-monitoring-config</literal> config map and change the <literal>nodeSelector</literal> to use the <literal>infra</literal> label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit configmap cluster-monitoring-config -n openshift-monitoring</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-monitoring-config
  namespace: openshift-monitoring
data:
  config.yaml: |+
    alertmanagerMain:
      nodeSelector: <co xml:id="CO86-1"/>
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    prometheusK8s:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    prometheusOperator:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    k8sPrometheusAdapter:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    kubeStateMetrics:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    telemeterClient:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    openshiftStateMetrics:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    thanosQuerier:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute
    monitoringPlugin:
      nodeSelector:
        node-role.kubernetes.io/infra: ""
      tolerations:
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoSchedule
      - key: node-role.kubernetes.io/infra
        value: reserved
        effect: NoExecute</programlisting>
<calloutlist>
<callout arearefs="CO86-1">
<para>Add a <literal>nodeSelector</literal> parameter with the appropriate value to the component you want to move. You can use a <literal>nodeSelector</literal> in the format shown or use <literal>&lt;key&gt;: &lt;value&gt;</literal> pairs, based on the value specified for the node. If you added a taint to the infrastructure node, also add a matching toleration.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Watch the monitoring pods move to the new machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ watch 'oc get pod -n openshift-monitoring -o wide'</programlisting>
</listitem>
<listitem>
<simpara>If a component has not moved to the <literal>infra</literal> node, delete the pod with this component:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pod -n openshift-monitoring &lt;pod&gt;</programlisting>
<simpara>The component from the deleted pod is re-created on the <literal>infra</literal> node.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="infrastructure-moving-logging_creating-infrastructure-machinesets">
<title>Moving logging resources</title>
<simpara>You can configure the Red Hat OpenShift Logging Operator to deploy the pods for logging components, such as Elasticsearch and Kibana, to different nodes. You cannot move the Red Hat OpenShift Logging Operator pod from its installed location.</simpara>
<simpara>For example, you can move the Elasticsearch pods to a separate node because of high CPU, memory, and disk requirements.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat OpenShift Logging Operator and the OpenShift Elasticsearch Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>ClusterLogging</literal> custom resource (CR) in the <literal>openshift-logging</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit ClusterLogging instance</programlisting>
<formalpara>
<title>Example <literal>ClusterLogging</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: ClusterLogging
# ...
spec:
  logStore:
    elasticsearch:
      nodeCount: 3
      nodeSelector: <co xml:id="CO87-1"/>
        node-role.kubernetes.io/infra: ''
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/infra
        value: reserved
      - effect: NoExecute
        key: node-role.kubernetes.io/infra
        value: reserved
      redundancyPolicy: SingleRedundancy
      resources:
        limits:
          cpu: 500m
          memory: 16Gi
        requests:
          cpu: 500m
          memory: 16Gi
      storage: {}
    type: elasticsearch
  managementState: Managed
  visualization:
    kibana:
      nodeSelector: <co xml:id="CO87-2"/>
        node-role.kubernetes.io/infra: ''
      tolerations:
      - effect: NoSchedule
        key: node-role.kubernetes.io/infra
        value: reserved
      - effect: NoExecute
        key: node-role.kubernetes.io/infra
        value: reserved
      proxy:
        resources: null
      replicas: 1
      resources: null
    type: kibana
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO87-1 CO87-2">
<para>Add a <literal>nodeSelector</literal> parameter with the appropriate value to the component you want to move. You can use a <literal>nodeSelector</literal> in the format shown or use <literal>&lt;key&gt;: &lt;value&gt;</literal> pairs, based on the value specified for the node.  If you added a taint to the infrasructure node, also add a matching toleration.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that a component has moved, you can use the <literal>oc get pod -o wide</literal> command.</para>
</formalpara>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>You want to move the Kibana pod from the <literal>ip-10-0-147-79.us-east-2.compute.internal</literal> node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod kibana-5b8bdf44f9-ccpq9 -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                      READY   STATUS    RESTARTS   AGE   IP            NODE                                        NOMINATED NODE   READINESS GATES
kibana-5b8bdf44f9-ccpq9   2/2     Running   0          27s   10.129.2.18   ip-10-0-147-79.us-east-2.compute.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You want to move the Kibana pod to the <literal>ip-10-0-139-48.us-east-2.compute.internal</literal> node, a dedicated infrastructure node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         STATUS   ROLES          AGE   VERSION
ip-10-0-133-216.us-east-2.compute.internal   Ready    master         60m   v1.28.5
ip-10-0-139-146.us-east-2.compute.internal   Ready    master         60m   v1.28.5
ip-10-0-139-192.us-east-2.compute.internal   Ready    worker         51m   v1.28.5
ip-10-0-139-241.us-east-2.compute.internal   Ready    worker         51m   v1.28.5
ip-10-0-147-79.us-east-2.compute.internal    Ready    worker         51m   v1.28.5
ip-10-0-152-241.us-east-2.compute.internal   Ready    master         60m   v1.28.5
ip-10-0-139-48.us-east-2.compute.internal    Ready    infra          51m   v1.28.5</programlisting>
</para>
</formalpara>
<simpara>Note that the node has a <literal>node-role.kubernetes.io/infra: ''</literal> label:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node ip-10-0-139-48.us-east-2.compute.internal -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: ip-10-0-139-48.us-east-2.compute.internal
  selfLink: /api/v1/nodes/ip-10-0-139-48.us-east-2.compute.internal
  uid: 62038aa9-661f-41d7-ba93-b5f1b6ef8751
  resourceVersion: '39083'
  creationTimestamp: '2020-04-13T19:07:55Z'
  labels:
    node-role.kubernetes.io/infra: ''
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To move the Kibana pod, edit the <literal>ClusterLogging</literal> CR to add a node selector:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: logging.openshift.io/v1
kind: ClusterLogging
# ...
spec:
# ...
  visualization:
    kibana:
      nodeSelector: <co xml:id="CO88-1"/>
        node-role.kubernetes.io/infra: ''
      proxy:
        resources: null
      replicas: 1
      resources: null
    type: kibana</programlisting>
<calloutlist>
<callout arearefs="CO88-1">
<para>Add a node selector to match the label in the node specification.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After you save the CR, the current Kibana pod is terminated and new pod is deployed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                            READY   STATUS        RESTARTS   AGE
cluster-logging-operator-84d98649c4-zb9g7       1/1     Running       0          29m
elasticsearch-cdm-hwv01pf7-1-56588f554f-kpmlg   2/2     Running       0          28m
elasticsearch-cdm-hwv01pf7-2-84c877d75d-75wqj   2/2     Running       0          28m
elasticsearch-cdm-hwv01pf7-3-f5d95b87b-4nx78    2/2     Running       0          28m
collector-42dzz                                 1/1     Running       0          28m
collector-d74rq                                 1/1     Running       0          28m
collector-m5vr9                                 1/1     Running       0          28m
collector-nkxl7                                 1/1     Running       0          28m
collector-pdvqb                                 1/1     Running       0          28m
collector-tflh6                                 1/1     Running       0          28m
kibana-5b8bdf44f9-ccpq9                         2/2     Terminating   0          4m11s
kibana-7d85dcffc8-bfpfp                         2/2     Running       0          33s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The new pod is on the <literal>ip-10-0-139-48.us-east-2.compute.internal</literal> node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod kibana-7d85dcffc8-bfpfp -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                      READY   STATUS        RESTARTS   AGE   IP            NODE                                        NOMINATED NODE   READINESS GATES
kibana-7d85dcffc8-bfpfp   2/2     Running       0          43s   10.131.0.22   ip-10-0-139-48.us-east-2.compute.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After a few moments, the original Kibana pod is removed.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                            READY   STATUS    RESTARTS   AGE
cluster-logging-operator-84d98649c4-zb9g7       1/1     Running   0          30m
elasticsearch-cdm-hwv01pf7-1-56588f554f-kpmlg   2/2     Running   0          29m
elasticsearch-cdm-hwv01pf7-2-84c877d75d-75wqj   2/2     Running   0          29m
elasticsearch-cdm-hwv01pf7-3-f5d95b87b-4nx78    2/2     Running   0          29m
collector-42dzz                                 1/1     Running   0          29m
collector-d74rq                                 1/1     Running   0          29m
collector-m5vr9                                 1/1     Running   0          29m
collector-nkxl7                                 1/1     Running   0          29m
collector-pdvqb                                 1/1     Running   0          29m
collector-tflh6                                 1/1     Running   0          29m
kibana-7d85dcffc8-bfpfp                         2/2     Running   0          62s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/monitoring/#moving-monitoring-components-to-different-nodes_configuring-the-monitoring-stack">the monitoring documentation</link> for the general instructions on moving OpenShift Container Platform components.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="adding-rhel-compute">
<title>Adding RHEL compute machines to an OpenShift Container Platform cluster</title>

<simpara>In OpenShift Container Platform, you can add Red Hat Enterprise Linux (RHEL) compute machines to a user-provisioned infrastructure cluster or an installation-provisioned infrastructure cluster on the <literal>x86_64</literal> architecture. You can use RHEL as the operating system only on compute machines.</simpara>
<section xml:id="rhel-compute-overview_adding-rhel-compute">
<title>About adding RHEL compute nodes to a cluster</title>
<simpara>In OpenShift Container Platform 4.14, you have the option of using Red Hat Enterprise Linux (RHEL) machines as compute machines in your cluster if you use a user-provisioned or installer-provisioned infrastructure installation on the <literal>x86_64</literal> architecture. You must use Red Hat Enterprise Linux CoreOS (RHCOS) machines for the control plane machines in your cluster.</simpara>
<simpara>If you choose to use RHEL compute machines in your cluster, you are responsible for all operating system life cycle management and maintenance. You must perform system updates, apply patches, and complete all other required tasks.</simpara>
<simpara>For installer-provisioned infrastructure clusters, you must manually add RHEL compute machines because automatic scaling in installer-provisioned infrastructure clusters adds Red Hat Enterprise Linux CoreOS (RHCOS) compute machines by default.</simpara>
<important>
<itemizedlist>
<listitem>
<simpara>Because removing OpenShift Container Platform from a machine in the cluster requires destroying the operating system, you must use dedicated hardware for any RHEL machines that you add to the cluster.</simpara>
</listitem>
<listitem>
<simpara>Swap memory is disabled on all RHEL machines that you add to your OpenShift Container Platform cluster. You cannot enable swap memory on these machines.</simpara>
</listitem>
</itemizedlist>
</important>
<simpara>You must add any RHEL compute machines to the cluster after you initialize the control plane.</simpara>
</section>
<section xml:id="rhel-compute-requirements_adding-rhel-compute">
<title>System requirements for RHEL compute nodes</title>
<simpara>The Red Hat Enterprise Linux (RHEL) compute machine hosts in your OpenShift Container Platform environment must meet the following minimum hardware specifications and system-level requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>You must have an active OpenShift Container Platform subscription on your Red Hat account. If you do not, contact your sales representative for more information.</simpara>
</listitem>
<listitem>
<simpara>Production environments must provide compute machines to support your expected workloads. As a cluster administrator, you must calculate the expected workload and add about 10% for overhead. For production environments, allocate enough resources so that a node host failure does not affect your maximum capacity.</simpara>
</listitem>
<listitem>
<simpara>Each system must meet the following hardware requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>Physical or virtual system, or an instance running on a public or private IaaS.</simpara>
</listitem>
<listitem>
<simpara>Base OS: <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/performing_a_standard_rhel_installation/index">RHEL 8.6 and later</link> with "Minimal" installation option.</simpara>
<important>
<simpara>Adding RHEL 7 compute machines to an OpenShift Container Platform cluster is not supported.</simpara>
<simpara>If you have RHEL 7 compute machines that were previously supported in a past OpenShift Container Platform version, you cannot upgrade them to RHEL 8. You must deploy new RHEL 8 hosts, and the old RHEL 7 hosts should be removed. See the "Deleting nodes" section for more information.</simpara>
<simpara>For the most recent list of major functionality that has been deprecated or removed within OpenShift Container Platform, refer to the <emphasis>Deprecated and removed features</emphasis> section of the OpenShift Container Platform release notes.</simpara>
</important>
</listitem>
<listitem>
<simpara>If you deployed OpenShift Container Platform in FIPS mode, you must enable FIPS on the RHEL machine before you boot it. See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/assembly_installing-a-rhel-8-system-with-fips-mode-enabled_security-hardening">Installing a RHEL 8 system with FIPS mode enabled</link> in the RHEL 8 documentation.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<important>
<simpara>To enable FIPS mode for your cluster, you must run the installation program from a Red Hat Enterprise Linux (RHEL) computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>. When running Red Hat Enterprise Linux (RHEL) or Red Hat Enterprise Linux CoreOS (RHCOS) booted in FIPS mode, OpenShift Container Platform core components use the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara>NetworkManager 1.0 or later.</simpara>
</listitem>
<listitem>
<simpara>1 vCPU.</simpara>
</listitem>
<listitem>
<simpara>Minimum 8 GB RAM.</simpara>
</listitem>
<listitem>
<simpara>Minimum 15 GB hard disk space for the file system containing <literal>/var/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Minimum 1 GB hard disk space for the file system containing <literal>/usr/local/bin/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Minimum 1 GB hard disk space for the file system containing its temporary directory. The temporary system directory is determined according to the rules defined in the tempfile module in the Python standard library.</simpara>
<itemizedlist>
<listitem>
<simpara>Each system must meet any additional requirements for your system provider. For example, if you installed your cluster on VMware vSphere, your disks must be configured according to its <link xlink:href="https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/index.html">storage guidelines</link> and the <literal>disk.enableUUID=true</literal> attribute must be set.</simpara>
</listitem>
<listitem>
<simpara>Each system must be able to access the cluster&#8217;s API endpoints by using DNS-resolvable hostnames. Any network security access control that is in place must allow system access to the cluster&#8217;s API service endpoints.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-nodes-working-deleting_nodes-nodes-working">Deleting nodes</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="csr-management_adding-rhel-compute">
<title>Certificate signing requests management</title>
<simpara>Because your cluster has limited access to automatic machine management when you use infrastructure that you provision, you must provide a mechanism for approving cluster certificate signing requests (CSRs) after installation. The <literal>kube-controller-manager</literal> only approves the kubelet client CSRs. The <literal>machine-approver</literal> cannot guarantee the validity of a serving certificate that is requested by using kubelet credentials because it cannot confirm that the correct machine issued the request. You must determine and implement a method of verifying the validity of the kubelet serving certificate requests and approving them.</simpara>
</section>
</section>
<section xml:id="adding-rhel-compute-preparing-image-cloud">
<title>Preparing an image for your cloud</title>
<simpara>Amazon Machine Images (AMI) are required because various image formats cannot be used directly by AWS. You may use the AMIs that Red Hat has provided, or you can manually import your own images. The AMI must exist before the EC2 instance can be provisioned. You will need a valid AMI ID so that the correct RHEL version needed for the compute machines is selected.</simpara>
<section xml:id="rhel-images-aws_adding-rhel-compute">
<title>Listing latest available RHEL images on AWS</title>
<simpara>AMI IDs correspond to native boot images for AWS. Because an AMI must exist before the EC2 instance is provisioned, you will need to know the AMI ID before configuration. The <link xlink:href="https://aws.amazon.com/cli/">AWS Command Line Interface (CLI)</link> is used to list the available Red Hat Enterprise Linux (RHEL) image IDs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the AWS CLI.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use this command to list RHEL 8.4 Amazon Machine Images (AMI):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ aws ec2 describe-images --owners 309956199498 \ <co xml:id="CO89-1"/>
--query 'sort_by(Images, &amp;CreationDate)[*].[CreationDate,Name,ImageId]' \ <co xml:id="CO89-2"/>
--filters "Name=name,Values=RHEL-8.4*" \ <co xml:id="CO89-3"/>
--region us-east-1 \ <co xml:id="CO89-4"/>
--output table <co xml:id="CO89-5"/></programlisting>
<calloutlist>
<callout arearefs="CO89-1">
<para>The <literal>--owners</literal> command option shows Red Hat images based on the account ID <literal>309956199498</literal>.</para>
<important>
<simpara>This account ID is required to display AMI IDs for images that are provided by Red Hat.</simpara>
</important>
</callout>
<callout arearefs="CO89-2">
<para>The <literal>--query</literal> command option sets how the images are sorted with the parameters <literal>'sort_by(Images, &amp;CreationDate)[*].[CreationDate,Name,ImageId]'</literal>. In this case, the images are sorted by the creation date, and the table is structured to show the creation date, the name of the image, and the AMI IDs.</para>
</callout>
<callout arearefs="CO89-3">
<para>The <literal>--filter</literal> command option sets which version of RHEL is shown. In this example, since the filter is set by <literal>"Name=name,Values=RHEL-8.4*"</literal>, then RHEL 8.4 AMIs are shown.</para>
</callout>
<callout arearefs="CO89-4">
<para>The <literal>--region</literal> command option sets where the region where an AMI is stored.</para>
</callout>
<callout arearefs="CO89-5">
<para>The <literal>--output</literal> command option sets how the results are displayed.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<note>
<simpara>When creating a RHEL compute machine for AWS, ensure that the AMI is RHEL 8.4 or 8.5.</simpara>
</note>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">------------------------------------------------------------------------------------------------------------
|                                              DescribeImages                                              |
+---------------------------+-----------------------------------------------------+------------------------+
|  2021-03-18T14:23:11.000Z |  RHEL-8.4.0_HVM_BETA-20210309-x86_64-1-Hourly2-GP2  |  ami-07eeb4db5f7e5a8fb |
|  2021-03-18T14:38:28.000Z |  RHEL-8.4.0_HVM_BETA-20210309-arm64-1-Hourly2-GP2   |  ami-069d22ec49577d4bf |
|  2021-05-18T19:06:34.000Z |  RHEL-8.4.0_HVM-20210504-arm64-2-Hourly2-GP2        |  ami-01fc429821bf1f4b4 |
|  2021-05-18T20:09:47.000Z |  RHEL-8.4.0_HVM-20210504-x86_64-2-Hourly2-GP2       |  ami-0b0af3577fe5e3532 |
+---------------------------+-----------------------------------------------------+------------------------+</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>You may also manually <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/image_builder_guide/sect-documentation-image_builder-chapter5-section_2">import RHEL images to AWS</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="rhel-preparing-playbook-machine_adding-rhel-compute">
<title>Preparing the machine to run the playbook</title>
<simpara>Before you can add compute machines that use Red Hat Enterprise Linux (RHEL) as the operating system to an OpenShift Container Platform 4.14 cluster, you must prepare a RHEL 8 machine to run an Ansible playbook that adds the new node to the cluster. This machine is not part of the cluster but must be able to access it.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>) on the machine that you run the playbook on.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Ensure that the <literal>kubeconfig</literal> file for the cluster and the installation program that you used to install the cluster are on the RHEL 8 machine. One way to accomplish this is to use the same machine that you used to install the cluster.</simpara>
</listitem>
<listitem>
<simpara>Configure the machine to access all of the RHEL hosts that you plan to use as compute machines. You can use any method that your company allows, including a bastion with an SSH proxy or a VPN.</simpara>
</listitem>
<listitem>
<simpara>Configure a user on the machine that you run the playbook on that has SSH access to all of the RHEL hosts.</simpara>
<important>
<simpara>If you use SSH key-based authentication, you must manage the key with an SSH agent.</simpara>
</important>
</listitem>
<listitem>
<simpara>If you have not already done so, register the machine with RHSM and attach a pool with an <literal>OpenShift</literal> subscription to it:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Register the machine with RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager register --username=&lt;user_name&gt; --password=&lt;password&gt;</programlisting>
</listitem>
<listitem>
<simpara>Pull the latest subscription data from RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager refresh</programlisting>
</listitem>
<listitem>
<simpara>List the available subscriptions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager list --available --matches '*OpenShift*'</programlisting>
</listitem>
<listitem>
<simpara>In the output for the previous command, find the pool ID for an OpenShift Container Platform subscription and attach it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager attach --pool=&lt;pool_id&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enable the repositories required by OpenShift Container Platform 4.14:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos \
    --enable="rhel-8-for-x86_64-baseos-rpms" \
    --enable="rhel-8-for-x86_64-appstream-rpms" \
    --enable="rhocp-4.14-for-rhel-8-x86_64-rpms"</programlisting>
</listitem>
<listitem>
<simpara>Install the required packages, including <literal>openshift-ansible</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum install openshift-ansible openshift-clients jq</programlisting>
<simpara>The <literal>openshift-ansible</literal> package provides installation program utilities and pulls in other packages that you require to add a RHEL compute node to your cluster, such as Ansible, playbooks, and related configuration files. The <literal>openshift-clients</literal> provides the <literal>oc</literal> CLI, and the <literal>jq</literal> package improves the display of JSON output on your command line.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="rhel-preparing-node_adding-rhel-compute">
<title>Preparing a RHEL compute node</title>
<simpara>Before you add a Red Hat Enterprise Linux (RHEL) machine to your OpenShift Container Platform cluster, you must register each host with Red Hat Subscription Manager (RHSM), attach an active OpenShift Container Platform subscription, and enable the required repositories. Ensure <literal>NetworkManager</literal> is enabled and configured to control all interfaces on the host.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On each host, register with RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager register --username=&lt;user_name&gt; --password=&lt;password&gt;</programlisting>
</listitem>
<listitem>
<simpara>Pull the latest subscription data from RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager refresh</programlisting>
</listitem>
<listitem>
<simpara>List the available subscriptions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager list --available --matches '*OpenShift*'</programlisting>
</listitem>
<listitem>
<simpara>In the output for the previous command, find the pool ID for an OpenShift Container Platform subscription and attach it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager attach --pool=&lt;pool_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>Disable all yum repositories:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Disable all the enabled RHSM repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos --disable="*"</programlisting>
</listitem>
<listitem>
<simpara>List the remaining yum repositories and note their names under <literal>repo id</literal>, if any:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum repolist</programlisting>
</listitem>
<listitem>
<simpara>Use <literal>yum-config-manager</literal> to disable the remaining yum repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum-config-manager --disable &lt;repo_id&gt;</programlisting>
<simpara>Alternatively, disable all repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum-config-manager --disable \*</programlisting>
<simpara>Note that this might take a few minutes if you have a large number of available repositories</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enable only the repositories required by OpenShift Container Platform 4.14:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos \
    --enable="rhel-8-for-x86_64-baseos-rpms" \
    --enable="rhel-8-for-x86_64-appstream-rpms" \
    --enable="rhocp-4.14-for-rhel-8-x86_64-rpms" \
    --enable="fast-datapath-for-rhel-8-x86_64-rpms"</programlisting>
</listitem>
<listitem>
<simpara>Stop and disable firewalld on the host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># systemctl disable --now firewalld.service</programlisting>
<note>
<simpara>You must not enable firewalld later. If you do, you cannot access OpenShift Container Platform logs on the worker.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="rhel-attaching-instance-aws_adding-rhel-compute">
<title>Attaching the role permissions to RHEL instance in AWS</title>
<simpara>Using the Amazon IAM console in your browser, you may select the needed roles and assign them to a worker node.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the AWS IAM console, create your <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#create-iam-role">desired IAM role</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#attach-iam-role">Attach the IAM role</link> to the desired worker node.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-aws-permissions-iam-roles_installing-aws-account">Required AWS permissions for IAM roles</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="rhel-worker-tag_adding-rhel-compute">
<title>Tagging a RHEL worker node as owned or shared</title>
<simpara>A cluster uses the value of the <literal>kubernetes.io/cluster/&lt;clusterid&gt;,Value=(owned|shared)</literal> tag to determine the lifetime of the resources related to the AWS cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>owned</literal> tag value should be added if the resource should be destroyed as part of destroying the cluster.</simpara>
</listitem>
<listitem>
<simpara>The <literal>shared</literal> tag value should be added if the resource continues to exist after the cluster has been destroyed. This tagging denotes that the cluster uses this resource, but there is a separate owner for the resource.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>With RHEL compute machines, the RHEL worker instance must be tagged with <literal>kubernetes.io/cluster/&lt;clusterid&gt;=owned</literal> or <literal>kubernetes.io/cluster/&lt;cluster-id&gt;=shared</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Do not tag all existing security groups with the <literal>kubernetes.io/cluster/&lt;name&gt;,Value=&lt;clusterid&gt;</literal> tag, or the Elastic Load Balancing (ELB) will not be able to create a load balancer.</simpara>
</note>
</section>
<section xml:id="rhel-adding-node_adding-rhel-compute">
<title>Adding a RHEL compute machine to your cluster</title>
<simpara>You can add compute machines that use Red Hat Enterprise Linux as the operating system to an OpenShift Container Platform 4.14 cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You installed the required packages and performed the necessary configuration on the machine that you run the playbook on.</simpara>
</listitem>
<listitem>
<simpara>You prepared the RHEL hosts for installation.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Perform the following steps on the machine that you prepared to run the playbook:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create an Ansible inventory file that is named <literal>/&lt;path&gt;/inventory/hosts</literal> that defines your compute machine hosts and required variables:</simpara>
<screen>[all:vars]
ansible_user=root <co xml:id="CO90-1"/>
#ansible_become=True <co xml:id="CO90-2"/>

openshift_kubeconfig_path="~/.kube/config" <co xml:id="CO90-3"/>

[new_workers] <co xml:id="CO90-4"/>
mycluster-rhel8-0.example.com
mycluster-rhel8-1.example.com</screen>
<calloutlist>
<callout arearefs="CO90-1">
<para>Specify the user name that runs the Ansible tasks on the remote compute machines.</para>
</callout>
<callout arearefs="CO90-2">
<para>If you do not specify <literal>root</literal> for the <literal>ansible_user</literal>, you must set <literal>ansible_become</literal> to <literal>True</literal> and assign the user sudo permissions.</para>
</callout>
<callout arearefs="CO90-3">
<para>Specify the path and file name of the <literal>kubeconfig</literal> file for your cluster.</para>
</callout>
<callout arearefs="CO90-4">
<para>List each RHEL machine to add to your cluster. You must provide the fully-qualified domain name for each host. This name is the hostname that the cluster uses to access the machine, so set the correct public or private name to access the machine.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Navigate to the Ansible playbook directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd /usr/share/ansible/openshift-ansible</programlisting>
</listitem>
<listitem>
<simpara>Run the playbook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-playbook -i /&lt;path&gt;/inventory/hosts playbooks/scaleup.yml <co xml:id="CO91-1"/></programlisting>
<calloutlist>
<callout arearefs="CO91-1">
<para>For <literal>&lt;path&gt;</literal>, specify the path to the Ansible inventory file that you created.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-approve-csrs_adding-rhel-compute">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO92-1"/></programlisting>
<calloutlist>
<callout arearefs="CO92-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO93-1"/></programlisting>
<calloutlist>
<callout arearefs="CO93-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="rhel-ansible-parameters_adding-rhel-compute">
<title>Required parameters for the Ansible hosts file</title>
<simpara>You must define the following parameters in the Ansible hosts file before you add Red Hat Enterprise Linux (RHEL) compute machines to your cluster.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ansible_user</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The SSH user that allows SSH-based authentication without requiring a password. If you use SSH key-based authentication, then you must manage the key with an SSH agent.</simpara></entry>
<entry align="left" valign="top"><simpara>A user name on the system. The default value is <literal>root</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ansible_become</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the values of <literal>ansible_user</literal> is not root, you must set <literal>ansible_become</literal> to <literal>True</literal>, and the user that you specify as the <literal>ansible_user</literal>  must be configured for passwordless sudo access.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal>. If the value is not <literal>True</literal>, do not specify and define this parameter.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_kubeconfig_path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a path and file name to a local directory that contains the <literal>kubeconfig</literal> file for your cluster.</simpara></entry>
<entry align="left" valign="top"><simpara>The path and name of the configuration file.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="rhel-removing-rhcos_adding-rhel-compute">
<title>Optional: Removing RHCOS compute machines from a cluster</title>
<simpara>After you add the Red Hat Enterprise Linux (RHEL) compute machines to your cluster, you can optionally remove the Red Hat Enterprise Linux CoreOS (RHCOS) compute machines to free up resources.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have added RHEL compute machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the list of machines and record the node names of the RHCOS compute machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -o wide</programlisting>
</listitem>
<listitem>
<simpara>For each RHCOS compute machine, delete the node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Mark the node as unschedulable by running the <literal>oc adm cordon</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;node_name&gt; <co xml:id="CO94-1"/></programlisting>
<calloutlist>
<callout arearefs="CO94-1">
<para>Specify the node name of one of the RHCOS compute machines.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Drain all the pods from the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node_name&gt; --force --delete-emptydir-data --ignore-daemonsets <co xml:id="CO95-1"/></programlisting>
<calloutlist>
<callout arearefs="CO95-1">
<para>Specify the node name of the RHCOS compute machine that you isolated.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Delete the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete nodes &lt;node_name&gt; <co xml:id="CO96-1"/></programlisting>
<calloutlist>
<callout arearefs="CO96-1">
<para>Specify the node name of the RHCOS compute machine that you drained.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Review the list of compute machines to ensure that only the RHEL nodes remain:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -o wide</programlisting>
</listitem>
<listitem>
<simpara>Remove the RHCOS machines from the load balancer for your cluster&#8217;s compute machines. You can delete the virtual machines or reimage the physical hardware for the RHCOS compute machines.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="more-rhel-compute">
<title>Adding more RHEL compute machines to an OpenShift Container Platform cluster</title>

<simpara>If your OpenShift Container Platform cluster already includes Red Hat Enterprise Linux (RHEL) compute machines, which are also known as worker machines, you can add more RHEL compute machines to it.</simpara>
<section xml:id="rhel-compute-overview_more-rhel-compute">
<title>About adding RHEL compute nodes to a cluster</title>
<simpara>In OpenShift Container Platform 4.14, you have the option of using Red Hat Enterprise Linux (RHEL) machines as compute machines in your cluster if you use a user-provisioned or installer-provisioned infrastructure installation on the <literal>x86_64</literal> architecture. You must use Red Hat Enterprise Linux CoreOS (RHCOS) machines for the control plane machines in your cluster.</simpara>
<simpara>If you choose to use RHEL compute machines in your cluster, you are responsible for all operating system life cycle management and maintenance. You must perform system updates, apply patches, and complete all other required tasks.</simpara>
<simpara>For installer-provisioned infrastructure clusters, you must manually add RHEL compute machines because automatic scaling in installer-provisioned infrastructure clusters adds Red Hat Enterprise Linux CoreOS (RHCOS) compute machines by default.</simpara>
<important>
<itemizedlist>
<listitem>
<simpara>Because removing OpenShift Container Platform from a machine in the cluster requires destroying the operating system, you must use dedicated hardware for any RHEL machines that you add to the cluster.</simpara>
</listitem>
<listitem>
<simpara>Swap memory is disabled on all RHEL machines that you add to your OpenShift Container Platform cluster. You cannot enable swap memory on these machines.</simpara>
</listitem>
</itemizedlist>
</important>
<simpara>You must add any RHEL compute machines to the cluster after you initialize the control plane.</simpara>
</section>
<section xml:id="rhel-compute-requirements_more-rhel-compute">
<title>System requirements for RHEL compute nodes</title>
<simpara>The Red Hat Enterprise Linux (RHEL) compute machine hosts in your OpenShift Container Platform environment must meet the following minimum hardware specifications and system-level requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>You must have an active OpenShift Container Platform subscription on your Red Hat account. If you do not, contact your sales representative for more information.</simpara>
</listitem>
<listitem>
<simpara>Production environments must provide compute machines to support your expected workloads. As a cluster administrator, you must calculate the expected workload and add about 10% for overhead. For production environments, allocate enough resources so that a node host failure does not affect your maximum capacity.</simpara>
</listitem>
<listitem>
<simpara>Each system must meet the following hardware requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>Physical or virtual system, or an instance running on a public or private IaaS.</simpara>
</listitem>
<listitem>
<simpara>Base OS: <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/performing_a_standard_rhel_installation/index">RHEL 8.6 and later</link> with "Minimal" installation option.</simpara>
<important>
<simpara>Adding RHEL 7 compute machines to an OpenShift Container Platform cluster is not supported.</simpara>
<simpara>If you have RHEL 7 compute machines that were previously supported in a past OpenShift Container Platform version, you cannot upgrade them to RHEL 8. You must deploy new RHEL 8 hosts, and the old RHEL 7 hosts should be removed. See the "Deleting nodes" section for more information.</simpara>
<simpara>For the most recent list of major functionality that has been deprecated or removed within OpenShift Container Platform, refer to the <emphasis>Deprecated and removed features</emphasis> section of the OpenShift Container Platform release notes.</simpara>
</important>
</listitem>
<listitem>
<simpara>If you deployed OpenShift Container Platform in FIPS mode, you must enable FIPS on the RHEL machine before you boot it. See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/assembly_installing-a-rhel-8-system-with-fips-mode-enabled_security-hardening">Installing a RHEL 8 system with FIPS mode enabled</link> in the RHEL 8 documentation.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<important>
<simpara>To enable FIPS mode for your cluster, you must run the installation program from a Red Hat Enterprise Linux (RHEL) computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>. When running Red Hat Enterprise Linux (RHEL) or Red Hat Enterprise Linux CoreOS (RHCOS) booted in FIPS mode, OpenShift Container Platform core components use the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara>NetworkManager 1.0 or later.</simpara>
</listitem>
<listitem>
<simpara>1 vCPU.</simpara>
</listitem>
<listitem>
<simpara>Minimum 8 GB RAM.</simpara>
</listitem>
<listitem>
<simpara>Minimum 15 GB hard disk space for the file system containing <literal>/var/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Minimum 1 GB hard disk space for the file system containing <literal>/usr/local/bin/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Minimum 1 GB hard disk space for the file system containing its temporary directory. The temporary system directory is determined according to the rules defined in the tempfile module in the Python standard library.</simpara>
<itemizedlist>
<listitem>
<simpara>Each system must meet any additional requirements for your system provider. For example, if you installed your cluster on VMware vSphere, your disks must be configured according to its <link xlink:href="https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/index.html">storage guidelines</link> and the <literal>disk.enableUUID=true</literal> attribute must be set.</simpara>
</listitem>
<listitem>
<simpara>Each system must be able to access the cluster&#8217;s API endpoints by using DNS-resolvable hostnames. Any network security access control that is in place must allow system access to the cluster&#8217;s API service endpoints.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-nodes-working-deleting_nodes-nodes-working">Deleting nodes</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="csr-management_more-rhel-compute">
<title>Certificate signing requests management</title>
<simpara>Because your cluster has limited access to automatic machine management when you use infrastructure that you provision, you must provide a mechanism for approving cluster certificate signing requests (CSRs) after installation. The <literal>kube-controller-manager</literal> only approves the kubelet client CSRs. The <literal>machine-approver</literal> cannot guarantee the validity of a serving certificate that is requested by using kubelet credentials because it cannot confirm that the correct machine issued the request. You must determine and implement a method of verifying the validity of the kubelet serving certificate requests and approving them.</simpara>
</section>
</section>
<section xml:id="more-rhel-compute-preparing-image-cloud">
<title>Preparing an image for your cloud</title>
<simpara>Amazon Machine Images (AMI) are required since various image formats cannot be used directly by AWS. You may use the AMIs that Red Hat has provided, or you can manually import your own images. The AMI must exist before the EC2 instance can be provisioned. You must list the AMI IDs so that the correct RHEL version needed for the compute machines is selected.</simpara>
<section xml:id="rhel-images-aws_more-rhel-compute">
<title>Listing latest available RHEL images on AWS</title>
<simpara>AMI IDs correspond to native boot images for AWS. Because an AMI must exist before the EC2 instance is provisioned, you will need to know the AMI ID before configuration. The <link xlink:href="https://aws.amazon.com/cli/">AWS Command Line Interface (CLI)</link> is used to list the available Red Hat Enterprise Linux (RHEL) image IDs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the AWS CLI.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use this command to list RHEL 8.4 Amazon Machine Images (AMI):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ aws ec2 describe-images --owners 309956199498 \ <co xml:id="CO97-1"/>
--query 'sort_by(Images, &amp;CreationDate)[*].[CreationDate,Name,ImageId]' \ <co xml:id="CO97-2"/>
--filters "Name=name,Values=RHEL-8.4*" \ <co xml:id="CO97-3"/>
--region us-east-1 \ <co xml:id="CO97-4"/>
--output table <co xml:id="CO97-5"/></programlisting>
<calloutlist>
<callout arearefs="CO97-1">
<para>The <literal>--owners</literal> command option shows Red Hat images based on the account ID <literal>309956199498</literal>.</para>
<important>
<simpara>This account ID is required to display AMI IDs for images that are provided by Red Hat.</simpara>
</important>
</callout>
<callout arearefs="CO97-2">
<para>The <literal>--query</literal> command option sets how the images are sorted with the parameters <literal>'sort_by(Images, &amp;CreationDate)[*].[CreationDate,Name,ImageId]'</literal>. In this case, the images are sorted by the creation date, and the table is structured to show the creation date, the name of the image, and the AMI IDs.</para>
</callout>
<callout arearefs="CO97-3">
<para>The <literal>--filter</literal> command option sets which version of RHEL is shown. In this example, since the filter is set by <literal>"Name=name,Values=RHEL-8.4*"</literal>, then RHEL 8.4 AMIs are shown.</para>
</callout>
<callout arearefs="CO97-4">
<para>The <literal>--region</literal> command option sets where the region where an AMI is stored.</para>
</callout>
<callout arearefs="CO97-5">
<para>The <literal>--output</literal> command option sets how the results are displayed.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<note>
<simpara>When creating a RHEL compute machine for AWS, ensure that the AMI is RHEL 8.4 or 8.5.</simpara>
</note>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">------------------------------------------------------------------------------------------------------------
|                                              DescribeImages                                              |
+---------------------------+-----------------------------------------------------+------------------------+
|  2021-03-18T14:23:11.000Z |  RHEL-8.4.0_HVM_BETA-20210309-x86_64-1-Hourly2-GP2  |  ami-07eeb4db5f7e5a8fb |
|  2021-03-18T14:38:28.000Z |  RHEL-8.4.0_HVM_BETA-20210309-arm64-1-Hourly2-GP2   |  ami-069d22ec49577d4bf |
|  2021-05-18T19:06:34.000Z |  RHEL-8.4.0_HVM-20210504-arm64-2-Hourly2-GP2        |  ami-01fc429821bf1f4b4 |
|  2021-05-18T20:09:47.000Z |  RHEL-8.4.0_HVM-20210504-x86_64-2-Hourly2-GP2       |  ami-0b0af3577fe5e3532 |
+---------------------------+-----------------------------------------------------+------------------------+</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>You may also manually <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/image_builder_guide/sect-documentation-image_builder-chapter5-section_2">import RHEL images to AWS</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="rhel-preparing-node_more-rhel-compute">
<title>Preparing a RHEL compute node</title>
<simpara>Before you add a Red Hat Enterprise Linux (RHEL) machine to your OpenShift Container Platform cluster, you must register each host with Red Hat Subscription Manager (RHSM), attach an active OpenShift Container Platform subscription, and enable the required repositories. Ensure <literal>NetworkManager</literal> is enabled and configured to control all interfaces on the host.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On each host, register with RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager register --username=&lt;user_name&gt; --password=&lt;password&gt;</programlisting>
</listitem>
<listitem>
<simpara>Pull the latest subscription data from RHSM:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager refresh</programlisting>
</listitem>
<listitem>
<simpara>List the available subscriptions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager list --available --matches '*OpenShift*'</programlisting>
</listitem>
<listitem>
<simpara>In the output for the previous command, find the pool ID for an OpenShift Container Platform subscription and attach it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager attach --pool=&lt;pool_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>Disable all yum repositories:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Disable all the enabled RHSM repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos --disable="*"</programlisting>
</listitem>
<listitem>
<simpara>List the remaining yum repositories and note their names under <literal>repo id</literal>, if any:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum repolist</programlisting>
</listitem>
<listitem>
<simpara>Use <literal>yum-config-manager</literal> to disable the remaining yum repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum-config-manager --disable &lt;repo_id&gt;</programlisting>
<simpara>Alternatively, disable all repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum-config-manager --disable \*</programlisting>
<simpara>Note that this might take a few minutes if you have a large number of available repositories</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enable only the repositories required by OpenShift Container Platform 4.14:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos \
    --enable="rhel-8-for-x86_64-baseos-rpms" \
    --enable="rhel-8-for-x86_64-appstream-rpms" \
    --enable="rhocp-4.14-for-rhel-8-x86_64-rpms" \
    --enable="fast-datapath-for-rhel-8-x86_64-rpms"</programlisting>
</listitem>
<listitem>
<simpara>Stop and disable firewalld on the host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># systemctl disable --now firewalld.service</programlisting>
<note>
<simpara>You must not enable firewalld later. If you do, you cannot access OpenShift Container Platform logs on the worker.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="rhel-attaching-instance-aws_more-rhel-compute">
<title>Attaching the role permissions to RHEL instance in AWS</title>
<simpara>Using the Amazon IAM console in your browser, you may select the needed roles and assign them to a worker node.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the AWS IAM console, create your <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#create-iam-role">desired IAM role</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html#attach-iam-role">Attach the IAM role</link> to the desired worker node.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-aws-permissions-iam-roles_installing-aws-account">Required AWS permissions for IAM roles</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="rhel-worker-tag_more-rhel-compute">
<title>Tagging a RHEL worker node as owned or shared</title>
<simpara>A cluster uses the value of the <literal>kubernetes.io/cluster/&lt;clusterid&gt;,Value=(owned|shared)</literal> tag to determine the lifetime of the resources related to the AWS cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>owned</literal> tag value should be added if the resource should be destroyed as part of destroying the cluster.</simpara>
</listitem>
<listitem>
<simpara>The <literal>shared</literal> tag value should be added if the resource continues to exist after the cluster has been destroyed. This tagging denotes that the cluster uses this resource, but there is a separate owner for the resource.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>With RHEL compute machines, the RHEL worker instance must be tagged with <literal>kubernetes.io/cluster/&lt;clusterid&gt;=owned</literal> or <literal>kubernetes.io/cluster/&lt;cluster-id&gt;=shared</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Do not tag all existing security groups with the <literal>kubernetes.io/cluster/&lt;name&gt;,Value=&lt;clusterid&gt;</literal> tag, or the Elastic Load Balancing (ELB) will not be able to create a load balancer.</simpara>
</note>
</section>
<section xml:id="rhel-adding-more-nodes_more-rhel-compute">
<title>Adding more RHEL compute machines to your cluster</title>
<simpara>You can add more compute machines that use Red Hat Enterprise Linux (RHEL) as the operating system to an OpenShift Container Platform 4.14 cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your OpenShift Container Platform cluster already contains RHEL compute nodes.</simpara>
</listitem>
<listitem>
<simpara>The <literal>hosts</literal> file that you used to add the first RHEL compute machines to your cluster is on the machine that you use the run the playbook.</simpara>
</listitem>
<listitem>
<simpara>The machine that you run the playbook on must be able to access all of the RHEL hosts. You can use any method that your company allows, including a bastion with an SSH proxy or a VPN.</simpara>
</listitem>
<listitem>
<simpara>The <literal>kubeconfig</literal> file for the cluster and the installation program that you used to install the cluster are on the machine that you use the run the playbook.</simpara>
</listitem>
<listitem>
<simpara>You must prepare the RHEL hosts for installation.</simpara>
</listitem>
<listitem>
<simpara>Configure a user on the machine that you run the playbook on that has SSH access to all of the RHEL hosts.</simpara>
</listitem>
<listitem>
<simpara>If you use SSH key-based authentication, you must manage the key with an SSH agent.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>) on the machine that you run the playbook on.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the Ansible inventory file at <literal>/&lt;path&gt;/inventory/hosts</literal> that defines your compute machine hosts and required variables.</simpara>
</listitem>
<listitem>
<simpara>Rename the <literal>[new_workers]</literal> section of the file to <literal>[workers]</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add a <literal>[new_workers]</literal> section to the file and define the fully-qualified domain names for each new host. The file resembles the following example:</simpara>
<screen>[all:vars]
ansible_user=root
#ansible_become=True

openshift_kubeconfig_path="~/.kube/config"

[workers]
mycluster-rhel8-0.example.com
mycluster-rhel8-1.example.com

[new_workers]
mycluster-rhel8-2.example.com
mycluster-rhel8-3.example.com</screen>
<simpara>In this example, the <literal>mycluster-rhel8-0.example.com</literal> and <literal>mycluster-rhel8-1.example.com</literal> machines are in the cluster and you add the <literal>mycluster-rhel8-2.example.com</literal> and <literal>mycluster-rhel8-3.example.com</literal> machines.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the Ansible playbook directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd /usr/share/ansible/openshift-ansible</programlisting>
</listitem>
<listitem>
<simpara>Run the scaleup playbook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-playbook -i /&lt;path&gt;/inventory/hosts playbooks/scaleup.yml <co xml:id="CO98-1"/></programlisting>
<calloutlist>
<callout arearefs="CO98-1">
<para>For <literal>&lt;path&gt;</literal>, specify the path to the Ansible inventory file that you created.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-approve-csrs_more-rhel-compute">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO99-1"/></programlisting>
<calloutlist>
<callout arearefs="CO99-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO100-1"/></programlisting>
<calloutlist>
<callout arearefs="CO100-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="rhel-ansible-parameters_more-rhel-compute">
<title>Required parameters for the Ansible hosts file</title>
<simpara>You must define the following parameters in the Ansible hosts file before you add Red Hat Enterprise Linux (RHEL) compute machines to your cluster.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ansible_user</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The SSH user that allows SSH-based authentication without requiring a password. If you use SSH key-based authentication, then you must manage the key with an SSH agent.</simpara></entry>
<entry align="left" valign="top"><simpara>A user name on the system. The default value is <literal>root</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ansible_become</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the values of <literal>ansible_user</literal> is not root, you must set <literal>ansible_become</literal> to <literal>True</literal>, and the user that you specify as the <literal>ansible_user</literal>  must be configured for passwordless sudo access.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal>. If the value is not <literal>True</literal>, do not specify and define this parameter.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_kubeconfig_path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a path and file name to a local directory that contains the <literal>kubeconfig</literal> file for your cluster.</simpara></entry>
<entry align="left" valign="top"><simpara>The path and name of the configuration file.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</chapter>
<chapter xml:id="_managing-user-provisioned-infrastructure-manually">
<title>Managing user-provisioned infrastructure manually</title>
<section xml:id="adding-compute-user-infra-general">
<title>Adding compute machines to clusters with user-provisioned infrastructure manually</title>

<simpara>You can add compute machines to a cluster on user-provisioned infrastructure either as part of the installation process or after installation. The postinstallation process requires some of the same configuration files and parameters that were used during installation.</simpara>
<section xml:id="upi-adding-compute-aws">
<title>Adding compute machines to Amazon Web Services</title>
<simpara>To add more compute machines to your OpenShift Container Platform cluster on Amazon Web Services (AWS), see <link linkend="adding-aws-compute-user-infra">Adding compute machines to AWS by using CloudFormation templates</link>.</simpara>
</section>
<section xml:id="upi-adding-compute-azure">
<title>Adding compute machines to Microsoft Azure</title>
<simpara>To add more compute machines to your OpenShift Container Platform cluster on Microsoft Azure, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-creating-azure-worker_installing-azure-user-infra">Creating additional worker machines in Azure</link>.</simpara>
</section>
<section xml:id="upi-adding-compute-ash">
<title>Adding compute machines to Azure Stack Hub</title>
<simpara>To add more compute machines to your OpenShift Container Platform cluster on Azure Stack Hub, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-creating-azure-worker_installing-azure-stack-hub-user-infra">Creating additional worker machines in Azure Stack Hub</link>.</simpara>
</section>
<section xml:id="upi-adding-compute-gcp">
<title>Adding compute machines to Google Cloud Platform</title>
<simpara>To add more compute machines to your OpenShift Container Platform cluster on Google Cloud Platform (GCP), see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-creating-gcp-worker_installing-restricted-networks-gcp">Creating additional worker machines in GCP</link>.</simpara>
</section>
<section xml:id="upi-adding-compute-vsphere">
<title>Adding compute machines to vSphere</title>
<simpara>You can <link linkend="creating-machineset-vsphere">use compute machine sets</link> to automate the creation of additional compute machines for your OpenShift Container Platform cluster on vSphere.</simpara>
<simpara>To manually add more compute machines to your cluster, see <link linkend="adding-vsphere-compute-user-infra">Adding compute machines to vSphere manually</link>.</simpara>
</section>
<section xml:id="upi-adding-compute-bare-metal">
<title>Adding compute machines to bare metal</title>
<simpara>To add more compute machines to your OpenShift Container Platform cluster on bare metal, see <link linkend="adding-bare-metal-compute-user-infra">Adding compute machines to bare metal</link>.</simpara>
</section>
</section>
<section xml:id="adding-aws-compute-user-infra">
<title>Adding compute machines to AWS by using CloudFormation templates</title>

<simpara>You can add more compute machines to your OpenShift Container Platform cluster on Amazon Web Services (AWS) that you created by using the sample CloudFormation templates.</simpara>
<section xml:id="prerequisites_adding-aws-compute-user-infra">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You installed your cluster on AWS by using the provided <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-aws-user-infra">AWS CloudFormation templates</link>.</simpara>
</listitem>
<listitem>
<simpara>You have the JSON file and CloudFormation template that you used to create the compute machines during cluster installation. If you do not have these files, you must recreate them by following the instructions in the <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-aws-user-infra">installation procedure</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-adding-aws-compute-cloudformation_adding-aws-compute-user-infra">
<title>Adding more compute machines to your AWS cluster by using CloudFormation templates</title>
<simpara>You can add more compute machines to your OpenShift Container Platform cluster on Amazon Web Services (AWS) that you created by using the sample CloudFormation templates.</simpara>
<important>
<simpara>The CloudFormation template creates a stack that represents one compute machine. You must create a stack for each compute machine.</simpara>
</important>
<note>
<simpara>If you do not use the provided CloudFormation template to create your compute nodes, you must review the provided information and manually create the infrastructure. If your cluster does not initialize correctly, you might have to contact Red Hat support with your installation logs.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You installed an OpenShift Container Platform cluster by using CloudFormation templates and have access to the JSON file and CloudFormation template that you used to create the compute machines during cluster installation.</simpara>
</listitem>
<listitem>
<simpara>You installed the AWS CLI.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create another compute stack.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Launch the template:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ aws cloudformation create-stack --stack-name &lt;name&gt; \ <co xml:id="CO101-1"/>
     --template-body file://&lt;template&gt;.yaml \ <co xml:id="CO101-2"/>
     --parameters file://&lt;parameters&gt;.json <co xml:id="CO101-3"/></programlisting>
<calloutlist>
<callout arearefs="CO101-1">
<para><literal>&lt;name&gt;</literal> is the name for the CloudFormation stack, such as <literal>cluster-workers</literal>. You must provide the name of this stack if you remove the cluster.</para>
</callout>
<callout arearefs="CO101-2">
<para><literal>&lt;template&gt;</literal> is the relative path to and name of the CloudFormation template YAML file that you saved.</para>
</callout>
<callout arearefs="CO101-3">
<para><literal>&lt;parameters&gt;</literal> is the relative path to and name of the CloudFormation parameters JSON file.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Confirm that the template components exist:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ aws cloudformation describe-stacks --stack-name &lt;name&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Continue to create compute stacks until you have created enough compute machines for your cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-approve-csrs_adding-aws-compute-user-infra">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO102-1"/></programlisting>
<calloutlist>
<callout arearefs="CO102-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO103-1"/></programlisting>
<calloutlist>
<callout arearefs="CO103-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="adding-vsphere-compute-user-infra">
<title>Adding compute machines to vSphere manually</title>

<simpara>You can add more compute machines to your OpenShift Container Platform cluster on VMware vSphere manually.</simpara>
<note>
<simpara>You can also <link linkend="creating-machineset-vsphere">use compute machine sets</link> to automate the creation of additional VMware vSphere compute machines for your cluster.</simpara>
</note>
<section xml:id="_prerequisites-2">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-vsphere">installed a cluster on vSphere</link>.</simpara>
</listitem>
<listitem>
<simpara>You have installation media and Red Hat Enterprise Linux CoreOS (RHCOS) images that you used to create your cluster. If you do not have these files, you must obtain them by following the instructions in the <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-vsphere">installation procedure</link>.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>If you do not have access to the Red Hat Enterprise Linux CoreOS (RHCOS) images that were used to create your cluster, you can add more compute machines to your OpenShift Container Platform cluster with newer versions of Red Hat Enterprise Linux CoreOS (RHCOS) images. For instructions, see <link xlink:href="https://access.redhat.com/solutions/5514051">Adding new nodes to UPI cluster fails after upgrading to OpenShift 4.6+</link>.</simpara>
</important>
</section>
<section xml:id="machine-vsphere-machines_adding-vsphere-compute-user-infra">
<title>Adding more compute machines to a cluster in vSphere</title>
<simpara>You can add more compute machines to a user-provisioned OpenShift Container Platform cluster on VMware vSphere.</simpara>
<simpara>After your vSphere template deploys in your OpenShift Container Platform cluster, you can deploy a virtual machine (VM) for a machine in that cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the base64-encoded Ignition file for your compute machines.</simpara>
</listitem>
<listitem>
<simpara>You have access to the vSphere template that you created for your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Right-click the template&#8217;s name and click <emphasis role="strong">Clone</emphasis> &#8594; <emphasis role="strong">Clone to Virtual Machine</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Select a name and folder</emphasis> tab, specify a name for the VM. You might include the machine type in the name, such as <literal>compute-1</literal>.</simpara>
<note>
<simpara>Ensure that all virtual machine names across a vSphere installation are unique.</simpara>
</note>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Select a name and folder</emphasis> tab, select the name of the folder that you created for the cluster.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Select a compute resource</emphasis> tab, select the name of a host in your datacenter.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Select storage</emphasis> tab, select storage for your configuration and disk files.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Select clone options</emphasis> tab, select <emphasis role="strong">Customize this virtual machine&#8217;s hardware</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Customize hardware</emphasis> tab, click <emphasis role="strong">Advanced Parameters</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>Add the following configuration parameter names and values by specifying data in the <emphasis role="strong">Attribute</emphasis> and <emphasis role="strong">Values</emphasis> fields. Ensure that you select the <emphasis role="strong">Add</emphasis> button for each parameter that you create.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>guestinfo.ignition.config.data</literal>: Paste the contents of the base64-encoded compute Ignition config file for this machine type.</simpara>
</listitem>
<listitem>
<simpara><literal>guestinfo.ignition.config.data.encoding</literal>: Specify <literal>base64</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>disk.EnableUUID</literal>: Specify <literal>TRUE</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Virtual Hardware</emphasis> panel of the <emphasis role="strong">Customize hardware</emphasis> tab, modify the specified values as required. Ensure that the amount of RAM, CPU, and disk storage meets the minimum requirements for the machine type. If many networks exist, select <emphasis role="strong">Add New Device</emphasis> &gt; <emphasis role="strong">Network Adapter</emphasis>, and then enter your network information in the fields provided by the <emphasis role="strong">New Network</emphasis> menu item.</simpara>
</listitem>
<listitem>
<simpara>Complete the remaining configuration steps. On clicking the <emphasis role="strong">Finish</emphasis> button, you have completed the cloning operation.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Virtual Machines</emphasis> tab, right-click on your VM and then select <emphasis role="strong">Power</emphasis> &#8594; <emphasis role="strong">Power On</emphasis>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Continue to create more compute machines for your cluster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-approve-csrs_adding-vsphere-compute-user-infra">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO104-1"/></programlisting>
<calloutlist>
<callout arearefs="CO104-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO105-1"/></programlisting>
<calloutlist>
<callout arearefs="CO105-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="adding-bare-metal-compute-user-infra">
<title>Adding compute machines to bare metal</title>

<simpara>You can add more compute machines to your OpenShift Container Platform cluster on bare metal.</simpara>
<section xml:id="_prerequisites-3">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-bare-metal">installed a cluster on bare metal</link>.</simpara>
</listitem>
<listitem>
<simpara>You have installation media and Red Hat Enterprise Linux CoreOS (RHCOS) images that you used to create your cluster. If you do not have these files, you must obtain them by following the instructions in the <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-bare-metal">installation procedure</link>.</simpara>
</listitem>
<listitem>
<simpara>If a DHCP server is available for your user-provisioned infrastructure, you have added the details for the additional compute machines to your DHCP server configuration. This includes a persistent IP address, DNS server information, and a hostname for each machine.</simpara>
</listitem>
<listitem>
<simpara>You have updated your DNS configuration to include the record name and IP address of each compute machine that you are adding. You have validated that DNS lookup and reverse DNS lookup resolve correctly.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>If you do not have access to the Red Hat Enterprise Linux CoreOS (RHCOS) images that were used to create your cluster, you can add more compute machines to your OpenShift Container Platform cluster with newer versions of Red Hat Enterprise Linux CoreOS (RHCOS) images. For instructions, see <link xlink:href="https://access.redhat.com/solutions/5514051">Adding new nodes to UPI cluster fails after upgrading to OpenShift 4.6+</link>.</simpara>
</important>
</section>
<section xml:id="creating-rhcos-machines-bare-metal">
<title>Creating Red Hat Enterprise Linux CoreOS (RHCOS) machines</title>
<simpara>Before you add more compute machines to a cluster that you installed on bare metal infrastructure, you must create RHCOS machines for it to use. You can either use an ISO image or network PXE booting to create the machines.</simpara>
<note>
<simpara>You must use the same ISO image that you used to install a cluster to deploy all new nodes in a cluster. It is recommended to use the same Ignition config file. The nodes automatically upgrade themselves on the first boot before running the workloads. You can add the nodes before or after the upgrade.</simpara>
</note>
<section xml:id="machine-user-infra-machines-iso_adding-bare-metal-compute-user-infra">
<title>Creating RHCOS machines using an ISO image</title>
<simpara>You can create more Red Hat Enterprise Linux CoreOS (RHCOS) compute machines for your bare metal cluster by using an ISO image to create the machines.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the URL of the Ignition config file for the compute machines for your cluster. You uploaded this file to your HTTP server during installation.</simpara>
</listitem>
<listitem>
<simpara>You must have the OpenShift CLI (<literal>oc</literal>)  installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Extract the Ignition config file from the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc extract -n openshift-machine-api secret/worker-user-data-managed --keys=userData --to=- &gt; worker.ign</programlisting>
</listitem>
<listitem>
<simpara>Upload the <literal>worker.ign</literal> Ignition config file you exported from your cluster to your HTTP server. Note the URLs of these files.</simpara>
</listitem>
<listitem>
<simpara>You can validate that the ignition files are available on the URLs. The following example gets the Ignition config files for the compute node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -k http://&lt;HTTP_server&gt;/worker.ign</programlisting>
</listitem>
<listitem>
<simpara>You can access the ISO image for booting your new machine by running to following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">RHCOS_VHD_ORIGIN_URL=$(oc -n openshift-machine-config-operator get configmap/coreos-bootimages -o jsonpath='{.data.stream}' | jq -r '.architectures.&lt;architecture&gt;.artifacts.metal.formats.iso.disk.location')</programlisting>
</listitem>
<listitem>
<simpara>Use the ISO file to install RHCOS on more compute machines. Use the same method that you used when you created machines before you installed the cluster:</simpara>
<itemizedlist>
<listitem>
<simpara>Burn the ISO image to a disk and boot it directly.</simpara>
</listitem>
<listitem>
<simpara>Use ISO redirection with a LOM interface.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Boot the RHCOS ISO image without specifying any options, or interrupting the live boot sequence. Wait for the installer to boot into a shell prompt in the RHCOS live environment.</simpara>
<note>
<simpara>You can interrupt the RHCOS installation boot process to add kernel arguments. However, for this ISO procedure you must use the <literal>coreos-installer</literal> command as outlined in the following steps, instead of adding kernel arguments.</simpara>
</note>
</listitem>
<listitem>
<simpara>Run the <literal>coreos-installer</literal> command and specify the options that meet your installation requirements. At a minimum, you must specify the URL that points to the Ignition config file for the node type, and the device that you are installing to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo coreos-installer install --ignition-url=http://&lt;HTTP_server&gt;/&lt;node_type&gt;.ign &lt;device&gt; --ignition-hash=sha512-&lt;digest&gt; <co xml:id="CO106-1"/><co xml:id="CO106-2"/></programlisting>
<calloutlist>
<callout arearefs="CO106-1">
<para>You must run the <literal>coreos-installer</literal> command by using <literal>sudo</literal>, because the <literal>core</literal> user does not have the required root privileges to perform the installation.</para>
</callout>
<callout arearefs="CO106-2">
<para>The <literal>--ignition-hash</literal> option is required when the Ignition config file is obtained through an HTTP URL to validate the authenticity of the Ignition config file on the cluster node. <literal>&lt;digest&gt;</literal> is the Ignition config file SHA512 digest obtained in a preceding step.</para>
</callout>
</calloutlist>
<note>
<simpara>If you want to provide your Ignition config files through an HTTPS server that uses TLS, you can add the internal certificate authority (CA) to the system trust store before running <literal>coreos-installer</literal>.</simpara>
</note>
<simpara>The following example initializes a bootstrap node installation to the <literal>/dev/sda</literal> device. The Ignition config file for the bootstrap node is obtained from an HTTP web server with the IP address 192.168.1.2:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo coreos-installer install --ignition-url=http://192.168.1.2:80/installation_directory/bootstrap.ign /dev/sda --ignition-hash=sha512-a5a2d43879223273c9b60af66b44202a1d1248fc01cf156c46d4a79f552b6bad47bc8cc78ddf0116e80c59d2ea9e32ba53bc807afbca581aa059311def2c3e3b</programlisting>
</listitem>
<listitem>
<simpara>Monitor the progress of the RHCOS installation on the console of the machine.</simpara>
<important>
<simpara>Ensure that the installation is successful on each node before commencing with the OpenShift Container Platform installation. Observing the installation process can also help to determine the cause of RHCOS installation issues that might arise.</simpara>
</important>
</listitem>
<listitem>
<simpara>Continue to create more compute machines for your cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machine-user-infra-machines-pxe_adding-bare-metal-compute-user-infra">
<title>Creating RHCOS machines by PXE or iPXE booting</title>
<simpara>You can create more Red Hat Enterprise Linux CoreOS (RHCOS) compute machines for your bare metal cluster by using PXE or iPXE booting.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the URL of the Ignition config file for the compute machines for your cluster. You uploaded this file to your HTTP server during installation.</simpara>
</listitem>
<listitem>
<simpara>Obtain the URLs of the RHCOS ISO image, compressed metal BIOS, <literal>kernel</literal>, and <literal>initramfs</literal> files that you uploaded to your HTTP server during cluster installation.</simpara>
</listitem>
<listitem>
<simpara>You have access to the PXE booting infrastructure that you used to create the machines for your OpenShift Container Platform cluster during installation. The machines must boot from their local disks after RHCOS is installed on them.</simpara>
</listitem>
<listitem>
<simpara>If you use UEFI, you have access to the <literal>grub.conf</literal> file that you modified during OpenShift Container Platform installation.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that your PXE or iPXE installation for the RHCOS images is correct.</simpara>
<itemizedlist>
<listitem>
<simpara>For PXE:</simpara>
<screen>DEFAULT pxeboot
TIMEOUT 20
PROMPT 0
LABEL pxeboot
    KERNEL http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-kernel-&lt;architecture&gt; <co xml:id="CO107-1"/>
    APPEND initrd=http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-initramfs.&lt;architecture&gt;.img coreos.inst.install_dev=/dev/sda coreos.inst.ignition_url=http://&lt;HTTP_server&gt;/worker.ign coreos.live.rootfs_url=http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-rootfs.&lt;architecture&gt;.img <co xml:id="CO107-2"/></screen>
<calloutlist>
<callout arearefs="CO107-1">
<para>Specify the location of the live <literal>kernel</literal> file that you uploaded to your HTTP server.</para>
</callout>
<callout arearefs="CO107-2">
<para>Specify locations of the RHCOS files that you uploaded to your HTTP server. The <literal>initrd</literal> parameter value is the location of the live <literal>initramfs</literal> file, the <literal>coreos.inst.ignition_url</literal> parameter value is the location of the worker Ignition config file, and the <literal>coreos.live.rootfs_url</literal> parameter value is the location of the live <literal>rootfs</literal> file. The <literal>coreos.inst.ignition_url</literal> and <literal>coreos.live.rootfs_url</literal> parameters only support HTTP and HTTPS.</para>
</callout>
</calloutlist>
<note>
<simpara>This configuration does not enable serial console access on machines with a graphical console. To configure a different console, add one or more <literal>console=</literal> arguments to the <literal>APPEND</literal> line. For example, add <literal>console=tty0 console=ttyS0</literal> to set the first PC serial port as the primary console and the graphical console as a secondary console. For more information, see <link xlink:href="https://access.redhat.com/articles/7212">How does one set up a serial terminal and/or console in Red Hat Enterprise Linux?</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>For iPXE (<literal>x86_64</literal> + <literal>aarch64</literal>):</simpara>
<screen>kernel http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-kernel-&lt;architecture&gt; initrd=main coreos.live.rootfs_url=http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-rootfs.&lt;architecture&gt;.img coreos.inst.install_dev=/dev/sda coreos.inst.ignition_url=http://&lt;HTTP_server&gt;/worker.ign <co xml:id="CO108-1"/> <co xml:id="CO108-2"/>
initrd --name main http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-initramfs.&lt;architecture&gt;.img <co xml:id="CO108-3"/>
boot</screen>
<calloutlist>
<callout arearefs="CO108-1">
<para>Specify the locations of the RHCOS files that you uploaded to your
HTTP server. The <literal>kernel</literal> parameter value is the location of the <literal>kernel</literal> file,
the <literal>initrd=main</literal> argument is needed for booting on UEFI systems,
the <literal>coreos.live.rootfs_url</literal> parameter value is the location of the <literal>rootfs</literal> file,
and the <literal>coreos.inst.ignition_url</literal> parameter value is the
location of the worker Ignition config file.</para>
</callout>
<callout arearefs="CO108-2">
<para>If you use multiple NICs, specify a single interface in the <literal>ip</literal> option.
For example, to use DHCP on a NIC that is named <literal>eno1</literal>, set <literal>ip=eno1:dhcp</literal>.</para>
</callout>
<callout arearefs="CO108-3">
<para>Specify the location of the <literal>initramfs</literal> file that you uploaded to your HTTP server.</para>
</callout>
</calloutlist>
<note>
<simpara>This configuration does not enable serial console access on machines with a graphical console To configure a different console, add one or more <literal>console=</literal> arguments to the <literal>kernel</literal> line. For example, add <literal>console=tty0 console=ttyS0</literal> to set the first PC serial port as the primary console and the graphical console as a secondary console. For more information, see <link xlink:href="https://access.redhat.com/articles/7212">How does one set up a serial terminal and/or console in Red Hat Enterprise Linux?</link> and "Enabling the serial console for PXE and ISO installation" in the "Advanced RHCOS installation configuration" section.</simpara>
</note>
<note>
<simpara>To network boot the CoreOS <literal>kernel</literal> on <literal>aarch64</literal> architecture, you need to use a version of iPXE build with the <literal>IMAGE_GZIP</literal> option enabled. See <link xlink:href="https://ipxe.org/buildcfg/image_gzip"><literal>IMAGE_GZIP</literal> option in iPXE</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>For PXE (with UEFI and GRUB as second stage) on <literal>aarch64</literal>:</simpara>
<screen>menuentry 'Install CoreOS' {
    linux rhcos-&lt;version&gt;-live-kernel-&lt;architecture&gt;  coreos.live.rootfs_url=http://&lt;HTTP_server&gt;/rhcos-&lt;version&gt;-live-rootfs.&lt;architecture&gt;.img coreos.inst.install_dev=/dev/sda coreos.inst.ignition_url=http://&lt;HTTP_server&gt;/worker.ign <co xml:id="CO109-1"/> <co xml:id="CO109-2"/>
    initrd rhcos-&lt;version&gt;-live-initramfs.&lt;architecture&gt;.img <co xml:id="CO109-3"/>
}</screen>
<calloutlist>
<callout arearefs="CO109-1">
<para>Specify the locations of the RHCOS files that you uploaded to your
HTTP/TFTP server. The <literal>kernel</literal> parameter value is the location of the <literal>kernel</literal> file on your TFTP server.
The <literal>coreos.live.rootfs_url</literal> parameter value is the location of the <literal>rootfs</literal> file, and the <literal>coreos.inst.ignition_url</literal> parameter value is the location of the worker Ignition config file on your HTTP Server.</para>
</callout>
<callout arearefs="CO109-2">
<para>If you use multiple NICs, specify a single interface in the <literal>ip</literal> option.
For example, to use DHCP on a NIC that is named <literal>eno1</literal>, set <literal>ip=eno1:dhcp</literal>.</para>
</callout>
<callout arearefs="CO109-3">
<para>Specify the location of the <literal>initramfs</literal> file that you uploaded to your TFTP server.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Use the PXE or iPXE infrastructure to create the required compute machines for your cluster.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="installation-approve-csrs_adding-bare-metal-compute-user-infra">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO110-1"/></programlisting>
<calloutlist>
<callout arearefs="CO110-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO111-1"/></programlisting>
<calloutlist>
<callout arearefs="CO111-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="capi-machine-management">
<title>Managing machines with the Cluster API</title>

<important>
<simpara>Managing machines with the Cluster API is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>The <link xlink:href="https://cluster-api.sigs.k8s.io/">Cluster API</link> is an upstream project that is integrated into OpenShift Container Platform as a Technology Preview for Amazon Web Services (AWS) and Google Cloud Platform (GCP). You can use the Cluster API to create and manage compute machine sets and compute machines in your OpenShift Container Platform cluster. This capability is in addition or an alternative to managing machines with the Machine API.</simpara>
<simpara>For OpenShift Container Platform 4.14 clusters, you can use the Cluster API to perform node host provisioning management actions after the cluster installation finishes. This system enables an elastic, dynamic provisioning method on top of public or private cloud infrastructure.</simpara>
<simpara>With the Cluster API Technology Preview, you can create compute machines and compute machine sets on OpenShift Container Platform clusters for supported providers. You can also explore the features that are enabled by this implementation that might not be available with the Machine API.</simpara>
<bridgehead xml:id="cluster-api-benefits_capi-machine-management" renderas="sect2">Benefits</bridgehead>
<simpara>By using the Cluster API, OpenShift Container Platform users and developers are able to realize the following advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>The option to use upstream community Cluster API infrastructure providers which might not be supported by the Machine API.</simpara>
</listitem>
<listitem>
<simpara>The opportunity to collaborate with third parties who maintain machine controllers for infrastructure providers.</simpara>
</listitem>
<listitem>
<simpara>The ability to use the same set of Kubernetes tools for infrastructure management in OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>The ability to create compute machine sets by using the Cluster API that support features that are not available with the Machine API.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="capi-tech-preview-limitations" renderas="sect2">Limitations</bridgehead>
<simpara>Using the Cluster API to manage machines is a Technology Preview feature and has the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>Only AWS and GCP clusters are supported.</simpara>
</listitem>
<listitem>
<simpara>To use this feature, you must enable the <literal>TechPreviewNoUpgrade</literal> <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-cluster-enabling-features-about_nodes-cluster-enabling">feature set</link>. Enabling this feature set cannot be undone and prevents minor version updates.</simpara>
</listitem>
<listitem>
<simpara>You must create the primary resources that the Cluster API requires manually.</simpara>
</listitem>
<listitem>
<simpara>You cannot manage control plane machines by using the Cluster API.</simpara>
</listitem>
<listitem>
<simpara>Migration of existing compute machine sets created by the Machine API to Cluster API compute machine sets is not supported.</simpara>
</listitem>
<listitem>
<simpara>Full feature parity with the Machine API is not available.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cluster-api-architecture_capi-machine-management">
<title>Cluster API architecture</title>
<simpara>The OpenShift Container Platform integration of the upstream Cluster API is implemented and managed by the Cluster CAPI Operator. The Cluster CAPI Operator and its operands are provisioned in the <literal>openshift-cluster-api</literal> namespace, in contrast to the Machine API, which uses the <literal>openshift-machine-api</literal> namespace.</simpara>
<section xml:id="capi-arch-operator">
<title>The Cluster CAPI Operator</title>
<simpara>The Cluster CAPI Operator is an OpenShift Container Platform Operator that maintains the lifecycle of Cluster API resources. This Operator is responsible for all administrative tasks related to deploying the Cluster API project within an OpenShift Container Platform cluster.</simpara>
<simpara>If a cluster is configured correctly to allow the use of the Cluster API, the Cluster CAPI Operator installs the Cluster API components on the cluster.</simpara>
<simpara>For more information, see the entry for the Cluster CAPI Operator in the <emphasis>Cluster Operators reference</emphasis> content.</simpara>
</section>
<section xml:id="capi-arch-resources">
<title>Primary resources</title>
<simpara>The Cluster API consists of the following primary resources. For the Technology Preview of this feature, you must create these resources manually in the <literal>openshift-cluster-api</literal> namespace.</simpara>
<variablelist>
<varlistentry>
<term>Cluster</term>
<listitem>
<simpara>A fundamental unit that represents a cluster that is managed by the Cluster API.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Infrastructure</term>
<listitem>
<simpara>A provider-specific resource that defines properties that are shared by all the compute machine sets in the cluster, such as the region and subnets.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine template</term>
<listitem>
<simpara>A provider-specific template that defines the properties of the machines that a compute machine set creates.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine set</term>
<listitem>
<simpara>A group of machines.</simpara>
<simpara>Compute machine sets are to machines as replica sets are to pods. If you need more machines or must scale them down, you change the <literal>replicas</literal> field on the compute machine set to meet your compute needs.</simpara>
<simpara>With the Cluster API, a compute machine set references a <literal>Cluster</literal> object and a provider-specific machine template.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine</term>
<listitem>
<simpara>A fundamental unit that describes the host for a node.</simpara>
<simpara>The Cluster API creates machines based on the configuration in the machine template.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/operators/#cluster-capi-operator_cluster-operators-ref">Cluster CAPI Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="capi-sample-yaml-files">
<title>Sample YAML files</title>
<simpara>For the Cluster API Technology Preview, you must create the primary resources that the Cluster API requires manually. The following example YAML files show how to make these resources work together and configure settings for the machines that they create that are appropriate for your environment.</simpara>
<section xml:id="capi-yaml-cluster_capi-machine-management">
<title>Sample YAML for a Cluster API cluster resource</title>
<simpara>The cluster resource defines the name and infrastructure provider for the cluster and is managed by the Cluster API. This resource has the same structure for all providers.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cluster.x-k8s.io/v1beta1
kind: Cluster
metadata:
  name: &lt;cluster_name&gt; <co xml:id="CO112-1"/>
  namespace: openshift-cluster-api
spec:
  infrastructureRef:
    apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
    kind: &lt;infrastructure_kind&gt; <co xml:id="CO112-2"/>
    name: &lt;cluster_name&gt; <co xml:id="CO112-3"/>
    namespace: openshift-cluster-api</programlisting>
<calloutlist>
<callout arearefs="CO112-1 CO112-3">
<para>Specify the name of the cluster.</para>
</callout>
<callout arearefs="CO112-2">
<para>Specify the infrastructure kind for the cluster. Valid values are:</para>
<itemizedlist>
<listitem>
<simpara><literal>AWSCluster</literal>: The cluster is running on Amazon Web Services (AWS).</simpara>
</listitem>
<listitem>
<simpara><literal>GCPCluster</literal>: The cluster is running on Google Cloud Platform (GCP).</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<simpara>The remaining Cluster API resources are provider-specific. Refer to the example YAML files for your cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="capi-sample-yaml-files-aws">Sample YAML files for configuring Amazon Web Services clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="capi-sample-yaml-files-gcp">Sample YAML files for configuring Google Cloud Platform clusters</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="capi-sample-yaml-files-aws">
<title>Sample YAML files for configuring Amazon Web Services clusters</title>
<simpara>Some Cluster API resources are provider-specific. The following example YAML files show configurations for an Amazon Web Services (AWS) cluster.</simpara>
<section xml:id="capi-yaml-infrastructure-aws_capi-machine-management">
<title>Sample YAML for a Cluster API infrastructure resource on Amazon Web Services</title>
<simpara>The infrastructure resource is provider-specific and defines properties that are shared by all the compute machine sets in the cluster, such as the region and subnets. The compute machine set references this resource when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
kind: AWSCluster <co xml:id="CO113-1"/>
metadata:
  name: &lt;cluster_name&gt; <co xml:id="CO113-2"/>
  namespace: openshift-cluster-api
spec:
  region: &lt;region&gt; <co xml:id="CO113-3"/></programlisting>
<calloutlist>
<callout arearefs="CO113-1">
<para>Specify the infrastructure kind for the cluster. This value must match the value for your platform.</para>
</callout>
<callout arearefs="CO113-2">
<para>Specify the name of the cluster.</para>
</callout>
<callout arearefs="CO113-3">
<para>Specify the AWS region.</para>
</callout>
</calloutlist>
</section>
<section xml:id="capi-yaml-machine-template-aws_capi-machine-management">
<title>Sample YAML for a Cluster API machine template resource on Amazon Web Services</title>
<simpara>The machine template resource is provider-specific and defines the basic properties of the machines that a compute machine set creates. The compute machine set references this template when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4
kind: AWSMachineTemplate <co xml:id="CO114-1"/>
metadata:
  name: &lt;template_name&gt; <co xml:id="CO114-2"/>
  namespace: openshift-cluster-api
spec:
  template:
    spec: <co xml:id="CO114-3"/>
      uncompressedUserData: true
      iamInstanceProfile: ....
      instanceType: m5.large
      cloudInit:
        insecureSkipSecretsManager: true
      ami:
        id: ....
      subnet:
        filters:
        - name: tag:Name
          values:
          - ...
      additionalSecurityGroups:
      - filters:
        - name: tag:Name
          values:
          - ...</programlisting>
<calloutlist>
<callout arearefs="CO114-1">
<para>Specify the machine template kind. This value must match the value for your platform.</para>
</callout>
<callout arearefs="CO114-2">
<para>Specify a name for the machine template.</para>
</callout>
<callout arearefs="CO114-3">
<para>Specify the details for your environment. The values here are examples.</para>
</callout>
</calloutlist>
</section>
<section xml:id="capi-yaml-machine-set-aws_capi-machine-management">
<title>Sample YAML for a Cluster API compute machine set resource on Amazon Web Services</title>
<simpara>The compute machine set resource defines additional properties of the machines that it creates. The compute machine set also references the infrastructure resource and machine template when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cluster.x-k8s.io/v1alpha4
kind: MachineSet
metadata:
  name: &lt;machine_set_name&gt; <co xml:id="CO115-1"/>
  namespace: openshift-cluster-api
spec:
  clusterName: &lt;cluster_name&gt; <co xml:id="CO115-2"/>
  replicas: 1
  selector:
    matchLabels:
      test: example
  template:
    metadata:
      labels:
        test: example
    spec:
      bootstrap:
         dataSecretName: worker-user-data <co xml:id="CO115-3"/>
      clusterName: &lt;cluster_name&gt; <co xml:id="CO115-4"/>
      infrastructureRef:
        apiVersion: infrastructure.cluster.x-k8s.io/v1alpha4
        kind: AWSMachineTemplate <co xml:id="CO115-5"/>
        name: &lt;cluster_name&gt; <co xml:id="CO115-6"/></programlisting>
<calloutlist>
<callout arearefs="CO115-1">
<para>Specify a name for the compute machine set.</para>
</callout>
<callout arearefs="CO115-2 CO115-4 CO115-6">
<para>Specify the name of the cluster.</para>
</callout>
<callout arearefs="CO115-3">
<para>For the Cluster API Technology Preview, the Operator can use the worker user data secret from <literal>openshift-machine-api</literal> namespace.</para>
</callout>
<callout arearefs="CO115-5">
<para>Specify the machine template kind. This value must match the value for your platform.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="capi-sample-yaml-files-gcp">
<title>Sample YAML files for configuring Google Cloud Platform clusters</title>
<simpara>Some Cluster API resources are provider-specific. The following example YAML files show configurations for a Google Cloud Platform (GCP) cluster.</simpara>
<section xml:id="capi-yaml-infrastructure-gcp_capi-machine-management">
<title>Sample YAML for a Cluster API infrastructure resource on Google Cloud Platform</title>
<simpara>The infrastructure resource is provider-specific and defines properties that are shared by all the compute machine sets in the cluster, such as the region and subnets. The compute machine set references this resource when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
kind: GCPCluster <co xml:id="CO116-1"/>
metadata:
  name: &lt;cluster_name&gt; <co xml:id="CO116-2"/>
spec:
  network:
    name: &lt;cluster_name&gt;-network <co xml:id="CO116-3"/>
  project: &lt;project&gt; <co xml:id="CO116-4"/>
  region: &lt;region&gt; <co xml:id="CO116-5"/></programlisting>
<calloutlist>
<callout arearefs="CO116-1">
<para>Specify the infrastructure kind for the cluster. This value must match the value for your platform.</para>
</callout>
<callout arearefs="CO116-2 CO116-3">
<para>Specify the name of the cluster.</para>
</callout>
<callout arearefs="CO116-4">
<para>Specify the GCP project name.</para>
</callout>
<callout arearefs="CO116-5">
<para>Specify the GCP region.</para>
</callout>
</calloutlist>
</section>
<section xml:id="capi-yaml-machine-template-gcp_capi-machine-management">
<title>Sample YAML for a Cluster API machine template resource on Google Cloud Platform</title>
<simpara>The machine template resource is provider-specific and defines the basic properties of the machines that a compute machine set creates. The compute machine set references this template when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
kind: GCPMachineTemplate <co xml:id="CO117-1"/>
metadata:
  name: &lt;template_name&gt; <co xml:id="CO117-2"/>
  namespace: openshift-cluster-api
spec:
  template:
    spec: <co xml:id="CO117-3"/>
      rootDeviceType: pd-ssd
      rootDeviceSize: 128
      instanceType: n1-standard-4
      image: projects/rhcos-cloud/global/images/rhcos-411-85-202203181601-0-gcp-x86-64
      subnet: &lt;cluster_name&gt;-worker-subnet
      serviceAccounts:
        email: &lt;service_account_email_address&gt;
        scopes:
          - https://www.googleapis.com/auth/cloud-platform
      additionalLabels:
        kubernetes-io-cluster-&lt;cluster_name&gt;: owned
      additionalNetworkTags:
        - &lt;cluster_name&gt;-worker
      ipForwarding: Disabled</programlisting>
<calloutlist>
<callout arearefs="CO117-1">
<para>Specify the machine template kind. This value must match the value for your platform.</para>
</callout>
<callout arearefs="CO117-2">
<para>Specify a name for the machine template.</para>
</callout>
<callout arearefs="CO117-3">
<para>Specify the details for your environment. The values here are examples.</para>
</callout>
</calloutlist>
</section>
<section xml:id="capi-yaml-machine-set-gcp_capi-machine-management">
<title>Sample YAML for a Cluster API compute machine set resource on Google Cloud Platform</title>
<simpara>The compute machine set resource defines additional properties of the machines that it creates. The compute machine set also references the infrastructure resource and machine template when creating machines.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cluster.x-k8s.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machine_set_name&gt; <co xml:id="CO118-1"/>
  namespace: openshift-cluster-api
spec:
  clusterName: &lt;cluster_name&gt; <co xml:id="CO118-2"/>
  replicas: 1
  selector:
    matchLabels:
      test: test
  template:
    metadata:
      labels:
        test: test
    spec:
      bootstrap:
         dataSecretName: worker-user-data <co xml:id="CO118-3"/>
      clusterName: &lt;cluster_name&gt; <co xml:id="CO118-4"/>
      infrastructureRef:
        apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
        kind: GCPMachineTemplate <co xml:id="CO118-5"/>
        name: &lt;machine_set_name&gt; <co xml:id="CO118-6"/>
      failureDomain: &lt;failure_domain&gt; <co xml:id="CO118-7"/></programlisting>
<calloutlist>
<callout arearefs="CO118-1 CO118-6">
<para>Specify a name for the compute machine set.</para>
</callout>
<callout arearefs="CO118-2 CO118-4">
<para>Specify the name of the cluster.</para>
</callout>
<callout arearefs="CO118-3">
<para>For the Cluster API Technology Preview, the Operator can use the worker user data secret from <literal>openshift-machine-api</literal> namespace.</para>
</callout>
<callout arearefs="CO118-5">
<para>Specify the machine template kind. This value must match the value for your platform.</para>
</callout>
<callout arearefs="CO118-7">
<para>Specify the failure domain within the GCP region.</para>
</callout>
</calloutlist>
</section>
</section>
</section>
<section xml:id="capi-machine-set-creating_capi-machine-management">
<title>Creating a Cluster API compute machine set</title>
<simpara>You can create compute machine sets that use the Cluster API to dynamically manage the machine compute resources for specific workloads of your choice.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Deploy an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Enable the use of the Cluster API.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <literal>oc</literal> as a user with <literal>cluster-admin</literal> permission.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file that contains the cluster custom resource (CR) and is named <literal>&lt;cluster_resource_file&gt;.yaml</literal>.</simpara>
<simpara>If you are not sure which value to set for the <literal>&lt;cluster_name&gt;</literal> parameter, you can check the value for an existing Machine API compute machine set in your cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>To list the Machine API compute machine sets, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api <co xml:id="CO119-1"/></programlisting>
<calloutlist>
<callout arearefs="CO119-1">
<para>Specify the <literal>openshift-machine-api</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                DESIRED   CURRENT   READY   AVAILABLE   AGE
agl030519-vplxk-worker-us-east-1a   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1b   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1c   1         1         1       1           55m
agl030519-vplxk-worker-us-east-1d   0         0                             55m
agl030519-vplxk-worker-us-east-1e   0         0                             55m
agl030519-vplxk-worker-us-east-1f   0         0                             55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To display the contents of a specific compute machine set CR, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset &lt;machineset_name&gt; \
-n openshift-machine-api \
-o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
template:
    metadata:
      labels:
        machine.openshift.io/cluster-api-cluster: agl030519-vplxk <co xml:id="CO120-1"/>
        machine.openshift.io/cluster-api-machine-role: worker
        machine.openshift.io/cluster-api-machine-type: worker
        machine.openshift.io/cluster-api-machineset: agl030519-vplxk-worker-us-east-1a
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO120-1">
<para>The cluster ID, which you use for the <literal>&lt;cluster_name&gt;</literal> parameter.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the cluster CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;cluster_resource_file&gt;.yaml</programlisting>
<formalpara>
<title>Verification</title>
<para>To confirm that the cluster CR is created, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME           PHASE        AGE  VERSION
&lt;cluster_name&gt; Provisioning 4h6m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a YAML file that contains the infrastructure CR and is named <literal>&lt;infrastructure_resource_file&gt;.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create the infrastructure CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;infrastructure_resource_file&gt;.yaml</programlisting>
<formalpara>
<title>Verification</title>
<para>To confirm that the infrastructure CR is created, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;infrastructure_kind&gt;</programlisting>
<simpara>where <literal>&lt;infrastructure_kind&gt;</literal> is the value that corresponds to your platform.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME           CLUSTER        READY VPC BASTION IP
&lt;cluster_name&gt; &lt;cluster_name&gt; true</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a YAML file that contains the machine template CR and is named <literal>&lt;machine_template_resource_file&gt;.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create the machine template CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine_template_resource_file&gt;.yaml</programlisting>
<formalpara>
<title>Verification</title>
<para>To confirm that the machine template CR is created, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;machine_template_kind&gt;</programlisting>
<simpara>where <literal>&lt;machine_template_kind&gt;</literal> is the value that corresponds to your platform.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            AGE
&lt;template_name&gt; 77m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a YAML file that contains the compute machine set CR and is named <literal>&lt;machine_set_resource_file&gt;.yaml</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create the compute machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine_set_resource_file&gt;.yaml</programlisting>
<formalpara>
<title>Verification</title>
<para>To confirm that the compute machine set CR is created, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineset -n openshift-cluster-api <co xml:id="CO121-1"/></programlisting>
<calloutlist>
<callout arearefs="CO121-1">
<para>Specify the <literal>openshift-cluster-api</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME               CLUSTER        REPLICAS READY AVAILABLE AGE VERSION
&lt;machine_set_name&gt; &lt;cluster_name&gt; 1        1     1         17m</programlisting>
</para>
</formalpara>
<simpara>When the new compute machine set is available, the <literal>REPLICAS</literal> and <literal>AVAILABLE</literal> values match. If the compute machine set is not available, wait a few minutes and run the command again.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the compute machine set is creating machines according to your desired configuration, you can review the lists of machines and nodes in the cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>To view the list of Cluster API machines, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machine -n openshift-cluster-api <co xml:id="CO122-1"/></programlisting>
<calloutlist>
<callout arearefs="CO122-1">
<para>Specify the <literal>openshift-cluster-api</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           CLUSTER        NODENAME                               PROVIDERID    PHASE   AGE   VERSION
&lt;machine_set_name&gt;-&lt;string_id&gt; &lt;cluster_name&gt; &lt;ip_address&gt;.&lt;region&gt;.compute.internal &lt;provider_id&gt; Running 8m23s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view the list of nodes, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                     STATUS ROLES  AGE   VERSION
&lt;ip_address_1&gt;.&lt;region&gt;.compute.internal Ready  worker 5h14m v1.28.5
&lt;ip_address_2&gt;.&lt;region&gt;.compute.internal Ready  master 5h19m v1.28.5
&lt;ip_address_3&gt;.&lt;region&gt;.compute.internal Ready  worker 7m    v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="capi-troubleshooting_capi-machine-management">
<title>Troubleshooting clusters that use the Cluster API</title>
<simpara>Use the information in this section to understand and recover from issues you might encounter. Generally, troubleshooting steps for problems with the Cluster API are similar to those steps for problems with the Machine API.</simpara>
<simpara>The Cluster CAPI Operator and its operands are provisioned in the <literal>openshift-cluster-api</literal> namespace, whereas the Machine API uses the <literal>openshift-machine-api</literal> namespace. When using <literal>oc</literal> commands that reference a namespace, be sure to reference the correct one.</simpara>
<section xml:id="ts-capi-cli_capi-machine-management">
<title>CLI commands return Cluster API machines</title>
<simpara>For clusters that use the Cluster API, <literal>oc</literal> commands such as <literal>oc get machine</literal> return results for Cluster API machines. Because the letter <literal>c</literal> precedes the letter <literal>m</literal> alphabetically, Cluster API machines appear in the return before Machine API machines do.</simpara>
<itemizedlist>
<listitem>
<simpara>To list only Machine API machines, use the fully qualified name <literal>machines.machine.openshift.io</literal> when running the <literal>oc get machine</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines.machine.openshift.io</programlisting>
</listitem>
<listitem>
<simpara>To list only Cluster API machines, use the fully qualified name <literal>machines.cluster.x-k8s.io</literal> when running the <literal>oc get machine</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines.cluster.x-k8s.io</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_managing-control-plane-machines">
<title>Managing control plane machines</title>
<section xml:id="cpmso-about">
<title>About control plane machine sets</title>

<simpara>With control plane machine sets, you can automate management of the control plane machine resources within your OpenShift Container Platform cluster.</simpara>
<important>
<simpara>Control plane machine sets cannot manage compute machines, and compute machine sets cannot manage control plane machines.</simpara>
</important>
<simpara>Control plane machine sets provide for control plane machines similar management capabilities as compute machine sets provide for compute machines. However, these two types of machine sets are separate custom resources defined within the Machine API and have several fundamental differences in their architecture and functionality.</simpara>
<section xml:id="cpmso-overview_cpmso-about">
<title>Control Plane Machine Set Operator overview</title>
<simpara>The Control Plane Machine Set Operator uses the <literal>ControlPlaneMachineSet</literal> custom resource (CR) to automate management of the control plane machine resources within your OpenShift Container Platform cluster.</simpara>
<simpara>When the state of the cluster control plane machine set is set to <literal>Active</literal>, the Operator ensures that the cluster has the correct number of control plane machines with the specified configuration. This allows the automated replacement of degraded control plane machines and rollout of changes to the control plane.</simpara>
<simpara>A cluster has only one control plane machine set, and the Operator only manages objects in the <literal>openshift-machine-api</literal> namespace.</simpara>
</section>
<section xml:id="cpmso-limitations_cpmso-about">
<title>Limitations</title>
<simpara>The Control Plane Machine Set Operator has the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The Operator requires the Machine API Operator to be operational and is therefore not supported on clusters with manually provisioned machines. When installing a OpenShift Container Platform cluster with manually provisioned machines for a platform that creates an active generated <literal>ControlPlaneMachineSet</literal> custom resource (CR), you must remove the Kubernetes manifest files that define the control plane machine set as instructed in the installation process.</simpara>
</listitem>
<listitem>
<simpara>Only Amazon Web Services (AWS), Google Cloud Platform (GCP), IBM Power&#174; Virtual Server, Microsoft Azure, Nutanix, VMware vSphere, and Red Hat OpenStack Platform (RHOSP) clusters are supported.</simpara>
</listitem>
<listitem>
<simpara>Only clusters with three control plane machines are supported.</simpara>
</listitem>
<listitem>
<simpara>Horizontal scaling of the control plane is not supported.</simpara>
</listitem>
<listitem>
<simpara>Deploying Azure control plane machines on Ephemeral OS disks increases risk for data loss and is not supported.</simpara>
</listitem>
<listitem>
<simpara>Deploying control plane machines as AWS Spot Instances, GCP preemptible VMs, or Azure Spot VMs is not supported.</simpara>
<important>
<simpara>Attempting to deploy control plane machines as AWS Spot Instances, GCP preemptible VMs, or Azure Spot VMs might cause the cluster to lose etcd quorum. A cluster that loses all control plane machines simultaneously is unrecoverable.</simpara>
</important>
</listitem>
<listitem>
<simpara>Making changes to the control plane machine set during or prior to installation is not supported. You must make any changes to the control plane machine set only after installation.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_cpmso-about" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/operators/#control-plane-machine-set-operator_cluster-operators-ref">Control Plane Machine Set Operator reference</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/api_reference/#controlplanemachineset-machine-openshift-io-v1"><literal>ControlPlaneMachineSet</literal> custom resource</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cpmso-getting-started">
<title>Getting started with control plane machine sets</title>

<simpara>The process for getting started with control plane machine sets depends on the state of the <literal>ControlPlaneMachineSet</literal> custom resource (CR) in your cluster.</simpara>
<variablelist>
<varlistentry>
<term>Clusters with an active generated CR</term>
<listitem>
<simpara>Clusters that have a generated CR with an active state use the control plane machine set by default. No administrator action is required.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Clusters with an inactive generated CR</term>
<listitem>
<simpara>For clusters that include an inactive generated CR, you must review the CR configuration and <link linkend="cpmso-activating_cpmso-getting-started">activate the CR</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Clusters without a generated CR</term>
<listitem>
<simpara>For clusters that do not include a generated CR, you must <link linkend="cpmso-creating-cr_cpmso-getting-started">create and activate a CR</link> with the appropriate configuration for your cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>If you are uncertain about the state of the <literal>ControlPlaneMachineSet</literal> CR in your cluster, you can <link linkend="cpmso-checking-status_cpmso-getting-started">verify the CR status</link>.</simpara>
<section xml:id="cpmso-platform-matrix_cpmso-getting-started">
<title>Supported cloud providers</title>
<simpara>In OpenShift Container Platform 4.14, the control plane machine set is supported for Amazon Web Services (AWS), Google Cloud Platform (GCP), Microsoft Azure, Nutanix, and VMware vSphere clusters.</simpara>
<simpara>The status of the control plane machine set after installation depends on your cloud provider and the version of OpenShift Container Platform that you installed on your cluster.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Control plane machine set implementation for OpenShift Container Platform 4.14</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="29.4117*"/>
<colspec colname="col_2" colwidth="23.5294*"/>
<colspec colname="col_3" colwidth="23.5294*"/>
<colspec colname="col_4" colwidth="23.5295*"/>
<thead>
<row>
<entry align="left" valign="middle">Cloud provider</entry>
<entry align="center" valign="middle">Active by default</entry>
<entry align="center" valign="middle">Generated CR</entry>
<entry align="center" valign="middle">Manual CR required</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Amazon Web Services (AWS)</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[1]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Google Cloud Platform (GCP)</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[2]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Microsoft Azure</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[2]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Nutanix</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[3]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>VMware vSphere</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[4]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[4]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Red Hat OpenStack Platform (RHOSP)</simpara></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[3]</superscript></simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>AWS clusters that are upgraded from version 4.11 or earlier require <link linkend="cpmso-activating_cpmso-getting-started">CR activation</link>.</simpara>
</listitem>
<listitem>
<simpara>GCP and Azure clusters that are upgraded from version 4.12 or earlier require <link linkend="cpmso-activating_cpmso-getting-started">CR activation</link>.</simpara>
</listitem>
<listitem>
<simpara>Nutanix and RHOSP clusters that are upgraded from version 4.13 or earlier require <link linkend="cpmso-activating_cpmso-getting-started">CR activation</link>.</simpara>
</listitem>
<listitem>
<simpara>In OpenShift Container Platform 4.14, installing a cluster with an active generated CR on VWware vSphere is available as a <link xlink:href="https://access.redhat.com/support/offerings/techpreview">Technology Preview</link> feature. To enable the feature, set the <literal>featureSet</literal> parameter to <literal>TechPreviewNoUpgrade</literal> in the <literal>install-config.yaml file</literal>.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="cpmso-checking-status_cpmso-getting-started">
<title>Checking the control plane machine set custom resource state</title>
<simpara>You can verify the existence and state of the <literal>ControlPlaneMachineSet</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Determine the state of the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get controlplanemachineset.machine.openshift.io cluster \
  --namespace openshift-machine-api</programlisting>
<itemizedlist>
<listitem>
<simpara>A result of <literal>Active</literal> indicates that the <literal>ControlPlaneMachineSet</literal> CR exists and is activated. No administrator action is required.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>Inactive</literal> indicates that a <literal>ControlPlaneMachineSet</literal> CR exists but is not activated.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>NotFound</literal> indicates that there is no existing <literal>ControlPlaneMachineSet</literal> CR.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<formalpara>
<title>Next steps</title>
<para>To use the control plane machine set, you must ensure that a <literal>ControlPlaneMachineSet</literal> CR with the correct settings for your cluster exists.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>If your cluster has an existing CR, you must verify that the configuration in the CR is correct for your cluster.</simpara>
</listitem>
<listitem>
<simpara>If your cluster does not have an existing CR, you must create one with the correct configuration for your cluster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-activating_cpmso-getting-started">
<title>Activating the control plane machine set custom resource</title>
<simpara>To use the control plane machine set, you must ensure that a <literal>ControlPlaneMachineSet</literal> custom resource (CR) with the correct settings for your cluster exists. On a cluster with a generated CR, you must verify that the configuration in the CR is correct for your cluster and activate it.</simpara>
<note>
<simpara>For more information about the parameters in the CR, see "Control plane machine set configuration".</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the configuration of the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace openshift-machine-api edit controlplanemachineset.machine.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Change the values of any fields that are incorrect for your cluster configuration.</simpara>
</listitem>
<listitem>
<simpara>When the configuration is correct, activate the CR by setting the <literal>.spec.state</literal> field to <literal>Active</literal> and saving your changes.</simpara>
<important>
<simpara>To activate the CR, you must change the <literal>.spec.state</literal> field to <literal>Active</literal> in the same <literal>oc edit</literal> session that you use to update the CR configuration. If the CR is saved with the state left as <literal>Inactive</literal>, the control plane machine set generator resets the CR to its original settings.</simpara>
</important>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-configuration">Control plane machine set configuration</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-creating-cr_cpmso-getting-started">
<title>Creating a control plane machine set custom resource</title>
<simpara>To use the control plane machine set, you must ensure that a <literal>ControlPlaneMachineSet</literal> custom resource (CR) with the correct settings for your cluster exists. On a cluster without a generated CR, you must create the CR manually and activate it.</simpara>
<note>
<simpara>For more information about the structure and parameters of the CR, see "Control plane machine set configuration".</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file using the following template:</simpara>
<formalpara>
<title>Control plane machine set CR YAML file template</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
metadata:
  name: cluster
  namespace: openshift-machine-api
spec:
  replicas: 3
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;cluster_id&gt; <co xml:id="CO123-1"/>
      machine.openshift.io/cluster-api-machine-role: master
      machine.openshift.io/cluster-api-machine-type: master
  state: Active <co xml:id="CO123-2"/>
  strategy:
    type: RollingUpdate <co xml:id="CO123-3"/>
  template:
    machineType: machines_v1beta1_machine_openshift_io
    machines_v1beta1_machine_openshift_io:
      failureDomains:
        platform: &lt;platform&gt; <co xml:id="CO123-4"/>
        &lt;platform_failure_domains&gt; <co xml:id="CO123-5"/>
      metadata:
        labels:
          machine.openshift.io/cluster-api-cluster: &lt;cluster_id&gt; <co xml:id="CO123-6"/>
          machine.openshift.io/cluster-api-machine-role: master
          machine.openshift.io/cluster-api-machine-type: master
      spec:
        providerSpec:
          value:
            &lt;platform_provider_spec&gt; <co xml:id="CO123-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO123-1">
<para>Specify the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. You must specify this value when you create a <literal>ControlPlaneMachineSet</literal> CR. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO123-2">
<para>Specify the state of the Operator. When the state is <literal>Inactive</literal>, the Operator is not operational. You can activate the Operator by setting the value to <literal>Active</literal>.</para>
<important>
<simpara>Before you activate the CR, you must ensure that its configuration is correct for your cluster requirements.</simpara>
</important>
</callout>
<callout arearefs="CO123-3">
<para>Specify the update strategy for the cluster. Valid values are <literal>OnDelete</literal> and <literal>RollingUpdate</literal>. The default value is <literal>RollingUpdate</literal>. For more information about update strategies, see "Updating the control plane configuration".</para>
</callout>
<callout arearefs="CO123-4">
<para>Specify your cloud provider platform name. Valid values are <literal>AWS</literal>, <literal>Azure</literal>, <literal>GCP</literal>, <literal>Nutanix</literal>, <literal>VSphere</literal>, and <literal>OpenStack</literal>.</para>
</callout>
<callout arearefs="CO123-5">
<para>Add the <literal>&lt;platform_failure_domains&gt;</literal> configuration for the cluster. The format and values of this section are provider-specific. For more information, see the sample failure domain configuration for your cloud provider.</para>
</callout>
<callout arearefs="CO123-6">
<para>Specify the infrastructure ID.</para>
</callout>
<callout arearefs="CO123-7">
<para>Add the <literal>&lt;platform_provider_spec&gt;</literal> configuration for the cluster. The format and values of this section are provider-specific. For more information, see the sample provider specification for your cloud provider.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Refer to the sample YAML for a control plane machine set CR and populate your file with values that are appropriate for your cluster configuration.</simpara>
</listitem>
<listitem>
<simpara>Refer to the sample failure domain configuration and sample provider specification for your cloud provider and update those sections of your file with the appropriate values.</simpara>
</listitem>
<listitem>
<simpara>When the configuration is correct, activate the CR by setting the <literal>.spec.state</literal> field to <literal>Active</literal> and saving your changes.</simpara>
</listitem>
<listitem>
<simpara>Create the CR from your YAML file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;control_plane_machine_set&gt;.yaml</programlisting>
<simpara>where <literal>&lt;control_plane_machine_set&gt;</literal> is the name of the YAML file that contains the CR configuration.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-feat-config-update_cpmso-using">Updating the control plane configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-configuration">Control plane machine set configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-aws_cpmso-configuration">Sample YAML for configuring Amazon Web Services clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-gcp_cpmso-configuration">Sample YAML for configuring Google Cloud Platform clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-azure_cpmso-configuration">Sample YAML for configuring Microsoft Azure clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-nutanix_cpmso-configuration">Sample YAML for configuring Nutanix clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-vsphere_cpmso-configuration">Sample YAML for configuring VMware vSphere clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-openstack_cpmso-configuration">Sample YAML for configuring Red Hat OpenStack Platform (RHOSP) clusters</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cpmso-configuration">
<title>Control plane machine set configuration</title>

<simpara>These example YAML snippets show the base structure for a control plane machine set custom resource (CR) and platform-specific samples for provider specification and failure domain configurations.</simpara>
<section xml:id="cpmso-yaml-sample-cr_cpmso-configuration">
<title>Sample YAML for a control plane machine set custom resource</title>
<simpara>The base of the <literal>ControlPlaneMachineSet</literal> CR is structured the same way for all platforms.</simpara>
<formalpara>
<title>Sample <literal>ControlPlaneMachineSet</literal> CR YAML file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
metadata:
  name: cluster <co xml:id="CO124-1"/>
  namespace: openshift-machine-api
spec:
  replicas: 3 <co xml:id="CO124-2"/>
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-cluster: &lt;cluster_id&gt; <co xml:id="CO124-3"/>
      machine.openshift.io/cluster-api-machine-role: master
      machine.openshift.io/cluster-api-machine-type: master
  state: Active <co xml:id="CO124-4"/>
  strategy:
    type: RollingUpdate <co xml:id="CO124-5"/>
  template:
    machineType: machines_v1beta1_machine_openshift_io
    machines_v1beta1_machine_openshift_io:
      failureDomains:
        platform: &lt;platform&gt; <co xml:id="CO124-6"/>
        &lt;platform_failure_domains&gt; <co xml:id="CO124-7"/>
      metadata:
        labels:
          machine.openshift.io/cluster-api-cluster: &lt;cluster_id&gt;
          machine.openshift.io/cluster-api-machine-role: master
          machine.openshift.io/cluster-api-machine-type: master
      spec:
        providerSpec:
          value:
            &lt;platform_provider_spec&gt; <co xml:id="CO124-8"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO124-1">
<para>Specifies the name of the <literal>ControlPlaneMachineSet</literal> CR, which is <literal>cluster</literal>. Do not change this value.</para>
</callout>
<callout arearefs="CO124-2">
<para>Specifies the number of control plane machines. Only clusters with three control plane machines are supported, so the <literal>replicas</literal> value is <literal>3</literal>. Horizontal scaling is not supported. Do not change this value.</para>
</callout>
<callout arearefs="CO124-3">
<para>Specifies the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. You must specify this value when you create a <literal>ControlPlaneMachineSet</literal> CR. If you have the OpenShift CLI (<literal>oc</literal>) installed, you can obtain the infrastructure ID by running the following command:</para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</callout>
<callout arearefs="CO124-4">
<para>Specifies the state of the Operator. When the state is <literal>Inactive</literal>, the Operator is not operational. You can activate the Operator by setting the value to <literal>Active</literal>.</para>
<important>
<simpara>Before you activate the Operator, you must ensure that the <literal>ControlPlaneMachineSet</literal> CR configuration is correct for your cluster requirements. For more information about activating the Control Plane Machine Set Operator, see "Getting started with control plane machine sets".</simpara>
</important>
</callout>
<callout arearefs="CO124-5">
<para>Specifies the update strategy for the cluster. The allowed values are <literal>OnDelete</literal> and <literal>RollingUpdate</literal>. The default value is <literal>RollingUpdate</literal>. For more information about update strategies, see "Updating the control plane configuration".</para>
</callout>
<callout arearefs="CO124-6">
<para>Specifies the cloud provider platform name. Do not change this value.</para>
</callout>
<callout arearefs="CO124-7">
<para>Specifies the <literal>&lt;platform_failure_domains&gt;</literal> configuration for the cluster. The format and values of this section are provider-specific. For more information, see the sample failure domain configuration for your cloud provider.</para>
</callout>
<callout arearefs="CO124-8">
<para>Specifies the <literal>&lt;platform_provider_spec&gt;</literal> configuration for the cluster. The format and values of this section are provider-specific. For more information, see the sample provider specification for your cloud provider.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-getting-started">Getting started with control plane machine sets</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-feat-config-update_cpmso-using">Updating the control plane configuration</link></simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="cpmso-sample-yaml-provider-specific_cpmso-configuration" renderas="sect4">Provider-specific configuration</bridgehead>
<simpara>The <literal>&lt;platform_provider_spec&gt;</literal> and <literal>&lt;platform_failure_domains&gt;</literal> sections of the control plane machine set resources are provider-specific. Refer to the example YAML for your cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-aws_cpmso-configuration">Sample YAML snippets for configuring Amazon Web Services clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-gcp_cpmso-configuration">Sample YAML snippets for configuring Google Cloud Platform clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-azure_cpmso-configuration">Sample YAML snippets for configuring Microsoft Azure clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-nutanix_cpmso-configuration">Sample YAML snippets for configuring Nutanix clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-vsphere_cpmso-configuration">Sample YAML snippets for configuring VMware vSphere clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-sample-yaml-openstack_cpmso-configuration">Sample YAML snippets for configuring Red Hat OpenStack Platform (RHOSP) clusters</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-sample-yaml-aws_cpmso-configuration">
<title>Sample YAML for configuring Amazon Web Services clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippets show provider specification and failure domain configurations for an Amazon Web Services (AWS) cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-aws_cpmso-configuration">
<title>Sample AWS provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane machine custom resource (CR) that is created by the installation program. You can omit any field that is set in the failure domain section of the CR.</simpara>
<simpara>In the following example, <literal>&lt;cluster_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<formalpara>
<title>Sample AWS <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    ami:
      id: ami-&lt;ami_id_string&gt; <co xml:id="CO125-1"/>
    apiVersion: machine.openshift.io/v1beta1
    blockDevices:
    - ebs: <co xml:id="CO125-2"/>
        encrypted: true
        iops: 0
        kmsKey:
          arn: ""
        volumeSize: 120
        volumeType: gp3
    credentialsSecret:
      name: aws-cloud-credentials <co xml:id="CO125-3"/>
    deviceIndex: 0
    iamInstanceProfile:
      id: &lt;cluster_id&gt;-master-profile <co xml:id="CO125-4"/>
    instanceType: m6i.xlarge <co xml:id="CO125-5"/>
    kind: AWSMachineProviderConfig <co xml:id="CO125-6"/>
    loadBalancers: <co xml:id="CO125-7"/>
    - name: &lt;cluster_id&gt;-int
      type: network
    - name: &lt;cluster_id&gt;-ext
      type: network
    metadata:
      creationTimestamp: null
    metadataServiceOptions: {}
    placement: <co xml:id="CO125-8"/>
      region: &lt;region&gt; <co xml:id="CO125-9"/>
    securityGroups:
    - filters:
      - name: tag:Name
        values:
        - &lt;cluster_id&gt;-master-sg <co xml:id="CO125-10"/>
    subnet: {} <co xml:id="CO125-11"/>
    userDataSecret:
      name: master-user-data <co xml:id="CO125-12"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO125-1">
<para>Specifies the Red Hat Enterprise Linux CoreOS (RHCOS) Amazon Machine Images (AMI) ID for the cluster. The AMI must belong to the same region as the cluster. If you want to use an AWS Marketplace image, you must complete the OpenShift Container Platform subscription from the <link xlink:href="https://aws.amazon.com/marketplace/fulfillment?productId=59ead7de-2540-4653-a8b0-fa7926d5c845">AWS Marketplace</link> to obtain an AMI ID for your region.</para>
</callout>
<callout arearefs="CO125-2">
<para>Specifies the configuration of an encrypted EBS volume.</para>
</callout>
<callout arearefs="CO125-3">
<para>Specifies the secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO125-4">
<para>Specifies the AWS Identity and Access Management (IAM) instance profile. Do not change this value.</para>
</callout>
<callout arearefs="CO125-5">
<para>Specifies the AWS instance type for the control plane.</para>
</callout>
<callout arearefs="CO125-6">
<para>Specifies the cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO125-7">
<para>Specifies the internal (<literal>int</literal>) and external (<literal>ext</literal>) load balancers for the cluster.</para>
</callout>
<callout arearefs="CO125-8">
<para>This parameter is configured in the failure domain, and is shown with an empty value here. If a value specified for this parameter differs from the value in the failure domain, the Operator overwrites it with the value in the failure domain.</para>
</callout>
<callout arearefs="CO125-9">
<para>Specifies the AWS region for the cluster.</para>
</callout>
<callout arearefs="CO125-10">
<para>Specifies the control plane machines security group.</para>
</callout>
<callout arearefs="CO125-11">
<para>This parameter is configured in the failure domain, and is shown with an empty value here. If a value specified for this parameter differs from the value in the failure domain, the Operator overwrites it with the value in the failure domain.</para>
</callout>
<callout arearefs="CO125-12">
<para>Specifies the control plane user data secret. Do not change this value.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cpmso-yaml-failure-domain-aws_cpmso-configuration">
<title>Sample AWS failure domain configuration</title>
<simpara>The control plane machine set concept of a failure domain is analogous to existing AWS concept of an <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones"><emphasis>Availability Zone (AZ)</emphasis></link>. The <literal>ControlPlaneMachineSet</literal> CR spreads control plane machines across multiple failure domains when possible.</simpara>
<simpara>When configuring AWS failure domains in the control plane machine set, you must specify the availability zone name and the subnet to use.</simpara>
<formalpara>
<title>Sample AWS failure domain values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">failureDomains:
  aws:
  - placement:
      availabilityZone: &lt;aws_zone_a&gt; <co xml:id="CO126-1"/>
    subnet: <co xml:id="CO126-2"/>
      filters:
      - name: tag:Name
        values:
        - &lt;cluster_id&gt;-private-&lt;aws_zone_a&gt; <co xml:id="CO126-3"/>
      type: Filters <co xml:id="CO126-4"/>
  - placement:
      availabilityZone: &lt;aws_zone_b&gt; <co xml:id="CO126-5"/>
    subnet:
      filters:
      - name: tag:Name
        values:
        - &lt;cluster_id&gt;-private-&lt;aws_zone_b&gt; <co xml:id="CO126-6"/>
      type: Filters
  platform: AWS <co xml:id="CO126-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO126-1">
<para>Specifies an AWS availability zone for the first failure domain.</para>
</callout>
<callout arearefs="CO126-2">
<para>Specifies a subnet configuration. In this example, the subnet type is <literal>Filters</literal>, so there is a <literal>filters</literal> stanza.</para>
</callout>
<callout arearefs="CO126-3">
<para>Specifies the subnet name for the first failure domain, using the infrastructure ID and the AWS availability zone.</para>
</callout>
<callout arearefs="CO126-4">
<para>Specifies the subnet type. The allowed values are: <literal>ARN</literal>, <literal>Filters</literal> and <literal>ID</literal>. The default value is <literal>Filters</literal>.</para>
</callout>
<callout arearefs="CO126-5">
<para>Specifies the subnet name for an additional failure domain, using the infrastructure ID and the AWS availability zone.</para>
</callout>
<callout arearefs="CO126-6">
<para>Specifies the cluster&#8217;s infrastructure ID and the AWS availability zone for the additional failure domain.</para>
</callout>
<callout arearefs="CO126-7">
<para>Specifies the cloud provider platform name. Do not change this value.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-supported-features-aws_cpmso-using">Enabling Amazon Web Services features for control plane machines</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cpmso-sample-yaml-gcp_cpmso-configuration">
<title>Sample YAML for configuring Google Cloud Platform clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippets show provider specification and failure domain configurations for a Google Cloud Platform (GCP) cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-gcp_cpmso-configuration">
<title>Sample GCP provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane machine custom resource (CR) that is created by the installation program. You can omit any field that is set in the failure domain section of the CR.</simpara>
<bridgehead xml:id="cpmso-yaml-provider-spec-gcp-oc_cpmso-configuration" renderas="sect5">Values obtained by using the OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI.</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;cluster_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
<varlistentry>
<term>Image path</term>
<listitem>
<simpara>The <literal>&lt;path_to_image&gt;</literal> string is the path to the image that was used to create the disk. If you have the OpenShift CLI installed, you can obtain the path to the image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
  -o jsonpath='{.spec.template.machines_v1beta1_machine_openshift_io.spec.providerSpec.value.disks[0].image}{"\n"}' \
  get ControlPlaneMachineSet/cluster</programlisting>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Sample GCP <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1beta1
    canIPForward: false
    credentialsSecret:
      name: gcp-cloud-credentials <co xml:id="CO127-1"/>
    deletionProtection: false
    disks:
    - autoDelete: true
      boot: true
      image: &lt;path_to_image&gt; <co xml:id="CO127-2"/>
      labels: null
      sizeGb: 200
      type: pd-ssd
    kind: GCPMachineProviderSpec <co xml:id="CO127-3"/>
    machineType: e2-standard-4
    metadata:
      creationTimestamp: null
    metadataServiceOptions: {}
    networkInterfaces:
    - network: &lt;cluster_id&gt;-network
      subnetwork: &lt;cluster_id&gt;-master-subnet
    projectID: &lt;project_name&gt; <co xml:id="CO127-4"/>
    region: &lt;region&gt; <co xml:id="CO127-5"/>
    serviceAccounts:
    - email: &lt;cluster_id&gt;-m@&lt;project_name&gt;.iam.gserviceaccount.com
      scopes:
      - https://www.googleapis.com/auth/cloud-platform
    shieldedInstanceConfig: {}
    tags:
    - &lt;cluster_id&gt;-master
    targetPools:
    - &lt;cluster_id&gt;-api
    userDataSecret:
      name: master-user-data <co xml:id="CO127-6"/>
    zone: "" <co xml:id="CO127-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO127-1">
<para>Specifies the secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO127-2">
<para>Specifies the path to the image that was used to create the disk.</para>
<simpara>To use a GCP Marketplace image, specify the offer to use:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-ocp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Platform Plus: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-opp-413-x86-64-202305021736</literal></simpara>
</listitem>
<listitem>
<simpara>OpenShift Kubernetes Engine: <literal>https://www.googleapis.com/compute/v1/projects/redhat-marketplace-public/global/images/redhat-coreos-oke-413-x86-64-202305021736</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO127-3">
<para>Specifies the cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO127-4">
<para>Specifies the name of the GCP project that you use for your cluster.</para>
</callout>
<callout arearefs="CO127-5">
<para>Specifies the GCP region for the cluster.</para>
</callout>
<callout arearefs="CO127-6">
<para>Specifies the control plane user data secret. Do not change this value.</para>
</callout>
<callout arearefs="CO127-7">
<para>This parameter is configured in the failure domain, and is shown with an empty value here. If a value specified for this parameter differs from the value in the failure domain, the Operator overwrites it with the value in the failure domain.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cpmso-yaml-failure-domain-gcp_cpmso-configuration">
<title>Sample GCP failure domain configuration</title>
<simpara>The control plane machine set concept of a failure domain is analogous to the existing GCP concept of a <link xlink:href="https://cloud.google.com/compute/docs/regions-zones"><emphasis>zone</emphasis></link>. The <literal>ControlPlaneMachineSet</literal> CR spreads control plane machines across multiple failure domains when possible.</simpara>
<simpara>When configuring GCP failure domains in the control plane machine set, you must specify the zone name to use.</simpara>
<formalpara>
<title>Sample GCP failure domain values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">failureDomains:
  gcp:
  - zone: &lt;gcp_zone_a&gt; <co xml:id="CO128-1"/>
  - zone: &lt;gcp_zone_b&gt; <co xml:id="CO128-2"/>
  - zone: &lt;gcp_zone_c&gt;
  - zone: &lt;gcp_zone_d&gt;
  platform: GCP <co xml:id="CO128-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO128-1">
<para>Specifies a GCP zone for the first failure domain.</para>
</callout>
<callout arearefs="CO128-2">
<para>Specifies an additional failure domain. Further failure domains are added the same way.</para>
</callout>
<callout arearefs="CO128-3">
<para>Specifies the cloud provider platform name. Do not change this value.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="cpmso-sample-yaml-azure_cpmso-configuration">
<title>Sample YAML for configuring Microsoft Azure clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippets show provider specification and failure domain configurations for an Azure cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-azure_cpmso-configuration">
<title>Sample Azure provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane <literal>Machine</literal> CR that is created by the installation program. You can omit any field that is set in the failure domain section of the CR.</simpara>
<simpara>In the following example, <literal>&lt;cluster_id&gt;</literal> is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
<formalpara>
<title>Sample Azure <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    acceleratedNetworking: true
    apiVersion: machine.openshift.io/v1beta1
    credentialsSecret:
      name: azure-cloud-credentials <co xml:id="CO129-1"/>
      namespace: openshift-machine-api
    diagnostics: {}
    image: <co xml:id="CO129-2"/>
      offer: ""
      publisher: ""
      resourceID: /resourceGroups/&lt;cluster_id&gt;-rg/providers/Microsoft.Compute/galleries/gallery_&lt;cluster_id&gt;/images/&lt;cluster_id&gt;-gen2/versions/412.86.20220930 <co xml:id="CO129-3"/>
      sku: ""
      version: ""
    internalLoadBalancer: &lt;cluster_id&gt;-internal <co xml:id="CO129-4"/>
    kind: AzureMachineProviderSpec <co xml:id="CO129-5"/>
    location: &lt;region&gt; <co xml:id="CO129-6"/>
    managedIdentity: &lt;cluster_id&gt;-identity
    metadata:
      creationTimestamp: null
      name: &lt;cluster_id&gt;
    networkResourceGroup: &lt;cluster_id&gt;-rg
    osDisk: <co xml:id="CO129-7"/>
      diskSettings: {}
      diskSizeGB: 1024
      managedDisk:
        storageAccountType: Premium_LRS
      osType: Linux
    publicIP: false
    publicLoadBalancer: &lt;cluster_id&gt; <co xml:id="CO129-8"/>
    resourceGroup: &lt;cluster_id&gt;-rg
    subnet: &lt;cluster_id&gt;-master-subnet <co xml:id="CO129-9"/>
    userDataSecret:
      name: master-user-data <co xml:id="CO129-10"/>
    vmSize: Standard_D8s_v3
    vnet: &lt;cluster_id&gt;-vnet
    zone: "" <co xml:id="CO129-11"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO129-1">
<para>Specifies the secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO129-2">
<para>Specifies the image details for your control plane machine set.</para>
</callout>
<callout arearefs="CO129-3">
<para>Specifies an image that is compatible with your instance type. The Hyper-V generation V2 images created by the installation program have a <literal>-gen2</literal> suffix, while V1 images have the same name without the suffix.</para>
</callout>
<callout arearefs="CO129-4">
<para>Specifies the internal load balancer for the control plane. This field might not be preconfigured but is required in both the <literal>ControlPlaneMachineSet</literal> and control plane <literal>Machine</literal> CRs.</para>
</callout>
<callout arearefs="CO129-5">
<para>Specifies the cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO129-6">
<para>Specifies the region to place control plane machines on.</para>
</callout>
<callout arearefs="CO129-7">
<para>Specifies the disk configuration for the control plane.</para>
</callout>
<callout arearefs="CO129-8">
<para>Specifies the public load balancer for the control plane.</para>
</callout>
<callout arearefs="CO129-9">
<para>Specifies the subnet for the control plane.</para>
</callout>
<callout arearefs="CO129-10">
<para>Specifies the control plane user data secret. Do not change this value.</para>
</callout>
<callout arearefs="CO129-11">
<para>This parameter is configured in the failure domain, and is shown with an empty value here. If a value specified for this parameter differs from the value in the failure domain, the Operator overwrites it with the value in the failure domain.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cpmso-yaml-failure-domain-azure_cpmso-configuration">
<title>Sample Azure failure domain configuration</title>
<simpara>The control plane machine set concept of a failure domain is analogous to existing Azure concept of an <link xlink:href="https://learn.microsoft.com/en-us/azure/azure-web-pubsub/concept-availability-zones"><emphasis>Azure availability zone</emphasis></link>. The <literal>ControlPlaneMachineSet</literal> CR spreads control plane machines across multiple failure domains when possible.</simpara>
<simpara>When configuring Azure failure domains in the control plane machine set, you must specify the availability zone name.</simpara>
<formalpara>
<title>Sample Azure failure domain values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">failureDomains:
  azure: <co xml:id="CO130-1"/>
  - zone: "1"
  - zone: "2"
  - zone: "3"
  platform: Azure <co xml:id="CO130-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO130-1">
<para>Each instance of <literal>zone</literal> specifies an Azure availability zone for a failure domain.</para>
</callout>
<callout arearefs="CO130-2">
<para>Specifies the cloud provider platform name. Do not change this value.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-supported-features-azure_cpmso-using">Enabling Microsoft Azure features for control plane machines</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cpmso-sample-yaml-nutanix_cpmso-configuration">
<title>Sample YAML for configuring Nutanix clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippet shows a provider specification configuration for a Nutanix cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-nutanix_cpmso-configuration">
<title>Sample Nutanix provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane machine custom resource (CR) that is created by the installation program.</simpara>
<bridgehead xml:id="cpmso-yaml-provider-spec-nutanix-oc_cpmso-configuration" renderas="sect5">Values obtained by using the OpenShift CLI</bridgehead>
<simpara>In the following example, you can obtain some of the values for your cluster by using the OpenShift CLI.</simpara>
<variablelist>
<varlistentry>
<term>Infrastructure ID</term>
<listitem>
<simpara>The <literal>&lt;cluster_id&gt;</literal> string is the infrastructure ID that is based on the cluster ID that you set when you provisioned the cluster. If you have the OpenShift CLI installed, you can obtain the infrastructure ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o jsonpath='{.status.infrastructureName}{"\n"}' infrastructure cluster</programlisting>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Sample Nutanix <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1
    bootType: "" <co xml:id="CO131-1"/>
    categories: <co xml:id="CO131-2"/>
    - key: &lt;category_name&gt;
      value: &lt;category_value&gt;
    cluster: <co xml:id="CO131-3"/>
      type: uuid
      uuid: &lt;cluster_uuid&gt;
    credentialsSecret:
      name: nutanix-credentials <co xml:id="CO131-4"/>
    image: <co xml:id="CO131-5"/>
      name: &lt;cluster_id&gt;-rhcos
      type: name
    kind: NutanixMachineProviderConfig <co xml:id="CO131-6"/>
    memorySize: 16Gi <co xml:id="CO131-7"/>
    metadata:
      creationTimestamp: null
    project: <co xml:id="CO131-8"/>
      type: name
      name: &lt;project_name&gt;
    subnets: <co xml:id="CO131-9"/>
    - type: uuid
      uuid: &lt;subnet_uuid&gt;
    systemDiskSize: 120Gi <co xml:id="CO131-10"/>
    userDataSecret:
      name: master-user-data <co xml:id="CO131-11"/>
    vcpuSockets: 8 <co xml:id="CO131-12"/>
    vcpusPerSocket: 1 <co xml:id="CO131-13"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO131-1">
<para>Specifies the boot type that the control plane machines use. For more information about boot types, see <link xlink:href="https://portal.nutanix.com/page/documents/kbs/details?targetId=kA07V000000H3K9SAK">Understanding UEFI, Secure Boot, and TPM in the Virtualized Environment</link>. Valid values are <literal>Legacy</literal>, <literal>SecureBoot</literal>, or <literal>UEFI</literal>. The default is <literal>Legacy</literal>.</para>
<note>
<simpara>You must use the <literal>Legacy</literal> boot type in OpenShift Container Platform 4.14.</simpara>
</note>
</callout>
<callout arearefs="CO131-2">
<para>Specifies one or more Nutanix Prism categories to apply to control plane machines. This stanza requires <literal>key</literal> and <literal>value</literal> parameters for a category key-value pair that exists in Prism Central. For more information about categories, see <link xlink:href="https://portal.nutanix.com/page/documents/details?targetId=Prism-Central-Guide-vpc_2022_6:ssp-ssp-categories-manage-pc-c.html">Category management</link>.</para>
</callout>
<callout arearefs="CO131-3">
<para>Specifies a Nutanix Prism Element cluster configuration. In this example, the cluster type is <literal>uuid</literal>, so there is a <literal>uuid</literal> stanza.</para>
</callout>
<callout arearefs="CO131-4">
<para>Specifies the secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO131-5">
<para>Specifies the image that was used to create the disk.</para>
</callout>
<callout arearefs="CO131-6">
<para>Specifies the cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO131-7">
<para>Specifies the memory allocated for the control plane machines.</para>
</callout>
<callout arearefs="CO131-8">
<para>Specifies the Nutanix project that you use for your cluster. In this example, the project type is <literal>name</literal>, so there is a <literal>name</literal> stanza.</para>
</callout>
<callout arearefs="CO131-9">
<para>Specifies a subnet configuration. In this example, the subnet type is <literal>uuid</literal>, so there is a <literal>uuid</literal> stanza.</para>
</callout>
<callout arearefs="CO131-10">
<para>Specifies the VM disk size for the control plane machines.</para>
</callout>
<callout arearefs="CO131-11">
<para>Specifies the control plane user data secret. Do not change this value.</para>
</callout>
<callout arearefs="CO131-12">
<para>Specifies the number of vCPU sockets allocated for the control plane machines.</para>
</callout>
<callout arearefs="CO131-13">
<para>Specifies the number of vCPUs for each control plane vCPU socket.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="cpmso-sample-yaml-vsphere_cpmso-configuration">
<title>Sample YAML for configuring VMware vSphere clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippet shows a provider specification configuration for a VMware vSphere cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-vsphere_cpmso-configuration">
<title>Sample vSphere provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane machine custom resource (CR) that is created by the installation program.</simpara>
<formalpara>
<title>Sample vSphere <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1beta1
    credentialsSecret:
      name: vsphere-cloud-credentials <co xml:id="CO132-1"/>
    diskGiB: 120 <co xml:id="CO132-2"/>
    kind: VSphereMachineProviderSpec <co xml:id="CO132-3"/>
    memoryMiB: 16384 <co xml:id="CO132-4"/>
    metadata:
      creationTimestamp: null
    network: <co xml:id="CO132-5"/>
      devices:
      - networkName: &lt;vm_network_name&gt;
    numCPUs: 4 <co xml:id="CO132-6"/>
    numCoresPerSocket: 4 <co xml:id="CO132-7"/>
    snapshot: ""
    template: &lt;vm_template_name&gt; <co xml:id="CO132-8"/>
    userDataSecret:
      name: master-user-data <co xml:id="CO132-9"/>
    workspace:
      datacenter: &lt;vcenter_datacenter_name&gt; <co xml:id="CO132-10"/>
      datastore: &lt;vcenter_datastore_name&gt; <co xml:id="CO132-11"/>
      folder: &lt;path_to_vcenter_vm_folder&gt; <co xml:id="CO132-12"/>
      resourcePool: &lt;vsphere_resource_pool&gt; <co xml:id="CO132-13"/>
      server: &lt;vcenter_server_ip&gt; <co xml:id="CO132-14"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO132-1">
<para>Specifies the secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO132-2">
<para>Specifies the VM disk size for the control plane machines.</para>
</callout>
<callout arearefs="CO132-3">
<para>Specifies the cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO132-4">
<para>Specifies the memory allocated for the control plane machines.</para>
</callout>
<callout arearefs="CO132-5">
<para>Specifies the network on which the control plane is deployed.</para>
</callout>
<callout arearefs="CO132-6">
<para>Specifies the number of CPUs allocated for the control plane machines.</para>
</callout>
<callout arearefs="CO132-7">
<para>Specifies the number of cores for each control plane CPU.</para>
</callout>
<callout arearefs="CO132-8">
<para>Specifies the vSphere VM template to use, such as <literal>user-5ddjd-rhcos</literal>.</para>
</callout>
<callout arearefs="CO132-9">
<para>Specifies the control plane user data secret. Do not change this value.</para>
</callout>
<callout arearefs="CO132-10">
<para>Specifies the vCenter Datacenter for the control plane.</para>
</callout>
<callout arearefs="CO132-11">
<para>Specifies the vCenter Datastore for the control plane.</para>
</callout>
<callout arearefs="CO132-12">
<para>Specifies the path to the vSphere VM folder in vCenter, such as <literal>/dc1/vm/user-inst-5ddjd</literal>.</para>
</callout>
<callout arearefs="CO132-13">
<para>Specifies the vSphere resource pool for your VMs.</para>
</callout>
<callout arearefs="CO132-14">
<para>Specifies the vCenter server IP or fully qualified domain name.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cpmso-yaml-failure-domain-vsphere_cpmso-configuration">
<title>Sample VMware vSphere failure domain configuration</title>
<simpara>On VMware vSphere infrastructure, the cluster-wide infrastructure Custom Resource Definition (CRD), <literal>infrastructures.config.openshift.io</literal>, defines failure domains for your cluster. The <literal>providerSpec</literal> in the <literal>ControlPlaneMachineSet</literal> custom resource (CR) specifies names for failure domains. A failure domain is an infrastructure resource that comprises a control plane machine set, a vCenter datacenter, vCenter datastore, and a network.</simpara>
<simpara>By using a failure domain resource, you can use a control plane machine set to deploy control plane machines on hardware that is separate from the primary VMware vSphere infrastructure. A control plane machine set also balances control plane machines across defined failure domains to provide fault tolerance capabilities to your infrastructure.</simpara>
<note>
<simpara>If you modify the <literal>ProviderSpec</literal> configuration in the <literal>ControlPlaneMachineSet</literal> CR, the control plane machine set updates all control plane machines deployed on the primary infrastructure and each failure domain infrastructure.</simpara>
</note>
<important>
<simpara>Defining a failure domain for a control plane machine set is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<formalpara>
<title>Example ProviderSpec configuration with specified failure domain names</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
metadata:
  name: cluster
  namespace: openshift-machine-api
spec:
# ...
  template:
    machineType: machines_v1beta1_machine_openshift_io
    machines_v1beta1_machine_openshift_io:
      failureDomains: <co xml:id="CO133-1"/>
        platform: VSphere
        vsphere: <co xml:id="CO133-2"/>
        - name: &lt;failure_domain_name1&gt;
        - name: &lt;failure_domain_name2&gt;
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO133-1">
<para>A failure domain defines the vCenter location for OpenShift Container Platform cluster nodes.</para>
</callout>
<callout arearefs="CO133-2">
<para>Defines failure domains by name for the control plane machine set.</para>
</callout>
</calloutlist>
<important>
<simpara>Each <literal>failureDomains.platform.vsphere.name</literal> field value in the <literal>ControlPlaneMachineSet</literal> CR must match the corresponding value defined in the <literal>failureDomains.name</literal> field of the cluster-wide infrastructure CRD. Currently, the <literal>vsphere.name</literal> field is the only supported failure domain field that you can specify in the <literal>ControlPlaneMachineSet</literal> CR.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For an example of a cluster-wide infrastructure CRD that defines resources for each failure domain, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/postinstallation_configuration/#specifying-regions-zones-infrastructure-vsphere_post-install-vsphere-zones-regions-configuration">Specifying multiple regions and zones for your cluster on vSphere</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cpmso-sample-yaml-openstack_cpmso-configuration">
<title>Sample YAML for configuring Red Hat OpenStack Platform (RHOSP) clusters</title>
<simpara>Some sections of the control plane machine set CR are provider-specific. The following example YAML snippets show provider specification and failure domain configurations for an RHOSP cluster.</simpara>
<section xml:id="cpmso-yaml-provider-spec-openstack_cpmso-configuration">
<title>Sample RHOSP provider specification</title>
<simpara>When you create a control plane machine set for an existing cluster, the provider specification must match the <literal>providerSpec</literal> configuration in the control plane machine custom resource (CR) that is created by the installation program.</simpara>
<formalpara>
<title>Sample OpenStack <literal>providerSpec</literal> values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1alpha1
    cloudName: openstack
    cloudsSecret:
      name: openstack-cloud-credentials <co xml:id="CO134-1"/>
      namespace: openshift-machine-api
    flavor: m1.xlarge <co xml:id="CO134-2"/>
    image: ocp1-2g2xs-rhcos
    kind: OpenstackProviderSpec <co xml:id="CO134-3"/>
    metadata:
      creationTimestamp: null
    networks:
    - filter: {}
      subnets:
      - filter:
          name: ocp1-2g2xs-nodes
          tags: openshiftClusterID=ocp1-2g2xs
    securityGroups:
    - filter: {}
      name: ocp1-2g2xs-master <co xml:id="CO134-4"/>
    serverGroupName: ocp1-2g2xs-master
    serverMetadata:
      Name: ocp1-2g2xs-master
      openshiftClusterID: ocp1-2g2xs
    tags:
    - openshiftClusterID=ocp1-2g2xs
    trunk: true
    userDataSecret:
      name: master-user-data</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO134-1">
<para>The secret name for the cluster. Do not change this value.</para>
</callout>
<callout arearefs="CO134-2">
<para>The RHOSP flavor type for the control plane.</para>
</callout>
<callout arearefs="CO134-3">
<para>The RHOSP cloud provider platform type. Do not change this value.</para>
</callout>
<callout arearefs="CO134-4">
<para>The control plane machines security group.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cpmso-yaml-failure-domain-openstack_cpmso-configuration">
<title>Sample RHOSP failure domain configuration</title>
<simpara>The control plane machine set concept of a failure domain is analogous to existing Red Hat OpenStack Platform (RHOSP) concept of an <link xlink:href="https://docs.openstack.org/nova/latest/admin/availability-zones.html">availability zone</link>. The <literal>ControlPlaneMachineSet</literal> CR spreads control plane machines across multiple failure domains when possible.</simpara>
<simpara>The following example demonstrates the use of multiple Nova availability zones as well as Cinder availability zones.</simpara>
<formalpara>
<title>Sample OpenStack failure domain values</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">failureDomains:
  platform: OpenStack
  openstack:
  - availabilityZone: nova-az0
    rootVolume:
      availabilityZone: cinder-az0
  - availabilityZone: nova-az1
    rootVolume:
      availabilityZone: cinder-az1
  - availabilityZone: nova-az2
    rootVolume:
      availabilityZone: cinder-az2</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="cpmso-using">
<title>Managing control plane machines with control plane machine sets</title>

<simpara>Control plane machine sets automate several essential aspects of control plane management.</simpara>
<section xml:id="cpmso-feat-replace_cpmso-using">
<title>Replacing a control plane machine</title>
<simpara>To replace a control plane machine in a cluster that has a control plane machine set, you delete the machine manually. The control plane machine set replaces the deleted machine with one using the specification in the control plane machine set custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>If your cluster runs on Red Hat OpenStack Platform (RHOSP) and you need to evacuate a compute server, such as for an upgrade, you must disable the RHOSP compute node that the machine runs on by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openstack compute service set &lt;target_node_host_name&gt; nova-compute --disable</programlisting>
<simpara>For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/17.1/html/configuring_the_compute_service_for_instance_creation/assembly_managing-instances_managing-instances#proc_preparing-to-migrate_migrating-instances">Preparing to migrate</link> in the RHOSP documentation.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the control plane machines in your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines \
  -l machine.openshift.io/cluster-api-machine-role==master \
  -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Delete a control plane machine by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete machine \
  -n openshift-machine-api \
  &lt;control_plane_machine_name&gt; <co xml:id="CO135-1"/></programlisting>
<calloutlist>
<callout arearefs="CO135-1">
<para>Specify the name of the control plane machine to delete.</para>
</callout>
</calloutlist>
<note>
<simpara>If you delete multiple control plane machines, the control plane machine set replaces them according to the configured update strategy:</simpara>
<itemizedlist>
<listitem>
<simpara>For clusters that use the default <literal>RollingUpdate</literal> update strategy, the Operator replaces one machine at a time until each machine is replaced.</simpara>
</listitem>
<listitem>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, the Operator creates all of the required replacement machines simultaneously.</simpara>
</listitem>
</itemizedlist>
<simpara>Both strategies maintain etcd health during control plane machine replacement.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="cpmso-feat-config-update_cpmso-using">
<title>Updating the control plane configuration</title>
<simpara>You can make changes to the configuration of the machines in the control plane by updating the specification in the control plane machine set custom resource (CR).</simpara>
<simpara>The Control Plane Machine Set Operator monitors the control plane machines and compares their configuration with the specification in the control plane machine set CR. When there is a discrepancy between the specification in the CR and the configuration of a control plane machine, the Operator marks that control plane machine for replacement.</simpara>
<note>
<simpara>For more information about the parameters in the CR, see "Control plane machine set configuration".</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster has an activated and functioning Control Plane Machine Set Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit your control plane machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit controlplanemachineset.machine.openshift.io cluster \
  -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Change the values of any fields that you want to update in your cluster configuration.</simpara>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>For clusters that use the default <literal>RollingUpdate</literal> update strategy, the control plane machine set propagates changes to your control plane configuration automatically.</simpara>
</listitem>
<listitem>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, you must replace your control plane machines manually.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cpmso-feat-auto-update_cpmso-using">
<title>Automatic updates to the control plane configuration</title>
<simpara>The <literal>RollingUpdate</literal> update strategy automatically propagates changes to your control plane configuration. This update strategy is the default configuration for the control plane machine set.</simpara>
<simpara>For clusters that use the <literal>RollingUpdate</literal> update strategy, the Operator creates a replacement control plane machine with the configuration that is specified in the CR. When the replacement control plane machine is ready, the Operator deletes the control plane machine that is marked for replacement. The replacement machine then joins the control plane.</simpara>
<simpara>If multiple control plane machines are marked for replacement, the Operator protects etcd health during replacement by repeating this replacement process one machine at a time until it has replaced each machine.</simpara>
</section>
<section xml:id="cpmso-feat-ondelete-update_cpmso-using">
<title>Manual updates to the control plane configuration</title>
<simpara>You can use the <literal>OnDelete</literal> update strategy to propagate changes to your control plane configuration by replacing machines manually. Manually replacing machines allows you to test changes to your configuration on a single machine before applying the changes more broadly.</simpara>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, the Operator creates a replacement control plane machine when you delete an existing machine. When the replacement control plane machine is ready, the etcd Operator allows the existing machine to be deleted. The replacement machine then joins the control plane.</simpara>
<simpara>If multiple control plane machines are deleted, the Operator creates all of the required replacement machines simultaneously. The Operator maintains etcd health by preventing more than one machine being removed from the control plane at once.</simpara>
</section>
</section>
<section xml:id="cpmso-supported-features-aws_cpmso-using">
<title>Enabling Amazon Web Services features for control plane machines</title>
<simpara>You can enable Amazon Web Services (AWS) features on control plane machines by changing the configuration of your control plane machine set. When you save an update to the control plane machine set, the Control Plane Machine Set Operator updates the control plane machines according to your configured update strategy.</simpara>
<section xml:id="private-clusters-setting-api-private_cpmso-using-aws">
<title>Restricting the API server to private</title>
<simpara>After you deploy a cluster to
Amazon Web Services (AWS),
you can reconfigure the API server to use only the private zone.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Have access to the web console as a user with <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web portal or console for your cloud provider, take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Locate and delete the appropriate load balancer component:</simpara>
<itemizedlist>
<listitem>
<simpara>For AWS, delete the external load balancer. The API DNS entry in the private zone already points to the internal load balancer, which uses an identical configuration, so you do not need to modify the internal load balancer.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>api.$clustername.$yourdomain</literal> DNS entry in the public zone.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the external load balancers by deleting the following lines in the control plane machine set custom resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    loadBalancers:
    - name: lk4pj-ext <co xml:id="CO136-1"/>
      type: network <co xml:id="CO136-2"/>
    - name: lk4pj-int
      type: network</programlisting>
<calloutlist>
<callout arearefs="CO136-1 CO136-2">
<para>Delete this line.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cpms-changing-aws-instance-type_cpmso-using">
<title>Changing the Amazon Web Services instance type by using a control plane machine set</title>
<simpara>You can change the Amazon Web Services (AWS) instance type that your control plane machines use by updating the specification in the control plane machine set custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your AWS cluster uses a control plane machine set.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    ...
    instanceType: &lt;compatible_aws_instance_type&gt; <co xml:id="CO137-1"/></programlisting>
<calloutlist>
<callout arearefs="CO137-1">
<para>Specify a larger AWS instance type with the same base as the previous selection. For example, you can change <literal>m6i.xlarge</literal> to <literal>m6i.2xlarge</literal> or <literal>m6i.4xlarge</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machineset-aws-existing-placement-group_cpmso-using">
<title>Assigning machines to placement groups for Elastic Fabric Adapter instances by using machine sets</title>
<simpara>You can configure a machine set to deploy machines on <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html">Elastic Fabric Adapter</link> (EFA) instances within an existing AWS placement group.</simpara>
<simpara>EFA instances do not require placement groups, and you can use placement groups for purposes other than configuring an EFA. This example uses both to demonstrate a configuration that can improve network performance for machines within the specified placement group.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You created a placement group in the AWS console.</simpara>
<note>
<simpara>Ensure that the <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/placement-groups.html#limitations-placement-groups">rules and limitations</link> for the type of placement group that you create are compatible with your intended use case.
The control plane machine set spreads the control plane machines across multiple failure domains when possible. To use placement groups for the control plane, you must use a placement group type that can span multiple Availability Zones.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following lines under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          instanceType: &lt;supported_instance_type&gt; <co xml:id="CO138-1"/>
          networkInterfaceType: EFA <co xml:id="CO138-2"/>
          placement:
            availabilityZone: &lt;zone&gt; <co xml:id="CO138-3"/>
            region: &lt;region&gt; <co xml:id="CO138-4"/>
          placementGroupName: &lt;placement_group&gt; <co xml:id="CO138-5"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO138-1">
<para>Specify an instance type that <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html#efa-instance-types">supports EFAs</link>.</para>
</callout>
<callout arearefs="CO138-2">
<para>Specify the <literal>EFA</literal> network interface type.</para>
</callout>
<callout arearefs="CO138-3">
<para>Specify the zone, for example, <literal>us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO138-4">
<para>Specify the region, for example, <literal>us-east-1</literal>.</para>
</callout>
<callout arearefs="CO138-5">
<para>Specify the name of the existing AWS placement group to deploy machines in.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>In the AWS console, find a machine that the machine set created and verify the following in the machine properties:</simpara>
<itemizedlist>
<listitem>
<simpara>The placement group field has the value that you specified for the <literal>placementGroupName</literal> parameter in the machine set.</simpara>
</listitem>
<listitem>
<simpara>The interface type field indicates that it uses an EFA.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-imds-options_cpmso-using">
<title>Machine set options for the Amazon EC2 Instance Metadata Service</title>
<simpara>You can use machine sets to create machines that use a specific version of the Amazon EC2 Instance Metadata Service (IMDS). Machine sets can create machines that allow the use of both IMDSv1 and <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-service.html">IMDSv2</link> or machines that require the use of IMDSv2.</simpara>
<note>
<simpara>Using IMDSv2 is only supported on AWS clusters that were created with OpenShift Container Platform version 4.7 or later.</simpara>
</note>
<simpara>To change the IMDS configuration for existing machines, edit the machine set YAML file that manages those machines.</simpara>
<important>
<simpara>Before configuring a machine set to create machines that require IMDSv2, ensure that any workloads that interact with the AWS metadata service support IMDSv2.</simpara>
</important>
<section xml:id="machineset-creating-imds-options_cpmso-using">
<title>Configuring IMDS by using machine sets</title>
<simpara>You can specify whether to require the use of IMDSv2 by adding or editing the value of <literal>metadataServiceOptions.authentication</literal> in the machine set YAML file for your machines.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>To use IMDSv2, your AWS cluster must have been created with OpenShift Container Platform version 4.7 or later.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add or edit the following lines under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    metadataServiceOptions:
      authentication: Required <co xml:id="CO139-1"/></programlisting>
<calloutlist>
<callout arearefs="CO139-1">
<para>To require IMDSv2, set the parameter value to <literal>Required</literal>. To allow the use of both IMDSv1 and IMDSv2, set the parameter value to <literal>Optional</literal>. If no value is specified, both IMDSv1 and IMDSv2 are allowed.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machineset-dedicated-instance_cpmso-using">
<title>Machine sets that deploy machines as Dedicated Instances</title>
<simpara>You can create a machine set running on AWS that deploys machines as Dedicated Instances. Dedicated Instances run in a virtual private cloud (VPC) on hardware that is dedicated to a single customer. These Amazon EC2 instances are physically isolated at the host hardware level. The isolation of Dedicated Instances occurs even if the instances belong to different AWS accounts that are linked to a single payer account. However, other instances that are not dedicated can share hardware with Dedicated Instances if they belong to the same AWS account.</simpara>
<simpara>Instances with either public or dedicated tenancy are supported by the Machine API. Instances with public tenancy run on shared hardware. Public tenancy is the default tenancy. Instances with dedicated tenancy run on single-tenant hardware.</simpara>
<section xml:id="machineset-creating-dedicated-instance_cpmso-using">
<title>Creating Dedicated Instances by using machine sets</title>
<simpara>You can run a machine that is backed by a Dedicated Instance by using Machine API integration. Set the <literal>tenancy</literal> field in your machine set YAML file to launch a Dedicated Instance on AWS.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Specify a dedicated tenancy under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  placement:
    tenancy: dedicated</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="cpmso-supported-features-azure_cpmso-using">
<title>Enabling Microsoft Azure features for control plane machines</title>
<simpara>You can enable Microsoft Azure features on control plane machines by changing the configuration of your control plane machine set. When you save an update to the control plane machine set, the Control Plane Machine Set Operator updates the control plane machines according to your configured update strategy.</simpara>
<section xml:id="private-clusters-setting-api-private_cpmso-using-azure">
<title>Restricting the API server to private</title>
<simpara>After you deploy a cluster to
Microsoft Azure,
you can reconfigure the API server to use only the private zone.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Have access to the web console as a user with <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web portal or console for your cloud provider, take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Locate and delete the appropriate load balancer component:</simpara>
<itemizedlist>
<listitem>
<simpara>For Azure, delete the <literal>api-internal</literal> rule for the load balancer.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>api.$clustername.$yourdomain</literal> DNS entry in the public zone.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the external load balancers by deleting the following lines in the control plane machine set custom resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    loadBalancers:
    - name: lk4pj-ext <co xml:id="CO140-1"/>
      type: network <co xml:id="CO140-2"/>
    - name: lk4pj-int
      type: network</programlisting>
<calloutlist>
<callout arearefs="CO140-1 CO140-2">
<para>Delete this line.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-azure-marketplace-subscribe_cpmso-using">
<title>Using the Azure Marketplace offering</title>
<simpara>You can create a machine set running on Azure that deploys machines that use the Azure Marketplace offering. To use this offering, you must first obtain the Azure Marketplace image. When obtaining your image, consider the following:</simpara>
<itemizedlist>
<listitem>
<simpara>While the images are the same, the Azure Marketplace publisher is different depending on your region. If you are located in North America, specify <literal>redhat</literal> as the publisher. If you are located in EMEA, specify <literal>redhat-limited</literal> as the publisher.</simpara>
</listitem>
<listitem>
<simpara>The offer includes a <literal>rh-ocp-worker</literal> SKU and a <literal>rh-ocp-worker-gen1</literal> SKU. The <literal>rh-ocp-worker</literal> SKU represents a Hyper-V generation version 2 VM image. The default instance types used in OpenShift Container Platform are version 2 compatible. If you plan to use an instance type that is only version 1 compatible, use the image associated with the <literal>rh-ocp-worker-gen1</literal> SKU. The <literal>rh-ocp-worker-gen1</literal> SKU represents a Hyper-V version 1 VM image.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Installing images with the Azure marketplace is not supported on clusters with 64-bit ARM instances.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Azure CLI client <literal>(az)</literal>.</simpara>
</listitem>
<listitem>
<simpara>Your Azure account is entitled for the offer and you have logged into this account with the Azure CLI client.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Display all of the available OpenShift Container Platform images by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  az vm image list --all --offer rh-ocp-worker --publisher redhat -o table</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Offer          Publisher       Sku                 Urn                                                             Version
-------------  --------------  ------------------  --------------------------------------------------------------  -----------------
rh-ocp-worker  RedHat          rh-ocp-worker       RedHat:rh-ocp-worker:rh-ocp-worker:413.92.2023101700            413.92.2023101700
rh-ocp-worker  RedHat          rh-ocp-worker-gen1  RedHat:rh-ocp-worker:rh-ocp-worker-gen1:413.92.2023101700       413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  az vm image list --all --offer rh-ocp-worker --publisher redhat-limited -o table</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Offer          Publisher       Sku                 Urn                                                                     Version
-------------  --------------  ------------------  --------------------------------------------------------------          -----------------
rh-ocp-worker  redhat-limited  rh-ocp-worker       redhat-limited:rh-ocp-worker:rh-ocp-worker:413.92.2023101700            413.92.2023101700
rh-ocp-worker  redhat-limited  rh-ocp-worker-gen1  redhat-limited:rh-ocp-worker:rh-ocp-worker-gen1:413.92.2023101700       413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<note>
<simpara>Regardless of the version of OpenShift Container Platform that you install, the correct version of the Azure Marketplace image to use is 4.13. If required, your VMs are automatically upgraded as part of the installation process.</simpara>
</note>
</listitem>
<listitem>
<simpara>Inspect the image for your offer by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image show --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image show --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Review the terms of the offer by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms show --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms show --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Accept the terms of the offering by running one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>North America:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms accept --urn redhat:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
<listitem>
<simpara>EMEA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ az vm image terms accept --urn redhat-limited:rh-ocp-worker:rh-ocp-worker:&lt;version&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Record the image details of your offer, specifically the values for <literal>publisher</literal>, <literal>offer</literal>, <literal>sku</literal>, and <literal>version</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the following parameters to the <literal>providerSpec</literal> section of your machine set YAML file using the image details for your offer:</simpara>
<formalpara>
<title>Sample <literal>providerSpec</literal> image values for Azure Marketplace machines</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    image:
      offer: rh-ocp-worker
      publisher: redhat
      resourceID: ""
      sku: rh-ocp-worker
      type: MarketplaceWithPlan
      version: 413.92.2023101700</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="machineset-azure-boot-diagnostics_cpmso-using">
<title>Enabling Azure boot diagnostics</title>
<simpara>You can enable boot diagnostics on Azure machines that your machine set creates.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure
cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>diagnostics</literal> configuration that is applicable to your storage type to the <literal>providerSpec</literal> field in your machine set YAML file:</simpara>
<itemizedlist>
<listitem>
<simpara>For an Azure Managed storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: AzureManaged <co xml:id="CO141-1"/></programlisting>
<calloutlist>
<callout arearefs="CO141-1">
<para>Specifies an Azure Managed storage account.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>For an Azure Unmanaged storage account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  diagnostics:
    boot:
      storageAccountType: CustomerManaged <co xml:id="CO142-1"/>
      customerManaged:
        storageAccountURI: https://&lt;storage-account&gt;.blob.core.windows.net <co xml:id="CO142-2"/></programlisting>
<calloutlist>
<callout arearefs="CO142-1">
<para>Specifies an Azure Unmanaged storage account.</para>
</callout>
<callout arearefs="CO142-2">
<para>Replace <literal>&lt;storage-account&gt;</literal> with the name of your storage account.</para>
</callout>
</calloutlist>
<note>
<simpara>Only the Azure Blob Storage data service is supported.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Boot diagnostics</emphasis> page for a machine deployed by the machine set, and verify that you can see the serial logs for the machine.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-ultra-disk_cpmso-using">
<title>Machine sets that deploy machines with ultra disks as data disks</title>
<simpara>You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-creating-azure-ultra-disk_cpmso-using">
<title>Creating machines with ultra disks by using machine sets</title>
<simpara>You can deploy machines with ultra disks on Azure by editing your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom secret in the <literal>openshift-machine-api</literal> namespace using the <literal>master</literal> data secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api \
get secret &lt;role&gt;-user-data \ <co xml:id="CO143-1"/>
--template='{{index .data.userData | base64decode}}' | jq &gt; userData.txt <co xml:id="CO143-2"/></programlisting>
<calloutlist>
<callout arearefs="CO143-1">
<para>Replace <literal>&lt;role&gt;</literal> with <literal>master</literal>.</para>
</callout>
<callout arearefs="CO143-2">
<para>Specify <literal>userData.txt</literal> as the name of the new custom secret.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>In a text editor, open the <literal>userData.txt</literal> file and locate the final <literal>}</literal> character in the file.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the immediately preceding line, add a <literal>,</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create a new line after the <literal>,</literal> and add the following configuration details:</simpara>
<programlisting language="json" linenumbering="unnumbered">"storage": {
  "disks": [ <co xml:id="CO144-1"/>
    {
      "device": "/dev/disk/azure/scsi1/lun0", <co xml:id="CO144-2"/>
      "partitions": [ <co xml:id="CO144-3"/>
        {
          "label": "lun0p1", <co xml:id="CO144-4"/>
          "sizeMiB": 1024, <co xml:id="CO144-5"/>
          "startMiB": 0
        }
      ]
    }
  ],
  "filesystems": [ <co xml:id="CO144-6"/>
    {
      "device": "/dev/disk/by-partlabel/lun0p1",
      "format": "xfs",
      "path": "/var/lib/lun0p1"
    }
  ]
},
"systemd": {
  "units": [ <co xml:id="CO144-7"/>
    {
      "contents": "[Unit]\nBefore=local-fs.target\n[Mount]\nWhere=/var/lib/lun0p1\nWhat=/dev/disk/by-partlabel/lun0p1\nOptions=defaults,pquota\n[Install]\nWantedBy=local-fs.target\n", <co xml:id="CO144-8"/>
      "enabled": true,
      "name": "var-lib-lun0p1.mount"
    }
  ]
}</programlisting>
<calloutlist>
<callout arearefs="CO144-1">
<para>The configuration details for the disk that you want to attach to a node as an ultra disk.</para>
</callout>
<callout arearefs="CO144-2">
<para>Specify the <literal>lun</literal> value that is defined in the <literal>dataDisks</literal> stanza of the machine set you are using. For example, if the machine set contains <literal>lun: 0</literal>, specify <literal>lun0</literal>. You can initialize multiple data disks by specifying multiple <literal>"disks"</literal> entries in this configuration file. If you specify multiple <literal>"disks"</literal> entries, ensure that the <literal>lun</literal> value for each matches the value in the machine set.</para>
</callout>
<callout arearefs="CO144-3">
<para>The configuration details for a new partition on the disk.</para>
</callout>
<callout arearefs="CO144-4">
<para>Specify a label for the partition. You might find it helpful to use hierarchical names, such as <literal>lun0p1</literal> for the first partition of <literal>lun0</literal>.</para>
</callout>
<callout arearefs="CO144-5">
<para>Specify the total size in MiB of the partition.</para>
</callout>
<callout arearefs="CO144-6">
<para>Specify the filesystem to use when formatting a partition. Use the partition label to specify the partition.</para>
</callout>
<callout arearefs="CO144-7">
<para>Specify a <literal>systemd</literal> unit to mount the partition at boot. Use the partition label to specify the partition. You can create multiple partitions by specifying multiple <literal>"partitions"</literal> entries in this configuration file. If you specify multiple <literal>"partitions"</literal> entries, you must specify a <literal>systemd</literal> unit for each.</para>
</callout>
<callout arearefs="CO144-8">
<para>For <literal>Where</literal>, specify the value of <literal>storage.filesystems.path</literal>. For <literal>What</literal>, specify the value of <literal>storage.filesystems.device</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Extract the disabling template value to a file called <literal>disableTemplating.txt</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api get secret &lt;role&gt;-user-data \ <co xml:id="CO145-1"/>
--template='{{index .data.disableTemplating | base64decode}}' | jq &gt; disableTemplating.txt</programlisting>
<calloutlist>
<callout arearefs="CO145-1">
<para>Replace <literal>&lt;role&gt;</literal> with <literal>master</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Combine the <literal>userData.txt</literal> file and <literal>disableTemplating.txt</literal> file to create a data secret file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api create secret generic &lt;role&gt;-user-data-x5 \ <co xml:id="CO146-1"/>
--from-file=userData=userData.txt \
--from-file=disableTemplating=disableTemplating.txt</programlisting>
<calloutlist>
<callout arearefs="CO146-1">
<para>For <literal>&lt;role&gt;-user-data-x5</literal>, specify the name of the secret. Replace <literal>&lt;role&gt;</literal> with <literal>master</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit your control plane machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc --namespace openshift-machine-api edit controlplanemachineset.machine.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the following lines in the positions indicated:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: ControlPlaneMachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <co xml:id="CO147-1"/>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <co xml:id="CO147-2"/>
          dataDisks: <co xml:id="CO147-3"/>
          - nameSuffix: ultrassd
            lun: 0
            diskSizeGB: 4
            deletionPolicy: Delete
            cachingType: None
            managedDisk:
              storageAccountType: UltraSSD_LRS
          userDataSecret:
            name: &lt;role&gt;-user-data-x5 <co xml:id="CO147-4"/></programlisting>
<calloutlist>
<callout arearefs="CO147-1">
<para>Specify a label to use to select a node that is created by this machine set. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO147-2 CO147-3">
<para>These lines enable the use of ultra disks. For <literal>dataDisks</literal>, include the entire stanza.</para>
</callout>
<callout arearefs="CO147-4">
<para>Specify the user data secret created earlier. Replace <literal>&lt;role&gt;</literal> with <literal>master</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
<itemizedlist>
<listitem>
<simpara>For clusters that use the default <literal>RollingUpdate</literal> update strategy, the Operator automatically propagates the changes to your control plane configuration.</simpara>
</listitem>
<listitem>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, you must replace your control plane machines manually.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Validate that the machines are created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines</programlisting>
<simpara>The machines should be in the <literal>Running</literal> state.</simpara>
</listitem>
<listitem>
<simpara>For a machine that is running and has a node attached, validate the partition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</programlisting>
<simpara>In this command, <literal>oc debug node/&lt;node-name&gt;</literal> starts a debugging shell on the node <literal>&lt;node-name&gt;</literal> and passes a command with <literal>--</literal>. The passed command <literal>chroot /host</literal> provides access to the underlying host OS binaries, and <literal>lsblk</literal> shows the block devices that are attached to the host OS machine.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>To use an ultra disk on the control plane, reconfigure your workload to use the control plane&#8217;s ultra disk mount point.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-troubleshooting-azure-ultra-disk_cpmso-using">
<title>Troubleshooting resources for machine sets that enable ultra disks</title>
<simpara>Use the information in this section to understand and recover from issues you might encounter.</simpara>
<section xml:id="ts-mapi-attach-misconfigure_cpmso-using">
<title>Incorrect ultra disk configuration</title>
<simpara>If an incorrect configuration of the <literal>ultraSSDCapability</literal> parameter is specified in the machine set, the machine provisioning fails.</simpara>
<simpara>For example, if the <literal>ultraSSDCapability</literal> parameter is set to <literal>Disabled</literal>, but an ultra disk is specified in the <literal>dataDisks</literal> parameter, the following error message appears:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, verify that your machine set configuration is correct.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ts-mapi-attach-unsupported_cpmso-using">
<title>Unsupported disk parameters</title>
<simpara>If a region, availability zone, or instance size that is not compatible with ultra disks is specified in the machine set, the machine provisioning fails. Check the logs for the following error message:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">failed to create vm &lt;machine_name&gt;: failure sending request for machine &lt;machine_name&gt;: cannot create vm: compute.VirtualMachinesClient#CreateOrUpdate: Failure sending request: StatusCode=400 -- Original Error: Code="BadRequest" Message="Storage Account type 'UltraSSD_LRS' is not supported &lt;more_information_about_why&gt;."</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, verify that you are using this feature in a supported environment and that your machine set configuration is correct.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ts-mapi-delete_cpmso-using">
<title>Unable to delete disks</title>
<simpara>If the deletion of ultra disks as data disks is not working as expected, the machines are deleted and the data disks are orphaned. You must delete the orphaned disks manually if desired.</simpara>
</section>
</section>
</section>
<section xml:id="machineset-enabling-customer-managed-encryption-azure_cpmso-using">
<title>Enabling customer-managed encryption keys for a machine set</title>
<simpara>You can supply an encryption key to Azure to encrypt data on managed disks at rest. You can enable server-side encryption with customer-managed keys by using the Machine API.</simpara>
<simpara>An Azure Key Vault, a disk encryption set, and an encryption key are required to use a customer-managed key. The disk encryption set must be in a resource group where the Cloud Credential Operator (CCO) has granted permissions. If not, an additional reader role is required to be granted on the disk encryption set.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-azure-key-vault-instance">Create an Azure Key Vault instance</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#create-an-instance-of-a-diskencryptionset">Create an instance of a disk encryption set</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/aks/azure-disk-customer-managed-keys#grant-the-diskencryptionset-access-to-key-vault">Grant the disk encryption set access to key vault</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Configure the disk encryption set under the <literal>providerSpec</literal> field in your machine set YAML file. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    osDisk:
      diskSizeGB: 128
      managedDisk:
        diskEncryptionSet:
          id: /subscriptions/&lt;subscription_id&gt;/resourceGroups/&lt;resource_group_name&gt;/providers/Microsoft.Compute/diskEncryptionSets/&lt;disk_encryption_set_name&gt;
        storageAccountType: Premium_LRS</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disk-encryption#customer-managed-keys">Azure documentation about customer-managed keys</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-trusted-launch_cpmso-using">
<title>Configuring trusted launch for Azure virtual machines by using machine sets</title>
<important>
<simpara>Using trusted launch for Azure virtual machines is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>OpenShift Container Platform 4.14 supports trusted launch for Azure virtual machines (VMs). By editing the machine set YAML file, you can configure the trusted launch options that a machine set uses for machines that it deploys. For example, you can configure these machines to use UEFI security features such as Secure Boot or a dedicated virtual Trusted Platform Module (vTPM) instance.</simpara>
<note>
<simpara>Some feature combinations result in an invalid configuration.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>UEFI feature combination compatibility</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Secure Boot<superscript>[1]</superscript></entry>
<entry align="left" valign="top">vTPM<superscript>[2]</superscript></entry>
<entry align="left" valign="top">Valid configuration</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>Omitted</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Using the <literal>secureBoot</literal> field.</simpara>
</listitem>
<listitem>
<simpara>Using the <literal>virtualizedTrustedPlatformModule</literal> field.</simpara>
</listitem>
</orderedlist>
</para>
<simpara>For more information about related features and functionality, see the Microsoft Azure documentation about <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/trusted-launch">Trusted launch for Azure virtual machines</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field to provide a valid configuration:</simpara>
<formalpara>
<title>Sample valid configuration with UEFI Secure Boot and vTPM enabled</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          securityProfile:
            settings:
              securityType: TrustedLaunch <co xml:id="CO148-1"/>
              trustedLaunch:
                uefiSettings: <co xml:id="CO148-2"/>
                  secureBoot: Enabled <co xml:id="CO148-3"/>
                  virtualizedTrustedPlatformModule: Enabled <co xml:id="CO148-4"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO148-1">
<para>Enables the use of trusted launch for Azure virtual machines. This value is required for all valid configurations.</para>
</callout>
<callout arearefs="CO148-2">
<para>Specifies which UEFI security features to use. This section is required for all valid configurations.</para>
</callout>
<callout arearefs="CO148-3">
<para>Enables UEFI Secure Boot.</para>
</callout>
<callout arearefs="CO148-4">
<para>Enables the use of a vTPM.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Azure portal, review the details for a machine deployed by the machine set and verify that the trusted launch options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-confidential-vms_cpmso-using">
<title>Configuring Azure confidential virtual machines by using machine sets</title>
<important>
<simpara>Using Azure confidential virtual machines is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>OpenShift Container Platform 4.14 supports Azure confidential virtual machines (VMs).</simpara>
<note>
<simpara>Confidential VMs are currently not supported on 64-bit ARM architectures.</simpara>
</note>
<simpara>By editing the machine set YAML file, you can configure the confidential VM options that a machine set uses for machines that it deploys. For example, you can configure these machines to use UEFI security features such as Secure Boot or a dedicated virtual Trusted Platform Module (vTPM) instance.</simpara>
<warning>
<simpara>Not all instance types support confidential VMs. Do not change the instance type for a control plane machine set that is configured to use confidential VMs to a type that is incompatible. Using an incompatible instance type can cause your cluster to become unstable.</simpara>
</warning>
<simpara>For more information about related features and functionality, see the Microsoft Azure documentation about <link xlink:href="https://learn.microsoft.com/en-us/azure/confidential-computing/confidential-vm-overview">Confidential virtual machines</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<formalpara>
<title>Sample configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          osDisk:
            # ...
            managedDisk:
              securityProfile: <co xml:id="CO149-1"/>
                securityEncryptionType: VMGuestStateOnly <co xml:id="CO149-2"/>
            # ...
          securityProfile: <co xml:id="CO149-3"/>
            settings:
                securityType: ConfidentialVM <co xml:id="CO149-4"/>
                confidentialVM:
                  uefiSettings: <co xml:id="CO149-5"/>
                    secureBoot: Disabled <co xml:id="CO149-6"/>
                    virtualizedTrustedPlatformModule: Enabled <co xml:id="CO149-7"/>
          vmSize: Standard_DC16ads_v5 <co xml:id="CO149-8"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO149-1">
<para>Specifies security profile settings for the managed disk when using a confidential VM.</para>
</callout>
<callout arearefs="CO149-2">
<para>Enables encryption of the Azure VM Guest State (VMGS) blob. This setting requires the use of vTPM.</para>
</callout>
<callout arearefs="CO149-3">
<para>Specifies security profile settings for the confidential VM.</para>
</callout>
<callout arearefs="CO149-4">
<para>Enables the use of confidential VMs. This value is required for all valid configurations.</para>
</callout>
<callout arearefs="CO149-5">
<para>Specifies which UEFI security features to use. This section is required for all valid configurations.</para>
</callout>
<callout arearefs="CO149-6">
<para>Disables UEFI Secure Boot.</para>
</callout>
<callout arearefs="CO149-7">
<para>Enables the use of a vTPM.</para>
</callout>
<callout arearefs="CO149-8">
<para>Specifies an instance type that supports confidential VMs.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Azure portal, review the details for a machine deployed by the machine set and verify that the confidential VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-accelerated-networking_cpmso-using">
<title>Accelerated Networking for Microsoft Azure VMs</title>
<simpara>Accelerated Networking uses single root I/O virtualization (SR-IOV) to provide Microsoft Azure VMs with a more direct path to the switch. This enhances network performance. This feature can be enabled
after installation.</simpara>
<section xml:id="machineset-azure-accelerated-networking-limits_cpmso-using">
<title>Limitations</title>
<simpara>Consider the following limitations when deciding whether to use Accelerated Networking:</simpara>
<itemizedlist>
<listitem>
<simpara>Accelerated Networking is only supported on clusters where the Machine API is operational.</simpara>
</listitem>
<listitem>
<simpara></simpara>
<simpara>Accelerated Networking requires an Azure VM size that includes at least four vCPUs. To satisfy this requirement, you can change the value of <literal>vmSize</literal> in your machine set. For information about Azure VM sizes, see <link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/sizes">Microsoft Azure documentation</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-azure-enabling-accelerated-networking-existing_cpmso-using">
<title>Enabling Accelerated Networking on an existing Microsoft Azure cluster</title>
<simpara>You can enable Accelerated Networking on Azure by adding <literal>acceleratedNetworking</literal> to your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster where the Machine API is operational.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the following to the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    acceleratedNetworking: true <co xml:id="CO150-1"/>
    vmSize: &lt;azure-vm-size&gt; <co xml:id="CO150-2"/></programlisting>
<calloutlist>
<callout arearefs="CO150-1">
<para>This line enables Accelerated Networking.</para>
</callout>
<callout arearefs="CO150-2">
<para>Specify an Azure VM size that includes at least four vCPUs. For information about VM sizes, see <link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/sizes">Microsoft Azure documentation</link>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Microsoft Azure portal, review the <emphasis role="strong">Networking</emphasis> settings page for a machine provisioned by the machine set, and verify that the <literal>Accelerated networking</literal> field is set to <literal>Enabled</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="cpmso-supported-features-gcp_cpmso-using">
<title>Enabling Google Cloud Platform features for control plane machines</title>
<simpara>You can enable Google Cloud Platform (GCP) features on control plane machines by changing the configuration of your control plane machine set. When you save an update to the control plane machine set, the Control Plane Machine Set Operator updates the control plane machines according to your configured update strategy.</simpara>
<section xml:id="machineset-gcp-pd-disk-types_cpmso-using">
<title>Configuring persistent disk types by using machine sets</title>
<simpara>You can configure the type of persistent disk that a machine set deploys machines on by editing the machine set YAML file.</simpara>
<simpara>For more information about persistent disk types, compatibility, regional availability, and limitations, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/compute/docs/disks#pdspecs">persistent disks</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          disks:
            type: &lt;pd-disk-type&gt; <co xml:id="CO151-1"/></programlisting>
<calloutlist>
<callout arearefs="CO151-1">
<para>Specify the disk persistent type. Valid values are <literal>pd-ssd</literal>, <literal>pd-standard</literal>, and <literal>pd-balanced</literal>. The default value is <literal>pd-standard</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Using the Google Cloud console, review the details for a machine deployed by the machine set and verify that the <literal>Type</literal> field matches the configured disk type.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-confidential-vm_cpmso-using">
<title>Configuring Confidential VM by using machine sets</title>
<simpara>By editing the machine set YAML file, you can configure the Confidential VM options that a machine set uses for machines that it deploys.</simpara>
<simpara>For more information about Confidential VM features, functions, and compatibility, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/confidential-computing/confidential-vm/docs/about-cvm#confidential-vm">Confidential VM</link>.</simpara>
<note>
<simpara>Confidential VMs are currently not supported on 64-bit ARM architectures.</simpara>
</note>
<important>
<simpara>OpenShift Container Platform 4.14 does not support some Confidential Compute features, such as Confidential VMs with AMD Secure Encrypted Virtualization Secure Nested Paging (SEV-SNP).</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          confidentialCompute: Enabled <co xml:id="CO152-1"/>
          onHostMaintenance: Terminate <co xml:id="CO152-2"/>
          machineType: n2d-standard-8 <co xml:id="CO152-3"/>
...</programlisting>
<calloutlist>
<callout arearefs="CO152-1">
<para>Specify whether Confidential VM is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
<callout arearefs="CO152-2">
<para>Specify the behavior of the VM during a host maintenance event, such as a hardware or software update. For a machine that uses Confidential VM, this value must be set to <literal>Terminate</literal>, which stops the VM. Confidential VM does not support live VM migration.</para>
</callout>
<callout arearefs="CO152-3">
<para>Specify a machine type that supports Confidential VM. Confidential VM supports the N2D and C2D series of machine types.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>On the Google Cloud console, review the details for a machine deployed by the machine set and verify that the Confidential VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-shielded-vms_cpmso-using">
<title>Configuring Shielded VM options by using machine sets</title>
<simpara>By editing the machine set YAML file, you can configure the Shielded VM options that a machine set uses for machines that it deploys.</simpara>
<simpara>For more information about Shielded VM features and functionality, see the GCP Compute Engine documentation about <link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm">Shielded VM</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In a text editor, open the YAML file for an existing machine set or create a new one.</simpara>
</listitem>
<listitem>
<simpara>Edit the following section under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
# ...
spec:
  template:
    spec:
      providerSpec:
        value:
          shieldedInstanceConfig: <co xml:id="CO153-1"/>
            integrityMonitoring: Enabled <co xml:id="CO153-2"/>
            secureBoot: Disabled <co xml:id="CO153-3"/>
            virtualizedTrustedPlatformModule: Enabled <co xml:id="CO153-4"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO153-1">
<para>In this section, specify any Shielded VM options that you want.</para>
</callout>
<callout arearefs="CO153-2">
<para>Specify whether integrity monitoring is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
<note>
<simpara>When integrity monitoring is enabled, you must not disable virtual trusted platform module (vTPM).</simpara>
</note>
</callout>
<callout arearefs="CO153-3">
<para>Specify whether UEFI Secure Boot is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
<callout arearefs="CO153-4">
<para>Specify whether vTPM is enabled. Valid values are <literal>Disabled</literal> or <literal>Enabled</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Using the Google Cloud console, review the details for a machine deployed by the machine set and verify that the Shielded VM options match the values that you configured.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm">What is Shielded VM?</link></simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot">Secure Boot</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#vtpm">Virtual Trusted Platform Module (vTPM)</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#integrity-monitoring">Integrity monitoring</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-gcp-enabling-customer-managed-encryption_cpmso-using">
<title>Enabling customer-managed encryption keys for a machine set</title>
<simpara>Google Cloud Platform (GCP) Compute Engine allows users to supply an encryption key to encrypt data on disks at rest. The key is used to encrypt the data encryption key, not to encrypt the customer&#8217;s data. By default, Compute Engine encrypts this data by using Compute Engine keys.</simpara>
<simpara>You can enable encryption with a customer-managed key in clusters that use the Machine API. You must first <link xlink:href="https://cloud.google.com/compute/docs/disks/customer-managed-encryption#before_you_begin">create a KMS key</link> and assign the correct permissions to a service account. The KMS key name, key ring name, and location are required to allow a service account to use your key.</simpara>
<note>
<simpara>If you do not want to use a dedicated service account for the KMS encryption, the Compute Engine default service account is used instead. You must grant the default service account permission to access the keys if you do not use a dedicated service account. The Compute Engine default service account name follows the <literal>service-&lt;project_number&gt;@compute-system.iam.gserviceaccount.com</literal> pattern.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To allow a specific service account to use your KMS key and to grant the service account the correct IAM role, run the following command with your KMS key name, key ring name, and location:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ gcloud kms keys add-iam-policy-binding &lt;key_name&gt; \
  --keyring &lt;key_ring_name&gt; \
  --location &lt;key_ring_location&gt; \
  --member "serviceAccount:service-&lt;project_number&gt;@compute-system.iam.gserviceaccount.com” \
  --role roles/cloudkms.cryptoKeyEncrypterDecrypter</programlisting>
</listitem>
<listitem>
<simpara>Configure the encryption key under the <literal>providerSpec</literal> field in your machine set YAML file. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1
kind: ControlPlaneMachineSet
...
spec:
  template:
    spec:
      providerSpec:
        value:
          disks:
          - type:
            encryptionKey:
              kmsKey:
                name: machine-encryption-key <co xml:id="CO154-1"/>
                keyRing: openshift-encrpytion-ring <co xml:id="CO154-2"/>
                location: global <co xml:id="CO154-3"/>
                projectID: openshift-gcp-project <co xml:id="CO154-4"/>
              kmsKeyServiceAccount: openshift-service-account@openshift-gcp-project.iam.gserviceaccount.com <co xml:id="CO154-5"/></programlisting>
<calloutlist>
<callout arearefs="CO154-1">
<para>The name of the customer-managed encryption key that is used for the disk encryption.</para>
</callout>
<callout arearefs="CO154-2">
<para>The name of the KMS key ring that the KMS key belongs to.</para>
</callout>
<callout arearefs="CO154-3">
<para>The GCP location in which the KMS key ring exists.</para>
</callout>
<callout arearefs="CO154-4">
<para>Optional: The ID of the project in which the KMS key ring exists. If a project ID is not set, the machine set <literal>projectID</literal> in which the machine set was created is used.</para>
</callout>
<callout arearefs="CO154-5">
<para>Optional: The service account that is used for the encryption request for the given KMS key. If a service account is not set, the Compute Engine default service account is used.</para>
</callout>
</calloutlist>
<simpara>When a new machine is created by using the updated <literal>providerSpec</literal> object configuration, the disk encryption key is encrypted with the KMS key.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cpmso-supported-features-openstack_cpmso-using">
<title>Updating the configuration for RHOSP control plane machines</title>
<simpara>You can configure Red Hat OpenStack Platform (RHOSP) control plane machines by changing the configuration of your control plane machine set. When you save an update to the control plane machine set, the Control Plane Machine Set Operator updates the control plane machines according to your configured update strategy.</simpara>
<section xml:id="cpms-changing-openstack-flavor-type_cpmso-using">
<title>Changing the RHOSP compute flavor by using a control plane machine set</title>
<simpara>You can change the Red Hat OpenStack Platform (RHOSP) compute service (Nova) flavor that your control plane machines use by updating the specification in the control plane machine set custom resource.</simpara>
<simpara>In RHOSP, flavors define the compute, memory, and storage capacity of computing instances. By increasing or decreasing the flavor size, you can scale your control plane vertically.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your RHOSP cluster uses a control plane machine set.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the following line under the <literal>providerSpec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
# ...
    flavor: m1.xlarge <co xml:id="CO155-1"/></programlisting>
<calloutlist>
<callout arearefs="CO155-1">
<para>Specify a RHOSP flavor type that has the same base as the existing selection. For example, you can change <literal>m6i.xlarge</literal> to <literal>m6i.2xlarge</literal> or <literal>m6i.4xlarge</literal>. You can choose larger or smaller flavors depending on your vertical scaling needs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save your changes.</simpara>
</listitem>
</orderedlist>
<simpara>After you save your changes, machines are replaced with ones that use the flavor you chose.</simpara>
</section>
</section>
</section>
<section xml:id="cpmso-resiliency">
<title>Control plane resiliency and recovery</title>

<simpara>You can use the control plane machine set to improve the resiliency of the control plane for your OpenShift Container Platform cluster.</simpara>
<section xml:id="cpmso-failure-domains_cpmso-resiliency">
<title>High availability and fault tolerance with failure domains</title>
<simpara>When possible, the control plane machine set spreads the control plane machines across multiple failure domains. This configuration provides high availability and fault tolerance within the control plane. This strategy can help protect the control plane when issues arise within the infrastructure provider.</simpara>
<section xml:id="cpmso-failure-domains-provider_cpmso-resiliency">
<title>Failure domain platform support and configuration</title>
<simpara>The control plane machine set concept of a failure domain is analogous to existing concepts on cloud providers. Not all platforms support the use of failure domains.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Failure domain support matrix</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="middle">Cloud provider</entry>
<entry align="center" valign="middle">Support for failure domains</entry>
<entry align="center" valign="middle">Provider nomenclature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Amazon Web Services (AWS)</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara><link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones">Availability Zone (AZ)</link></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Google Cloud Platform (GCP)</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara><link xlink:href="https://cloud.google.com/compute/docs/regions-zones">zone</link></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Nutanix</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>Not applicable <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Microsoft Azure</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara><link xlink:href="https://learn.microsoft.com/en-us/azure/azure-web-pubsub/concept-availability-zones">Azure availability zone</link></simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>VMware vSphere</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>Not applicable</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Red Hat OpenStack Platform (RHOSP)</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara><link xlink:href="https://docs.openstack.org/nova/2023.2/admin/availability-zones.html">OpenStack Nova availability zones</link> and <link xlink:href="https://docs.openstack.org/cinder/2023.2/admin/availability-zone-type.html">OpenStack Cinder availability zones</link></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Nutanix has a failure domain concept, but OpenShift Container Platform 4.14 does not include support for this feature.</simpara>
</listitem>
</orderedlist>
</para>
<simpara>The failure domain configuration in the control plane machine set custom resource (CR) is platform-specific. For more information about failure domain parameters in the CR, see the sample failure domain configuration for your provider.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-yaml-failure-domain-aws_cpmso-configuration">Sample Amazon Web Services failure domain configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-yaml-failure-domain-gcp_cpmso-configuration">Sample Google Cloud Platform failure domain configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-yaml-failure-domain-azure_cpmso-configuration">Sample Microsoft Azure failure domain configuration</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-yaml-failure-domain-openstack_cpmso-configuration">Sample Red Hat OpenStack Platform (RHOSP) failure domain configuration</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-failure-domains-balancing_cpmso-resiliency">
<title>Balancing control plane machines</title>
<simpara>The control plane machine set balances control plane machines across the failure domains that are specified in the custom resource (CR).</simpara>
<simpara>When possible, the control plane machine set uses each failure domain equally to ensure appropriate fault tolerance. If there are fewer failure domains than control plane machines, failure domains are selected for reuse alphabetically by name. For clusters with no failure domains specified, all control plane machines are placed within a single failure domain.</simpara>
<simpara>Some changes to the failure domain configuration cause the control plane machine set to rebalance the control plane machines. For example, if you add failure domains to a cluster with fewer failure domains than control plane machines, the control plane machine set rebalances the machines across all available failure domains.</simpara>
</section>
</section>
<section xml:id="cpmso-control-plane-recovery_cpmso-resiliency">
<title>Recovery of failed control plane machines</title>
<simpara>The Control Plane Machine Set Operator automates the recovery of control plane machines. When a control plane machine is deleted, the Operator creates a replacement with the configuration that is specified in the <literal>ControlPlaneMachineSet</literal> custom resource (CR).</simpara>
<simpara>For clusters that use control plane machine sets, you can configure a machine health check. The machine health check deletes unhealthy control plane machines so that they are replaced.</simpara>
<important>
<simpara>If you configure a <literal>MachineHealthCheck</literal> resource for the control plane, set the value of <literal>maxUnhealthy</literal> to <literal>1</literal>.</simpara>
<simpara>This configuration ensures that the machine health check takes no action when multiple control plane machines appear to be unhealthy. Multiple unhealthy control plane machines can indicate that the etcd cluster is degraded or that a scaling operation to replace a failed machine is in progress.</simpara>
<simpara>If the etcd cluster is degraded, manual intervention might be required. If a scaling operation is in progress, the machine health check should allow it to finish.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="deploying-machine-health-checks">Deploying machine health checks</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-lifecycle-hook-deletion-etcd_cpmso-resiliency">
<title>Quorum protection with machine lifecycle hooks</title>
<simpara>For OpenShift Container Platform clusters that use the Machine API Operator, the etcd Operator uses lifecycle hooks for the machine deletion phase to implement a quorum protection mechanism.</simpara>
<simpara>By using a <literal>preDrain</literal> lifecycle hook, the etcd Operator can control when the pods on a control plane machine are drained and removed. To protect etcd quorum, the etcd Operator prevents the removal of an etcd member until it migrates that member onto a new node within the cluster.</simpara>
<simpara>This mechanism allows the etcd Operator precise control over the members of the etcd quorum and allows the Machine API Operator to safely create and remove control plane machines without specific operational knowledge of the etcd cluster.</simpara>
<section xml:id="machine-lifecycle-hook-deletion-etcd-order_cpmso-resiliency">
<title>Control plane deletion with quorum protection processing order</title>
<simpara>When a control plane machine is replaced on a cluster that uses a control plane machine set, the cluster temporarily has four control plane machines. When the fourth control plane node joins the cluster, the etcd Operator starts a new etcd member on the replacement node. When the etcd Operator observes that the old control plane machine is marked for deletion, it stops the etcd member on the old node and promotes the replacement etcd member to join the quorum of the cluster.</simpara>
<simpara>The control plane machine <literal>Deleting</literal> phase proceeds in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A control plane machine is slated for deletion.</simpara>
</listitem>
<listitem>
<simpara>The control plane machine enters the <literal>Deleting</literal> phase.</simpara>
</listitem>
<listitem>
<simpara>To satisfy the <literal>preDrain</literal> lifecycle hook, the etcd Operator takes the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>The etcd Operator waits until a fourth control plane machine is added to the cluster as an etcd member. This new etcd member has a state of <literal>Running</literal> but not <literal>ready</literal> until it receives the full database update from the etcd leader.</simpara>
</listitem>
<listitem>
<simpara>When the new etcd member receives the full database update, the etcd Operator promotes the new etcd member to a voting member and removes the old etcd member from the cluster.</simpara>
</listitem>
</orderedlist>
<simpara>After this transition is complete, it is safe for the old etcd pod and its data to be removed, so the <literal>preDrain</literal> lifecycle hook is removed.</simpara>
</listitem>
<listitem>
<simpara>The control plane machine status condition <literal>Drainable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller attempts to drain the node that is backed by the control plane machine.</simpara>
<itemizedlist>
<listitem>
<simpara>If draining fails, <literal>Drained</literal> is set to <literal>False</literal> and the machine controller attempts to drain the node again.</simpara>
</listitem>
<listitem>
<simpara>If draining succeeds, <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The control plane machine status condition <literal>Drained</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>If no other Operators have added a <literal>preTerminate</literal> lifecycle hook, the control plane machine status condition <literal>Terminable</literal> is set to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>The machine controller removes the instance from the infrastructure provider.</simpara>
</listitem>
<listitem>
<simpara>The machine controller deletes the <literal>Node</literal> object.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>YAML snippet demonstrating the etcd quorum protection <literal>preDrain</literal> lifecycle hook</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: Machine
metadata:
  ...
spec:
  lifecycleHooks:
    preDrain:
    - name: EtcdQuorumOperator <co xml:id="CO156-1"/>
      owner: clusteroperator/etcd <co xml:id="CO156-2"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO156-1">
<para>The name of the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
<callout arearefs="CO156-2">
<para>The hook-implementing controller that manages the <literal>preDrain</literal> lifecycle hook.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="machine-lifecycle-hook-deletion_deleting-machine">Lifecycle hooks for the machine deletion phase</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="cpmso-troubleshooting">
<title>Troubleshooting the control plane machine set</title>

<simpara>Use the information in this section to understand and recover from issues you might encounter.</simpara>
<section xml:id="cpmso-checking-status_cpmso-troubleshooting">
<title>Checking the control plane machine set custom resource state</title>
<simpara>You can verify the existence and state of the <literal>ControlPlaneMachineSet</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Determine the state of the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get controlplanemachineset.machine.openshift.io cluster \
  --namespace openshift-machine-api</programlisting>
<itemizedlist>
<listitem>
<simpara>A result of <literal>Active</literal> indicates that the <literal>ControlPlaneMachineSet</literal> CR exists and is activated. No administrator action is required.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>Inactive</literal> indicates that a <literal>ControlPlaneMachineSet</literal> CR exists but is not activated.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>NotFound</literal> indicates that there is no existing <literal>ControlPlaneMachineSet</literal> CR.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<formalpara>
<title>Next steps</title>
<para>To use the control plane machine set, you must ensure that a <literal>ControlPlaneMachineSet</literal> CR with the correct settings for your cluster exists.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>If your cluster has an existing CR, you must verify that the configuration in the CR is correct for your cluster.</simpara>
</listitem>
<listitem>
<simpara>If your cluster does not have an existing CR, you must create one with the correct configuration for your cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-activating_cpmso-getting-started">Activating the control plane machine set custom resource</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-creating-cr_cpmso-getting-started">Creating a control plane machine set custom resource</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-ts-ilb-missing_cpmso-troubleshooting">
<title>Adding a missing Azure internal load balancer</title>
<simpara>The <literal>internalLoadBalancer</literal> parameter is required in both the <literal>ControlPlaneMachineSet</literal> and control plane <literal>Machine</literal> custom resources (CRs) for Azure. If this parameter is not preconfigured on your cluster, you must add it to both CRs.</simpara>
<simpara>For more information about where this parameter is located in the Azure provider specification, see the sample Azure provider specification. The placement in the control plane <literal>Machine</literal> CR is similar.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the control plane machines in your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines \
  -l machine.openshift.io/cluster-api-machine-role==master \
  -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>For each control plane machine, edit the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machine &lt;control_plane_machine_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>internalLoadBalancer</literal> parameter with the correct details for your cluster and save your changes.</simpara>
</listitem>
<listitem>
<simpara>Edit your control plane machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit controlplanemachineset.machine.openshift.io cluster \
  -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>internalLoadBalancer</literal> parameter with the correct details for your cluster and save your changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>For clusters that use the default <literal>RollingUpdate</literal> update strategy, the Operator automatically propagates the changes to your control plane configuration.</simpara>
</listitem>
<listitem>
<simpara>For clusters that are configured to use the <literal>OnDelete</literal> update strategy, you must replace your control plane machines manually.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-yaml-provider-spec-azure_cpmso-configuration">Sample Azure provider specification</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-ts-etcd-degraded_cpmso-troubleshooting">
<title>Recovering a degraded etcd Operator</title>
<simpara>Certain situations can cause the etcd Operator to become degraded.</simpara>
<simpara>For example, while performing remediation, the machine health check might delete a control plane machine that is hosting etcd. If the etcd member is not reachable at that time, the etcd Operator becomes degraded.</simpara>
<simpara>When the etcd Operator is degraded, manual intervention is required to force the Operator to remove the failed member and restore the cluster state.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the control plane machines in your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines \
  -l machine.openshift.io/cluster-api-machine-role==master \
  -n openshift-machine-api \
  -o wide</programlisting>
<simpara>Any of the following conditions might indicate a failed control plane machine:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>STATE</literal> value is <literal>stopped</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>PHASE</literal> value is <literal>Failed</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>PHASE</literal> value is <literal>Deleting</literal> for more than ten minutes.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Before continuing, ensure that your cluster has two healthy control plane machines. Performing the actions in this procedure on more than one control plane machine risks losing etcd quorum and can cause data loss.</simpara>
<simpara>If you have lost the majority of your control plane hosts, leading to etcd quorum loss, then you must follow the disaster recovery procedure "Restoring to a previous cluster state" instead of this procedure.</simpara>
</important>
</listitem>
<listitem>
<simpara>Edit the machine CR for the failed control plane machine by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machine &lt;control_plane_machine_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Remove the contents of the <literal>lifecycleHooks</literal> parameter from the failed control plane machine and save your changes.</simpara>
<simpara>The etcd Operator removes the failed machine from the cluster and can then safely add new etcd members.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/backup_and_restore/#dr-restoring-cluster-state">Restoring to a previous cluster state</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-troubleshooting-shiftstack-upgrade_cpmso-troubleshooting">
<title>Upgrading clusters that run on RHOSP</title>
<simpara>For clusters that run on Red Hat OpenStack Platform (RHOSP) that were created with OpenShift Container Platform 4.13 or earlier, you might have to perform post-upgrade tasks before you can use control plane machine sets.</simpara>
<section xml:id="cpmso-openstack-ts-root-volume-azs_cpmso-troubleshooting">
<title>Configuring RHOSP clusters that have machines with root volume availability zones after an upgrade</title>
<simpara>For some clusters that run on Red Hat OpenStack Platform (RHOSP) that you upgrade, you must manually update machine resources before you can use control plane machine sets if the following configurations are true:</simpara>
<itemizedlist>
<listitem>
<simpara>The upgraded cluster was created with OpenShift Container Platform 4.13 or earlier.</simpara>
</listitem>
<listitem>
<simpara>The cluster infrastructure is installer-provisioned.</simpara>
</listitem>
<listitem>
<simpara>Machines were distributed across multiple availability zones.</simpara>
</listitem>
<listitem>
<simpara>Machines were configured to use root volumes for which block storage availability zones were not defined.</simpara>
</listitem>
</itemizedlist>
<simpara>To understand why this procedure is necessary, see <link xlink:href="https://access.redhat.com/solutions/7013893">Solution #7024383</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>For all control plane machines, edit the provider spec for all control plane machines that match the environment. For example, to edit the machine <literal>master-0</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machine/&lt;cluster_id&gt;-master-0 -n openshift-machine-api</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;cluster_id&gt;</literal></term>
<listitem>
<simpara>Specifies the ID of the upgraded cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>In the provider spec, set the value of the property <literal>rootVolume.availabilityZone</literal> to the volume of the availability zone you want to use.</simpara>
<formalpara>
<title>An example RHOSP provider spec</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1alpha1
    availabilityZone: az0
      cloudName: openstack
    cloudsSecret:
      name: openstack-cloud-credentials
      namespace: openshift-machine-api
    flavor: m1.xlarge
    image: rhcos-4.14
    kind: OpenstackProviderSpec
    metadata:
      creationTimestamp: null
    networks:
    - filter: {}
      subnets:
      - filter:
          name: refarch-lv7q9-nodes
          tags: openshiftClusterID=refarch-lv7q9
    rootVolume:
        availabilityZone: nova <co xml:id="CO157-1"/>
        diskSize: 30
        sourceUUID: rhcos-4.12
        volumeType: fast-0
    securityGroups:
    - filter: {}
      name: refarch-lv7q9-master
    serverGroupName: refarch-lv7q9-master
    serverMetadata:
      Name: refarch-lv7q9-master
      openshiftClusterID: refarch-lv7q9
    tags:
    - openshiftClusterID=refarch-lv7q9
    trunk: true
    userDataSecret:
      name: master-user-data</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO157-1">
<para>Set the zone name as this value.</para>
</callout>
</calloutlist>
<note>
<simpara>If you edited or recreated machine resources after your initial cluster deployment, you might have to adapt these steps for your configuration.</simpara>
<simpara>In your RHOSP cluster, find the availability zone of the root volumes for your machines and use that as the value.</simpara>
</note>
</listitem>
<listitem>
<simpara>Run the following command to retrieve information about the control plane machine set resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe controlplanemachineset.machine.openshift.io/cluster --namespace openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to edit the resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit controlplanemachineset.machine.openshift.io/cluster --namespace openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>For that resource, set the value of the <literal>spec.state</literal> property to <literal>Active</literal> to activate control plane machine sets for your cluster.</simpara>
</listitem>
</orderedlist>
<simpara>Your control plane is ready to be managed by the Cluster Control Plane Machine Set Operator.</simpara>
</section>
<section xml:id="cpmso-openstack-with-az-config_cpmso-troubleshooting">
<title>Configuring RHOSP clusters that have control plane machines with availability zones after an upgrade</title>
<simpara>For some clusters that run on Red Hat OpenStack Platform (RHOSP) that you upgrade, you must manually update machine resources before you can use control plane machine sets if the following configurations are true:</simpara>
<itemizedlist>
<listitem>
<simpara>The upgraded cluster was created with OpenShift Container Platform 4.13 or earlier.</simpara>
</listitem>
<listitem>
<simpara>The cluster infrastructure is installer-provisioned.</simpara>
</listitem>
<listitem>
<simpara>Control plane machines were distributed across multiple compute availability zones.</simpara>
</listitem>
</itemizedlist>
<simpara>To understand why this procedure is necessary, see <link xlink:href="https://access.redhat.com/solutions/7013893">Solution #7013893</link>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>For the <literal>master-1</literal> and <literal>master-2</literal> control plane machines, open the provider specs for editing. For example, to edit the first machine, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machine/&lt;cluster_id&gt;-master-1 -n openshift-machine-api</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;cluster_id&gt;</literal></term>
<listitem>
<simpara>Specifies the ID of the upgraded cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>For the <literal>master-1</literal> and <literal>master-2</literal> control plane machines, edit the value of the <literal>serverGroupName</literal> property in their provider specs to match that of the machine <literal>master-0</literal>.</simpara>
<formalpara>
<title>An example RHOSP provider spec</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">providerSpec:
  value:
    apiVersion: machine.openshift.io/v1alpha1
    availabilityZone: az0
      cloudName: openstack
    cloudsSecret:
      name: openstack-cloud-credentials
      namespace: openshift-machine-api
    flavor: m1.xlarge
    image: rhcos-4.15
    kind: OpenstackProviderSpec
    metadata:
      creationTimestamp: null
    networks:
    - filter: {}
      subnets:
      - filter:
          name: refarch-lv7q9-nodes
          tags: openshiftClusterID=refarch-lv7q9
    securityGroups:
    - filter: {}
      name: refarch-lv7q9-master
    serverGroupName: refarch-lv7q9-master-az0 <co xml:id="CO158-1"/>
    serverMetadata:
      Name: refarch-lv7q9-master
      openshiftClusterID: refarch-lv7q9
    tags:
    - openshiftClusterID=refarch-lv7q9
    trunk: true
    userDataSecret:
      name: master-user-data</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO158-1">
<para>This value must match for machines <literal>master-0</literal>, <literal>master-1</literal>, and <literal>master-3</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>If you edited or recreated machine resources after your initial cluster deployment, you might have to adapt these steps for your configuration.</simpara>
<simpara>In your RHOSP cluster, find the server group that your control plane instances are in and use that as the value.</simpara>
</note>
</listitem>
<listitem>
<simpara>Run the following command to retrieve information about the control plane machine set resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe controlplanemachineset.machine.openshift.io/cluster --namespace openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to edit the resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit controlplanemachineset.machine.openshift.io/cluster --namespace openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>For that resource, set the value of the <literal>spec.state</literal> property to <literal>Active</literal> to activate control plane machine sets for your cluster.</simpara>
</listitem>
</orderedlist>
<simpara>Your control plane is ready to be managed by the Cluster Control Plane Machine Set Operator.</simpara>
</section>
</section>
</section>
<section xml:id="cpmso-disabling">
<title>Disabling the control plane machine set</title>

<simpara>The <literal>.spec.state</literal> field in an activated <literal>ControlPlaneMachineSet</literal> custom resource (CR) cannot be changed from <literal>Active</literal> to <literal>Inactive</literal>. To disable the control plane machine set, you must delete the CR so that it is removed from the cluster.</simpara>
<simpara>When you delete the CR, the Control Plane Machine Set Operator performs cleanup operations and disables the control plane machine set. The Operator then removes the CR from the cluster and creates an inactive control plane machine set with default settings.</simpara>
<section xml:id="cpmso-deleting_cpmso-disabling">
<title>Deleting the control plane machine set</title>
<simpara>To stop managing control plane machines with the control plane machine set on your cluster, you must delete the <literal>ControlPlaneMachineSet</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Delete the control plane machine set CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete controlplanemachineset.machine.openshift.io cluster \
  -n openshift-machine-api</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the control plane machine set custom resource state. A result of <literal>Inactive</literal> indicates that the removal and replacement process is successful. A <literal>ControlPlaneMachineSet</literal> CR exists but is not activated.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-checking-status_cpmso-disabling">
<title>Checking the control plane machine set custom resource state</title>
<simpara>You can verify the existence and state of the <literal>ControlPlaneMachineSet</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Determine the state of the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get controlplanemachineset.machine.openshift.io cluster \
  --namespace openshift-machine-api</programlisting>
<itemizedlist>
<listitem>
<simpara>A result of <literal>Active</literal> indicates that the <literal>ControlPlaneMachineSet</literal> CR exists and is activated. No administrator action is required.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>Inactive</literal> indicates that a <literal>ControlPlaneMachineSet</literal> CR exists but is not activated.</simpara>
</listitem>
<listitem>
<simpara>A result of <literal>NotFound</literal> indicates that there is no existing <literal>ControlPlaneMachineSet</literal> CR.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cpmso-reenabling_cpmso-disabling">
<title>Re-enabling the control plane machine set</title>
<simpara>To re-enable the control plane machine set, you must ensure that the configuration in the CR is correct for your cluster and activate it.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="cpmso-activating_cpmso-getting-started">Activating the control plane machine set custom resource</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="deploying-machine-health-checks">
<title>Deploying machine health checks</title>

<simpara>You can configure and deploy a machine health check to automatically repair damaged machines in a machine pool.</simpara>
<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<section xml:id="machine-health-checks-about_deploying-machine-health-checks">
<title>About machine health checks</title>
<note>
<simpara>You can only apply a machine health check to machines that are managed by compute machine sets or control plane machine sets.</simpara>
</note>
<simpara>To monitor machine health, create a resource to define the configuration for a controller. Set a condition to check, such as staying in the <literal>NotReady</literal> status for five minutes or displaying a permanent condition in the node-problem-detector, and a label for the set of machines to monitor.</simpara>
<simpara>The controller that observes a <literal>MachineHealthCheck</literal> resource checks for the defined condition. If a machine fails the health check, the machine is automatically deleted and one is created to take its place. When a machine is deleted, you see a <literal>machine deleted</literal> event.</simpara>
<simpara>To limit disruptive impact of the machine deletion, the controller drains and deletes only one node at a time. If there are more unhealthy machines than the <literal>maxUnhealthy</literal> threshold allows for in the targeted pool of machines, remediation stops and therefore enables manual intervention.</simpara>
<note>
<simpara>Consider the timeouts carefully, accounting for workloads and requirements.</simpara>
<itemizedlist>
<listitem>
<simpara>Long timeouts can result in long periods of downtime for the workload on the unhealthy machine.</simpara>
</listitem>
<listitem>
<simpara>Too short timeouts can result in a remediation loop. For example, the timeout for checking the <literal>NotReady</literal> status must be long enough to allow the machine to complete the startup process.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>To stop the check, remove the resource.</simpara>
<section xml:id="machine-health-checks-limitations_deploying-machine-health-checks">
<title>Limitations when deploying machine health checks</title>
<simpara>There are limitations to consider before deploying a machine health check:</simpara>
<itemizedlist>
<listitem>
<simpara>Only machines owned by a machine set are remediated by a machine health check.</simpara>
</listitem>
<listitem>
<simpara>If the node for a machine is removed from the cluster, a machine health check considers the machine to be unhealthy and remediates it immediately.</simpara>
</listitem>
<listitem>
<simpara>If the corresponding node for a machine does not join the cluster after the <literal>nodeStartupTimeout</literal>, the machine is remediated.</simpara>
</listitem>
<listitem>
<simpara>A machine is remediated immediately if the <literal>Machine</literal> resource phase is <literal>Failed</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-nodes-viewing-listing_nodes-nodes-viewing">About listing all the nodes in a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="machine-health-checks-short-circuiting_deploying-machine-health-checks">Short-circuiting machine health check remediation</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="cpmso-about">About the Control Plane Machine Set Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="machine-health-checks-resource_deploying-machine-health-checks">
<title>Sample MachineHealthCheck resource</title>
<simpara>The <literal>MachineHealthCheck</literal> resource for all cloud-based installation types, and other than bare metal, resembles the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineHealthCheck
metadata:
  name: example <co xml:id="CO159-1"/>
  namespace: openshift-machine-api
spec:
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO159-2"/>
      machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO159-3"/>
      machine.openshift.io/cluster-api-machineset: &lt;cluster_name&gt;-&lt;label&gt;-&lt;zone&gt; <co xml:id="CO159-4"/>
  unhealthyConditions:
  - type:    "Ready"
    timeout: "300s" <co xml:id="CO159-5"/>
    status: "False"
  - type:    "Ready"
    timeout: "300s" <co xml:id="CO159-6"/>
    status: "Unknown"
  maxUnhealthy: "40%" <co xml:id="CO159-7"/>
  nodeStartupTimeout: "10m" <co xml:id="CO159-8"/></programlisting>
<calloutlist>
<callout arearefs="CO159-1">
<para>Specify the name of the machine health check to deploy.</para>
</callout>
<callout arearefs="CO159-2 CO159-3">
<para>Specify a label for the machine pool that you want to check.</para>
</callout>
<callout arearefs="CO159-4">
<para>Specify the machine set to track in <literal>&lt;cluster_name&gt;-&lt;label&gt;-&lt;zone&gt;</literal> format. For example, <literal>prod-node-us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO159-5 CO159-6">
<para>Specify the timeout duration for a node condition. If a condition is met for the duration of the timeout, the machine will be remediated. Long timeouts can result in long periods of downtime for a workload on an unhealthy machine.</para>
</callout>
<callout arearefs="CO159-7">
<para>Specify the amount of machines allowed to be concurrently remediated in the targeted pool. This can be set as a percentage or an integer. If the number of unhealthy machines exceeds the limit set by <literal>maxUnhealthy</literal>, remediation is not performed.</para>
</callout>
<callout arearefs="CO159-8">
<para>Specify the timeout duration that a machine health check must wait for a node to join the cluster before a machine is determined to be unhealthy.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>matchLabels</literal> are examples only; you must map your machine groups based on your specific needs.</simpara>
</note>
<section xml:id="machine-health-checks-short-circuiting_deploying-machine-health-checks">
<title>Short-circuiting machine health check remediation</title>
<simpara>Short-circuiting ensures that machine health checks remediate machines only when the cluster is healthy.
Short-circuiting is configured through the <literal>maxUnhealthy</literal> field in the <literal>MachineHealthCheck</literal> resource.</simpara>
<simpara>If the user defines a value for the <literal>maxUnhealthy</literal> field, before remediating any machines, the <literal>MachineHealthCheck</literal> compares the value of <literal>maxUnhealthy</literal> with the number of machines within its target pool that it has determined to be unhealthy. Remediation is not performed if the number of unhealthy machines exceeds the <literal>maxUnhealthy</literal> limit.</simpara>
<important>
<simpara>If <literal>maxUnhealthy</literal> is not set, the value defaults to <literal>100%</literal> and the machines are remediated regardless of the state of the cluster.</simpara>
</important>
<simpara>The appropriate <literal>maxUnhealthy</literal> value depends on the scale of the cluster you deploy and how many machines the <literal>MachineHealthCheck</literal> covers. For example, you can use the <literal>maxUnhealthy</literal> value to cover multiple compute machine sets across multiple availability zones so that if you lose an entire zone, your <literal>maxUnhealthy</literal> setting prevents further remediation within the cluster. In global Azure regions that do not have multiple availability zones, you can use availability sets to ensure high availability.</simpara>
<important>
<simpara>If you configure a <literal>MachineHealthCheck</literal> resource for the control plane, set the value of <literal>maxUnhealthy</literal> to <literal>1</literal>.</simpara>
<simpara>This configuration ensures that the machine health check takes no action when multiple control plane machines appear to be unhealthy. Multiple unhealthy control plane machines can indicate that the etcd cluster is degraded or that a scaling operation to replace a failed machine is in progress.</simpara>
<simpara>If the etcd cluster is degraded, manual intervention might be required. If a scaling operation is in progress, the machine health check should allow it to finish.</simpara>
</important>
<simpara>The <literal>maxUnhealthy</literal> field can be set as either an integer or percentage.
There are different remediation implementations depending on the <literal>maxUnhealthy</literal> value.</simpara>
<section xml:id="_setting-maxunhealthy-by-using-an-absolute-value">
<title>Setting maxUnhealthy by using an absolute value</title>
<simpara>If <literal>maxUnhealthy</literal> is set to <literal>2</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Remediation will be performed if 2 or fewer nodes are unhealthy</simpara>
</listitem>
<listitem>
<simpara>Remediation will not be performed if 3 or more nodes are unhealthy</simpara>
</listitem>
</itemizedlist>
<simpara>These values are independent of how many machines are being checked by the machine health check.</simpara>
</section>
<section xml:id="_setting-maxunhealthy-by-using-percentages">
<title>Setting maxUnhealthy by using percentages</title>
<simpara>If <literal>maxUnhealthy</literal> is set to <literal>40%</literal> and there are 25 machines being checked:</simpara>
<itemizedlist>
<listitem>
<simpara>Remediation will be performed if 10 or fewer nodes are unhealthy</simpara>
</listitem>
<listitem>
<simpara>Remediation will not be performed if 11 or more nodes are unhealthy</simpara>
</listitem>
</itemizedlist>
<simpara>If <literal>maxUnhealthy</literal> is set to <literal>40%</literal> and there are 6 machines being checked:</simpara>
<itemizedlist>
<listitem>
<simpara>Remediation will be performed if 2 or fewer nodes are unhealthy</simpara>
</listitem>
<listitem>
<simpara>Remediation will not be performed if 3 or more nodes are unhealthy</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The allowed number of machines is rounded down when the percentage of <literal>maxUnhealthy</literal> machines that are checked is not a whole number.</simpara>
</note>
</section>
</section>
</section>
<section xml:id="machine-health-checks-creating_deploying-machine-health-checks">
<title>Creating a machine health check resource</title>
<simpara>You can create a <literal>MachineHealthCheck</literal> resource for machine sets in your cluster.</simpara>
<note>
<simpara>You can only apply a machine health check to machines that are managed by compute machine sets or control plane machine sets.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the <literal>oc</literal> command line interface.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>healthcheck.yml</literal> file that contains the definition of your machine health check.</simpara>
</listitem>
<listitem>
<simpara>Apply the <literal>healthcheck.yml</literal> file to your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f healthcheck.yml</programlisting>
</listitem>
</orderedlist>
<simpara>You can configure and deploy a machine health check to detect and repair unhealthy bare metal nodes.</simpara>
</section>
<section xml:id="mgmt-power-remediation-baremetal-about_deploying-machine-health-checks">
<title>About power-based remediation of bare metal</title>
<simpara>In a bare metal cluster, remediation of nodes is critical to ensuring the overall health of the cluster. Physically remediating a cluster can be challenging and any delay in putting the machine into a safe or an operational state increases the time the cluster remains in a degraded state, and the risk that subsequent failures might bring the cluster offline. Power-based remediation helps counter such challenges.</simpara>
<simpara>Instead of reprovisioning the nodes, power-based remediation uses a power controller to power off an inoperable node. This type of remediation is also called power fencing.</simpara>
<simpara>OpenShift Container Platform uses the <literal>MachineHealthCheck</literal> controller to detect faulty bare metal nodes. Power-based remediation is fast and reboots faulty nodes instead of removing them from the cluster.</simpara>
<simpara>Power-based remediation provides the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara>Allows the recovery of control plane nodes</simpara>
</listitem>
<listitem>
<simpara>Reduces the risk of data loss in hyperconverged environments</simpara>
</listitem>
<listitem>
<simpara>Reduces the downtime associated with recovering physical machines</simpara>
</listitem>
</itemizedlist>
<section xml:id="machine-health-checks-bare-metal_deploying-machine-health-checks">
<title>MachineHealthChecks on bare metal</title>
<simpara>Machine deletion on bare metal cluster triggers reprovisioning of a bare metal host.
Usually bare metal reprovisioning is a lengthy process, during which the cluster
is missing compute resources and applications might be interrupted.</simpara>
<simpara>There are two ways to change the default remediation process from machine deletion to host power-cycle:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Annotate the <literal>MachineHealthCheck</literal> resource with the
<literal>machine.openshift.io/remediation-strategy: external-baremetal</literal> annotation.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>Metal3RemediationTemplate</literal> resource, and refer to it in the <literal>spec.remediationTemplate</literal> of the <literal>MachineHealthCheck</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>After using one of these methods, unhealthy machines are power-cycled by using Baseboard Management Controller (BMC) credentials.</simpara>
</section>
<section xml:id="mgmt-understanding-remediation-process_deploying-machine-health-checks">
<title>Understanding the annotation-based remediation process</title>
<simpara>The remediation process operates as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The MachineHealthCheck (MHC) controller detects that a node is unhealthy.</simpara>
</listitem>
<listitem>
<simpara>The MHC notifies the bare metal machine controller which requests to power-off the unhealthy node.</simpara>
</listitem>
<listitem>
<simpara>After the power is off, the node is deleted, which allows the cluster to reschedule the affected workload on other nodes.</simpara>
</listitem>
<listitem>
<simpara>The bare metal machine controller requests to power on the node.</simpara>
</listitem>
<listitem>
<simpara>After the node is up, the node re-registers itself with the cluster, resulting in the creation of a new node.</simpara>
</listitem>
<listitem>
<simpara>After the node is recreated, the bare metal machine controller restores the annotations and labels that existed on the unhealthy node before its deletion.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>If the power operations did not complete, the bare metal machine controller triggers the reprovisioning of the unhealthy node unless this is a control plane node or a node that was provisioned externally.</simpara>
</note>
</section>
<section xml:id="mgmt-understanding-metal3-remediation-process_deploying-machine-health-checks">
<title>Understanding the metal3-based remediation process</title>
<simpara>The remediation process operates as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The MachineHealthCheck (MHC) controller detects that a node is unhealthy.</simpara>
</listitem>
<listitem>
<simpara>The MHC creates a metal3 remediation custom resource for the metal3 remediation controller, which requests to power-off the unhealthy node.</simpara>
</listitem>
<listitem>
<simpara>After the power is off, the node is deleted, which allows the cluster to reschedule the affected workload on other nodes.</simpara>
</listitem>
<listitem>
<simpara>The metal3 remediation controller requests to power on the node.</simpara>
</listitem>
<listitem>
<simpara>After the node is up, the node re-registers itself with the cluster, resulting in the creation of a new node.</simpara>
</listitem>
<listitem>
<simpara>After the node is recreated, the metal3 remediation controller restores the annotations and labels that existed on the unhealthy node before its deletion.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>If the power operations did not complete, the metal3 remediation controller triggers the reprovisioning of the unhealthy node unless this is a control plane node or a node that was provisioned externally.</simpara>
</note>
</section>
<section xml:id="mgmt-creating-mhc-baremetal_deploying-machine-health-checks">
<title>Creating a MachineHealthCheck resource for bare metal</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The OpenShift Container Platform is installed using installer-provisioned infrastructure (IPI).</simpara>
</listitem>
<listitem>
<simpara>Access to BMC credentials (or BMC access to each node).</simpara>
</listitem>
<listitem>
<simpara>Network access to the BMC interface of the unhealthy node.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>healthcheck.yaml</literal> file that contains the definition of your machine health check.</simpara>
</listitem>
<listitem>
<simpara>Apply the <literal>healthcheck.yaml</literal> file to your cluster using the following command:</simpara>
</listitem>
</orderedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f healthcheck.yaml</programlisting>
<formalpara>
<title>Sample <literal>MachineHealthCheck</literal> resource for bare metal, annotation-based remediation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineHealthCheck
metadata:
  name: example <co xml:id="CO160-1"/>
  namespace: openshift-machine-api
  annotations:
    machine.openshift.io/remediation-strategy: external-baremetal <co xml:id="CO160-2"/>
spec:
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-machine-role: &lt;role&gt; <co xml:id="CO160-3"/>
      machine.openshift.io/cluster-api-machine-type: &lt;role&gt; <co xml:id="CO160-4"/>
      machine.openshift.io/cluster-api-machineset: &lt;cluster_name&gt;-&lt;label&gt;-&lt;zone&gt; <co xml:id="CO160-5"/>
  unhealthyConditions:
  - type:    "Ready"
    timeout: "300s" <co xml:id="CO160-6"/>
    status: "False"
  - type:    "Ready"
    timeout: "300s" <co xml:id="CO160-7"/>
    status: "Unknown"
  maxUnhealthy: "40%" <co xml:id="CO160-8"/>
  nodeStartupTimeout: "10m" <co xml:id="CO160-9"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO160-1">
<para>Specify the name of the machine health check to deploy.</para>
</callout>
<callout arearefs="CO160-2">
<para>For bare metal clusters, you must include the <literal>machine.openshift.io/remediation-strategy: external-baremetal</literal> annotation in the <literal>annotations</literal> section to enable power-cycle remediation. With this remediation strategy, unhealthy hosts are rebooted instead of removed from the cluster.</para>
</callout>
<callout arearefs="CO160-3 CO160-4">
<para>Specify a label for the machine pool that you want to check.</para>
</callout>
<callout arearefs="CO160-5">
<para>Specify the compute machine set to track in <literal>&lt;cluster_name&gt;-&lt;label&gt;-&lt;zone&gt;</literal> format. For example, <literal>prod-node-us-east-1a</literal>.</para>
</callout>
<callout arearefs="CO160-6 CO160-7">
<para>Specify the timeout duration for the node condition. If the condition is met for the duration of the timeout, the machine will be remediated. Long timeouts can result in long periods of downtime for a workload on an unhealthy machine.</para>
</callout>
<callout arearefs="CO160-8">
<para>Specify the amount of machines allowed to be concurrently remediated in the targeted pool. This can be set as a percentage or an integer. If the number of unhealthy machines exceeds the limit set by <literal>maxUnhealthy</literal>, remediation is not performed.</para>
</callout>
<callout arearefs="CO160-9">
<para>Specify the timeout duration that a machine health check must wait for a node to join the cluster before a machine is determined to be unhealthy.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>matchLabels</literal> are examples only; you must map your machine groups based on your specific needs.</simpara>
</note>
<formalpara>
<title>Sample <literal>MachineHealthCheck</literal> resource for bare metal, metal3-based remediation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineHealthCheck
metadata:
  name: example
  namespace: openshift-machine-api
spec:
  selector:
    matchLabels:
      machine.openshift.io/cluster-api-machine-role: &lt;role&gt;
      machine.openshift.io/cluster-api-machine-type: &lt;role&gt;
      machine.openshift.io/cluster-api-machineset: &lt;cluster_name&gt;-&lt;label&gt;-&lt;zone&gt;
  remediationTemplate:
    apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
    kind: Metal3RemediationTemplate
    name: metal3-remediation-template
    namespace: openshift-machine-api
  unhealthyConditions:
  - type:    "Ready"
    timeout: "300s"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample <literal>Metal3RemediationTemplate</literal> resource for bare metal, metal3-based remediation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: infrastructure.cluster.x-k8s.io/v1beta1
kind: Metal3RemediationTemplate
metadata:
  name: metal3-remediation-template
  namespace: openshift-machine-api
spec:
  template:
    spec:
      strategy:
        type: Reboot
        retryLimit: 1
        timeout: 5m0s</programlisting>
</para>
</formalpara>
<note>
<simpara>The <literal>matchLabels</literal> are examples only; you must map your machine groups based on your specific needs. The <literal>annotations</literal> section does not apply to metal3-based remediation. Annotation-based remediation and metal3-based remediation are mutually exclusive.</simpara>
</note>
</section>
<mgmt-troubleshooting-issue-power-remediation_deploying-machine-health-checks xml:id="_troubleshooting-issues-with-power-based-remediation">
<title>Troubleshooting issues with power-based remediation</title>
<simpara>To troubleshoot an issue with power-based remediation, verify the following:</simpara>
<itemizedlist>
<listitem>
<simpara>You have access to the BMC.</simpara>
</listitem>
<listitem>
<simpara>BMC is connected to the control plane node that is responsible for running the remediation task.</simpara>
</listitem>
</itemizedlist>
</mgmt-troubleshooting-issue-power-remediation_deploying-machine-health-checks>
</section>
</chapter>
</book>