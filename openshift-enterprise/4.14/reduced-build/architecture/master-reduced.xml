<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Architecture</title>
<date>2024-02-13</date>
</info>
<chapter xml:id="architecture-overview">
<title>Architecture overview</title>

<simpara>{product-title} is a cloud-based Kubernetes container platform.
The foundation of {product-title} is based on Kubernetes and therefore shares the same technology.
To learn more about {product-title} and Kubernetes, see <link xl:href="../architecture/architecture.xml#architecture">product architecture</link>.</simpara>
<section xml:id="openshift-architecture-common-terms_architecture-overview">
<title>Glossary of common terms for {product-title} architecture</title>
<simpara>This glossary defines common terms that are used in the architecture content.</simpara>
<variablelist>
<varlistentry>
<term>access policies</term>
<listitem>
<simpara>A set of roles that dictate how users, applications, and entities within a cluster interacts with one another. An access policy increases cluster security.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>admission plugins</term>
<listitem>
<simpara>Admission plugins enforce security policies, resource limitations, or configuration requirements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>authentication</term>
<listitem>
<simpara>To control access to an {product-title} cluster, a cluster administrator can configure user authentication and ensure only approved users access the cluster. To interact with an {product-title} cluster, you must authenticate to the {product-title} API. You can authenticate by providing an OAuth access token or an X.509 client certificate in your requests to the {product-title} API.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bootstrap</term>
<listitem>
<simpara>A temporary machine that runs minimal Kubernetes and deploys the {product-title} control plane.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>certificate signing requests (CSRs)</term>
<listitem>
<simpara>A resource requests a denoted signer to sign a certificate. This request might get approved or denied.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cluster Version Operator (CVO)</term>
<listitem>
<simpara>An Operator that checks with the {product-title} Update Service to see the valid updates and update paths based on current component versions and information in the graph.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>compute nodes</term>
<listitem>
<simpara>Nodes that are responsible for executing workloads for cluster users. Compute nodes are also known as worker nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>configuration drift</term>
<listitem>
<simpara>A situation where the configuration on a node does not match what the machine config specifies.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>containers</term>
<listitem>
<simpara>Lightweight and executable images that consist software and all its dependencies. Because containers virtualize the operating system, you can run containers anywhere, from a data center to a public or private cloud to your local host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>container orchestration engine</term>
<listitem>
<simpara>Software that automates the deployment, management, scaling, and networking of containers.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>container workloads</term>
<listitem>
<simpara>Applications that are packaged and deployed in containers.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>control groups (cgroups)</term>
<listitem>
<simpara>Partitions sets of processes into groups to manage and limit the resources processes consume.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>control plane</term>
<listitem>
<simpara>A container orchestration layer that exposes the API and interfaces to define, deploy, and manage the life cycle of containers. Control planes are also known as control plane machines.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CRI-O</term>
<listitem>
<simpara>A Kubernetes native container runtime implementation that integrates with the operating system to deliver an efficient Kubernetes experience.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>deployment</term>
<listitem>
<simpara>A Kubernetes resource object that maintains the life cycle of an application.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Dockerfile</term>
<listitem>
<simpara>A text file that contains the user commands to perform on a terminal to assemble the image.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hosted control planes</term>
<listitem>
<simpara>A {product-title} feature that enables hosting a control plane on the {product-title} cluster from its data plane and workers. This model performs following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Optimize infrastructure costs required for the control planes.</simpara>
</listitem>
<listitem>
<simpara>Improve the cluster creation time.</simpara>
</listitem>
<listitem>
<simpara>Enable hosting the control plane using the Kubernetes native high level primitives. For example, deployments, stateful sets.</simpara>
</listitem>
<listitem>
<simpara>Allow a strong network segmentation between the control plane and workloads.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>hybrid cloud deployments</term>
<listitem>
<simpara>Deployments that deliver a consistent platform across bare metal, virtual, private, and public cloud environments. This offers speed, agility, and portability.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Ignition</term>
<listitem>
<simpara>A utility that RHCOS uses to manipulate disks during initial configuration. It completes common disk tasks, including partitioning disks, formatting partitions, writing files, and configuring users.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>installer-provisioned infrastructure</term>
<listitem>
<simpara>The installation program deploys and configures the infrastructure that the cluster runs on.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>kubelet</term>
<listitem>
<simpara>A primary node agent that runs on each node in the cluster to ensure that containers are running in a pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>kubernetes manifest</term>
<listitem>
<simpara>Specifications of a Kubernetes API object in a JSON or YAML format. A configuration file can include deployments, config maps, secrets, daemon sets.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine Config Daemon (MCD)</term>
<listitem>
<simpara>A daemon that regularly checks the nodes for configuration drift.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine Config Operator (MCO)</term>
<listitem>
<simpara>An Operator that applies the new configuration to your cluster machines.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>machine config pools (MCP)</term>
<listitem>
<simpara>A group of machines, such as control plane components or user workloads, that are based on the resources that they handle.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>metadata</term>
<listitem>
<simpara>Additional information about cluster deployment artifacts.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>microservices</term>
<listitem>
<simpara>An approach to writing software. Applications can be separated into the smallest components, independent from each other by using microservices.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>mirror registry</term>
<listitem>
<simpara>A registry that holds the mirror of {product-title} images.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>monolithic applications</term>
<listitem>
<simpara>Applications that are self-contained, built, and packaged as a single piece.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>namespaces</term>
<listitem>
<simpara>A namespace isolates specific system resources that are visible to all processes. Inside a namespace, only processes that are members of that namespace can see those resources.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>networking</term>
<listitem>
<simpara>Network information of {product-title} cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>node</term>
<listitem>
<simpara>A worker machine in the {product-title} cluster. A node is either a virtual machine (VM) or a physical machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>{product-title} Update Service (OSUS)</term>
<listitem>
<simpara>For clusters with internet access, Red Hat Enterprise Linux (RHEL) provides over-the-air updates by using an {product-title} update service as a hosted service located behind public APIs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenShift CLI (<literal>oc</literal>)</term>
<listitem>
<simpara>A command line tool to run {product-title} commands on the terminal.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenShift Dedicated</term>
<listitem>
<simpara>A managed RHEL {product-title} offering on Amazon Web Services (AWS) and Google Cloud Platform (GCP). OpenShift Dedicated focuses on building and scaling applications.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenShift image registry</term>
<listitem>
<simpara>A registry provided by {product-title} to manage images.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator</term>
<listitem>
<simpara>The preferred method of packaging, deploying, and managing a Kubernetes application in an {product-title} cluster. An Operator takes human operational knowledge and encodes it into software that is packaged and shared with customers.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OperatorHub</term>
<listitem>
<simpara>A platform that contains various {product-title} Operators to install.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager (OLM)</term>
<listitem>
<simpara>OLM helps you to install, update, and manage the lifecycle of Kubernetes native applications. OLM is an open source toolkit designed to manage Operators in an effective, automated, and scalable way.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OSTree</term>
<listitem>
<simpara>An upgrade system for Linux-based operating systems that performs atomic upgrades of complete file system trees. OSTree tracks meaningful changes to the file system tree using an addressable object store, and is designed to complement existing package management systems.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>over-the-air (OTA) updates</term>
<listitem>
<simpara>The {product-title} Update Service (OSUS) provides over-the-air updates to {product-title}, including Red Hat Enterprise Linux CoreOS (RHCOS).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>pod</term>
<listitem>
<simpara>One or more containers with shared resources, such as volume and IP addresses, running in your {product-title} cluster.
A pod is the smallest compute unit defined, deployed, and managed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>private registry</term>
<listitem>
<simpara>{product-title} can use any server implementing the container image registry API as a source of the image which allows the developers to push and pull their private container images.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>public registry</term>
<listitem>
<simpara>{product-title} can use any server implementing the container image registry API as a source of the image which allows the developers to push and pull their public container images.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RHEL {product-title} Cluster Manager</term>
<listitem>
<simpara>A managed service where you can install, modify, operate, and upgrade your {product-title} clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RHEL Quay Container Registry</term>
<listitem>
<simpara>A Quay.io container registry that serves most of the container images and Operators to {product-title} clusters.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>replication controllers</term>
<listitem>
<simpara>An asset that indicates how many pod replicas are required to run at a time.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>role-based access control (RBAC)</term>
<listitem>
<simpara>A key security control to ensure that cluster users and workloads have only access to resources required to execute their roles.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>route</term>
<listitem>
<simpara>Routes expose a service to allow for network access to pods from users and applications outside the {product-title} instance.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>scaling</term>
<listitem>
<simpara>The increasing or decreasing of resource capacity.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>service</term>
<listitem>
<simpara>A service exposes a running application on a set of pods.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Source-to-Image (S2I) image</term>
<listitem>
<simpara>An image created based on the programming language of the application source code in {product-title} to deploy applications.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>storage</term>
<listitem>
<simpara>{product-title} supports many types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an {product-title} cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Telemetry</term>
<listitem>
<simpara>A component to collect information such as size, health, and status of {product-title}.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>template</term>
<listitem>
<simpara>A template describes a set of objects that can be parameterized and processed to produce a list of objects for creation by {product-title}.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>user-provisioned infrastructure</term>
<listitem>
<simpara>You can install {product-title} on the infrastructure that you provide. You can use the installation program to generate the assets required to provision the cluster infrastructure, create the cluster infrastructure, and then deploy the cluster to the infrastructure that you provided.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>web console</term>
<listitem>
<simpara>A user interface (UI) to manage {product-title}.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>worker node</term>
<listitem>
<simpara>Nodes that are responsible for executing workloads for cluster users. Worker nodes are also known as compute nodes.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on networking, see <link xl:href="../networking/understanding-networking.xml#understanding-networking">{product-title} networking</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on storage, see <link xl:href="../storage/index.xml#index">{product-title} storage</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on authentication, see <link xl:href="../authentication/index.xml#index">{product-title} authentication</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on Operator Lifecycle Manager (OLM), see <link xl:href="../operators/understanding/olm/olm-understanding-olm.xml#olm-understanding-olm">OLM</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on logging, see <link xl:href="../logging/cluster-logging.xml#cluster-logging">About Logging</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on over-the-air (OTA) updates, see <link xl:href="../updating/understanding_updates/intro-to-updates.xml#understanding-openshift-updates">Introduction to OpenShift updates</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-installation-and-updates">
<title>About installation and updates</title>
<simpara>As a cluster administrator, you can use the {product-title} <link xl:href="../architecture/architecture-installation.xml#architecture-installation">installation program</link> to install and deploy a cluster by using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Installer-provisioned infrastructure</simpara>
</listitem>
<listitem>
<simpara>User-provisioned infrastructure</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-control-planes">
<title>About the control plane</title>
<simpara>The <link xl:href="../architecture/control-plane.xml#control-plane">control plane</link> manages the worker nodes and the pods in your cluster. You can configure nodes with the use of machine config pools (MCPs).
MCPs are groups of machines, such as control plane components or user workloads, that are based on the resources that they handle.
{product-title} assigns different roles to hosts. These roles define the function of a machine in a cluster.
The cluster contains definitions for the standard control plane and worker role types.</simpara>
<simpara>You can use Operators to package, deploy, and manage services on the control plane.
Operators are important components in {product-title} because they provide the following services:</simpara>
<itemizedlist>
<listitem>
<simpara>Perform health checks</simpara>
</listitem>
<listitem>
<simpara>Provide ways to watch applications</simpara>
</listitem>
<listitem>
<simpara>Manage over-the-air updates</simpara>
</listitem>
<listitem>
<simpara>Ensure applications stay in the specified state</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-containerized-applications-for-developers">
<title>About containerized applications for developers</title>
<simpara>As a developer, you can use different tools, methods, and formats to <link xl:href="../architecture/understanding-development.xml#understanding-development">develop your containerized application</link> based on your unique requirements, for example:</simpara>
<itemizedlist>
<listitem>
<simpara>Use various build-tool, base-image, and registry options to build a simple container application.</simpara>
</listitem>
<listitem>
<simpara>Use supporting components such as OperatorHub and templates to develop your application.</simpara>
</listitem>
<listitem>
<simpara>Package and deploy your application as an Operator.</simpara>
</listitem>
</itemizedlist>
<simpara>You can also create a Kubernetes manifest and store it in a Git repository.
Kubernetes works on basic units called pods. A pod is a single instance of a running process in your cluster. Pods can contain one or more containers.
You can create a service by grouping a set of pods and their access policies.
Services provide permanent internal IP addresses and host names for other applications to use as pods are created and destroyed. Kubernetes defines workloads based on the type of your application.</simpara>
</section>
<section xml:id="coreos-and-ignition">
<title>About Red Hat Enterprise Linux CoreOS (RHCOS) and Ignition</title>
<simpara>As a cluster administrator, you can perform the following Red Hat Enterprise Linux CoreOS (RHCOS) tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Learn about the next generation of <link xl:href="../architecture/architecture-rhcos.xml#architecture-rhcos">single-purpose container operating system technology</link>.</simpara>
</listitem>
<listitem>
<simpara>Choose how to configure Red Hat Enterprise Linux CoreOS (RHCOS)</simpara>
</listitem>
<listitem>
<simpara>Choose how to deploy Red Hat Enterprise Linux CoreOS (RHCOS):</simpara>
<itemizedlist>
<listitem>
<simpara>Installer-provisioned deployment</simpara>
</listitem>
<listitem>
<simpara>User-provisioned deployment</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The {product-title} installation program creates the Ignition configuration files that you need to deploy your cluster.
Red Hat Enterprise Linux CoreOS (RHCOS) uses Ignition during the initial configuration to perform common disk tasks, such as partitioning, formatting, writing files, and configuring users.
During the first boot, Ignition reads its configuration from the installation media or the location that you specify and applies the configuration to the machines.</simpara>
<simpara>You can learn how <link xl:href="../architecture/architecture-rhcos.xml#architecture-rhcos">Ignition works</link>, the process for a Red Hat Enterprise Linux CoreOS (RHCOS) machine in an {product-title} cluster, view Ignition configuration files, and change Ignition configuration after an installation.</simpara>
</section>
<section xml:id="about-admission-plug-ins">
<title>About admission plugins</title>
<simpara>You can use <link xl:href="../architecture/admission-plug-ins.xml#admission-plug-ins">admission plugins</link> to regulate how {product-title} functions. After a resource request is authenticated and authorized, admission plugins intercept the resource request to the master API to validate resource requests and to ensure that scaling policies are adhered to.
Admission plugins are used to enforce security policies, resource limitations, or configuration requirements.</simpara>
</section>
</chapter>
<chapter xml:id="architecture">
<title>{product-title} architecture</title>

<section xml:id="architecture-platform-introduction_architecture">
<title>Introduction to {product-title}</title>
<simpara>{product-title} is a platform for developing and running containerized
applications. It is designed to allow applications and the data centers
that support them to expand from just a few machines and applications to
thousands of machines that serve millions of clients.</simpara>
<simpara>With its foundation in Kubernetes, {product-title} incorporates the same
technology that serves as the engine for massive telecommunications, streaming
video, gaming, banking, and other applications. Its implementation in open
Red Hat technologies lets you extend your containerized applications beyond a
single cloud to on-premise and multi-cloud environments.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/oke-arch-ocp-stack.png"/>
</imageobject>
<textobject><phrase>Red Hat OpenShift Kubernetes Engine</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="architecture-kubernetes-introduction_architecture">
<title>About Kubernetes</title>
<simpara>Although container images and the containers that run from them are the
primary building blocks for modern application development, to run them at scale
requires a reliable and flexible distribution system. Kubernetes is the
defacto standard for orchestrating containers.</simpara>
<simpara>Kubernetes is an open source container orchestration engine for automating
deployment, scaling, and management of containerized applications. The general
concept of Kubernetes is fairly simple:</simpara>
<itemizedlist>
<listitem>
<simpara>Start with one or more worker nodes to run the container workloads.</simpara>
</listitem>
<listitem>
<simpara>Manage the deployment of those workloads from one or more control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>Wrap containers in a deployment unit called a pod. Using pods provides extra
metadata with the container and offers the ability to group several containers
in a single deployment entity.</simpara>
</listitem>
<listitem>
<simpara>Create special kinds of assets. For example, services are represented by a
set of pods and a policy that defines how they are accessed. This policy
allows containers to connect to the services that they need even if they do not
have the specific IP addresses for the services. Replication controllers are
another special asset that indicates how many pod replicas are required to run
at a time. You can use this capability to automatically scale your application
to adapt to its current demand.</simpara>
</listitem>
</itemizedlist>
<simpara>In only a few years, Kubernetes has seen massive cloud and on-premise adoption.
The open source development model allows many people to extend Kubernetes
by implementing different technologies for components such as networking,
storage, and authentication.</simpara>
</section>
<section xml:id="architecture-container-application-benefits_architecture">
<title>The benefits of containerized applications</title>
<simpara>Using containerized applications offers many advantages over using traditional deployment methods. Where applications were once expected to be installed on operating systems that included all their dependencies, containers let an application carry their dependencies with them. Creating containerized applications offers many benefits.</simpara>
<section xml:id="operating-system-benefits_architecture">
<title>Operating system benefits</title>
<simpara>Containers use small, dedicated Linux operating systems without a kernel. Their file system, networking, cgroups, process tables, and namespaces are separate from the host Linux system, but the containers can integrate with the hosts seamlessly when necessary. Being based on Linux allows containers to use all the advantages that come with the open source development model of rapid innovation.</simpara>
<simpara>Because each container uses a dedicated operating system, you can deploy applications that require conflicting software dependencies on the same host. Each container carries its own dependent software and manages its own interfaces, such as networking and file systems, so applications never need to compete for those assets.</simpara>
</section>
<section xml:id="deployment-scaling-benefits_architecture">
<title>Deployment and scaling benefits</title>
<simpara>If you employ rolling upgrades between major releases of your application, you can continuously improve your applications without downtime and still maintain compatibility with the current release.</simpara>
<simpara>You can also deploy and test a new version of an application alongside the existing version. If the container passes your tests, simply deploy more new containers and remove the old ones. </simpara>
<simpara>Since all the software dependencies for an application are resolved within the container itself, you can use a standardized operating system on each host in your data center. You do not need to configure a specific operating system for each application host. When your data center needs more capacity, you can deploy another generic host system.</simpara>
<simpara>Similarly, scaling containerized applications is simple. {product-title} offers a simple, standard way of scaling any containerized service. For example, if you build applications as a set of microservices rather than large, monolithic applications, you can scale the individual microservices individually to meet demand. This capability allows you to scale only the required services instead of the entire application, which can allow you to meet application demands while using minimal resources.</simpara>
</section>
</section>
<section xml:id="architecture-platform-benefits_architecture">
<title>{product-title} overview</title>
<simpara>{product-title} provides enterprise-ready enhancements to Kubernetes, including the following enhancements:</simpara>
<itemizedlist>
<listitem>
<simpara>Hybrid cloud deployments. You can deploy {product-title} clusters to a variety of public cloud platforms or in your data center.</simpara>
</listitem>
<listitem>
<simpara>Integrated Red Hat technology. Major components in {product-title} come from Red Hat Enterprise Linux (RHEL) and related Red Hat technologies. {product-title} benefits from the intense testing and certification initiatives for Red Hat&#8217;s enterprise quality software.</simpara>
</listitem>
<listitem>
<simpara>Open source development model. Development is completed in the open, and the source code is available from public software repositories. This open collaboration fosters rapid innovation and development.</simpara>
</listitem>
</itemizedlist>
<simpara>Although Kubernetes excels at managing your applications, it does not specify
or manage platform-level requirements or deployment processes. Powerful and
flexible platform management tools and processes are important benefits that
{product-title} {product-version} offers. The following sections describe some
unique features and benefits of {product-title}.</simpara>
<section xml:id="architecture-custom-os_architecture">
<title>Custom operating system</title>
<simpara>{product-title} uses Red Hat Enterprise Linux CoreOS (RHCOS), a container-oriented operating system that is specifically designed for running containerized applications from {product-title} and works with new tools to provide fast installation, Operator-based management, and simplified upgrades.</simpara>
<simpara>RHCOS includes:</simpara>
<itemizedlist>
<listitem>
<simpara>Ignition, which {product-title} uses as a firstboot system configuration for initially bringing up and configuring machines.</simpara>
</listitem>
<listitem>
<simpara>CRI-O, a Kubernetes native container runtime implementation that integrates closely with the operating system to deliver an efficient and optimized Kubernetes experience. CRI-O provides facilities for running, stopping, and restarting containers. It fully replaces the Docker Container Engine, which was used in {product-title} 3.</simpara>
</listitem>
<listitem>
<simpara>Kubelet, the primary node agent for Kubernetes that is responsible for
launching and monitoring containers.</simpara>
</listitem>
</itemizedlist>
<simpara>In {product-title} {product-version}, you must use RHCOS for all control
plane machines, but you can use Red Hat Enterprise Linux (RHEL) as the operating
system for compute machines, which are also known as worker machines. If you choose to use RHEL workers, you
must perform more system maintenance than if you use RHCOS for all of the
cluster machines.</simpara>
</section>
<section xml:id="architecture-platform-management_architecture">
<title>Simplified installation and update process</title>
<simpara>With {product-title} {product-version}, if you have an account with the right
permissions, you can deploy a production cluster in supported clouds by running
a single command and providing a few values. You can also customize your cloud
installation or install your cluster in your data center if you use a supported
platform.</simpara>
<simpara>For clusters that use RHCOS for all machines, updating, or
upgrading, {product-title} is a simple, highly-automated process. Because
{product-title} completely controls the systems and services that run on each
machine, including the operating system itself, from a central control plane,
upgrades are designed to become automatic events. If your cluster contains
RHEL worker machines, the control plane benefits from the streamlined update
process, but you must perform more tasks to upgrade the RHEL machines.</simpara>
</section>
<section xml:id="architecture-key-features_architecture">
<title>Other key features</title>
<simpara>Operators are both the fundamental unit of the {product-title} {product-version}
code base and a convenient way to deploy applications and software components
for your applications to use. In {product-title}, Operators serve as the platform foundation and remove the need for manual upgrades of operating systems and control plane applications. {product-title} Operators such as the
Cluster Version Operator and Machine Config Operator allow simplified,
cluster-wide management of those critical components.</simpara>
<simpara>Operator Lifecycle Manager (OLM) and the OperatorHub provide facilities for
storing and distributing Operators to people developing and deploying applications.</simpara>
<simpara>The Red Hat Quay Container Registry is a Quay.io container registry that serves
most of the container images and Operators to {product-title} clusters.
Quay.io is a public registry version of Red Hat Quay that stores millions of images
and tags.</simpara>
<simpara>Other enhancements to Kubernetes in {product-title} include improvements in
software defined networking (SDN), authentication, log aggregation, monitoring,
and routing. {product-title} also offers a comprehensive web console and the
custom OpenShift CLI (<literal>oc</literal>) interface.</simpara>
</section>
<section xml:id="architecture-overview-image_architecture">
<title>{product-title} lifecycle</title>
<simpara>The following figure illustrates the basic {product-title} lifecycle:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating an {product-title} cluster</simpara>
</listitem>
<listitem>
<simpara>Managing the cluster</simpara>
</listitem>
<listitem>
<simpara>Developing and deploying applications</simpara>
</listitem>
<listitem>
<simpara>Scaling up applications</simpara>
</listitem>
</itemizedlist>
<figure>
<title>High level {product-title} overview</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/product-workflow-overview.png"/>
</imageobject>
<textobject><phrase>High-level {product-title} flow</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="cluster-entitlements_architecture">
<title>Internet access for {product-title}</title>
<simpara>In {product-title} {product-version}, you require access to the internet to
install
your cluster.</simpara>
<simpara>You must have internet access to:</simpara>
<itemizedlist>
<listitem>
<simpara>Access <link xl:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link> to download the installation program and perform subscription management. If the cluster has internet access and you do not disable Telemetry, that service automatically entitles your cluster.</simpara>
</listitem>
<listitem>
<simpara>Access <link xl:href="http://quay.io">Quay.io</link> to obtain the packages that are required to install your cluster.</simpara>
</listitem>
<listitem>
<simpara>Obtain the packages that are required to perform cluster updates.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>If your cluster cannot have direct internet access, you can perform a restricted network installation on some types of infrastructure that you provision. During that process, you download the required content and use it to populate a mirror registry with the installation packages. With some installation types, the environment that you install your cluster in will not require internet access. Before you update the cluster, you update the content of the mirror registry.</simpara>
</important>
</section>
</section>
</chapter>
<chapter xml:id="architecture-installation">
<title>Installation and update</title>

<section xml:id="installation-overview_architecture-installation">
<title>About {product-title} installation</title>
<simpara>The {product-title} installation program offers four methods for deploying a cluster which are detailed in the following list:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Interactive</emphasis>: You can deploy a cluster with the web-based <link xl:href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform">Assisted Installer</link>. This is an ideal approach for clusters with networks connected to the internet. The Assisted Installer is the easiest way to install {product-title}, it provides smart defaults, and it performs pre-flight validations before installing the cluster. It also provides a RESTful API for automation and advanced configuration scenarios.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Local Agent-based</emphasis>: You can deploy a cluster locally with the Agent-based Installer for disconnected environments or restricted networks. It provides many of the benefits of the Assisted Installer, but you must download and configure the <link xl:href="https://console.redhat.com/openshift/install/metal/agent-based">Agent-based Installer</link> first. Configuration is done with a command-line interface. This approach is ideal for disconnected environments.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Automated</emphasis>: You can deploy a cluster on installer-provisioned infrastructure. The installation program uses each cluster host&#8217;s baseboard management controller (BMC) for provisioning. You can deploy clusters in connected or disconnected environments.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Full control</emphasis>: You can deploy a cluster on infrastructure that you prepare and maintain, which provides maximum customizability. You can deploy clusters in connected or disconnected environments.</simpara>
</listitem>
</itemizedlist>
<simpara>Each method deploys a cluster with the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara>Highly available infrastructure with no single points of failure, which is available by default.</simpara>
</listitem>
<listitem>
<simpara>Administrators can control what updates are applied and when.</simpara>
</listitem>
</itemizedlist>
<section xml:id="about-the-installation-program">
<title>About the installation program</title>
<simpara>You can use the installation program to deploy each type of cluster. The installation program generates the main assets, such as Ignition config files for the bootstrap, control plane, and compute machines. You can start an {product-title} cluster with these three machine configurations, provided you correctly configured the infrastructure.</simpara>
<simpara>The {product-title} installation program uses a set of targets and dependencies to manage cluster installations. The installation program has a set of targets that it must achieve, and each target has a set of dependencies. Because each target is only concerned with its own dependencies, the installation program can act to achieve multiple targets in parallel with the ultimate target being a running cluster. The installation program recognizes and uses existing components instead of running commands to create them again because the program meets the dependencies.</simpara>
<figure>
<title>{product-title} installation targets and dependencies</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/targets-and-dependencies.png"/>
</imageobject>
<textobject><phrase>{product-title} installation targets and dependencies</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="about-rhcos">
<title>About Red Hat Enterprise Linux CoreOS (RHCOS)</title>
<simpara>Post-installation, each cluster machine uses Red Hat Enterprise Linux CoreOS (RHCOS) as the operating system. RHCOS is the immutable container host version of Red Hat Enterprise Linux (RHEL) and features a RHEL kernel with SELinux enabled by default. RHCOS includes the <literal>kubelet</literal>, which is the Kubernetes node agent, and the CRI-O container runtime, which is optimized for Kubernetes.</simpara>
<simpara>Every control plane machine in an {product-title} {product-version} cluster must use RHCOS, which includes a critical first-boot provisioning tool called Ignition. This tool enables the cluster to configure the machines. Operating system updates are delivered as a bootable container image, using <emphasis role="strong">OSTree</emphasis> as a backend, that is deployed across the cluster by the Machine Config Operator. Actual operating system changes are made in-place on each machine as an atomic operation by using <emphasis role="strong">rpm-ostree</emphasis>. Together, these technologies enable {product-title} to manage the operating system like it manages any other application on the cluster, by in-place upgrades that keep the entire platform up to date. These in-place updates can reduce the burden on operations teams.</simpara>
<simpara>If you use RHCOS as the operating system for all cluster machines, the cluster manages all aspects of its components and machines, including the operating system. Because of this, only the installation program and the Machine Config Operator can change machines. The installation program uses Ignition config files to set the exact state of each machine, and the Machine Config Operator completes more changes to the machines, such as the application of new certificates or keys, after installation.</simpara>
</section>
<section xml:id="supported-platforms-for-openshift-clusters_architecture-installation">
<title>Supported platforms for {product-title} clusters</title>
<simpara>In {product-title} {product-version}, you can install a cluster that uses installer-provisioned infrastructure on the following platforms:</simpara>
<itemizedlist>
<listitem>
<simpara>Alibaba Cloud</simpara>
</listitem>
<listitem>
<simpara>Amazon Web Services (AWS)</simpara>
</listitem>
<listitem>
<simpara>Bare metal</simpara>
</listitem>
<listitem>
<simpara>Google Cloud Platform (GCP)</simpara>
</listitem>
<listitem>
<simpara>IBM Cloud&#174;</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure Stack Hub</simpara>
</listitem>
<listitem>
<simpara>Nutanix</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenStack Platform (RHOSP)</simpara>
<itemizedlist>
<listitem>
<simpara>The latest {product-title} release supports both the latest RHOSP long-life release and intermediate release. For complete RHOSP release compatibility, see the <link xl:href="https://access.redhat.com/articles/4679401">{product-title} on RHOSP support matrix</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>VMware vSphere</simpara>
</listitem>
</itemizedlist>
<simpara>For these clusters, all machines, including the computer that you run the installation process on, must have direct internet access to pull images for platform containers and provide telemetry data to Red Hat.</simpara>
<important>
<simpara>After installation, the following changes are not supported:</simpara>
<itemizedlist>
<listitem>
<simpara>Mixing cloud provider platforms.</simpara>
</listitem>
<listitem>
<simpara>Mixing cloud provider components. For example, using a persistent storage framework from a another platform on the platform where you installed the cluster.</simpara>
</listitem>
</itemizedlist>
</important>
<simpara>In {product-title} {product-version}, you can install a cluster that uses user-provisioned infrastructure on the following platforms:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS</simpara>
</listitem>
<listitem>
<simpara>Azure</simpara>
</listitem>
<listitem>
<simpara>Azure Stack Hub</simpara>
</listitem>
<listitem>
<simpara>Bare metal</simpara>
</listitem>
<listitem>
<simpara>GCP</simpara>
</listitem>
<listitem>
<simpara>IBM Power&#174;</simpara>
</listitem>
<listitem>
<simpara>IBM Z&#174; or IBM&#174; LinuxONE</simpara>
</listitem>
<listitem>
<simpara>RHOSP</simpara>
<itemizedlist>
<listitem>
<simpara>The latest {product-title} release supports both the latest RHOSP long-life release and intermediate release. For complete RHOSP release compatibility, see the <link xl:href="https://access.redhat.com/articles/4679401">{product-title} on RHOSP support matrix</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>VMware Cloud on AWS</simpara>
</listitem>
<listitem>
<simpara>VMware vSphere</simpara>
</listitem>
</itemizedlist>
<simpara>Depending on the supported cases for the platform, you can perform installations on user-provisioned infrastructure, so that you can run machines with full internet access, place your cluster behind a proxy, or perform a disconnected installation.</simpara>
<simpara>In a disconnected installation, you can download the images that are required to install a cluster, place them in a mirror registry, and use that data to install your cluster. While you require internet access to pull images for platform containers, with a disconnected installation on vSphere or bare metal infrastructure, your cluster machines do not require direct internet access.</simpara>
<simpara>The <link xl:href="https://access.redhat.com/articles/4128421">OpenShift Container Platform 4.x Tested Integrations</link> page contains details about integration testing for different platforms.</simpara>
</section>
<section xml:id="installation-process_architecture-installation">
<title>Installation process</title>
<simpara>Except for the Assisted Installer, when you install an {product-title} cluster, you must download the installation program from
the appropriate <link xl:href="https://console.redhat.com/openshift/create"><emphasis role="strong">Cluster Type</emphasis></link> page on the OpenShift Cluster Manager Hybrid Cloud Console. This console manages:</simpara>
<itemizedlist>
<listitem>
<simpara>REST API for accounts.</simpara>
</listitem>
<listitem>
<simpara>Registry tokens, which are the pull secrets that you use to obtain the required components.</simpara>
</listitem>
<listitem>
<simpara>Cluster registration, which associates the cluster identity to your Red Hat account to facilitate the gathering of usage metrics.</simpara>
</listitem>
</itemizedlist>
<simpara>In {product-title} {product-version}, the installation program is a Go binary file that performs a series of file transformations on a set of assets. The way you interact with the installation program differs depending on your installation type. Consider the following installation use cases:</simpara>
<itemizedlist>
<listitem>
<simpara>To deploy a cluster with the Assisted Installer, you must configure the cluster settings by using the <link xl:href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform">Assisted Installer</link>. There is no installation program to download and configure. After you finish setting the cluster configuration, you download a discovery ISO and then boot cluster machines with that image. You can install clusters with the Assisted Installer on Nutanix, vSphere, and bare metal with full integration, and other platforms without integration. If you install on bare metal, you must provide all of the cluster infrastructure and resources, including the networking, load balancing, storage, and individual cluster machines.</simpara>
</listitem>
<listitem>
<simpara>To deploy clusters with the Agent-based Installer, you can download the <link xl:href="https://console.redhat.com/openshift/install/metal/agent-based">Agent-based Installer</link> first. You can then configure the cluster and generate a discovery image. You boot cluster machines with the discovery image, which installs an agent that communicates with the installation program and handles the provisioning for you instead of you interacting with the installation program or setting up a provisioner machine yourself. You must provide all of the cluster infrastructure and resources, including the networking, load balancing, storage, and individual cluster machines. This approach is ideal for disconnected environments.</simpara>
</listitem>
<listitem>
<simpara>For clusters with installer-provisioned infrastructure, you delegate the infrastructure bootstrapping and provisioning to the installation program instead of doing it yourself. The installation program creates all of the networking, machines, and operating systems that are required to support the cluster, except if you install on bare metal. If you install on bare metal, you must provide all of the cluster infrastructure and resources, including the bootstrap machine, networking, load balancing, storage, and individual cluster machines.</simpara>
</listitem>
<listitem>
<simpara>If you provision and manage the infrastructure for your cluster, you must provide all of the cluster infrastructure and resources, including the bootstrap machine, networking, load balancing, storage, and individual cluster machines.</simpara>
</listitem>
</itemizedlist>
<simpara>For the installation program, the program uses three sets of files during installation: an installation configuration file that is named <literal>install-config.yaml</literal>, Kubernetes manifests, and Ignition config files for your machine types.</simpara>
<important>
<simpara>You can modify Kubernetes and the Ignition config files that control the underlying RHCOS operating system during installation. However, no validation is available to confirm the suitability of any modifications that you make to these objects. If you modify these objects, you might render your cluster non-functional. Because of this risk, modifying Kubernetes and Ignition config files is not supported unless you are following documented procedures or are instructed to do so by Red Hat support.</simpara>
</important>
<simpara>The installation configuration file is transformed into Kubernetes manifests, and then the manifests are wrapped into Ignition config files. The installation program uses these Ignition config files to create the cluster.</simpara>
<simpara>The installation configuration files are all pruned when you run the installation program, so be sure to back up all the configuration files that you want to use again.</simpara>
<important>
<simpara>You cannot modify the parameters that you set during installation, but you can modify many cluster attributes after installation.</simpara>
</important>
<bridgehead xml:id="_the_installation_process_with_the_assisted_installer" renderas="sect4">The installation process with the Assisted Installer</bridgehead>
<simpara>Installation with the <link xl:href="https://access.redhat.com/documentation/en-us/assisted_installer_for_openshift_container_platform">Assisted Installer</link> involves creating a cluster configuration interactively by using the web-based user interface or the RESTful API. The Assisted Installer user interface prompts you for required values and provides reasonable default values for the remaining parameters, unless you change them in the user interface or with the API.  The Assisted Installer generates a discovery image, which you download and use to boot the cluster machines. The image installs RHCOS and an agent, and the agent handles the provisioning for you. You can install {product-title} with the Assisted Installer and full integration on Nutanix, vSphere, and bare metal. Additionally, you can install {product-title} with the Assisted Installer on other platforms without integration.</simpara>
<simpara>{product-title} manages all aspects of the cluster, including the operating system itself. Each machine boots with a configuration that references resources hosted in the cluster that it joins. This configuration allows the cluster to manage itself as updates are applied.</simpara>
<simpara>If possible, use the Assisted Installer feature to avoid having to download and configure the Agent-based Installer.</simpara>
<bridgehead xml:id="_the_installation_process_with_agent_based_infrastructure" renderas="sect4">The installation process with Agent-based infrastructure</bridgehead>
<simpara>Agent-based installation is similar to using the Assisted Installer, except that you must initially download and install the <link xl:href="https://console.redhat.com/openshift/install/metal/agent-based">Agent-based Installer</link>. An Agent-based installation is useful when you want the convenience of the Assisted Installer, but you need to install a cluster in a disconnected environment.</simpara>
<simpara>If possible, use the Agent-based installation feature to avoid having to create a provisioner machine with a bootstrap VM, and then provision and maintain the cluster infrastructure.</simpara>
<bridgehead xml:id="_the_installation_process_with_installer_provisioned_infrastructure" renderas="sect4">The installation process with installer-provisioned infrastructure</bridgehead>
<simpara>The default installation type uses installer-provisioned infrastructure. By default, the installation program acts as an installation wizard, prompting you for values that it cannot determine on its own and providing reasonable default values for the remaining parameters. You can also customize the installation process to support advanced infrastructure scenarios. The installation program provisions the underlying infrastructure for the cluster.</simpara>
<simpara>You can install either a standard cluster or a customized cluster. With a standard cluster, you provide minimum details that are required to install the cluster. With a customized cluster, you can specify more details about the platform, such as the number of machines that the control plane uses, the type of virtual machine that the cluster deploys, or the CIDR range for the Kubernetes service network.</simpara>
<simpara>If possible, use this feature to avoid having to provision and maintain the cluster infrastructure. In all other environments, you use the installation program to generate the assets that you require to provision your cluster infrastructure.</simpara>
<simpara>With installer-provisioned infrastructure clusters, {product-title} manages all aspects of the cluster, including the operating system itself. Each machine boots with a configuration that references resources hosted in the cluster that it joins. This configuration allows the cluster to manage itself as updates are applied.</simpara>
<bridgehead xml:id="_the_installation_process_with_user_provisioned_infrastructure" renderas="sect4">The installation process with user-provisioned infrastructure</bridgehead>
<simpara>You can also install {product-title} on infrastructure that you provide. You use the installation program to generate the assets that you require to provision the cluster infrastructure, create the cluster infrastructure, and then deploy the cluster to the infrastructure that you provided.</simpara>
<simpara>If you do not use infrastructure that the installation program provisioned, you must manage and maintain the cluster resources yourself. The following list details some of these self-managed resources:</simpara>
<itemizedlist>
<listitem>
<simpara>The underlying infrastructure for the control plane and compute machines that make up the cluster</simpara>
</listitem>
<listitem>
<simpara>Load balancers</simpara>
</listitem>
<listitem>
<simpara>Cluster networking, including the DNS records and required subnets</simpara>
</listitem>
<listitem>
<simpara>Storage for the cluster infrastructure and applications</simpara>
</listitem>
</itemizedlist>
<simpara>If your cluster uses user-provisioned infrastructure, you have the option of adding RHEL compute machines to your cluster.</simpara>
<bridgehead xml:id="_installation_process_details" renderas="sect4">Installation process details</bridgehead>
<simpara>When a cluster is provisioned, each machine in the cluster requires information about the cluster. {product-title} uses a temporary bootstrap machine during initial configuration to provide the required information to the permanent control plane. The temporary bootstrap machine boots by using an Ignition config file that describes how to create the cluster. The bootstrap machine creates the control plane machines that make up the control plane. The control plane machines then create the compute machines, which are also known as worker machines. The following figure illustrates this process:</simpara>
<figure>
<title>Creating the bootstrap, control plane, and compute machines</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/create-nodes.png" contentwidth="control plane" contentdepth="and compute machines"/>
</imageobject>
<textobject><phrase>Creating bootstrap</phrase></textobject>
</mediaobject>
</figure>
<simpara>After the cluster machines initialize, the bootstrap machine is destroyed. All clusters use the bootstrap process to initialize the cluster, but if you provision the infrastructure for your cluster, you must complete many of the steps manually.</simpara>
<important>
<itemizedlist>
<listitem>
<simpara>The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending <literal>node-bootstrapper</literal> certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for <emphasis>Recovering from expired control plane certificates</emphasis> for more information.</simpara>
</listitem>
<listitem>
<simpara>Consider using Ignition config files within 12 hours after they are generated, because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.</simpara>
</listitem>
</itemizedlist>
</important>
<simpara>Bootstrapping a cluster involves the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The bootstrap machine boots and starts hosting the remote resources required for the control plane machines to boot. If you provision the infrastructure, this step requires manual intervention.</simpara>
</listitem>
<listitem>
<simpara>The bootstrap machine starts a single-node etcd cluster and a temporary Kubernetes control plane.</simpara>
</listitem>
<listitem>
<simpara>The control plane machines fetch the remote resources from the bootstrap machine and finish booting. If you provision the infrastructure, this step requires manual intervention.</simpara>
</listitem>
<listitem>
<simpara>The temporary control plane schedules the production control plane to the production control plane machines.</simpara>
</listitem>
<listitem>
<simpara>The Cluster Version Operator (CVO) comes online and installs the etcd Operator. The etcd Operator scales up etcd on all control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>The temporary control plane shuts down and passes control to the production control plane.</simpara>
</listitem>
<listitem>
<simpara>The bootstrap machine injects {product-title} components into the production control plane.</simpara>
</listitem>
<listitem>
<simpara>The installation program shuts down the bootstrap machine. If you provision the infrastructure, this step requires manual intervention.</simpara>
</listitem>
<listitem>
<simpara>The control plane sets up the compute nodes.</simpara>
</listitem>
<listitem>
<simpara>The control plane installs additional services in the form of a set of Operators.</simpara>
</listitem>
</orderedlist>
<simpara>The result of this bootstrapping process is a running {product-title} cluster. The cluster then downloads and configures remaining components needed for the day-to-day operations, including the creation of compute machines in supported environments.</simpara>
<bridgehead xml:id="_installation_scope" renderas="sect3">Installation scope</bridgehead>
<simpara>The scope of the {product-title} installation program is intentionally narrow. It is designed for simplicity and ensured success. You can complete many more configuration tasks after installation completes.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../post_installation_configuration/cluster-tasks.xml#available_cluster_customizations">Available cluster customizations</link> for details about {product-title} configuration resources.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="update-service-about_architecture-installation">
<title>About the OpenShift Update Service</title>
<simpara>The OpenShift Update Service (OSUS) provides update recommendations to {product-title}, including Red Hat Enterprise Linux CoreOS (RHCOS). It provides a graph, or diagram, that contains the <emphasis>vertices</emphasis> of component Operators and the <emphasis>edges</emphasis> that connect them. The edges in the graph show which versions you can safely update to. The vertices are update payloads that specify the intended state of the managed cluster components.</simpara>
<simpara>The Cluster Version Operator (CVO) in your cluster checks with the OpenShift Update Service to see the valid updates and update paths based on current component versions and information in the graph. When you request an update, the CVO uses the corresponding release image to update your cluster. The release artifacts are hosted in Quay as container images.</simpara>
<simpara>To allow the OpenShift Update Service to provide only compatible updates, a release verification pipeline drives automation. Each release artifact is verified for compatibility with supported cloud platforms and system architectures, as well as other component packages. After the pipeline confirms the suitability of a release, the OpenShift Update Service notifies you that it is available.</simpara>
<important>
<simpara>The OpenShift Update Service displays all recommended updates for your current cluster.  If an update path is not recommended by the OpenShift Update Service, it might be because of a known issue with the update or the target release.</simpara>
</important>
<simpara>Two controllers run during continuous update mode. The first controller continuously updates the payload manifests, applies the manifests to the cluster, and outputs the controlled rollout status of the Operators to indicate whether they are available, upgrading, or failed. The second controller polls the OpenShift Update Service to determine if updates are available.</simpara>
<important>
<simpara>Only updating to a newer version is supported. Reverting or rolling back your cluster to a previous version is not supported. If your update fails, contact Red Hat support.</simpara>
</important>
<simpara>During the update process, the Machine Config Operator (MCO) applies the new configuration to your cluster machines. The MCO cordons the number of nodes specified by the <literal>maxUnavailable</literal> field on the machine configuration pool and marks them unavailable. By default, this value is set to <literal>1</literal>. The MCO updates the affected nodes alphabetically by zone, based on the <literal>topology.kubernetes.io/zone</literal> label. If a zone has more than one node, the oldest nodes are updated first. For nodes that do not use zones, such as in bare metal deployments, the nodes are updated by age, with the oldest nodes updated first. The MCO updates the number of nodes as specified by the <literal>maxUnavailable</literal> field on the machine configuration pool at a time. The MCO then applies the new configuration and reboots the machine.</simpara>
<simpara>If you use Red Hat Enterprise Linux (RHEL) machines as workers, the MCO does not update the kubelet because you must update the OpenShift API on the machines first.</simpara>
<simpara>With the specification for the new version applied to the old kubelet, the RHEL machine cannot return to the <literal>Ready</literal> state. You cannot complete the update until the machines are available. However, the maximum number of unavailable nodes is set to ensure that normal cluster operations can continue with that number of machines out of service.</simpara>
<simpara>The OpenShift Update Service is composed of an Operator and one or more application instances.</simpara>
</section>
<section xml:id="unmanaged-operators_architecture-installation">
<title>Support policy for unmanaged Operators</title>
<simpara>The <emphasis>management state</emphasis> of an Operator determines whether an Operator is actively
managing the resources for its related component in the cluster as designed. If
an Operator is set to an <emphasis>unmanaged</emphasis> state, it does not respond to changes in
configuration nor does it receive updates.</simpara>
<simpara>While this can be helpful in non-production clusters or during debugging,
Operators in an unmanaged state are unsupported and the cluster administrator
assumes full control of the individual component configurations and upgrades.</simpara>
<simpara>An Operator can be set to an unmanaged state using the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Individual Operator configuration</emphasis></simpara>
<simpara>Individual Operators have a <literal>managementState</literal> parameter in their configuration.
This can be accessed in different ways, depending on the Operator. For example,
the Red Hat OpenShift Logging Operator accomplishes this by modifying a custom resource
(CR) that it manages, while the Cluster Samples Operator uses a cluster-wide
configuration resource.</simpara>
<simpara>Changing the <literal>managementState</literal> parameter to <literal>Unmanaged</literal> means that the Operator
is not actively managing its resources and will take no action related to the
related component. Some Operators might not support this management state as it
might damage the cluster and require manual recovery.</simpara>
<warning>
<simpara>Changing individual Operators to the <literal>Unmanaged</literal> state renders that particular
component and functionality unsupported. Reported issues must be reproduced in
<literal>Managed</literal> state for support to proceed.</simpara>
</warning>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cluster Version Operator (CVO) overrides</emphasis></simpara>
<simpara>The <literal>spec.overrides</literal> parameter can be added to the CVO&#8217;s configuration to allow
administrators to provide a list of overrides to the CVO&#8217;s behavior for a
component. Setting the <literal>spec.overrides[].unmanaged</literal> parameter to <literal>true</literal> for a
component blocks cluster upgrades and alerts the administrator after a CVO
override has been set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">Disabling ownership via cluster version overrides prevents upgrades. Please remove overrides before continuing.</programlisting>
<warning>
<simpara>Setting a CVO override puts the entire cluster in an unsupported state. Reported
issues must be reproduced after removing any overrides for support to proceed.</simpara>
</warning>
</listitem>
</itemizedlist>
</section>
<section xml:id="architecture-installation-next-steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../installing/installing-preparing.xml#installing-preparing">Selecting a cluster installation method and preparing it for users</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="ocm-overview-ocp">
<title>Red Hat OpenShift Cluster Manager</title>

<simpara>Red Hat OpenShift Cluster Manager is a managed service where you can install, modify, operate, and upgrade your Red Hat OpenShift clusters. This service allows you to work with all of your organization’s clusters from a single dashboard.</simpara>
<simpara>OpenShift Cluster Manager guides you to install OpenShift Container Platform, Red Hat OpenShift Service on AWS (ROSA), and OpenShift Dedicated clusters. It is also responsible for managing both OpenShift Container Platform clusters after self-installation as well as your ROSA and OpenShift Dedicated clusters.</simpara>
<simpara>You can use OpenShift Cluster Manager to do the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create new clusters</simpara>
</listitem>
<listitem>
<simpara>View cluster details and metrics</simpara>
</listitem>
<listitem>
<simpara>Manage your clusters with tasks such as scaling, changing node labels, networking, authentication</simpara>
</listitem>
<listitem>
<simpara>Manage access control</simpara>
</listitem>
<listitem>
<simpara>Monitor clusters</simpara>
</listitem>
<listitem>
<simpara>Schedule upgrades</simpara>
</listitem>
</itemizedlist>
<section xml:id="accessing-ocm_ocm-overview-ocp">
<title>Accessing Red Hat OpenShift Cluster Manager</title>
<simpara>You can access OpenShift Cluster Manager with your configured OpenShift account.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have an account that is part of an OpenShift organization.</simpara>
</listitem>
<listitem>
<simpara>If you are creating a cluster, your organization has specified quota.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Log in to <link xl:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link> using your login credentials.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ocm-general-actions-ocp">
<title>General actions</title>
<simpara>On the top right of the cluster page, there are some actions that a user can perform on the entire cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Open console</emphasis> launches a web console so that the cluster owner can issue commands to the cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Actions</emphasis> drop-down menu allows the cluster owner to rename the display name of the cluster, change the amount of load balancers and persistent storage on the cluster, if applicable, manually set the node count, and delete the cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Refresh</emphasis> icon forces a refresh of the cluster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ocm-cluster-tabs-ocp">
<title>Cluster tabs</title>
<simpara>Selecting an active, installed cluster shows tabs associated with that cluster. The following tabs display after the cluster&#8217;s installation completes:</simpara>
<itemizedlist>
<listitem>
<simpara>Overview</simpara>
</listitem>
<listitem>
<simpara>Access control</simpara>
</listitem>
<listitem>
<simpara>Add-ons</simpara>
</listitem>
<listitem>
<simpara>Networking</simpara>
</listitem>
<listitem>
<simpara>Insights Advisor</simpara>
</listitem>
<listitem>
<simpara>Machine pools</simpara>
</listitem>
<listitem>
<simpara>Support</simpara>
</listitem>
<listitem>
<simpara>Settings</simpara>
</listitem>
</itemizedlist>
<section xml:id="ocm-overview-tab_ocm-overview-ocp">
<title>Overview tab</title>
<simpara>The <emphasis role="strong">Overview</emphasis> tab provides information about how your cluster was configured:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Cluster ID</emphasis> is the unique identification for the created cluster. This ID can be used when issuing commands to the cluster from the command line.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Type</emphasis> shows the OpenShift version that the cluster is using.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Region</emphasis> is the server region.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Provider</emphasis> shows which cloud provider that the cluster was built upon.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Availability</emphasis> shows which type of availability zone that the cluster uses, either single or multizone.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Version</emphasis> is the OpenShift version that is installed on the cluster. If there is an update available, you can update from this field.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Created at</emphasis> shows the date and time that the cluster was created.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Owner</emphasis> identifies who created the cluster and has owner rights.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Subscription type</emphasis> shows the subscription model that was selected on creation.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Infrastructure type</emphasis> is the type of account that the cluster uses.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Status</emphasis> displays the current status of the cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Total vCPU</emphasis> shows the total available virtual CPU for this cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Total memory</emphasis> shows the total available memory for this cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Load balancers</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Persistent storage</emphasis> displays the amount of storage that is available on this cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Nodes</emphasis> shows the actual and desired nodes on the cluster. These numbers might not match due to cluster scaling.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Network</emphasis> field shows the address and prefixes for network connectivity.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Resource usage</emphasis> section of the tab displays the resources in use with a graph.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Advisor recommendations</emphasis> section gives insight in relation to security, performance, availability, and stablility. This section requires the use of remote health functionality. See <emphasis>Using Insights to identify issues with your cluster</emphasis> in the <emphasis>Additional resources</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cluster history</emphasis> section shows everything that has been done with the cluster including creation and when a new version is identified.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ocm-accesscontrol-tab_ocm-overview-ocp">
<title>Access control tab</title>
<simpara>The <emphasis role="strong">Access control</emphasis> tab allows the cluster owner to set up an identity provider, grant elevated permissions, and grant roles to other users.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must be the cluster owner or have the correct permissions to grant roles on the cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Select the <emphasis role="strong">Grant role</emphasis> button.</simpara>
</listitem>
<listitem>
<simpara>Enter the Red Hat account login for the user that you wish to grant a role on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Grant role</emphasis> button on the dialog box.</simpara>
</listitem>
<listitem>
<simpara>The dialog box closes, and the selected user shows the "Cluster Editor" access.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="ocm-addons-tab_ocm-overview-ocp">
<title>Add-ons tab</title>
<simpara>The <emphasis role="strong">Add-ons</emphasis> tab displays all of the optional add-ons that can be added to the cluster. Select the desired add-on, and then select <emphasis role="strong">Install</emphasis> below the description for the add-on that displays.</simpara>
</section>
<section xml:id="ocm-insightsadvisor-tab_ocm-overview-ocp">
<title>Insights Advisor tab</title>
<simpara>The <emphasis role="strong">Insights Advisor</emphasis> tab uses the Remote Health functionality of the OpenShift Container Platform to identify and mitigate risks to security, performance, availability, and stability. See <link xl:href="https://docs.openshift.com/container-platform/latest/support/getting-support.html">Using Insights to identify issues with your cluster</link> in the OpenShift Container Platform documentation.</simpara>
</section>
<section xml:id="ocm-machinepools-tab_ocm-overview-ocp">
<title>Machine pools tab</title>
<simpara>The <emphasis role="strong">Machine pools</emphasis> tab allows the cluster owner to create new machine pools, if there is enough available quota, or edit an existing machine pool.</simpara>
<simpara>Selecting the <emphasis role="strong">More options</emphasis> &gt; <emphasis role="strong">Scale</emphasis> opens the "Edit node count" dialog. In this dialog, you can change the node count per availability zone. If autoscaling is enabled, you can also set the range for autoscaling.</simpara>
</section>
<section xml:id="ocm-support-tab_ocm-overview-ocp">
<title>Support tab</title>
<simpara>In the <emphasis role="strong">Support</emphasis> tab, you can add notification contacts for individuals that should receive cluster notifications. The username or email address that you provide must relate to a user account in the Red Hat organization where the cluster is deployed.</simpara>
<simpara>Also from this tab, you can open a support case to request technical support for your cluster.</simpara>
</section>
<section xml:id="ocm-settings-tab_ocm-overview-ocp">
<title>Settings tab</title>
<simpara>The <emphasis role="strong">Settings</emphasis> tab provides a few options for the cluster owner:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Monitoring</emphasis>, which is enabled by default, allows for reporting done on user-defined actions. See <link xl:href="https://docs.openshift.com/rosa/monitoring/osd-understanding-the-monitoring-stack.html">Understanding the monitoring stack</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Update strategy</emphasis> allows you to determine if the cluster automatically updates on a certain day of the week at a specified time or if all updates are scheduled manually.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Node draining</emphasis> sets the duration that protected workloads are respected during updates. When this duration has passed, the node is forcibly removed.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Update status</emphasis> shows the current version and if there are any updates available.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ocm-additional-resources-ocp">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>For the complete documentation for OpenShift Cluster Manager, see <link xl:href="https://access.redhat.com/documentation/en-us/openshift_cluster_manager/2022/html-single/managing_clusters/index">OpenShift Cluster Manager documentation</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="mce-overview-ocp">
<title>About multicluster engine for Kubernetes operator</title>

<simpara>One of the challenges of scaling Kubernetes environments is managing the lifecycle of a growing fleet. To meet that challenge, you can use multicluster engine for Kubernetes operator (MCE). The operator delivers full lifecycle capabilities for managed {product-title} clusters and partial lifecycle management for other Kubernetes distributions. It is available in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>As a standalone operator that you install as part of your {product-title} or OpenShift Kubernetes Engine subscription</simpara>
</listitem>
<listitem>
<simpara>As part of <link xl:href="https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes">Red Hat Advanced Cluster Management for Kubernetes</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="mce-on-ocp">
<title>Cluster management with multicluster engine on {product-title}</title>
<simpara>When you enable multicluster engine on {product-title}, you gain the following capabilities:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../architecture/control-plane.xml#hosted-control-planes-overview_control-plane">Hosted control planes</link>, which is a feature that is based on the HyperShift project. With a centralized hosted control plane, you can operate {product-title} clusters in a hyperscale manner.</simpara>
</listitem>
<listitem>
<simpara>Hive, which provisions self-managed {product-title} clusters to the hub and completes the initial configurations for those clusters.</simpara>
</listitem>
<listitem>
<simpara>klusterlet agent, which registers managed clusters to the hub.</simpara>
</listitem>
<listitem>
<simpara>Infrastructure Operator, which manages the deployment of the Assisted Service to orchestrate on-premise bare metal and vSphere installations of {product-title}, such as SNO on bare metal. The Infrastructure Operator includes <link xl:href="../scalability_and_performance/ztp_far_edge/ztp-deploying-far-edge-clusters-at-scale.xml#ztp-challenges-of-far-edge-deployments_ztp-deploying-far-edge-clusters-at-scale">GitOps Zero Touch Provisioning (ZTP)</link>, which fully automates cluster creation on bare metal and vSphere provisioning with GitOps workflows to manage deployments and configuration changes.</simpara>
</listitem>
<listitem>
<simpara>Open cluster management, which provides resources to manage Kubernetes clusters.</simpara>
</listitem>
</itemizedlist>
<simpara>The multicluster engine is included with your {product-title} support subscription and is delivered separately from the core payload. To start to use multicluster engine, you deploy the {product-title} cluster and then install the operator. For more information, see <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#mce-install-intro">Installing and upgrading multicluster engine operator</link>.</simpara>
</section>
<section xml:id="mce-on-rhacm">
<title>Cluster management with Red Hat Advanced Cluster Management</title>
<simpara>If you need cluster management capabilities beyond what {product-title} with multicluster engine can provide, consider Red Hat Advanced Cluster Management. The multicluster engine is an integral part of Red Hat Advanced Cluster Management and is enabled by default.</simpara>
</section>
<section xml:id="mce-additional-resources-ocp">
<title>Additional resources</title>
<simpara>For the complete documentation for multicluster engine, see <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#doc-wrapper">Cluster lifecycle with multicluster engine documentation</link>, which is part of the product documentation for Red Hat Advanced Cluster Management.</simpara>
</section>
</chapter>
<chapter xml:id="control-plane">
<title>Control plane architecture</title>

<simpara>The <emphasis>control plane</emphasis>, which is composed of control plane machines, manages the {product-title} cluster. The control plane machines manage workloads on the compute machines, which are also known as worker machines. The cluster itself manages all upgrades to the machines by the actions of the Cluster Version Operator (CVO), the Machine Config Operator, and a set of individual Operators.</simpara>
<section xml:id="architecture-machine-config-pools_control-plane">
<title>Node configuration management with machine config pools</title>
<simpara>Machines that run control plane components or user workloads are divided into groups based on the types of resources they handle. These groups of machines are called machine config pools (MCP). Each MCP manages a set of nodes and its corresponding machine configs. The role of the node determines which MCP it belongs to; the MCP governs nodes based on its assigned node role label. Nodes in an MCP have the same configuration; this means nodes can be scaled up and torn down in response to increased or decreased workloads.</simpara>
<simpara>By default, there are two MCPs created by the cluster when it is installed: <literal>master</literal> and <literal>worker</literal>. Each default MCP has a defined configuration applied by the Machine Config Operator (MCO), which is responsible for managing MCPs and facilitating MCP upgrades. You can create additional MCPs, or custom pools, to manage nodes that have custom use cases that extend outside of the default node types.</simpara>
<simpara>Custom pools are pools that inherit their configurations from the worker pool. They use any machine config targeted for the worker pool, but add the ability to deploy changes only targeted at the custom pool. Since a custom pool inherits its configuration from the worker pool, any change to the worker pool is applied to the custom pool as well. Custom pools that do not inherit their configurations from the worker pool are not supported by the MCO.</simpara>
<note>
<simpara>A node can only be included in one MCP. If a node has multiple labels that correspond to several MCPs, like <literal>worker,infra</literal>, it is managed by the infra custom pool, not the worker pool. Custom pools take priority on selecting nodes to manage based on node labels; nodes that do not belong to a custom pool are managed by the worker pool.</simpara>
</note>
<simpara>It is recommended to have a custom pool for every node role you want to manage in your cluster. For example, if you create infra nodes to handle infra workloads, it is recommended to create a custom infra MCP to group those nodes together. If you apply an <literal>infra</literal> role label to a worker node so it has the <literal>worker,infra</literal> dual label, but do not have a custom infra MCP, the MCO considers it a worker node. If you remove the <literal>worker</literal> label from a node and apply the <literal>infra</literal> label without grouping it in a custom pool, the node is not recognized by the MCO and is unmanaged by the cluster.</simpara>
<important>
<simpara>Any node labeled with the <literal>infra</literal> role that is only running infra workloads is not counted toward the total number of subscriptions. The MCP managing an infra node is mutually exclusive from how the cluster determines subscription charges; tagging a node with the appropriate <literal>infra</literal> role and using taints to prevent user workloads from being scheduled on that node are the only requirements for avoiding subscription charges for infra workloads.</simpara>
</important>
<simpara>The MCO applies updates for pools independently; for example, if there is an update that affects all pools, nodes from each pool update in parallel with each other. If you add a custom pool, nodes from that pool also attempt to update concurrently with the master and worker nodes.</simpara>
<simpara>There might be situations where the configuration on a node does not fully match what the currently-applied machine config specifies. This state is called <emphasis>configuration drift</emphasis>. The Machine Config Daemon (MCD) regularly checks the nodes for configuration drift. If the MCD detects configuration drift, the MCO marks the node <literal>degraded</literal> until an administrator corrects the node configuration. A degraded node is online and operational, but, it cannot be updated.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../post_installation_configuration/machine-configuration-tasks.xml#machine-config-drift-detection_post-install-machine-configuration-tasks">Understanding configuration drift detection</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="architecture-machine-roles_control-plane">
<title>Machine roles in {product-title}</title>
<simpara>{product-title} assigns hosts different roles. These roles define the function of the machine within the cluster. The cluster contains definitions for the standard <literal>master</literal> and <literal>worker</literal> role types.</simpara>
<note>
<simpara>The cluster also contains the definition for the <literal>bootstrap</literal> role. Because the bootstrap machine is used only during cluster installation, its function is explained in the cluster installation documentation.</simpara>
</note>
<section xml:id="_control_plane_and_node_host_compatibility">
<title>Control plane and node host compatibility</title>
<simpara>The {product-title} version must match between control plane host and node host. For example, in a {product-version} cluster, all control plane hosts must be {product-version} and all nodes must be {product-version}.</simpara>
<simpara>Temporary mismatches during cluster upgrades are acceptable. For example, when upgrading from the previous {product-title} version to {product-version}, some nodes will upgrade to {product-version} before others. Prolonged skewing of control plane hosts and node hosts might expose older compute machines to bugs and missing features. Users should resolve skewed control plane hosts and node hosts as soon as possible.</simpara>
<simpara>The <literal>kubelet</literal> service must not be newer than <literal>kube-apiserver</literal>, and can be up to two minor versions older depending on whether your {product-title} version is odd or even. The table below shows the appropriate version compatibility:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">{product-title} version</entry>
<entry align="left" valign="top">Supported <literal>kubelet</literal> skew</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Odd {product-title} minor versions <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Up to one version older</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Even {product-title} minor versions <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>Up to two versions older</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>For example, {product-title} 4.11, 4.13.</simpara>
</listitem>
<listitem>
<simpara>For example, {product-title} 4.10, 4.12.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="defining-workers_control-plane">
<title>Cluster workers</title>
<simpara>In a Kubernetes cluster, the worker nodes are where the actual workloads requested by Kubernetes users run and are managed. The worker nodes advertise their capacity and the scheduler, which a control plane service, determines on which nodes to start pods and containers. Important services run on each worker node, including CRI-O, which is the container engine; Kubelet, which is the service that accepts and fulfills requests for running and stopping container workloads; a service proxy, which manages communication for pods across workers; and the runC or crun low-level container runtime, which creates and runs containers.</simpara>
<note>
<simpara>For information about how to enable crun instead of the default runC, see the documentation for creating a <literal>ContainerRuntimeConfig</literal> CR.</simpara>
</note>
<simpara>In {product-title}, compute machine sets control the compute machines, which are assigned the <literal>worker</literal> machine role. Machines with the <literal>worker</literal> role drive compute workloads that are governed by a specific machine pool that autoscales them. Because {product-title} has the capacity to support multiple machine types, the machines with the <literal>worker</literal> role are classed as <emphasis>compute</emphasis> machines. In this release, the terms <emphasis>worker machine</emphasis> and <emphasis>compute machine</emphasis> are used interchangeably because the only default type of compute machine is the worker machine. In future versions of {product-title}, different types of compute machines, such as infrastructure machines, might be used by default.</simpara>
<note>
<simpara>Compute machine sets are groupings of compute machine resources under the <literal>machine-api</literal> namespace. Compute machine sets are configurations that are designed to start new compute machines on a specific cloud provider. Conversely, machine config pools (MCPs) are part of the Machine Config Operator (MCO) namespace. An MCP is used to group machines together so the MCO can manage their configurations and facilitate their upgrades.</simpara>
</note>
</section>
<section xml:id="defining-masters_control-plane">
<title>Cluster control planes</title>
<simpara>In a Kubernetes cluster, the <emphasis>master</emphasis> nodes run services that are required to control the Kubernetes cluster. In {product-title}, the control plane is comprised of control plane machines that have a <literal>master</literal> machine role. They contain more than just the Kubernetes services for managing the {product-title} cluster.</simpara>
<simpara>For most {product-title} clusters, control plane machines are defined by a series of standalone machine API resources. For supported cloud provider and {product-title} version combinations, control planes can be managed with control plane machine sets. Extra controls apply to control plane machines to prevent you from deleting all control plane machines and breaking your cluster.</simpara>
<note>
<simpara>Exactly three control plane nodes must be used for all production deployments.</simpara>
</note>
<simpara>Services that fall under the Kubernetes category on the control plane include the Kubernetes API server, etcd, the Kubernetes controller manager, and the Kubernetes scheduler.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Kubernetes services that run on the control plane</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API server</simpara></entry>
<entry align="left" valign="top"><simpara>The Kubernetes API server validates and configures the data for pods, services,
and replication controllers. It also provides a focal point for the shared state of the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>etcd</simpara></entry>
<entry align="left" valign="top"><simpara>etcd stores the persistent control plane state while other components watch etcd for
changes to bring themselves into the specified state.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes controller manager</simpara></entry>
<entry align="left" valign="top"><simpara>The Kubernetes controller manager watches etcd for changes to objects such as
replication, namespace, and service account controller objects, and then uses the
API to enforce the specified state. Several such processes create a cluster with
one active leader at a time.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes scheduler</simpara></entry>
<entry align="left" valign="top"><simpara>The Kubernetes scheduler watches for newly created pods without an assigned node and selects the best node to host the pod.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>There are also OpenShift services that run on the control plane, which include the OpenShift API server, OpenShift controller manager, OpenShift OAuth API server, and OpenShift OAuth server.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>OpenShift services that run on the control plane</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>OpenShift API server</simpara></entry>
<entry align="left" valign="top"><simpara>The OpenShift API server validates and configures the data for OpenShift resources, such as projects, routes, and templates.</simpara><simpara>The OpenShift API server is managed by the OpenShift API Server Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenShift controller manager</simpara></entry>
<entry align="left" valign="top"><simpara>The OpenShift controller manager watches etcd for changes to OpenShift objects, such as project, route, and template controller objects, and then uses the API to enforce the specified state.</simpara><simpara>The OpenShift controller manager is managed by the OpenShift Controller Manager Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenShift OAuth API server</simpara></entry>
<entry align="left" valign="top"><simpara>The OpenShift OAuth API server validates and configures the data to authenticate to {product-title}, such as users, groups, and OAuth tokens.</simpara><simpara>The OpenShift OAuth API server is managed by the Cluster Authentication Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenShift OAuth server</simpara></entry>
<entry align="left" valign="top"><simpara>Users request tokens from the OpenShift OAuth server to authenticate themselves to the API.</simpara><simpara>The OpenShift OAuth server is managed by the Cluster Authentication Operator.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Some of these services on the control plane machines run as systemd services, while others run as static pods.</simpara>
<simpara>Systemd services are appropriate for services that you need to always come up on that particular system shortly after it starts. For control plane machines, those include sshd, which allows remote login. It also includes services such as:</simpara>
<itemizedlist>
<listitem>
<simpara>The CRI-O container engine (crio), which runs and manages the containers. {product-title} {product-version} uses CRI-O instead of the Docker Container Engine.</simpara>
</listitem>
<listitem>
<simpara>Kubelet (kubelet), which accepts requests for managing containers on the machine from control plane services.</simpara>
</listitem>
</itemizedlist>
<simpara>CRI-O and Kubelet must run directly on the host as systemd services because they need to be running before you can run other containers.</simpara>
<simpara>The <literal>installer-*</literal> and <literal>revision-pruner-*</literal> control plane pods must run with root permissions because they write to the <literal>/etc/kubernetes</literal> directory, which is owned by the root user. These pods are in the following namespaces:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>openshift-etcd</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift-kube-apiserver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift-kube-controller-manager</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift-kube-scheduler</literal></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="operators-overview_control-plane">
<title>Operators in {product-title}</title>
<simpara>Operators are among the most important components of {product-title}. Operators are the preferred method of packaging, deploying, and managing services on the control plane. They can also provide advantages to applications that users run.</simpara>
<simpara>Operators integrate with Kubernetes APIs and CLI tools such as <literal>kubectl</literal> and <literal>oc</literal> commands. They provide the means of monitoring applications, performing health checks, managing over-the-air (OTA) updates, and ensuring that applications remain in your specified state.</simpara>
<simpara>Operators also offer a more granular configuration experience. You configure each component by modifying the API that the Operator exposes instead of modifying a global configuration file.</simpara>
<simpara>Because CRI-O and the Kubelet run on every node, almost every other cluster function can be managed on the control plane by using Operators. Components that are added to the control plane by using Operators include critical networking and credential services.</simpara>
<simpara>While both follow similar Operator concepts and goals, Operators in {product-title} are managed by two different systems, depending on their purpose:</simpara>
<itemizedlist>
<listitem>
<simpara>Cluster Operators, which are managed by the Cluster Version Operator (CVO), are installed by default to perform cluster functions.</simpara>
</listitem>
<listitem>
<simpara>Optional add-on Operators, which are managed by Operator Lifecycle Manager (OLM), can be made accessible for users to run in their applications.</simpara>
</listitem>
</itemizedlist>
<section xml:id="cluster-operators_control-plane">
<title>Cluster Operators</title>
<simpara>In {product-title}, all cluster functions are divided into a series of default <emphasis>cluster Operators</emphasis>. Cluster Operators manage a particular area of cluster functionality, such as cluster-wide application logging, management of the Kubernetes control plane, or the machine provisioning system.</simpara>
<simpara>Cluster Operators are represented by a <literal>ClusterOperator</literal> object, which
cluster administrators
can view in the {product-title} web console from the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> page. Each cluster Operator provides a simple API for determining cluster functionality. The Operator hides the details of managing the lifecycle of that component. Operators can manage a single component or tens of components, but the end goal is always to reduce operational burden by automating common actions.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../operators/operator-reference.xml#cluster-operators-ref">Cluster Operators reference</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-operators_control-plane">
<title>Add-on Operators</title>
<simpara>Operator Lifecycle Manager (OLM) and OperatorHub are default components in {product-title} that help manage Kubernetes-native applications as Operators. Together they provide the system for discovering, installing, and managing the optional add-on Operators available on the cluster.</simpara>
<simpara>Using OperatorHub in the {product-title} web console,
cluster administrators
and authorized users can select Operators to install from catalogs of Operators. After installing an Operator from OperatorHub, it can be made available globally or in specific namespaces to run in user applications.</simpara>
<simpara>Default catalog sources are available that include Red Hat Operators, certified Operators, and community Operators.
Cluster administrators
can also add their own custom catalog sources, which can contain a custom set of Operators.</simpara>
<simpara>Developers can use the Operator SDK to help author custom Operators that take advantage of OLM features, as well. Their Operator can then be bundled and added to a custom catalog source, which can be added to a cluster and made available to users.</simpara>
<note>
<simpara>OLM does not manage the cluster Operators that comprise the {product-title} architecture.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more details on running add-on Operators in {product-title}, see the <emphasis>Operators</emphasis> guide sections on <link xl:href="../operators/understanding/olm/olm-understanding-olm.xml#olm-understanding-olm">Operator Lifecycle Manager (OLM)</link> and <link xl:href="../operators/understanding/olm-understanding-operatorhub.xml#olm-understanding-operatorhub">OperatorHub</link>.</simpara>
</listitem>
<listitem>
<simpara>For more details on the Operator SDK, see <link xl:href="../operators/operator_sdk/osdk-about.xml#osdk-about">Developing Operators</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="platform-operators_control-plane">
<title>Platform Operators (Technology Preview)</title>
<important>
<simpara>The platform Operator type is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Operator Lifecycle Manager (OLM) introduces a new type of Operator called <emphasis>platform Operators</emphasis>. A platform Operator is an OLM-based Operator that can be installed during or after an {product-title} cluster&#8217;s Day 0 operations and participates in the cluster&#8217;s lifecycle. As a cluster administrator, you can use platform Operators to further customize your {product-title} installation to meet your requirements and use cases.</simpara>
<simpara>Using the existing cluster capabilities feature in {product-title}, cluster administrators can already disable a subset of Cluster Version Operator-based (CVO) components considered non-essential to the initial payload prior to cluster installation. Platform Operators iterate on this model by providing additional customization options. Through the platform Operator mechanism, which relies on resources from the RukPak component, OLM-based Operators can now be installed at cluster installation time and can block cluster rollout if the Operator fails to install successfully.</simpara>
<simpara>In {product-title} 4.12, this Technology Preview release focuses on the basic platform Operator mechanism and builds a foundation for expanding the concept in upcoming releases. You can use the cluster-wide <literal>PlatformOperator</literal> API to configure Operators before or after cluster creation on clusters that have enabled the <literal>TechPreviewNoUpgrades</literal> feature set.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../operators/admin/olm-managing-po.xml#olm-managing-po">Managing platform Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-managing-po.xml#olm-po-techpreview_olm-managing-po">Technology Preview restrictions for platform Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/understanding/olm-packaging-format.xml#olm-rukpak-about_olm-packaging-format">RukPak component and packaging format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#cluster-capabilities">Cluster capabilities</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="about-machine-config-operator_control-plane">
<title>About the Machine Config Operator</title>
<simpara>{product-title} {product-version} integrates both
operating system and cluster management. Because the cluster manages its own
updates, including updates to Red Hat Enterprise Linux CoreOS (RHCOS) on cluster nodes,
{product-title} provides an opinionated lifecycle management
experience that simplifies the orchestration of node upgrades.</simpara>
<simpara>{product-title} employs three daemon sets and controllers to
simplify node management. These daemon sets orchestrate operating system updates
and configuration changes to the hosts by using standard Kubernetes-style
constructs. They include:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>machine-config-controller</literal>, which coordinates machine upgrades from the control
plane. It monitors all of the cluster nodes and orchestrates their configuration
updates.</simpara>
</listitem>
<listitem>
<simpara>The <literal>machine-config-daemon</literal> daemon set, which runs on
each node in the cluster and updates a machine to configuration as defined by
machine config and as instructed by the MachineConfigController. When the node detects
a change, it drains off its pods, applies the update, and reboots. These changes
come in the form of Ignition configuration files that apply the specified
machine configuration and control kubelet configuration. The update itself is
delivered in a container. This process is key to the success of managing
{product-title} and RHCOS updates together.</simpara>
</listitem>
<listitem>
<simpara>The <literal>machine-config-server</literal> daemon set, which provides the Ignition config files
to control plane nodes as they join the cluster.</simpara>
</listitem>
</itemizedlist>
<simpara>The machine configuration is a subset of the Ignition configuration. The
<literal>machine-config-daemon</literal> reads the machine configuration to see if it needs to do
an OSTree update or if it must apply a series of systemd kubelet file changes,
configuration changes, or other changes to the operating system or {product-title}
configuration.</simpara>
<simpara>When you perform node management operations, you create or modify a
<literal>KubeletConfig</literal> custom resource (CR).</simpara>
<important>
<simpara>When changes are made to a machine configuration, the Machine Config Operator (MCO) automatically reboots all corresponding nodes in order for the changes to take effect.</simpara>
<simpara>To prevent the nodes from automatically rebooting after machine configuration changes, before making the changes, you must pause the autoreboot process by setting the <literal>spec.paused</literal> field to <literal>true</literal> in the corresponding machine config pool. When paused, machine configuration changes are not applied until you set the <literal>spec.paused</literal> field to <literal>false</literal> and the nodes have rebooted into the new configuration.</simpara>
<simpara>The following modifications do not trigger a node reboot:</simpara>
<itemizedlist>
<listitem>
<simpara>When the MCO detects any of the following changes, it applies the update without draining or rebooting the node:</simpara>
<itemizedlist>
<listitem>
<simpara>Changes to the SSH key in the <literal>spec.config.passwd.users.sshAuthorizedKeys</literal> parameter of a machine config.</simpara>
</listitem>
<listitem>
<simpara>Changes to the global pull secret or pull secret in the <literal>openshift-config</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Automatic rotation of the <literal>/etc/kubernetes/kubelet-ca.crt</literal> certificate authority (CA) by the Kubernetes API Server Operator.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>When the MCO detects changes to the <literal>/etc/containers/registries.conf</literal> file, such as adding or editing an <literal>ImageDigestMirrorSet</literal>, <literal>ImageTagMirrorSet</literal>, or <literal>ImageContentSourcePolicy</literal> object, it drains the corresponding nodes, applies the changes, and uncordons the nodes. The node drain does not happen for the following changes:</simpara>
<itemizedlist>
<listitem>
<simpara>The addition of a registry with the <literal>pull-from-mirror = "digest-only"</literal> parameter set for each mirror.</simpara>
</listitem>
<listitem>
<simpara>The addition of a mirror with the <literal>pull-from-mirror = "digest-only"</literal> parameter set in a registry.</simpara>
</listitem>
<listitem>
<simpara>The addition of items to the <literal>unqualified-search-registries</literal> list.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</important>
<simpara>There might be situations where the configuration on a node does not fully match what the currently-applied machine config specifies. This state is called <emphasis>configuration drift</emphasis>. The Machine Config Daemon (MCD) regularly checks the nodes for configuration drift. If the MCD detects configuration drift, the MCO marks the node <literal>degraded</literal> until an administrator corrects the node configuration. A degraded node is online and operational, but, it cannot be updated.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about detecting configuration drift, see <link xl:href="../post_installation_configuration/machine-configuration-tasks.xml#machine-config-drift-detection_post-install-machine-configuration-tasks">Understanding configuration drift detection</link>.</simpara>
</listitem>
<listitem>
<simpara>For information about preventing the control plane machines from rebooting after the Machine Config Operator makes changes to the machine configuration, see <link xl:href="../support/troubleshooting/troubleshooting-operator-issues.xml#troubleshooting-disabling-autoreboot-mco_troubleshooting-operator-issues">Disabling Machine Config Operator from automatically rebooting</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="etcd-overview_control-plane">
<title>Overview of etcd</title>
<simpara>etcd is a consistent, distributed key-value store that holds small amounts of data that can fit entirely in memory. Although etcd is a core component of many projects, it is the primary data store for Kubernetes, which is the standard system for container orchestration.</simpara>
<section xml:id="etcd-benefits_control-plane">
<title>Benefits of using etcd</title>
<simpara>By using etcd, you can benefit in several ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Maintain consistent uptime for your cloud-native applications, and keep them working even if individual servers fail</simpara>
</listitem>
<listitem>
<simpara>Store and replicate all cluster states for Kubernetes</simpara>
</listitem>
<listitem>
<simpara>Distribute configuration data to provide redundancy and resiliency for the configuration of nodes</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="etcd-architecture_control-plane">
<title>How etcd works</title>
<simpara>To ensure a reliable approach to cluster configuration and management, etcd uses the etcd Operator. The Operator simplifies the use of etcd on a Kubernetes container platform like {product-title}. With the etcd Operator, you can create or delete etcd members, resize clusters, perform backups, and upgrade etcd.</simpara>
<simpara>The etcd Operator observes, analyzes, and acts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>It observes the cluster state by using the Kubernetes API.</simpara>
</listitem>
<listitem>
<simpara>It analyzes differences between the current state and the state that you want.</simpara>
</listitem>
<listitem>
<simpara>It fixes the differences through the etcd cluster management APIs, the Kubernetes API, or both.</simpara>
</listitem>
</orderedlist>
<simpara>etcd holds the cluster state, which is constantly updated. This state is continuously persisted, which leads to a high number of small changes at high frequency. As a result, it is critical to back the etcd cluster member with fast, low-latency I/O. For more information about best practices for etcd, see "Recommended etcd practices".</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../scalability_and_performance/recommended-performance-scale-practices/recommended-etcd-practices.xml#recommended-etcd-practices">Recommended etcd practices</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../backup_and_restore/control_plane_backup_and_restore/backing-up-etcd.xml#backing-up-etcd">Backing up etcd</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="hosted-control-planes-overview_control-plane">
<title>Introduction to hosted control planes</title>
<simpara>You can use hosted control planes for Red Hat {product-title} to reduce management costs, optimize cluster deployment time, and separate management and workload concerns so that you can focus on your applications.</simpara>
<simpara>Hosted control planes is available by using the <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#cluster_mce_overview">multicluster engine for Kubernetes operator version 2.0 or later</link> on the following platforms:</simpara>
<itemizedlist>
<listitem>
<simpara>Bare metal by using the Agent provider</simpara>
</listitem>
<listitem>
<simpara>OpenShift Virtualization</simpara>
</listitem>
<listitem>
<simpara>Amazon Web Services, as a Technology Preview feature</simpara>
</listitem>
<listitem>
<simpara>IBM Z, as a Technology Preview feature</simpara>
</listitem>
<listitem>
<simpara>IBM Power, as a Technology Preview feature</simpara>
</listitem>
</itemizedlist>
<section xml:id="hosted-control-planes-architecture_control-plane">
<title>Architecture of hosted control planes</title>
<simpara>{product-title} is often deployed in a coupled, or standalone, model, where a cluster consists of a control plane and a data plane. The control plane includes an API endpoint, a storage endpoint, a workload scheduler, and an actuator that ensures state. The data plane includes compute, storage, and networking where workloads and applications run.</simpara>
<simpara>The standalone control plane is hosted by a dedicated group of nodes, which can be physical or virtual, with a minimum number to ensure quorum. The network stack is shared. Administrator access to a cluster offers visibility into the cluster&#8217;s control plane, machine management APIs, and other components that contribute to the state of a cluster.</simpara>
<simpara>Although the standalone model works well, some situations require an architecture where the control plane and data plane are decoupled. In those cases, the data plane is on a separate network domain with a dedicated physical hosting environment. The control plane is hosted by using high-level primitives such as deployments and stateful sets that are native to Kubernetes. The control plane is treated as any other workload.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/hosted-control-planes-diagram.png"/>
</imageobject>
<textobject><phrase>Diagram that compares the hosted control plane model against OpenShift with a coupled control plane and workers</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="hosted-control-planes-benefits_control-plane">
<title>Benefits of hosted control planes</title>
<simpara>With hosted control planes for {product-title}, you can pave the way for a true hybrid-cloud approach and enjoy several other benefits.</simpara>
<itemizedlist>
<listitem>
<simpara>The security boundaries between management and workloads are stronger because the control plane is decoupled and hosted on a dedicated hosting service cluster. As a result, you are less likely to leak credentials for clusters to other users. Because infrastructure secret account management is also decoupled, cluster infrastructure administrators cannot accidentally delete control plane infrastructure.</simpara>
</listitem>
<listitem>
<simpara>With hosted control planes, you can run many control planes on fewer nodes. As a result, clusters are more affordable.</simpara>
</listitem>
<listitem>
<simpara>Because the control planes consist of pods that are launched on {product-title}, control planes start quickly. The same principles apply to control planes and workloads, such as monitoring, logging, and auto-scaling.</simpara>
</listitem>
<listitem>
<simpara>From an infrastructure perspective, you can push registries, HAProxy, cluster monitoring, storage nodes, and other infrastructure components to the tenant&#8217;s cloud provider account, isolating usage to the tenant.</simpara>
</listitem>
<listitem>
<simpara>From an operational perspective, multicluster management is more centralized, which results in fewer external factors that affect the cluster status and consistency. Site reliability engineers have a central place to debug issues and navigate to the cluster data plane, which can lead to shorter Time to Resolution (TTR) and greater productivity.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/clusters/cluster_mce_overview#hosted-control-planes-intro">Hosted control planes</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="hosted-control-planes-concepts-personas_control-plane">
<title>Glossary of common concepts and personas for hosted control planes</title>
<simpara>When you use hosted control planes for {product-title}, it is important to understand its key concepts and the personas that are involved.</simpara>
<section xml:id="hosted-control-planes-concepts_control-plane">
<title>Concepts</title>
<variablelist>
<varlistentry>
<term>hosted cluster</term>
<listitem>
<simpara>An {product-title} cluster with its control plane and API endpoint hosted on a management cluster. The hosted cluster includes the control plane and its corresponding data plane.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hosted cluster infrastructure</term>
<listitem>
<simpara>Network, compute, and storage resources that exist in the tenant or end-user cloud account.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hosted control plane</term>
<listitem>
<simpara>An {product-title} control plane that runs on the management cluster, which is exposed by the API endpoint of a hosted cluster. The components of a control plane include etcd, the Kubernetes API server, the Kubernetes controller manager, and a VPN.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hosting cluster</term>
<listitem>
<simpara>See <emphasis>management cluster</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>managed cluster</term>
<listitem>
<simpara>A cluster that the hub cluster manages. This term is specific to the cluster lifecycle that the multicluster engine for Kubernetes Operator manages in Red Hat Advanced Cluster Management. A managed cluster is not the same thing as a <emphasis>management cluster</emphasis>. For more information, see <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/about/welcome-to-red-hat-advanced-cluster-management-for-kubernetes#managed-cluster">Managed cluster</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>management cluster</term>
<listitem>
<simpara>An {product-title} cluster where the HyperShift Operator is deployed and where the control planes for hosted clusters are hosted. The management cluster is synonymous with the <emphasis>hosting cluster</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>management cluster infrastructure</term>
<listitem>
<simpara>Network, compute, and storage resources of the management cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="hosted-control-planes-personas_control-plane">
<title>Personas</title>
<variablelist>
<varlistentry>
<term>cluster instance administrator</term>
<listitem>
<simpara>Users who assume this role are the equivalent of administrators in standalone {product-title}. This user has the <literal>cluster-admin</literal> role in the provisioned cluster, but might not have power over when or how the cluster is updated or configured. This user might have read-only access to see some configuration projected into the cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>cluster instance user</term>
<listitem>
<simpara>Users who assume this role are the equivalent of developers in standalone {product-title}. This user does not have a view into OperatorHub or machines.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>cluster service consumer</term>
<listitem>
<simpara>Users who assume this role can request control planes and worker nodes, drive updates, or modify externalized configurations. Typically, this user does not manage or access cloud credentials or infrastructure encryption keys. The cluster service consumer persona can request hosted clusters and interact with node pools. Users who assume this role have RBAC to create, read, update, or delete hosted clusters and node pools within a logical boundary.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>cluster service provider</term>
<listitem>
<simpara>Users who assume this role typically have the <literal>cluster-admin</literal> role on the management cluster and have RBAC to monitor and own the availability of the HyperShift Operator as well as the control planes for the tenant&#8217;s hosted clusters. The cluster service provider persona is responsible for several activities, including the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara>Owning service-level objects for control plane availability, uptime, and stability</simpara>
</listitem>
<listitem>
<simpara>Configuring the cloud account for the management cluster to host control planes</simpara>
</listitem>
<listitem>
<simpara>Configuring the user-provisioned infrastructure, which includes the host awareness of available compute resources</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="hosted-control-planes-version-support_control-plane">
<title>Versioning for hosted control planes</title>
<simpara>With each major, minor, or patch version release of {product-title}, two components of hosted control planes are released:</simpara>
<itemizedlist>
<listitem>
<simpara>HyperShift Operator</simpara>
</listitem>
<listitem>
<simpara>Command-line interface (CLI)</simpara>
</listitem>
</itemizedlist>
<simpara>The HyperShift Operator manages the lifecycle of hosted clusters that are represented by <literal>HostedCluster</literal> API resources. The HyperShift Operator is released with each {product-title} release. After the HyperShift Operator is installed, it creates a config map called <literal>supported-versions</literal> in the HyperShift namespace, as shown in the following example. The config map describes the HostedCluster versions that can be deployed.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: v1
    data:
      supported-versions: '{"versions":["4.15"]}'
    kind: ConfigMap
    metadata:
      labels:
        hypershift.openshift.io/supported-versions: "true"
      name: supported-versions
      namespace: hypershift</programlisting>
<simpara>The CLI is a helper utility for development purposes. The CLI is released as part of any HyperShift Operator release. No compatibility policies are guaranteed.</simpara>
<simpara>The API, <literal>hypershift.openshift.io</literal>, provides a way to create and manage lightweight, flexible, heterogeneous {product-title} clusters at scale. The API exposes two user-facing resources: <literal>HostedCluster</literal> and <literal>NodePool</literal>. A <literal>HostedCluster</literal> resource encapsulates the control plane and common data plane configuration. When you create a <literal>HostedCluster</literal> resource, you have a fully functional control plane with no attached nodes. A <literal>NodePool</literal> resource is a scalable set of worker nodes that is attached to a <literal>HostedCluster</literal> resource.</simpara>
<simpara>The API version policy generally aligns with the policy for <link xl:href="https://kubernetes.io/docs/reference/using-api/#api-versioning">Kubernetes API versioning</link>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="nvidia-gpu-architecture-overview">
<title>NVIDIA GPU architecture overview</title>

<simpara>NVIDIA supports the use of graphics processing unit (GPU) resources on {product-title}. {product-title} is a security-focused and hardened Kubernetes platform developed and supported by Red Hat for deploying and managing Kubernetes clusters at scale. {product-title} includes enhancements to Kubernetes so that users can easily configure and use NVIDIA GPU resources to accelerate workloads.</simpara>
<simpara>The NVIDIA GPU Operator leverages the Operator framework within {product-title} to manage the full lifecycle of NVIDIA software components required to run GPU-accelerated workloads.</simpara>
<simpara>These components include the NVIDIA drivers (to enable CUDA), the Kubernetes device plugin for GPUs, the NVIDIA Container Toolkit, automatic node tagging using GPU feature discovery (GFD), DCGM-based monitoring, and others.</simpara>
<note>
<simpara>The NVIDIA GPU Operator is only supported by NVIDIA. For more information about obtaining support from NVIDIA, see <link xl:href="https://access.redhat.com/solutions/5174941">Obtaining Support from NVIDIA</link>.</simpara>
</note>
<section xml:id="nvidia-gpu-prerequisites_nvidia-gpu-architecture-overview">
<title>NVIDIA GPU prerequisites</title>
<itemizedlist>
<listitem>
<simpara>A working OpenShift cluster with at least one GPU worker node.</simpara>
</listitem>
<listitem>
<simpara>Access to the OpenShift cluster as a <literal>cluster-admin</literal> to perform the required steps.</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) is installed.</simpara>
</listitem>
<listitem>
<simpara>The node feature discovery (NFD) Operator is installed and a <literal>nodefeaturediscovery</literal> instance is created.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-enablement_nvidia-gpu-architecture-overview">
<title>NVIDIA GPU enablement</title>
<simpara>The following diagram shows how the GPU architecture is enabled for OpenShift:</simpara>
<figure>
<title>NVIDIA GPU enablement</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/512_OpenShift_NVIDIA_GPU_enablement_1223.png"/>
</imageobject>
<textobject><phrase>NVIDIA GPU enablement</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>MIG is only supported with A30, A100, A100X, A800, AX800, H100, H200, and H800.</simpara>
</note>
<section xml:id="nvidia-gpu-bare-metal_nvidia-gpu-architecture-overview">
<title>GPUs and bare metal</title>
<simpara>You can deploy {product-title} on an NVIDIA-certified bare metal server but with some limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>Control plane nodes can be CPU nodes.</simpara>
</listitem>
<listitem>
<simpara>Worker nodes must be GPU nodes, provided that AI/ML workloads are executed on these worker nodes.</simpara>
<simpara>In addition, the worker nodes can host one or more GPUs, but they must be of the same type. For example, a node can have two NVIDIA A100 GPUs, but a node with one A100 GPU and one T4 GPU is not supported. The NVIDIA Device Plugin for Kubernetes does not support mixing different GPU models on the same node.</simpara>
</listitem>
<listitem>
<simpara>When using OpenShift, note that one or three or more servers are required. Clusters with two servers are not supported. The single server deployment is called single node openShift (SNO) and using this configuration results in a non-high availability OpenShift environment.</simpara>
</listitem>
</itemizedlist>
<simpara>You can choose one of the following methods to access the containerized GPUs:</simpara>
<itemizedlist>
<listitem>
<simpara>GPU passthrough</simpara>
</listitem>
<listitem>
<simpara>Multi-Instance GPU (MIG)</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/ai-enterprise/deployment-guide-openshift-on-bare-metal/0.1.0/on-bare-metal.html">Red Hat OpenShift on Bare Metal Stack</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-virtualization_nvidia-gpu-architecture-overview">
<title>GPUs and virtualization</title>
<simpara>Many developers and enterprises are moving to containerized applications and serverless infrastructures, but there is still a lot of interest in developing and maintaining applications that run on virtual machines (VMs). Red Hat OpenShift Virtualization provides this capability, enabling enterprises to incorporate VMs into containerized workflows within clusters.</simpara>
<simpara>You can choose one of the following methods to connect the worker nodes to the GPUs:</simpara>
<itemizedlist>
<listitem>
<simpara>GPU passthrough to access and use GPU hardware within a virtual machine (VM).</simpara>
</listitem>
<listitem>
<simpara>GPU (vGPU) time-slicing, when GPU compute capacity is not saturated by workloads.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/openshift/openshift-virtualization.html">NVIDIA GPU Operator with OpenShift Virtualization</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-vsphere_nvidia-gpu-architecture-overview">
<title>GPUs and vSphere</title>
<simpara>You can deploy {product-title} on an NVIDIA-certified VMware vSphere server that can host different GPU types.</simpara>
<simpara>An NVIDIA GPU driver must be installed in the hypervisor in case vGPU instances are used by the VMs. For VMware vSphere, this host driver is provided in the form of a VIB file.</simpara>
<simpara>The maximum number of vGPUS that can be allocated to worker node VMs depends on the version of vSphere:</simpara>
<itemizedlist>
<listitem>
<simpara>vSphere 7.0: maximum 4 vGPU per VM</simpara>
</listitem>
<listitem>
<simpara>vSphere 8.0: maximum 8 vGPU per VM</simpara>
<note>
<simpara>vSphere 8.0 introduced support for multiple full or fractional heterogenous profiles associated with a VM.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>You can choose one of the following methods to attach the worker nodes to the GPUs:</simpara>
<itemizedlist>
<listitem>
<simpara>GPU passthrough for accessing and using GPU hardware within a virtual machine (VM)</simpara>
</listitem>
<listitem>
<simpara>GPU (vGPU) time-slicing, when not all of the GPU is needed</simpara>
</listitem>
</itemizedlist>
<simpara>Similar to bare metal deployments, one or three or more servers are required. Clusters with two servers are not supported.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/gpu-operator/latest/openshift/nvaie-with-ocp.html#openshift-container-platform-on-vmware-vsphere-with-nvidia-vgpus">OpenShift Container Platform on VMware vSphere with NVIDIA vGPUs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-kvm_nvidia-gpu-architecture-overview">
<title>GPUs and Red Hat KVM</title>
<simpara>You can use {product-title} on an NVIDIA-certified kernel-based virtual machine (KVM) server.</simpara>
<simpara>Similar to bare-metal deployments, one or three or more servers are required. Clusters with two servers are not supported.</simpara>
<simpara>However, unlike bare-metal deployments, you can use different types of GPUs in the server. This is because you can assign these GPUs to different VMs that act as Kubernetes nodes. The only limitation is that a Kubernetes node must have the same set of GPU types at its own level.</simpara>
<simpara>You can choose one of the following methods to access the containerized GPUs:</simpara>
<itemizedlist>
<listitem>
<simpara>GPU passthrough for accessing and using GPU hardware within a virtual machine (VM)</simpara>
</listitem>
<listitem>
<simpara>GPU (vGPU) time-slicing when not all of the GPU is needed</simpara>
</listitem>
</itemizedlist>
<simpara>To enable the vGPU capability, a special driver must be installed at the host level. This driver is delivered as a RPM package. This host driver is not required at all for GPU passthrough allocation.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://computingforgeeks.com/how-to-deploy-openshift-container-platform-on-kvm/">How To Deploy OpenShift Container Platform 4.13 on KVM</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-csps_nvidia-gpu-architecture-overview">
<title>GPUs and CSPs</title>
<simpara>You can deploy {product-title} to one of the major cloud service providers (CSPs): Amazon Web Services (AWS), Google Cloud Platform (GCP), or Microsoft Azure.</simpara>
<simpara>Two modes of operation are available: a fully managed deployment and a self-managed deployment.</simpara>
<itemizedlist>
<listitem>
<simpara>In a fully managed deployment, everything is automated by Red Hat in collaboration with CSP. You can request an OpenShift instance through the CSP web console, and the cluster is automatically created and fully managed by Red Hat. You do not have to worry about node failures or errors in the environment. Red Hat is fully responsible for maintaining the uptime of the cluster. The fully managed services are available on AWS and Azure. For AWS, the OpenShift service is called ROSA (Red Hat OpenShift Service on AWS). For Azure, the service is called Azure Red Hat OpenShift.</simpara>
</listitem>
<listitem>
<simpara>In a self-managed deployment, you are responsible for instantiating and maintaining the OpenShift cluster. Red Hat provides the OpenShift-install utility to support the deployment of the OpenShift cluster in this case. The self-managed services are available globally to all CSPs.</simpara>
</listitem>
</itemizedlist>
<simpara>It is important that this compute instance is a GPU-accelerated compute instance and that the GPU type matches the list of supported GPUs from NVIDIA AI Enterprise. For example, T4, V100, and A100 are part of this list.</simpara>
<simpara>You can choose one of the following methods to access the containerized GPUs:</simpara>
<itemizedlist>
<listitem>
<simpara>GPU passthrough to access and use GPU hardware within a virtual machine (VM).</simpara>
</listitem>
<listitem>
<simpara>GPU (vGPU) time slicing when the entire GPU is not required.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/ai-enterprise/deployment-guide-cloud/0.1.0/aws-redhat-openshift.html">Red Hat Openshift in the Cloud</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-red-hat-device-edge_nvidia-gpu-architecture-overview">
<title>GPUs and Red Hat Device Edge</title>
<simpara>Red Hat Device Edge provides access to MicroShift. MicroShift provides the simplicity of a single-node deployment with the functionality and services you need for resource-constrained (edge) computing. Red Hat Device Edge meets the needs of bare-metal, virtual, containerized, or Kubernetes workloads deployed in resource-constrained environments.</simpara>
<simpara>You can enable NVIDIA GPUs on containers in a Red Hat Device Edge environment.</simpara>
<simpara>You use GPU passthrough to access the containerized GPUs.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://cloud.redhat.com/blog/how-to-accelerate-workloads-with-nvidia-gpus-on-red-hat-device-edge">How to accelerate workloads with NVIDIA GPUs on Red Hat Device Edge</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nvidia-gpu-sharing-methods_nvidia-gpu-architecture-overview">
<title>GPU sharing methods</title>
<simpara>Red&#160;Hat and NVIDIA have developed GPU concurrency and sharing mechanisms to simplify GPU-accelerated computing on an enterprise-level {product-title} cluster.</simpara>
<simpara>Applications typically have different compute requirements that can leave GPUs underutilized. Providing the right amount of compute resources for each workload is critical to reduce deployment cost and maximize GPU utilization.</simpara>
<simpara>Concurrency mechanisms for improving GPU utilization exist that range from programming model APIs to system software and hardware partitioning, including virtualization. The following list shows the GPU concurrency mechanisms:</simpara>
<itemizedlist>
<listitem>
<simpara>Compute Unified Device Architecture (CUDA) streams</simpara>
</listitem>
<listitem>
<simpara>Time-slicing</simpara>
</listitem>
<listitem>
<simpara>CUDA Multi-Process Service (MPS)</simpara>
</listitem>
<listitem>
<simpara>Multi-instance GPU (MIG)</simpara>
</listitem>
<listitem>
<simpara>Virtualization with vGPU</simpara>
</listitem>
</itemizedlist>
<simpara>Consider the following GPU sharing suggestions when using the GPU concurrency mechanisms for different {product-title} scenarios:</simpara>
<variablelist>
<varlistentry>
<term>Bare metal</term>
<listitem>
<simpara>vGPU is not available. Consider using MIG-enabled cards.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>VMs</term>
<listitem>
<simpara>vGPU is the best choice.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Older NVIDIA cards with no MIG on bare metal</term>
<listitem>
<simpara>Consider using time-slicing.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>VMs with multiple GPUs and you want passthrough and vGPU</term>
<listitem>
<simpara>Consider using separate VMs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bare metal with OpenShift Virtualization and multiple GPUs</term>
<listitem>
<simpara>Consider using pass-through for hosted VMs and time-slicing for containers.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://developer.nvidia.com/blog/improving-gpu-utilization-in-kubernetes/">Improving GPU Utilization</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="nvidia-gpu-cuda-streams_nvidia-gpu-architecture-overview">
<title>CUDA streams</title>
<simpara>Compute Unified Device Architecture (CUDA) is a parallel computing platform and programming model developed by NVIDIA for general computing on GPUs.</simpara>
<simpara>A stream is a sequence of operations that executes in issue-order on the GPU. CUDA commands are typically executed sequentially in a default stream and a task does not start until a preceding task has completed.</simpara>
<simpara>Asynchronous processing of operations across different streams allows for parallel execution of tasks. A task issued in one stream runs before, during, or after another task is issued into another stream. This allows the GPU to run multiple tasks simultaneously in no prescribed order, leading to improved performance.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#asynchronous-concurrent-execution">Asynchronous Concurrent Execution</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-time-slicing_nvidia-gpu-architecture-overview">
<title>Time-slicing</title>
<simpara>GPU time-slicing interleaves workloads scheduled on overloaded GPUs when you are running multiple CUDA applications.</simpara>
<simpara>You can enable time-slicing of GPUs on Kubernetes by defining a set of replicas for a GPU, each of which can be independently distributed to a pod to run workloads on. Unlike multi-instance GPU (MIG), there is no memory or fault isolation between replicas, but for some workloads this is better than not sharing at all. Internally, GPU time-slicing is used to multiplex workloads from replicas of the same underlying GPU.</simpara>
<simpara>You can apply a cluster-wide default configuration for time-slicing. You can also apply node-specific configurations. For example, you can apply a time-slicing configuration only to nodes with Tesla T4 GPUs and not modify nodes with other GPU models.</simpara>
<simpara>You can combine these two approaches by applying a cluster-wide default configuration and then labeling nodes to give those nodes a node-specific configuration.</simpara>
</section>
<section xml:id="nvidia-gpu-cuda-mps_nvidia-gpu-architecture-overview">
<title>CUDA Multi-Process Service</title>
<simpara>CUDA Multi-Process Service (MPS) allows a single GPU to use multiple CUDA processes. The processes run in parallel on the GPU, eliminating saturation of the GPU compute resources. MPS also enables concurrent execution, or overlapping, of kernel operations and memory copying from different processes to
enhance utilization.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/deploy/mps/index.html">CUDA MPS</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-mig-gpu_nvidia-gpu-architecture-overview">
<title>Multi-instance GPU</title>
<simpara>Using Multi-instance GPU (MIG), you can split GPU compute units and memory into multiple MIG instances. Each of these instances represents a standalone GPU device from a system perspective and can be connected to any application, container, or virtual machine running on the node. The software that uses the GPU treats each of these MIG instances as an individual GPU.</simpara>
<simpara>MIG is useful when you have an application that does not require the full power of an entire GPU. The MIG feature of the new NVIDIA Ampere architecture enables you to split your hardware resources into multiple GPU instances, each of which is available to the operating system as an independent CUDA-enabled GPU.</simpara>
<simpara>NVIDIA GPU Operator version 1.7.0 and higher provides MIG support for the A100 and A30 Ampere cards. These GPU instances are designed to support up to seven multiple independent CUDA applications so that they operate completely isolated with dedicated hardware resources.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/tesla/mig-user-guide/">NVIDIA Multi-Instance GPU User Guide</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nvidia-gpu-virtualization-with-gpu_nvidia-gpu-architecture-overview">
<title>Virtualization with vGPU</title>
<simpara>Virtual machines (VMs) can directly access a single physical GPU using NVIDIA vGPU. You can create virtual GPUs that can be shared by VMs across the enterprise and accessed by other devices.</simpara>
<simpara>This capability combines the power of GPU performance with the management and security benefits provided by vGPU. Additional benefits provided by vGPU includes proactive management and monitoring for your VM environment, workload balancing for mixed VDI and compute workloads, and resource sharing across multiple VMs.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://www.nvidia.com/en-us/data-center/virtual-solutions/">Virtual GPUs</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nvidia-gpu-features_nvidia-gpu-architecture-overview">
<title>NVIDIA GPU features for {product-title}</title>
<variablelist>
<varlistentry>
<term>NVIDIA Container Toolkit</term>
<listitem>
<simpara>NVIDIA Container Toolkit enables you to create and run GPU-accelerated containers. The toolkit includes a container runtime library and utilities to automatically configure containers to use NVIDIA GPUs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NVIDIA AI Enterprise</term>
<listitem>
<simpara>NVIDIA AI Enterprise is an end-to-end, cloud-native suite of AI and data analytics software optimized, certified, and supported with NVIDIA-Certified systems.</simpara>
<simpara>NVIDIA AI Enterprise includes support for Red Hat {product-title}. The following installation methods are supported:</simpara>
<itemizedlist>
<listitem>
<simpara>{product-title} on bare metal or VMware vSphere with GPU Passthrough.</simpara>
</listitem>
<listitem>
<simpara>{product-title} on VMware vSphere with NVIDIA vGPU.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>GPU Feature Discovery</term>
<listitem>
<simpara>NVIDIA GPU Feature Discovery for Kubernetes is a software component that enables you to automatically generate labels for the GPUs available on a node. GPU Feature Discovery uses node feature discovery (NFD) to perform this labeling.</simpara>
<simpara>The Node Feature Discovery Operator (NFD) manages the discovery of hardware features and configurations in an OpenShift Container Platform cluster by labeling nodes with hardware-specific information. NFD labels the host with node-specific attributes, such as PCI cards, kernel, OS version, and so on.</simpara>
<simpara>You can find the NFD Operator in the Operator Hub by searching for “Node Feature Discovery”.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NVIDIA GPU Operator with OpenShift Virtualization</term>
<listitem>
<simpara>Up until this point, the GPU Operator only provisioned worker nodes to run GPU-accelerated containers. Now, the GPU Operator can also be used to provision worker nodes for running GPU-accelerated virtual machines (VMs).</simpara>
<simpara>You can configure the GPU Operator to deploy different software components to worker nodes depending on which GPU workload is configured to run on those nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>GPU Monitoring dashboard</term>
<listitem>
<simpara>You can install a monitoring dashboard to display GPU usage information on the cluster <emphasis role="strong">Observe</emphasis> page in the {product-title} web console. GPU utilization information includes the number of available GPUs, power consumption (in watts), temperature (in degrees Celsius), utilization (in percent), and other metrics for each GPU.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/ngc/ngc-deploy-on-premises/nvidia-certified-systems/index.html">NVIDIA-Certified Systems</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/ai-enterprise/index.html#deployment-guides">NVIDIA AI Enterprise</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/overview.html#">NVIDIA Container Toolkit</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/openshift/latest/enable-gpu-monitoring-dashboard.html">Enabling the GPU Monitoring Dashboard</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/openshift/latest/mig-ocp.html">MIG Support in OpenShift Container Platform</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/openshift/latest/time-slicing-gpus-in-openshift.html">Time-slicing NVIDIA GPUs in OpenShift</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.nvidia.com/datacenter/cloud-native/openshift/latest/mirror-gpu-ocp-disconnected.html">Deploy GPU Operators in a disconnected or airgapped environment</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../hardware_enablement/psap-node-feature-discovery-operator.html">Node Feature Discovery Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="understanding-development">
<title>Understanding {product-title} development</title>

<simpara>To fully leverage the capability of containers when developing and running
enterprise-quality applications, ensure your environment is supported by tools
that allow containers to be:</simpara>
<itemizedlist>
<listitem>
<simpara>Created as discrete microservices that can be connected to other
containerized, and non-containerized, services. For example, you might want to
join your application with a database or attach a monitoring application to it.</simpara>
</listitem>
<listitem>
<simpara>Resilient, so if a server crashes or needs to go down for maintenance or to be
decommissioned, containers can start on another machine.</simpara>
</listitem>
<listitem>
<simpara>Automated to pick up code changes automatically and then start and deploy new
versions of themselves.</simpara>
</listitem>
<listitem>
<simpara>Scaled up, or replicated, to have more instances serving clients as demand
increases and then spun down to fewer instances as demand declines.</simpara>
</listitem>
<listitem>
<simpara>Run in different ways, depending on the type of application. For example, one
application might run once a month to produce a report and then exit. Another
application might need to run constantly and be highly available to clients.</simpara>
</listitem>
<listitem>
<simpara>Managed so you can watch the state of your application and react when
something goes wrong.</simpara>
</listitem>
</itemizedlist>
<simpara>Containers’ widespread acceptance, and the resulting requirements for tools and
methods to make them enterprise-ready, resulted in many options for them.</simpara>
<simpara>The rest of this section explains options for
assets you can create when you build and deploy containerized Kubernetes
applications in {product-title}. It also describes which approaches you might
use for different kinds of applications and development requirements.</simpara>
<section xml:id="developing-containerized-applications">
<title>About developing containerized applications</title>
<simpara>You can approach application development with containers in many ways, and
different approaches might be more appropriate for different situations. To
illustrate some of this variety, the series of approaches that is presented
starts with developing a single container and ultimately deploys that container
as a mission-critical application for a large enterprise. These approaches
show different tools, formats, and methods that you can employ with containerized
application development. This topic describes:</simpara>
<itemizedlist>
<listitem>
<simpara>Building a simple container and storing it in a registry</simpara>
</listitem>
<listitem>
<simpara>Creating a Kubernetes manifest and saving it to a Git repository</simpara>
</listitem>
<listitem>
<simpara>Making an Operator to share your application with others</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="building-simple-container">
<title>Building a simple container</title>
<simpara>You have an idea for an application and you want to containerize it.</simpara>
<simpara>First you require a tool for building a container, like buildah or docker,
and a file that describes what goes in your container, which is typically a
<link xl:href="https://docs.docker.com/engine/reference/builder/">Dockerfile</link>.</simpara>
<simpara>Next, you require a location to push the resulting container image so you can
pull it to run anywhere you want it to run. This location is a container
registry.</simpara>
<simpara>Some examples of each of these components are installed by default on most
Linux operating systems, except for the Dockerfile, which you provide yourself.</simpara>
<simpara>The following diagram displays the process of building and pushing an image:</simpara>
<figure>
<title>Create a simple containerized application and push it to a registry</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/create-push-app.png"/>
</imageobject>
<textobject><phrase>Creating and pushing a containerized application</phrase></textobject>
</mediaobject>
</figure>
<simpara>If you use a computer that runs Red Hat Enterprise Linux (RHEL) as the operating
system, the process of creating a containerized application requires the
following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install container build tools: RHEL contains a set of tools that includes
podman, buildah, and skopeo that you use to build and manage containers.</simpara>
</listitem>
<listitem>
<simpara>Create a Dockerfile to combine base image and software: Information about
building your container goes into a file that is named <literal>Dockerfile</literal>. In that
file, you identify the base image you build from, the software packages you
install, and the software you copy into the container. You also identify
parameter values like network ports that you expose outside the container and
volumes that you mount inside the container. Put your Dockerfile and the
software you want to containerize in a directory on your RHEL system.</simpara>
</listitem>
<listitem>
<simpara>Run buildah or docker build: Run the <literal>buildah build-using-dockerfile</literal> or
the <literal>docker build</literal> command to pull your chosen base image to the local system and
create a container image that is stored locally. You can also build container images
without a Dockerfile by using buildah.</simpara>
</listitem>
<listitem>
<simpara>Tag and push to a registry: Add a tag to your new container image that
identifies the location of the registry in which you want to store and share
your container. Then push that image to the registry by running the
<literal>podman push</literal> or <literal>docker push</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Pull and run the image: From any system that has a container client tool,
such as podman or docker, run a command that identifies your new image.
For example, run the <literal>podman run &lt;image_name&gt;</literal> or <literal>docker run &lt;image_name&gt;</literal>
command. Here <literal>&lt;image_name&gt;</literal> is the name of your new container image, which
resembles <literal>quay.io/myrepo/myapp:latest</literal>. The registry might require credentials
to push and pull images.</simpara>
</listitem>
</orderedlist>
<simpara>For more details on the process of building container images, pushing them to
registries, and running them, see
<link xl:href="../cicd/builds/custom-builds-buildah.xml#custom-builds-buildah">Custom image builds with Buildah</link>.</simpara>
<section xml:id="container-build-tool-options">
<title>Container build tool options</title>
<simpara>Building and managing containers with buildah, podman, and skopeo results in industry standard container images that include features specifically tuned for deploying containers in {product-title} or other Kubernetes environments. These tools are daemonless and can run without root privileges, requiring less overhead to run them.</simpara>
<important>
<simpara>Support for Docker Container Engine as a container runtime is deprecated in Kubernetes 1.20 and will be removed in a future release. However, Docker-produced images will continue to work in your cluster with all runtimes, including CRI-O. For more information, see the <link xl:href="https://kubernetes.io/blog/2020/12/02/dont-panic-kubernetes-and-docker/">Kubernetes blog announcement</link>.</simpara>
</important>
<simpara>When you ultimately run your containers in {product-title}, you use the
<link xl:href="https://cri-o.io/">CRI-O</link> container engine. CRI-O runs on every worker and
control plane machine in an {product-title} cluster, but CRI-O is not yet supported as
a standalone runtime outside of {product-title}.</simpara>
</section>
<section xml:id="base-image-options">
<title>Base image options</title>
<simpara>The base image you choose to build your application on contains a set of
software that resembles a Linux system to your application. When you build your
own image, your software is placed into that file system and sees that file
system as though it were looking at its operating system. Choosing this base
image has major impact on how secure, efficient and upgradeable your container
is in the future.</simpara>
<simpara>Red Hat provides a new set of base images referred to as
<link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/getting_started_with_containers/index#using_red_hat_base_container_images_standard_and_minimal">Red Hat Universal Base Images</link> (UBI).
These images are based on Red Hat Enterprise Linux and are similar to base
images that Red Hat has offered in the past, with one major difference: they
are freely redistributable without a Red Hat subscription. As a result, you can
build your application on UBI images without having to worry about how they
are shared or the need to create different images for different environments.</simpara>
<simpara>These UBI images have standard, init, and minimal versions. You can also use the
<link xl:href="https://access.redhat.com/documentation/en-us/red_hat_software_collections/3/html-single/using_red_hat_software_collections_container_images/index">Red Hat Software Collections</link>
images as a foundation for applications that rely on specific runtime
environments such as Node.js, Perl, or Python. Special versions of some of
these runtime base images are referred to as Source-to-Image (S2I) images. With
S2I images, you can insert your code into a base image environment that is ready
to run that code.</simpara>
<simpara>S2I images are available for you to use directly from the {product-title} web UI
by selecting <emphasis role="strong">Catalog</emphasis> &#8594; <emphasis role="strong">Developer Catalog</emphasis>, as shown in the following figure:</simpara>
<figure>
<title>Choose S2I base images for apps that need specific runtimes</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/developer-catalog.png"/>
</imageobject>
<textobject><phrase>{product-title} Developer Catalog</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="understanding-development-registry-options">
<title>Registry options</title>
<simpara>Container registries are where you store container images so you can share them
with others and make them available to the platform where they ultimately run.
You can select large, public container registries that offer free accounts or a
premium version that offer more storage and special features. You can also
install your own registry that can be exclusive to your organization or
selectively shared with others.</simpara>
<simpara>To get Red Hat images and certified partner images, you can draw from the
Red Hat Registry. The Red Hat Registry is represented by two locations:
<literal>registry.access.redhat.com</literal>, which is unauthenticated and deprecated, and
<literal>registry.redhat.io</literal>, which requires authentication. You can learn about the Red
Hat and partner images in the Red Hat Registry from the
<link xl:href="https://catalog.redhat.com/software/containers/explore">Container images section of the Red Hat Ecosystem Catalog</link>.
Besides listing Red Hat container images, it also shows extensive information
about the contents and quality of those images, including health scores that are
based on applied security updates.</simpara>
<simpara>Large, public registries include <link xl:href="https://hub.docker.com/">Docker Hub</link> and
<link xl:href="https://quay.io/">Quay.io</link>. The Quay.io registry is owned and managed by Red
Hat. Many of the components used in {product-title} are stored in Quay.io,
including container images and the Operators that are used to deploy
{product-title} itself. Quay.io also offers the means of storing other types of
content, including Helm charts.</simpara>
<simpara>If you want your own, private container registry, {product-title} itself
includes a private container registry that is installed with {product-title}
and runs on its cluster. Red Hat also offers a private version of the Quay.io
registry called <link xl:href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</link>.
Red Hat Quay includes geo replication, Git build triggers, Clair image scanning,
and many other features.</simpara>
<simpara>All of the registries mentioned here can require credentials to download images
from those registries. Some of those credentials are presented on a cluster-wide
basis from {product-title}, while other credentials can be assigned to individuals.</simpara>
</section>
</section>
<section xml:id="creating-kubernetes-manifest-openshift">
<title>Creating a Kubernetes manifest for {product-title}</title>
<simpara>While the container image is the basic building block for a containerized
application, more information is required to manage and deploy that application
in a Kubernetes environment such as {product-title}. The typical next steps after
you create an image are to:</simpara>
<itemizedlist>
<listitem>
<simpara>Understand the different resources you work with in Kubernetes manifests</simpara>
</listitem>
<listitem>
<simpara>Make some decisions about what kind of an application you are running</simpara>
</listitem>
<listitem>
<simpara>Gather supporting components</simpara>
</listitem>
<listitem>
<simpara>Create a manifest and store that manifest in a Git repository so you can store
it in a source versioning system, audit it, track it, promote and deploy it
to the next environment, roll it back to earlier versions, if necessary, and
share it with others</simpara>
</listitem>
</itemizedlist>
<section xml:id="understanding-kubernetes-pods">
<title>About Kubernetes pods and services</title>
<simpara>While the container image is the basic unit with docker, the basic units that
Kubernetes works with are called
<link xl:href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">pods</link>.
Pods represent the next step in building out an application. A pod can contain
one or more than one container. The key is that the pod is the single unit
that you deploy, scale, and manage.</simpara>
<simpara>Scalability and namespaces are probably the main items to consider when determining
what goes in a pod. For ease of deployment, you might want to deploy a container
in a pod and include its own logging and monitoring container in the pod. Later,
when you run the pod and need to scale up an additional instance, those other
containers are scaled up with it. For namespaces, containers in a pod share the
same network interfaces, shared storage volumes, and resource limitations,
such as memory and CPU, which makes it easier to manage the contents of the pod
as a single unit. Containers in a pod can also communicate with each other by
using standard inter-process communications, such as System V semaphores or
POSIX shared memory.</simpara>
<simpara>While individual pods represent a scalable unit in Kubernetes, a
<link xl:href="https://kubernetes.io/docs/concepts/services-networking/service/">service</link>
provides a means of grouping together a set of pods to create a complete, stable
application that can complete tasks such as load balancing. A service is also
more permanent than a pod because the service remains available from the same
IP address until you delete it. When the service is in use, it is requested by
name and the {product-title} cluster resolves that name into the IP addresses
and ports where you can reach the pods that compose the service.</simpara>
<simpara>By their nature, containerized applications are separated from the operating
systems where they run and, by extension, their users. Part of your Kubernetes
manifest describes how to expose the application to internal and external
networks by defining
<link xl:href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">network policies</link>
that allow fine-grained control over communication with your containerized
applications. To connect incoming requests for HTTP, HTTPS, and other services
from outside your cluster to services inside your cluster, you can use an
<link xl:href="https://kubernetes.io/docs/concepts/services-networking/ingress/"><literal>Ingress</literal></link>
resource.</simpara>
<simpara>If your container requires on-disk storage instead of database storage, which
might be provided through a service, you can add
<link xl:href="https://kubernetes.io/docs/concepts/storage/volumes/">volumes</link>
to your manifests to make that storage available to your pods. You can configure
the manifests to create persistent volumes (PVs) or dynamically create volumes that
are added to your <literal>Pod</literal> definitions.</simpara>
<simpara>After you define a group of pods that compose your application, you can define
those pods in
<link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"><literal>Deployment</literal></link>
and <link xl:href="../applications/deployments/what-deployments-are.xml#what-deployments-are"><literal>DeploymentConfig</literal></link> objects.</simpara>
</section>
<section xml:id="application-types">
<title>Application types</title>
<simpara>Next, consider how your application type influences how to run it.</simpara>
<simpara>Kubernetes defines different types of workloads that are appropriate for
different kinds of applications. To determine the appropriate workload for your
application, consider if the application is:</simpara>
<itemizedlist>
<listitem>
<simpara>Meant to run to completion and be done. An example is an application that
starts up to produce a report and exits when the report is complete. The
application might not run again then for a month. Suitable {product-title}
objects for these types of applications include
<link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/"><literal>Job</literal></link>
and <link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/"><literal>CronJob</literal></link> objects.</simpara>
</listitem>
<listitem>
<simpara>Expected to run continuously. For long-running applications, you can write a
<link xl:href="../applications/deployments/what-deployments-are.xml#deployments-kube-deployments">deployment</link>.</simpara>
</listitem>
<listitem>
<simpara>Required to be highly available. If your application requires high
availability, then you want to size your deployment to have more than one
instance. A <literal>Deployment</literal> or <literal>DeploymentConfig</literal> object can incorporate a
<link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">replica set</link>
for that type of application. With replica sets, pods run across multiple nodes
to make sure the application is always available, even if a worker goes down.</simpara>
</listitem>
<listitem>
<simpara>Need to run on every node. Some types of Kubernetes applications are intended
to run in the cluster itself on every master or worker node. DNS and monitoring
applications are examples of applications that need to run continuously on every
node. You can run this type of application as a
<link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">daemon set</link>.
You can also run a daemon set on a subset of nodes, based on node labels.</simpara>
</listitem>
<listitem>
<simpara>Require life-cycle management. When you want to hand off your application so
that others can use it, consider creating an
<link xl:href="https://www.openshift.com/learn/topics/operators">Operator</link>. Operators let you build in
intelligence, so it can handle things like backups and upgrades automatically.
Coupled with the Operator Lifecycle Manager (OLM), cluster managers can expose
Operators to selected namespaces so that users in the cluster can run them.</simpara>
</listitem>
<listitem>
<simpara>Have identity or numbering requirements. An application might have identity
requirements or numbering requirements. For example, you might be
required to run exactly three instances of the application and to name the
instances <literal>0</literal>, <literal>1</literal>, and <literal>2</literal>. A
<link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">stateful set</link>
is suitable for this application. Stateful sets are most useful for applications
that require independent storage, such as databases and zookeeper clusters.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="supporting-components">
<title>Available supporting components</title>
<simpara>The application you write might need supporting components, like a database or
a logging component. To fulfill that need, you might be able to obtain the
required component from the following Catalogs that are available in the
{product-title} web console:</simpara>
<itemizedlist>
<listitem>
<simpara>OperatorHub, which is available in each {product-title} {product-version}
cluster. The OperatorHub makes Operators available from Red Hat,
certified Red Hat partners, and community members to the cluster operator. The
cluster operator can make those Operators available in all or selected
namespaces in the cluster, so developers can launch them and configure them
with their applications.</simpara>
</listitem>
<listitem>
<simpara>Templates, which are useful for a one-off type of application, where the
lifecycle of a component is not important after it is installed. A template provides an easy
way to get started developing a Kubernetes application with minimal overhead.
A template can be a list of resource definitions, which could be <literal>Deployment</literal>,
<literal>Service</literal>, <literal>Route</literal>, or other objects. If you want to change names or resources,
you can set these values as parameters in the template.</simpara>
</listitem>
</itemizedlist>
<simpara>You can configure the supporting Operators and
templates to the specific needs of your development team and then make them
available in the namespaces in which your developers work. Many people add
shared templates to the <literal>openshift</literal> namespace because it is accessible from all
other namespaces.</simpara>
</section>
<section xml:id="applying-manifest">
<title>Applying the manifest</title>
<simpara>Kubernetes manifests let you create a more complete picture of the components
that make up your Kubernetes applications. You write these manifests as YAML
files and deploy them by applying them to the cluster, for example, by running
the <literal>oc apply</literal> command.</simpara>
</section>
<section xml:id="manifest-next-steps">
<title>Next steps</title>
<simpara>At this point, consider ways to automate your container development process.
Ideally, you have some sort of CI pipeline that builds the images and pushes
them to a registry. In particular, a GitOps pipeline integrates your container
development with the Git repositories that you use to store the software that
is required to build your applications.</simpara>
<simpara>The workflow to this point might look like:</simpara>
<itemizedlist>
<listitem>
<simpara>Day 1: You write some YAML. You then run the <literal>oc apply</literal> command to apply that
YAML to the cluster and test that it works.</simpara>
</listitem>
<listitem>
<simpara>Day 2: You put your YAML container configuration file into your own Git
repository. From there, people who want to install that app, or help you improve
it, can pull down the YAML and apply it to their cluster to run the app.</simpara>
</listitem>
<listitem>
<simpara>Day 3: Consider writing an Operator for your application.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="develop-for-operators">
<title>Develop for Operators</title>
<simpara>Packaging and deploying your application as an Operator might be preferred
if you make your application available for others to run. As noted earlier,
Operators add a lifecycle component to your application that acknowledges that
the job of running an application is not complete as soon as it is installed.</simpara>
<simpara>When you create an application as an Operator, you can build in your own
knowledge of how to run and maintain the application. You can build in features
for upgrading the application, backing it up, scaling it, or keeping track of
its state. If you configure the application correctly, maintenance tasks,
like updating the Operator, can happen automatically and invisibly to the
Operator&#8217;s users.</simpara>
<simpara>An example of a useful Operator is one that is set up to automatically back up
data at particular times. Having an Operator manage an application&#8217;s backup at
set times can save a system administrator from remembering to do it.</simpara>
<simpara>Any application maintenance that has traditionally been completed manually,
like backing up data or rotating certificates, can be completed automatically
with an Operator.</simpara>
</section>
</chapter>
<chapter xml:id="architecture-rhcos">
<title>Red Hat Enterprise Linux CoreOS (RHCOS)</title>

<section xml:id="rhcos-about_architecture-rhcos">
<title>About RHCOS</title>
<simpara>Red Hat Enterprise Linux CoreOS (RHCOS) represents the next generation of single-purpose container operating system technology by providing the quality standards of Red Hat Enterprise Linux (RHEL) with automated, remote upgrade features.</simpara>
<simpara>RHCOS is supported only as a component of {product-title} {product-version} for all {product-title} machines. RHCOS is the only supported operating system for {product-title} control plane, or master, machines. While RHCOS is the default operating system for all cluster machines, you can create compute machines, which are also known as worker machines, that use RHEL as their operating system. There are two general ways RHCOS is deployed in {product-title} {product-version}:</simpara>
<itemizedlist>
<listitem>
<simpara>If you install your cluster on infrastructure that the installation program provisions, RHCOS images are downloaded to the target platform during installation. Suitable Ignition config files, which control the RHCOS configuration, are also downloaded and used to deploy the machines.</simpara>
</listitem>
<listitem>
<simpara>If you install your cluster on infrastructure that you manage, you must follow the installation documentation to obtain the RHCOS images, generate Ignition config files, and use the Ignition config files to provision your machines.</simpara>
</listitem>
</itemizedlist>
<section xml:id="rhcos-key-features_architecture-rhcos">
<title>Key RHCOS features</title>
<simpara>The following list describes key features of the RHCOS operating system:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Based on RHEL</emphasis>: The underlying operating system consists primarily of RHEL components. The same quality, security, and control measures that support RHEL also support RHCOS. For example, RHCOS software is in RPM packages, and each RHCOS system starts up with a RHEL kernel and a set of services that are managed by the systemd init system.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Controlled immutability</emphasis>: Although it contains RHEL components, RHCOS is designed to be managed more tightly than a default RHEL installation. Management is performed remotely from the {product-title} cluster. When you set up your RHCOS machines, you can modify only a few system settings. This controlled immutability allows {product-title} to store the latest state of RHCOS systems in the cluster so it is always able to create additional machines and perform updates based on the latest RHCOS configurations.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">CRI-O container runtime</emphasis>: Although RHCOS contains features for running the OCI- and libcontainer-formatted containers that Docker requires, it incorporates the CRI-O container engine instead of the Docker container engine. By focusing on features needed by Kubernetes platforms, such as {product-title}, CRI-O can offer specific compatibility with different Kubernetes versions. CRI-O also offers a smaller footprint and reduced attack surface than is possible with container engines that offer a larger feature set. At the moment, CRI-O is the only engine available within {product-title} clusters.</simpara>
<simpara>CRI-O can use either the runC or crun container runtime to start and manage containers. For information about how to enable crun, see the documentation for creating a <literal>ContainerRuntimeConfig</literal> CR.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Set of container tools</emphasis>: For tasks such as building, copying, and otherwise managing containers, RHCOS replaces the Docker CLI tool with a compatible set of container tools. The podman CLI tool supports many container runtime features, such as running, starting, stopping, listing, and removing containers and container images. The skopeo CLI tool can copy, authenticate, and sign images. You can use the <literal>crictl</literal> CLI tool to work with containers and pods from the CRI-O container engine. While direct use of these tools in RHCOS is discouraged, you can use them for debugging purposes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">rpm-ostree upgrades</emphasis>: RHCOS features transactional upgrades using the <literal>rpm-ostree</literal> system. Updates are delivered by means of container images and are part of the {product-title} update process. When deployed, the container image is pulled, extracted, and written to disk, then the bootloader is modified to boot into the new version. The machine will reboot into the update in a rolling manner to ensure cluster capacity is minimally impacted.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">bootupd firmware and bootloader updater</emphasis>: Package managers and hybrid systems such as <literal>rpm-ostree</literal> do not update the firmware or the bootloader. With <literal>bootupd</literal>, RHCOS users have access to a cross-distribution, system-agnostic update tool that manages firmware and boot updates in UEFI and legacy BIOS boot modes that run on modern architectures, such as x86_64, ppc64le, and aarch64.</simpara>
<simpara>For information about how to install <literal>bootupd</literal>, see the documentation for <emphasis>Updating the bootloader using bootupd</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Updated through the Machine Config Operator</emphasis>: In {product-title}, the Machine Config Operator handles operating system upgrades. Instead of upgrading individual packages, as is done with <literal>yum</literal> upgrades, <literal>rpm-ostree</literal> delivers upgrades of the OS as an atomic unit. The new OS deployment is staged during upgrades and goes into effect on the next reboot. If something goes wrong with the upgrade, a single rollback and reboot returns the system to the previous state. RHCOS upgrades in {product-title} are performed during cluster updates.</simpara>
</listitem>
</itemizedlist>
<simpara>For RHCOS systems, the layout of the <literal>rpm-ostree</literal> file system has the following characteristics:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/usr</literal> is where the operating system binaries and libraries are stored and is read-only. We do not support altering this.</simpara>
</listitem>
<listitem>
<simpara><literal>/etc</literal>, <literal>/boot</literal>, <literal>/var</literal> are writable on the system but only intended to be altered by the Machine Config Operator.</simpara>
</listitem>
<listitem>
<simpara><literal>/var/lib/containers</literal> is the graph storage location for storing container images.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="rhcos-configured_architecture-rhcos">
<title>Choosing how to configure RHCOS</title>
<simpara>RHCOS is designed to deploy on an {product-title} cluster with a minimal amount of user configuration. In its most basic form, this consists of:</simpara>
<itemizedlist>
<listitem>
<simpara>Starting with a provisioned infrastructure, such as on AWS, or provisioning the infrastructure yourself.</simpara>
</listitem>
<listitem>
<simpara>Supplying a few pieces of information, such as credentials and cluster name, in an <literal>install-config.yaml</literal> file when running <literal>openshift-install</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>Because RHCOS systems in {product-title} are designed to be fully managed from the {product-title} cluster after that, directly changing an RHCOS machine is discouraged. Although limited direct access to RHCOS machines cluster can be accomplished for debugging purposes, you should not directly configure RHCOS systems. Instead, if you need to add or change features on your {product-title} nodes, consider making changes in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kubernetes workload objects, such as DaemonSet and Deployment</emphasis>: If you need to add services or other user-level features to your cluster, consider adding them as Kubernetes workload objects. Keeping those features outside of specific node configurations is the best way to reduce the risk of breaking the cluster on subsequent upgrades.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Day-2 customizations</emphasis>: If possible, bring up a cluster without making any customizations to cluster nodes and make necessary node changes after the cluster is up. Those changes are easier to track later and less likely to break updates. Creating machine configs or modifying Operator custom resources are ways of making these customizations.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Day-1 customizations</emphasis>: For customizations that you must implement when the cluster first comes up, there are ways of modifying your cluster so changes are implemented on first boot.
Day-1 customizations can be done through Ignition configs and manifest files during <literal>openshift-install</literal> or by adding boot options during ISO installs provisioned by the user.</simpara>
</listitem>
</itemizedlist>
<simpara>Here are examples of customizations you could do on day 1:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Kernel arguments</emphasis>: If particular kernel features or tuning is needed on nodes when the cluster first boots.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Disk encryption</emphasis>: If your security needs require that the root file system on the nodes are encrypted, such as with FIPS support.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Kernel modules</emphasis>: If a particular hardware device, such as a network card or video card, does not have a usable module available by default in the Linux kernel.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Chronyd</emphasis>: If you want to provide specific clock settings to your nodes, such as the location of time servers.</simpara>
</listitem>
</itemizedlist>
<simpara>To accomplish these tasks, you can augment the <literal>openshift-install</literal> process to include additional objects such as <literal>MachineConfig</literal> objects. Those procedures that result in creating machine configs can be passed to the Machine Config Operator after the cluster is up.</simpara>
<note>
<itemizedlist>
<listitem>
<simpara>The Ignition config files that the installation program generates contain certificates that expire after 24 hours, which are then renewed at that time. If the cluster is shut down before renewing the certificates and the cluster is later restarted after the 24 hours have elapsed, the cluster automatically recovers the expired certificates. The exception is that you must manually approve the pending <literal>node-bootstrapper</literal> certificate signing requests (CSRs) to recover kubelet certificates. See the documentation for <emphasis>Recovering from expired control plane certificates</emphasis> for more information.</simpara>
</listitem>
<listitem>
<simpara>It is recommended that you use Ignition config files within 12 hours after they are generated because the 24-hour certificate rotates from 16 to 22 hours after the cluster is installed. By using the Ignition config files within 12 hours, you can avoid installation failure if the certificate update runs during installation.</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="rhcos-deployed_architecture-rhcos">
<title>Choosing how to deploy RHCOS</title>
<simpara>Differences between RHCOS installations for {product-title} are based on whether you are deploying on an infrastructure provisioned by the installer or by the user:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Installer-provisioned</emphasis>: Some cloud environments offer preconfigured infrastructures that allow you to bring up an {product-title} cluster with minimal configuration. For these types of installations, you can supply Ignition configs that place content on each node so it is there when the cluster first boots.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">User-provisioned</emphasis>: If you are provisioning your own infrastructure, you have more flexibility in how you add content to a RHCOS node. For example, you could add kernel arguments when you boot the RHCOS ISO installer to install each system. However, in most cases where configuration is required on the operating system itself, it is best to provide that configuration through an Ignition config.</simpara>
</listitem>
</itemizedlist>
<simpara>The Ignition facility runs only when the RHCOS system is first set up. After that, Ignition configs can be supplied later using the machine config.</simpara>
</section>
<section xml:id="rhcos-about-ignition_architecture-rhcos">
<title>About Ignition</title>
<simpara>Ignition is the utility that is used by RHCOS to manipulate disks during initial configuration. It completes common disk tasks, including partitioning disks, formatting partitions, writing files, and configuring users. On first boot, Ignition reads its configuration from the installation media or the location that you specify and applies the configuration to the machines.</simpara>
<simpara>Whether you are installing your cluster or adding machines to it, Ignition always performs the initial configuration of the {product-title} cluster machines. Most of the actual system setup happens on each machine itself. For each machine, Ignition takes the RHCOS image and boots the RHCOS kernel. Options on the kernel command line identify the type of deployment and the location of the Ignition-enabled initial RAM disk (initramfs).</simpara>
<section xml:id="about-ignition_architecture-rhcos">
<title>How Ignition works</title>
<simpara>To create machines by using Ignition, you need Ignition config files. The {product-title} installation program creates the Ignition config files that you need to deploy your cluster. These files are based on the information that you provide to the installation program directly or through an <literal>install-config.yaml</literal> file.</simpara>
<simpara>The way that Ignition configures machines is similar to how tools like <link xl:href="https://cloud-init.io/">cloud-init</link> or Linux Anaconda <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html-single/installation_guide/index#chap-kickstart-installations">kickstart</link> configure systems, but with some important differences:</simpara>
<itemizedlist>
<listitem>
<simpara>Ignition runs from an initial RAM disk that is separate from the system you are installing to. Because of that, Ignition can repartition disks, set up file systems, and perform other changes to the machine&#8217;s permanent file system. In contrast, cloud-init runs as part of a machine init system when the system boots, so making foundational changes to things like disk partitions cannot be done as easily. With cloud-init, it is also difficult to reconfigure the boot process while you are in the middle of the node boot process.</simpara>
</listitem>
<listitem>
<simpara>Ignition is meant to initialize systems, not change existing systems. After a machine initializes and the kernel is running from the installed system, the Machine Config Operator from the {product-title} cluster completes all future machine configuration.</simpara>
</listitem>
<listitem>
<simpara>Instead of completing a defined set of actions, Ignition implements a declarative configuration. It checks that all partitions, files, services, and other items are in place before the new machine starts. It then makes the changes, like copying files to disk that are necessary for the new machine to meet the specified configuration.</simpara>
</listitem>
<listitem>
<simpara>After Ignition finishes configuring a machine, the kernel keeps running but discards the initial RAM disk and pivots to the installed system on disk. All of the new system services and other features start without requiring a system reboot.</simpara>
</listitem>
<listitem>
<simpara>Because Ignition confirms that all new machines meet the declared configuration, you cannot have a partially configured machine. If a machine setup fails, the initialization process does not finish, and Ignition does not start the new machine. Your cluster will never contain partially configured machines. If Ignition cannot complete, the machine is not added to the cluster. You must add a new machine instead. This behavior prevents the difficult case of debugging a machine when the results of a failed configuration task are not known until something that depended on it fails at a later date.</simpara>
</listitem>
<listitem>
<simpara>If there is a problem with an Ignition config that causes the setup of a machine to fail, Ignition will not try to use the same config to set up another machine. For example, a failure could result from an Ignition config made up of a parent and child config that both want to create the same file. A failure in such a case would prevent that Ignition config from being used again to set up an other machines until the problem is resolved.</simpara>
</listitem>
<listitem>
<simpara>If you have multiple Ignition config files, you get a union of that set of configs. Because Ignition is declarative, conflicts between the configs could cause Ignition to fail to set up the machine. The order of information in those files does not matter. Ignition will sort and implement each setting in ways that make the most sense. For example, if a file needs a directory several levels deep, if another file needs a directory along that path, the later file is created first. Ignition sorts and creates all files, directories, and links by depth.</simpara>
</listitem>
<listitem>
<simpara>Because Ignition can start with a completely empty hard disk, it can do something cloud-init cannot do: set up systems on bare metal from scratch using features such as PXE boot. In the bare metal case, the Ignition config is injected into the boot partition so that Ignition can find it and configure the system correctly.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ignition-sequence_architecture-rhcos">
<title>The Ignition sequence</title>
<simpara>The Ignition process for an RHCOS machine in an {product-title} cluster involves the following steps:</simpara>
<itemizedlist>
<listitem>
<simpara>The machine gets its Ignition config file. Control plane machines get their Ignition config files from the bootstrap machine, and worker machines get Ignition config files from a control plane machine.</simpara>
</listitem>
<listitem>
<simpara>Ignition creates disk partitions, file systems, directories, and links on the machine. It supports RAID arrays but does not support LVM volumes.</simpara>
</listitem>
<listitem>
<simpara>Ignition mounts the root of the permanent file system to the <literal>/sysroot</literal> directory in the initramfs and starts working in that <literal>/sysroot</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>Ignition configures all defined file systems and sets them up to mount appropriately at runtime.</simpara>
</listitem>
<listitem>
<simpara>Ignition runs <literal>systemd</literal> temporary files to populate required files in the <literal>/var</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>Ignition runs the Ignition config files to set up users, systemd unit files, and other configuration files.</simpara>
</listitem>
<listitem>
<simpara>Ignition unmounts all components in the permanent system that were mounted in the initramfs.</simpara>
</listitem>
<listitem>
<simpara>Ignition starts up the init process of the new machine, which in turn starts up all other services on the machine that run during system boot.</simpara>
</listitem>
</itemizedlist>
<simpara>At the end of this process, the machine is ready to join the cluster and does not require a reboot.</simpara>
</section>
</section>
</section>
<section xml:id="ignition-config-viewing_architecture-rhcos">
<title>Viewing Ignition configuration files</title>
<simpara>To see the Ignition config file used to deploy the bootstrap machine, run the
following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openshift-install create ignition-configs --dir $HOME/testconfig</programlisting>
<simpara>After you answer a few questions, the <literal>bootstrap.ign</literal>, <literal>master.ign</literal>, and
<literal>worker.ign</literal> files appear in the directory you entered.</simpara>
<simpara>To see the contents of the <literal>bootstrap.ign</literal> file, pipe it through the <literal>jq</literal> filter.
Here&#8217;s a snippet from that file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat $HOME/testconfig/bootstrap.ign | jq
{
  "ignition": {
    "version": "3.2.0"
  },
  "passwd": {
    "users": [
      {
        "name": "core",
        "sshAuthorizedKeys": [
          "ssh-rsa AAAAB3NzaC1yc...."
        ]
      }
    ]
  },
  "storage": {
    "files": [
      {
        "overwrite": false,
        "path": "/etc/motd",
        "user": {
          "name": "root"
        },
        "append": [
          {
            "source": "data:text/plain;charset=utf-8;base64,VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg=="
          }
        ],
        "mode": 420
      },
...</programlisting>
<simpara>To decode the contents of a file listed in the <literal>bootstrap.ign</literal> file, pipe the
base64-encoded data string representing the contents of that file to the <literal>base64
-d</literal> command. Here&#8217;s an example using the contents of the <literal>/etc/motd</literal> file added to
the bootstrap machine from the output shown above:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo VGhpcyBpcyB0aGUgYm9vdHN0cmFwIG5vZGU7IGl0IHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIG1hc3RlciBpcyBmdWxseSB1cC4KClRoZSBwcmltYXJ5IHNlcnZpY2VzIGFyZSByZWxlYXNlLWltYWdlLnNlcnZpY2UgZm9sbG93ZWQgYnkgYm9vdGt1YmUuc2VydmljZS4gVG8gd2F0Y2ggdGhlaXIgc3RhdHVzLCBydW4gZS5nLgoKICBqb3VybmFsY3RsIC1iIC1mIC11IHJlbGVhc2UtaW1hZ2Uuc2VydmljZSAtdSBib290a3ViZS5zZXJ2aWNlCg== | base64 --decode</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">This is the bootstrap node; it will be destroyed when the master is fully up.

The primary services are release-image.service followed by bootkube.service. To watch their status, run e.g.

  journalctl -b -f -u release-image.service -u bootkube.service</programlisting>
</para>
</formalpara>
<simpara>Repeat those commands on the <literal>master.ign</literal> and <literal>worker.ign</literal> files to see the source
of Ignition config files for each of those machine types.  You should see a line
like the following for the <literal>worker.ign</literal>, identifying how it gets its Ignition
config from the bootstrap machine:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">"source": "https://api.myign.develcluster.example.com:22623/config/worker",</programlisting>
<simpara>Here are a few things you can learn from the <literal>bootstrap.ign</literal> file:<?asciidoc-br?></simpara>
<itemizedlist>
<listitem>
<simpara>Format: The format of the file is defined in the
<link xl:href="https://coreos.github.io/ignition/configuration-v3_2/">Ignition config spec</link>.
Files of the same format are used later by the MCO to merge changes into a
machine&#8217;s configuration.</simpara>
</listitem>
<listitem>
<simpara>Contents: Because the bootstrap machine serves the Ignition configs for other
machines, both master and worker machine Ignition config information is stored in the
<literal>bootstrap.ign</literal>, along with the bootstrap machine&#8217;s configuration.</simpara>
</listitem>
<listitem>
<simpara>Size: The file is more than 1300 lines long, with path to various types of resources.</simpara>
</listitem>
<listitem>
<simpara>The content of each file that will be copied to the machine is actually encoded
into data URLs, which tends to make the content a bit clumsy to read. (Use the
  <literal>jq</literal> and <literal>base64</literal> commands shown previously to make the content more readable.)</simpara>
</listitem>
<listitem>
<simpara>Configuration: The different sections of the Ignition config file are generally
meant to contain files that are just dropped into a machine&#8217;s file system, rather
than commands to modify existing files. For example, instead of having a section
on NFS that configures that service, you would just add an NFS configuration
file, which would then be started by the init process when the system comes up.</simpara>
</listitem>
<listitem>
<simpara>users: A user named <literal>core</literal> is created, with your SSH key assigned to that user.
This allows you to log in to the cluster with that user name and your
credentials.</simpara>
</listitem>
<listitem>
<simpara>storage: The storage section identifies files that are added to each machine. A
few notable files include <literal>/root/.docker/config.json</literal> (which provides credentials
  your cluster needs to pull from container image registries) and a bunch of
  manifest files in <literal>/opt/openshift/manifests</literal> that are used to configure your cluster.</simpara>
</listitem>
<listitem>
<simpara>systemd: The <literal>systemd</literal> section holds content used to create <literal>systemd</literal> unit files.
Those files are used to start up services at boot time, as well as manage those
services on running systems.</simpara>
</listitem>
<listitem>
<simpara>Primitives: Ignition also exposes low-level primitives that other tools can
build on.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="digging-into-machine-config_architecture-rhcos">
<title>Changing Ignition configs after installation</title>
<simpara>Machine config pools manage a cluster of nodes and their corresponding machine
configs. Machine configs contain configuration information for a cluster.
To list all machine config pools that are known:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpools</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME   CONFIG                                  UPDATED UPDATING DEGRADED
master master-1638c1aea398413bb918e76632f20799 False   False    False
worker worker-2feef4f8288936489a5a832ca8efe953 False   False    False</programlisting>
</para>
</formalpara>
<simpara>To list all machine configs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfig</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                      GENERATEDBYCONTROLLER   IGNITIONVERSION   CREATED   OSIMAGEURL

00-master                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-master-ssh                             4.0.0-0.150.0.0-dirty                     16m
00-worker                                 4.0.0-0.150.0.0-dirty   3.2.0             16m
00-worker-ssh                             4.0.0-0.150.0.0-dirty                     16m
01-master-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
01-worker-kubelet                         4.0.0-0.150.0.0-dirty   3.2.0             16m
master-1638c1aea398413bb918e76632f20799   4.0.0-0.150.0.0-dirty   3.2.0             16m
worker-2feef4f8288936489a5a832ca8efe953   4.0.0-0.150.0.0-dirty   3.2.0             16m</programlisting>
</para>
</formalpara>
<simpara>The Machine Config Operator acts somewhat differently than Ignition when it
comes to applying these machine configs. The machine configs are read in order
(from 00* to 99*). Labels inside the machine configs identify the type of node
each is for (master or worker). If the same file appears in multiple
machine config files, the last one wins. So, for example, any file that appears
in a 99* file would replace the same file that appeared in a 00* file.
The input <literal>MachineConfig</literal> objects are unioned into a "rendered" <literal>MachineConfig</literal>
object, which will be used as a target by the operator and is the value you
can see in the machine config pool.</simpara>
<simpara>To see what files are being managed from a machine config, look for "Path:"
inside a particular <literal>MachineConfig</literal> object. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfigs 01-worker-container-runtime | grep Path:</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">            Path:            /etc/containers/registries.conf
            Path:            /etc/containers/storage.conf
            Path:            /etc/crio/crio.conf</programlisting>
</para>
</formalpara>
<simpara>Be sure to give the machine config file a later name
(such as 10-worker-container-runtime). Keep in mind that the content of each
file is in URL-style data. Then apply the new machine config to the cluster.</simpara>
</section>
</chapter>
<chapter xml:id="admission-plug-ins">
<title>Admission plugins</title>

<simpara>Admission plugins are used to help regulate how {product-title} functions.</simpara>
<section xml:id="admission-plug-ins-about_admission-plug-ins">
<title>About admission plugins</title>
<simpara>Admission plugins intercept requests to the master API to validate resource requests. After a request is authenticated and authorized, the admission plugins ensure that any associated policies are followed. For example, they are commonly used to enforce security policy, resource limitations or configuration requirements.</simpara>
<simpara>Admission plugins run in sequence as an admission chain. If any admission plugin in the sequence rejects a request, the whole chain is aborted and an error is returned.</simpara>
<simpara>{product-title} has a default set of admission plugins enabled for each resource type. These are required for proper functioning of the cluster. Admission plugins ignore resources that they are not responsible for.</simpara>
<simpara>In addition to the defaults, the admission chain can be extended dynamically through webhook admission plugins that call out to custom webhook servers. There are two types of webhook admission plugins: a mutating admission plugin and a validating admission plugin. The mutating admission plugin runs first and can both modify resources and validate requests. The validating admission plugin validates requests and runs after the mutating admission plugin so that modifications triggered by the mutating admission plugin can also be validated.</simpara>
<simpara>Calling webhook servers through a mutating admission plugin can produce side effects on resources related to the target object. In such situations, you must take steps to validate that the end result is as expected.</simpara>
<warning>
<simpara>Dynamic admission should be used cautiously because it impacts cluster control plane operations. When calling webhook servers through webhook admission plugins in {product-title} {product-version}, ensure that you have read the documentation fully and tested for side effects of mutations. Include steps to restore resources back to their original state prior to mutation, in the event that a request does not pass through the entire admission chain.</simpara>
</warning>
</section>
<section xml:id="admission-plug-ins-default_admission-plug-ins">
<title>Default admission plugins</title>
<simpara>Default validating and admission plugins are enabled in {product-title} {product-version}. These default plugins contribute to fundamental control plane functionality, such as ingress policy, cluster resource limit override and quota policy.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<simpara>The following lists contain the default admission plugins:</simpara>
<example>
<title>Validating admission plugins</title>
<itemizedlist>
<listitem>
<simpara><literal>LimitRanger</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceAccount</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PodNodeSelector</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Priority</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PodTolerationRestriction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>OwnerReferencesPermissionEnforcement</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PersistentVolumeClaimResize</literal></simpara>
</listitem>
<listitem>
<simpara><literal>RuntimeClass</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CertificateApproval</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CertificateSigning</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CertificateSubjectRestriction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>autoscaling.openshift.io/ManagementCPUsOverride</literal></simpara>
</listitem>
<listitem>
<simpara><literal>authorization.openshift.io/RestrictSubjectBindings</literal></simpara>
</listitem>
<listitem>
<simpara><literal>scheduling.openshift.io/OriginPodNodeEnvironment</literal></simpara>
</listitem>
<listitem>
<simpara><literal>network.openshift.io/ExternalIPRanger</literal></simpara>
</listitem>
<listitem>
<simpara><literal>network.openshift.io/RestrictedEndpointsAdmission</literal></simpara>
</listitem>
<listitem>
<simpara><literal>image.openshift.io/ImagePolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>security.openshift.io/SecurityContextConstraint</literal></simpara>
</listitem>
<listitem>
<simpara><literal>security.openshift.io/SCCExecRestrictions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>route.openshift.io/IngressAdmission</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateAPIServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateAuthentication</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateFeatureGate</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateConsole</literal></simpara>
</listitem>
<listitem>
<simpara><literal>operator.openshift.io/ValidateDNS</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateImage</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateOAuth</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateProject</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/DenyDeleteClusterConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateScheduler</literal></simpara>
</listitem>
<listitem>
<simpara><literal>quota.openshift.io/ValidateClusterResourceQuota</literal></simpara>
</listitem>
<listitem>
<simpara><literal>security.openshift.io/ValidateSecurityContextConstraints</literal></simpara>
</listitem>
<listitem>
<simpara><literal>authorization.openshift.io/ValidateRoleBindingRestriction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>config.openshift.io/ValidateNetwork</literal></simpara>
</listitem>
<listitem>
<simpara><literal>operator.openshift.io/ValidateKubeControllerManager</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ValidatingAdmissionWebhook</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ResourceQuota</literal></simpara>
</listitem>
<listitem>
<simpara><literal>quota.openshift.io/ClusterResourceQuota</literal></simpara>
</listitem>
</itemizedlist>
</example>
<example>
<title>Mutating admission plugins</title>
<itemizedlist>
<listitem>
<simpara><literal>NamespaceLifecycle</literal></simpara>
</listitem>
<listitem>
<simpara><literal>LimitRanger</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceAccount</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NodeRestriction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>TaintNodesByCondition</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PodNodeSelector</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Priority</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DefaultTolerationSeconds</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PodTolerationRestriction</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DefaultStorageClass</literal></simpara>
</listitem>
<listitem>
<simpara><literal>StorageObjectInUseProtection</literal></simpara>
</listitem>
<listitem>
<simpara><literal>RuntimeClass</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DefaultIngressClass</literal></simpara>
</listitem>
<listitem>
<simpara><literal>autoscaling.openshift.io/ManagementCPUsOverride</literal></simpara>
</listitem>
<listitem>
<simpara><literal>scheduling.openshift.io/OriginPodNodeEnvironment</literal></simpara>
</listitem>
<listitem>
<simpara><literal>image.openshift.io/ImagePolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>security.openshift.io/SecurityContextConstraint</literal></simpara>
</listitem>
<listitem>
<simpara><literal>security.openshift.io/DefaultSecurityContextConstraints</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MutatingAdmissionWebhook</literal></simpara>
</listitem>
</itemizedlist>
</example>
</section>
<section xml:id="admission-webhooks-about_admission-plug-ins">
<title>Webhook admission plugins</title>
<simpara>In addition to {product-title} default admission plugins, dynamic admission can be implemented through webhook admission plugins that call webhook servers, to extend the functionality of the admission chain. Webhook servers are called over HTTP at defined endpoints.</simpara>
<simpara>There are two types of webhook admission plugins in {product-title}:</simpara>
<itemizedlist>
<listitem>
<simpara>During the admission process, the <emphasis>mutating admission plugin</emphasis> can perform tasks, such as injecting affinity labels.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara>At the end of the admission process, the <emphasis>validating admission plugin</emphasis> can be used to make sure an object is configured properly, for example ensuring affinity labels are as expected. If the validation passes, {product-title} schedules the object as configured.</simpara>
</listitem>
</itemizedlist>
<simpara>When an API request comes in, mutating or validating admission plugins use the list of external webhooks in the configuration and call them in parallel:</simpara>
<itemizedlist>
<listitem>
<simpara>If all of the webhooks approve the request, the admission chain continues.</simpara>
</listitem>
<listitem>
<simpara>If any of the webhooks deny the request, the admission request is denied and the reason for doing so is based on the first denial.</simpara>
</listitem>
<listitem>
<simpara>If more than one webhook denies the admission request, only the first denial reason is returned to the user.</simpara>
</listitem>
<listitem>
<simpara>If an error is encountered when calling a webhook, the request is either denied or the webhook is ignored depending on the error policy set. If the error policy is set to <literal>Ignore</literal>, the request is unconditionally accepted in the event of a failure. If the policy is set to <literal>Fail</literal>, failed requests are denied. Using <literal>Ignore</literal> can result in unpredictable behavior for all clients.</simpara>
</listitem>
</itemizedlist>
<simpara>Communication between the webhook admission plugin and the webhook server must use TLS. Generate a CA certificate and use the certificate to sign the server certificate that is used by your webhook admission server. The PEM-encoded CA certificate is supplied to the webhook admission plugin using a mechanism, such as service serving certificate secrets.</simpara>
<simpara>The following diagram illustrates the sequential admission chain process within which multiple webhook servers are called.</simpara>
<figure>
<title>API admission chain with mutating and validating admission plugins</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/api-admission-chain.png" align="center"/>
</imageobject>
<textobject><phrase>API admission stage</phrase></textobject>
</mediaobject>
</figure>
<simpara>An example webhook admission plugin use case is where all pods must have a common set of labels. In this example, the mutating admission plugin can inject labels and the validating admission plugin can check that labels are as expected. {product-title} would subsequently schedule pods that include required labels and reject those that do not.</simpara>
<simpara>Some common webhook admission plugin use cases include:</simpara>
<itemizedlist>
<listitem>
<simpara>Namespace reservation.</simpara>
</listitem>
<listitem>
<simpara>Limiting custom network resources managed by the SR-IOV network device plugin.</simpara>
</listitem>
<listitem>
<simpara>Defining tolerations that enable taints to qualify which pods should be scheduled on a node.</simpara>
</listitem>
<listitem>
<simpara>Pod priority class validation.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The maximum default webhook timeout value in {product-title} is 13 seconds, and it cannot be changed.</simpara>
</note>
</section>
<section xml:id="admission-webhook-types_admission-plug-ins">
<title>Types of webhook admission plugins</title>
<simpara>Cluster administrators can call out to webhook servers through the mutating admission plugin or the validating admission plugin in the API server admission chain.</simpara>
<section xml:id="mutating-admission-plug-in_admission-plug-ins">
<title>Mutating admission plugin</title>
<simpara>The mutating admission plugin is invoked during the mutation phase of the admission process, which allows modification of resource content before it is persisted. One example webhook that can be called through the mutating admission plugin is the Pod Node Selector feature, which uses an annotation on a namespace to find a label selector and add it to the pod specification.</simpara>
<formalpara xml:id="mutating-admission-plug-in-config_admission-plug-ins">
<title>Sample mutating admission plugin configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: admissionregistration.k8s.io/v1beta1
kind: MutatingWebhookConfiguration <co xml:id="CO1-1"/>
metadata:
  name: &lt;webhook_name&gt; <co xml:id="CO1-2"/>
webhooks:
- name: &lt;webhook_name&gt; <co xml:id="CO1-3"/>
  clientConfig: <co xml:id="CO1-4"/>
    service:
      namespace: default <co xml:id="CO1-5"/>
      name: kubernetes <co xml:id="CO1-6"/>
      path: &lt;webhook_url&gt; <co xml:id="CO1-7"/>
    caBundle: &lt;ca_signing_certificate&gt; <co xml:id="CO1-8"/>
  rules: <co xml:id="CO1-9"/>
  - operations: <co xml:id="CO1-10"/>
    - &lt;operation&gt;
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - &lt;resource&gt;
  failurePolicy: &lt;policy&gt; <co xml:id="CO1-11"/>
  sideEffects: None</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Specifies a mutating admission plugin configuration.</para>
</callout>
<callout arearefs="CO1-2">
<para>The name for the <literal>MutatingWebhookConfiguration</literal> object. Replace <literal>&lt;webhook_name&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO1-3">
<para>The name of the webhook to call. Replace <literal>&lt;webhook_name&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO1-4">
<para>Information about how to connect to, trust, and send data to the webhook server.</para>
</callout>
<callout arearefs="CO1-5">
<para>The namespace where the front-end service is created.</para>
</callout>
<callout arearefs="CO1-6">
<para>The name of the front-end service.</para>
</callout>
<callout arearefs="CO1-7">
<para>The webhook URL used for admission requests. Replace <literal>&lt;webhook_url&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO1-8">
<para>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server.  Replace <literal>&lt;ca_signing_certificate&gt;</literal> with the appropriate certificate in base64 format.</para>
</callout>
<callout arearefs="CO1-9">
<para>Rules that define when the API server should use this webhook admission plugin.</para>
</callout>
<callout arearefs="CO1-10">
<para>One or more operations that trigger the API server to call this webhook admission plugin. Possible values are <literal>create</literal>, <literal>update</literal>, <literal>delete</literal> or <literal>connect</literal>. Replace <literal>&lt;operation&gt;</literal> and <literal>&lt;resource&gt;</literal> with the appropriate values.</para>
</callout>
<callout arearefs="CO1-11">
<para>Specifies how the policy should proceed if the webhook server is unavailable.
Replace <literal>&lt;policy&gt;</literal> with either <literal>Ignore</literal> (to unconditionally accept the request in the event of a failure) or <literal>Fail</literal> (to deny the failed request). Using <literal>Ignore</literal> can result in unpredictable behavior for all clients.</para>
</callout>
</calloutlist>
<important>
<simpara>In {product-title} {product-version}, objects created by users or control loops through a mutating admission plugin might return unexpected results, especially if values set in an initial request are overwritten, which is not recommended.</simpara>
</important>
</section>
<section xml:id="validating-admission-plug-in_admission-plug-ins">
<title>Validating admission plugin</title>
<simpara>A validating admission plugin is invoked during the validation phase of the admission process. This phase allows the enforcement of invariants on particular API resources to ensure that the resource does not change again. The Pod Node Selector is also an example of a webhook which is called by the validating admission plugin, to ensure that all <literal>nodeSelector</literal> fields are constrained by the node selector restrictions on the namespace.</simpara>
<formalpara xml:id="validating-admission-plug-in-config_admission-plug-ins">
<title>Sample validating admission plugin configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration <co xml:id="CO2-1"/>
metadata:
  name: &lt;webhook_name&gt; <co xml:id="CO2-2"/>
webhooks:
- name: &lt;webhook_name&gt; <co xml:id="CO2-3"/>
  clientConfig: <co xml:id="CO2-4"/>
    service:
      namespace: default  <co xml:id="CO2-5"/>
      name: kubernetes <co xml:id="CO2-6"/>
      path: &lt;webhook_url&gt; <co xml:id="CO2-7"/>
    caBundle: &lt;ca_signing_certificate&gt; <co xml:id="CO2-8"/>
  rules: <co xml:id="CO2-9"/>
  - operations: <co xml:id="CO2-10"/>
    - &lt;operation&gt;
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - &lt;resource&gt;
  failurePolicy: &lt;policy&gt; <co xml:id="CO2-11"/>
  sideEffects: Unknown</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>Specifies a validating admission plugin configuration.</para>
</callout>
<callout arearefs="CO2-2">
<para>The name for the <literal>ValidatingWebhookConfiguration</literal> object. Replace <literal>&lt;webhook_name&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO2-3">
<para>The name of the webhook to call. Replace <literal>&lt;webhook_name&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO2-4">
<para>Information about how to connect to, trust, and send data to the webhook server.</para>
</callout>
<callout arearefs="CO2-5">
<para>The namespace where the front-end service is created.</para>
</callout>
<callout arearefs="CO2-6">
<para>The name of the front-end service.</para>
</callout>
<callout arearefs="CO2-7">
<para>The webhook URL used for admission requests. Replace <literal>&lt;webhook_url&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO2-8">
<para>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server.  Replace <literal>&lt;ca_signing_certificate&gt;</literal> with the appropriate certificate in base64 format.</para>
</callout>
<callout arearefs="CO2-9">
<para>Rules that define when the API server should use this webhook admission plugin.</para>
</callout>
<callout arearefs="CO2-10">
<para>One or more operations that trigger the API server to call this webhook admission plugin. Possible values are <literal>create</literal>, <literal>update</literal>, <literal>delete</literal> or <literal>connect</literal>. Replace <literal>&lt;operation&gt;</literal> and <literal>&lt;resource&gt;</literal> with the appropriate values.</para>
</callout>
<callout arearefs="CO2-11">
<para>Specifies how the policy should proceed if the webhook server is unavailable.
Replace <literal>&lt;policy&gt;</literal> with either <literal>Ignore</literal> (to unconditionally accept the request in the event of a failure) or <literal>Fail</literal> (to deny the failed request). Using <literal>Ignore</literal> can result in unpredictable behavior for all clients.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="configuring-dynamic-admission_admission-plug-ins">
<title>Configuring dynamic admission</title>
<simpara>This procedure outlines high-level steps to configure dynamic admission. The functionality of the admission chain is extended by configuring a webhook admission plugin to call out to a webhook server.</simpara>
<simpara>The webhook server is also configured as an aggregated API server. This allows other {product-title} components to communicate with the webhook using internal credentials and facilitates testing using the <literal>oc</literal> command. Additionally, this enables role based access control (RBAC) into the webhook and prevents token information from other API servers from being disclosed to the webhook.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An {product-title} account with cluster administrator access.</simpara>
</listitem>
<listitem>
<simpara>The {product-title} CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
<listitem>
<simpara>A published webhook server container image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Build a webhook server container image and make it available to the cluster using an image registry.</simpara>
</listitem>
<listitem>
<simpara>Create a local CA key and certificate and use them to sign the webhook server&#8217;s certificate signing request (CSR).</simpara>
</listitem>
<listitem>
<simpara>Create a new project for webhook resources:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-webhook-namespace  <co xml:id="CO3-1"/></programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>Note that the webhook server might expect a specific name.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Define RBAC rules for the aggregated API service in a file called <literal>rbac.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: List
items:

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-1"/>
  kind: ClusterRoleBinding
  metadata:
    name: auth-delegator-my-webhook-namespace
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: system:auth-delegator
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-2"/>
  kind: ClusterRole
  metadata:
    annotations:
    name: system:openshift:online:my-webhook-server
  rules:
  - apiGroups:
    - online.openshift.io
    resources:
    - namespacereservations  <co xml:id="CO4-3"/>
    verbs:
    - get
    - list
    - watch

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-4"/>
  kind: ClusterRole
  metadata:
    name: system:openshift:online:my-webhook-requester
  rules:
  - apiGroups:
    - admission.online.openshift.io
    resources:
    - namespacereservations <co xml:id="CO4-5"/>
    verbs:
    - create

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-6"/>
  kind: ClusterRoleBinding
  metadata:
    name: my-webhook-server-my-webhook-namespace
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: system:openshift:online:my-webhook-server
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-7"/>
  kind: RoleBinding
  metadata:
    namespace: kube-system
    name: extension-server-authentication-reader-my-webhook-namespace
  roleRef:
    kind: Role
    apiGroup: rbac.authorization.k8s.io
    name: extension-apiserver-authentication-reader
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server

- apiVersion: rbac.authorization.k8s.io/v1  <co xml:id="CO4-8"/>
  kind: ClusterRole
  metadata:
    name: my-cluster-role
  rules:
  - apiGroups:
    - admissionregistration.k8s.io
    resources:
    - validatingwebhookconfigurations
    - mutatingwebhookconfigurations
    verbs:
    - get
    - list
    - watch
  - apiGroups:
    - ""
    resources:
    - namespaces
    verbs:
    - get
    - list
    - watch

- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: my-cluster-role
  roleRef:
    kind: ClusterRole
    apiGroup: rbac.authorization.k8s.io
    name: my-cluster-role
  subjects:
  - kind: ServiceAccount
    namespace: my-webhook-namespace
    name: server</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Delegates authentication and authorization to the webhook server API.</para>
</callout>
<callout arearefs="CO4-2">
<para>Allows the webhook server to access cluster resources.</para>
</callout>
<callout arearefs="CO4-3">
<para>Points to resources. This example points to the <literal>namespacereservations</literal> resource.</para>
</callout>
<callout arearefs="CO4-4">
<para>Enables the aggregated API server to create admission reviews.</para>
</callout>
<callout arearefs="CO4-5">
<para>Points to resources. This example points to the <literal>namespacereservations</literal> resource.</para>
</callout>
<callout arearefs="CO4-6">
<para>Enables the webhook server to access cluster resources.</para>
</callout>
<callout arearefs="CO4-7">
<para>Role binding to read the configuration for terminating authentication.</para>
</callout>
<callout arearefs="CO4-8">
<para>Default cluster role and cluster role bindings for an aggregated API server.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply those RBAC rules to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc auth reconcile -f rbac.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file called <literal>webhook-daemonset.yaml</literal> that is used to deploy a webhook as a daemon set server in a namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: my-webhook-namespace
  name: server
  labels:
    server: "true"
spec:
  selector:
    matchLabels:
      server: "true"
  template:
    metadata:
      name: server
      labels:
        server: "true"
    spec:
      serviceAccountName: server
      containers:
      - name: my-webhook-container  <co xml:id="CO5-1"/>
        image: &lt;image_registry_username&gt;/&lt;image_path&gt;:&lt;tag&gt;  <co xml:id="CO5-2"/>
        imagePullPolicy: IfNotPresent
        command:
        - &lt;container_commands&gt;  <co xml:id="CO5-3"/>
        ports:
        - containerPort: 8443 <co xml:id="CO5-4"/>
        volumeMounts:
        - mountPath: /var/serving-cert
          name: serving-cert
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8443 <co xml:id="CO5-5"/>
            scheme: HTTPS
      volumes:
      - name: serving-cert
        secret:
          defaultMode: 420
          secretName: server-serving-cert</programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Note that the webhook server might expect a specific container name.</para>
</callout>
<callout arearefs="CO5-2">
<para>Points to a webhook server container image. Replace <literal>&lt;image_registry_username&gt;/&lt;image_path&gt;:&lt;tag&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO5-3">
<para>Specifies webhook container run commands. Replace <literal>&lt;container_commands&gt;</literal> with the appropriate value.</para>
</callout>
<callout arearefs="CO5-4">
<para>Defines the target port within pods. This example uses port 8443.</para>
</callout>
<callout arearefs="CO5-5">
<para>Specifies the port used by the readiness probe. This example uses port 8443.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Deploy the daemon set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-daemonset.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a secret for the service serving certificate signer, within a YAML file called <literal>webhook-secret.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: my-webhook-namespace
  name: server-serving-cert
type: kubernetes.io/tls
data:
  tls.crt: &lt;server_certificate&gt;  <co xml:id="CO6-1"/>
  tls.key: &lt;server_key&gt;  <co xml:id="CO6-2"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>References the signed webhook server certificate. Replace <literal>&lt;server_certificate&gt;</literal> with the appropriate certificate in base64 format.</para>
</callout>
<callout arearefs="CO6-2">
<para>References the signed webhook server key. Replace <literal>&lt;server_key&gt;</literal> with the appropriate key in base64 format.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-secret.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a service account and service, within a YAML file called <literal>webhook-service.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: List
items:

- apiVersion: v1
  kind: ServiceAccount
  metadata:
    namespace: my-webhook-namespace
    name: server

- apiVersion: v1
  kind: Service
  metadata:
    namespace: my-webhook-namespace
    name: server
    annotations:
      service.beta.openshift.io/serving-cert-secret-name: server-serving-cert
  spec:
    selector:
      server: "true"
    ports:
    - port: 443  <co xml:id="CO7-1"/>
      targetPort: 8443  <co xml:id="CO7-2"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Defines the port that the service listens on. This example uses port 443.</para>
</callout>
<callout arearefs="CO7-2">
<para>Defines the target port within pods that the service forwards connections to. This example uses port 8443.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Expose the webhook server within the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-service.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a custom resource definition for the webhook server, in a file called <literal>webhook-crd.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: namespacereservations.online.openshift.io  <co xml:id="CO8-1"/>
spec:
  group: online.openshift.io  <co xml:id="CO8-2"/>
  version: v1alpha1  <co xml:id="CO8-3"/>
  scope: Cluster  <co xml:id="CO8-4"/>
  names:
    plural: namespacereservations  <co xml:id="CO8-5"/>
    singular: namespacereservation  <co xml:id="CO8-6"/>
    kind: NamespaceReservation  <co xml:id="CO8-7"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Reflects <literal>CustomResourceDefinition</literal> <literal>spec</literal> values and is in the format <literal>&lt;plural&gt;.&lt;group&gt;</literal>. This example uses the <literal>namespacereservations</literal> resource.</para>
</callout>
<callout arearefs="CO8-2">
<para>REST API group name.</para>
</callout>
<callout arearefs="CO8-3">
<para>REST API version name.</para>
</callout>
<callout arearefs="CO8-4">
<para>Accepted values are <literal>Namespaced</literal> or <literal>Cluster</literal>.</para>
</callout>
<callout arearefs="CO8-5">
<para>Plural name to be included in URL.</para>
</callout>
<callout arearefs="CO8-6">
<para>Alias seen in <literal>oc</literal> output.</para>
</callout>
<callout arearefs="CO8-7">
<para>The reference for resource manifests.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the custom resource definition:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-crd.yaml</programlisting>
</listitem>
<listitem>
<simpara>Configure the webhook server also as an aggregated API server, within a file called <literal>webhook-api-service.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apiregistration.k8s.io/v1beta1
kind: APIService
metadata:
  name: v1beta1.admission.online.openshift.io
spec:
  caBundle: &lt;ca_signing_certificate&gt;  <co xml:id="CO9-1"/>
  group: admission.online.openshift.io
  groupPriorityMinimum: 1000
  versionPriority: 15
  service:
    name: server
    namespace: my-webhook-namespace
  version: v1beta1</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server. Replace <literal>&lt;ca_signing_certificate&gt;</literal> with the appropriate certificate in base64 format.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Deploy the aggregated API service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-api-service.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define the webhook admission plugin configuration within a file called <literal>webhook-config.yaml</literal>. This example uses the validating admission plugin:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration
metadata:
  name: namespacereservations.admission.online.openshift.io  <co xml:id="CO10-1"/>
webhooks:
- name: namespacereservations.admission.online.openshift.io  <co xml:id="CO10-2"/>
  clientConfig:
    service:  <co xml:id="CO10-3"/>
      namespace: default
      name: kubernetes
      path: /apis/admission.online.openshift.io/v1beta1/namespacereservations  <co xml:id="CO10-4"/>
    caBundle: &lt;ca_signing_certificate&gt;  <co xml:id="CO10-5"/>
  rules:
  - operations:
    - CREATE
    apiGroups:
    - project.openshift.io
    apiVersions:
    - "*"
    resources:
    - projectrequests
  - operations:
    - CREATE
    apiGroups:
    - ""
    apiVersions:
    - "*"
    resources:
    - namespaces
  failurePolicy: Fail</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>Name for the <literal>ValidatingWebhookConfiguration</literal> object. This example uses the <literal>namespacereservations</literal> resource.</para>
</callout>
<callout arearefs="CO10-2">
<para>Name of the webhook to call. This example uses the <literal>namespacereservations</literal> resource.</para>
</callout>
<callout arearefs="CO10-3">
<para>Enables access to the webhook server through the aggregated API.</para>
</callout>
<callout arearefs="CO10-4">
<para>The webhook URL used for admission requests. This example uses the <literal>namespacereservation</literal> resource.</para>
</callout>
<callout arearefs="CO10-5">
<para>A PEM-encoded CA certificate that signs the server certificate that is used by the webhook server. Replace <literal>&lt;ca_signing_certificate&gt;</literal> with the appropriate certificate in base64 format.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Deploy the webhook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f webhook-config.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the webhook is functioning as expected. For example, if you have configured dynamic admission to reserve specific namespaces, confirm that requests to create those namespaces are rejected and that requests to create non-reserved namespaces succeed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="admission-plug-ins-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../networking/hardware_networks/configuring-sriov-operator.xml#configuring-sriov-operator">Limiting custom network resources managed by the SR-IOV network device plugin</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations_dedicating_nodes-scheduler-taints-tolerations">Defining tolerations that enable taints to qualify which pods should be scheduled on a node</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/pods/nodes-pods-priority.xml#admin-guide-priority-preemption-names_nodes-pods-priority">Pod priority class validation</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
</book>