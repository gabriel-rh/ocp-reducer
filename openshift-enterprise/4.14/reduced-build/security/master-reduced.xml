<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Security and compliance</title>
<date>2024-02-20</date>
</info>
<chapter xml:id="security-compliance-overview">
<title>OpenShift Container Platform security and compliance</title>

<section xml:id="security-overview">
<title>Security overview</title>
<simpara>It is important to understand how to properly secure various aspects of your OpenShift Container Platform cluster.</simpara>
<bridgehead xml:id="container-security" renderas="sect3">Container security</bridgehead>
<simpara>A good starting point to understanding OpenShift Container Platform security is to review the concepts in <link xlink:href="../security/container_security/security-understanding.xml#security-understanding">Understanding container security</link>. This and subsequent sections provide a high-level walkthrough of the container security measures available in OpenShift Container Platform, including solutions for the host layer, the container and orchestration layer, and the build and application layer. These sections also include information on the following topics:</simpara>
<itemizedlist>
<listitem>
<simpara>Why container security is important and how it compares with existing security standards.</simpara>
</listitem>
<listitem>
<simpara>Which container security measures are provided by the host (RHCOS and RHEL) layer and
which are provided by OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>How to evaluate your container content and sources for vulnerabilities.</simpara>
</listitem>
<listitem>
<simpara>How to design your build and deployment process to proactively check container content.</simpara>
</listitem>
<listitem>
<simpara>How to control access to containers through authentication and authorization.</simpara>
</listitem>
<listitem>
<simpara>How networking and attached storage are secured in OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Containerized solutions for API management and SSO.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="auditing" renderas="sect3">Auditing</bridgehead>
<simpara>OpenShift Container Platform auditing provides a security-relevant chronological set of records documenting the sequence of activities that have affected the system by individual users, administrators, or other components of the system. Administrators can <link xlink:href="../security/audit-log-policy-config.xml#audit-log-policy-config">configure the audit log policy</link> and <link xlink:href="../security/audit-log-view.xml#audit-log-view">view audit logs</link>.</simpara>
<bridgehead xml:id="certificates" renderas="sect3">Certificates</bridgehead>
<simpara>Certificates are used by various components to validate access to the cluster. Administrators can <link xlink:href="../security/certificates/replacing-default-ingress-certificate.xml#replacing-default-ingress">replace the default ingress certificate</link>, <link xlink:href="../security/certificates/api-server.xml#api-server-certificates">add API server certificates</link>, or <link xlink:href="../security/certificates/service-serving-certificate.xml#add-service-serving">add a service certificate</link>.</simpara>
<simpara>You can also review more details about the types of certificates used by the cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/user-provided-certificates-for-api-server.xml#cert-types-user-provided-certificates-for-the-api-server">User-provided certificates for the API server</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/proxy-certificates.xml#cert-types-proxy-certificates">Proxy certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/service-ca-certificates.xml#cert-types-service-ca-certificates">Service CA certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/node-certificates.xml#cert-types-node-certificates">Node certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/bootstrap-certificates.xml#cert-types-bootstrap-certificates">Bootstrap certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/etcd-certificates.xml#cert-types-etcd-certificates">etcd certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/olm-certificates.xml#cert-types-olm-certificates">OLM certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/aggregated-api-client-certificates.xml#cert-types-aggregated-api-client-certificates">Aggregated API client certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/machine-config-operator-certificates.xml#cert-types-machine-config-operator-certificates">Machine Config Operator certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/user-provided-certificates-for-default-ingress.xml#cert-types-user-provided-certificates-for-default-ingress">User-provided certificates for default ingress</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/ingress-certificates.xml#cert-types-ingress-certificates">Ingress certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/monitoring-and-cluster-logging-operator-component-certificates.xml#cert-types-monitoring-and-cluster-logging-operator-component-certificates">Monitoring and cluster logging Operator component certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/certificate_types_descriptions/control-plane-certificates.xml#cert-types-control-plane-certificates">Control plane certificates</link></simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="encrypting-data" renderas="sect3">Encrypting data</bridgehead>
<simpara>You can <link xlink:href="../security/encrypting-etcd.xml#encrypting-etcd">enable etcd encryption</link> for your cluster to provide an additional layer of data security. For example, it can help protect the loss of sensitive data if an etcd backup is exposed to the incorrect parties.</simpara>
<bridgehead xml:id="vulnerability-scanning" renderas="sect3">Vulnerability scanning</bridgehead>
<simpara>Administrators can use the Red Hat Quay Container Security Operator to run <link xlink:href="../security/pod-vulnerability-scan.xml#pod-vulnerability-scan">vulnerability scans</link> and review information about detected vulnerabilities.</simpara>
</section>
<section xml:id="compliance-overview">
<title>Compliance overview</title>
<simpara>For many OpenShift Container Platform customers, regulatory readiness, or compliance, on some level is required before any systems can be put into production. That regulatory readiness can be imposed by national standards, industry standards, or the organization&#8217;s corporate governance framework.</simpara>
<bridgehead xml:id="compliance-checking" renderas="sect3">Compliance checking</bridgehead>
<simpara>Administrators can use the <link xlink:href="../security/compliance_operator/co-concepts/compliance-operator-understanding.xml#understanding-compliance-operator">Compliance Operator</link> to run compliance scans and recommend remediations for any issues found. The <link xlink:href="../security/compliance_operator/co-scans/oc-compliance-plug-in-using.xml#using-oc-compliance-plug-in"><literal>oc-compliance</literal> plugin</link> is an OpenShift CLI (<literal>oc</literal>) plugin that provides a set of utilities to easily interact with the Compliance Operator.</simpara>
<bridgehead xml:id="file-integrity-checking" renderas="sect3">File integrity checking</bridgehead>
<simpara>Administrators can use the <link xlink:href="../security/file_integrity_operator/file-integrity-operator-understanding.xml#understanding-file-integrity-operator">File Integrity Operator</link> to continually run file integrity checks on cluster nodes and provide a log of files that have been modified.</simpara>
</section>
<section xml:id="additional-resources_security-compliance-overview" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../authentication/understanding-authentication.xml#understanding-authentication">Understanding authentication</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/configuring-internal-oauth.xml#configuring-internal-oauth">Configuring the internal OAuth server</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/understanding-identity-provider.xml#understanding-identity-provider">Understanding identity provider configuration</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/using-rbac.xml#using-rbac">Using RBAC to define and apply permissions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/managing-security-context-constraints.xml#managing-pod-security-policies">Managing security context constraints</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_container_security">
<title>Container security</title>
<section xml:id="security-understanding">
<title>Understanding container security</title>

<simpara>Securing a containerized application relies on multiple levels of security:</simpara>
<itemizedlist>
<listitem>
<simpara>Container security begins with a trusted base container image and continues
through the container build process as it moves through your CI/CD pipeline.</simpara>
<important>
<simpara>Image streams by default do not automatically update. This default behavior might create a security issue because security updates to images referenced by an image stream do not automatically occur.
For information about how to override this default behavior, see <link xlink:href="../../openshift_images/image-streams-manage.xml#images-imagestreams-import_image-streams-managing">Configuring periodic importing of imagestreamtags</link>.</simpara>
</important>
</listitem>
<listitem>
<simpara>When a container is deployed, its security depends on it running
on secure operating systems and networks, and
establishing firm boundaries between the container itself and
the users and hosts that interact with it.</simpara>
</listitem>
<listitem>
<simpara>Continued security relies on being able to scan container images for
vulnerabilities and having an efficient way to correct and
replace vulnerable images.</simpara>
</listitem>
</itemizedlist>
<simpara>Beyond what a platform such as OpenShift Container Platform offers out of the box,
your organization will likely have its own security demands. Some level
of compliance verification might be needed before you can even bring
OpenShift Container Platform into your data center.</simpara>
<simpara>Likewise, you may need to add your own agents, specialized hardware drivers,
or encryption features to OpenShift Container Platform, before it can meet your
organization&#8217;s security standards.</simpara>
<simpara>This guide provides a high-level walkthrough of the container security measures
available in OpenShift Container Platform, including solutions for the host layer, the
container and orchestration layer, and the build and application layer.
It then points you to specific OpenShift Container Platform documentation to
help you achieve those security measures.</simpara>
<simpara>This guide contains the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>Why container security is important and how it compares with existing security standards.</simpara>
</listitem>
<listitem>
<simpara>Which container security measures are provided by the host (RHCOS and RHEL) layer and
which are provided by OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>How to evaluate your container content and sources for vulnerabilities.</simpara>
</listitem>
<listitem>
<simpara>How to design your build and deployment process to proactively check container content.</simpara>
</listitem>
<listitem>
<simpara>How to control access to containers through authentication and authorization.</simpara>
</listitem>
<listitem>
<simpara>How networking and attached storage are secured in OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Containerized solutions for API management and SSO.</simpara>
</listitem>
</itemizedlist>
<simpara>The goal of this guide is to understand the incredible security benefits of
using OpenShift Container Platform for your containerized workloads and how the entire
Red Hat ecosystem plays a part in making and keeping containers secure.
It will also help you understand how you can engage with the OpenShift Container Platform
to achieve your organization&#8217;s security goals.</simpara>
<section xml:id="security-understanding-containers_security-understanding">
<title>What are containers?</title>
<simpara>Containers package an application and all its dependencies into a single image
that can be promoted from development, to test, to production, without change.
A container might be part of a larger application that works closely with other
containers.</simpara>
<simpara>Containers provide consistency across environments and multiple deployment
targets: physical servers, virtual machines (VMs), and private or public cloud.</simpara>
<simpara>Some of the benefits of using containers include:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Infrastructure</entry>
<entry align="left" valign="top">Applications</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Sandboxed application processes on a shared Linux operating system kernel</simpara></entry>
<entry align="left" valign="top"><simpara>Package my application and all of its dependencies</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Simpler, lighter, and denser than virtual machines</simpara></entry>
<entry align="left" valign="top"><simpara>Deploy to any environment in seconds and enable CI/CD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Portable across different environments</simpara></entry>
<entry align="left" valign="top"><simpara>Easily access and share containerized components</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>See <link xlink:href="https://www.redhat.com/en/topics/containers">Understanding Linux containers</link> from the Red Hat Customer Portal
to find out more about Linux containers. To learn about RHEL container tools, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index">Building, running, and managing containers</link> in the RHEL product documentation.</simpara>
</section>
<section xml:id="security-understanding-openshift_security-understanding">
<title>What is OpenShift Container Platform?</title>
<simpara>Automating how containerized applications are deployed, run, and managed is the
job of a platform such as OpenShift Container Platform. At its core, OpenShift Container Platform relies
on the Kubernetes project to provide the engine for orchestrating containers
across many nodes in scalable data centers.</simpara>
<simpara>Kubernetes is a project, which can run using different operating systems
and add-on components that offer no guarantees of supportability from the project.
As a result, the security of different Kubernetes platforms can vary.</simpara>
<simpara>OpenShift Container Platform is designed to lock down Kubernetes security and integrate
the platform with a variety of extended components. To do this,
OpenShift Container Platform draws on the extensive Red Hat ecosystem of open source
technologies that include the operating systems, authentication, storage,
networking, development tools, base container images, and many other
components.</simpara>
<simpara>OpenShift Container Platform can leverage Red Hat&#8217;s experience in uncovering
and rapidly deploying fixes for vulnerabilities in the platform itself
as well as the containerized applications running on the platform.
Red Hat&#8217;s experience also extends to efficiently integrating new
components with OpenShift Container Platform as they become available and
adapting technologies to individual customer needs.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../architecture/architecture.xml#architecture">OpenShift Container Platform architecture</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://www.redhat.com/en/resources/openshift-security-guide-ebook">OpenShift Security Guide</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-hosts-vms">
<title>Understanding host and VM security</title>

<simpara>Both containers and virtual machines provide ways of separating
applications running on a host from the operating system itself.
Understanding RHCOS, which is the operating system used by
OpenShift Container Platform, will help you see how the host
systems protect containers and hosts from each other.</simpara>
<section xml:id="security-hosts-vms-rhcos_security-hosts-vms">
<title>Securing containers on Red Hat Enterprise Linux CoreOS (RHCOS)</title>
<simpara>Containers simplify the act of deploying many applications to run on the same host, using the same kernel and container runtime to spin up each container. The applications can be owned by many users and, because they are kept separate, can run different, and even incompatible, versions of those applications at the same time without issue.</simpara>
<simpara>In Linux, containers are just a special type of process, so securing containers is similar in many ways to securing any other running process. An environment for running containers starts with an operating system that can secure the host kernel from containers and other processes running on the host, as well as secure containers from each other.</simpara>
<simpara>Because OpenShift Container Platform 4.14 runs on RHCOS hosts, with the option of using Red Hat Enterprise Linux (RHEL) as worker nodes, the following concepts apply by default to any deployed OpenShift Container Platform cluster. These RHEL security features are at the core of what makes running containers in OpenShift Container Platform more secure:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Linux namespaces</emphasis> enable creating an abstraction of a particular global system resource to make it appear as a separate instance to processes within a namespace. Consequently, several containers can use the same computing resource simultaneously without creating a conflict. Container namespaces that are separate from the host by default include mount table, process table, network interface, user, control group, UTS, and IPC namespaces. Those containers that need direct access to host namespaces need to have elevated permissions to request that access.
See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index">Overview of Containers in Red Hat Systems</link> from the RHEL 8 container documentation for details on the types of namespaces.</simpara>
</listitem>
<listitem>
<simpara><emphasis>SELinux</emphasis> provides an additional layer of security to keep containers isolated from each other and from the host. SELinux allows administrators to enforce mandatory access controls (MAC) for every user, application, process, and file.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Disabling SELinux on RHCOS is not supported.</simpara>
</warning>
<itemizedlist>
<listitem>
<simpara><emphasis>CGroups</emphasis> (control groups) limit, account for, and isolate the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes. CGroups are used to ensure that containers on the same host are not impacted by each other.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Secure computing mode (seccomp)</emphasis> profiles can be associated with a container to restrict available system calls. See page 94 of the <link xlink:href="https://access.redhat.com/articles/5059881">OpenShift Security Guide</link> for details about seccomp.</simpara>
</listitem>
<listitem>
<simpara>Deploying containers using <emphasis>RHCOS</emphasis> reduces the attack surface by minimizing the host environment and tuning it for containers. The <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/3.11/html-single/cri-o_runtime/index">CRI-O container engine</link> further reduces that attack surface by implementing only those features required by Kubernetes and OpenShift Container Platform to run and manage containers, as opposed to other container engines that implement desktop-oriented standalone features.</simpara>
</listitem>
</itemizedlist>
<simpara>RHCOS is a version of Red Hat Enterprise Linux (RHEL) that is specially configured to work as control plane (master) and worker nodes on OpenShift Container Platform clusters. So RHCOS is tuned to efficiently run container workloads, along with Kubernetes and OpenShift Container Platform services.</simpara>
<simpara>To further protect RHCOS systems in OpenShift Container Platform clusters, most containers, except those managing or monitoring the host system itself, should run as a non-root user. Dropping the privilege level or creating containers with the least amount of privileges possible is recommended best practice for protecting your own OpenShift Container Platform clusters.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../nodes/nodes/nodes-nodes-resources-configuring.xml#allocate-node-enforcement_nodes-nodes-resources-configuring">How nodes enforce resource constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/managing-security-context-constraints.xml#managing-pod-security-policies">Managing security context constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../architecture/architecture-installation.xml#supported-platforms-for-openshift-clusters_architecture-installation">Supported platforms for OpenShift clusters</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installation-requirements-user-infra_installing-bare-metal">Requirements for a cluster with user-provisioned infrastructure</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../architecture/architecture-rhcos.xml#rhcos-configured_architecture-rhcos">Choosing how to configure RHCOS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../architecture/architecture-rhcos.xml#rhcos-about-ignition_architecture-rhcos">Ignition</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installation-special-config-kargs_installing-customizing">Kernel arguments</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installation-special-config-kmod_installing-customizing">Kernel modules</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installation-special-config-encrypt-disk_installing-customizing">Disk encryption</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installation-special-config-chrony_installing-customizing">Chrony time service</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../updating/understanding_updates/intro-to-updates.xml#update-service-about_understanding-openshift-updates">About the OpenShift Update Service</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing-fips.xml#installing-fips">FIPS cryptography</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-hosts-vms-vs-containers_security-hosts-vms">
<title>Comparing virtualization and containers</title>
<simpara>Traditional virtualization provides another way to keep application
environments separate on the same physical host. However, virtual machines
work in a different way than containers.
Virtualization relies on a hypervisor spinning up guest
virtual machines (VMs), each of which has its own operating system (OS),
represented by a running kernel, as well as the running application and its dependencies.</simpara>
<simpara>With VMs, the hypervisor isolates the guests from each other and from the host
kernel. Fewer individuals and processes have access to the hypervisor, reducing
the attack surface on the physical server. That said, security must still be
monitored: one guest VM might be able to use hypervisor bugs to gain access to
another VM or the host kernel. And, when the OS needs to be patched, it must be
patched on all guest VMs using that OS.</simpara>
<simpara>Containers can be run inside guest VMs, and there might be use cases where this is
desirable. For example, you might be deploying a traditional application in a
container, perhaps to lift-and-shift an application to the cloud.</simpara>
<simpara>Container separation on a single host, however, provides a more lightweight,
flexible, and easier-to-scale deployment solution. This deployment model is
particularly appropriate for cloud-native applications. Containers are
generally much smaller than VMs and consume less memory and CPU.</simpara>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/overview_of_containers_in_red_hat_systems/introduction_to_linux_containers#linux_containers_compared_to_kvm_virtualization">Linux Containers Compared to KVM Virtualization</link>
in the RHEL 7 container documentation to learn about the differences between container and VMs.</simpara>
</section>
<section xml:id="security-hosts-vms-openshift_security-hosts-vms">
<title>Securing OpenShift Container Platform</title>
<simpara>When you deploy OpenShift Container Platform, you have the choice of an
installer-provisioned infrastructure (there are several available platforms)
or your own user-provisioned infrastructure.
Some low-level security-related configuration, such as enabling FIPS
mode or adding kernel modules required at first boot, might
benefit from a user-provisioned infrastructure.
Likewise, user-provisioned infrastructure is appropriate for disconnected OpenShift Container Platform deployments.</simpara>
<simpara>Keep in mind that, when it comes to making security enhancements and other
configuration changes to OpenShift Container Platform, the goals should include:</simpara>
<itemizedlist>
<listitem>
<simpara>Keeping the underlying nodes as generic as possible. You want to be able to
easily throw away and spin up similar nodes quickly and in prescriptive ways.</simpara>
</listitem>
<listitem>
<simpara>Managing modifications to nodes through OpenShift Container Platform as much as possible,
rather than making direct, one-off changes to the nodes.</simpara>
</listitem>
</itemizedlist>
<simpara>In pursuit of those goals, most node changes should be done during installation through Ignition
or later using MachineConfigs that are applied to sets of nodes by the Machine Config Operator.
Examples of security-related configuration changes you can do in this way include:</simpara>
<itemizedlist>
<listitem>
<simpara>Adding kernel arguments</simpara>
</listitem>
<listitem>
<simpara>Adding kernel modules</simpara>
</listitem>
<listitem>
<simpara>Enabling support for FIPS cryptography</simpara>
</listitem>
<listitem>
<simpara>Configuring disk encryption</simpara>
</listitem>
<listitem>
<simpara>Configuring the chrony time service</simpara>
</listitem>
</itemizedlist>
<simpara>Besides the Machine Config Operator, there are several other Operators available to configure OpenShift Container Platform infrastructure that are managed by the Cluster Version Operator (CVO). The CVO is able to automate many aspects of
OpenShift Container Platform cluster updates.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../installing/installing-fips.xml#installing-fips">FIPS cryptography</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-hardening">
<title>Hardening RHCOS</title>

<simpara>RHCOS was created and tuned to be deployed in OpenShift Container Platform with
few if any changes needed to RHCOS nodes.
Every organization adopting OpenShift Container Platform has its own requirements for
system hardening. As a RHEL system with OpenShift-specific modifications and
features added (such as Ignition, ostree, and a read-only <literal>/usr</literal> to provide
limited immutability),
RHCOS can be hardened just as you would any RHEL system.
Differences lie in the ways you manage the hardening.</simpara>
<simpara>A key feature of OpenShift Container Platform and its Kubernetes engine is to be able
to quickly scale applications and infrastructure up and down as needed.
Unless it is unavoidable, you do not want to make direct changes to RHCOS by
logging into a host and adding software or changing settings. You want
to have the OpenShift Container Platform installer and control plane manage changes
to RHCOS so new nodes can be spun up without manual intervention.</simpara>
<simpara>So, if you are setting out to harden RHCOS nodes in OpenShift Container Platform to meet
your security needs, you should consider both what to harden
and how to go about doing that hardening.</simpara>
<section xml:id="security-hardening-what_security-hardening">
<title>Choosing what to harden in RHCOS</title>
<simpara>The <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/security_hardening/index#scanning-container-and-container-images-for-vulnerabilities_scanning-the-system-for-security-compliance-and-vulnerabilities">RHEL 8 Security Hardening</link> guide describes how you should approach security for any
RHEL system.</simpara>
<simpara>Use this guide to learn how to approach cryptography, evaluate
vulnerabilities, and assess threats to various services.
Likewise, you can learn how to scan for compliance standards, check file
integrity, perform auditing, and encrypt storage devices.</simpara>
<simpara>With the knowledge of what features you want to harden, you can then
decide how to harden them in RHCOS.</simpara>
</section>
<section xml:id="security-hardening-how_security-hardening">
<title>Choosing how to harden RHCOS</title>
<simpara>Direct modification of RHCOS systems in OpenShift Container Platform is discouraged. Instead, you should think of modifying systems in pools of nodes, such as worker nodes and control plane nodes. When a new node is needed, in non-bare metal installs, you can request a new node of the type you want and it will be created from an RHCOS image plus the modifications you created earlier.</simpara>
<simpara>There are opportunities for modifying RHCOS before installation, during installation, and after the cluster is up and running.</simpara>
<section xml:id="security-harden-before-installation_security-hardening">
<title>Hardening before installation</title>
<simpara>For bare metal installations, you can add hardening features to RHCOS before beginning the OpenShift Container Platform installation. For example, you can add kernel options when you boot the RHCOS installer to turn security features on or off, such as various SELinux booleans or low-level settings, such as symmetric multithreading.</simpara>
<warning>
<simpara>Disabling SELinux on RHCOS nodes is not supported.</simpara>
</warning>
<simpara>Although bare metal RHCOS installations are more difficult, they offer the opportunity of getting operating system changes in place before starting the OpenShift Container Platform installation. This can be important when you need to ensure that certain features, such as disk encryption or special networking settings, be set up at the earliest possible moment.</simpara>
</section>
<section xml:id="security-harden-during-installation_security-hardening">
<title>Hardening during installation</title>
<simpara>You can interrupt the OpenShift Container Platform installation process and change Ignition configs. Through Ignition configs, you can add your own files and systemd services to the RHCOS nodes. You can also make some basic security-related changes to the <literal>install-config.yaml</literal> file used for installation. Contents added in this way are available at each node&#8217;s first boot.</simpara>
</section>
<section xml:id="security-harden-after-installation_security-hardening">
<title>Hardening after the cluster is running</title>
<simpara>After the OpenShift Container Platform cluster is up and running, there are several ways to apply hardening features to RHCOS:</simpara>
<itemizedlist>
<listitem>
<simpara>Daemon set: If you need a service to run on every node, you can add
that service with a <link xlink:href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">Kubernetes <literal>DaemonSet</literal> object</link>.</simpara>
</listitem>
<listitem>
<simpara>Machine config: <literal>MachineConfig</literal> objects contain a subset of Ignition configs in the same format. By applying machine configs to all worker or control plane nodes, you can ensure that the next node of the same type that is added to the cluster has the same changes applied.</simpara>
</listitem>
</itemizedlist>
<simpara>All of the features noted here are described in the OpenShift Container Platform product documentation.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/articles/5059881">OpenShift Security Guide</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../architecture/architecture-rhcos.xml#rhcos-deployed_architecture-rhcos">Choosing how to configure RHCOS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../nodes/nodes/nodes-nodes-managing.xml#nodes-nodes-managing">Modifying Nodes</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installation-initializing-manual_installing-bare-metal">Manually creating the installation configuration file</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installation-user-infra-generate-k8s-manifest-ignition_installing-bare-metal">Creating the Kubernetes manifest and Ignition config files</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_bare_metal/installing-bare-metal.xml#installation-user-infra-machines-iso_installing-bare-metal">Installing RHCOS by using an ISO image</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installing-customizing">Customizing nodes</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../nodes/nodes/nodes-nodes-managing.xml#nodes-nodes-kernel-arguments_nodes-nodes-managing">Adding kernel arguments to Nodes</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#installation-configuration-parameters_installing-aws-customizations">Installation configuration parameters</link> - see <literal>fips</literal></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing-fips.xml#installing-fips">Support for FIPS cryptography</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/articles/3359851">RHEL core crypto components</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="security-container-signature">
<title>Container image signatures</title>

<simpara>Red Hat delivers signatures for the images in the Red Hat Container Registries. Those signatures can be automatically verified when being pulled to OpenShift Container Platform 4 clusters by using the Machine Config Operator (MCO).</simpara>
<simpara><link xlink:href="https://quay.io/">Quay.io</link> serves most of the images that make up OpenShift Container Platform, and only the release image is signed. Release images refer to the approved OpenShift Container Platform images, offering a degree of protection against supply chain attacks. However, some extensions to OpenShift Container Platform, such as logging, monitoring, and service mesh, are shipped as Operators from the Operator Lifecycle Manager (OLM). Those images ship from the <link xlink:href="https://catalog.redhat.com/software/containers/explore">Red Hat Ecosystem Catalog Container images</link> registry.</simpara>
<simpara>To verify the integrity of those images between Red Hat registries and your infrastructure, enable signature verification.</simpara>
<section xml:id="containers-signature-verify-enable_security-container-signature">
<title>Enabling signature verification for Red Hat Container Registries</title>
<simpara>Enabling container signature validation for Red Hat Container Registries requires writing a signature verification policy file specifying the keys to verify images from these registries. For RHEL8 nodes, the registries are already defined in <literal>/etc/containers/registries.d</literal> by default.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a Butane config file, <literal>51-worker-rh-registry-trust.bu</literal>, containing the necessary configuration for the worker nodes.</simpara>
<note>
<simpara>See "Creating machine configs with Butane" for information about Butane.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">variant: openshift
version: 4.14.0
metadata:
  name: 51-worker-rh-registry-trust
  labels:
    machineconfiguration.openshift.io/role: worker
storage:
  files:
  - path: /etc/containers/policy.json
    mode: 0644
    overwrite: true
    contents:
      inline: |
        {
          "default": [
            {
              "type": "insecureAcceptAnything"
            }
          ],
          "transports": {
            "docker": {
              "registry.access.redhat.com": [
                {
                  "type": "signedBy",
                  "keyType": "GPGKeys",
                  "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
                }
              ],
              "registry.redhat.io": [
                {
                  "type": "signedBy",
                  "keyType": "GPGKeys",
                  "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
                }
              ]
            },
            "docker-daemon": {
              "": [
                {
                  "type": "insecureAcceptAnything"
                }
              ]
            }
          }
        }</programlisting>
</listitem>
<listitem>
<simpara>Use Butane to generate a machine config YAML file, <literal>51-worker-rh-registry-trust.yaml</literal>, containing the file to be written to disk on the worker nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ butane 51-worker-rh-registry-trust.bu -o 51-worker-rh-registry-trust.yaml</programlisting>
</listitem>
<listitem>
<simpara>Apply the created machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f 51-worker-rh-registry-trust.yaml</programlisting>
</listitem>
<listitem>
<simpara>Check that the worker machine config pool has rolled out with the new machine config:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check that the new machine config was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mc</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               GENERATEDBYCONTROLLER                      IGNITIONVERSION   AGE
00-master                                          a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
00-worker                                          a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
01-master-container-runtime                        a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
01-master-kubelet                                  a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
01-worker-container-runtime                        a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
01-worker-kubelet                                  a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
51-master-rh-registry-trust                                                                   3.2.0             13s
51-worker-rh-registry-trust                                                                   3.2.0             53s <co xml:id="CO1-1"/>
99-master-generated-crio-seccomp-use-default                                                  3.2.0             25m
99-master-generated-registries                     a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
99-master-ssh                                                                                 3.2.0             28m
99-worker-generated-crio-seccomp-use-default                                                  3.2.0             25m
99-worker-generated-registries                     a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             25m
99-worker-ssh                                                                                 3.2.0             28m
rendered-master-af1e7ff78da0a9c851bab4be2777773b   a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             8s
rendered-master-cd51fd0c47e91812bfef2765c52ec7e6   a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             24m
rendered-worker-2b52f75684fbc711bd1652dd86fd0b82   a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             24m
rendered-worker-be3b3bce4f4aa52a62902304bac9da3c   a2178ad522c49ee330b0033bb5cb5ea132060b0a   3.2.0             48s <co xml:id="CO1-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>New machine config</para>
</callout>
<callout arearefs="CO1-2">
<para>New rendered machine config</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check that the worker machine config pool is updating with the new machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                             UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master   rendered-master-af1e7ff78da0a9c851bab4be2777773b   True      False      False      3              3                   3                     0                      30m
worker   rendered-worker-be3b3bce4f4aa52a62902304bac9da3c   False     True       False      3              0                   0                     0                      30m <co xml:id="CO2-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>When the <literal>UPDATING</literal> field is <literal>True</literal>, the machine config pool is updating with the new machine config. When the field becomes <literal>False</literal>, the worker machine config pool has rolled out to the new machine config.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If your cluster uses any RHEL7 worker nodes, when the worker machine config pool is updated, create YAML files on those nodes in the <literal>/etc/containers/registries.d</literal> directory, which specify the location of the detached signatures for a given registry server. The following example works only for images hosted in <literal>registry.access.redhat.com</literal> and <literal>registry.redhat.io</literal>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Start a debug session to each RHEL7 worker node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>/etc/containers/registries.d/registry.redhat.io.yaml</literal> file that contains the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">docker:
     registry.redhat.io:
         sigstore: https://registry.redhat.io/containers/sigstore</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>/etc/containers/registries.d/registry.access.redhat.com.yaml</literal> file that contains the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">docker:
     registry.access.redhat.com:
         sigstore: https://access.redhat.com/webassets/docker/content/sigstore</programlisting>
</listitem>
<listitem>
<simpara>Exit the debug session.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="containers-signature-verify-application_security-container-signature">
<title>Verifying the signature verification configuration</title>
<simpara>After you apply the machine configs to the cluster, the Machine Config Controller detects the new <literal>MachineConfig</literal> object and generates a new <literal>rendered-worker-&lt;hash&gt;</literal> version.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You enabled signature verification by using a machine config file.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>On the command line, run the following command to display information about a desired worker:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfigpool/worker</programlisting>
<formalpara>
<title>Example output of initial worker monitoring</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         worker
Namespace:
Labels:       machineconfiguration.openshift.io/mco-built-in=
Annotations:  &lt;none&gt;
API Version:  machineconfiguration.openshift.io/v1
Kind:         MachineConfigPool
Metadata:
  Creation Timestamp:  2019-12-19T02:02:12Z
  Generation:          3
  Resource Version:    16229
  Self Link:           /apis/machineconfiguration.openshift.io/v1/machineconfigpools/worker
  UID:                 92697796-2203-11ea-b48c-fa163e3940e5
Spec:
  Configuration:
    Name:  rendered-worker-f6819366eb455a401c42f8d96ab25c02
    Source:
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         00-worker
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         01-worker-container-runtime
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         01-worker-kubelet
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         51-worker-rh-registry-trust
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         99-worker-92697796-2203-11ea-b48c-fa163e3940e5-registries
      API Version:  machineconfiguration.openshift.io/v1
      Kind:         MachineConfig
      Name:         99-worker-ssh
  Machine Config Selector:
    Match Labels:
      machineconfiguration.openshift.io/role:  worker
  Node Selector:
    Match Labels:
      node-role.kubernetes.io/worker:
  Paused:                              false
Status:
  Conditions:
    Last Transition Time:  2019-12-19T02:03:27Z
    Message:
    Reason:
    Status:                False
    Type:                  RenderDegraded
    Last Transition Time:  2019-12-19T02:03:43Z
    Message:
    Reason:
    Status:                False
    Type:                  NodeDegraded
    Last Transition Time:  2019-12-19T02:03:43Z
    Message:
    Reason:
    Status:                False
    Type:                  Degraded
    Last Transition Time:  2019-12-19T02:28:23Z
    Message:
    Reason:
    Status:                False
    Type:                  Updated
    Last Transition Time:  2019-12-19T02:28:23Z
    Message:               All nodes are updating to rendered-worker-f6819366eb455a401c42f8d96ab25c02
    Reason:
    Status:                True
    Type:                  Updating
  Configuration:
    Name:  rendered-worker-d9b3f4ffcfd65c30dcf591a0e8cf9b2e
    Source:
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   00-worker
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   01-worker-container-runtime
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   01-worker-kubelet
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   99-worker-92697796-2203-11ea-b48c-fa163e3940e5-registries
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   99-worker-ssh
  Degraded Machine Count:     0
  Machine Count:              1
  Observed Generation:        3
  Ready Machine Count:        0
  Unavailable Machine Count:  1
  Updated Machine Count:      0
Events:                       &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the <literal>oc describe</literal> command again:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfigpool/worker</programlisting>
<formalpara>
<title>Example output after the worker is updated</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
    Last Transition Time:  2019-12-19T04:53:09Z
    Message:               All nodes are updated with rendered-worker-f6819366eb455a401c42f8d96ab25c02
    Reason:
    Status:                True
    Type:                  Updated
    Last Transition Time:  2019-12-19T04:53:09Z
    Message:
    Reason:
    Status:                False
    Type:                  Updating
  Configuration:
    Name:  rendered-worker-f6819366eb455a401c42f8d96ab25c02
    Source:
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   00-worker
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   01-worker-container-runtime
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   01-worker-kubelet
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   51-worker-rh-registry-trust
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   99-worker-92697796-2203-11ea-b48c-fa163e3940e5-registries
      API Version:            machineconfiguration.openshift.io/v1
      Kind:                   MachineConfig
      Name:                   99-worker-ssh
  Degraded Machine Count:     0
  Machine Count:              3
  Observed Generation:        4
  Ready Machine Count:        3
  Unavailable Machine Count:  0
  Updated Machine Count:      3
...</programlisting>
</para>
</formalpara>
<note>
<simpara>The <literal>Observed Generation</literal> parameter shows an increased count based on the generation of the controller-produced configuration. This controller updates this value even if it fails to process the specification and generate a revision. The <literal>Configuration Source</literal> value points to the <literal>51-worker-rh-registry-trust</literal> configuration.</simpara>
</note>
</listitem>
<listitem>
<simpara>Confirm that the <literal>policy.json</literal> file exists with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node&gt; -- chroot /host cat /etc/containers/policy.json</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/&lt;node&gt;-debug ...
To use host binaries, run `chroot /host`
{
  "default": [
    {
      "type": "insecureAcceptAnything"
    }
  ],
  "transports": {
    "docker": {
      "registry.access.redhat.com": [
        {
          "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
        }
      ],
      "registry.redhat.io": [
        {
          "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
        }
      ]
    },
    "docker-daemon": {
      "": [
        {
          "type": "insecureAcceptAnything"
        }
      ]
    }
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Confirm that the <literal>registry.redhat.io.yaml</literal> file exists with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node&gt; -- chroot /host cat /etc/containers/registries.d/registry.redhat.io.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/&lt;node&gt;-debug ...
To use host binaries, run `chroot /host`
docker:
     registry.redhat.io:
         sigstore: https://registry.redhat.io/containers/sigstore</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Confirm that the <literal>registry.access.redhat.com.yaml</literal> file exists with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node&gt; -- chroot /host cat /etc/containers/registries.d/registry.access.redhat.com.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/&lt;node&gt;-debug ...
To use host binaries, run `chroot /host`
docker:
     registry.access.redhat.com:
         sigstore: https://access.redhat.com/webassets/docker/content/sigstore</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="containers-signature-verify-artifacts_security-container-signature">
<title>Understanding the verification of container images lacking verifiable signatures</title>
<simpara>Each OpenShift Container Platform release image is immutable and signed with a Red Hat production key. During an OpenShift Container Platform update or installation, a release image might deploy container images that do not have verifiable signatures. Each signed release image digest is immutable. Each reference in the release image is to the immutable digest of another image, so the contents can be trusted transitively. In other words, the signature on the release image validates all release contents.</simpara>
<simpara>For example, the image references lacking a verifiable signature are contained in the signed OpenShift Container Platform release image:</simpara>
<formalpara>
<title>Example release info output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release info  quay.io/openshift-release-dev/ ocp-release@sha256:2309578b68c5666dad62aed696f1f9d778ae1a089ee461060ba7b9514b7ca417 -o pullspec <co xml:id="CO3-1"/>
quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:9aafb914d5d7d0dec4edd800d02f811d7383a7d49e500af548eab5d00c1bffdb <co xml:id="CO3-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Signed release image SHA.</para>
</callout>
<callout arearefs="CO3-2">
<para>Container image lacking a verifiable signature included in the release.</para>
</callout>
</calloutlist>
<section xml:id="containers-signature-verification-automatic_security-container-signature">
<title>Automated verification during updates</title>
<simpara>Verification of signatures is automatic. The OpenShift Cluster Version Operator (CVO) verifies signatures on the release images during an OpenShift Container Platform update. This is an internal process. An OpenShift Container Platform installation or update fails if the automated verification fails.</simpara>
<simpara>Verification of signatures can also be done manually using the <literal>skopeo</literal> command-line utility.</simpara>
<itemizedlist xml:id="additional-resources" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../updating/understanding_updates/intro-to-updates.xml#understanding-openshift-updates">Introduction to OpenShift Updates</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="containers-signature-verify-skopeo_security-container-signature">
<title>Using skopeo to verify signatures of Red Hat container images</title>
<simpara>You can verify the signatures for container images included in an OpenShift Container Platform release image by pulling those signatures from <link xlink:href="https://mirror.openshift.com/pub/openshift-v4/signatures/openshift-release-dev/ocp-release/">OCP release mirror site</link>. Because the signatures on the mirror site are not in a format readily understood by Podman or CRI-O, you can use the <literal>skopeo standalone-verify</literal> command to verify that the your release images are signed by Red Hat.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the <literal>skopeo</literal> command-line utility.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the full SHA for your release by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release info &lt;release_version&gt;  \ <co xml:id="CO4-1"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Substitute &lt;release_version&gt; with your release number, for example, <literal>4.14.3</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output snippet</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">---
Pull From: quay.io/openshift-release-dev/ocp-release@sha256:e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55
---</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Pull down the Red Hat release key by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -o pub.key https://access.redhat.com/security/data/fd431d51.txt</programlisting>
</listitem>
<listitem>
<simpara>Get the signature file for the specific release that you want to verify by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -o signature-1 https://mirror.openshift.com/pub/openshift-v4/signatures/openshift-release-dev/ocp-release/sha256%&lt;sha_from_version&gt;/signature-1 \ <co xml:id="CO5-1"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Replace <literal>&lt;sha_from_version&gt;</literal> with SHA value from the full link to the mirror site that matches the SHA of your release. For example, the link to the signature for the 4.12.23 release is <literal><link xlink:href="https://mirror.openshift.com/pub/openshift-v4/signatures/openshift-release-dev/ocp-release/sha256%e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55/signature-1">https://mirror.openshift.com/pub/openshift-v4/signatures/openshift-release-dev/ocp-release/sha256%e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55/signature-1</link></literal>, and the SHA value is <literal>e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Get the manifest for the release image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ skopeo inspect --raw docker://&lt;quay_link_to_release&gt; &gt; manifest.json \ <co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Replace <literal>&lt;quay_link_to_release&gt;</literal> with the output of the <literal>oc adm release info</literal> command. For example, <literal>quay.io/openshift-release-dev/ocp-release@sha256:e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use skopeo to verify the signature:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ skopeo standalone-verify manifest.json quay.io/openshift-release-dev/ocp-release:&lt;release_number&gt;-&lt;arch&gt; any signature-1 --public-key-file pub.key</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;release_number&gt;</literal></term>
<listitem>
<simpara>Specifies the release number, for example <literal>4.14.3</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;arch&gt;</literal></term>
<listitem>
<simpara>Specifies the architecture, for example <literal>x86_64</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Signature verified using fingerprint 567E347AD0044ADE55BA8A5F199E2F91FD431D51, digest sha256:e73ab4b33a9c3ff00c9f800a38d69853ca0c4dfa5a88e3df331f66df8f18ec55</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="additional-resources_security-container-signature" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../post_installation_configuration/machine-configuration-tasks.xml#machine-config-overview-post-install-machine-configuration-tasks">Machine Config Overview</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-compliance">
<title>Understanding compliance</title>

<simpara>For many OpenShift Container Platform customers, regulatory readiness, or compliance, on
some level is required before any systems can be put into production.
That regulatory readiness can be imposed by national standards, industry
standards or the organization&#8217;s corporate governance framework.</simpara>
<section xml:id="security-compliance-nist_security-compliance">
<title>Understanding compliance and risk management</title>
<simpara>FIPS compliance is one of the most critical components required in
highly secure environments, to ensure that only supported cryptographic
technologies are allowed on nodes.</simpara>
<important>
<simpara>To enable FIPS mode for your cluster, you must run the installation program from a Red Hat Enterprise Linux (RHEL) computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>. When running Red Hat Enterprise Linux (RHEL) or Red Hat Enterprise Linux CoreOS (RHCOS) booted in FIPS mode, OpenShift Container Platform core components use the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures.</simpara>
</important>
<simpara>To understand Red Hat&#8217;s view of OpenShift Container Platform compliance frameworks, refer
to the Risk Management and Regulatory Readiness chapter of the
<link xlink:href="https://access.redhat.com/articles/5059881">OpenShift Security Guide Book</link>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../installing/installing-fips.xml#installing-fips-mode_installing-fips">Installing a cluster in FIPS mode</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-container-content">
<title>Securing container content</title>

<simpara>To ensure the security of the content inside your containers
you need to start with trusted base images, such as Red Hat
Universal Base Images, and add trusted software. To check the
ongoing security of your container images, there are both
Red Hat and third-party tools for scanning images.</simpara>
<section xml:id="security-container-content-inside_security-container-content">
<title>Securing inside the container</title>
<simpara>Applications and infrastructures are composed of readily available components,
many of which are open source packages such as, the Linux operating system,
JBoss Web Server, PostgreSQL, and Node.js.</simpara>
<simpara>Containerized versions of these packages are also available. However, you need
to know where the packages originally came from, what versions are used, who built them, and whether
there is any malicious code inside them.</simpara>
<simpara>Some questions to answer include:</simpara>
<itemizedlist>
<listitem>
<simpara>Will what is inside the containers compromise your infrastructure?</simpara>
</listitem>
<listitem>
<simpara>Are there known vulnerabilities in the application layer?</simpara>
</listitem>
<listitem>
<simpara>Are the runtime and operating system layers current?</simpara>
</listitem>
</itemizedlist>
<simpara>By building your containers from Red Hat
<link xlink:href="https://access.redhat.com/articles/4238681">Universal Base Images</link> (UBI) you are
assured of a foundation for your container images that consists of
the same RPM-packaged software that is included in Red Hat Enterprise Linux.
No subscriptions are required to either use or redistribute UBI images.</simpara>
<simpara>To assure ongoing security of the containers themselves, security
scanning features, used directly from RHEL or added to OpenShift Container Platform,
can alert you when
an image you are using has vulnerabilities. OpenSCAP image scanning is
available in RHEL and the
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/red_hat_quay_operator_features/container-security-operator-setup">Red Hat Quay Container Security Operator</link> can be added
to check container images used in OpenShift Container Platform.</simpara>
</section>
<section xml:id="security-container-content-universal_security-container-content">
<title>Creating redistributable images with UBI</title>
<simpara>To create containerized applications, you typically start with a trusted base
image that offers the components that are usually provided by the operating system.
These include the libraries, utilities, and other features the application
expects to see in the operating system&#8217;s file system.</simpara>
<simpara>Red Hat Universal Base Images (UBI) were created to encourage anyone building their
own containers to start with one that is made entirely from Red Hat Enterprise
Linux rpm packages and other content. These UBI images are updated regularly
to keep up with security patches and free to use and redistribute with
container images built to include your own software.</simpara>
<simpara>Search the
<link xlink:href="https://catalog.redhat.com/software/containers/explore">Red Hat Ecosystem Catalog</link>
to both find and check the health of different UBI images.
As someone creating secure container images, you might
be interested in these two general types of UBI images:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">UBI</emphasis>: There are standard UBI images for RHEL 7, 8, and 9 (<literal>ubi7/ubi</literal>,
<literal>ubi8/ubi</literal>, and <literal>ubi9/ubi</literal>), as well as minimal images based on those systems (<literal>ubi7/ubi-minimal</literal>, <literal>ubi8/ubi-mimimal</literal>, and ubi9/ubi-minimal). All of these images are preconfigured to point to free
repositories of RHEL software that you can add to the container images you build,
using standard <literal>yum</literal> and <literal>dnf</literal> commands.
Red Hat encourages people to use these images on other distributions,
such as Fedora and Ubuntu.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Red Hat Software Collections</emphasis>: Search the Red Hat Ecosystem Catalog
for <literal>rhscl/</literal> to find images created to use as base images for specific types
of applications. For example, there are Apache httpd (<literal>rhscl/httpd-*</literal>),
Python (<literal>rhscl/python-*</literal>), Ruby (<literal>rhscl/ruby-*</literal>), Node.js
(<literal>rhscl/nodejs-*</literal>) and Perl (<literal>rhscl/perl-*</literal>) rhscl images.</simpara>
</listitem>
</itemizedlist>
<simpara>Keep in mind that while UBI images are freely available and redistributable,
Red Hat support for these images is only available through Red Hat
product subscriptions.</simpara>
<simpara>See
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/building_running_and_managing_containers/index#using_red_hat_universal_base_images_standard_minimal_and_runtimes">Using Red Hat Universal Base Images</link>
in the Red Hat Enterprise Linux documentation for information on how to use and build on
standard, minimal and init UBI images.</simpara>
</section>
<section xml:id="security-container-content-scanning_security-container-content">
<title>Security scanning in RHEL</title>
<simpara>For Red Hat Enterprise Linux (RHEL) systems, OpenSCAP scanning is available
from the <literal>openscap-utils</literal> package. In RHEL, you can use the <literal>openscap-podman</literal>
command to scan images for vulnerabilities. See
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/security_hardening/index#scanning-the-system-for-configuration-compliance-and-vulnerabilities_security-hardening">Scanning containers and container images for vulnerabilities</link> in the Red Hat Enterprise Linux documentation.</simpara>
<simpara>OpenShift Container Platform enables you to leverage RHEL scanners with your CI/CD process.
For example, you can integrate static code analysis tools that test for security
flaws in your source code and software composition analysis tools that identify
open source libraries to provide metadata on those libraries such as
known vulnerabilities.</simpara>
<section xml:id="quay-security-scan_security-container-content">
<title>Scanning OpenShift images</title>
<simpara>For the container images that are running in OpenShift Container Platform
and are pulled from Red Hat Quay registries, you can use an Operator to list the
vulnerabilities of those images. The
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/red_hat_quay_operator_features/container-security-operator-setup">Red Hat Quay Container Security Operator</link>
can be added to OpenShift Container Platform to provide vulnerability reporting
for images added to selected namespaces.</simpara>
<simpara>Container image scanning for Red Hat Quay is performed by the
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/vulnerability_reporting_with_clair_on_red_hat_quay/index">Clair</link>.
In Red Hat Quay, Clair can search for and report vulnerabilities in
images built from RHEL, CentOS, Oracle, Alpine, Debian, and Ubuntu
operating system software.</simpara>
</section>
</section>
<section xml:id="security-container-content-external-scanning_security-container-content">
<title>Integrating external scanning</title>
<simpara>OpenShift Container Platform makes use of <link xlink:href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">object annotations</link>
to extend functionality. External tools, such as vulnerability scanners, can
annotate image objects with metadata to summarize results and control pod
execution. This section describes the recognized format of this annotation so it
can be reliably used in consoles to display useful data to users.</simpara>
<section xml:id="security-image-metadata_security-container-content">
<title>Image metadata</title>
<simpara>There are different types of image quality data, including package
vulnerabilities and open source software (OSS) license compliance. Additionally,
there may be more than one provider of this metadata. To that end, the following
annotation format has been reserved:</simpara>
<screen>quality.images.openshift.io/&lt;qualityType&gt;.&lt;providerId&gt;: {}</screen>
<table frame="all" rowsep="1" colsep="1">
<title>Annotation key format</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Acceptable values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>qualityType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Metadata type</simpara></entry>
<entry align="left" valign="top"><simpara><literal>vulnerability</literal><?asciidoc-br?>
<literal>license</literal><?asciidoc-br?>
<literal>operations</literal><?asciidoc-br?>
<literal>policy</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>providerId</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provider ID string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openscap</literal><?asciidoc-br?>
<literal>redhatcatalog</literal><?asciidoc-br?>
<literal>redhatinsights</literal><?asciidoc-br?>
<literal>blackduck</literal><?asciidoc-br?>
<literal>jfrog</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="security-example-annotation-keys_security-container-content">
<title>Example annotation keys</title>
<screen>quality.images.openshift.io/vulnerability.blackduck: {}
quality.images.openshift.io/vulnerability.jfrog: {}
quality.images.openshift.io/license.blackduck: {}
quality.images.openshift.io/vulnerability.openscap: {}</screen>
<simpara>The value of the image quality annotation is structured data that must adhere to
the following format:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Annotation value format</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Required?</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Provider display name</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>timestamp</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Scan timestamp</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Short description</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reference</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>URL of information source or more details. Required so user may validate the data.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>scannerVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Scanner version</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>compliant</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance pass or fail</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>summary</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
<entry align="left" valign="top"><simpara>Summary of issues found</simpara></entry>
<entry align="left" valign="top"><simpara>List (see table below)</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The <literal>summary</literal> field must adhere to the following format:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Summary field value format</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Type</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>label</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display label for component (for example, "critical," "important," "moderate,"
"low," or "health")</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Data for this component (for example, count of vulnerabilities found or score)</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>severityIndex</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Component index allowing for ordering and assigning graphical
representation. The value is range <literal>0..3</literal> where <literal>0</literal> = low.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reference</literal></simpara></entry>
<entry align="left" valign="top"><simpara>URL of information source or more details. Optional.</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="security-example-annotation-values_security-container-content">
<title>Example annotation values</title>
<simpara>This example shows an OpenSCAP annotation for an image with
vulnerability summary data and a compliance boolean:</simpara>
<formalpara>
<title>OpenSCAP annotation</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "name": "OpenSCAP",
  "description": "OpenSCAP vulnerability score",
  "timestamp": "2016-09-08T05:04:46Z",
  "reference": "https://www.open-scap.org/930492",
  "compliant": true,
  "scannerVersion": "1.2",
  "summary": [
    { "label": "critical", "data": "4", "severityIndex": 3, "reference": null },
    { "label": "important", "data": "12", "severityIndex": 2, "reference": null },
    { "label": "moderate", "data": "8", "severityIndex": 1, "reference": null },
    { "label": "low", "data": "26", "severityIndex": 0, "reference": null }
  ]
}</programlisting>
</para>
</formalpara>
<simpara>This example shows the
<link xlink:href="https://catalog.redhat.com/software/containers/explore">Container images section of the Red Hat Ecosystem Catalog</link>
annotation for an image with health index data
with an external URL for additional details:</simpara>
<formalpara>
<title>Red Hat Ecosystem Catalog annotation</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "name": "Red Hat Ecosystem Catalog",
  "description": "Container health index",
  "timestamp": "2016-09-08T05:04:46Z",
  "reference": "https://access.redhat.com/errata/RHBA-2016:1566",
  "compliant": null,
  "scannerVersion": "1.2",
  "summary": [
    { "label": "Health index", "data": "B", "severityIndex": 1, "reference": null }
  ]
}</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="security-annotating-image-objects_security-container-content">
<title>Annotating image objects</title>
<simpara>While image stream objects
are what an end user of OpenShift Container Platform operates against,
image objects are annotated with
security metadata. Image objects are cluster-scoped, pointing to a single image
that may be referenced by many image streams and tags.</simpara>
<section xml:id="security-example-annotate-CLI_security-container-content">
<title>Example annotate CLI command</title>
<simpara>Replace <literal>&lt;image&gt;</literal> with an image digest, for example
<literal>sha256:401e359e0f45bfdcf004e258b72e253fd07fba8cc5c6f2ed4f4608fb119ecc2</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate image &lt;image&gt; \
    quality.images.openshift.io/vulnerability.redhatcatalog='{ \
    "name": "Red Hat Ecosystem Catalog", \
    "description": "Container health index", \
    "timestamp": "2020-06-01T05:04:46Z", \
    "compliant": null, \
    "scannerVersion": "1.2", \
    "reference": "https://access.redhat.com/errata/RHBA-2020:2347", \
    "summary": "[ \
      { "label": "Health index", "data": "B", "severityIndex": 1, "reference": null } ]" }'</programlisting>
</section>
</section>
<section xml:id="controlling-pod-execution_security-container-content">
<title>Controlling pod execution</title>
<simpara>Use the <literal>images.openshift.io/deny-execution</literal> image policy
to programmatically control if an image can be run.</simpara>
<section xml:id="security-controlling-pod-execution-example-annotation_security-container-content">
<title>Example annotation</title>
<programlisting language="yaml" linenumbering="unnumbered">annotations:
  images.openshift.io/deny-execution: true</programlisting>
</section>
</section>
<section xml:id="security-integration-reference_security-container-content">
<title>Integration reference</title>
<simpara>In most cases, external tools such as vulnerability scanners develop a
script or plugin that watches for image updates, performs scanning, and
annotates the associated image object with the results. Typically this
automation calls the OpenShift Container Platform 4.14 REST APIs to write the annotation. See
OpenShift Container Platform REST APIs for general
information on the REST APIs.</simpara>
<section xml:id="security-integration-reference-example-api-call_security-container-content">
<title>Example REST API call</title>
<simpara>The following example call using <literal>curl</literal> overrides the value of the
annotation. Be sure to replace the values for <literal>&lt;token&gt;</literal>, <literal>&lt;openshift_server&gt;</literal>,
<literal>&lt;image_id&gt;</literal>, and <literal>&lt;image_annotation&gt;</literal>.</simpara>
<formalpara>
<title>Patch API call</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -X PATCH \
  -H "Authorization: Bearer &lt;token&gt;" \
  -H "Content-Type: application/merge-patch+json" \
  https://&lt;openshift_server&gt;:6443/apis/image.openshift.io/v1/images/&lt;image_id&gt; \
  --data '{ &lt;image_annotation&gt; }'</programlisting>
</para>
</formalpara>
<simpara>The following is an example of <literal>PATCH</literal> payload data:</simpara>
<formalpara>
<title>Patch call data</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
"metadata": {
  "annotations": {
    "quality.images.openshift.io/vulnerability.redhatcatalog":
       "{ 'name': 'Red Hat Ecosystem Catalog', 'description': 'Container health index', 'timestamp': '2020-06-01T05:04:46Z', 'compliant': null, 'reference': 'https://access.redhat.com/errata/RHBA-2020:2347', 'summary': [{'label': 'Health index', 'data': '4', 'severityIndex': 1, 'reference': null}] }"
    }
  }
}</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../openshift_images/index.xml#overview-of-images">Image stream objects</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</section>
<section xml:id="security-registries">
<title>Using container registries securely</title>

<simpara>Container registries store container images to:</simpara>
<itemizedlist>
<listitem>
<simpara>Make images accessible to others</simpara>
</listitem>
<listitem>
<simpara>Organize images into repositories that can include multiple versions of an image</simpara>
</listitem>
<listitem>
<simpara>Optionally limit access to images, based on different authentication methods, or
make them publicly available</simpara>
</listitem>
</itemizedlist>
<simpara>There are public container registries, such as Quay.io and Docker Hub
where many people and organizations share their images.
The Red Hat Registry offers supported Red Hat and partner images,
while the Red Hat Ecosystem Catalog offers detailed descriptions
and health checks for those images.
To manage your own registry, you could purchase a container
registry such as
<link xlink:href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</link>.</simpara>
<simpara>From a security standpoint, some registries provide special features to
check and improve the health of your containers.
For example, Red Hat Quay offers container vulnerability scanning
with Clair security scanner, build triggers to automatically rebuild
images when source code changes in GitHub and other locations, and
the ability to use role-based access control (RBAC) to
secure access to images.</simpara>
<section xml:id="security-registries-where_security-registries">
<title>Knowing where containers come from?</title>
<simpara>There are tools you can use to scan and track the contents of your downloaded
and deployed container images. However, there are many public sources of
container images. When using public container registries, you can add a layer of
protection by using trusted sources.</simpara>
</section>
<section xml:id="security-registries-immutable_security-registries">
<title>Immutable and certified containers</title>
<simpara>Consuming security updates is particularly important when managing <emphasis>immutable
containers</emphasis>. Immutable containers are containers that will never be changed
while running. When you deploy immutable containers, you do not step into the
running container to replace one or more binaries. From an operational
standpoint, you rebuild and redeploy an updated container image
to replace a container instead of changing it.</simpara>
<simpara>Red Hat certified images are:</simpara>
<itemizedlist>
<listitem>
<simpara>Free of known vulnerabilities in the platform components or layers</simpara>
</listitem>
<listitem>
<simpara>Compatible across the RHEL platforms, from bare metal to cloud</simpara>
</listitem>
<listitem>
<simpara>Supported by Red Hat</simpara>
</listitem>
</itemizedlist>
<simpara>The list of known vulnerabilities is constantly evolving, so you must track the
contents of your deployed container images, as well as newly downloaded images,
over time. You can use
<link xlink:href="https://access.redhat.com/security/security-updates/#/security-advisories">Red Hat Security Advisories (RHSAs)</link>
to alert you to any newly discovered issues in
Red Hat certified container images, and direct you to the updated image.
Alternatively, you can go to the Red Hat Ecosystem Catalog
to look up that and other security-related issues for each Red Hat image.</simpara>
</section>
<section xml:id="security-registries-ecosystem_security-registries">
<title>Getting containers from Red Hat Registry and Ecosystem Catalog</title>
<simpara>Red Hat lists certified container images for Red Hat products and partner offerings from the
<link xlink:href="https://catalog.redhat.com/software/containers/explore">Container Images</link>
section of the Red Hat Ecosystem Catalog. From that catalog,
you can see details of each image, including CVE, software packages listings, and health
scores.</simpara>
<simpara>Red Hat images are actually stored in what is referred to as the <emphasis>Red Hat Registry</emphasis>,
which is represented by a public container registry (<literal>registry.access.redhat.com</literal>)
and an authenticated registry (<literal>registry.redhat.io</literal>).
Both include basically the same set of container images, with
<literal>registry.redhat.io</literal> including some additional images that require authentication
with Red Hat subscription credentials.</simpara>
<simpara>Container content is monitored for vulnerabilities by Red Hat and updated
regularly. When Red Hat releases security updates, such as fixes to <emphasis>glibc</emphasis>,
<link xlink:href="https://access.redhat.com/security/vulnerabilities/drown">DROWN</link>, or
<link xlink:href="https://access.redhat.com/blogs/766093/posts/2757141">Dirty Cow</link>,
any affected container images are also rebuilt and pushed
to the Red Hat Registry.</simpara>
<simpara>Red Hat uses a <literal>health index</literal> to reflect the security risk for each container provided through
the Red Hat Ecosystem Catalog. Because containers consume software provided by Red
Hat and the errata process, old, stale containers are insecure whereas new,
fresh containers are more secure.</simpara>
<simpara>To illustrate the age of containers, the Red Hat Ecosystem Catalog uses a
grading system. A freshness grade is a measure of the oldest and most severe
security errata available for an image. "A" is more up to date than "F". See
<link xlink:href="https://access.redhat.com/articles/2803031">Container Health Index grades as used inside the Red Hat Ecosystem Catalog</link> for more details on this grading system.</simpara>
<simpara>See the <link xlink:href="https://access.redhat.com/security/">Red Hat Product Security Center</link>
for details on security updates and vulnerabilities related to Red Hat software.
Check out <link xlink:href="https://access.redhat.com/security/security-updates/#/security-advisories">Red Hat Security Advisories</link>
to search for specific advisories and CVEs.</simpara>
</section>
<section xml:id="security-registries-openshift_security-registries">
<title>OpenShift Container Registry</title>
<simpara>OpenShift Container Platform includes the <emphasis>OpenShift Container Registry</emphasis>, a private registry
running as an integrated component of the platform that you can use to manage your container
images. The OpenShift Container Registry provides role-based access controls
that allow you to manage who can pull and push which container images.</simpara>
<simpara>OpenShift Container Platform also supports integration with other private registries that you might
already be using, such as Red Hat Quay.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../registry/index.xml#registry-overview">Integrated OpenShift image registry</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-registries-quay_security-registries">
<title>Storing containers using Red Hat Quay</title>
<simpara><link xlink:href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</link> is an
enterprise-quality container registry product from Red Hat.
Development for Red Hat Quay is done through the upstream
<link xlink:href="https://docs.projectquay.io/welcome.html">Project Quay</link>.
Red Hat Quay is available to deploy on-premise or through the hosted
version of Red Hat Quay at <link xlink:href="https://quay.io">Quay.io</link>.</simpara>
<simpara>Security-related features of Red Hat Quay include:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Time machine</emphasis>: Allows images with older tags to expire after a set
period of time or based on a user-selected expiration time.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html-single/manage_red_hat_quay/index#repo-mirroring-in-red-hat-quay">Repository mirroring</link></emphasis>: Lets you mirror
other registries for security reasons, such hosting a public repository
on Red Hat Quay behind a company firewall, or for performance reasons, to
keep registries closer to where they are used.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Action log storage</emphasis>: Save Red Hat Quay logging output to <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html-single/manage_red_hat_quay/index#proc_manage-log-storage">Elasticsearch storage or Splunk</link> to allow for later search and analysis.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/vulnerability_reporting_with_clair_on_red_hat_quay/index">Clair</link></emphasis>: Scan images against a variety of Linux
vulnerability databases, based on the origins of each container image.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Internal authentication</emphasis>: Use the default local database to handle RBAC
authentication to Red Hat Quay or choose from LDAP, Keystone (OpenStack),
JWT Custom Authentication, or External Application Token authentication.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">External authorization (OAuth)</emphasis>: Allow authorization to Red Hat Quay
from GitHub, GitHub Enterprise, or Google Authentication.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Access settings</emphasis>: Generate tokens to allow access to Red Hat Quay
from docker, rkt, anonymous access, user-created accounts, encrypted
client passwords, or prefix username autocompletion.</simpara>
</listitem>
</itemizedlist>
<simpara>Ongoing integration of Red Hat Quay with OpenShift Container Platform continues,
with several OpenShift Container Platform Operators of particular interest.
The <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html-single/red_hat_quay_operator_features/index#quay-bridge-operator">Quay Bridge Operator</link>
lets you replace the internal OpenShift image registry with Red Hat Quay.
The <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html-single/red_hat_quay_operator_features/index#container-security-operator-setup">Red Hat Quay Container Security Operator</link>
lets you check vulnerabilities of images running in OpenShift Container Platform that were
pulled from Red Hat Quay registries.</simpara>
</section>
</section>
<section xml:id="security-build">
<title>Securing the build process</title>

<simpara>In a container environment, the software build process is the stage in the life
cycle where application code is integrated with the required runtime libraries.
Managing this build process is key to securing the software stack.</simpara>
<section xml:id="security-build-once_security-build">
<title>Building once, deploying everywhere</title>
<simpara>Using OpenShift Container Platform as the standard platform for container builds enables you
to guarantee the security of the build environment. Adhering to a "build once,
deploy everywhere" philosophy ensures that the product of the build process is
exactly what is deployed in production.</simpara>
<simpara>It is also important to maintain the immutability of your containers. You should
not patch running containers, but rebuild and redeploy them.</simpara>
<simpara>As your software moves through the stages of building, testing, and production, it is
important that the tools making up your software supply chain be trusted. The
following figure illustrates the process and tools that could be incorporated
into a trusted software supply chain for containerized software:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/trustedsupplychain.png" align="center"/>
</imageobject>
<textobject><phrase></phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>OpenShift Container Platform can be integrated with trusted code repositories (such as GitHub)
and development platforms (such as Che) for creating and managing secure code.
Unit testing could rely on
<link xlink:href="https://cucumber.io/">Cucumber</link> and <link xlink:href="https://junit.org/">JUnit</link>.
You could inspect your containers for vulnerabilities and compliance issues
with <link xlink:href="https://anchore.com">Anchore</link> or Twistlock,
and use image scanning tools such as AtomicScan or Clair.
Tools such as <link xlink:href="https://sysdig.com">Sysdig</link> could provide ongoing monitoring
of your containerized applications.</simpara>
</section>
<section xml:id="security-build-management_security-build">
<title>Managing builds</title>
<simpara>You can use Source-to-Image (S2I) to combine source code and base images.
<emphasis>Builder images</emphasis> make use of S2I to enable your development and operations teams
to collaborate on a reproducible build environment.
With Red Hat S2I images available as Universal Base Image (UBI) images,
you can now freely redistribute your software with
base images built from real RHEL RPM packages.
Red Hat has removed subscription restrictions to allow this.</simpara>
<simpara>When developers commit code with Git for an application using build images,
OpenShift Container Platform can perform the following functions:</simpara>
<itemizedlist>
<listitem>
<simpara>Trigger, either by using webhooks on the code repository or other automated
continuous integration (CI) process, to automatically assemble a new image from
available artifacts, the S2I builder image, and the newly committed code.</simpara>
</listitem>
<listitem>
<simpara>Automatically deploy the newly built image for testing.</simpara>
</listitem>
<listitem>
<simpara>Promote the tested image to production where it can be automatically deployed
using a CI process.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/build_process1.png" align="center"/>
</imageobject>
<textobject><phrase>Source-to-Image Builds</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>You can use the integrated OpenShift Container Registry to manage access to final images.
Both S2I and native build images are automatically pushed to your OpenShift Container
Registry.</simpara>
<simpara>In addition to the included Jenkins for CI, you can also integrate your own
build and CI environment with OpenShift Container Platform using RESTful APIs, as well as use
any API-compliant image registry.</simpara>
</section>
<section xml:id="security-build-inputs_security-build">
<title>Securing inputs during builds</title>
<simpara>In some scenarios, build operations require credentials to access dependent
resources, but it is undesirable for those credentials to be available in the
final application image produced by the build. You can define input secrets for
this purpose.</simpara>
<simpara>For example, when building a Node.js application, you can set up your private
mirror for Node.js modules. To download modules from that private
mirror, you must supply a custom <literal>.npmrc</literal> file for the build that contains
a URL, user name, and password. For security reasons, you do not want to expose
your credentials in the application image.</simpara>
<simpara>Using this example scenario, you can add an input secret to a new <literal>BuildConfig</literal> object:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the secret, if it does not exist:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic secret-npmrc --from-file=.npmrc=~/.npmrc</programlisting>
<simpara>This creates a new secret named <literal>secret-npmrc</literal>, which contains the base64
encoded content of the <literal>~/.npmrc</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Add the secret to the <literal>source</literal> section in the existing <literal>BuildConfig</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">source:
  git:
    uri: https://github.com/sclorg/nodejs-ex.git
  secrets:
  - destinationDir: .
    secret:
      name: secret-npmrc</programlisting>
</listitem>
<listitem>
<simpara>To include the secret in a new <literal>BuildConfig</literal> object, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-build \
    openshift/nodejs-010-centos7~https://github.com/sclorg/nodejs-ex.git \
    --build-secret secret-npmrc</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="security-build-designing_security-build">
<title>Designing your build process</title>
<simpara>You can design your container image management and build process to use container layers so that you can separate control.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/build_process2.png" align="center"/>
</imageobject>
<textobject><phrase>Designing Your Build Process</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For example, an operations team manages base images, while architects manage
middleware, runtimes, databases, and other solutions. Developers can then focus
on application layers and focus on writing code.</simpara>
<simpara>Because new vulnerabilities are identified daily, you need to proactively check
container content over time. To do this, you should integrate automated security
testing into your build or CI process. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>SAST / DAST – Static and Dynamic security testing tools.</simpara>
</listitem>
<listitem>
<simpara>Scanners for real-time checking against known vulnerabilities. Tools like these
catalog the open source packages in your container, notify you of any known
vulnerabilities, and update you when new vulnerabilities are discovered in
previously scanned packages.</simpara>
</listitem>
</itemizedlist>
<simpara>Your CI process should include policies that flag builds with issues discovered
by security scans so that your team can take appropriate action to address those
issues. You should sign your custom built containers to ensure that nothing is
tampered with between build and deployment.</simpara>
<simpara>Using GitOps methodology, you can use the same CI/CD mechanisms to
manage not only your application configurations, but also your
OpenShift Container Platform infrastructure.</simpara>
</section>
<section xml:id="security-build-knative_security-build">
<title>Building Knative serverless applications</title>
<simpara>Relying on Kubernetes and Kourier, you can build, deploy, and manage serverless applications by using OpenShift Serverless in OpenShift Container Platform.</simpara>
<simpara>As with other builds, you can use S2I images to build your containers, then serve them using Knative services. View Knative application builds through the
<emphasis role="strong">Topology</emphasis> view of the OpenShift Container Platform web console.</simpara>
</section>
<section xml:id="additional-resources_security-build" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../cicd/builds/understanding-image-builds.xml#understanding-image-builds">Understanding image builds</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/builds/triggering-builds-build-hooks.xml#triggering-builds-build-hooks">Triggering and modifying builds</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/builds/creating-build-inputs.xml#creating-build-inputs">Creating build inputs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-input-secrets-configmaps_creating-build-inputs">Input secrets and config maps</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.openshift.com/serverless/1.28/about/about-serverless.html">OpenShift Serverless overview</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../applications/odc-viewing-application-composition-using-topology-view.xml#odc-viewing-application-composition-using-topology-view">Viewing application composition using the Topology view</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-deploy">
<title>Deploying containers</title>

<simpara>You can use a variety of techniques to make sure that the containers you
deploy hold the latest production-quality content and that they have not
been tampered with. These techniques include setting up build triggers to
incorporate the latest code and using signatures to ensure that the container
comes from a trusted source and has not been modified.</simpara>
<section xml:id="security-deploy-trigger_security-deploy">
<title>Controlling container deployments with triggers</title>
<simpara>If something happens during the build process, or if a vulnerability is
discovered after an image has been deployed, you can use tooling for automated,
policy-based deployment to remediate. You can use triggers to rebuild and replace images,
ensuring the immutable containers process,
instead of patching running containers, which is not recommended.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/secure_deployments.png" align="center"/>
</imageobject>
<textobject><phrase>Secure Deployments</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For example, you build an application using three container image layers: core,
middleware, and applications. An issue is discovered in the core image and that
image is rebuilt. After the build is complete, the image is pushed to your
OpenShift Container Registry. OpenShift Container Platform detects that the image has changed
and automatically rebuilds and deploys the application image, based on the
defined triggers. This change incorporates the fixed libraries and ensures that
the production code is identical to the most current image.</simpara>
<simpara>You can use the <literal>oc set triggers</literal> command to set a deployment trigger.
For example, to set a trigger for a deployment called
deployment-example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers deploy/deployment-example \
    --from-image=example:latest \
    --containers=web</programlisting>
</section>
<section xml:id="security-deploy-image-sources_security-deploy">
<title>Controlling what image sources can be deployed</title>
<simpara>It is important that the intended images are actually being deployed, that the
images including the contained content
are from trusted sources, and they have not been altered. Cryptographic signing
provides this assurance. OpenShift Container Platform enables cluster administrators to apply
security policy that is broad or narrow, reflecting deployment environment and
security requirements. Two parameters define this policy:</simpara>
<itemizedlist>
<listitem>
<simpara>one or more registries, with optional project namespace</simpara>
</listitem>
<listitem>
<simpara>trust type, such as accept, reject, or require public key(s)</simpara>
</listitem>
</itemizedlist>
<simpara>You can use these policy parameters to allow, deny, or require a trust
relationship for entire registries, parts of registries, or individual
images. Using trusted public keys, you can ensure that the source is
cryptographically verified.
The policy rules apply to nodes. Policy may be
applied uniformly across all nodes or targeted for different node workloads (for
example, build, zone, or environment).</simpara>
<formalpara>
<title>Example image signature policy file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "default": [{"type": "reject"}],
    "transports": {
        "docker": {
            "access.redhat.com": [
                {
                    "type": "signedBy",
                    "keyType": "GPGKeys",
                    "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
                }
            ]
        },
        "atomic": {
            "172.30.1.1:5000/openshift": [
                {
                    "type": "signedBy",
                    "keyType": "GPGKeys",
                    "keyPath": "/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release"
                }
            ],
            "172.30.1.1:5000/production": [
                {
                    "type": "signedBy",
                    "keyType": "GPGKeys",
                    "keyPath": "/etc/pki/example.com/pubkey"
                }
            ],
            "172.30.1.1:5000": [{"type": "reject"}]
        }
    }
}</programlisting>
</para>
</formalpara>
<simpara>The policy can be saved onto a node as <literal>/etc/containers/policy.json</literal>.
Saving this file to a node is best accomplished using a new
<literal>MachineConfig</literal> object. This
example enforces the following rules:</simpara>
<itemizedlist>
<listitem>
<simpara>Require images from the Red Hat Registry (<literal>registry.access.redhat.com</literal>) to be
signed by the Red Hat public key.</simpara>
</listitem>
<listitem>
<simpara>Require images from your OpenShift Container Registry in the <literal>openshift</literal>
namespace to be signed by the Red Hat public key.</simpara>
</listitem>
<listitem>
<simpara>Require images from your OpenShift Container Registry in the <literal>production</literal>
namespace to be signed by the public key for <literal>example.com</literal>.</simpara>
</listitem>
<listitem>
<simpara>Reject all other registries not specified by the global <literal>default</literal> definition.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-deploy-signature_security-deploy">
<title>Using signature transports</title>
<simpara>A signature transport is a way to store and retrieve the binary signature blob.
There are two types of signature transports.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>atomic</literal>: Managed by the OpenShift Container Platform API.</simpara>
</listitem>
<listitem>
<simpara><literal>docker</literal>: Served as a local file or by a web server.</simpara>
</listitem>
</itemizedlist>
<simpara>The OpenShift Container Platform API manages signatures that use the <literal>atomic</literal> transport type.
You must store the images that use this signature type in
your OpenShift Container Registry. Because the docker/distribution <literal>extensions</literal> API
auto-discovers the image signature endpoint, no additional
configuration is required.</simpara>
<simpara>Signatures that use the <literal>docker</literal> transport type are served by local file or web
server. These signatures are more flexible; you can serve images from any
container image registry and use an independent server to deliver binary
signatures.</simpara>
<simpara>However, the <literal>docker</literal> transport type requires additional configuration. You must
configure the nodes with the URI of the signature server by placing
arbitrarily-named YAML files into a directory on the host system,
<literal>/etc/containers/registries.d</literal> by default. The YAML configuration files contain a
registry URI and a signature server URI, or <emphasis>sigstore</emphasis>:</simpara>
<formalpara>
<title>Example registries.d file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">docker:
    access.redhat.com:
        sigstore: https://access.redhat.com/webassets/docker/content/sigstore</programlisting>
</para>
</formalpara>
<simpara>In this example, the Red Hat Registry, <literal>access.redhat.com</literal>, is the signature
server that provides signatures for the <literal>docker</literal> transport type. Its URI is
defined in the <literal>sigstore</literal> parameter. You might name this file
<literal>/etc/containers/registries.d/redhat.com.yaml</literal> and use the Machine Config
Operator to
automatically place the file on each node in your cluster. No service
restart is required since policy and <literal>registries.d</literal> files are dynamically
loaded by the container runtime.</simpara>
</section>
<section xml:id="security-deploy-secrets_security-deploy">
<title>Creating secrets and config maps</title>
<simpara>The <literal>Secret</literal> object type provides a mechanism to hold sensitive information such
as passwords, OpenShift Container Platform client configuration files, <literal>dockercfg</literal> files,
and private source repository credentials. Secrets decouple sensitive content
from pods. You can mount secrets into containers using a volume plugin or the
system can use secrets to perform actions on behalf of a pod.</simpara>
<simpara>For example, to add a secret to your deployment configuration
so that it can access a private image repository, do the following:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Create a new project.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Resources</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis> and create a new secret. Set <literal>Secret Type</literal> to
<literal>Image Secret</literal> and <literal>Authentication Type</literal> to <literal>Image Registry Credentials</literal> to
enter credentials for accessing a private image repository.</simpara>
</listitem>
<listitem>
<simpara>When creating a deployment configuration (for example, from the <emphasis role="strong">Add to Project</emphasis> &#8594;
<emphasis role="strong">Deploy Image</emphasis> page), set the <literal>Pull Secret</literal> to your new secret.</simpara>
</listitem>
</orderedlist>
<simpara>Config maps are similar to secrets, but are designed to support working with
strings that do not contain sensitive information. The <literal>ConfigMap</literal> object holds
key-value pairs of configuration data that can be consumed in pods or used to
store configuration data for system components such as controllers.</simpara>
</section>
<section xml:id="security-deploy-continuous_security-deploy">
<title>Automating continuous deployment</title>
<simpara>You can integrate your own continuous deployment (CD) tooling with
OpenShift Container Platform.</simpara>
<simpara>By leveraging CI/CD and OpenShift Container Platform, you can automate the process of
rebuilding the application to incorporate the latest fixes, testing, and
ensuring that it is deployed everywhere within the environment.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../cicd/builds/creating-build-inputs.xml#builds-input-secrets-configmaps_creating-build-inputs">Input secrets and config maps</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-platform">
<title>Securing the container platform</title>

<simpara>OpenShift Container Platform and Kubernetes APIs are key to automating container management at scale. APIs are used to:</simpara>
<itemizedlist>
<listitem>
<simpara>Validate and configure the data for pods, services, and replication controllers.</simpara>
</listitem>
<listitem>
<simpara>Perform project validation on incoming requests and invoke triggers on other
major system components.</simpara>
</listitem>
</itemizedlist>
<simpara>Security-related features in OpenShift Container Platform that are based on Kubernetes include:</simpara>
<itemizedlist>
<listitem>
<simpara>Multitenancy, which combines Role-Based Access Controls and network policies
to isolate containers at multiple levels.</simpara>
</listitem>
<listitem>
<simpara>Admission plugins, which form boundaries between an API and those
making requests to the API.</simpara>
</listitem>
</itemizedlist>
<simpara>OpenShift Container Platform uses Operators to automate and simplify the management of
Kubernetes-level security features.</simpara>
<section xml:id="security-platform-multi-tenancy_security-platform">
<title>Isolating containers with multitenancy</title>
<simpara>Multitenancy allows applications on an OpenShift Container Platform cluster that are owned
by multiple users, and run across multiple hosts and namespaces,
to remain isolated from each other and from outside attacks.
You obtain multitenancy by applying role-based access control (RBAC)
to Kubernetes namespaces.</simpara>
<simpara>In Kubernetes, <emphasis>namespaces</emphasis> are areas where applications can run
in ways that are separate from other applications.
OpenShift Container Platform uses and extends namespaces by adding extra
annotations, including MCS labeling in SELinux, and identifying
these extended namespaces as <emphasis>projects</emphasis>. Within the scope of
a project, users can maintain their own cluster resources,
including service accounts, policies, constraints,
and various other objects.</simpara>
<simpara>RBAC objects are assigned to projects to authorize selected users
to have access to those projects. That authorization takes the form
of rules, roles, and bindings:</simpara>
<itemizedlist>
<listitem>
<simpara>Rules define what a user can create or access in a project.</simpara>
</listitem>
<listitem>
<simpara>Roles are collections of rules that you can bind to selected users or groups.</simpara>
</listitem>
<listitem>
<simpara>Bindings define the association between users or groups and roles.</simpara>
</listitem>
</itemizedlist>
<simpara>Local RBAC roles and bindings attach a user or group to a
particular project. Cluster RBAC can attach cluster-wide roles and bindings
to all projects in a cluster. There are default
cluster roles that can be assigned to provide <literal>admin</literal>, <literal>basic-user</literal>, <literal>cluster-admin</literal>,
and <literal>cluster-status</literal> access.</simpara>
</section>
<section xml:id="security-platform-admission_security-platform">
<title>Protecting control plane with admission plugins</title>
<simpara>While RBAC controls access rules between users and groups and available projects,
<emphasis>admission plugins</emphasis> define access to the OpenShift Container Platform master API.
Admission plugins form a chain of rules that consist of:</simpara>
<itemizedlist>
<listitem>
<simpara>Default admissions plugins: These implement a default set of
policies and resources limits that are applied to components of the OpenShift Container Platform
control plane.</simpara>
</listitem>
<listitem>
<simpara>Mutating admission plugins: These plugins dynamically extend the admission chain.
They call out to a webhook server and can both authenticate a request and modify the selected resource.</simpara>
</listitem>
<listitem>
<simpara>Validating admission plugins: These validate requests for a selected resource
and can both validate the request and ensure that the resource does not change again.</simpara>
</listitem>
</itemizedlist>
<simpara>API requests go through admissions plugins in a chain, with any failure along
the way causing the request to be rejected. Each admission plugin is associated with particular resources and only
responds to requests for those resources.</simpara>
<section xml:id="security-deployment-sccs_security-platform">
<title>Security context constraints (SCCs)</title>
<simpara>You can use <emphasis>security context constraints</emphasis> (SCCs) to define a set of conditions
that a pod must run with to be accepted
into the system.</simpara>
<simpara>Some aspects that can be managed by SCCs include:</simpara>
<itemizedlist>
<listitem>
<simpara>Running of privileged containers</simpara>
</listitem>
<listitem>
<simpara>Capabilities a container can request to be added</simpara>
</listitem>
<listitem>
<simpara>Use of host directories as volumes</simpara>
</listitem>
<listitem>
<simpara>SELinux context of the container</simpara>
</listitem>
<listitem>
<simpara>Container user ID</simpara>
</listitem>
</itemizedlist>
<simpara>If you have the required permissions, you can adjust the default SCC policies to
be more permissive, if required.</simpara>
</section>
<section xml:id="security-service-account_security-platform">
<title>Granting roles to service accounts</title>
<simpara>You can assign roles to service accounts, in the same way that
users are assigned role-based access.
There are three default service accounts created for each project.
A service account:</simpara>
<itemizedlist>
<listitem>
<simpara>is limited in scope to a particular project</simpara>
</listitem>
<listitem>
<simpara>derives its name from its project</simpara>
</listitem>
<listitem>
<simpara>is automatically assigned an API token and credentials to access the
OpenShift Container Registry</simpara>
</listitem>
</itemizedlist>
<simpara>Service accounts associated with platform components automatically
have their keys rotated.</simpara>
</section>
</section>
<section xml:id="security-platform-authentication_security-platform">
<title>Authentication and authorization</title>
<section xml:id="security-platform-auth-controlling-access_security-platform">
<title>Controlling access using OAuth</title>
<simpara>You can use API access control via authentication and authorization for securing
your container platform. The OpenShift Container Platform master includes a built-in OAuth
server. Users can obtain OAuth access tokens to authenticate themselves to the
API.</simpara>
<simpara>As an administrator, you can configure OAuth to authenticate using an <emphasis>identity
provider</emphasis>, such as LDAP, GitHub, or Google. The
identity provider is used by default for new OpenShift Container Platform deployments, but
you can configure this at initial installation time or postinstallation.</simpara>
</section>
<section xml:id="security-platform-api-access-control_security-platform">
<title>API access control and management</title>
<simpara>Applications can have multiple, independent API services which have different
endpoints that require management. OpenShift Container Platform includes a containerized
version of the 3scale API gateway so that you can manage your APIs and control
access.</simpara>
<simpara>3scale gives you a variety of standard options for API authentication and
security, which can be used alone or in combination to issue credentials and
control access: standard API keys, application ID and key pair, and OAuth 2.0.</simpara>
<simpara>You can restrict access to specific endpoints, methods, and services and apply
access policy for groups of users. Application plans allow you to set rate
limits for API usage and control traffic flow for groups of developers.</simpara>
<simpara>For a tutorial on using APIcast v2, the containerized 3scale API Gateway, see
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.0/html/deployment_options/apicast-openshift">Running APIcast on Red Hat OpenShift</link>
in the 3scale documentation.</simpara>
</section>
<section xml:id="security-platform-red-hat-sso_security-platform">
<title>Red Hat Single Sign-On</title>
<simpara>The Red Hat Single Sign-On server enables you to secure your
applications by providing web single sign-on capabilities based on standards, including
SAML 2.0, OpenID Connect, and OAuth 2.0. The server can act as a SAML or OpenID
Connect–based identity provider (IdP), mediating with your enterprise user
directory or third-party identity provider for identity information and your
applications using standards-based tokens. You can integrate Red Hat Single Sign-On with
LDAP-based directory services including Microsoft Active Directory and Red Hat
Enterprise Linux Identity Management.</simpara>
</section>
<section xml:id="security-platform-auth-secure-self-service-web-console_security-platform">
<title>Secure self-service web console</title>
<simpara>OpenShift Container Platform provides a self-service web console to ensure that teams do not
access other environments without authorization. OpenShift Container Platform ensures a
secure multitenant master by providing the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Access to the master uses Transport Layer Security (TLS)</simpara>
</listitem>
<listitem>
<simpara>Access to the API Server uses X.509 certificates or OAuth access tokens</simpara>
</listitem>
<listitem>
<simpara>Project quota limits the damage that a rogue token could do</simpara>
</listitem>
<listitem>
<simpara>The etcd service is not exposed directly to the cluster</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-platform-certificates_security-platform">
<title>Managing certificates for the platform</title>
<simpara>OpenShift Container Platform has multiple components within its framework that use REST-based
HTTPS communication leveraging encryption via TLS certificates.
OpenShift Container Platform&#8217;s installer configures these certificates during
installation. There are some primary components that generate this traffic:</simpara>
<itemizedlist>
<listitem>
<simpara>masters (API server and controllers)</simpara>
</listitem>
<listitem>
<simpara>etcd</simpara>
</listitem>
<listitem>
<simpara>nodes</simpara>
</listitem>
<listitem>
<simpara>registry</simpara>
</listitem>
<listitem>
<simpara>router</simpara>
</listitem>
</itemizedlist>
<section xml:id="security-platform-config-custom-certs_security-platform">
<title>Configuring custom certificates</title>
<simpara>You can configure custom serving certificates for the public hostnames of the
API server and web console during initial installation or when redeploying
certificates. You can also use a custom CA.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../architecture/architecture.xml#architecture-platform-introduction_architecture">Introduction to OpenShift Container Platform</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/using-rbac.xml#using-rbac">Using RBAC to define and apply permissions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../architecture/admission-plug-ins.xml#admission-plug-ins">About admission plugins</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/managing-security-context-constraints.xml#managing-pod-security-policies">Managing security context constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/managing-security-context-constraints.xml#security-context-constraints-command-reference_configuring-internal-oauth">SCC reference commands</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/understanding-and-creating-service-accounts.xml#service-accounts-granting-roles_understanding-service-accounts">Examples of granting roles to service accounts</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/configuring-internal-oauth.xml#configuring-internal-oauth">Configuring the internal OAuth server</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/understanding-identity-provider.xml#understanding-identity-provider">Understanding identity provider configuration</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificate_types_descriptions/user-provided-certificates-for-api-server.xml#cert-types-user-provided-certificates-for-the-api-server">Certificate types and descriptions</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificate_types_descriptions/proxy-certificates.xml#cert-types-proxy-certificates">Proxy certificates</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="security-network">
<title>Securing networks</title>

<simpara>Network security can be managed at several levels. At the pod level,
network namespaces can prevent containers from seeing other pods or
the host system by restricting network access. Network policies
give you control over allowing and rejecting connections.
You can manage ingress and egress traffic to and from your
containerized applications.</simpara>
<section xml:id="security-network-namespaces_security-network">
<title>Using network namespaces</title>
<simpara>OpenShift Container Platform uses software-defined networking (SDN) to provide a unified
cluster network that enables communication between containers across the
cluster.</simpara>
<simpara>Network policy mode, by default, makes all pods in a project accessible from
other pods and network endpoints.
To isolate one or more pods in a project, you can create <literal>NetworkPolicy</literal> objects
in that project to indicate the allowed incoming connections.
Using multitenant mode, you can provide project-level isolation for pods and services.</simpara>
</section>
<section xml:id="security-network-policies_security-network">
<title>Isolating pods with network policies</title>
<simpara>Using <emphasis>network policies</emphasis>, you can isolate pods from each other in the same project.
Network policies can deny all network access to a pod,
only allow connections for the Ingress Controller, reject connections from
pods in other projects, or set similar rules for how networks behave.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/network_policy/about-network-policy.xml#about-network-policy">About network policy</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-network-multiple-pod_security-network">
<title>Using multiple pod networks</title>
<simpara>Each running container has only one network interface by default.
The Multus CNI plugin lets you create multiple CNI networks, and then
attach any of those networks to your pods. In that way, you can do
things like separate private data onto a more restricted network
and have multiple network interfaces on each node.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/multiple_networks/understanding-multiple-networks.xml#understanding-multiple-networks">Using multiple networks</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-network-isolating_security-network">
<title>Isolating applications</title>
<simpara>OpenShift Container Platform enables you to segment network traffic on a single cluster to
make multitenant clusters that isolate users, teams, applications, and
environments from non-global resources.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/openshift_sdn/multitenant-isolation.xml#configuring-multitenant-isolation">Configuring network isolation using OpenShiftSDN</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-network-ingress_security-network">
<title>Securing ingress traffic</title>
<simpara>There are many security implications related to how you configure
access to your Kubernetes services from outside of your OpenShift Container Platform cluster.
Besides exposing HTTP and HTTPS routes, ingress routing allows you to set up
NodePort or LoadBalancer ingress types. NodePort exposes an application&#8217;s
service API object from each cluster worker. LoadBalancer lets you assign an
external load balancer to an associated service API object
in your OpenShift Container Platform cluster.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/configuring_ingress_cluster_traffic/configuring-ingress-cluster-traffic-ingress-controller.xml#configuring-ingress-cluster-traffic-ingress-controller">Configuring ingress cluster traffic</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-network-egress_security-network">
<title>Securing egress traffic</title>
<simpara>OpenShift Container Platform provides the ability to control egress traffic using either
a router or firewall method. For example, you can use IP whitelisting to control
database access.
A cluster administrator can assign one or more egress IP addresses to a project
in an OpenShift Container Platform SDN network provider.
Likewise, a cluster administrator can prevent egress traffic from
going outside of an OpenShift Container Platform cluster using an egress firewall.</simpara>
<simpara>By assigning a fixed egress IP address, you can have all outgoing traffic
assigned to that IP address for a particular project.
With the egress firewall, you can prevent a pod from connecting to an
external network, prevent a pod from connecting to an internal network,
or limit a pod&#8217;s access to specific internal subnets.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../networking/openshift_sdn/configuring-egress-firewall.xml#configuring-egress-firewall">Configuring an egress firewall to control access to external IP addresses</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../networking/openshift_sdn/assigning-egress-ips.xml#assigning-egress-ips">Configuring egress IPs for a project</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-storage">
<title>Securing attached storage</title>

<simpara>OpenShift Container Platform supports multiple types of storage, both
for on-premise and cloud providers. In particular,
OpenShift Container Platform can use storage types that support the Container
Storage Interface.</simpara>
<section xml:id="security-network-storage-persistent_security-storage">
<title>Persistent volume plugins</title>
<simpara>Containers are useful for both stateless and stateful applications.
Protecting attached storage is a key element of securing stateful services.
Using the Container Storage Interface (CSI), OpenShift Container Platform can
incorporate storage from any storage back end that supports the CSI interface.</simpara>
<simpara>OpenShift Container Platform provides plugins for multiple types of storage, including:</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat OpenShift Data Foundation *</simpara>
</listitem>
<listitem>
<simpara>AWS Elastic Block Stores (EBS) *</simpara>
</listitem>
<listitem>
<simpara>AWS Elastic File System (EFS) *</simpara>
</listitem>
<listitem>
<simpara>Azure Disk *</simpara>
</listitem>
<listitem>
<simpara>Azure File *</simpara>
</listitem>
<listitem>
<simpara>OpenStack Cinder *</simpara>
</listitem>
<listitem>
<simpara>GCE Persistent Disks *</simpara>
</listitem>
<listitem>
<simpara>VMware vSphere *</simpara>
</listitem>
<listitem>
<simpara>Network File System (NFS)</simpara>
</listitem>
<listitem>
<simpara>FlexVolume</simpara>
</listitem>
<listitem>
<simpara>Fibre Channel</simpara>
</listitem>
<listitem>
<simpara>iSCSI</simpara>
</listitem>
</itemizedlist>
<simpara>Plugins for those storage types with dynamic provisioning are marked with
an asterisk (*). Data in transit is encrypted via HTTPS for all
OpenShift Container Platform components communicating with each other.</simpara>
<simpara>You can mount a persistent volume (PV) on a host in any way supported by your
storage type. Different types of storage have different capabilities and each
PV&#8217;s access modes are set to the specific modes supported by that particular
volume.</simpara>
<simpara>For example, NFS can support multiple read/write clients, but a specific NFS PV
might be exported on the server as read-only. Each PV has its own set of access
modes describing that specific PV&#8217;s capabilities, such as <literal>ReadWriteOnce</literal>,
<literal>ReadOnlyMany</literal>, and <literal>ReadWriteMany</literal>.</simpara>
</section>
<section xml:id="security-network-storage-shared_security-storage">
<title>Shared storage</title>
<simpara>For shared storage providers like NFS, the PV registers its
group ID (GID) as an annotation on the PV resource. Then, when the PV is claimed
by the pod, the annotated GID is added to the supplemental groups of the pod,
giving that pod access to the contents of the shared storage.</simpara>
</section>
<section xml:id="security-network-storage-block_security-storage">
<title>Block storage</title>
<simpara>For block storage providers like AWS Elastic Block Store (EBS), GCE Persistent
Disks, and iSCSI, OpenShift Container Platform uses SELinux capabilities to secure the root
of the mounted volume for non-privileged pods, making the mounted volume owned
by and only visible to the container with which it is associated.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../storage/understanding-persistent-storage.xml#understanding-persistent-storage">Understanding persistent storage</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../storage/container_storage_interface/persistent-storage-csi.xml#persistent-storage-using-csi">Configuring CSI volumes</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../storage/dynamic-provisioning.xml#dynamic-provisioning">Dynamic provisioning</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../storage/persistent_storage/persistent-storage-nfs.xml#persistent-storage-using-nfs">Persistent storage using NFS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../storage/persistent_storage/persistent-storage-aws.xml#persistent-storage-using-aws-ebs">Persistent storage using AWS Elastic Block Store</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../storage/persistent_storage/persistent-storage-gce.xml#persistent-storage-using-gce">Persistent storage using GCE Persistent Disk</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="security-monitoring">
<title>Monitoring cluster events and logs</title>

<simpara>The ability to monitor and audit an OpenShift Container Platform cluster is an
important part of safeguarding the cluster and its users against
inappropriate usage.</simpara>
<simpara>There are two main sources of cluster-level information that
are useful for this purpose: events and logging.</simpara>
<section xml:id="security-monitoring-events_security-monitoring">
<title>Watching cluster events</title>
<simpara>Cluster administrators are encouraged to familiarize themselves with the <literal>Event</literal> resource
type and review the list of system events to
determine which events are of interest.
Events are associated with a namespace, either the namespace of the
resource they are related to or, for cluster events, the <literal>default</literal>
namespace. The default namespace holds relevant events for monitoring or auditing a cluster,
such as node events and resource events related to infrastructure components.</simpara>
<simpara>The master API and <literal>oc</literal> command do not provide parameters to scope a listing of events to only those
related to nodes. A simple approach would be to use <literal>grep</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get event -n default | grep Node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">1h         20h         3         origin-node-1.example.local   Node      Normal    NodeHasDiskPressure   ...</programlisting>
</para>
</formalpara>
<simpara>A more flexible approach is to output the events in a form that other
tools can process. For example, the following example uses the <literal>jq</literal>
tool against JSON output to extract only <literal>NodeHasDiskPressure</literal> events:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events -n default -o json \
  | jq '.items[] | select(.involvedObject.kind == "Node" and .reason == "NodeHasDiskPressure")'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "apiVersion": "v1",
  "count": 3,
  "involvedObject": {
    "kind": "Node",
    "name": "origin-node-1.example.local",
    "uid": "origin-node-1.example.local"
  },
  "kind": "Event",
  "reason": "NodeHasDiskPressure",
  ...
}</programlisting>
</para>
</formalpara>
<simpara>Events related to resource creation, modification, or deletion can also be
good candidates for detecting misuse of the cluster. The following query,
for example, can be used to look for excessive pulling of images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events --all-namespaces -o json \
  | jq '[.items[] | select(.involvedObject.kind == "Pod" and .reason == "Pulling")] | length'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">4</programlisting>
</para>
</formalpara>
<note>
<simpara>When a namespace is deleted, its events are deleted as well. Events can also expire and are deleted to prevent
filling up etcd storage. Events are
not stored as a permanent record and frequent polling is necessary to capture statistics over time.</simpara>
</note>
</section>
<section xml:id="security-monitoring-cluster-logging_security-monitoring">
<title>Logging</title>
<simpara>Using the <literal>oc log</literal> command, you can view container logs, build configs and deployments in real time. Different can users have access different access to logs:</simpara>
<itemizedlist>
<listitem>
<simpara>Users who have access to a project are able to see the logs for that project by default.</simpara>
</listitem>
<listitem>
<simpara>Users with admin roles can access all container logs.</simpara>
</listitem>
</itemizedlist>
<simpara>To save your logs for further audit and analysis, you can enable the <literal>cluster-logging</literal> add-on feature to collect, manage, and view system, container, and audit logs. You can deploy, manage, and upgrade OpenShift Logging through the OpenShift Elasticsearch Operator and Red Hat OpenShift Logging Operator.</simpara>
</section>
<section xml:id="security-monitoring-audit-logs_security-monitoring">
<title>Audit logs</title>
<simpara>With <emphasis>audit logs</emphasis>, you can follow a sequence of activities associated with how a
user, administrator, or other OpenShift Container Platform component is behaving.
API audit logging is done on each server.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../nodes/clusters/nodes-containers-events.xml#nodes-containers-events">List of system events</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../logging/cluster-logging.xml#cluster-logging">Understanding OpenShift Logging</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/audit-log-view.xml#audit-log-view">Viewing audit logs</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_configuring_certificates">
<title>Configuring certificates</title>
<section xml:id="replacing-default-ingress">
<title>Replacing the default ingress certificate</title>

<section xml:id="understanding-default-ingress_replacing-default-ingress">
<title>Understanding the default ingress certificate</title>
<simpara>By default, OpenShift Container Platform uses the Ingress Operator to
create an internal CA and issue a wildcard certificate that is valid for
applications under the <literal>.apps</literal> sub-domain. Both the web console and CLI
use this certificate as well.</simpara>
<simpara>The internal infrastructure CA certificates are self-signed.
While this process might be perceived as bad practice by some security or
PKI teams, any risk here is minimal. The only clients that implicitly
trust these certificates are other components within the cluster.
Replacing the default wildcard certificate with one that is issued by a
public CA already included in the CA bundle as provided by the container userspace
allows external clients to connect securely to applications running under the <literal>.apps</literal> sub-domain.</simpara>
</section>
<section xml:id="replacing-default-ingress_replacing-default-ingress">
<title>Replacing the default ingress certificate</title>
<simpara>You can replace the default ingress certificate for all
applications under the <literal>.apps</literal> subdomain. After you replace
the certificate, all applications, including the web console
and CLI, will have encryption provided by specified certificate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have a wildcard certificate for the fully qualified <literal>.apps</literal> subdomain
and its corresponding private key. Each should be in a separate PEM format file.</simpara>
</listitem>
<listitem>
<simpara>The private key must be unencrypted. If your key is encrypted, decrypt it
before importing it into OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>The certificate must include the <literal>subjectAltName</literal> extension showing
<literal>*.apps.&lt;clustername&gt;.&lt;domain&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>The certificate file can contain one or more certificates in a chain. The
wildcard certificate must be the first certificate in the file. It can then be
followed with any intermediate certificates, and the file should end with the
root CA certificate.</simpara>
</listitem>
<listitem>
<simpara>Copy the root CA certificate into an additional PEM format file.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a config map that includes only the root CA certificate used to sign the wildcard certificate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap custom-ca \
     --from-file=ca-bundle.crt=&lt;/path/to/example-ca.crt&gt; \<co xml:id="CO7-1"/>
     -n openshift-config</programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para><literal>&lt;/path/to/example-ca.crt&gt;</literal> is the path to the root CA certificate file on your local file system.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the cluster-wide proxy configuration with the newly created config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch proxy/cluster \
     --type=merge \
     --patch='{"spec":{"trustedCA":{"name":"custom-ca"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Create a secret that contains the wildcard certificate chain and key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret tls &lt;secret&gt; \<co xml:id="CO8-1"/>
     --cert=&lt;/path/to/cert.crt&gt; \<co xml:id="CO8-2"/>
     --key=&lt;/path/to/cert.key&gt; \<co xml:id="CO8-3"/>
     -n openshift-ingress</programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para><literal>&lt;secret&gt;</literal> is the name of the secret that will contain the certificate chain
and private key.</para>
</callout>
<callout arearefs="CO8-2">
<para><literal>&lt;/path/to/cert.crt&gt;</literal> is the path to the certificate chain on your local
file system.</para>
</callout>
<callout arearefs="CO8-3">
<para><literal>&lt;/path/to/cert.key&gt;</literal> is the path to the private key associated
with this certificate.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the Ingress Controller configuration with the newly created
secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch ingresscontroller.operator default \
     --type=merge -p \
     '{"spec":{"defaultCertificate": {"name": "&lt;secret&gt;"}}}' \<co xml:id="CO9-1"/>
     -n openshift-ingress-operator</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>Replace <literal>&lt;secret&gt;</literal> with the name used for the secret in
the previous step.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<bridgehead xml:id="_additional_resources" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/certificates/updating-ca-bundle.xml#ca-bundle-understanding_updating-ca-bundle">Replacing the CA Bundle certificate</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificate_types_descriptions/proxy-certificates.xml#customization">Proxy certificate customization</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="api-server-certificates">
<title>Adding API server certificates</title>

<simpara>The default API server certificate is issued by an internal OpenShift Container Platform
cluster CA. Clients outside of the cluster will not be able to verify the
API server&#8217;s certificate by default. This certificate can be replaced
by one that is issued by a CA that clients trust.</simpara>
<section xml:id="customize-certificates-api-add-named_api-server-certificates">
<title>Add an API server named certificate</title>
<simpara>The default API server certificate is issued by an internal OpenShift Container Platform
cluster CA. You can add one or more alternative certificates that the API
server will return based on the fully qualified domain name (FQDN) requested by
the client, for example when a reverse proxy or load balancer is used.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have a certificate for the FQDN and its corresponding private key. Each should be in a separate PEM format file.</simpara>
</listitem>
<listitem>
<simpara>The private key must be unencrypted. If your key is encrypted, decrypt it
before importing it into OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>The certificate must include the <literal>subjectAltName</literal> extension showing the FQDN.</simpara>
</listitem>
<listitem>
<simpara>The certificate file can contain one or more certificates in a chain. The
certificate for the API server FQDN must be the first certificate in the file.
It can then be followed with any intermediate certificates, and the file should
end with the root CA certificate.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Do not provide a named certificate for the internal load balancer (host
name <literal>api-int.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal>). Doing so will leave your
cluster in a degraded state.</simpara>
</warning>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Login to the new API as the <literal>kubeadmin</literal> user.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u kubeadmin -p &lt;password&gt; https://FQDN:6443</programlisting>
</listitem>
<listitem>
<simpara>Get the <literal>kubeconfig</literal> file.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc config view --flatten &gt; kubeconfig-newapi</programlisting>
</listitem>
<listitem>
<simpara>Create a secret that contains the certificate chain and private key in the
<literal>openshift-config</literal> namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret tls &lt;secret&gt; \<co xml:id="CO10-1"/>
     --cert=&lt;/path/to/cert.crt&gt; \<co xml:id="CO10-2"/>
     --key=&lt;/path/to/cert.key&gt; \<co xml:id="CO10-3"/>
     -n openshift-config</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para><literal>&lt;secret&gt;</literal> is the name of the secret that will contain the certificate chain and private key.</para>
</callout>
<callout arearefs="CO10-2">
<para><literal>&lt;/path/to/cert.crt&gt;</literal> is the path to the certificate chain on your local file system.</para>
</callout>
<callout arearefs="CO10-3">
<para><literal>&lt;/path/to/cert.key&gt;</literal> is the path to the private key associated with this certificate.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the API server to reference the created secret.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch apiserver cluster \
     --type=merge -p \
     '{"spec":{"servingCerts": {"namedCertificates":
     [{"names": ["&lt;FQDN&gt;"], <co xml:id="CO11-1"/>
     "servingCertificate": {"name": "&lt;secret&gt;"}}]}}}' <co xml:id="CO11-2"/></programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Replace <literal>&lt;FQDN&gt;</literal> with the FQDN that the API server should provide the certificate for.</para>
</callout>
<callout arearefs="CO11-2">
<para>Replace <literal>&lt;secret&gt;</literal> with the name used for the secret in the previous step.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Examine the <literal>apiserver/cluster</literal> object and confirm the secret is now
referenced.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get apiserver cluster -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
spec:
  servingCerts:
    namedCertificates:
    - names:
      - &lt;FQDN&gt;
      servingCertificate:
        name: &lt;secret&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>kube-apiserver</literal> operator, and verify that a new revision of the Kubernetes API server rolls out.
It may take a minute for the operator to detect the configuration change and trigger a new deployment.
While the new revision is rolling out, <literal>PROGRESSING</literal> will report <literal>True</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperators kube-apiserver</programlisting>
<simpara>Do not continue to the next step until <literal>PROGRESSING</literal> is listed as <literal>False</literal>, as shown in the following output:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
kube-apiserver   4.14.0     True        False         False      145m</programlisting>
</para>
</formalpara>
<simpara>If <literal>PROGRESSING</literal> is showing <literal>True</literal>, wait a few minutes and try again.</simpara>
<note>
<simpara>A new revision of the Kubernetes API server only rolls out if the API server named certificate is added for the first time. When the API server named certificate is renewed, a new revision of the Kubernetes API server does not roll out because the <literal>kube-apiserver</literal> pods dynamically reload the updated certificate.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="add-service-serving">
<title>Securing service traffic using service serving certificate secrets</title>

<section xml:id="understanding-service-serving_service-serving-certificate">
<title>Understanding service serving certificates</title>
<simpara>Service serving certificates are intended to support complex
middleware applications that require encryption. These certificates are
issued as TLS web server certificates.</simpara>
<simpara>The <literal>service-ca</literal> controller uses the <literal>x509.SHA256WithRSA</literal> signature
algorithm to generate service certificates.</simpara>
<simpara>The generated certificate and key are in PEM format, stored in <literal>tls.crt</literal>
and <literal>tls.key</literal> respectively, within a created secret. The
certificate and key are automatically replaced when they get close to
expiration.</simpara>
<simpara>The service CA certificate, which issues the service certificates, is valid for 26 months and is automatically rotated when there is less than 13 months validity left. After rotation, the previous service CA configuration is still trusted until its expiration. This allows a grace period for all affected services to refresh their key material before the expiration. If you do not upgrade your cluster during this grace period, which restarts services and refreshes their key material, you might need to manually restart services to avoid failures after the previous service CA expires.</simpara>
<note>
<simpara>You can use the following command to manually restart all pods in the cluster. Be aware that running this command causes a service interruption, because it deletes every running pod in every namespace. These pods will automatically restart after they are deleted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ for I in $(oc get ns -o jsonpath='{range .items[*]} {.metadata.name}{"\n"} {end}'); \
      do oc delete pods --all -n $I; \
      sleep 1; \
      done</programlisting>
</note>
</section>
<section xml:id="add-service-certificate_service-serving-certificate">
<title>Add a service certificate</title>
<simpara>To secure communication to your service, generate a signed serving certificate and key pair into a secret in the same namespace as the service.</simpara>
<simpara>The generated certificate is only valid for the internal service DNS name <literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal>, and is only valid for internal communications. If your service is a headless service (no <literal>clusterIP</literal> value set), the generated certificate also contains a wildcard subject in the format of <literal>*.&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal>.</simpara>
<important>
<simpara>Because the generated certificates contain wildcard subjects for headless services, you must not use the service CA if your client must differentiate between individual pods. In this case:</simpara>
<itemizedlist>
<listitem>
<simpara>Generate individual TLS certificates by using a different CA.</simpara>
</listitem>
<listitem>
<simpara>Do not accept the service CA as a trusted CA for connections that are directed to individual pods and must not be impersonated by other pods. These connections must be configured to trust the CA that was used to generate the individual TLS certificates.</simpara>
</listitem>
</itemizedlist>
</important>
<itemizedlist>
<title>Prerequisites:</title>
<listitem>
<simpara>You must have a service defined.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the service with <literal>service.beta.openshift.io/serving-cert-secret-name</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service &lt;service_name&gt; \<co xml:id="CO12-1"/>
     service.beta.openshift.io/serving-cert-secret-name=&lt;secret_name&gt; <co xml:id="CO12-2"/></programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>Replace <literal>&lt;service_name&gt;</literal> with the name of the service to secure.</para>
</callout>
<callout arearefs="CO12-2">
<para><literal>&lt;secret_name&gt;</literal> will be the name of the generated secret containing the
certificate and key pair. For convenience, it is recommended that this
be the same as <literal>&lt;service_name&gt;</literal>.</para>
</callout>
</calloutlist>
<simpara>For example, use the following command to annotate the service <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service test1 service.beta.openshift.io/serving-cert-secret-name=test1</programlisting>
</listitem>
<listitem>
<simpara>Examine the service to confirm that the annotations are present:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe service &lt;service_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
Annotations:              service.beta.openshift.io/serving-cert-secret-name: &lt;service_name&gt;
                          service.beta.openshift.io/serving-cert-signed-by: openshift-service-serving-signer@1556850837
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After the cluster generates a secret for your service, your <literal>Pod</literal> spec can
mount it, and the pod will run after it becomes available.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>You can use a service certificate to configure a secure route using reencrypt TLS termination. For more information, see <link xlink:href="../../networking/routes/secured-routes.xml#nw-ingress-creating-a-reencrypt-route-with-a-custom-certificate_secured-routes">Creating a re-encrypt route with a custom certificate</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-service-certificate-configmap_service-serving-certificate">
<title>Add the service CA bundle to a config map</title>
<simpara>A pod can access the service CA certificate by mounting a <literal>ConfigMap</literal> object that
is annotated with <literal>service.beta.openshift.io/inject-cabundle=true</literal>.
Once annotated, the cluster automatically injects the service CA
certificate into the <literal>service-ca.crt</literal> key on the config map. Access to
this CA certificate allows TLS clients to verify connections to
services using service serving certificates.</simpara>
<important>
<simpara>After adding this annotation to a config map all existing data in it is
deleted. It is recommended to use a separate config map to contain the
<literal>service-ca.crt</literal>, instead of using the same config map that stores your
pod configuration.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the config map with <literal>service.beta.openshift.io/inject-cabundle=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate configmap &lt;config_map_name&gt; \<co xml:id="CO13-1"/>
     service.beta.openshift.io/inject-cabundle=true</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Replace <literal>&lt;config_map_name&gt;</literal> with the name of the config map to annotate.</para>
</callout>
</calloutlist>
<note>
<simpara>Explicitly referencing the <literal>service-ca.crt</literal> key in a volume mount will prevent a pod from starting until the config map has been injected with the CA bundle. This behavior can be overridden by setting the <literal>optional</literal> field to <literal>true</literal> for the volume&#8217;s serving certificate configuration.</simpara>
</note>
<simpara>For example, use the following command to annotate the config map <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate configmap test1 service.beta.openshift.io/inject-cabundle=true</programlisting>
</listitem>
<listitem>
<simpara>View the config map to ensure that the service CA bundle has been injected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmap &lt;config_map_name&gt; -o yaml</programlisting>
<simpara>The CA bundle is displayed as the value of the <literal>service-ca.crt</literal> key in the YAML output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
data:
  service-ca.crt: |
    -----BEGIN CERTIFICATE-----
...</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="add-service-certificate-apiservice_service-serving-certificate">
<title>Add the service CA bundle to an API service</title>
<simpara>You can annotate an <literal>APIService</literal> object with <literal>service.beta.openshift.io/inject-cabundle=true</literal> to have its <literal>spec.caBundle</literal> field populated with the service CA bundle. This allows the Kubernetes API server to validate the service CA certificate used to secure the targeted endpoint.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the API service with <literal>service.beta.openshift.io/inject-cabundle=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate apiservice &lt;api_service_name&gt; \<co xml:id="CO14-1"/>
     service.beta.openshift.io/inject-cabundle=true</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Replace <literal>&lt;api_service_name&gt;</literal> with the name of the API service to annotate.</para>
</callout>
</calloutlist>
<simpara>For example, use the following command to annotate the API service <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate apiservice test1 service.beta.openshift.io/inject-cabundle=true</programlisting>
</listitem>
<listitem>
<simpara>View the API service to ensure that the service CA bundle has been injected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get apiservice &lt;api_service_name&gt; -o yaml</programlisting>
<simpara>The CA bundle is displayed in the <literal>spec.caBundle</literal> field in the YAML output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: apiregistration.k8s.io/v1
kind: APIService
metadata:
  annotations:
    service.beta.openshift.io/inject-cabundle: "true"
...
spec:
  caBundle: &lt;CA_BUNDLE&gt;
...</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="add-service-certificate-crd_service-serving-certificate">
<title>Add the service CA bundle to a custom resource definition</title>
<simpara>You can annotate a <literal>CustomResourceDefinition</literal> (CRD) object with <literal>service.beta.openshift.io/inject-cabundle=true</literal> to have its <literal>spec.conversion.webhook.clientConfig.caBundle</literal> field populated with the service CA bundle. This allows the Kubernetes API server to validate the service CA certificate used to secure the targeted endpoint.</simpara>
<note>
<simpara>The service CA bundle will only be injected into the CRD if the CRD is configured to use a webhook for conversion. It is only useful to inject the service CA bundle if a CRD&#8217;s webhook is secured with a service CA certificate.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the CRD with <literal>service.beta.openshift.io/inject-cabundle=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate crd &lt;crd_name&gt; \<co xml:id="CO15-1"/>
     service.beta.openshift.io/inject-cabundle=true</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Replace <literal>&lt;crd_name&gt;</literal> with the name of the CRD to annotate.</para>
</callout>
</calloutlist>
<simpara>For example, use the following command to annotate the CRD <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate crd test1 service.beta.openshift.io/inject-cabundle=true</programlisting>
</listitem>
<listitem>
<simpara>View the CRD to ensure that the service CA bundle has been injected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crd &lt;crd_name&gt; -o yaml</programlisting>
<simpara>The CA bundle is displayed in the <literal>spec.conversion.webhook.clientConfig.caBundle</literal> field in the YAML output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    service.beta.openshift.io/inject-cabundle: "true"
...
spec:
  conversion:
    strategy: Webhook
    webhook:
      clientConfig:
        caBundle: &lt;CA_BUNDLE&gt;
...</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="add-service-certificate-mutating-webhook_service-serving-certificate">
<title>Add the service CA bundle to a mutating webhook configuration</title>
<simpara>You can annotate a <literal>MutatingWebhookConfiguration</literal> object with <literal>service.beta.openshift.io/inject-cabundle=true</literal> to have the <literal>clientConfig.caBundle</literal> field of each webhook populated with the service CA bundle. This allows the Kubernetes API server to validate the service CA certificate used to secure the targeted endpoint.</simpara>
<note>
<simpara>Do not set this annotation for admission webhook configurations that need to specify different CA bundles for different webhooks. If you do, then the service CA bundle will be injected for all webhooks.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the mutating webhook configuration with <literal>service.beta.openshift.io/inject-cabundle=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate mutatingwebhookconfigurations &lt;mutating_webhook_name&gt; \<co xml:id="CO16-1"/>
     service.beta.openshift.io/inject-cabundle=true</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Replace <literal>&lt;mutating_webhook_name&gt;</literal> with the name of the mutating webhook configuration to annotate.</para>
</callout>
</calloutlist>
<simpara>For example, use the following command to annotate the mutating webhook configuration <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate mutatingwebhookconfigurations test1 service.beta.openshift.io/inject-cabundle=true</programlisting>
</listitem>
<listitem>
<simpara>View the mutating webhook configuration to ensure that the service CA bundle has been injected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mutatingwebhookconfigurations &lt;mutating_webhook_name&gt; -o yaml</programlisting>
<simpara>The CA bundle is displayed in the <literal>clientConfig.caBundle</literal> field of all webhooks in the YAML output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  annotations:
    service.beta.openshift.io/inject-cabundle: "true"
...
webhooks:
- myWebhook:
  - v1beta1
  clientConfig:
    caBundle: &lt;CA_BUNDLE&gt;
...</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="add-service-certificate-validating-webhook_service-serving-certificate">
<title>Add the service CA bundle to a validating webhook configuration</title>
<simpara>You can annotate a <literal>ValidatingWebhookConfiguration</literal> object with <literal>service.beta.openshift.io/inject-cabundle=true</literal> to have the <literal>clientConfig.caBundle</literal> field of each webhook populated with the service CA bundle. This allows the Kubernetes API server to validate the service CA certificate used to secure the targeted endpoint.</simpara>
<note>
<simpara>Do not set this annotation for admission webhook configurations that need to specify different CA bundles for different webhooks. If you do, then the service CA bundle will be injected for all webhooks.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Annotate the validating webhook configuration with <literal>service.beta.openshift.io/inject-cabundle=true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate validatingwebhookconfigurations &lt;validating_webhook_name&gt; \<co xml:id="CO17-1"/>
     service.beta.openshift.io/inject-cabundle=true</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>Replace <literal>&lt;validating_webhook_name&gt;</literal> with the name of the validating webhook configuration to annotate.</para>
</callout>
</calloutlist>
<simpara>For example, use the following command to annotate the validating webhook configuration <literal>test1</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate validatingwebhookconfigurations test1 service.beta.openshift.io/inject-cabundle=true</programlisting>
</listitem>
<listitem>
<simpara>View the validating webhook configuration to ensure that the service CA bundle has been injected:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get validatingwebhookconfigurations &lt;validating_webhook_name&gt; -o yaml</programlisting>
<simpara>The CA bundle is displayed in the <literal>clientConfig.caBundle</literal> field of all webhooks in the YAML output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  annotations:
    service.beta.openshift.io/inject-cabundle: "true"
...
webhooks:
- myWebhook:
  - v1beta1
  clientConfig:
    caBundle: &lt;CA_BUNDLE&gt;
...</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="rotate-service-serving_service-serving-certificate">
<title>Manually rotate the generated service certificate</title>
<simpara>You can rotate the service certificate by deleting the
associated secret. Deleting the secret results in a new one
being automatically created, resulting in a new certificate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A secret containing the certificate and key pair must
have been generated for the service.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Examine the service to determine the secret containing the
certificate. This is found in the <literal>serving-cert-secret-name</literal>
annotation, as seen below.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe service &lt;service_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
service.beta.openshift.io/serving-cert-secret-name: &lt;secret&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the generated secret for the service. This process
will automatically recreate the secret.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret &lt;secret&gt; <co xml:id="CO18-1"/></programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Replace <literal>&lt;secret&gt;</literal> with the name of the secret from the previous
step.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Confirm that the certificate has been recreated
by obtaining the new secret and examining the <literal>AGE</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;service_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              TYPE                DATA   AGE
&lt;service.name&gt;    kubernetes.io/tls   2      1s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="manually-rotate-service-ca_service-serving-certificate">
<title>Manually rotate the service CA certificate</title>
<simpara>The service CA is valid for 26 months and is automatically refreshed when there is less than 13 months validity left.</simpara>
<simpara>If necessary, you can manually refresh the service CA by using the following procedure.</simpara>
<warning>
<simpara>A manually-rotated service CA does not maintain trust with the previous service CA. You might experience a temporary service disruption until the pods in the cluster are restarted, which ensures that pods are using service serving certificates issued by the new service CA.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must be logged in as a cluster admin.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the expiration date of the current service CA certificate by
using the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secrets/signing-key -n openshift-service-ca \
     -o template='{{index .data "tls.crt"}}' \
     | base64 --decode \
     | openssl x509 -noout -enddate</programlisting>
</listitem>
<listitem>
<simpara>Manually rotate the service CA. This process generates a new service CA
which will be used to sign the new service certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret/signing-key -n openshift-service-ca</programlisting>
</listitem>
<listitem>
<simpara>To apply the new certificates to all services, restart all the pods
in your cluster. This command ensures that all services use the
updated certificates.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ for I in $(oc get ns -o jsonpath='{range .items[*]} {.metadata.name}{"\n"} {end}'); \
      do oc delete pods --all -n $I; \
      sleep 1; \
      done</programlisting>
<warning>
<simpara>This command will cause a service interruption, as it goes through and
deletes every running pod in every namespace. These pods will automatically
restart after they are deleted.</simpara>
</warning>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="updating-ca-bundle">
<title>Updating the CA bundle</title>

<section xml:id="ca-bundle-understanding_updating-ca-bundle">
<title>Understanding the CA Bundle certificate</title>
<simpara>Proxy certificates allow users to specify one or more custom certificate authority (CA) used by platform components when making egress connections.</simpara>
<simpara>The <literal>trustedCA</literal> field of the Proxy object is a reference to a config map that contains a user-provided trusted certificate authority (CA) bundle. This bundle is merged with the Red Hat Enterprise Linux CoreOS (RHCOS) trust bundle and injected into the trust store of platform components that make egress HTTPS calls. For example, <literal>image-registry-operator</literal> calls an external image registry to download images. If <literal>trustedCA</literal> is not specified, only the RHCOS trust bundle is used for proxied HTTPS connections. Provide custom CA certificates to the RHCOS trust bundle if you want to use your own certificate infrastructure.</simpara>
<simpara>The <literal>trustedCA</literal> field should only be consumed by a proxy validator. The validator is responsible for reading the certificate bundle from required key <literal>ca-bundle.crt</literal> and copying it to a config map named <literal>trusted-ca-bundle</literal> in the <literal>openshift-config-managed</literal> namespace. The namespace for the config map referenced by <literal>trustedCA</literal> is <literal>openshift-config</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: user-ca-bundle
  namespace: openshift-config
data:
  ca-bundle.crt: |
    -----BEGIN CERTIFICATE-----
    Custom CA certificate bundle.
    -----END CERTIFICATE-----</programlisting>
</section>
<section xml:id="ca-bundle-replacing_updating-ca-bundle">
<title>Replacing the CA Bundle certificate</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a config map that includes the root CA certificate used to sign the wildcard certificate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap custom-ca \
     --from-file=ca-bundle.crt=&lt;/path/to/example-ca.crt&gt; \<co xml:id="CO19-1"/>
     -n openshift-config</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para><literal>&lt;/path/to/example-ca.crt&gt;</literal> is the path to the CA certificate bundle on your local file system.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the cluster-wide proxy configuration with the newly created config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch proxy/cluster \
     --type=merge \
     --patch='{"spec":{"trustedCA":{"name":"custom-ca"}}}'</programlisting>
</listitem>
</orderedlist>
<bridgehead xml:id="_additional_resources_2" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/certificates/replacing-default-ingress-certificate.xml#replacing-default-ingress_replacing-default-ingress">Replacing the default ingress certificate</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../networking/enable-cluster-wide-proxy.xml#nw-proxy-configure-object_config-cluster-wide-proxy">Enabling the cluster-wide proxy</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificate_types_descriptions/proxy-certificates.xml#customization">Proxy certificate customization</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_certificate_types_and_descriptions">
<title>Certificate types and descriptions</title>
<section xml:id="cert-types-user-provided-certificates-for-the-api-server">
<title>User-provided certificates for the API server</title>

<section xml:id="_purpose">
<title>Purpose</title>
<simpara>The API server is accessible by clients external to the cluster at <literal>api.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal>. You might want clients to access the API server at a different hostname or without the need to distribute the cluster-managed certificate authority (CA) certificates to the clients. The administrator must set a custom default certificate to be used by the API server when serving content.</simpara>
</section>
<section xml:id="_location">
<title>Location</title>
<simpara>The user-provided certificates must be provided in a <literal>kubernetes.io/tls</literal> type <literal>Secret</literal> in the <literal>openshift-config</literal> namespace. Update the API server cluster configuration, the <literal>apiserver/cluster</literal> resource, to enable the use of the user-provided certificate.</simpara>
</section>
<section xml:id="_management">
<title>Management</title>
<simpara>User-provided certificates are managed by the user.</simpara>
</section>
<section xml:id="_expiration">
<title>Expiration</title>
<simpara>API server client certificate expiration is less than five minutes.</simpara>
<simpara>User-provided certificates are managed by the user.</simpara>
</section>
<section xml:id="_customization">
<title>Customization</title>
<simpara>Update the secret containing the user-managed certificate as needed.</simpara>
<bridgehead xml:id="_additional_resources_3" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/certificates/api-server.xml#api-server-certificates">Adding API server certificates</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-types-proxy-certificates">
<title>Proxy certificates</title>

<section xml:id="_purpose_2">
<title>Purpose</title>
<simpara>Proxy certificates allow users to specify one or more custom certificate authority (CA) certificates used by platform components when making egress connections.</simpara>
<simpara>The <literal>trustedCA</literal> field of the Proxy object is a reference to a config map that contains a user-provided trusted certificate authority (CA) bundle. This bundle is merged with the Red Hat Enterprise Linux CoreOS (RHCOS) trust bundle and injected into the trust store of platform components that make egress HTTPS calls. For example, <literal>image-registry-operator</literal> calls an external image registry to download images. If <literal>trustedCA</literal> is not specified, only the RHCOS trust bundle is used for proxied HTTPS connections. Provide custom CA certificates to the RHCOS trust bundle if you want to use your own certificate infrastructure.</simpara>
<simpara>The <literal>trustedCA</literal> field should only be consumed by a proxy validator. The validator is responsible for reading the certificate bundle from required key <literal>ca-bundle.crt</literal> and copying it to a config map named <literal>trusted-ca-bundle</literal> in the <literal>openshift-config-managed</literal> namespace. The namespace for the config map referenced by <literal>trustedCA</literal> is <literal>openshift-config</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: user-ca-bundle
  namespace: openshift-config
data:
  ca-bundle.crt: |
    -----BEGIN CERTIFICATE-----
    Custom CA certificate bundle.
    -----END CERTIFICATE-----</programlisting>
<bridgehead xml:id="_additional_resources_4" role="_additional-resources" renderas="sect4">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">Configuring the cluster-wide proxy</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_managing_proxy_certificates_during_installation">
<title>Managing proxy certificates during installation</title>
<simpara>The <literal>additionalTrustBundle</literal> value of the installer configuration is used to specify any proxy-trusted CA certificates during installation. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat install-config.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
proxy:
  httpProxy: http://&lt;https://username:password@proxy.example.com:123/&gt;
  httpsProxy: https://&lt;https://username:password@proxy.example.com:123/&gt;
	noProxy: &lt;123.example.com,10.88.0.0/16&gt;
additionalTrustBundle: |
    -----BEGIN CERTIFICATE-----
   &lt;MY_HTTPS_PROXY_TRUSTED_CA_CERT&gt;
    -----END CERTIFICATE-----
...</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_location_2">
<title>Location</title>
<simpara>The user-provided trust bundle is represented as a config map. The config map is mounted into the file system of platform components that make egress HTTPS calls. Typically, Operators mount the config map to <literal>/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem</literal>, but this is not required by the proxy. A proxy can modify or inspect the HTTPS connection. In either case, the proxy must generate and sign a new certificate for the connection.</simpara>
<simpara>Complete proxy support means connecting to the specified proxy and trusting any signatures it has generated. Therefore, it is necessary to let the user specify a trusted root, such that any certificate chain connected to that trusted root is also trusted.</simpara>
<simpara>If using the RHCOS trust bundle, place CA certificates in <literal>/etc/pki/ca-trust/source/anchors</literal>.</simpara>
<simpara>See <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/using-shared-system-certificates_security-hardening">Using shared system certificates</link> in the Red Hat Enterprise Linux documentation for more information.</simpara>
</section>
<section xml:id="_expiration_2">
<title>Expiration</title>
<simpara>The user sets the expiration term of the user-provided trust bundle.</simpara>
<simpara>The default expiration term is defined by the CA certificate itself. It is up to the CA administrator to configure this for the certificate before it can be used by OpenShift Container Platform or RHCOS.</simpara>
<note>
<simpara>Red Hat does not monitor for when CAs expire. However, due to the long life of CAs, this is generally not an issue. However, you might need to periodically update the trust bundle.</simpara>
</note>
</section>
<section xml:id="_services">
<title>Services</title>
<simpara>By default, all platform components that make egress HTTPS calls will use the RHCOS trust bundle. If <literal>trustedCA</literal> is defined, it will also be used.</simpara>
<simpara>Any service that is running on the RHCOS node is able to use the trust bundle of the node.</simpara>
</section>
<section xml:id="_management_2">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
</section>
<section xml:id="_customization_2">
<title>Customization</title>
<simpara>Updating the user-provided trust bundle consists of either:</simpara>
<itemizedlist>
<listitem>
<simpara>updating the PEM-encoded certificates in the config map referenced by <literal>trustedCA,</literal> or</simpara>
</listitem>
<listitem>
<simpara>creating a config map in the namespace <literal>openshift-config</literal> that contains the new trust bundle and updating <literal>trustedCA</literal> to reference the name of the new config map.</simpara>
</listitem>
</itemizedlist>
<simpara>The mechanism for writing CA certificates to the RHCOS trust bundle is exactly the same as writing any other file to RHCOS, which is done through the use of machine configs. When the Machine Config Operator (MCO) applies the new machine config that contains the new CA certificates, the node is rebooted. During the next boot, the service <literal>coreos-update-ca-trust.service</literal> runs on the RHCOS nodes, which automatically update the trust bundle with the new CA certificates. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 50-examplecorp-ca-cert
spec:
  config:
    ignition:
      version: 3.1.0
    storage:
      files:
      - contents:
          source: data:text/plain;charset=utf-8;base64,LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUVORENDQXh5Z0F3SUJBZ0lKQU51bkkwRDY2MmNuTUEwR0NTcUdTSWIzRFFFQkN3VUFNSUdsTVFzd0NRWUQKV1FRR0V3SlZVekVYTUJVR0ExVUVDQXdPVG05eWRHZ2dRMkZ5YjJ4cGJtRXhFREFPQmdOVkJBY01CMUpoYkdWcApBMmd4RmpBVUJnTlZCQW9NRFZKbFpDQklZWFFzSUVsdVl5NHhFekFSQmdOVkJBc01DbEpsWkNCSVlYUWdTVlF4Ckh6QVpCZ05WQkFNTUVsSmxaQ0JJWVhRZ1NWUWdVbTl2ZENCRFFURWhNQjhHQ1NxR1NJYjNEUUVKQVJZU2FXNW0KWGpDQnBURUxNQWtHQTFVRUJoTUNWVk14RnpBVkJnTlZCQWdNRGs1dmNuUm9JRU5oY205c2FXNWhNUkF3RGdZRApXUVFIREFkU1lXeGxhV2RvTVJZd0ZBWURWUVFLREExU1pXUWdTR0YwTENCSmJtTXVNUk13RVFZRFZRUUxEQXBTCkFXUWdTR0YwSUVsVU1Sc3dHUVlEVlFRRERCSlNaV1FnU0dGMElFbFVJRkp2YjNRZ1EwRXhJVEFmQmdrcWhraUcKMHcwQkNRRVdFbWx1Wm05elpXTkFjbVZrYUdGMExtTnZiVENDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUApCRENDQVFvQ2dnRUJBTFF0OU9KUWg2R0M1TFQxZzgwcU5oMHU1MEJRNHNaL3laOGFFVHh0KzVsblBWWDZNSEt6CmQvaTdsRHFUZlRjZkxMMm55VUJkMmZRRGsxQjBmeHJza2hHSUlaM2lmUDFQczRsdFRrdjhoUlNvYjNWdE5xU28KSHhrS2Z2RDJQS2pUUHhEUFdZeXJ1eTlpckxaaW9NZmZpM2kvZ0N1dDBaV3RBeU8zTVZINXFXRi9lbkt3Z1BFUwpZOXBvK1RkQ3ZSQi9SVU9iQmFNNzYxRWNyTFNNMUdxSE51ZVNmcW5obzNBakxRNmRCblBXbG82MzhabTFWZWJLCkNFTHloa0xXTVNGa0t3RG1uZTBqUTAyWTRnMDc1dkNLdkNzQ0F3RUFBYU5qTUdFd0hRWURWUjBPQkJZRUZIN1IKNXlDK1VlaElJUGV1TDhacXczUHpiZ2NaTUI4R0ExVWRJd1FZTUJhQUZIN1I0eUMrVWVoSUlQZXVMOFpxdzNQegpjZ2NaTUE4R0ExVWRFd0VCL3dRRk1BTUJBZjh3RGdZRFZSMFBBUUgvQkFRREFnR0dNQTBHQ1NxR1NJYjNEUUVCCkR3VUFBNElCQVFCRE52RDJWbTlzQTVBOUFsT0pSOCtlbjVYejloWGN4SkI1cGh4Y1pROGpGb0cwNFZzaHZkMGUKTUVuVXJNY2ZGZ0laNG5qTUtUUUNNNFpGVVBBaWV5THg0ZjUySHVEb3BwM2U1SnlJTWZXK0tGY05JcEt3Q3NhawpwU29LdElVT3NVSks3cUJWWnhjckl5ZVFWMnFjWU9lWmh0UzV3QnFJd09BaEZ3bENFVDdaZTU4UUhtUzQ4c2xqCjVlVGtSaml2QWxFeHJGektjbGpDNGF4S1Fsbk92VkF6eitHbTMyVTB4UEJGNEJ5ZVBWeENKVUh3MVRzeVRtZWwKU3hORXA3eUhvWGN3bitmWG5hK3Q1SldoMWd4VVp0eTMKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
        mode: 0644
        overwrite: true
        path: /etc/pki/ca-trust/source/anchors/examplecorp-ca.crt</programlisting>
<simpara>The trust store of machines must also support updating the trust store of nodes.</simpara>
</section>
<section xml:id="_renewal">
<title>Renewal</title>
<simpara>There are no Operators that can auto-renew certificates on the RHCOS nodes.</simpara>
<note>
<simpara>Red Hat does not monitor for when CAs expire. However, due to the long life of CAs, this is generally not an issue. However, you might need to periodically update the trust bundle.</simpara>
</note>
</section>
</section>
<section xml:id="cert-types-service-ca-certificates">
<title>Service CA certificates</title>

<section xml:id="_purpose_3">
<title>Purpose</title>
<simpara><literal>service-ca</literal> is an Operator that creates a self-signed CA when an OpenShift Container Platform cluster is deployed.</simpara>
</section>
<section xml:id="_expiration_3">
<title>Expiration</title>
<simpara>A custom expiration term is not supported. The self-signed CA is stored in a secret with qualified name <literal>service-ca/signing-key</literal> in fields <literal>tls.crt</literal> (certificate(s)), <literal>tls.key</literal> (private key), and <literal>ca-bundle.crt</literal> (CA bundle).</simpara>
<simpara>Other services can request a service serving certificate by annotating a service resource with <literal>service.beta.openshift.io/serving-cert-secret-name: &lt;secret name&gt;</literal>. In response, the Operator generates a new certificate, as <literal>tls.crt</literal>, and private key, as <literal>tls.key</literal> to the named secret. The certificate is valid for two years.</simpara>
<simpara>Other services can request that the CA bundle for the service CA be injected into API service or config map resources by annotating with <literal>service.beta.openshift.io/inject-cabundle: true</literal> to support validating certificates generated from the service CA. In response, the Operator writes its current CA bundle to the <literal>CABundle</literal> field of an API service or as <literal>service-ca.crt</literal> to a config map.</simpara>
<simpara>As of OpenShift Container Platform 4.3.5, automated rotation is supported and is backported to some 4.2.z and 4.3.z releases. For any release supporting automated rotation, the service CA is valid for 26 months and is automatically refreshed when there is less than 13 months validity left. If necessary, you can manually refresh the service CA.</simpara>
<simpara>The service CA expiration of 26 months is longer than the expected upgrade interval for a supported OpenShift Container Platform cluster, such that non-control plane consumers of service CA certificates will be refreshed after CA rotation and prior to the expiration of the pre-rotation CA.</simpara>
<warning>
<simpara>A manually-rotated service CA does not maintain trust with the previous service CA. You might experience a temporary service disruption until the pods in the cluster are restarted, which ensures that pods are using service serving certificates issued by the new service CA.</simpara>
</warning>
</section>
<section xml:id="_management_3">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
</section>
<section xml:id="_services_2">
<title>Services</title>
<simpara>Services that use service CA certificates include:</simpara>
<itemizedlist>
<listitem>
<simpara>cluster-autoscaler-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-monitoring-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-authentication-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-image-registry-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-ingress-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-kube-apiserver-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-kube-controller-manager-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-kube-scheduler-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-networking-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-openshift-apiserver-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-openshift-controller-manager-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-samples-operator</simpara>
</listitem>
<listitem>
<simpara>cluster-storage-operator</simpara>
</listitem>
<listitem>
<simpara>machine-config-operator</simpara>
</listitem>
<listitem>
<simpara>console-operator</simpara>
</listitem>
<listitem>
<simpara>insights-operator</simpara>
</listitem>
<listitem>
<simpara>machine-api-operator</simpara>
</listitem>
<listitem>
<simpara>operator-lifecycle-manager</simpara>
</listitem>
<listitem>
<simpara>CSI driver operators</simpara>
</listitem>
</itemizedlist>
<simpara>This is not a comprehensive list.</simpara>
<bridgehead xml:id="_additional_resources_5" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/certificates/service-serving-certificate.xml#add-service-serving">Manually rotate service serving certificates</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificates/service-serving-certificate.xml#add-service-serving">Securing service traffic using service serving certificate secrets</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-types-node-certificates">
<title>Node certificates</title>

<section xml:id="_purpose_4">
<title>Purpose</title>
<simpara>Node certificates are signed by the cluster; they come from a certificate authority (CA) that is generated by the bootstrap process. After the cluster is installed, the node certificates are auto-rotated.</simpara>
</section>
<section xml:id="_management_4">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
<bridgehead xml:id="_additional_resources_6" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working">Working with nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-types-bootstrap-certificates">
<title>Bootstrap certificates</title>

<section xml:id="_purpose_5">
<title>Purpose</title>
<simpara>The kubelet, in OpenShift Container Platform 4 and later, uses the bootstrap certificate located in <literal>/etc/kubernetes/kubeconfig</literal> to initially bootstrap. This is followed by the <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#bootstrap-initialization">bootstrap initialization process</link> and <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#authorize-kubelet-to-create-csr">authorization of the kubelet to create a CSR</link>.</simpara>
<simpara>In that process, the kubelet generates a CSR while communicating over the bootstrap channel. The controller manager signs the CSR, resulting in a certificate that the kubelet manages.</simpara>
</section>
<section xml:id="_management_5">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
</section>
<section xml:id="_expiration_4">
<title>Expiration</title>
<simpara>This bootstrap certificate is valid for 10 years.</simpara>
<simpara>The kubelet-managed certificate is valid for one year and rotates automatically at around the 80 percent mark of that one year.</simpara>
<note>
<simpara>OpenShift Lifecycle Manager (OLM) does not update the bootstrap certificate.</simpara>
</note>
</section>
<section xml:id="_customization_3">
<title>Customization</title>
<simpara>You cannot customize the bootstrap certificates.</simpara>
</section>
</section>
<section xml:id="cert-types-etcd-certificates">
<title>etcd certificates</title>

<section xml:id="_purpose_6">
<title>Purpose</title>
<simpara>etcd certificates are signed by the etcd-signer; they come from a certificate authority (CA) that is generated by the bootstrap process.</simpara>
</section>
<section xml:id="_expiration_5">
<title>Expiration</title>
<simpara>The CA certificates are valid for 10 years. The peer, client, and server certificates are valid for three years.</simpara>
</section>
<section xml:id="_management_6">
<title>Management</title>
<simpara>These certificates are only managed by the system and are automatically rotated.</simpara>
</section>
<section xml:id="_services_3">
<title>Services</title>
<simpara>etcd certificates are used for encrypted communication between etcd member peers, as well as encrypted client traffic. The following certificates are generated and used by etcd and other processes that communicate with etcd:</simpara>
<itemizedlist>
<listitem>
<simpara>Peer certificates: Used for communication between etcd members.</simpara>
</listitem>
<listitem>
<simpara>Client certificates: Used for encrypted server-client communication. Client certificates are currently used by the API server only, and no other service should connect to etcd directly except for the proxy. Client secrets (<literal>etcd-client</literal>, <literal>etcd-metric-client</literal>, <literal>etcd-metric-signer</literal>, and <literal>etcd-signer</literal>) are added to the <literal>openshift-config</literal>, <literal>openshift-monitoring</literal>, and <literal>openshift-kube-apiserver</literal> namespaces.</simpara>
</listitem>
<listitem>
<simpara>Server certificates: Used by the etcd server for authenticating client requests.</simpara>
</listitem>
<listitem>
<simpara>Metric certificates: All metric consumers connect to proxy with metric-client certificates.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_additional_resources_7" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../backup_and_restore/control_plane_backup_and_restore/disaster_recovery/scenario-2-restoring-cluster-state.xml#dr-restoring-cluster-state">Restoring to a previous cluster state</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-types-olm-certificates">
<title>OLM certificates</title>

<section xml:id="_management_7">
<title>Management</title>
<simpara>All certificates for OpenShift Lifecycle Manager (OLM) components (<literal>olm-operator</literal>, <literal>catalog-operator</literal>, <literal>packageserver</literal>, and <literal>marketplace-operator</literal>) are managed by the system.</simpara>
<simpara>When installing Operators that include webhooks or API services in their <literal>ClusterServiceVersion</literal> (CSV) object, OLM creates and rotates the certificates for these resources. Certificates for resources in the <literal>openshift-operator-lifecycle-manager</literal> namespace are managed by OLM.</simpara>
<simpara>OLM will not update the certificates of Operators that it manages in proxy environments. These certificates must be managed by the user using the subscription config.</simpara>
</section>
</section>
<section xml:id="cert-types-aggregated-api-client-certificates">
<title>Aggregated API client certificates</title>

<section xml:id="_purpose_7">
<title>Purpose</title>
<simpara>Aggregated API client certificates are used to authenticate the KubeAPIServer when connecting to the Aggregated API Servers.</simpara>
</section>
<section xml:id="_management_8">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
</section>
<section xml:id="_expiration_6">
<title>Expiration</title>
<simpara>This CA is valid for 30 days.</simpara>
<simpara>The managed client certificates are valid for 30 days.</simpara>
<simpara>CA and client certificates are rotated automatically through the use of controllers.</simpara>
</section>
<section xml:id="_customization_4">
<title>Customization</title>
<simpara>You cannot customize the aggregated API server certificates.</simpara>
</section>
</section>
<section xml:id="cert-types-machine-config-operator-certificates">
<title>Machine Config Operator certificates</title>

<section xml:id="_purpose_8">
<title>Purpose</title>
<simpara>This certificate authority is used to secure connections from nodes to Machine Config Server (MCS) during initial provisioning.</simpara>
<simpara>There are two certificates:
. A self-signed CA, the MCS CA
. A derived certificate, the MCS cert</simpara>
<section xml:id="_provisioning_details">
<title>Provisioning details</title>
<simpara>OpenShift Container Platform installations that use Red Hat Enterprise Linux CoreOS (RHCOS) are installed by using Ignition. This process is split into two parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>An Ignition config is created that references a URL for the full configuration served by the MCS.</simpara>
</listitem>
<listitem>
<simpara>For user-provisioned infrastucture installation methods, the Ignition config manifests as a <literal>worker.ign</literal> file created by the <literal>openshift-install</literal> command. For installer-provisioned infrastructure installation methods that use the Machine API Operator, this configuration appears as the <literal>worker-user-data</literal> secret.</simpara>
</listitem>
</orderedlist>
<important>
<simpara>Currently, there is no supported way to block or restrict the machine config server endpoint. The machine config server must be exposed to the network so that newly-provisioned machines, which have no existing configuration or state, are able to fetch their configuration. In this model, the root of trust is the certificate signing requests (CSR) endpoint, which is where the kubelet sends its certificate signing request for approval to join the cluster. Because of this, machine configs should not be used to distribute sensitive information, such as secrets and certificates.</simpara>
<simpara>To ensure that the machine config server endpoints, ports 22623 and 22624, are secured in bare metal scenarios, customers must configure proper network policies.</simpara>
</important>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../post_installation_configuration/machine-configuration-tasks.xml#understanding-the-machine-config-operator">Understanding the Machine Config Operator</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../networking/openshift_sdn/about-openshift-sdn.xml#about-openshift-sdn">About the OpenShift SDN network plugin</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_provisioning_chain_of_trust">
<title>Provisioning chain of trust</title>
<simpara>The MCS CA is injected into the Ignition configuration under the <literal>security.tls.certificateAuthorities</literal> configuration field. The MCS then provides the complete configuration using the MCS cert presented by the web server.</simpara>
<simpara>The client validates that the MCS cert presented by the server has a chain of trust to an authority it recognizes. In this case, the MCS CA is that authority, and it signs the MCS cert. This ensures that the client is accessing the correct server. The client in this case is Ignition running on a machine in the initramfs.</simpara>
</section>
<section xml:id="_key_material_inside_a_cluster">
<title>Key material inside a cluster</title>
<simpara>The MCS CA appears in the cluster as a config map in the <literal>kube-system</literal> namespace, <literal>root-ca</literal> object, with <literal>ca.crt</literal> key.  The private key is not stored in the cluster and is discarded after the installation completes.</simpara>
<simpara>The MCS cert appears in the cluster as a secret in the <literal>openshift-machine-config-operator</literal> namespace and <literal>machine-config-server-tls</literal> object with the <literal>tls.crt</literal> and <literal>tls.key</literal> keys.</simpara>
</section>
</section>
<section xml:id="_management_9">
<title>Management</title>
<simpara>At this time, directly modifying either of these certificates is not supported.</simpara>
</section>
<section xml:id="_expiration_7">
<title>Expiration</title>
<simpara>The MCS CA is valid for 10 years.</simpara>
<simpara>The issued serving certificates are valid for 10 years.</simpara>
</section>
<section xml:id="_customization_5">
<title>Customization</title>
<simpara>You cannot customize the Machine Config Operator certificates.</simpara>
</section>
</section>
<section xml:id="cert-types-user-provided-certificates-for-default-ingress">
<title>User-provided certificates for default ingress</title>

<section xml:id="_purpose_9">
<title>Purpose</title>
<simpara>Applications are usually exposed at <literal>&lt;route_name&gt;.apps.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal>. The <literal>&lt;cluster_name&gt;</literal> and <literal>&lt;base_domain&gt;</literal> come from the installation config file. <literal>&lt;route_name&gt;</literal> is the host field of the route, if specified, or the route name. For example, <literal>hello-openshift-default.apps.username.devcluster.openshift.com</literal>. <literal>hello-openshift</literal> is the name of the route and the route is in the default namespace. You might want clients to access the applications without the need to distribute the cluster-managed CA certificates to the clients. The administrator must set a custom default certificate when serving application content.</simpara>
<warning>
<simpara>The Ingress Operator generates a default certificate for an Ingress Controller to serve as a placeholder until you configure a custom default certificate. Do not use operator-generated default certificates in production clusters.</simpara>
</warning>
</section>
<section xml:id="_location_3">
<title>Location</title>
<simpara>The user-provided certificates must be provided in a <literal>tls</literal> type <literal>Secret</literal> resource in the <literal>openshift-ingress</literal> namespace. Update the <literal>IngressController</literal> CR in the <literal>openshift-ingress-operator</literal> namespace to enable the use of the user-provided certificate. For more information on this process, see <link xlink:href="../../networking/ingress-operator.xml#nw-ingress-setting-a-custom-default-certificate_configuring-ingress">Setting a custom default certificate</link>.</simpara>
</section>
<section xml:id="_management_10">
<title>Management</title>
<simpara>User-provided certificates are managed by the user.</simpara>
</section>
<section xml:id="_expiration_8">
<title>Expiration</title>
<simpara>User-provided certificates are managed by the user.</simpara>
</section>
<section xml:id="_services_4">
<title>Services</title>
<simpara>Applications deployed on the cluster use user-provided certificates for default ingress.</simpara>
</section>
<section xml:id="_customization_6">
<title>Customization</title>
<simpara>Update the secret containing the user-managed certificate as needed.</simpara>
<bridgehead xml:id="_additional_resources_8" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/certificates/replacing-default-ingress-certificate.xml#replacing-default-ingress">Replacing the default ingress certificate</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-types-ingress-certificates">
<title>Ingress certificates</title>

<section xml:id="_purpose_10">
<title>Purpose</title>
<simpara>The Ingress Operator uses certificates for:</simpara>
<itemizedlist>
<listitem>
<simpara>Securing access to metrics for Prometheus.</simpara>
</listitem>
<listitem>
<simpara>Securing access to routes.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_location_4">
<title>Location</title>
<simpara>To secure access to Ingress Operator and Ingress Controller metrics, the Ingress Operator uses service serving certificates. The Operator requests a certificate from the <literal>service-ca</literal> controller for its own metrics, and the <literal>service-ca</literal> controller puts the certificate in a secret named <literal>metrics-tls</literal> in the <literal>openshift-ingress-operator</literal> namespace. Additionally, the Ingress Operator requests a certificate for each Ingress Controller, and the <literal>service-ca</literal> controller puts the certificate in a secret named <literal>router-metrics-certs-&lt;name&gt;</literal>, where <literal>&lt;name&gt;</literal> is the name of the Ingress Controller, in the <literal>openshift-ingress</literal> namespace.</simpara>
<simpara>Each Ingress Controller has a default certificate that it uses for secured routes that do not specify their own certificates. Unless you specify a custom certificate, the Operator uses a self-signed certificate by default. The Operator uses its own self-signed signing certificate to sign any default certificate that it generates. The Operator generates this signing certificate and puts it in a secret named <literal>router-ca</literal> in the <literal>openshift-ingress-operator</literal> namespace. When the Operator generates a default certificate, it puts the default certificate in a secret named <literal>router-certs-&lt;name&gt;</literal> (where <literal>&lt;name&gt;</literal> is the name of the Ingress Controller) in the <literal>openshift-ingress</literal> namespace.</simpara>
<warning>
<simpara>The Ingress Operator generates a default certificate for an Ingress Controller to serve as a placeholder until you configure a custom default certificate. Do not use Operator-generated default certificates in production clusters.</simpara>
</warning>
</section>
<section xml:id="_workflow">
<title>Workflow</title>
<figure>
<title>Custom certificate workflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/custom_4.5.svg"/>
</imageobject>
<textobject><phrase>custom ingress certificate workflow</phrase></textobject>
</mediaobject>
</figure>
<figure>
<title>Default certificate workflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/default_4.5.svg"/>
</imageobject>
<textobject><phrase>default ingress certificate workflow</phrase></textobject>
</mediaobject>
</figure>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-0.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> An empty <literal>defaultCertificate</literal> field causes the Ingress Operator to use its self-signed CA to generate a serving certificate for the specified domain.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-1.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The default CA certificate and key generated by the Ingress Operator. Used to sign Operator-generated default serving certificates.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-2.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> In the default workflow, the wildcard default serving certificate, created by the Ingress Operator and signed using the generated default CA certificate. In the custom workflow, this is the user-provided certificate.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-3.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The router deployment. Uses the certificate in <literal>secrets/router-certs-default</literal> as its default front-end server certificate.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-4.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> In the default workflow, the contents of the wildcard default serving certificate (public and private parts) are copied here to enable OAuth integration. In the custom workflow, this is the user-provided certificate.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-5.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The public (certificate) part of the default serving certificate. Replaces the <literal>configmaps/router-ca</literal> resource.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-6.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The user updates the cluster proxy configuration with the CA certificate that signed the <literal>ingresscontroller</literal> serving certificate. This enables components like <literal>auth</literal>, <literal>console</literal>, and the registry to trust the serving certificate.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-7.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The cluster-wide trusted CA bundle containing the combined Red Hat Enterprise Linux CoreOS (RHCOS) and user-provided CA bundles or an RHCOS-only bundle if a user bundle is not provided.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-8.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The custom CA certificate bundle, which instructs other components (for example, <literal>auth</literal> and <literal>console</literal>) to trust an <literal>ingresscontroller</literal> configured with a custom certificate.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-9.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The <literal>trustedCA</literal> field is used to reference the user-provided CA bundle.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-10.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> The Cluster Network Operator injects the trusted CA bundle into the <literal>proxy-ca</literal> config map.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/darkcircle-11.png" contentwidth="20"/>
</imageobject>
<textobject><phrase>20</phrase></textobject>
</inlinemediaobject> OpenShift Container Platform 4.14 and newer use <literal>default-ingress-cert</literal>.</simpara>
</section>
<section xml:id="_expiration_9">
<title>Expiration</title>
<simpara>The expiration terms for the Ingress Operator&#8217;s certificates are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>The expiration date for metrics certificates that the <literal>service-ca</literal> controller creates is two years after the date of creation.</simpara>
</listitem>
<listitem>
<simpara>The expiration date for the Operator&#8217;s signing certificate is two years after the date of creation.</simpara>
</listitem>
<listitem>
<simpara>The expiration date for default certificates that the Operator generates is two years after the date of creation.</simpara>
</listitem>
</itemizedlist>
<simpara>You cannot specify custom expiration terms on certificates that the Ingress Operator or <literal>service-ca</literal> controller creates.</simpara>
<simpara>You cannot specify expiration terms when installing OpenShift Container Platform for certificates that the Ingress Operator or <literal>service-ca</literal> controller creates.</simpara>
</section>
<section xml:id="_services_5">
<title>Services</title>
<simpara>Prometheus uses the certificates that secure metrics.</simpara>
<simpara>The Ingress Operator uses its signing certificate to sign default certificates that it generates for Ingress Controllers for which you do not set custom default certificates.</simpara>
<simpara>Cluster components that use secured routes may use the default Ingress Controller&#8217;s default certificate.</simpara>
<simpara>Ingress to the cluster via a secured route uses the default certificate of the Ingress Controller by which the route is accessed unless the route specifies its own certificate.</simpara>
</section>
<section xml:id="_management_11">
<title>Management</title>
<simpara>Ingress certificates are managed by the user. See <link xlink:href="../../security/certificates/replacing-default-ingress-certificate.xml#replacing-default-ingress">Replacing the default ingress certificate</link> for more information.</simpara>
</section>
<section xml:id="_renewal_2">
<title>Renewal</title>
<simpara>The <literal>service-ca</literal> controller automatically rotates the certificates that it issues. However, it is possible to use <literal>oc delete secret &lt;secret&gt;</literal> to manually rotate service serving certificates.</simpara>
<simpara>The Ingress Operator does not rotate its own signing certificate or the default certificates that it generates. Operator-generated default certificates are intended as placeholders for custom default certificates that you configure.</simpara>
</section>
</section>
<section xml:id="cert-types-monitoring-and-cluster-logging-operator-component-certificates">
<title>Monitoring and OpenShift Logging Operator component certificates</title>

<section xml:id="_expiration_10">
<title>Expiration</title>
<simpara>Monitoring components secure their traffic with service CA certificates. These certificates are valid for 2 years and are replaced automatically on rotation of the service CA, which is every 13 months.</simpara>
<simpara>If the certificate lives in the <literal>openshift-monitoring</literal> or <literal>openshift-logging</literal> namespace, it is system managed and rotated automatically.</simpara>
</section>
<section xml:id="_management_12">
<title>Management</title>
<simpara>These certificates are managed by the system and not the user.</simpara>
</section>
</section>
<section xml:id="cert-types-control-plane-certificates">
<title>Control plane certificates</title>

<section xml:id="_location_5">
<title>Location</title>
<simpara>Control plane certificates are included in these namespaces:</simpara>
<itemizedlist>
<listitem>
<simpara>openshift-config-managed</simpara>
</listitem>
<listitem>
<simpara>openshift-kube-apiserver</simpara>
</listitem>
<listitem>
<simpara>openshift-kube-apiserver-operator</simpara>
</listitem>
<listitem>
<simpara>openshift-kube-controller-manager</simpara>
</listitem>
<listitem>
<simpara>openshift-kube-controller-manager-operator</simpara>
</listitem>
<listitem>
<simpara>openshift-kube-scheduler</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_management_13">
<title>Management</title>
<simpara>Control plane certificates are managed by the system and rotated automatically.</simpara>
<simpara>In the rare case that your control plane certificates have expired, see <link xlink:href="../../backup_and_restore/control_plane_backup_and_restore/disaster_recovery/scenario-3-expired-certs.xml#dr-recovering-expired-certs">Recovering from expired control plane certificates</link>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_compliance_operator">
<title>Compliance Operator</title>
<section xml:id="co-overview">
<title>Compliance Operator overview</title>
<simpara>OpenShift Container Platform Compliance Operator (CO) runs compliance scans and provides remediations to assist users in meeting compliance standards. For the latest updates, see the <link xlink:href="../../security/compliance_operator/compliance-operator-release-notes.xml#compliance-operator-release-notes">Compliance Operator release notes</link>. If needed, you can engage <link xlink:href="https://access.redhat.com/support/">Red Hat support</link>.</simpara>
<important>
<simpara>The Compliance Operator does not automatically perform remediations. Ensuring compliance standards are met is required by the user.</simpara>
</important>
<bridgehead xml:id="_compliance_operator_concepts" renderas="sect5">Compliance Operator concepts</bridgehead>
<simpara><link xlink:href="../../security/compliance_operator/co-concepts/compliance-operator-understanding.xml#compliance-operator-understanding">Understanding the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-concepts/compliance-operator-crd.xml#custom-resource-definitions">Understanding the Custom Resource Definitions</link></simpara>
<bridgehead xml:id="_compliance_operator_management" renderas="sect5">Compliance Operator management</bridgehead>
<simpara><link xlink:href="../../security/compliance_operator/co-management/compliance-operator-installation.xml#compliance-operator-installation">Installing the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-management/compliance-operator-updating.xml#compliance-operator-updating">Updating the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-management/compliance-operator-manage.xml#compliance-operator-understanding">Managing the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-management/compliance-operator-uninstallation.xml#compliance-operator-uninstallation">Uninstalling the Compliance Operator</link></simpara>
<bridgehead xml:id="_compliance_operator_scan_management" renderas="sect5">Compliance Operator scan management</bridgehead>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-supported-profiles.xml#compliance-operator-supported-profiles">Supported compliance profiles</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-scans.xml#compliance-operator-scans">Compliance Operator scans</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-tailor.xml#compliance-operator-tailor">Tailoring the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-raw-results.xml#compliance-operator-raw-results">Retrieving Compliance Operator raw results</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-remediation.xml#compliance-operator-remediation">Managing Compliance Operator remediation</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-advanced.xml#compliance-operator-advanced">Performing advanced Compliance Operator tasks</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-troubleshooting.xml#compliance-operator-troubleshooting">Troubleshooting the Compliance Operator</link></simpara>
<simpara><link xlink:href="../../security/compliance_operator/co-scans/oc-compliance-plug-in-using.xml#using-oc-compliance-plug-in">Using the oc-compliance plugin</link></simpara>
</section>
<section xml:id="compliance-operator-release-notes">
<title>Compliance Operator release notes</title>

<simpara>The Compliance Operator lets OpenShift Container Platform administrators describe the required compliance state of a cluster and provides them with an overview of gaps and ways to remediate them.</simpara>
<simpara>These release notes track the development of the Compliance Operator in the OpenShift Container Platform.</simpara>
<simpara>For an overview of the Compliance Operator, see <link xlink:href="../../security/compliance_operator/co-concepts/compliance-operator-understanding.xml#understanding-compliance-operator">Understanding the Compliance Operator</link>.</simpara>
<simpara>To access the latest release, see <link xlink:href="../../security/compliance_operator/co-management/compliance-operator-updating.xml#olm-preparing-upgrade_compliance-operator-updating">Updating the Compliance Operator</link>.</simpara>
<section xml:id="compliance-operator-release-notes-1-4-0">
<title>OpenShift Compliance Operator 1.4.0</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.4.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:7658">RHBA-2023:7658 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-1-4-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>With this update, clusters which use custom node pools outside the default <literal>worker</literal> and <literal>master</literal> node pools no longer need to supply additional variables to ensure Compliance Operator aggregates the configuration file for that node pool.</simpara>
</listitem>
<listitem>
<simpara>Users can now pause scan schedules by setting the <literal>ScanSetting.suspend</literal> attribute to <literal>True</literal>. This allows users to suspend a scan schedule and reactivate it without the need to delete and re-create the <literal>ScanSettingBinding</literal>. This simplifies pausing scan schedules during maintenance periods. (<link xlink:href="https://issues.redhat.com/browse/CMP-2123"><emphasis role="strong">CMP-2123</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Compliance Operator now supports an optional <literal>version</literal> attribute on <literal>Profile</literal> custom resources. (<link xlink:href="https://issues.redhat.com/browse/CMP-2125"><emphasis role="strong">CMP-2125</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Compliance Operator now supports profile names in <literal>ComplianceRules</literal>. (<link xlink:href="https://issues.redhat.com/browse/CMP-2126"><emphasis role="strong">CMP-2126</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Compliance Operator compatibility with improved <literal>cronjob</literal> API improvements is available in this release. (<link xlink:href="https://issues.redhat.com/browse/CMP-2310"><emphasis role="strong">CMP-2310</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-1-4-0-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, on a cluster with Windows nodes, some rules will FAIL after auto remediation is applied because the Windows nodes were not skipped by the compliance scan. With this release, Windows nodes are correctly skipped when scanning. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-7355"><emphasis role="strong">OCPBUGS-7355</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>With this update, <literal>rprivate</literal> default mount propagation is now handled correctly for root volume mounts of pods that rely on multipathing. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-17494"><emphasis role="strong">OCPBUGS-17494</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator would generate a remediation for <literal>coreos_vsyscall_kernel_argument</literal> without reconciling the rule even while applying the remediation. With release 1.4.0, the <literal>coreos_vsyscall_kernel_argument</literal> rule properly evaluates kernel arguments and generates an appropriate remediation.(<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-8041"><emphasis role="strong">OCPBUGS-8041</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, rule <literal>rhcos4-audit-rules-login-events-faillock</literal> would fail even after auto-remediation has been applied. With this update, <literal>rhcos4-audit-rules-login-events-faillock</literal> failure locks are now applied correctly after auto-remediation. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-24594"><emphasis role="strong">OCPBUGS-24594</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, upgrades from Compliance Operator 1.3.1 to Compliance Operator 1.4.0 would cause OVS rules scan results to go from <literal>PASS</literal> to <literal>NOT-APPLICABLE</literal>. With this update, OVS rules scan results now show <literal>PASS</literal> (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-25323"><emphasis role="strong">OCPBUGS-25323</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-1-3-1">
<title>OpenShift Compliance Operator 1.3.1</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.3.1:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:5669">RHBA-2023:5669 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<simpara>This update addresses a CVE in an underlying dependency.</simpara>
<section xml:id="compliance-operator-1-3-1-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>You can install and use the Compliance Operator in an OpenShift Container Platform cluster running in FIPS mode.</simpara>
<important>
<simpara>To enable FIPS mode for your cluster, you must run the installation program from a RHEL computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>.</simpara>
</important>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-1-3-1-known-issue">
<title>Known issue</title>
<itemizedlist>
<listitem>
<simpara>On a cluster with Windows nodes, some rules will FAIL after auto remediation is applied because the Windows nodes are not skipped by the compliance scan. This differs from the expected results because the Windows nodes must be skipped when scanning. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-7355"><emphasis role="strong">OCPBUGS-7355</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-1-3-0">
<title>OpenShift Compliance Operator 1.3.0</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.3.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:5102">RHBA-2023:5102 - OpenShift Compliance Operator enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-1-3-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Defense Information Systems Agency Security Technical Implementation Guide (DISA-STIG) for OpenShift Container Platform is now available from Compliance Operator 1.3.0. See <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-supported-profiles.xml#compliance-supported-profiles_compliance-operator-supported-profiles">Supported compliance profiles</link> for additional information.</simpara>
</listitem>
<listitem>
<simpara>Compliance Operator 1.3.0 now supports IBM Power&#174; and IBM Z&#174; for NIST 800-53 Moderate-Impact Baseline for OpenShift Container Platform platform and node profiles.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-1-2-0">
<title>OpenShift Compliance Operator 1.2.0</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.2.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:4245">RHBA-2023:4245 - OpenShift Compliance Operator enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-1-2-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The CIS OpenShift Container Platform 4 Benchmark v1.4.0 profile is now available for platform and node applications. To locate the CIS OpenShift Container Platform v4 Benchmark, go to  <link xlink:href="https://www.cisecurity.org/benchmark/kubernetes">CIS Benchmarks</link> and click <emphasis role="strong">Download Latest CIS Benchmark</emphasis>, where you can then register to download the benchmark.</simpara>
<important>
<simpara>Upgrading to Compliance Operator 1.2.0 will overwrite the CIS OpenShift Container Platform 4 Benchmark 1.1.0 profiles.</simpara>
<simpara>If your OpenShift Container Platform environment contains existing <literal>cis</literal> and <literal>cis-node</literal> remediations, there might be some differences in scan results after upgrading to Compliance Operator 1.2.0.</simpara>
</important>
</listitem>
<listitem>
<simpara>Additional clarity for auditing security context constraints (SCCs) is now available for the <literal>scc-limit-container-allowed-capabilities</literal> rule.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-1-1-0">
<title>OpenShift Compliance Operator 1.1.0</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.1.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:3630">RHBA-2023:3630 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-1-1-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>A start and end timestamp is now available in the <literal>ComplianceScan</literal> custom resource definition (CRD) status.</simpara>
</listitem>
<listitem>
<simpara>The Compliance Operator can now be deployed on Hosted Control Planes using the OperatorHub by creating a <literal>Subscription</literal> file. For more information, see <link xlink:href="../../security/compliance_operator/co-management/compliance-operator-installation.xml#installing-compliance-operator-hcp_compliance-operator-installation">Installing the Compliance Operator on Hosted Control Planes</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-1-1-0-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Before this update, some Compliance Operator rule instructions were not present. After this update, instructions are improved for the following rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>classification_banner</literal></simpara>
</listitem>
<listitem>
<simpara><literal>oauth_login_template_set</literal></simpara>
</listitem>
<listitem>
<simpara><literal>oauth_logout_url_set</literal></simpara>
</listitem>
<listitem>
<simpara><literal>oauth_provider_selection_set</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp_allowed_registries</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp_allowed_registries_for_import</literal></simpara>
<simpara>(<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-10473"><emphasis role="strong">OCPBUGS-10473</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Before this update, check accuracy and rule instructions were unclear. After this update, the check accuracy and instructions are improved for the following <literal>sysctl</literal> rules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-kernel-keys-root-maxbytes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-kernel-keys-root-maxkeys</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-kernel-panic</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-kernel-panic-on-oops</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-vm-overcommit-memory</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kubelet-enable-protect-kernel-sysctl-vm-panic-on-oom</literal></simpara>
<simpara>(<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-11334"><emphasis role="strong">OCPBUGS-11334</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Before this update, the <literal>ocp4-alert-receiver-configured</literal> rule did not include instructions. With this update, the <literal>ocp4-alert-receiver-configured</literal> rule now includes improved instructions. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-7307"><emphasis role="strong">OCPBUGS-7307</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the <literal>rhcos4-sshd-set-loglevel-info</literal> rule would fail for the <literal>rhcos4-e8</literal> profile. With this update, the remediation for the <literal>sshd-set-loglevel-info</literal> rule was updated to apply the correct configuration changes, allowing subsequent scans to pass after the remediation is applied. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-7816"><emphasis role="strong">OCPBUGS-7816</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, a new installation of OpenShift Container Platform with the latest Compliance Operator install failed on the <literal>scheduler-no-bind-address</literal> rule. With this update, the <literal>scheduler-no-bind-address</literal> rule has been disabled on newer versions of OpenShift Container Platform since the parameter was removed. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-8347"><emphasis role="strong">OCPBUGS-8347</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-1-0-0">
<title>OpenShift Compliance Operator 1.0.0</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 1.0.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:1682">RHBA-2023:1682 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-1-0-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator is now stable and the release channel is upgraded to <literal>stable</literal>. Future releases will follow <link xlink:href="https://semver.org/">Semantic Versioning</link>. To access the latest release, see <link xlink:href="../../security/compliance_operator/co-management/compliance-operator-updating.xml#olm-preparing-upgrade_compliance-operator-updating">Updating the Compliance Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-1-0-0-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Before this update, the compliance_operator_compliance_scan_error_total metric had an ERROR label with a different value for each error message. With this update, the compliance_operator_compliance_scan_error_total metric does not increase in values. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-1803"><emphasis role="strong">OCPBUGS-1803</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the <literal>ocp4-api-server-audit-log-maxsize</literal> rule would result in a <literal>FAIL</literal> state. With this update, the error message has been removed from the metric, decreasing the cardinality of the metric in line with best practices. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-7520"><emphasis role="strong">OCPBUGS-7520</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the <literal>rhcos4-enable-fips-mode</literal> rule description was misleading that FIPS could be enabled after installation. With this update, the <literal>rhcos4-enable-fips-mode</literal> rule description clarifies that FIPS must be enabled at install time. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-8358"><emphasis role="strong">OCPBUGS-8358</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-61">
<title>OpenShift Compliance Operator 0.1.61</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.61:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:0557">RHBA-2023:0557 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-61-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator now supports timeout configuration for Scanner Pods. The timeout is specified in the <literal>ScanSetting</literal> object. If the scan is not completed within the timeout, the scan retries until the maximum number of retries is reached. See <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-troubleshooting.xml#compliance-timeout_compliance-troubleshooting">Configuring ScanSetting timeout</link> for more information.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-61-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Before this update, Compliance Operator remediations required variables as inputs. Remediations without variables set were applied cluster-wide and resulted in stuck nodes, even though it appeared the remediation applied correctly. With this update, the Compliance Operator validates if a variable needs to be supplied using a <literal>TailoredProfile</literal> for a remediation. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-3864"><emphasis role="strong">OCPBUGS-3864</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the instructions for <literal>ocp4-kubelet-configure-tls-cipher-suites</literal> were incomplete, requiring users to refine the query manually. With this update, the query provided in <literal>ocp4-kubelet-configure-tls-cipher-suites</literal> returns the actual results to perform the audit steps. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-3017"><emphasis role="strong">OCPBUGS-3017</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, system reserved parameters were not generated in kubelet configuration files, causing the Compliance Operator to fail to unpause the machine config pool. With this update, the Compliance Operator omits system reserved parameters during machine configuration pool evaluation. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4445"><emphasis role="strong">OCPBUGS-4445</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, <literal>ComplianceCheckResult</literal> objects did not have correct descriptions. With this update, the Compliance Operator sources the <literal>ComplianceCheckResult</literal> information from the rule description. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4615"><emphasis role="strong">OCPBUGS-4615</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the Compliance Operator did not check for empty kubelet configuration files when parsing machine configurations. As a result, the Compliance Operator would panic and crash. With this update, the Compliance Operator implements improved checking of the kubelet configuration data structure and only continues if it is fully rendered. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4621"><emphasis role="strong">OCPBUGS-4621</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, the Compliance Operator generated remediations for kubelet evictions based on machine config pool name and a grace period, resulting in multiple remediations for a single eviction rule. With this update, the Compliance Operator applies all remediations for a single rule. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4338"><emphasis role="strong">OCPBUGS-4338</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, a regression occurred when attempting to create a <literal>ScanSettingBinding</literal> that was using a <literal>TailoredProfile</literal> with a non-default <literal>MachineConfigPool</literal> marked the <literal>ScanSettingBinding</literal> as <literal>Failed</literal>. With this update, functionality is restored and custom <literal>ScanSettingBinding</literal> using a <literal>TailoredProfile</literal> performs correctly. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-6827"><emphasis role="strong">OCPBUGS-6827</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Before this update, some kubelet configuration parameters did not have default values. With this update, the following parameters contain default values (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-6708"><emphasis role="strong">OCPBUGS-6708</emphasis></link>):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ocp4-cis-kubelet-enable-streaming-connections</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-eviction-thresholds-set-hard-imagefs-available</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-eviction-thresholds-set-hard-imagefs-inodesfree</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-eviction-thresholds-set-hard-memory-available</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-eviction-thresholds-set-hard-nodefs-available</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Before this update, the <literal>selinux_confinement_of_daemons</literal> rule failed running on the kubelet because of the permissions necessary for the kubelet to run. With this update, the <literal>selinux_confinement_of_daemons</literal> rule is disabled. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-6968"><emphasis role="strong">OCPBUGS-6968</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-59">
<title>OpenShift Compliance Operator 0.1.59</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.59:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:8538">RHBA-2022:8538 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-59-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator now supports Payment Card Industry Data Security Standard (PCI-DSS) <literal>ocp4-pci-dss</literal> and <literal>ocp4-pci-dss-node</literal> profiles on the <literal>ppc64le</literal> architecture.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-59-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the Compliance Operator did not support the Payment Card Industry Data Security Standard (PCI DSS) <literal>ocp4-pci-dss</literal> and <literal>ocp4-pci-dss-node</literal> profiles on different architectures such as <literal>ppc64le</literal>. Now, the Compliance Operator supports <literal>ocp4-pci-dss</literal> and <literal>ocp4-pci-dss-node</literal> profiles on the <literal>ppc64le</literal> architecture. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-3252"><emphasis role="strong">OCPBUGS-3252</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, after the recent update to version 0.1.57, the <literal>rerunner</literal> service account (SA) was no longer owned by the cluster service version (CSV), which caused the SA to be removed during the Operator upgrade. Now, the CSV owns the <literal>rerunner</literal> SA in 0.1.59, and upgrades from any previous version will not result in a missing SA. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-3452"><emphasis role="strong">OCPBUGS-3452</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-57">
<title>OpenShift Compliance Operator 0.1.57</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.57:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:6657">RHBA-2022:6657 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-57-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara><literal>KubeletConfig</literal> checks changed from <literal>Node</literal> to <literal>Platform</literal> type. <literal>KubeletConfig</literal> checks the default configuration of the <literal>KubeletConfig</literal>. The configuration files are aggregated from all nodes into a single location per node pool. See <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-remediation.xml#compliance-evaluate-kubeletconfig-rules_compliance-remediation">Evaluating <literal>KubeletConfig</literal> rules against default configuration values</link>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>ScanSetting</literal> Custom Resource now allows users to override the default CPU and memory limits of scanner pods through the <literal>scanLimits</literal> attribute. For more information, see <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-troubleshooting.xml#compliance-increasing-operator-limits_compliance-troubleshooting">Increasing Compliance Operator resource limits</link>.</simpara>
</listitem>
<listitem>
<simpara>A <literal>PriorityClass</literal> object can now be set through <literal>ScanSetting</literal>. This ensures the Compliance Operator is prioritized and minimizes the chance that the cluster falls out of compliance. For more information, see <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-advanced.xml#compliance-priorityclass_compliance-advanced">Setting <literal>PriorityClass</literal> for <literal>ScanSetting</literal> scans</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-57-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the Compliance Operator hard-coded notifications to the default <literal>openshift-compliance</literal> namespace. If the Operator were installed in a non-default namespace, the notifications would not work as expected. Now, notifications work in non-default <literal>openshift-compliance</literal> namespaces. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2060726"><emphasis role="strong">BZ#2060726</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator was unable to evaluate default configurations used by kubelet objects, resulting in inaccurate results and false positives. <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-remediation.xml#compliance-evaluate-kubeletconfig-rules_compliance-remediation">This new feature</link> evaluates the kubelet configuration and now reports accurately. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2075041"><emphasis role="strong">BZ#2075041</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator reported the <literal>ocp4-kubelet-configure-event-creation</literal> rule in a <literal>FAIL</literal> state after applying an automatic remediation because the <literal>eventRecordQPS</literal> value was set higher than the default value. Now, the <literal>ocp4-kubelet-configure-event-creation</literal> rule remediation sets the default value, and the rule applies correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2082416"><emphasis role="strong">BZ#2082416</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>The <literal>ocp4-configure-network-policies</literal> rule requires manual intervention to perform effectively. New descriptive instructions and rule updates increase applicability of the <literal>ocp4-configure-network-policies</literal> rule for clusters using Calico CNIs. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2091794"><emphasis role="strong">BZ#2091794</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator would not clean up pods used to scan infrastructure when using the <literal>debug=true</literal> option in the scan settings. This caused pods to be left on the cluster even after deleting the <literal>ScanSettingBinding</literal>. Now, pods are always deleted when a <literal>ScanSettingBinding</literal> is deleted.(<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2092913"><emphasis role="strong">BZ#2092913</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator used an older version of the <literal>operator-sdk</literal> command that caused alerts about deprecated functionality. Now, an updated version of the <literal>operator-sdk</literal> command is included and there are no more alerts for deprecated functionality. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2098581"><emphasis role="strong">BZ#2098581</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator would fail to apply remediations if it could not determine the relationship between kubelet and machine configurations. Now, the Compliance Operator has improved handling of the machine configurations and is able to determine if a kubelet configuration is a subset of a machine configuration. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2102511"><emphasis role="strong">BZ#2102511</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the rule for <literal>ocp4-cis-node-master-kubelet-enable-cert-rotation</literal> did not properly describe success criteria. As a result, the requirements for <literal>RotateKubeletClientCertificate</literal> were unclear. Now, the rule for <literal>ocp4-cis-node-master-kubelet-enable-cert-rotation</literal> reports accurately regardless of the configuration present in the kubelet configuration file. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2105153"><emphasis role="strong">BZ#2105153</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the rule for checking idle streaming timeouts did not consider default values, resulting in inaccurate rule reporting. Now, more robust checks ensure increased accuracy in results based on default configuration values. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2105878"><emphasis role="strong">BZ#2105878</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator would fail to fetch API resources when parsing machine configurations without Ignition specifications, which caused the <literal>api-check-pods</literal> processes to crash loop. Now, the Compliance Operator handles Machine Config Pools that do not have Ignition specifications correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2117268"><emphasis role="strong">BZ#2117268</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, rules evaluating the <literal>modprobe</literal> configuration would fail even after applying remediations due to a mismatch in values for the <literal>modprobe</literal> configuration. Now, the same values are used for the <literal>modprobe</literal> configuration in checks and remediations, ensuring consistent results. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2117747"><emphasis role="strong">BZ#2117747</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-57-deprecations">
<title>Deprecations</title>
<itemizedlist>
<listitem>
<simpara>Specifying <emphasis role="strong">Install into all namespaces in the cluster</emphasis> or setting the <literal>WATCH_NAMESPACES</literal> environment variable to <literal>""</literal> no longer affects all namespaces. Any API resources installed in namespaces not specified at the time of Compliance Operator installation is no longer be operational. API resources might require creation in the selected namespace, or the <literal>openshift-compliance</literal> namespace by default. This change improves the Compliance Operator&#8217;s memory usage.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-53">
<title>OpenShift Compliance Operator 0.1.53</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.53:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:5537">RHBA-2022:5537 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-53-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the <literal>ocp4-kubelet-enable-streaming-connections</literal> rule contained an incorrect variable comparison, resulting in false positive scan results. Now, the Compliance Operator provides accurate scan results when setting <literal>streamingConnectionIdleTimeout</literal>.  (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2069891"><emphasis role="strong">BZ#2069891</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, group ownership for <literal>/etc/openvswitch/conf.db</literal> was incorrect on IBM Z&#174; architectures, resulting in <literal>ocp4-cis-node-worker-file-groupowner-ovs-conf-db</literal> check failures. Now, the check is marked <literal>NOT-APPLICABLE</literal> on IBM Z&#174; architecture systems. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2072597"><emphasis role="strong">BZ#2072597</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the <literal>ocp4-cis-scc-limit-container-allowed-capabilities</literal> rule reported in a <literal>FAIL</literal> state due to incomplete data regarding the security context constraints (SCC) rules in the deployment. Now, the result is <literal>MANUAL</literal>, which is consistent with other checks that require human intervention. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2077916"><emphasis role="strong">BZ#2077916</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the following rules failed to account for additional configuration paths for API servers and TLS certificates and keys, resulting in reported failures even if the certificates and keys were set properly:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ocp4-cis-api-server-kubelet-client-cert</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-api-server-kubelet-client-key</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-configure-tls-cert</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ocp4-cis-kubelet-configure-tls-key</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Now, the rules report accurately and observe legacy file paths specified in the kubelet configuration file. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2079813"><emphasis role="strong">BZ#2079813</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the <literal>content_rule_oauth_or_oauthclient_inactivity_timeout</literal> rule did not account for a configurable timeout set by the deployment when assessing compliance for timeouts. This resulted in the rule failing even if the timeout was valid. Now, the Compliance Operator uses the <literal>var_oauth_inactivity_timeout</literal> variable to set valid timeout length. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2081952"><emphasis role="strong">BZ#2081952</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator used administrative permissions on namespaces not labeled appropriately for privileged use, resulting in warning messages regarding pod security-level violations. Now, the Compliance Operator has appropriate namespace labels and permission adjustments to access results without violating permissions. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2088202"><emphasis role="strong">BZ#2088202</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, applying auto remediations for <literal>rhcos4-high-master-sysctl-kernel-yama-ptrace-scope</literal> and <literal>rhcos4-sysctl-kernel-core-pattern</literal> resulted in subsequent failures of those rules in scan results, even though they were remediated. Now, the rules report <literal>PASS</literal> accurately, even after remediations are applied.(<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2094382"><emphasis role="strong">BZ#2094382</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator would fail in a <literal>CrashLoopBackoff</literal> state because of out-of-memory exceptions. Now, the Compliance Operator is improved to handle large machine configuration data sets in memory and function correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2094854"><emphasis role="strong">BZ#2094854</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-53-known-issue">
<title>Known issue</title>
<itemizedlist>
<listitem>
<simpara>When <literal>"debug":true</literal> is set within the <literal>ScanSettingBinding</literal> object, the pods generated by the <literal>ScanSettingBinding</literal> object are not removed when that binding is deleted. As a workaround, run the following command to delete the remaining pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pods -l compliance.openshift.io/scan-name=ocp4-cis</programlisting>
<simpara>(<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2092913"><emphasis role="strong">BZ#2092913</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-52">
<title>OpenShift Compliance Operator 0.1.52</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.52:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:4657">RHBA-2022:4657 - OpenShift Compliance Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-52-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The FedRAMP high SCAP profile is now available for use in OpenShift Container Platform environments. For more information, See <link xlink:href="../../security/compliance_operator/co-scans/compliance-operator-supported-profiles.xml#compliance-operator-supported-profiles">Supported compliance profiles</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-52-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the <literal>OpenScap</literal> container would crash due to a mount permission issue in a security environment where <literal>DAC_OVERRIDE</literal> capability is dropped. Now, executable mount permissions are applied to all users. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2082151"><emphasis role="strong">BZ#2082151</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the compliance rule <literal>ocp4-configure-network-policies</literal> could be configured as <literal>MANUAL</literal>. Now, compliance rule <literal>ocp4-configure-network-policies</literal> is set to <literal>AUTOMATIC</literal>. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2072431"><emphasis role="strong">BZ#2072431</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Cluster Autoscaler would fail to scale down because the Compliance Operator scan pods were never removed after a scan. Now, the pods are removed from each node by default unless explicitly saved for debugging purposes. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2075029"><emphasis role="strong">BZ#2075029</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, applying the Compliance Operator to the <literal>KubeletConfig</literal> would result in the node going into a <literal>NotReady</literal> state due to unpausing the Machine Config Pools too early. Now, the Machine Config Pools are unpaused appropriately and the node operates correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2071854"><emphasis role="strong">BZ#2071854</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Machine Config Operator used <literal>base64</literal> instead of <literal>url-encoded</literal> code in the latest release, causing Compliance Operator remediation to fail. Now, the Compliance Operator checks encoding to handle both <literal>base64</literal> and <literal>url-encoded</literal> Machine Config code and the remediation applies correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2082431"><emphasis role="strong">BZ#2082431</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-52-known-issue">
<title>Known issue</title>
<itemizedlist>
<listitem>
<simpara>When <literal>"debug":true</literal> is set within the <literal>ScanSettingBinding</literal> object, the pods generated by the <literal>ScanSettingBinding</literal> object are not removed when that binding is deleted. As a workaround, run the following command to delete the remaining pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pods -l compliance.openshift.io/scan-name=ocp4-cis</programlisting>
<simpara>(<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2092913"><emphasis role="strong">BZ#2092913</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-49">
<title>OpenShift Compliance Operator 0.1.49</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.49:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:1148">RHBA-2022:1148 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-49-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator is now supported on the following architectures:</simpara>
<itemizedlist>
<listitem>
<simpara>IBM Power&#174;</simpara>
</listitem>
<listitem>
<simpara>IBM Z&#174;</simpara>
</listitem>
<listitem>
<simpara>IBM&#174; LinuxONE</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-operator-0-1-49-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the <literal>openshift-compliance</literal> content did not include platform-specific checks for network types. As a result, OVN- and SDN-specific checks would show as <literal>failed</literal> instead of <literal>not-applicable</literal> based on the network configuration. Now, new rules contain platform checks for networking rules, resulting in a more accurate assessment of network-specific checks. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1994609"><emphasis role="strong">BZ#1994609</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the <literal>ocp4-moderate-routes-protected-by-tls</literal> rule incorrectly checked TLS settings that results in the rule failing the check, even if the connection secure SSL/TLS protocol. Now, the check properly evaluates TLS settings that are consistent with the networking guidance and profile recommendations. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2002695"><emphasis role="strong">BZ#2002695</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, <literal>ocp-cis-configure-network-policies-namespace</literal> used pagination when requesting namespaces. This caused the rule to fail because the deployments truncated lists of more than 500 namespaces. Now, the entire namespace list is requested, and the rule for checking configured network policies works for deployments with more than 500 namespaces. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2038909"><emphasis role="strong">BZ#2038909</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, remediations using the <literal>sshd jinja</literal> macros were hard-coded to specific sshd configurations. As a result, the configurations were inconsistent with the content the rules were checking for and the check would fail. Now, the sshd configuration is parameterized and the rules apply successfully. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2049141"><emphasis role="strong">BZ#2049141</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the <literal>ocp4-cluster-version-operator-verify-integrity</literal> always checked the first entry in the Cluter Version Operator (CVO) history. As a result, the upgrade would fail in situations where subsequent versions of OpenShift Container Platform would be verified. Now, the compliance check result for <literal>ocp4-cluster-version-operator-verify-integrity</literal> is able to detect verified versions and is accurate with the CVO history. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2053602"><emphasis role="strong">BZ#2053602</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the <literal>ocp4-api-server-no-adm-ctrl-plugins-disabled</literal> rule did not check for a list of empty admission controller plugins. As a result, the rule would always fail, even if all admission plugins were enabled. Now, more robust checking of the <literal>ocp4-api-server-no-adm-ctrl-plugins-disabled</literal> rule accurately passes with all admission controller plugins enabled. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2058631"><emphasis role="strong">BZ#2058631</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, scans did not contain platform checks for running against Linux worker nodes. As a result, running scans against worker nodes that were not Linux-based resulted in a never ending scan loop. Now, the scan schedules appropriately based on platform type and labels complete successfully. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2056911"><emphasis role="strong">BZ#2056911</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-48">
<title>OpenShift Compliance Operator 0.1.48</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.48:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:0416">RHBA-2022:0416 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="openshift-compliance-operator-0-1-48-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, some rules associated with extended Open Vulnerability and Assessment Language (OVAL) definitions had a <literal>checkType</literal> of <literal>None</literal>. This was because the Compliance Operator was not processing extended OVAL definitions when parsing rules. With this update, content from extended OVAL definitions is parsed so that these rules now have a <literal>checkType</literal> of either <literal>Node</literal> or <literal>Platform</literal>. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2040282"><emphasis role="strong">BZ#2040282</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, a manually created <literal>MachineConfig</literal> object for <literal>KubeletConfig</literal> prevented a <literal>KubeletConfig</literal> object from being generated for remediation, leaving the remediation in the <literal>Pending</literal> state. With this release, a <literal>KubeletConfig</literal>  object is created by the remediation, regardless if there is a manually created <literal>MachineConfig</literal> object for <literal>KubeletConfig</literal>. As a result, <literal>KubeletConfig</literal> remediations now work as expected. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2040401"><emphasis role="strong">BZ#2040401</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-47">
<title>OpenShift Compliance Operator 0.1.47</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.47:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:0014">RHBA-2022:0014 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-47-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator now supports the following compliance benchmarks for the Payment Card Industry Data Security Standard (PCI DSS):</simpara>
<itemizedlist>
<listitem>
<simpara>ocp4-pci-dss</simpara>
</listitem>
<listitem>
<simpara>ocp4-pci-dss-node</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Additional rules and remediations for FedRAMP moderate impact level are added to the OCP4-moderate, OCP4-moderate-node, and rhcos4-moderate profiles.</simpara>
</listitem>
<listitem>
<simpara>Remediations for KubeletConfig are now available in node-level profiles.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-compliance-operator-0-1-47-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, if your cluster was running OpenShift Container Platform 4.6 or earlier, remediations for USBGuard-related rules would fail for the moderate profile. This is because the remediations created by the Compliance Operator were based on an older version of USBGuard that did not support drop-in directories. Now, invalid remediations for USBGuard-related rules are not created for clusters running OpenShift Container Platform 4.6. If your cluster is using OpenShift Container Platform 4.6, you must manually create remediations for USBGuard-related rules.</simpara>
<simpara>Additionally, remediations are created only for rules that satisfy minimum version requirements. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1965511"><emphasis role="strong">BZ#1965511</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, when rendering remediations, the compliance operator would check that the remediation was well-formed by using a regular expression that was too strict. As a result, some remediations, such as those that render <literal>sshd_config</literal>, would not pass the regular expression check and therefore, were not created. The regular expression was found to be unnecessary and removed. Remediations now render correctly. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2033009"><emphasis role="strong">BZ#2033009</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-44">
<title>OpenShift Compliance Operator 0.1.44</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.44:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2021:4530">RHBA-2021:4530 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-44-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>In this release, the <literal>strictNodeScan</literal> option is now added to the <literal>ComplianceScan</literal>, <literal>ComplianceSuite</literal> and <literal>ScanSetting</literal> CRs. This option defaults to <literal>true</literal> which matches the previous behavior, where an error occurred if a scan was not able to be scheduled on a node. Setting the option to <literal>false</literal> allows the Compliance Operator to be more permissive about scheduling scans. Environments with ephemeral nodes can set the <literal>strictNodeScan</literal> value to false, which allows a compliance scan to proceed, even if some of the nodes in the cluster are not available for scheduling.</simpara>
</listitem>
<listitem>
<simpara>You can now customize the node that is used to schedule the result server workload by configuring the <literal>nodeSelector</literal> and <literal>tolerations</literal> attributes of the <literal>ScanSetting</literal> object. These attributes are used to place the <literal>ResultServer</literal> pod, the pod that is used to mount a PV storage volume and store the raw Asset Reporting Format (ARF) results. Previously, the <literal>nodeSelector</literal> and the <literal>tolerations</literal> parameters defaulted to selecting one of the control plane nodes and tolerating the <literal>node-role.kubernetes.io/master taint</literal>. This did not work in environments where control plane nodes are not permitted to mount PVs. This feature provides a way for you to select the node and tolerate a different taint in those environments.</simpara>
</listitem>
<listitem>
<simpara>The Compliance Operator can now remediate <literal>KubeletConfig</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>A comment containing an error message is now added to help content developers differentiate between objects that do not exist in the cluster compared to objects that cannot be fetched.</simpara>
</listitem>
<listitem>
<simpara>Rule objects now contain two new attributes, <literal>checkType</literal> and <literal>description</literal>. These attributes allow you to determine if the rule pertains to a node check or platform check, and also allow you to review what the rule does.</simpara>
</listitem>
<listitem>
<simpara>This enhancement removes the requirement that you have to extend an existing profile to create a tailored profile. This means the <literal>extends</literal> field in the <literal>TailoredProfile</literal> CRD is no longer mandatory. You can now select a list of rule objects to create a tailored profile. Note that you must select whether your profile applies to nodes or the platform by setting the <literal>compliance.openshift.io/product-type:</literal> annotation or by setting the <literal>-node</literal> suffix for the <literal>TailoredProfile</literal> CR.</simpara>
</listitem>
<listitem>
<simpara>In this release, the Compliance Operator is now able to schedule scans on all nodes irrespective of their taints. Previously, the scan pods would only tolerated the <literal>node-role.kubernetes.io/master taint</literal>, meaning that they would either ran on nodes with no taints or only on nodes with the <literal>node-role.kubernetes.io/master</literal> taint. In deployments that use custom taints for their nodes, this resulted in the scans not being scheduled on those nodes. Now, the scan pods tolerate all node taints.</simpara>
</listitem>
<listitem>
<simpara>In this release, the Compliance Operator supports the following North American Electric Reliability Corporation (NERC) security profiles:</simpara>
<itemizedlist>
<listitem>
<simpara>ocp4-nerc-cip</simpara>
</listitem>
<listitem>
<simpara>ocp4-nerc-cip-node</simpara>
</listitem>
<listitem>
<simpara>rhcos4-nerc-cip</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In this release, the Compliance Operator supports the NIST 800-53 Moderate-Impact Baseline for the Red Hat OpenShift - Node level, ocp4-moderate-node, security profile.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-compliance-operator-0-1-44-templating">
<title>Templating and variable use</title>
<itemizedlist>
<listitem>
<simpara>In this release, the remediation template now allows multi-value variables.</simpara>
</listitem>
<listitem>
<simpara>With this update, the Compliance Operator can change remediations based on variables that are set in the compliance profile. This is useful for remediations that include deployment-specific values such as time outs, NTP server host names, or similar. Additionally, the <literal>ComplianceCheckResult</literal> objects now use the label <literal>compliance.openshift.io/check-has-value</literal> that lists the variables a check has used.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-compliance-operator-0-1-44-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, while performing a scan, an unexpected termination occurred in one of the scanner containers of the pods. In this release, the Compliance Operator uses the latest OpenSCAP version 1.3.5 to avoid a crash.</simpara>
</listitem>
<listitem>
<simpara>Previously, using <literal>autoReplyRemediations</literal> to apply remediations triggered an update of the cluster nodes. This was disruptive if some of the remediations did not include all of the required input variables. Now, if a remediation is missing one or more required input variables, it is  assigned a state of <literal>NeedsReview</literal>.  If one or more remediations are in a <literal>NeedsReview</literal> state, the machine config pool remains paused, and the remediations are not applied until all of the required variables are set. This helps minimize disruption to the nodes.</simpara>
</listitem>
<listitem>
<simpara>The RBAC Role and Role Binding used for Prometheus metrics are changed to 'ClusterRole' and 'ClusterRoleBinding' to ensure that monitoring works without customization.</simpara>
</listitem>
<listitem>
<simpara>Previously, if an error occurred while parsing a profile, rules or variables objects were removed and deleted from the profile. Now, if an error occurs during parsing, the <literal>profileparser</literal> annotates the object with a temporary annotation that prevents the object from being deleted until after parsing completes. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=1988259"><emphasis role="strong">BZ#1988259</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, an error occurred if titles or descriptions were missing from a tailored profile. Because the XCCDF standard requires titles and descriptions for tailored profiles, titles and descriptions are now required to be set in <literal>TailoredProfile</literal> CRs.</simpara>
</listitem>
<listitem>
<simpara>Previously, when using tailored profiles, <literal>TailoredProfile</literal> variable values were allowed to be set using only a specific selection set. This restriction is now removed, and <literal>TailoredProfile</literal> variables can be set to any value.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes-0-1-39">
<title>Release Notes for Compliance Operator 0.1.39</title>
<simpara>The following advisory is available for the OpenShift Compliance Operator 0.1.39:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2021:3214">RHBA-2021:3214 - OpenShift Compliance Operator bug fix and enhancement update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-operator-0-1-39-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>Previously, the Compliance Operator was unable to parse Payment Card Industry Data Security Standard (PCI DSS) references. Now, the Operator can parse compliance content that is provided with PCI DSS profiles.</simpara>
</listitem>
<listitem>
<simpara>Previously, the Compliance Operator was unable to execute rules for AU-5 control in the moderate profile. Now, permission is added to the Operator so that it can read <emphasis role="strong">Prometheusrules.monitoring.coreos.com</emphasis> objects and run the rules that cover AU-5 control in the moderate profile.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-release-notes_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/compliance_operator/co-concepts/compliance-operator-understanding.xml#understanding-compliance-operator">Understanding the Compliance Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_compliance_operator_concepts_2">
<title>Compliance Operator concepts</title>
<section xml:id="understanding-compliance-operator">
<title>Understanding the Compliance Operator</title>

<simpara>The Compliance Operator lets OpenShift Container Platform administrators describe the required compliance state of a cluster and provides them with an overview of gaps and ways to remediate them. The Compliance Operator assesses compliance of both the Kubernetes API resources of OpenShift Container Platform, as well as the nodes running the cluster. The Compliance Operator uses OpenSCAP, a NIST-certified tool, to scan and enforce security policies provided by the content.</simpara>
<important>
<simpara>The Compliance Operator is available for Red Hat Enterprise Linux CoreOS (RHCOS) deployments only.</simpara>
</important>
<section xml:id="compliance_profiles_understanding-compliance">
<title>Compliance Operator profiles</title>
<simpara>There are several profiles available as part of the Compliance Operator installation. You can use the <literal>oc get</literal> command to view available profiles, profile details, and specific rules.</simpara>
<itemizedlist>
<listitem>
<simpara>View the available profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance profiles.compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 AGE
ocp4-cis             94m
ocp4-cis-node        94m
ocp4-e8              94m
ocp4-high            94m
ocp4-high-node       94m
ocp4-moderate        94m
ocp4-moderate-node   94m
ocp4-nerc-cip        94m
ocp4-nerc-cip-node   94m
ocp4-pci-dss         94m
ocp4-pci-dss-node    94m
rhcos4-e8            94m
rhcos4-high          94m
rhcos4-moderate      94m
rhcos4-nerc-cip      94m</programlisting>
</para>
</formalpara>
<simpara>These profiles represent different compliance benchmarks. Each profile has the product name that it applies to added as a prefix to the profile’s name. <literal>ocp4-e8</literal> applies the Essential 8 benchmark to the OpenShift Container Platform product, while <literal>rhcos4-e8</literal> applies the Essential 8 benchmark to the Red Hat Enterprise Linux CoreOS (RHCOS) product.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to view the details of the <literal>rhcos4-e8</literal> profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance -oyaml profiles.compliance rhcos4-e8</programlisting>
<example>
<title>Example output</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
description: 'This profile contains configuration checks for Red Hat Enterprise Linux
  CoreOS that align to the Australian Cyber Security Centre (ACSC) Essential Eight.
  A copy of the Essential Eight in Linux Environments guide can be found at the ACSC
  website: https://www.cyber.gov.au/acsc/view-all-content/publications/hardening-linux-workstations-and-servers'
id: xccdf_org.ssgproject.content_profile_e8
kind: Profile
metadata:
  annotations:
    compliance.openshift.io/image-digest: pb-rhcos4hrdkm
    compliance.openshift.io/product: redhat_enterprise_linux_coreos_4
    compliance.openshift.io/product-type: Node
  creationTimestamp: "2022-10-19T12:06:49Z"
  generation: 1
  labels:
    compliance.openshift.io/profile-bundle: rhcos4
  name: rhcos4-e8
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ProfileBundle
    name: rhcos4
    uid: 22350850-af4a-4f5c-9a42-5e7b68b82d7d
  resourceVersion: "43699"
  uid: 86353f70-28f7-40b4-bf0e-6289ec33675b
rules:
- rhcos4-accounts-no-uid-except-zero
- rhcos4-audit-rules-dac-modification-chmod
- rhcos4-audit-rules-dac-modification-chown
- rhcos4-audit-rules-execution-chcon
- rhcos4-audit-rules-execution-restorecon
- rhcos4-audit-rules-execution-semanage
- rhcos4-audit-rules-execution-setfiles
- rhcos4-audit-rules-execution-setsebool
- rhcos4-audit-rules-execution-seunshare
- rhcos4-audit-rules-kernel-module-loading-delete
- rhcos4-audit-rules-kernel-module-loading-finit
- rhcos4-audit-rules-kernel-module-loading-init
- rhcos4-audit-rules-login-events
- rhcos4-audit-rules-login-events-faillock
- rhcos4-audit-rules-login-events-lastlog
- rhcos4-audit-rules-login-events-tallylog
- rhcos4-audit-rules-networkconfig-modification
- rhcos4-audit-rules-sysadmin-actions
- rhcos4-audit-rules-time-adjtimex
- rhcos4-audit-rules-time-clock-settime
- rhcos4-audit-rules-time-settimeofday
- rhcos4-audit-rules-time-stime
- rhcos4-audit-rules-time-watch-localtime
- rhcos4-audit-rules-usergroup-modification
- rhcos4-auditd-data-retention-flush
- rhcos4-auditd-freq
- rhcos4-auditd-local-events
- rhcos4-auditd-log-format
- rhcos4-auditd-name-format
- rhcos4-auditd-write-logs
- rhcos4-configure-crypto-policy
- rhcos4-configure-ssh-crypto-policy
- rhcos4-no-empty-passwords
- rhcos4-selinux-policytype
- rhcos4-selinux-state
- rhcos4-service-auditd-enabled
- rhcos4-sshd-disable-empty-passwords
- rhcos4-sshd-disable-gssapi-auth
- rhcos4-sshd-disable-rhosts
- rhcos4-sshd-disable-root-login
- rhcos4-sshd-disable-user-known-hosts
- rhcos4-sshd-do-not-permit-user-env
- rhcos4-sshd-enable-strictmodes
- rhcos4-sshd-print-last-log
- rhcos4-sshd-set-loglevel-info
- rhcos4-sysctl-kernel-dmesg-restrict
- rhcos4-sysctl-kernel-kptr-restrict
- rhcos4-sysctl-kernel-randomize-va-space
- rhcos4-sysctl-kernel-unprivileged-bpf-disabled
- rhcos4-sysctl-kernel-yama-ptrace-scope
- rhcos4-sysctl-net-core-bpf-jit-harden
title: Australian Cyber Security Centre (ACSC) Essential Eight</programlisting>
</example>
</listitem>
<listitem>
<simpara>Run the following command to view the details of the <literal>rhcos4-audit-rules-login-events</literal> rule:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance -oyaml rules rhcos4-audit-rules-login-events</programlisting>
<example>
<title>Example output</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
checkType: Node
description: |-
  The audit system already collects login information for all users and root. If the auditd daemon is configured to use the augenrules program to read audit rules during daemon startup (the default), add the following lines to a file with suffix.rules in the directory /etc/audit/rules.d in order to watch for attempted manual edits of files involved in storing logon events:

  -w /var/log/tallylog -p wa -k logins
  -w /var/run/faillock -p wa -k logins
  -w /var/log/lastlog -p wa -k logins

  If the auditd daemon is configured to use the auditctl utility to read audit rules during daemon startup, add the following lines to /etc/audit/audit.rules file in order to watch for unattempted manual edits of files involved in storing logon events:

  -w /var/log/tallylog -p wa -k logins
  -w /var/run/faillock -p wa -k logins
  -w /var/log/lastlog -p wa -k logins
id: xccdf_org.ssgproject.content_rule_audit_rules_login_events
kind: Rule
metadata:
  annotations:
    compliance.openshift.io/image-digest: pb-rhcos4hrdkm
    compliance.openshift.io/rule: audit-rules-login-events
    control.compliance.openshift.io/NIST-800-53: AU-2(d);AU-12(c);AC-6(9);CM-6(a)
    control.compliance.openshift.io/PCI-DSS: Req-10.2.3
    policies.open-cluster-management.io/controls: AU-2(d),AU-12(c),AC-6(9),CM-6(a),Req-10.2.3
    policies.open-cluster-management.io/standards: NIST-800-53,PCI-DSS
  creationTimestamp: "2022-10-19T12:07:08Z"
  generation: 1
  labels:
    compliance.openshift.io/profile-bundle: rhcos4
  name: rhcos4-audit-rules-login-events
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ProfileBundle
    name: rhcos4
    uid: 22350850-af4a-4f5c-9a42-5e7b68b82d7d
  resourceVersion: "44819"
  uid: 75872f1f-3c93-40ca-a69d-44e5438824a4
rationale: Manual editing of these files may indicate nefarious activity, such as
  an attacker attempting to remove evidence of an intrusion.
severity: medium
title: Record Attempts to Alter Logon and Logout Events
warning: Manual editing of these files may indicate nefarious activity, such as an
  attacker attempting to remove evidence of an intrusion.</programlisting>
</example>
</listitem>
</itemizedlist>
<section xml:id="compliance_profile_types_understanding-compliance">
<title>Compliance Operator profile types</title>
<simpara>There are two types of compliance profiles available: Platform and Node.</simpara>
<variablelist>
<varlistentry>
<term>Platform</term>
<listitem>
<simpara>Platform scans target your OpenShift Container Platform cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Node</term>
<listitem>
<simpara>Node scans target the nodes of the cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>For compliance profiles that have Node and Platform applications, such as <literal>pci-dss</literal> compliance profiles, you must run both in your OpenShift Container Platform environment.</simpara>
</important>
</section>
</section>
<section xml:id="additional-resources_compliance-operator-understanding" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../../security/compliance_operator/co-scans/compliance-operator-supported-profiles.xml#compliance-operator-supported-profiles">Supported compliance profiles</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="custom-resource-definitions">
<title>Understanding the Custom Resource Definitions</title>

<simpara>The Compliance Operator in the OpenShift Container Platform provides you with several Custom Resource Definitions (CRDs) to accomplish the compliance scans. To run a compliance scan, it leverages the predefined security policies, which are derived from the <link xlink:href="https://github.com/ComplianceAsCode/content">ComplianceAsCode</link> community project. The Compliance Operator converts these security policies into CRDs, which you can use to run compliance scans and get remediations for the issues found.</simpara>
<section xml:id="custom-resource-definitions-workflow_compliance-crd">
<title>CRDs workflow</title>
<simpara>The CRD provides you the following workflow to complete the compliance scans:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Define your compliance scan requirements</simpara>
</listitem>
<listitem>
<simpara>Configure the compliance scan settings</simpara>
</listitem>
<listitem>
<simpara>Process compliance requirements with compliance scans settings</simpara>
</listitem>
<listitem>
<simpara>Monitor the compliance scans</simpara>
</listitem>
<listitem>
<simpara>Check the compliance scan results</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="defining-compliance-scan-requirements_compliance-crd">
<title>Defining the compliance scan requirements</title>
<simpara>By default, the Compliance Operator CRDs include <literal>ProfileBundle</literal> and <literal>Profile</literal> objects, in which you can define and set the rules for your compliance scan requirements. You can also customize the default profiles by using a <literal>TailoredProfile</literal> object.</simpara>
<section xml:id="profile-bundle-object_compliance-crd">
<title>ProfileBundle object</title>
<simpara>When you install the Compliance Operator, it includes ready-to-run <literal>ProfileBundle</literal> objects. The Compliance Operator parses the <literal>ProfileBundle</literal> object and creates a <literal>Profile</literal> object for each profile in the bundle. It also parses <literal>Rule</literal> and <literal>Variable</literal> objects, which are used by the <literal>Profile</literal> object.</simpara>
<formalpara>
<title>Example <literal>ProfileBundle</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ProfileBundle
  name: &lt;profile bundle name&gt;
  namespace: openshift-compliance
status:
  dataStreamStatus: VALID <co xml:id="CO20-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>Indicates whether the Compliance Operator was able to parse the content files.</para>
</callout>
</calloutlist>
<note>
<simpara>When the <literal>contentFile</literal> fails, an <literal>errorMessage</literal> attribute appears, which provides details of the error that occurred.</simpara>
</note>
<formalpara>
<title>Troubleshooting</title>
<para>When you roll back to a known content image from an invalid image, the <literal>ProfileBundle</literal> object stops responding and displays <literal>PENDING</literal> state. As a workaround, you can move to a different image than the previous one. Alternatively, you can delete and re-create the <literal>ProfileBundle</literal> object to return to the working state.</para>
</formalpara>
</section>
<section xml:id="profile-object_compliance-crd">
<title>Profile object</title>
<simpara>The <literal>Profile</literal> object defines the rules and variables that can be evaluated for a certain compliance standard. It contains parsed out details about an OpenSCAP profile, such as its XCCDF identifier and profile checks for a <literal>Node</literal> or <literal>Platform</literal> type. You can either directly use the <literal>Profile</literal> object or further customize it using a <literal>TailorProfile</literal> object.</simpara>
<note>
<simpara>You cannot create or modify the <literal>Profile</literal> object manually because it is derived from a single <literal>ProfileBundle</literal> object. Typically, a single <literal>ProfileBundle</literal> object can include several <literal>Profile</literal> objects.</simpara>
</note>
<formalpara>
<title>Example <literal>Profile</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
description: &lt;description of the profile&gt;
id: xccdf_org.ssgproject.content_profile_moderate <co xml:id="CO21-1"/>
kind: Profile
metadata:
  annotations:
    compliance.openshift.io/product: &lt;product name&gt;
    compliance.openshift.io/product-type: Node <co xml:id="CO21-2"/>
  creationTimestamp: "YYYY-MM-DDTMM:HH:SSZ"
  generation: 1
  labels:
    compliance.openshift.io/profile-bundle: &lt;profile bundle name&gt;
  name: rhcos4-moderate
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ProfileBundle
    name: &lt;profile bundle name&gt;
    uid: &lt;uid string&gt;
  resourceVersion: "&lt;version number&gt;"
  selfLink: /apis/compliance.openshift.io/v1alpha1/namespaces/openshift-compliance/profiles/rhcos4-moderate
  uid: &lt;uid string&gt;
rules: <co xml:id="CO21-3"/>
- rhcos4-account-disable-post-pw-expiration
- rhcos4-accounts-no-uid-except-zero
- rhcos4-audit-rules-dac-modification-chmod
- rhcos4-audit-rules-dac-modification-chown
title: &lt;title of the profile&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>Specify the XCCDF name of the profile. Use this identifier when you define a <literal>ComplianceScan</literal> object as the value of the profile attribute of the scan.</para>
</callout>
<callout arearefs="CO21-2">
<para>Specify either a <literal>Node</literal> or <literal>Platform</literal>. Node profiles scan the cluster nodes and platform profiles scan the Kubernetes platform.</para>
</callout>
<callout arearefs="CO21-3">
<para>Specify the list of rules for the profile. Each rule corresponds to a single check.</para>
</callout>
</calloutlist>
</section>
<section xml:id="rule-object_compliance-crd">
<title>Rule object</title>
<simpara>The <literal>Rule</literal> object, which forms the profiles, are also exposed as objects. Use the <literal>Rule</literal> object to define your compliance check requirements and specify how it could be fixed.</simpara>
<formalpara>
<title>Example <literal>Rule</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">    apiVersion: compliance.openshift.io/v1alpha1
    checkType: Platform <co xml:id="CO22-1"/>
    description: &lt;description of the rule&gt;
    id: xccdf_org.ssgproject.content_rule_configure_network_policies_namespaces <co xml:id="CO22-2"/>
    instructions: &lt;manual instructions for the scan&gt;
    kind: Rule
    metadata:
      annotations:
        compliance.openshift.io/rule: configure-network-policies-namespaces
        control.compliance.openshift.io/CIS-OCP: 5.3.2
        control.compliance.openshift.io/NERC-CIP: CIP-003-3 R4;CIP-003-3 R4.2;CIP-003-3
          R5;CIP-003-3 R6;CIP-004-3 R2.2.4;CIP-004-3 R3;CIP-007-3 R2;CIP-007-3 R2.1;CIP-007-3
          R2.2;CIP-007-3 R2.3;CIP-007-3 R5.1;CIP-007-3 R6.1
        control.compliance.openshift.io/NIST-800-53: AC-4;AC-4(21);CA-3(5);CM-6;CM-6(1);CM-7;CM-7(1);SC-7;SC-7(3);SC-7(5);SC-7(8);SC-7(12);SC-7(13);SC-7(18)
      labels:
        compliance.openshift.io/profile-bundle: ocp4
      name: ocp4-configure-network-policies-namespaces
      namespace: openshift-compliance
    rationale: &lt;description of why this rule is checked&gt;
    severity: high <co xml:id="CO22-3"/>
    title: &lt;summary of the rule&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para>Specify the type of check this rule executes. <literal>Node</literal> profiles scan the cluster nodes and <literal>Platform</literal> profiles scan the Kubernetes platform. An empty value indicates there is no automated check.</para>
</callout>
<callout arearefs="CO22-2">
<para>Specify the XCCDF name of the rule, which is parsed directly from the datastream.</para>
</callout>
<callout arearefs="CO22-3">
<para>Specify the severity of the rule when it fails.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>Rule</literal> object gets an appropriate label for an easy identification of the associated <literal>ProfileBundle</literal> object. The <literal>ProfileBundle</literal> also gets specified in the <literal>OwnerReferences</literal> of this object.</simpara>
</note>
</section>
<section xml:id="tailored-profile-object_compliance-crd">
<title>TailoredProfile object</title>
<simpara>Use the <literal>TailoredProfile</literal> object to modify the default <literal>Profile</literal> object based on your organization requirements. You can enable or disable rules, set variable values, and provide justification for the customization. After validation, the <literal>TailoredProfile</literal> object creates a <literal>ConfigMap</literal>, which can be referenced by a <literal>ComplianceScan</literal> object.</simpara>
<tip>
<simpara>You can use the <literal>TailoredProfile</literal> object by referencing it in a <literal>ScanSettingBinding</literal> object. For more information about <literal>ScanSettingBinding</literal>, see ScanSettingBinding object.</simpara>
</tip>
<formalpara>
<title>Example <literal>TailoredProfile</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
  name: rhcos4-with-usb
spec:
  extends: rhcos4-moderate <co xml:id="CO23-1"/>
  title: &lt;title of the tailored profile&gt;
  disableRules:
    - name: &lt;name of a rule object to be disabled&gt;
      rationale: &lt;description of why this rule is checked&gt;
status:
  id: xccdf_compliance.openshift.io_profile_rhcos4-with-usb <co xml:id="CO23-2"/>
  outputRef:
    name: rhcos4-with-usb-tp <co xml:id="CO23-3"/>
    namespace: openshift-compliance
  state: READY <co xml:id="CO23-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para>This is optional. Name of the <literal>Profile</literal> object upon which the <literal>TailoredProfile</literal> is built. If no value is set, a new profile is created from the <literal>enableRules</literal> list.</para>
</callout>
<callout arearefs="CO23-2">
<para>Specifies the XCCDF name of the tailored profile.</para>
</callout>
<callout arearefs="CO23-3">
<para>Specifies the <literal>ConfigMap</literal> name, which can be used as the value of the <literal>tailoringConfigMap.name</literal> attribute of a <literal>ComplianceScan</literal>.</para>
</callout>
<callout arearefs="CO23-4">
<para>Shows the state of the object such as <literal>READY</literal>, <literal>PENDING</literal>, and <literal>FAILURE</literal>. If the state of the object is <literal>ERROR</literal>, then the attribute <literal>status.errorMessage</literal> provides the reason for the failure.</para>
</callout>
</calloutlist>
<simpara>With the <literal>TailoredProfile</literal> object, it is possible to create a new <literal>Profile</literal> object using the <literal>TailoredProfile</literal> construct. To create a new <literal>Profile</literal>, set the following configuration parameters :</simpara>
<itemizedlist>
<listitem>
<simpara>an appropriate title</simpara>
</listitem>
<listitem>
<simpara><literal>extends</literal> value must be empty</simpara>
</listitem>
<listitem>
<simpara>scan type annotation on the <literal>TailoredProfile</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">compliance.openshift.io/product-type: Platform/Node</programlisting>
<note>
<simpara>If you have not set the <literal>product-type</literal> annotation, the Compliance Operator defaults to <literal>Platform</literal> scan type. Adding the <literal>-node</literal> suffix to the name of the <literal>TailoredProfile</literal> object results in <literal>node</literal> scan type.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="configure-compliance-scan-settings_compliance-crd">
<title>Configuring the compliance scan settings</title>
<simpara>After you have defined the requirements of the compliance scan, you can configure it by specifying the type of the scan, occurrence of the scan, and location of the scan. To do so, Compliance Operator provides you with a <literal>ScanSetting</literal> object.</simpara>
<section xml:id="scan-setting-object_compliance-crd">
<title>ScanSetting object</title>
<simpara>Use the <literal>ScanSetting</literal> object to define and reuse the operational policies to run your scans.
By default, the Compliance Operator creates the following <literal>ScanSetting</literal> objects:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">default</emphasis> - it runs a scan every day at 1 AM on both master and worker nodes using a 1Gi Persistent Volume (PV) and keeps the last three results. Remediation is neither applied nor updated automatically.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">default-auto-apply</emphasis> - it runs a scan every day at 1AM on both control plane and worker nodes using a 1Gi Persistent Volume (PV) and keeps the last three results. Both <literal>autoApplyRemediations</literal> and <literal>autoUpdateRemediations</literal> are set to true.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example <literal>ScanSetting</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
autoApplyRemediations: true <co xml:id="CO24-1"/>
autoUpdateRemediations: true <co xml:id="CO24-2"/>
kind: ScanSetting
maxRetryOnTimeout: 3
metadata:
  creationTimestamp: "2022-10-18T20:21:00Z"
  generation: 1
  name: default-auto-apply
  namespace: openshift-compliance
  resourceVersion: "38840"
  uid: 8cb0967d-05e0-4d7a-ac1c-08a7f7e89e84
rawResultStorage:
  nodeSelector:
    node-role.kubernetes.io/master: ""
  pvAccessModes:
  - ReadWriteOnce
  rotation: 3 <co xml:id="CO24-3"/>
  size: 1Gi <co xml:id="CO24-4"/>
  tolerations:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
    operator: Exists
  - effect: NoExecute
    key: node.kubernetes.io/not-ready
    operator: Exists
    tolerationSeconds: 300
  - effect: NoExecute
    key: node.kubernetes.io/unreachable
    operator: Exists
    tolerationSeconds: 300
  - effect: NoSchedule
    key: node.kubernetes.io/memory-pressure
    operator: Exists
roles: <co xml:id="CO24-5"/>
- master
- worker
scanTolerations:
- operator: Exists
schedule: 0 1 * * * <co xml:id="CO24-6"/>
showNotApplicable: false
strictNodeScan: true
timeout: 30m</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO24-1">
<para>Set to <literal>true</literal> to enable auto remediations. Set to <literal>false</literal> to disable auto remediations.</para>
</callout>
<callout arearefs="CO24-2">
<para>Set to <literal>true</literal> to enable auto remediations for content updates. Set to <literal>false</literal> to disable auto remediations for content updates.</para>
</callout>
<callout arearefs="CO24-3">
<para>Specify the number of stored scans in the raw result format. The default value is <literal>3</literal>. As the older results get rotated, the administrator must store the results elsewhere before the rotation happens.</para>
</callout>
<callout arearefs="CO24-4">
<para>Specify the storage size that should be created for the scan to store the raw results. The default value is <literal>1Gi</literal></para>
</callout>
<callout arearefs="CO24-6">
<para>Specify how often the scan should be run in cron format.</para>
<note>
<simpara>To disable the rotation policy, set the value to <literal>0</literal>.</simpara>
</note>
</callout>
<callout arearefs="CO24-5">
<para>Specify the <literal>node-role.kubernetes.io</literal> label value to schedule the scan for <literal>Node</literal> type. This value has to match the name of a <literal>MachineConfigPool</literal>.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="process-compliance-requirements-with-compliance-settings_compliance-crd">
<title>Processing the compliance scan requirements with compliance scans settings</title>
<simpara>When you have defined the compliance scan requirements and configured the settings to run the scans, then the Compliance Operator processes it using the <literal>ScanSettingBinding</literal> object.</simpara>
<section xml:id="scan-setting-binding-object_compliance-crd">
<title>ScanSettingBinding object</title>
<simpara>Use the <literal>ScanSettingBinding</literal> object to specify your compliance requirements with reference to the <literal>Profile</literal> or <literal>TailoredProfile</literal> object. It is then linked to a <literal>ScanSetting</literal> object, which provides the operational constraints for the scan. Then the Compliance Operator generates the <literal>ComplianceSuite</literal> object based on the <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> objects.</simpara>
<formalpara>
<title>Example <literal>ScanSettingBinding</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
  name: &lt;name of the scan&gt;
profiles: <co xml:id="CO25-1"/>
  # Node checks
  - name: rhcos4-with-usb
    kind: TailoredProfile
    apiGroup: compliance.openshift.io/v1alpha1
  # Cluster checks
  - name: ocp4-moderate
    kind: Profile
    apiGroup: compliance.openshift.io/v1alpha1
settingsRef: <co xml:id="CO25-2"/>
  name: my-companys-constraints
  kind: ScanSetting
  apiGroup: compliance.openshift.io/v1alpha1</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO25-1">
<para>Specify the details of <literal>Profile</literal> or <literal>TailoredProfile</literal> object to scan your environment.</para>
</callout>
<callout arearefs="CO25-2">
<para>Specify the operational constraints, such as schedule and storage size.</para>
</callout>
</calloutlist>
<simpara>The creation of <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> objects results in the compliance suite. To get the list of compliance suite, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get compliancesuites</programlisting>
<important>
<simpara>If you delete <literal>ScanSettingBinding</literal>, then compliance suite also is deleted.</simpara>
</important>
</section>
</section>
<section xml:id="track-compliance-scans_compliance-crd">
<title>Tracking the compliance scans</title>
<simpara>After the creation of compliance suite, you can monitor the status of the deployed scans using the <literal>ComplianceSuite</literal> object.</simpara>
<section xml:id="compliance-suite-object_compliance-crd">
<title>ComplianceSuite object</title>
<simpara>The <literal>ComplianceSuite</literal> object helps you keep track of the state of the scans. It contains the raw settings to create scans and the overall result.</simpara>
<simpara>For <literal>Node</literal> type scans, you should map the scan to the <literal>MachineConfigPool</literal>, since it contains the remediations for any issues. If you specify a label, ensure it directly applies to a pool.</simpara>
<formalpara>
<title>Example <literal>ComplianceSuite</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceSuite
metadata:
  name: &lt;name of the scan&gt;
spec:
  autoApplyRemediations: false <co xml:id="CO26-1"/>
  schedule: "0 1 * * *" <co xml:id="CO26-2"/>
  scans: <co xml:id="CO26-3"/>
    - name: workers-scan
      scanType: Node
      profile: xccdf_org.ssgproject.content_profile_moderate
      content: ssg-rhcos4-ds.xml
      contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:45dc...
      rule: "xccdf_org.ssgproject.content_rule_no_netrc_files"
      nodeSelector:
        node-role.kubernetes.io/worker: ""
status:
  Phase: DONE <co xml:id="CO26-4"/>
  Result: NON-COMPLIANT <co xml:id="CO26-5"/>
  scanStatuses:
  - name: workers-scan
    phase: DONE
    result: NON-COMPLIANT</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO26-1">
<para>Set to <literal>true</literal> to enable auto remediations. Set to <literal>false</literal> to disable auto remediations.</para>
</callout>
<callout arearefs="CO26-2">
<para>Specify how often the scan should be run in cron format.</para>
</callout>
<callout arearefs="CO26-3">
<para>Specify a list of scan specifications to run in the cluster.</para>
</callout>
<callout arearefs="CO26-4">
<para>Indicates the progress of the scans.</para>
</callout>
<callout arearefs="CO26-5">
<para>Indicates the overall verdict of the suite.</para>
</callout>
</calloutlist>
<simpara>The suite in the background creates the <literal>ComplianceScan</literal> object based on the <literal>scans</literal> parameter.
You can programmatically fetch the <literal>ComplianceSuites</literal> events. To get the events for the suite, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events --field-selector involvedObject.kind=ComplianceSuite,involvedObject.name=&lt;name of the suite&gt;</programlisting>
<important>
<simpara>You might create errors when you manually define the <literal>ComplianceSuite</literal>, since it contains the XCCDF attributes.</simpara>
</important>
</section>
<section xml:id="advance-compliance-scan-object_compliance-crd">
<title>Advanced ComplianceScan Object</title>
<simpara>The Compliance Operator includes options for advanced users for debugging or integrating with existing tooling. While it is recommended that you not create a <literal>ComplianceScan</literal> object directly, you can instead manage it using a <literal>ComplianceSuite</literal> object.</simpara>
<formalpara>
<title>Example Advanced <literal>ComplianceScan</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceScan
metadata:
  name: &lt;name of the scan&gt;
spec:
  scanType: Node <co xml:id="CO27-1"/>
  profile: xccdf_org.ssgproject.content_profile_moderate <co xml:id="CO27-2"/>
  content: ssg-ocp4-ds.xml
  contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:45dc... <co xml:id="CO27-3"/>
  rule: "xccdf_org.ssgproject.content_rule_no_netrc_files" <co xml:id="CO27-4"/>
  nodeSelector: <co xml:id="CO27-5"/>
    node-role.kubernetes.io/worker: ""
status:
  phase: DONE <co xml:id="CO27-6"/>
  result: NON-COMPLIANT <co xml:id="CO27-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO27-1">
<para>Specify either <literal>Node</literal> or <literal>Platform</literal>. Node profiles scan the cluster nodes and platform profiles scan the Kubernetes platform.</para>
</callout>
<callout arearefs="CO27-2">
<para>Specify the XCCDF identifier of the profile that you want to run.</para>
</callout>
<callout arearefs="CO27-3">
<para>Specify the container image that encapsulates the profile files.</para>
</callout>
<callout arearefs="CO27-4">
<para>It is optional. Specify the scan to run a single rule. This rule has to be identified with the XCCDF ID, and has to belong to the specified profile.</para>
<note>
<simpara>If you skip the <literal>rule</literal> parameter, then scan runs for all the available rules of the specified profile.</simpara>
</note>
</callout>
<callout arearefs="CO27-5">
<para>If you are on the OpenShift Container Platform and wants to generate a remediation, then nodeSelector label has to match the <literal>MachineConfigPool</literal> label.</para>
<note>
<simpara>If you do not specify <literal>nodeSelector</literal> parameter or match the <literal>MachineConfig</literal> label, scan will still run, but it will not create remediation.</simpara>
</note>
</callout>
<callout arearefs="CO27-6">
<para>Indicates the current phase of the scan.</para>
</callout>
<callout arearefs="CO27-7">
<para>Indicates the verdict of the scan.</para>
</callout>
</calloutlist>
<important>
<simpara>If you delete a <literal>ComplianceSuite</literal> object, then all the associated scans get deleted.</simpara>
</important>
<simpara>When the scan is complete, it generates the result as Custom Resources of the <literal>ComplianceCheckResult</literal> object. However, the raw results are available in ARF format. These results are stored in a Persistent Volume (PV), which has a Persistent Volume Claim (PVC) associated with the name of the scan.
You can programmatically fetch the <literal>ComplianceScans</literal> events. To generate events for the suite, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get events --field-selector involvedObject.kind=ComplianceScan,involvedObject.name=&lt;name of the suite&gt;</programlisting>
</section>
</section>
<section xml:id="view-compliance-results_compliance-crd">
<title>Viewing the compliance results</title>
<simpara>When the compliance suite reaches the <literal>DONE</literal> phase, you can view the scan results and possible remediations.</simpara>
<section xml:id="compliance-check-result_compliance-crd">
<title>ComplianceCheckResult object</title>
<simpara>When you run a scan with a specific profile, several rules in the profiles are verified. For each of these rules, a <literal>ComplianceCheckResult</literal> object is created, which provides the state of the cluster for a specific rule.</simpara>
<formalpara>
<title>Example <literal>ComplianceCheckResult</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceCheckResult
metadata:
  labels:
    compliance.openshift.io/check-severity: medium
    compliance.openshift.io/check-status: FAIL
    compliance.openshift.io/suite: example-compliancesuite
    compliance.openshift.io/scan-name: workers-scan
  name: workers-scan-no-direct-root-logins
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ComplianceScan
    name: workers-scan
description: &lt;description of scan check&gt;
instructions: &lt;manual instructions for the scan&gt;
id: xccdf_org.ssgproject.content_rule_no_direct_root_logins
severity: medium <co xml:id="CO28-1"/>
status: FAIL <co xml:id="CO28-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO28-1">
<para>Describes the severity of the scan check.</para>
</callout>
<callout arearefs="CO28-2">
<para>Describes the result of the check. The possible values are:</para>
<itemizedlist>
<listitem>
<simpara>PASS: check was successful.</simpara>
</listitem>
<listitem>
<simpara>FAIL: check was unsuccessful.</simpara>
</listitem>
<listitem>
<simpara>INFO: check was successful and found something not severe enough to be considered an error.</simpara>
</listitem>
<listitem>
<simpara>MANUAL: check cannot automatically assess the status and manual check is required.</simpara>
</listitem>
<listitem>
<simpara>INCONSISTENT: different nodes report different results.</simpara>
</listitem>
<listitem>
<simpara>ERROR: check run successfully, but could not complete.</simpara>
</listitem>
<listitem>
<simpara>NOTAPPLICABLE: check did not run as it is not applicable.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<simpara>To get all the check results from a suite, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get compliancecheckresults \
-l compliance.openshift.io/suite=workers-compliancesuite</programlisting>
</section>
<section xml:id="compliance-remediation-object_compliance-crd">
<title>ComplianceRemediation object</title>
<simpara>For a specific check you can have a datastream specified fix. However, if a Kubernetes fix is available, then the Compliance Operator creates a <literal>ComplianceRemediation</literal> object.</simpara>
<formalpara>
<title>Example <literal>ComplianceRemediation</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceRemediation
metadata:
  labels:
    compliance.openshift.io/suite: example-compliancesuite
    compliance.openshift.io/scan-name: workers-scan
    machineconfiguration.openshift.io/role: worker
  name: workers-scan-disable-users-coredumps
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ComplianceCheckResult
    name: workers-scan-disable-users-coredumps
    uid: &lt;UID&gt;
spec:
  apply: false <co xml:id="CO29-1"/>
  object:
    current: <co xml:id="CO29-2"/>
       apiVersion: machineconfiguration.openshift.io/v1
       kind: MachineConfig
       spec:
         config:
           ignition:
             version: 2.2.0
           storage:
             files:
             - contents:
                 source: data:,%2A%20%20%20%20%20hard%20%20%20core%20%20%20%200
               filesystem: root
               mode: 420
               path: /etc/security/limits.d/75-disable_users_coredumps.conf
    outdated: {} <co xml:id="CO29-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO29-1">
<para><literal>true</literal> indicates the remediation was applied. <literal>false</literal> indicates the remediation was not applied.</para>
</callout>
<callout arearefs="CO29-2">
<para>Includes the definition of the remediation.</para>
</callout>
<callout arearefs="CO29-3">
<para>Indicates remediation that was previously parsed from an earlier version of the content. The Compliance Operator still retains the outdated objects to give the administrator a chance to review the new remediations before applying them.</para>
</callout>
</calloutlist>
<simpara>To get all the remediations from a suite, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get complianceremediations \
-l compliance.openshift.io/suite=workers-compliancesuite</programlisting>
<simpara>To list all failing checks that can be remediated automatically, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get compliancecheckresults \
-l 'compliance.openshift.io/check-status in (FAIL),compliance.openshift.io/automated-remediation'</programlisting>
<simpara>To list all failing checks that can be remediated manually, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get compliancecheckresults \
-l 'compliance.openshift.io/check-status in (FAIL),!compliance.openshift.io/automated-remediation'</programlisting>
</section>
</section>
</section>
</section>
<section xml:id="_compliance_operator_management_2">
<title>Compliance Operator management</title>
<section xml:id="compliance-operator-installation">
<title>Installing the Compliance Operator</title>

<simpara>Before you can use the Compliance Operator, you must ensure it is deployed in the cluster.</simpara>
<important>
<simpara>The Compliance Operator might report incorrect results on managed platforms, such as OpenShift Dedicated, Red Hat OpenShift Service on AWS, and Microsoft Azure Red Hat OpenShift. For more information, see the <link xlink:href="https://access.redhat.com/solutions/6983418">Red Hat Knowledgebase Solution #6983418</link>.</simpara>
</important>
<section xml:id="installing-compliance-operator-web-console_compliance-operator-installation">
<title>Installing the Compliance Operator through the web console</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Search for the Compliance Operator, then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Keep the default selection of <emphasis role="strong">Installation mode</emphasis> and <emphasis role="strong">namespace</emphasis> to ensure that the Operator will be installed to the <literal>openshift-compliance</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To confirm that the installation is successful:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Check that the Compliance Operator is installed in the <literal>openshift-compliance</literal> namespace and its status is <literal>Succeeded</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If the Operator is not installed successfully:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <literal>Status</literal> column for any errors or failures.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs in any pods in the <literal>openshift-compliance</literal> project that are reporting issues.</simpara>
</listitem>
</orderedlist>
<important>
<simpara>If the <literal>restricted</literal> Security Context Constraints (SCC) have been modified to contain the <literal>system:authenticated</literal> group or has added <literal>requiredDropCapabilities</literal>, the Compliance Operator may not function properly due to permissions issues.</simpara>
<simpara>You can create a custom SCC for the Compliance Operator scanner pod service account. For more information, see <link xlink:href="../../../security/compliance_operator/co-scans/compliance-operator-advanced.xml#compliance-custom-scc_compliance-advanced">Creating a custom SCC for the Compliance Operator</link>.</simpara>
</important>
</section>
<section xml:id="installing-compliance-operator-cli_compliance-operator-installation">
<title>Installing the Compliance Operator using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a <literal>Namespace</literal> object:</simpara>
<formalpara>
<title>Example <literal>namespace-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  labels:
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: privileged <co xml:id="CO30-1"/>
  name: openshift-compliance</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO30-1">
<para>In OpenShift Container Platform 4.14, the pod security label must be set to <literal>privileged</literal> at the namespace level.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f namespace-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> object:</simpara>
<formalpara>
<title>Example <literal>operator-group-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: compliance-operator
  namespace: openshift-compliance
spec:
  targetNamespaces:
  - openshift-compliance</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f operator-group-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a <literal>Subscription</literal> object:</simpara>
<formalpara>
<title>Example <literal>subscription-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: compliance-operator-sub
  namespace: openshift-compliance
spec:
  channel: "stable"
  installPlanApproval: Automatic
  name: compliance-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f subscription-object.yaml</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>If you are setting the global scheduler feature and enable <literal>defaultNodeSelector</literal>, you must create the namespace manually and update the annotations of the <literal>openshift-compliance</literal> namespace, or the namespace where the Compliance Operator was installed, with <literal>openshift.io/node-selector: “”</literal>. This removes the default node selector and prevents deployment failures.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the installation succeeded by inspecting the CSV file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Verify that the Compliance Operator is up and running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n openshift-compliance</programlisting>
</listitem>
</orderedlist>
<important>
<simpara>If the <literal>restricted</literal> Security Context Constraints (SCC) have been modified to contain the <literal>system:authenticated</literal> group or has added <literal>requiredDropCapabilities</literal>, the Compliance Operator may not function properly due to permissions issues.</simpara>
<simpara>You can create a custom SCC for the Compliance Operator scanner pod service account. For more information, see <link xlink:href="../../../security/compliance_operator/co-scans/compliance-operator-advanced.xml#compliance-custom-scc_compliance-advanced">Creating a custom SCC for the Compliance Operator</link>.</simpara>
</important>
</section>
<section xml:id="installing-compliance-operator-hcp_compliance-operator-installation">
<title>Installing the Compliance Operator on Hosted control planes</title>
<simpara>The Compliance Operator can be installed in Hosted control planes using the OperatorHub by creating a <literal>Subscription</literal> file.</simpara>
<important>
<simpara>Hosted control planes is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a <literal>Namespace</literal> object similar to the following:</simpara>
<formalpara>
<title>Example <literal>namespace-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  labels:
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: privileged <co xml:id="CO31-1"/>
  name: openshift-compliance</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO31-1">
<para>In OpenShift Container Platform 4.14, the pod security label must be set to <literal>privileged</literal> at the namespace level.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f namespace-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> object:</simpara>
<formalpara>
<title>Example <literal>operator-group-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: compliance-operator
  namespace: openshift-compliance
spec:
  targetNamespaces:
  - openshift-compliance</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f operator-group-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a <literal>Subscription</literal> object:</simpara>
<formalpara>
<title>Example <literal>subscription-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: compliance-operator-sub
  namespace: openshift-compliance
spec:
  channel: "stable"
  installPlanApproval: Automatic
  name: compliance-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  config:
    nodeSelector:
      node-role.kubernetes.io/worker: ""
    env:
    - name: PLATFORM
      value: "HyperShift"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f subscription-object.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the installation succeeded by inspecting the CSV file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Verify that the Compliance Operator is up and running by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n openshift-compliance</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../../hosted_control_planes/index.xml#hcp-overview">Hosted control planes overview</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources-installing-the-compliance-operator" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator is supported in a restricted network environment. For more information, see <link xlink:href="../../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-updating">
<title>Updating the Compliance Operator</title>

<simpara>As a cluster administrator, you can update the Compliance Operator on your OpenShift Container Platform cluster.</simpara>
<section xml:id="olm-preparing-upgrade_compliance-operator-updating">
<title>Preparing for an Operator update</title>
<simpara>The subscription of an installed Operator specifies an update channel that tracks and receives updates for the Operator. You can change the update channel to start tracking and receiving updates from a newer channel.</simpara>
<simpara>The names of update channels in a subscription can differ between Operators, but the naming scheme typically follows a common convention within a given Operator. For example, channel names might follow a minor release update stream for the application provided by the Operator (<literal>1.2</literal>, <literal>1.3</literal>) or a release frequency (<literal>stable</literal>, <literal>fast</literal>).</simpara>
<note>
<simpara>You cannot change installed Operators to a channel that is older than the current channel.</simpara>
</note>
<simpara>Red Hat Customer Portal Labs include the following application that helps administrators prepare to update their Operators:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/labs/ocpouic/">Red Hat OpenShift Container Platform Operator Update Information Checker</link></simpara>
</listitem>
</itemizedlist>
<simpara>You can use the application to search for Operator Lifecycle Manager-based Operators and verify the available Operator version per update channel across different versions of OpenShift Container Platform. Cluster Version Operator-based Operators are not included.</simpara>
</section>
<section xml:id="olm-changing-update-channel_compliance-operator-updating">
<title>Changing the update channel for an Operator</title>
<simpara>You can change the update channel for an Operator by using the OpenShift Container Platform web console.</simpara>
<tip>
<simpara>If the approval strategy in the subscription is set to <emphasis role="strong">Automatic</emphasis>, the update process initiates as soon as a new Operator version is available in the selected channel. If the approval strategy is set to <emphasis role="strong">Manual</emphasis>, you must manually approve pending updates.</simpara>
</tip>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the Operator you want to change the update channel for.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the update channel under <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the newer update channel that you want to change to, then click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>For subscriptions with an <emphasis role="strong">Automatic</emphasis> approval strategy, the update begins automatically. Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
<simpara>For subscriptions with a <emphasis role="strong">Manual</emphasis> approval strategy, you can manually approve the update from the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-approving-pending-upgrade_compliance-operator-updating">
<title>Manually approving a pending Operator update</title>
<simpara>If an installed Operator has the approval strategy in its subscription set to <emphasis role="strong">Manual</emphasis>, when new updates are released in its current update channel, the update must be manually approved before installation can begin.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Operators that have a pending update display a status with <emphasis role="strong">Upgrade available</emphasis>. Click the name of the Operator you want to update.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab. Any updates requiring approval are displayed next to <emphasis role="strong">Upgrade status</emphasis>. For example, it might display <emphasis role="strong">1 requires approval</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">1 requires approval</emphasis>, then click <emphasis role="strong">Preview Install Plan</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Review the resources that are listed as available for update. When satisfied, click <emphasis role="strong">Approve</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="compliance-operator-understanding">
<title>Managing the Compliance Operator</title>

<simpara>This section describes the lifecycle of security content, including how to use an updated version of compliance content and how to create a custom <literal>ProfileBundle</literal> object.</simpara>
<section xml:id="compliance-profilebundle_managing-compliance">
<title>ProfileBundle CR example</title>
<simpara>The <literal>ProfileBundle</literal> object requires two pieces of information: the URL of a container image that contains the <literal>contentImage</literal> and the file that contains the compliance content. The <literal>contentFile</literal> parameter is relative to the root of the file system. You can define the built-in <literal>rhcos4</literal> <literal>ProfileBundle</literal> object as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ProfileBundle
metadata:
  creationTimestamp: "2022-10-19T12:06:30Z"
  finalizers:
  - profilebundle.finalizers.compliance.openshift.io
  generation: 1
  name: rhcos4
  namespace: openshift-compliance
  resourceVersion: "46741"
  uid: 22350850-af4a-4f5c-9a42-5e7b68b82d7d
spec:
  contentFile: ssg-rhcos4-ds.xml <co xml:id="CO32-1"/>
  contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:900e... <co xml:id="CO32-2"/>
status:
  conditions:
  - lastTransitionTime: "2022-10-19T12:07:51Z"
    message: Profile bundle successfully parsed
    reason: Valid
    status: "True"
    type: Ready
  dataStreamStatus: VALID</programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>Location of the file containing the compliance content.</para>
</callout>
<callout arearefs="CO32-2">
<para>Content image location.</para>
<important>
<simpara>The base image used for the content images must include <literal>coreutils</literal>.</simpara>
</important>
</callout>
</calloutlist>
</section>
<section xml:id="compliance-update_managing-compliance">
<title>Updating security content</title>
<simpara>Security content is included as container images that the <literal>ProfileBundle</literal> objects refer to. To accurately track updates to <literal>ProfileBundles</literal> and the custom resources parsed from the bundles such as rules or profiles, identify the container image with the compliance content using a digest instead of a tag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance get profilebundles rhcos4 -oyaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ProfileBundle
metadata:
  creationTimestamp: "2022-10-19T12:06:30Z"
  finalizers:
  - profilebundle.finalizers.compliance.openshift.io
  generation: 1
  name: rhcos4
  namespace: openshift-compliance
  resourceVersion: "46741"
  uid: 22350850-af4a-4f5c-9a42-5e7b68b82d7d
spec:
  contentFile: ssg-rhcos4-ds.xml
  contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:900e... <co xml:id="CO33-1"/>
status:
  conditions:
  - lastTransitionTime: "2022-10-19T12:07:51Z"
    message: Profile bundle successfully parsed
    reason: Valid
    status: "True"
    type: Ready
  dataStreamStatus: VALID</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO33-1">
<para>Security container image.</para>
</callout>
</calloutlist>
<simpara>Each <literal>ProfileBundle</literal> is backed by a deployment. When the Compliance Operator detects that the container image digest has changed, the deployment is updated to reflect the change and parse the content again. Using the digest instead of a tag ensures that you use a stable and predictable set of profiles.</simpara>
</section>
<section xml:id="additional-resources_managing-the-compliance-operator" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator is supported in a restricted network environment. For more information, see <link xlink:href="../../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-uninstallation">
<title>Uninstalling the Compliance Operator</title>

<simpara>You can remove the OpenShift Compliance Operator from your cluster by using the OpenShift Container Platform web console or the CLI.</simpara>
<section xml:id="compliance-operator-uninstall_compliance-operator-uninstallation">
<title>Uninstalling the OpenShift Compliance Operator from OpenShift Container Platform using the web console</title>
<simpara>To remove the Compliance Operator, you must first delete the objects in the namespace. After the objects are removed, you can remove the Operator and its namespace by deleting the <emphasis role="strong">openshift-compliance</emphasis> project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an OpenShift Container Platform cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Compliance Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To remove the Compliance Operator by using the OpenShift Container Platform web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Go to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> &#8594; <emphasis role="strong">Compliance Operator</emphasis> page.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">All instances</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In <emphasis role="strong">All namespaces</emphasis>, click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> and delete all ScanSettingBinding, ComplainceSuite, ComplianceScan, and ProfileBundle objects.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> on the <emphasis role="strong">Compliance Operator</emphasis> entry and select <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Search for 'compliance'.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">openshift-compliance</emphasis> project, and select <emphasis role="strong">Delete Project</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Confirm the deletion by typing <literal>openshift-compliance</literal> in the dialog box, and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="compliance-operator-uninstall-cli_compliance-operator-uninstallation">
<title>Uninstalling the OpenShift Compliance Operator from OpenShift Container Platform using the CLI</title>
<simpara>To remove the Compliance Operator, you must first delete the objects in the namespace. After the objects are removed, you can remove the Operator and its namespace by deleting the <emphasis role="strong">openshift-compliance</emphasis> project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an OpenShift Container Platform cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Compliance Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Delete all objects in the namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the <literal>ScanSettingBinding</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete ssb --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>ScanSetting</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete ss --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>ComplianceSuite</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete suite --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>ComplianceScan</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete scan --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>ProfileBundle</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete profilebundle.compliance --all -n openshift-compliance</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the Subscription object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete sub --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the CSV object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete csv --all -n openshift-compliance</programlisting>
</listitem>
<listitem>
<simpara>Delete the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">project.project.openshift.io "openshift-compliance" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Confirm the namespace is deleted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get project/openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error from server (NotFound): namespaces "openshift-compliance" not found</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="_compliance_operator_scan_management_2">
<title>Compliance Operator scan management</title>
<section xml:id="compliance-operator-supported-profiles">
<title>Supported compliance profiles</title>
<simpara>There are several profiles available as part of the Compliance Operator (CO) installation. While you can use the following profiles to assess gaps in a cluster, usage alone does not infer or guarantee compliance with a particular profile.</simpara>
<important>
<simpara>The Compliance Operator might report incorrect results on managed platforms, such as OpenShift Dedicated, Red Hat OpenShift Service on AWS, and Azure Red Hat OpenShift. For more information, see the <link xlink:href="https://access.redhat.com/solutions/6983418">Red Hat Knowledgebase Solution #6983418</link>.</simpara>
</important>
<section xml:id="compliance-supported-profiles_compliance-operator-supported-profiles">
<title>Compliance profiles</title>
<simpara>The Compliance Operator provides the following compliance profiles:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported compliance profiles</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="8.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="8.3333*"/>
<colspec colname="col_4" colwidth="8.3333*"/>
<colspec colname="col_5" colwidth="33.3333*"/>
<colspec colname="col_6" colwidth="8.3335*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Profile title</entry>
<entry align="left" valign="top">Application</entry>
<entry align="left" valign="top">Compliance Operator version</entry>
<entry align="left" valign="top">Industry compliance benchmark</entry>
<entry align="left" valign="top">Supported architectures</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>rhcos4-stig</simpara></entry>
<entry align="left" valign="top"><simpara>Defense Information Systems Agency Security Technical Implementation Guide (DISA STIG) for Red Hat Openshift</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>1.3.0+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://public.cyber.mil/stigs/downloads/">DISA-STIG</link> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-stig-node</simpara></entry>
<entry align="left" valign="top"><simpara>Defense Information Systems Agency Security Technical Implementation Guide (DISA STIG) for Red Hat Openshift</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>1.3.0+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://public.cyber.mil/stigs/downloads/">DISA-STIG</link> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-stig</simpara></entry>
<entry align="left" valign="top"><simpara>Defense Information Systems Agency Security Technical Implementation Guide (DISA STIG) for Red Hat Openshift</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>1.3.0+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://public.cyber.mil/stigs/downloads/">DISA-STIG</link> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-cis</simpara></entry>
<entry align="left" valign="top"><simpara>CIS Red Hat OpenShift Container Platform 4 Benchmark v1.4.0</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>1.2.0+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.cisecurity.org/cis-benchmarks/">CIS Benchmarks &#8482;</link> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal>
 <literal>s390x</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-cis-node</simpara></entry>
<entry align="left" valign="top"><simpara>CIS Red Hat OpenShift Container Platform 4 Benchmark v1.4.0</simpara></entry>
<entry align="left" valign="top"><simpara>Node <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>1.2.0+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.cisecurity.org/cis-benchmarks/">CIS Benchmarks &#8482;</link> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal>
 <literal>s390x</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-e8</simpara></entry>
<entry align="left" valign="top"><simpara>Australian Cyber Security Centre (ACSC) Essential Eight</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.39+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.cyber.gov.au/acsc/view-all-content/publications/hardening-linux-workstations-and-servers">ACSC Hardening Linux Workstations and Servers</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-moderate</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 Moderate-Impact Baseline for Red Hat OpenShift - Platform level</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.39+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://nvd.nist.gov/800-53/Rev4/impact/moderate">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal>
 <literal>s390x</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rhcos4-e8</simpara></entry>
<entry align="left" valign="top"><simpara>Australian Cyber Security Centre (ACSC) Essential Eight</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.39+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.cyber.gov.au/acsc/view-all-content/publications/hardening-linux-workstations-and-servers">ACSC Hardening Linux Workstations and Servers</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rhcos4-moderate</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 Moderate-Impact Baseline for Red Hat Enterprise Linux CoreOS</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.39+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://nvd.nist.gov/800-53/Rev4/impact/moderate">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-moderate-node</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 Moderate-Impact Baseline for Red Hat OpenShift - Node level</simpara></entry>
<entry align="left" valign="top"><simpara>Node <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>0.1.44+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://nvd.nist.gov/800-53/Rev4/impact/moderate">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal>
 <literal>s390x</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-nerc-cip</simpara></entry>
<entry align="left" valign="top"><simpara>North American Electric Reliability Corporation (NERC) Critical Infrastructure Protection (CIP) cybersecurity standards profile for the Red Hat OpenShift Container Platform - Platform level</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.44+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.nerc.com/pa/Stand/Pages/USRelStand.aspx">NERC CIP Standards</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-nerc-cip-node</simpara></entry>
<entry align="left" valign="top"><simpara>North American Electric Reliability Corporation (NERC) Critical Infrastructure Protection (CIP) cybersecurity standards profile for the Red Hat OpenShift Container Platform - Node level</simpara></entry>
<entry align="left" valign="top"><simpara>Node <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>0.1.44+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.nerc.com/pa/Stand/Pages/USRelStand.aspx">NERC CIP Standards</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rhcos4-nerc-cip</simpara></entry>
<entry align="left" valign="top"><simpara>North American Electric Reliability Corporation (NERC) Critical Infrastructure Protection (CIP) cybersecurity standards profile for Red Hat Enterprise Linux CoreOS</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.44+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.nerc.com/pa/Stand/Pages/USRelStand.aspx">NERC CIP Standards</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-pci-dss</simpara></entry>
<entry align="left" valign="top"><simpara>PCI-DSS v3.2.1 Control Baseline for Red Hat OpenShift Container Platform 4</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.47+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.pcisecuritystandards.org/document_library?document=pci_dss">PCI Security Standards &#174; Council Document Library</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-pci-dss-node</simpara></entry>
<entry align="left" valign="top"><simpara>PCI-DSS v3.2.1 Control Baseline for Red Hat OpenShift Container Platform 4</simpara></entry>
<entry align="left" valign="top"><simpara>Node <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>0.1.47+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.pcisecuritystandards.org/document_library?document=pci_dss">PCI Security Standards &#174; Council Document Library</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal>
 <literal>ppc64le</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-high</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 High-Impact Baseline for Red Hat OpenShift - Platform level</simpara></entry>
<entry align="left" valign="top"><simpara>Platform</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.52+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://csrc.nist.gov/Projects/risk-management/sp800-53-controls/release-search#!/800-53">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-high-node</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 High-Impact Baseline for Red Hat OpenShift - Node level</simpara></entry>
<entry align="left" valign="top"><simpara>Node <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>0.1.52+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://csrc.nist.gov/Projects/risk-management/sp800-53-controls/release-search#!/800-53">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rhcos4-high</simpara></entry>
<entry align="left" valign="top"><simpara>NIST 800-53 High-Impact Baseline for Red Hat Enterprise Linux CoreOS</simpara></entry>
<entry align="left" valign="top"><simpara>Node</simpara></entry>
<entry align="left" valign="top"><simpara>0.1.52+</simpara></entry>
<entry align="left" valign="top"><simpara><link xlink:href="https://csrc.nist.gov/Projects/risk-management/sp800-53-controls/release-search#!/800-53">NIST SP-800-53 Release Search</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>x86_64</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist role="small" numeration="arabic">
<listitem>
<simpara>To locate the CIS OpenShift Container Platform v4 Benchmark, go to  <link xlink:href="https://www.cisecurity.org/benchmark/kubernetes">CIS Benchmarks</link> and click <emphasis role="strong">Download Latest CIS Benchmark</emphasis>, where you can then register to download the benchmark.</simpara>
</listitem>
<listitem>
<simpara>Node profiles must be used with the relevant Platform profile. For more information, see <emphasis>Compliance Operator profile types</emphasis>.</simpara>
</listitem>
</orderedlist>
<section xml:id="compliance-extended-profiles_compliance-operator-supported-profiles">
<title>About extended compliance profiles</title>
<simpara>Some compliance profiles have controls that require following industry best practices, resulting in some profiles extending others. Combining the Center for Internet Security (CIS) best practices with National Institute of Standards and Technology (NIST) security frameworks establishes a path to a secure and compliant environment.</simpara>
<simpara>For example, the NIST High-Impact and Moderate-Impact profiles extend the CIS profile to achieve compliance. As a result, extended compliance profiles eliminate the need to run both profiles in a single cluster.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Profile extensions</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Extends</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ocp4-pci-dss</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-pci-dss-node</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis-node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-high</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-high-node</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis-node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-moderate</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-moderate-node</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-cis-node</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-nerc-cip</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-moderate</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ocp4-nerc-cip-node</simpara></entry>
<entry align="left" valign="top"><simpara>ocp4-moderate-node</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="additional-resources-compliance-operator-" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../../security/compliance_operator/co-concepts/compliance-operator-understanding.html#compliance_profile_types_understanding-compliance">Compliance Operator profile types</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-scans">
<title>Compliance Operator scans</title>

<simpara>The <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> APIs are recommended to run compliance scans with the Compliance Operator. For more information on these API objects, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain scansettings</programlisting>
<simpara>or</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain scansettingbindings</programlisting>
<section xml:id="running-compliance-scans_compliance-operator-scans">
<title>Running compliance scans</title>
<simpara>You can run a scan using the Center for Internet Security (CIS) profiles. For convenience, the Compliance Operator creates a <literal>ScanSetting</literal> object with reasonable defaults on startup. This <literal>ScanSetting</literal> object is named <literal>default</literal>.</simpara>
<note>
<simpara>For all-in-one control plane and worker nodes, the compliance scan runs twice on the worker and control plane nodes. The compliance scan might generate inconsistent scan results. You can avoid inconsistent results by defining only a single role in the <literal>ScanSetting</literal> object.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Inspect the <literal>ScanSetting</literal> object by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe scansettings default -n openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">Name:         default
Namespace:    openshift-compliance
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  compliance.openshift.io/v1alpha1
Kind:         ScanSetting
Metadata:
  Creation Timestamp:  2022-10-10T14:07:29Z
  Generation:          1
  Managed Fields:
    API Version:  compliance.openshift.io/v1alpha1
    Fields Type:  FieldsV1
    fieldsV1:
      f:rawResultStorage:
        .:
        f:nodeSelector:
          .:
          f:node-role.kubernetes.io/master:
        f:pvAccessModes:
        f:rotation:
        f:size:
        f:tolerations:
      f:roles:
      f:scanTolerations:
      f:schedule:
      f:showNotApplicable:
      f:strictNodeScan:
    Manager:         compliance-operator
    Operation:       Update
    Time:            2022-10-10T14:07:29Z
  Resource Version:  56111
  UID:               c21d1d14-3472-47d7-a450-b924287aec90
Raw Result Storage:
  Node Selector:
    node-role.kubernetes.io/master:
  Pv Access Modes:
    ReadWriteOnce <co xml:id="CO34-1"/>
  Rotation:  3 <co xml:id="CO34-2"/>
  Size:      1Gi <co xml:id="CO34-3"/>
  Tolerations:
    Effect:              NoSchedule
    Key:                 node-role.kubernetes.io/master
    Operator:            Exists
    Effect:              NoExecute
    Key:                 node.kubernetes.io/not-ready
    Operator:            Exists
    Toleration Seconds:  300
    Effect:              NoExecute
    Key:                 node.kubernetes.io/unreachable
    Operator:            Exists
    Toleration Seconds:  300
    Effect:              NoSchedule
    Key:                 node.kubernetes.io/memory-pressure
    Operator:            Exists
Roles:
  master <co xml:id="CO34-4"/>
  worker <co xml:id="CO34-5"/>
Scan Tolerations: <co xml:id="CO34-6"/>
  Operator:           Exists
Schedule:             0 1 * * * <co xml:id="CO34-7"/>
Show Not Applicable:  false
Strict Node Scan:     true
Events:               &lt;none&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>The Compliance Operator creates a persistent volume (PV) that contains the results of the scans. By default, the PV will use access mode <literal>ReadWriteOnce</literal> because the Compliance Operator cannot make any assumptions about the storage classes configured on the cluster. Additionally, <literal>ReadWriteOnce</literal> access mode is available on most clusters. If you need to fetch the scan results, you can do so by using a helper pod, which also binds the volume. Volumes that use the <literal>ReadWriteOnce</literal> access mode can be mounted by only one pod at time, so it is important to remember to delete the helper pods. Otherwise, the Compliance Operator will not be able to reuse the volume for subsequent scans.</para>
</callout>
<callout arearefs="CO34-2">
<para>The Compliance Operator keeps results of three subsequent scans in the volume; older scans are rotated.</para>
</callout>
<callout arearefs="CO34-3">
<para>The Compliance Operator will allocate one GB of storage for the scan results.</para>
</callout>
<callout arearefs="CO34-4 CO34-5">
<para>If the scan setting uses any profiles that scan cluster nodes, scan these node roles.</para>
</callout>
<callout arearefs="CO34-6">
<para>The default scan setting object scans all the nodes.</para>
</callout>
<callout arearefs="CO34-7">
<para>The default scan setting object runs scans at 01:00 each day.</para>
</callout>
</calloutlist>
<simpara>As an alternative to the default scan setting, you can use <literal>default-auto-apply</literal>, which has the following settings:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">Name:                      default-auto-apply
Namespace:                 openshift-compliance
Labels:                    &lt;none&gt;
Annotations:               &lt;none&gt;
API Version:               compliance.openshift.io/v1alpha1
Auto Apply Remediations:   true <co xml:id="CO35-1"/>
Auto Update Remediations:  true <co xml:id="CO35-2"/>
Kind:                      ScanSetting
Metadata:
  Creation Timestamp:  2022-10-18T20:21:00Z
  Generation:          1
  Managed Fields:
    API Version:  compliance.openshift.io/v1alpha1
    Fields Type:  FieldsV1
    fieldsV1:
      f:autoApplyRemediations:
      f:autoUpdateRemediations:
      f:rawResultStorage:
        .:
        f:nodeSelector:
          .:
          f:node-role.kubernetes.io/master:
        f:pvAccessModes:
        f:rotation:
        f:size:
        f:tolerations:
      f:roles:
      f:scanTolerations:
      f:schedule:
      f:showNotApplicable:
      f:strictNodeScan:
    Manager:         compliance-operator
    Operation:       Update
    Time:            2022-10-18T20:21:00Z
  Resource Version:  38840
  UID:               8cb0967d-05e0-4d7a-ac1c-08a7f7e89e84
Raw Result Storage:
  Node Selector:
    node-role.kubernetes.io/master:
  Pv Access Modes:
    ReadWriteOnce
  Rotation:  3
  Size:      1Gi
  Tolerations:
    Effect:              NoSchedule
    Key:                 node-role.kubernetes.io/master
    Operator:            Exists
    Effect:              NoExecute
    Key:                 node.kubernetes.io/not-ready
    Operator:            Exists
    Toleration Seconds:  300
    Effect:              NoExecute
    Key:                 node.kubernetes.io/unreachable
    Operator:            Exists
    Toleration Seconds:  300
    Effect:              NoSchedule
    Key:                 node.kubernetes.io/memory-pressure
    Operator:            Exists
Roles:
  master
  worker
Scan Tolerations:
  Operator:           Exists
Schedule:             0 1 * * *
Show Not Applicable:  false
Strict Node Scan:     true
Events:               &lt;none&gt;</programlisting>
<calloutlist>
<callout arearefs="CO35-1 CO35-2">
<para>Setting <literal>autoUpdateRemediations</literal> and <literal>autoApplyRemediations</literal> flags to <literal>true</literal> allows you to easily create <literal>ScanSetting</literal> objects that auto-remediate without extra steps.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>ScanSettingBinding</literal> object that binds to the default <literal>ScanSetting</literal> object and scans the cluster using the <literal>cis</literal> and <literal>cis-node</literal> profiles. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
  name: cis-compliance
  namespace: openshift-compliance
profiles:
  - name: ocp4-cis-node
    kind: Profile
    apiGroup: compliance.openshift.io/v1alpha1
  - name: ocp4-cis
    kind: Profile
    apiGroup: compliance.openshift.io/v1alpha1
settingsRef:
  name: default
  kind: ScanSetting
  apiGroup: compliance.openshift.io/v1alpha1</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>ScanSettingBinding</literal> object by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml -n openshift-compliance</programlisting>
<simpara>At this point in the process, the <literal>ScanSettingBinding</literal> object is reconciled and based on the <literal>Binding</literal> and the <literal>Bound</literal> settings. The Compliance Operator creates a <literal>ComplianceSuite</literal> object and the associated <literal>ComplianceScan</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>Follow the compliance scan progress by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get compliancescan -w -n openshift-compliance</programlisting>
<simpara>The scans progress through the scanning phases and eventually reach the <literal>DONE</literal> phase when complete. In most cases, the result of the scan is <literal>NON-COMPLIANT</literal>. You can review the scan results and start applying remediations to make the cluster compliant. See <emphasis>Managing Compliance Operator remediation</emphasis> for more information.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="running-compliance-scans-worker-node_compliance-operator-scans">
<title>Scheduling the result server pod on a worker node</title>
<simpara>The result server pod mounts the persistent volume (PV) that stores the raw Asset Reporting Format (ARF) scan results. The <literal>nodeSelector</literal> and <literal>tolerations</literal> attributes enable you to configure the location of the result server pod.</simpara>
<simpara>This is helpful for those environments where control plane nodes are not permitted to mount persistent volumes.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>ScanSetting</literal> custom resource (CR) for the Compliance Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define the <literal>ScanSetting</literal> CR, and save the YAML file, for example, <literal>rs-workers.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  name: rs-on-workers
  namespace: openshift-compliance
rawResultStorage:
  nodeSelector:
    node-role.kubernetes.io/worker: "" <co xml:id="CO36-1"/>
  pvAccessModes:
  - ReadWriteOnce
  rotation: 3
  size: 1Gi
  tolerations:
  - operator: Exists <co xml:id="CO36-2"/>
roles:
- worker
- master
scanTolerations:
  - operator: Exists
schedule: 0 1 * * *</programlisting>
<calloutlist>
<callout arearefs="CO36-1">
<para>The Compliance Operator uses this node to store scan results in ARF format.</para>
</callout>
<callout arearefs="CO36-2">
<para>The result server pod tolerates all taints.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To create the <literal>ScanSetting</literal> CR, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f rs-workers.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the <literal>ScanSetting</literal> object is created, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scansettings rs-on-workers -n openshift-compliance -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  creationTimestamp: "2021-11-19T19:36:36Z"
  generation: 1
  name: rs-on-workers
  namespace: openshift-compliance
  resourceVersion: "48305"
  uid: 43fdfc5f-15a7-445a-8bbc-0e4a160cd46e
rawResultStorage:
  nodeSelector:
    node-role.kubernetes.io/worker: ""
  pvAccessModes:
  - ReadWriteOnce
  rotation: 3
  size: 1Gi
  tolerations:
  - operator: Exists
roles:
- worker
- master
scanTolerations:
- operator: Exists
schedule: 0 1 * * *
strictNodeScan: true</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-scansetting-cr_compliance-operator-scans">
<title><literal>ScanSetting</literal> Custom Resource</title>
<simpara>The <literal>ScanSetting</literal> Custom Resource now allows you to override the default CPU and memory limits of scanner pods through the scan limits attribute. The Compliance Operator will use defaults of 500Mi memory, 100m CPU for the scanner container, and 200Mi memory with 100m CPU for the <literal>api-resource-collector</literal> container. To set the memory limits of the Operator, modify the <literal>Subscription</literal> object if installed through OLM or the Operator deployment itself.</simpara>
<simpara>To increase the default CPU and memory limits of the Compliance Operator, see <emphasis>Increasing Compliance Operator resource limits</emphasis>.</simpara>
<important>
<simpara>Increasing the memory limit for the Compliance Operator or the scanner pods is needed if the default limits are not sufficient and the Operator or scanner pods are ended by the Out Of Memory (OOM) process.</simpara>
</important>
</section>
<section xml:id="co-hcp-mgmt-config_compliance-operator-scans">
<title>Configuring the Hosted control planes management cluster</title>
<simpara>If you are hosting your own Hosted control plane or Hypershift environment and want to scan a Hosted Cluster from the management cluster, you will need to set the name and prefix namespace for the target Hosted Cluster. You can achieve this by creating a <literal>TailoredProfile</literal>.</simpara>
<important>
<simpara>This procedure only applies to users managing their own Hosted control planes environment.</simpara>
</important>
<note>
<simpara>Only <literal>ocp4-cis</literal> and <literal>ocp4-pci-dss</literal> profiles are supported in Hosted control planes management clusters.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Compliance Operator is installed in the management cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Obtain the <literal>name</literal> and <literal>namespace</literal> of the hosted cluster to be scanned by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get hostedcluster -A</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE       NAME                   VERSION   KUBECONFIG                              PROGRESS    AVAILABLE   PROGRESSING   MESSAGE
local-cluster   79136a1bdb84b3c13217   4.13.5    79136a1bdb84b3c13217-admin-kubeconfig   Completed   True        False         The hosted control plane is available</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>In the management cluster, create a <literal>TailoredProfile</literal> extending the scan Profile and define the name and namespace of the Hosted Cluster to be scanned:</simpara>
<formalpara>
<title>Example <literal>management-tailoredprofile.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
  name: hypershift-cisk57aw88gry
  namespace: openshift-compliance
spec:
  description: This profile test required rules
  extends: ocp4-cis <co xml:id="CO37-1"/>
  title: Management namespace profile
  setValues:
  - name: ocp4-hypershift-cluster
    rationale: This value is used for HyperShift version detection
    value: 79136a1bdb84b3c13217 <co xml:id="CO37-2"/>
  - name: ocp4-hypershift-namespace-prefix
    rationale: This value is used for HyperShift control plane namespace detection
    value: local-cluster <co xml:id="CO37-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO37-1">
<para>Variable. Only <literal>ocp4-cis</literal> and <literal>ocp4-pci-dss</literal> profiles are supported in Hosted control planes management clusters.</para>
</callout>
<callout arearefs="CO37-2">
<para>The <literal>value</literal> is the <literal>NAME</literal> from the output in the previous step.</para>
</callout>
<callout arearefs="CO37-3">
<para>The <literal>value</literal> is the <literal>NAMESPACE</literal> from the output in the previous step.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>TailoredProfile</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-compliance -f mgmt-tp.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="compliance-applying-resource-requests-and-limits_compliance-operator-scans">
<title>Applying resource requests and limits</title>
<simpara>When the kubelet starts a container as part of a Pod, the kubelet passes that container&#8217;s requests and limits for memory and CPU to the container runtime. In Linux, the container runtime configures the kernel cgroups that apply and enforce the limits you defined.</simpara>
<simpara>The CPU limit defines how much CPU time the container can use. During each scheduling interval, the Linux kernel checks to see if this limit is exceeded. If so, the kernel waits before allowing the cgroup to resume execution.</simpara>
<simpara>If several different containers (cgroups) want to run on a contended system, workloads with larger CPU requests are allocated more CPU time than workloads with small requests. The memory request is used during Pod scheduling. On a node that uses cgroups v2, the container runtime might use the memory request as a hint to set <literal>memory.min</literal> and <literal>memory.low</literal> values.</simpara>
<simpara>If a container attempts to allocate more memory than this limit, the Linux kernel out-of-memory subsystem activates and intervenes by stopping one of the processes in the container that tried to allocate memory. The memory limit for the Pod or container can also apply to pages in memory-backed volumes, such as an emptyDir.</simpara>
<simpara>The kubelet tracks <literal>tmpfs</literal> <literal>emptyDir</literal> volumes as container memory is used, rather than as local ephemeral storage. If a container exceeds its memory request and the node that it runs on becomes short of memory overall, the Pod&#8217;s container might be evicted.</simpara>
<important>
<simpara>A container may not exceed its CPU limit for extended periods. Container run times do not stop Pods or containers for excessive CPU usage. To determine whether a container cannot be scheduled or is being killed due to resource limits, see <emphasis>Troubleshooting the Compliance Operator</emphasis>.</simpara>
</important>
</section>
<section xml:id="compliance-scheduling-pods-with-resource-requests_compliance-operator-scans">
<title>Scheduling Pods with container resource requests</title>
<simpara>When a Pod is created, the scheduler selects a Node for the Pod to run on. Each node has a maximum capacity for each resource type in the amount of CPU and memory it can provide for the Pods. The scheduler ensures that the sum of the resource requests of the scheduled containers is less than the capacity nodes for each resource type.</simpara>
<simpara>Although memory or CPU resource usage on nodes is very low, the scheduler might still refuse to place a Pod on a node if the capacity check fails to protect against a resource shortage on a node.</simpara>
<simpara>For each container, you can specify the following resource limits and request:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">spec.containers[].resources.limits.cpu
spec.containers[].resources.limits.memory
spec.containers[].resources.limits.hugepages-&lt;size&gt;
spec.containers[].resources.requests.cpu
spec.containers[].resources.requests.memory
spec.containers[].resources.requests.hugepages-&lt;size&gt;</programlisting>
<simpara>Although you can specify requests and limits for only individual containers, it is also useful to consider the overall resource requests and limits for a pod. For a particular resource, a container resource request or limit is the sum of the resource requests or limits of that type for each container in the pod.</simpara>
<formalpara>
<title>Example container resource requests and limits</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    resources:
      requests: <co xml:id="CO38-1"/>
        memory: "64Mi"
        cpu: "250m"
      limits: <co xml:id="CO38-2"/>
        memory: "128Mi"
        cpu: "500m"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO38-1">
<para>The container is requesting 64 Mi of memory and 250 m CPU.</para>
</callout>
<callout arearefs="CO38-2">
<para>The container&#8217;s limits are 128 Mi of memory and 500 m CPU.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="compliance-operator-tailor">
<title>Tailoring the Compliance Operator</title>

<simpara>While the Compliance Operator comes with ready-to-use profiles, they must be modified to fit the organizations’ needs and requirements. The process of modifying a profile is called <emphasis>tailoring</emphasis>.</simpara>
<simpara>The Compliance Operator provides the <literal>TailoredProfile</literal> object to help tailor profiles.</simpara>
<section xml:id="compliance-new-tailored-profiles_compliance-tailor">
<title>Creating a new tailored profile</title>
<simpara>You can write a tailored profile from scratch by using the <literal>TailoredProfile</literal> object. Set an appropriate <literal>title</literal> and <literal>description</literal> and leave the <literal>extends</literal> field empty. Indicate to the Compliance Operator what type of scan this custom profile will generate:</simpara>
<itemizedlist>
<listitem>
<simpara>Node scan: Scans the Operating System.</simpara>
</listitem>
<listitem>
<simpara>Platform scan: Scans the OpenShift Container Platform configuration.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the following annotation on the <literal>TailoredProfile</literal> object:</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Example <literal>new-profile.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
  name: new-profile
  annotations:
    compliance.openshift.io/product-type: Node <co xml:id="CO39-1"/>
spec:
  extends: ocp4-cis-node <co xml:id="CO39-2"/>
  description: My custom profile <co xml:id="CO39-3"/>
  title: Custom profile <co xml:id="CO39-4"/>
  enableRules:
    - name: ocp4-etcd-unique-ca
      rationale: We really need to enable this
  disableRules:
    - name: ocp4-file-groupowner-cni-conf
      rationale: This does not apply to the cluster</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO39-1">
<para>Set <literal>Node</literal> or <literal>Platform</literal> accordingly.</para>
</callout>
<callout arearefs="CO39-2">
<para>The <literal>extends</literal> field is optional.</para>
</callout>
<callout arearefs="CO39-3">
<para>Use the <literal>description</literal> field to describe the function of the new <literal>TailoredProfile</literal> object.</para>
</callout>
<callout arearefs="CO39-4">
<para>Give your <literal>TailoredProfile</literal> object a title with the <literal>title</literal> field.</para>
<note>
<simpara>Adding the <literal>-node</literal> suffix to the <literal>name</literal> field of the <literal>TailoredProfile</literal> object is similar to adding the <literal>Node</literal> product type annotation and generates an Operating System scan.</simpara>
</note>
</callout>
</calloutlist>
</section>
<section xml:id="compliance-tailored-profiles_compliance-tailor">
<title>Using tailored profiles to extend existing ProfileBundles</title>
<simpara>While the <literal>TailoredProfile</literal> CR enables the most common tailoring operations, the XCCDF standard allows even more flexibility in tailoring OpenSCAP profiles. In addition, if your organization has been using OpenScap previously, you may have an existing XCCDF tailoring file and can reuse it.</simpara>
<simpara>The <literal>ComplianceSuite</literal> object contains an optional <literal>TailoringConfigMap</literal> attribute that you can point to a custom tailoring file. The value of the <literal>TailoringConfigMap</literal> attribute is a name of a config map, which must contain a key called <literal>tailoring.xml</literal> and the value of this key is the tailoring contents.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Browse the available rules for the Red Hat Enterprise Linux CoreOS (RHCOS) <literal>ProfileBundle</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get rules.compliance -n openshift-compliance -l compliance.openshift.io/profile-bundle=rhcos4</programlisting>
</listitem>
<listitem>
<simpara>Browse the available variables in the same <literal>ProfileBundle</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get variables.compliance -n openshift-compliance -l compliance.openshift.io/profile-bundle=rhcos4</programlisting>
</listitem>
<listitem>
<simpara>Create a tailored profile named <literal>nist-moderate-modified</literal>:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose which rules you want to add to the <literal>nist-moderate-modified</literal> tailored profile. This example extends the <literal>rhcos4-moderate</literal> profile by disabling two rules and changing one value. Use the <literal>rationale</literal> value to describe why these changes were made:</simpara>
<formalpara>
<title>Example <literal>new-profile-node.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
  name: nist-moderate-modified
spec:
  extends: rhcos4-moderate
  description: NIST moderate profile
  title: My modified NIST moderate profile
  disableRules:
  - name: rhcos4-file-permissions-var-log-messages
    rationale: The file contains logs of error messages in the system
  - name: rhcos4-account-disable-post-pw-expiration
    rationale: No need to check this as it comes from the IdP
  setValues:
  - name: rhcos4-var-selinux-state
    rationale: Organizational requirements
    value: permissive</programlisting>
</para>
</formalpara>
<table frame="all" rowsep="1" colsep="1">
<title>Attributes for spec variables</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Attribute</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>extends</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the <literal>Profile</literal> object upon which this <literal>TailoredProfile</literal> is built.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>title</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Human-readable title of the <literal>TailoredProfile</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disableRules</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of name and rationale pairs. Each name refers to a name of a rule object that is to be disabled. The rationale value is human-readable text describing why the rule is disabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manualRules</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of name and rationale pairs. When a manual rule is added, the check result status will always be <literal>manual</literal> and remediation will not be generated. This attribute is automatic and by default has no values when set as a manual rule.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>enableRules</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of name and rationale pairs. Each name refers to a name of a rule object that is to be enabled. The rationale value is human-readable text describing why the rule is enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Human-readable text describing the <literal>TailoredProfile</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>setValues</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A list of name, rationale, and value groupings. Each name refers to a name of the value set. The rationale is human-readable text describing the set. The value is the actual setting.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</listitem>
<listitem>
<simpara>Add the <literal>tailoredProfile.spec.manualRules</literal> attribute:</simpara>
<formalpara>
<title>Example <literal>tailoredProfile.spec.manualRules.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: TailoredProfile
metadata:
  name: ocp4-manual-scc-check
spec:
  extends: ocp4-cis
  description: This profile extends ocp4-cis by forcing the SCC check to always return MANUAL
  title: OCP4 CIS profile with manual SCC check
  manualRules:
    - name: ocp4-scc-limit-container-allowed-capabilities
      rationale: We use third party software that installs its own SCC with extra privileges</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>TailoredProfile</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-compliance -f new-profile-node.yaml <co xml:id="CO40-1"/></programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>The <literal>TailoredProfile</literal> object is created in the default <literal>openshift-compliance</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">tailoredprofile.compliance.openshift.io/nist-moderate-modified created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Define the <literal>ScanSettingBinding</literal> object to bind the new <literal>nist-moderate-modified</literal> tailored profile to the default <literal>ScanSetting</literal> object.</simpara>
<formalpara>
<title>Example <literal>new-scansettingbinding.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
  name: nist-moderate-modified
profiles:
  - apiGroup: compliance.openshift.io/v1alpha1
    kind: Profile
    name: ocp4-moderate
  - apiGroup: compliance.openshift.io/v1alpha1
    kind: TailoredProfile
    name: nist-moderate-modified
settingsRef:
  apiGroup: compliance.openshift.io/v1alpha1
  kind: ScanSetting
  name: default</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>ScanSettingBinding</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-compliance -f new-scansettingbinding.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">scansettingbinding.compliance.openshift.io/nist-moderate-modified created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="compliance-operator-raw-results">
<title>Retrieving Compliance Operator raw results</title>
<simpara>When proving compliance for your OpenShift Container Platform cluster, you might need to provide the scan results for auditing purposes.</simpara>
<section xml:id="compliance-results_compliance-raw-results">
<title>Obtaining Compliance Operator raw results from a persistent volume</title>
<formalpara>
<title>Procedure</title>
<para>The Compliance Operator generates and stores the raw results in a persistent volume. These results are in Asset Reporting Format (ARF).</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Explore the <literal>ComplianceSuite</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get compliancesuites nist-moderate-modified \
-o json -n openshift-compliance | jq '.status.scanStatuses[].resultsStorage'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
     "name": "ocp4-moderate",
     "namespace": "openshift-compliance"
}
{
     "name": "nist-moderate-modified-master",
     "namespace": "openshift-compliance"
}
{
     "name": "nist-moderate-modified-worker",
     "namespace": "openshift-compliance"
}</programlisting>
</para>
</formalpara>
<simpara>This shows the persistent volume claims where the raw results are accessible.</simpara>
</listitem>
<listitem>
<simpara>Verify the raw data location by using the name and namespace of one of the results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc -n openshift-compliance rhcos4-moderate-worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 	STATUS   VOLUME                                 	CAPACITY   ACCESS MODES   STORAGECLASS   AGE
rhcos4-moderate-worker   Bound	pvc-548f6cfe-164b-42fe-ba13-a07cfbc77f3a   1Gi    	RWO        	gp2        	92m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Fetch the raw results by spawning a pod that mounts the volume and copying the results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-compliance -f pod.yaml</programlisting>
<formalpara>
<title>Example pod.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: Pod
metadata:
  name: pv-extract
spec:
  containers:
    - name: pv-extract-pod
      image: registry.access.redhat.com/ubi9/ubi
      command: ["sleep", "3000"]
      volumeMounts:
      - mountPath: "/workers-scan-results"
        name: workers-scan-vol
  volumes:
    - name: workers-scan-vol
      persistentVolumeClaim:
        claimName: rhcos4-moderate-worker</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After the pod is running, download the results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc cp pv-extract:/workers-scan-results -n openshift-compliance .</programlisting>
<important>
<simpara>Spawning a pod that mounts the persistent volume will keep the claim as <literal>Bound</literal>. If the volume&#8217;s storage class in use has permissions set to <literal>ReadWriteOnce</literal>, the volume is only mountable by one pod at a time. You must delete the pod upon completion, or it will not be possible for the Operator to schedule a pod and continue storing results in this location.</simpara>
</important>
</listitem>
<listitem>
<simpara>After the extraction is complete, the pod can be deleted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pod pv-extract -n openshift-compliance</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="compliance-operator-remediation">
<title>Managing Compliance Operator result and remediation</title>

<simpara>Each <literal>ComplianceCheckResult</literal> represents a result of one compliance rule check. If the rule can be remediated automatically, a <literal>ComplianceRemediation</literal> object with the same name, owned by the <literal>ComplianceCheckResult</literal> is created. Unless requested, the remediations are not applied automatically, which gives an OpenShift Container Platform administrator the opportunity to review what the remediation does and only apply a remediation once it has been verified.</simpara>
<important>
<simpara>Full remediation for Federal Information Processing Standards (FIPS) compliance requires enabling FIPS mode for the cluster. To enable FIPS mode, you must run the installation program from a Red Hat Enterprise Linux (RHEL) computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>.</simpara>
<simpara>FIPS mode is supported on the following architectures:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>x86_64</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ppc64le</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s390x</literal></simpara>
</listitem>
</itemizedlist>
</important>
<section xml:id="filtering-compliance-check-results_compliance-remediation">
<title>Filters for compliance check results</title>
<simpara>By default, the <literal>ComplianceCheckResult</literal> objects are labeled with several useful labels that allow you to query the checks and decide on the next steps after the results are generated.</simpara>
<simpara>List checks that belong to a specific suite:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance compliancecheckresults \
  -l compliance.openshift.io/suite=workers-compliancesuite</programlisting>
<simpara>List checks that belong to a specific scan:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance compliancecheckresults \
-l compliance.openshift.io/scan=workers-scan</programlisting>
<simpara>Not all <literal>ComplianceCheckResult</literal> objects create <literal>ComplianceRemediation</literal> objects. Only <literal>ComplianceCheckResult</literal> objects that can be remediated automatically do. A <literal>ComplianceCheckResult</literal> object has a related remediation if it is labeled with the <literal>compliance.openshift.io/automated-remediation</literal> label. The name of the remediation is the same as the name of the check.</simpara>
<simpara>List all failing checks that can be remediated automatically:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance compliancecheckresults \
-l 'compliance.openshift.io/check-status=FAIL,compliance.openshift.io/automated-remediation'</programlisting>
<simpara>List all failing checks sorted by severity:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get compliancecheckresults -n openshift-compliance \
-l 'compliance.openshift.io/check-status=FAIL,compliance.openshift.io/check-severity=high'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                           STATUS   SEVERITY
nist-moderate-modified-master-configure-crypto-policy          FAIL     high
nist-moderate-modified-master-coreos-pti-kernel-argument       FAIL     high
nist-moderate-modified-master-disable-ctrlaltdel-burstaction   FAIL     high
nist-moderate-modified-master-disable-ctrlaltdel-reboot        FAIL     high
nist-moderate-modified-master-enable-fips-mode                 FAIL     high
nist-moderate-modified-master-no-empty-passwords               FAIL     high
nist-moderate-modified-master-selinux-state                    FAIL     high
nist-moderate-modified-worker-configure-crypto-policy          FAIL     high
nist-moderate-modified-worker-coreos-pti-kernel-argument       FAIL     high
nist-moderate-modified-worker-disable-ctrlaltdel-burstaction   FAIL     high
nist-moderate-modified-worker-disable-ctrlaltdel-reboot        FAIL     high
nist-moderate-modified-worker-enable-fips-mode                 FAIL     high
nist-moderate-modified-worker-no-empty-passwords               FAIL     high
nist-moderate-modified-worker-selinux-state                    FAIL     high
ocp4-moderate-configure-network-policies-namespaces            FAIL     high
ocp4-moderate-fips-mode-enabled-on-all-nodes                   FAIL     high</programlisting>
</para>
</formalpara>
<simpara>List all failing checks that must be remediated manually:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance compliancecheckresults \
-l 'compliance.openshift.io/check-status=FAIL,!compliance.openshift.io/automated-remediation'</programlisting>
<simpara>The manual remediation steps are typically stored in the <literal>description</literal> attribute in the <literal>ComplianceCheckResult</literal> object.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>ComplianceCheckResult Status</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">ComplianceCheckResult Status</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PASS</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check ran to completion and passed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FAIL</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check ran to completion and failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>INFO</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check ran to completion and found something not severe enough to be considered an error.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MANUAL</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check does not have a way to automatically assess the success or failure and must be checked manually.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>INCONSISTENT</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check reports different results from different sources, typically cluster nodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ERROR</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check ran, but could not complete properly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NOT-APPLICABLE</simpara></entry>
<entry align="left" valign="top"><simpara>Compliance check did not run because it is not applicable or not selected.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="compliance-review_compliance-remediation">
<title>Reviewing a remediation</title>
<simpara>Review both the <literal>ComplianceRemediation</literal> object and the <literal>ComplianceCheckResult</literal> object that owns the remediation. The <literal>ComplianceCheckResult</literal> object contains human-readable descriptions of what the check does and the hardening trying to prevent, as well as other <literal>metadata</literal> like the severity and the associated security controls. The <literal>ComplianceRemediation</literal> object represents a way to fix the problem described in the <literal>ComplianceCheckResult</literal>. After first scan, check for remediations with the state <literal>MissingDependencies</literal>.</simpara>
<simpara>Below is an example of a check and a remediation called <literal>sysctl-net-ipv4-conf-all-accept-redirects</literal>. This example is redacted to only show <literal>spec</literal> and <literal>status</literal> and omits <literal>metadata</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  apply: false
  current:
  object:
    apiVersion: machineconfiguration.openshift.io/v1
    kind: MachineConfig
    spec:
      config:
        ignition:
          version: 3.2.0
        storage:
          files:
            - path: /etc/sysctl.d/75-sysctl_net_ipv4_conf_all_accept_redirects.conf
              mode: 0644
              contents:
                source: data:,net.ipv4.conf.all.accept_redirects%3D0
  outdated: {}
status:
  applicationState: NotApplied</programlisting>
<simpara>The remediation payload is stored in the <literal>spec.current</literal> attribute. The payload can be any Kubernetes object, but because this remediation was produced by a node scan, the remediation payload in the above example is a <literal>MachineConfig</literal> object. For Platform scans, the remediation payload is often a different kind of an object (for example, a <literal>ConfigMap</literal> or <literal>Secret</literal> object), but typically applying that remediation is up to the administrator, because otherwise the Compliance Operator would have required a very broad set of permissions to manipulate any generic Kubernetes object. An example of remediating a Platform check is provided later in the text.</simpara>
<simpara>To see exactly what the remediation does when applied, the <literal>MachineConfig</literal> object contents use the Ignition objects for the configuration. See the <link xlink:href="https://coreos.github.io/ignition/specs/">Ignition specification</link> for further information about the format. In our example, <literal>the spec.config.storage.files[0].path</literal> attribute specifies the file that is being create by this remediation (<literal>/etc/sysctl.d/75-sysctl_net_ipv4_conf_all_accept_redirects.conf</literal>) and the <literal>spec.config.storage.files[0].contents.source</literal> attribute specifies the contents of that file.</simpara>
<note>
<simpara>The contents of the files are URL-encoded.</simpara>
</note>
<simpara>Use the following Python script to view the contents:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo "net.ipv4.conf.all.accept_redirects%3D0" | python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(''.join(sys.stdin.readlines())))"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">net.ipv4.conf.all.accept_redirects=0</programlisting>
</para>
</formalpara>
<important>
<simpara>The Compliance Operator does not automatically resolve dependency issues that can occur between remediations. Users should perform a rescan after remediations are applied to ensure accurate results.</simpara>
</important>
</section>
<section xml:id="compliance-operator-apply-remediation-for-customized-mcp">
<title>Applying remediation when using customized machine config pools</title>
<simpara>When you create a custom <literal>MachineConfigPool</literal>, add a label to the <literal>MachineConfigPool</literal> so that <literal>machineConfigPoolSelector</literal> present in the <literal>KubeletConfig</literal> can match the label with <literal>MachineConfigPool</literal>.</simpara>
<important>
<simpara>Do not set <literal>protectKernelDefaults: false</literal> in the <literal>KubeletConfig</literal> file, because the <literal>MachineConfigPool</literal> object might fail to unpause unexpectedly after the Compliance Operator finishes applying remediation.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the nodes.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -n openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS  ROLES  AGE    VERSION
ip-10-0-128-92.us-east-2.compute.internal  Ready   master 5h21m  v1.28.5
ip-10-0-158-32.us-east-2.compute.internal  Ready   worker 5h17m  v1.28.5
ip-10-0-166-81.us-east-2.compute.internal  Ready   worker 5h17m  v1.28.5
ip-10-0-171-170.us-east-2.compute.internal Ready   master 5h21m  v1.28.5
ip-10-0-197-35.us-east-2.compute.internal  Ready   master 5h22m  v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add a label to nodes.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
label node ip-10-0-166-81.us-east-2.compute.internal \
node-role.kubernetes.io/&lt;machine_config_pool_name&gt;=</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/ip-10-0-166-81.us-east-2.compute.internal labeled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create custom <literal>MachineConfigPool</literal> CR.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: &lt;machine_config_pool_name&gt;
  labels:
    pools.operator.machineconfiguration.openshift.io/&lt;machine_config_pool_name&gt;: '' <co xml:id="CO41-1"/>
spec:
  machineConfigSelector:
  matchExpressions:
  - {key: machineconfiguration.openshift.io/role, operator: In, values: [worker,&lt;machine_config_pool_name&gt;]}
  nodeSelector:
  matchLabels:
    node-role.kubernetes.io/&lt;machine_config_pool_name&gt;: ""</programlisting>
<calloutlist>
<callout arearefs="CO41-1">
<para>The <literal>labels</literal> field defines label name to add for Machine config pool(MCP).</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify MCP created successfully.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp -w</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="compliance-evaluate-kubeletconfig-rules_compliance-remediation">
<title>Evaluating KubeletConfig rules against default configuration values</title>
<simpara>OpenShift Container Platform infrastructure might contain incomplete configuration files at run time, and nodes assume default configuration values for missing configuration options. Some configuration options can be passed as command line arguments. As a result, the Compliance Operator cannot verify if the configuration file on the node is complete because it might be missing options used in the rule checks.</simpara>
<simpara>To prevent false negative results where the default configuration value passes a check, the Compliance Operator uses the Node/Proxy API to fetch the configuration for each node in a node pool, then all configuration options that are consistent across nodes in the node pool are stored in a file that represents the configuration for all nodes within that node pool. This increases the accuracy of the scan results.</simpara>
<simpara>No additional configuration changes are required to use this feature with default <literal>master</literal> and <literal>worker</literal> node pools configurations.</simpara>
</section>
<section xml:id="compliance-custom-node-pools_compliance-remediation">
<title>Scanning custom node pools</title>
<simpara>The Compliance Operator does not maintain a copy of each node pool configuration. The Compliance Operator aggregates consistent configuration options for all nodes within a single node pool into one copy of the configuration file. The Compliance Operator then uses the configuration file for a particular node pool to evaluate rules against nodes within that pool.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>example</literal> role to the <literal>ScanSetting</literal> object that will be stored in the <literal>ScanSettingBinding</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  name: default
  namespace: openshift-compliance
rawResultStorage:
  rotation: 3
  size: 1Gi
roles:
- worker
- master
- example
scanTolerations:
- effect: NoSchedule
  key: node-role.kubernetes.io/master
  operator: Exists
schedule: '0 1 * * *'</programlisting>
</listitem>
<listitem>
<simpara>Create a scan that uses the <literal>ScanSettingBinding</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
  name: cis
  namespace: openshift-compliance
profiles:
- apiGroup: compliance.openshift.io/v1alpha1
  kind: Profile
  name: ocp4-cis
- apiGroup: compliance.openshift.io/v1alpha1
  kind: Profile
  name: ocp4-cis-node
settingsRef:
  apiGroup: compliance.openshift.io/v1alpha1
  kind: ScanSetting
  name: default</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>The Platform KubeletConfig rules are checked through the <literal>Node/Proxy</literal> object. You can find those rules by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get rules -o json | jq '.items[] | select(.checkType == "Platform") | select(.metadata.name | contains("ocp4-kubelet-")) | .metadata.name'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-kubeletconfig-sub-pool-remediation_compliance-remediation">
<title>Remediating <literal>KubeletConfig</literal> sub pools</title>
<simpara><literal>KubeletConfig</literal> remediation labels can be applied to <literal>MachineConfigPool</literal> sub-pools.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add a label to the sub-pool <literal>MachineConfigPool</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label mcp &lt;sub-pool-name&gt; pools.operator.machineconfiguration.openshift.io/&lt;sub-pool-name&gt;=</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-applying_compliance-remediation">
<title>Applying a remediation</title>
<simpara>The boolean attribute <literal>spec.apply</literal> controls whether the remediation should be applied by the Compliance Operator.  You can apply the remediation by setting the attribute to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
patch complianceremediations/&lt;scan-name&gt;-sysctl-net-ipv4-conf-all-accept-redirects \
--patch '{"spec":{"apply":true}}' --type=merge</programlisting>
<simpara>After the Compliance Operator processes the applied remediation, the <literal>status.ApplicationState</literal> attribute would change to <emphasis role="strong">Applied</emphasis> or to <emphasis role="strong">Error</emphasis> if incorrect. When a machine config remediation is applied, that remediation along with all other applied remediations are rendered into a <literal>MachineConfig</literal> object named <literal>75-$scan-name-$suite-name</literal>. That <literal>MachineConfig</literal> object is subsequently rendered by the Machine Config Operator and finally applied to all the nodes in a machine config pool by an instance of the machine control daemon running on each node.</simpara>
<simpara>Note that when the Machine Config Operator applies a new <literal>MachineConfig</literal> object to nodes in a pool, all the nodes belonging to the pool are rebooted. This might be inconvenient when applying multiple remediations, each of which re-renders the composite <literal>75-$scan-name-$suite-name</literal> <literal>MachineConfig</literal> object. To prevent applying the remediation immediately, you can pause the machine config pool by setting the <literal>.spec.paused</literal> attribute of a <literal>MachineConfigPool</literal> object to <literal>true</literal>.</simpara>
<simpara>The Compliance Operator can apply remediations automatically. Set <literal>autoApplyRemediations: true</literal> in the <literal>ScanSetting</literal> top-level object.</simpara>
<warning>
<simpara>Applying remediations automatically should only be done with careful consideration.</simpara>
</warning>
<important>
<simpara>The Compliance Operator does not automatically resolve dependency issues that can occur between remediations. Users should perform a rescan after remediations are applied to ensure accurate results.</simpara>
</important>
</section>
<section xml:id="compliance-manual_compliance-remediation">
<title>Remediating a platform check manually</title>
<simpara>Checks for Platform scans typically have to be remediated manually by the administrator for two reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>It is not always possible to automatically determine the value that must be set. One of the checks requires that a list of allowed registries is provided, but the scanner has no way of knowing which registries the organization wants to allow.</simpara>
</listitem>
<listitem>
<simpara>Different checks modify different API objects, requiring automated remediation to possess <literal>root</literal> or superuser access to modify objects in the cluster, which is not advised.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>The example below uses the <literal>ocp4-ocp-allowed-registries-for-import</literal> rule, which would fail on a default OpenShift Container Platform installation. Inspect the rule <literal>oc get rule.compliance/ocp4-ocp-allowed-registries-for-import -oyaml</literal>, the rule is to limit the registries the users are allowed to import images from by setting the <literal>allowedRegistriesForImport</literal> attribute, The <emphasis>warning</emphasis> attribute of the rule also shows the API object checked, so it can be modified and remediate the issue:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2020-09-10T10:12:54Z"
  generation: 2
  name: cluster
  resourceVersion: "363096"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: 2dcb614e-2f8a-4a23-ba9a-8e33cd0ff77e
spec:
  allowedRegistriesForImport:
  - domainName: registry.redhat.io
status:
  externalRegistryHostnames:
  - default-route-openshift-image-registry.apps.user-cluster-09-10-12-07.devcluster.openshift.com
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Re-run the scan:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancescans/rhcos4-e8-worker compliance.openshift.io/rescan=</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="compliance-updating_compliance-remediation">
<title>Updating remediations</title>
<simpara>When a new version of compliance content is used, it might deliver a new and different version of a remediation than the previous version. The Compliance Operator will keep the old version of the remediation applied. The OpenShift Container Platform administrator is also notified of the new version to review and apply. A ComplianceRemediation object that had been applied earlier, but was updated changes its status to <emphasis role="strong">Outdated</emphasis>. The outdated objects are labeled so that they can be searched for easily.</simpara>
<simpara>The previously applied remediation contents would then be stored in the <literal>spec.outdated</literal> attribute of a <literal>ComplianceRemediation</literal> object and the new updated contents would be stored in the <literal>spec.current</literal> attribute. After updating the content to a newer version, the administrator then needs to review the remediation. As long as the <literal>spec.outdated</literal> attribute exists, it would be used to render the resulting <literal>MachineConfig</literal> object. After the <literal>spec.outdated</literal> attribute is removed, the Compliance Operator re-renders the resulting <literal>MachineConfig</literal> object, which causes the Operator to push the configuration to the nodes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Search for any outdated remediations:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance get complianceremediations \
-l complianceoperator.openshift.io/outdated-remediation=</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              STATE
workers-scan-no-empty-passwords   Outdated</programlisting>
</para>
</formalpara>
<simpara>The currently applied remediation is stored in the <literal>Outdated</literal> attribute and the new, unapplied remediation is stored in the <literal>Current</literal> attribute. If you are satisfied with the new version, remove the <literal>Outdated</literal> field. If you want to keep the updated content, remove the <literal>Current</literal> and <literal>Outdated</literal> attributes.</simpara>
</listitem>
<listitem>
<simpara>Apply the newer version of the remediation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance patch complianceremediations workers-scan-no-empty-passwords \
--type json -p '[{"op":"remove", "path":/spec/outdated}]'</programlisting>
</listitem>
<listitem>
<simpara>The remediation state will switch from <literal>Outdated</literal> to <literal>Applied</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance complianceremediations workers-scan-no-empty-passwords</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              STATE
workers-scan-no-empty-passwords   Applied</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The nodes will apply the newer remediation version and reboot.</simpara>
</listitem>
</orderedlist>
<important>
<simpara>The Compliance Operator does not automatically resolve dependency issues that can occur between remediations. Users should perform a rescan after remediations are applied to ensure accurate results.</simpara>
</important>
</section>
<section xml:id="compliance-unapplying_compliance-remediation">
<title>Unapplying a remediation</title>
<simpara>It might be required to unapply a remediation that was previously applied.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>apply</literal> flag to <literal>false</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
patch complianceremediations/rhcos4-moderate-worker-sysctl-net-ipv4-conf-all-accept-redirects \
--patch '{"spec":{"apply":false}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>The remediation status will change to <literal>NotApplied</literal> and the composite <literal>MachineConfig</literal> object would be re-rendered to not include the remediation.</simpara>
<important>
<simpara>All affected nodes with the remediation will be rebooted.</simpara>
</important>
</listitem>
</orderedlist>
<important>
<simpara>The Compliance Operator does not automatically resolve dependency issues that can occur between remediations. Users should perform a rescan after remediations are applied to ensure accurate results.</simpara>
</important>
</section>
<section xml:id="compliance-removing-kubeletconfig_compliance-remediation">
<title>Removing a KubeletConfig remediation</title>
<simpara><literal>KubeletConfig</literal> remediations are included in node-level profiles. In order to remove a KubeletConfig remediation, you must manually remove it from the <literal>KubeletConfig</literal> objects. This example demonstrates how to remove the compliance check for the <literal>one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available</literal> remediation.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Locate the <literal>scan-name</literal> and compliance check for the <literal>one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available</literal> remediation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance get remediation \ one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceRemediation
metadata:
  annotations:
    compliance.openshift.io/xccdf-value-used: var-kubelet-evictionhard-imagefs-available
  creationTimestamp: "2022-01-05T19:52:27Z"
  generation: 1
  labels:
    compliance.openshift.io/scan-name: one-rule-tp-node-master <co xml:id="CO42-1"/>
    compliance.openshift.io/suite: one-rule-ssb-node
  name: one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available
  namespace: openshift-compliance
  ownerReferences:
  - apiVersion: compliance.openshift.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: ComplianceCheckResult
    name: one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available
    uid: fe8e1577-9060-4c59-95b2-3e2c51709adc
  resourceVersion: "84820"
  uid: 5339d21a-24d7-40cb-84d2-7a2ebb015355
spec:
  apply: true
  current:
    object:
      apiVersion: machineconfiguration.openshift.io/v1
      kind: KubeletConfig
      spec:
        kubeletConfig:
          evictionHard:
            imagefs.available: 10% <co xml:id="CO42-2"/>
  outdated: {}
  type: Configuration
status:
  applicationState: Applied</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO42-1">
<para>The scan name of the remediation.</para>
</callout>
<callout arearefs="CO42-2">
<para>The remediation that was added to the <literal>KubeletConfig</literal> objects.</para>
</callout>
</calloutlist>
<note>
<simpara>If the remediation invokes an <literal>evictionHard</literal> kubelet configuration, you must specify all of the <literal>evictionHard</literal> parameters: <literal>memory.available</literal>, <literal>nodefs.available</literal>, <literal>nodefs.inodesFree</literal>, <literal>imagefs.available</literal>, and <literal>imagefs.inodesFree</literal>. If you do not specify all parameters, only the specified parameters are applied and the remediation will not function properly.</simpara>
</note>
</listitem>
<listitem>
<simpara>Remove the remediation:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set <literal>apply</literal> to false for the remediation object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance patch \
complianceremediations/one-rule-tp-node-master-kubelet-eviction-thresholds-set-hard-imagefs-available \
-p '{"spec":{"apply":false}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Using the <literal>scan-name</literal>, find the <literal>KubeletConfig</literal> object that the remediation was applied to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance get kubeletconfig \
--selector compliance.openshift.io/scan-name=one-rule-tp-node-master</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                 AGE
compliance-operator-kubelet-master   2m34s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Manually remove the remediation, <literal>imagefs.available: 10%</literal>, from the <literal>KubeletConfig</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit -n openshift-compliance KubeletConfig compliance-operator-kubelet-master</programlisting>
<important>
<simpara>All affected nodes with the remediation will be rebooted.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>You must also exclude the rule from any scheduled scans in your tailored profiles that auto-applies the remediation, otherwise, the remediation will be re-applied during the next scheduled scan.</simpara>
</note>
</section>
<section xml:id="compliance-inconsistent_compliance-remediation">
<title>Inconsistent ComplianceScan</title>
<simpara>The <literal>ScanSetting</literal> object lists the node roles that the compliance scans generated from the <literal>ScanSetting</literal> or <literal>ScanSettingBinding</literal> objects would scan. Each node role usually maps to a machine config pool.</simpara>
<important>
<simpara>It is expected that all machines in a machine config pool are identical and all scan results from the nodes in a pool should be identical.</simpara>
</important>
<simpara>If some of the results are different from others, the Compliance Operator flags a <literal>ComplianceCheckResult</literal> object where some of the nodes will report as <literal>INCONSISTENT</literal>. All <literal>ComplianceCheckResult</literal> objects are also labeled with <literal>compliance.openshift.io/inconsistent-check</literal>.</simpara>
<simpara>Because the number of machines in a pool might be quite large, the Compliance Operator attempts to find the most common state and list the nodes that differ from the common state. The most common state is stored in the <literal>compliance.openshift.io/most-common-status</literal> annotation and the annotation <literal>compliance.openshift.io/inconsistent-source</literal> contains pairs of <literal>hostname:status</literal> of check statuses that differ from the most common status. If no common state can be found, all the <literal>hostname:status</literal> pairs are listed in the <literal>compliance.openshift.io/inconsistent-source annotation</literal>.</simpara>
<simpara>If possible, a remediation is still created so that the cluster can converge to a compliant status. However, this might not always be possible and correcting the difference between nodes must be done manually. The compliance scan must be re-run to get a consistent result by annotating the scan with the <literal>compliance.openshift.io/rescan=</literal> option:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancescans/rhcos4-e8-worker compliance.openshift.io/rescan=</programlisting>
</section>
<section xml:id="_additional_resources_9" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../../nodes/nodes/nodes-nodes-managing.xml#nodes-nodes-managing-about_nodes-nodes-managing">Modifying nodes</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-advanced">
<title>Performing advanced Compliance Operator tasks</title>

<simpara>The Compliance Operator includes options for advanced users for the purpose of debugging or integration with existing tooling.</simpara>
<section xml:id="compliance-objects_compliance-advanced">
<title>Using the ComplianceSuite and ComplianceScan objects directly</title>
<simpara>While it is recommended that users take advantage of the <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> objects to define the suites and scans, there are valid use cases to define the <literal>ComplianceSuite</literal> objects directly:</simpara>
<itemizedlist>
<listitem>
<simpara>Specifying only a single rule to scan. This can be useful for debugging together with the <literal>debug: true</literal> attribute which increases the OpenSCAP scanner verbosity, as the debug mode tends to get quite verbose otherwise. Limiting the test to one rule helps to lower the amount of debug information.</simpara>
</listitem>
<listitem>
<simpara>Providing a custom nodeSelector. In order for a remediation to be applicable, the nodeSelector must match a pool.</simpara>
</listitem>
<listitem>
<simpara>Pointing the Scan to a bespoke config map with a tailoring file.</simpara>
</listitem>
<listitem>
<simpara>For testing or development when the overhead of parsing profiles from bundles is not required.</simpara>
</listitem>
</itemizedlist>
<simpara>The following example shows a <literal>ComplianceSuite</literal> that scans the worker machines with only a single rule:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceSuite
metadata:
  name: workers-compliancesuite
spec:
  scans:
    - name: workers-scan
      profile: xccdf_org.ssgproject.content_profile_moderate
      content: ssg-rhcos4-ds.xml
      contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:45dc...
      debug: true
      rule: xccdf_org.ssgproject.content_rule_no_direct_root_logins
      nodeSelector:
      node-role.kubernetes.io/worker: ""</programlisting>
<simpara>The <literal>ComplianceSuite</literal> object and the <literal>ComplianceScan</literal> objects referred to above specify several attributes in a format that OpenSCAP expects.</simpara>
<simpara>To find out the profile, content, or rule values, you can start by creating a similar Suite from <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> or inspect the objects parsed from the <literal>ProfileBundle</literal> objects like rules or profiles. Those objects contain the <literal>xccdf_org</literal> identifiers you can use to refer to them from a <literal>ComplianceSuite</literal>.</simpara>
</section>
<section xml:id="compliance-priorityclass_compliance-advanced">
<title>Setting <literal>PriorityClass</literal> for <literal>ScanSetting</literal> scans</title>
<simpara>In large scale environments, the default <literal>PriorityClass</literal> object can be too low to guarantee Pods execute scans on time. For clusters that must maintain compliance or guarantee automated scanning, it is recommended to set the <literal>PriorityClass</literal> variable to ensure the Compliance Operator is always given priority in resource constrained situations.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>PriorityClass</literal> variable:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
strictNodeScan: true
metadata:
  name: default
  namespace: openshift-compliance
priorityClass: compliance-high-priority <co xml:id="CO43-1"/>
kind: ScanSetting
showNotApplicable: false
rawResultStorage:
  nodeSelector:
    node-role.kubernetes.io/master: ''
  pvAccessModes:
    - ReadWriteOnce
  rotation: 3
  size: 1Gi
  tolerations:
    - effect: NoSchedule
      key: node-role.kubernetes.io/master
      operator: Exists
    - effect: NoExecute
      key: node.kubernetes.io/not-ready
      operator: Exists
      tolerationSeconds: 300
    - effect: NoExecute
      key: node.kubernetes.io/unreachable
      operator: Exists
      tolerationSeconds: 300
    - effect: NoSchedule
      key: node.kubernetes.io/memory-pressure
      operator: Exists
schedule: 0 1 * * *
roles:
  - master
  - worker
scanTolerations:
  - operator: Exists</programlisting>
<calloutlist>
<callout arearefs="CO43-1">
<para>If the <literal>PriorityClass</literal> referenced in the <literal>ScanSetting</literal> cannot be found, the Operator will leave the <literal>PriorityClass</literal> empty, issue a warning, and continue scheduling scans without a <literal>PriorityClass</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-raw-tailored_compliance-advanced">
<title>Using raw tailored profiles</title>
<simpara>While the <literal>TailoredProfile</literal> CR enables the most common tailoring operations, the XCCDF standard allows even more flexibility in tailoring OpenSCAP profiles. In addition, if your organization has been using OpenScap previously, you may have an existing XCCDF tailoring file and can reuse it.</simpara>
<simpara>The <literal>ComplianceSuite</literal> object contains an optional <literal>TailoringConfigMap</literal> attribute that you can point to a custom tailoring file. The value of the <literal>TailoringConfigMap</literal> attribute is a name of a config map which must contain a key called <literal>tailoring.xml</literal> and the value of this key is the tailoring contents.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>ConfigMap</literal> object from a file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
create configmap nist-moderate-modified \
--from-file=tailoring.xml=/path/to/the/tailoringFile.xml</programlisting>
</listitem>
<listitem>
<simpara>Reference the tailoring file in a scan that belongs to a suite:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ComplianceSuite
metadata:
  name: workers-compliancesuite
spec:
  debug: true
  scans:
    - name: workers-scan
      profile: xccdf_org.ssgproject.content_profile_moderate
      content: ssg-rhcos4-ds.xml
      contentImage: registry.redhat.io/compliance/openshift-compliance-content-rhel8@sha256:45dc...
      debug: true
  tailoringConfigMap:
      name: nist-moderate-modified
  nodeSelector:
    node-role.kubernetes.io/worker: ""</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="compliance-rescan_compliance-advanced">
<title>Performing a rescan</title>
<simpara>Typically you will want to re-run a scan on a defined schedule, like every Monday or daily. It can also be useful to re-run a scan once after fixing a problem on a node. To perform a single scan, annotate the scan with the <literal>compliance.openshift.io/rescan=</literal> option:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancescans/rhcos4-e8-worker compliance.openshift.io/rescan=</programlisting>
<simpara>A rescan generates four additional <literal>mc</literal> for <literal>rhcos-moderate</literal> profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">75-worker-scan-chronyd-or-ntpd-specify-remote-server
75-worker-scan-configure-usbguard-auditbackend
75-worker-scan-service-usbguard-enabled
75-worker-scan-usbguard-allow-hid-and-hub</programlisting>
</para>
</formalpara>
<important>
<simpara>When the scan setting <literal>default-auto-apply</literal> label is applied, remediations are applied automatically and outdated remediations automatically update. If there are remediations that were not applied due to dependencies, or remediations that had been outdated, rescanning applies the remediations and might trigger a reboot. Only remediations that use <literal>MachineConfig</literal> objects trigger reboots. If there are no updates or dependencies to be applied, no reboot occurs.</simpara>
</important>
</section>
<section xml:id="compliance-custom-storage_compliance-advanced">
<title>Setting custom storage size for results</title>
<simpara>While the custom resources such as <literal>ComplianceCheckResult</literal> represent an aggregated result of one check across all scanned nodes, it can be useful to review the raw results as produced by the scanner. The raw results are produced in the ARF format and can be large (tens of megabytes per node), it is impractical to store them in a Kubernetes resource backed by the <literal>etcd</literal> key-value store. Instead, every scan creates a persistent volume (PV) which defaults to 1GB size. Depending on your environment, you may want to increase the PV size accordingly. This is done using the <literal>rawResultStorage.size</literal> attribute that is exposed in both the <literal>ScanSetting</literal> and <literal>ComplianceScan</literal> resources.</simpara>
<simpara>A related parameter is <literal>rawResultStorage.rotation</literal> which controls how many scans are retained in the PV before the older scans are rotated. The default value is 3, setting the rotation policy to 0 disables the rotation. Given the default rotation policy and an estimate of 100MB per a raw ARF scan report, you can calculate the right PV size for your environment.</simpara>
<section xml:id="using-custom-result-storage-values_compliance-advanced">
<title>Using custom result storage values</title>
<simpara>Because OpenShift Container Platform can be deployed in a variety of public clouds or bare metal, the Compliance Operator cannot determine available storage configurations. By default, the Compliance Operator will try to create the PV for storing results using the default storage class of the cluster, but a custom storage class can be configured using the <literal>rawResultStorage.StorageClassName</literal> attribute.</simpara>
<important>
<simpara>If your cluster does not specify a default storage class, this attribute must be set.</simpara>
</important>
<simpara>Configure the <literal>ScanSetting</literal> custom resource to use a standard storage class and create persistent volumes that are 10GB in size and keep the last 10 results:</simpara>
<formalpara>
<title>Example <literal>ScanSetting</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  name: default
  namespace: openshift-compliance
rawResultStorage:
  storageClassName: standard
  rotation: 10
  size: 10Gi
roles:
- worker
- master
scanTolerations:
- effect: NoSchedule
  key: node-role.kubernetes.io/master
  operator: Exists
schedule: '0 1 * * *'</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="installing-compliance-operator-cli_compliance-advanced">
<title>Applying remediations generated by suite scans</title>
<simpara>Although you can use the <literal>autoApplyRemediations</literal> boolean parameter in a <literal>ComplianceSuite</literal> object, you can alternatively annotate the object with <literal>compliance.openshift.io/apply-remediations</literal>. This allows the Operator to apply all of the created remediations.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Apply the <literal>compliance.openshift.io/apply-remediations</literal> annotation by running:</simpara>
</listitem>
</itemizedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancesuites/workers-compliancesuite compliance.openshift.io/apply-remediations=</programlisting>
</section>
<section xml:id="automatically-update-remediations_compliance-advanced">
<title>Automatically update remediations</title>
<simpara>In some cases, a scan with newer content might mark remediations as <literal>OUTDATED</literal>. As an administrator, you can apply the <literal>compliance.openshift.io/remove-outdated</literal> annotation to apply new remediations and remove the outdated ones.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Apply the <literal>compliance.openshift.io/remove-outdated</literal> annotation:</simpara>
</listitem>
</itemizedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancesuites/workers-compliancesuite compliance.openshift.io/remove-outdated=</programlisting>
<simpara>Alternatively, set the <literal>autoUpdateRemediations</literal> flag in a <literal>ScanSetting</literal> or <literal>ComplianceSuite</literal> object to update the remediations automatically.</simpara>
</section>
<section xml:id="compliance-custom-scc_compliance-advanced">
<title>Creating a custom SCC for the Compliance Operator</title>
<simpara>In some environments, you must create a custom Security Context Constraints (SCC) file to ensure the correct permissions are available to the Compliance Operator <literal>api-resource-collector</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define the SCC in a YAML file named <literal>restricted-adjusted-compliance.yaml</literal>:</simpara>
<formalpara>
<title><literal>SecurityContextConstraints</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  allowHostDirVolumePlugin: false
  allowHostIPC: false
  allowHostNetwork: false
  allowHostPID: false
  allowHostPorts: false
  allowPrivilegeEscalation: true
  allowPrivilegedContainer: false
  allowedCapabilities: null
  apiVersion: security.openshift.io/v1
  defaultAddCapabilities: null
  fsGroup:
    type: MustRunAs
  kind: SecurityContextConstraints
  metadata:
    name: restricted-adjusted-compliance
  priority: 30 <co xml:id="CO44-1"/>
  readOnlyRootFilesystem: false
  requiredDropCapabilities:
  - KILL
  - SETUID
  - SETGID
  - MKNOD
  runAsUser:
    type: MustRunAsRange
  seLinuxContext:
    type: MustRunAs
  supplementalGroups:
    type: RunAsAny
  users:
  - system:serviceaccount:openshift-compliance:api-resource-collector <co xml:id="CO44-2"/>
  volumes:
  - configMap
  - downwardAPI
  - emptyDir
  - persistentVolumeClaim
  - projected
  - secret</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>The priority of this SCC must be higher than any other SCC that applies to the <literal>system:authenticated</literal> group.</para>
</callout>
<callout arearefs="CO44-2">
<para>Service Account used by Compliance Operator Scanner pod.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the SCC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-compliance  -f restricted-adjusted-compliance.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">securitycontextconstraints.security.openshift.io/restricted-adjusted-compliance created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the SCC was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance scc restricted-adjusted-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                             PRIV    CAPS         SELINUX     RUNASUSER        FSGROUP     SUPGROUP   PRIORITY   READONLYROOTFS   VOLUMES
restricted-adjusted-compliance   false   &lt;no value&gt;   MustRunAs   MustRunAsRange   MustRunAs   RunAsAny   30         false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_compliance-operator-advanced" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../../authentication/managing-security-context-constraints.xml">Managing security context constraints</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="compliance-operator-troubleshooting">
<title>Troubleshooting the Compliance Operator</title>

<simpara>This section describes how to troubleshoot the Compliance Operator. The information can be useful either to diagnose a problem or provide information in a bug report. Some general tips:</simpara>
<itemizedlist>
<listitem>
<simpara>The Compliance Operator emits Kubernetes events when something important happens. You can either view all events in the cluster using the command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"> $ oc get events -n openshift-compliance</programlisting>
<simpara>Or view events for an object like a scan using the command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -n openshift-compliance compliancescan/cis-compliance</programlisting>
</listitem>
<listitem>
<simpara>The Compliance Operator consists of several controllers, approximately one per API object. It could be useful to filter only those controllers that correspond to the API object having issues. If a <literal>ComplianceRemediation</literal> cannot be applied, view the messages from the <literal>remediationctrl</literal> controller. You can filter the messages from a single controller by parsing with <literal>jq</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance logs compliance-operator-775d7bddbd-gj58f \
    | jq -c 'select(.logger == "profilebundlectrl")'</programlisting>
</listitem>
<listitem>
<simpara>The timestamps are logged as seconds since UNIX epoch in UTC. To convert them to a human-readable date, use <literal>date -d @timestamp --utc</literal>, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ date -d @1596184628.955853 --utc</programlisting>
</listitem>
<listitem>
<simpara>Many custom resources, most importantly <literal>ComplianceSuite</literal> and <literal>ScanSetting</literal>, allow the <literal>debug</literal> option to be set. Enabling this option increases verbosity of the OpenSCAP scanner pods, as well as some other helper pods.</simpara>
</listitem>
<listitem>
<simpara>If a single rule is passing or failing unexpectedly, it could be helpful to run a single scan or a suite with only that rule to find the rule ID from the corresponding <literal>ComplianceCheckResult</literal> object and use it as the <literal>rule</literal> attribute value in a <literal>Scan</literal> CR. Then, together with the <literal>debug</literal> option enabled, the <literal>scanner</literal> container logs in the scanner pod would show the raw OpenSCAP logs.</simpara>
</listitem>
</itemizedlist>
<section xml:id="compliance-anatomy_compliance-troubleshooting">
<title>Anatomy of a scan</title>
<simpara>The following sections outline the components and stages of Compliance Operator scans.</simpara>
<section xml:id="compliance-anatomy-compliance-sources_compliance-troubleshooting">
<title>Compliance sources</title>
<simpara>The compliance content is stored in <literal>Profile</literal> objects that are generated from a <literal>ProfileBundle</literal> object. The Compliance Operator creates a <literal>ProfileBundle</literal> object for the cluster and another for the cluster nodes.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance profilebundle.compliance</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance profile.compliance</programlisting>
<simpara>The <literal>ProfileBundle</literal> objects are processed by deployments labeled with the <literal>Bundle</literal> name. To troubleshoot an issue with the <literal>Bundle</literal>, you can find the deployment and view logs of the pods in a deployment:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-compliance -lprofile-bundle=ocp4 -c profileparser</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-compliance deployments,pods -lprofile-bundle=ocp4</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -n openshift-compliance pods/&lt;pod-name&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -n openshift-compliance pod/&lt;pod-name&gt; -c profileparser</programlisting>
</section>
<section xml:id="compliance-anatomy-scan-setting-scan-binding-lifecycle_compliance-troubleshooting">
<title>The ScanSetting and ScanSettingBinding objects lifecycle and debugging</title>
<simpara>With valid compliance content sources, the high-level <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> objects can be used to generate <literal>ComplianceSuite</literal> and <literal>ComplianceScan</literal> objects:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  name: my-companys-constraints
debug: true
# For each role, a separate scan will be created pointing
# to a node-role specified in roles
roles:
  - worker
---
apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSettingBinding
metadata:
  name: my-companys-compliance-requirements
profiles:
  # Node checks
  - name: rhcos4-e8
    kind: Profile
    apiGroup: compliance.openshift.io/v1alpha1
  # Cluster checks
  - name: ocp4-e8
    kind: Profile
    apiGroup: compliance.openshift.io/v1alpha1
settingsRef:
  name: my-companys-constraints
  kind: ScanSetting
  apiGroup: compliance.openshift.io/v1alpha1</programlisting>
<simpara>Both <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> objects are handled by the same controller tagged with <literal>logger=scansettingbindingctrl</literal>.  These objects have no status. Any issues are communicated in form of events:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">Events:
  Type     Reason        Age    From                    Message
  ----     ------        ----   ----                    -------
  Normal   SuiteCreated  9m52s  scansettingbindingctrl  ComplianceSuite openshift-compliance/my-companys-compliance-requirements created</programlisting>
<simpara>Now a <literal>ComplianceSuite</literal> object is created. The flow continues to reconcile the newly created <literal>ComplianceSuite</literal>.</simpara>
</section>
<section xml:id="compliance-suite-lifecycle-debugging_compliance-troubleshooting">
<title>ComplianceSuite custom resource lifecycle and debugging</title>
<simpara>The <literal>ComplianceSuite</literal> CR is a wrapper around <literal>ComplianceScan</literal> CRs. The <literal>ComplianceSuite</literal> CR is handled by controller tagged with <literal>logger=suitectrl</literal>.
This controller handles creating scans from a suite, reconciling and aggregating individual Scan statuses into a single Suite status. If a suite is set to execute periodically, the <literal>suitectrl</literal> also handles creating a <literal>CronJob</literal> CR that re-runs the scans in the suite after the initial run is done:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cronjobs</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                           SCHEDULE    SUSPEND   ACTIVE   LAST SCHEDULE   AGE
&lt;cron_name&gt;                                    0 1 * * *   False     0        &lt;none&gt;          151m</programlisting>
</para>
</formalpara>
<simpara>For the most important issues, events are emitted. View them with <literal>oc describe compliancesuites/&lt;name&gt;</literal>. The <literal>Suite</literal> objects also have a <literal>Status</literal> subresource that is updated when any of <literal>Scan</literal> objects that belong to this suite update their <literal>Status</literal> subresource. After all expected scans are created, control is passed to the scan controller.</simpara>
</section>
<section xml:id="compliance-scan-lifecycle-debugging_compliance-troubleshooting">
<title>ComplianceScan custom resource lifecycle and debugging</title>
<simpara>The <literal>ComplianceScan</literal> CRs are handled by the <literal>scanctrl</literal> controller. This is also where the actual scans happen and the scan results are created. Each scan goes through several phases:</simpara>
<section xml:id="compliance-scan-pending-phase_compliance-troubleshooting">
<title>Pending phase</title>
<simpara>The scan is validated for correctness in this phase. If some parameters like storage size are invalid, the scan transitions to DONE with ERROR result, otherwise proceeds to the Launching phase.</simpara>
</section>
<section xml:id="compliance-scan-launching-phase_compliance-troubleshooting">
<title>Launching phase</title>
<simpara>In this phase, several config maps that contain either environment for the scanner pods or directly the script that the scanner pods will be evaluating. List the config maps:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance get cm \
-l compliance.openshift.io/scan-name=rhcos4-e8-worker,complianceoperator.openshift.io/scan-script=</programlisting>
<simpara>These config maps will be used by the scanner pods. If you ever needed to modify the scanner behavior, change the scanner debug level or print the raw results, modifying the config maps is the way to go. Afterwards, a persistent volume claim is created per scan to store the raw ARF results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc -n openshift-compliance -lcompliance.openshift.io/scan-name=rhcos4-e8-worker</programlisting>
<simpara>The PVCs are mounted by a per-scan <literal>ResultServer</literal> deployment. A <literal>ResultServer</literal> is a simple HTTP server where the individual scanner pods upload the full ARF results to. Each server can run on a different node. The full ARF results might be very large and you cannot presume that it would be possible to create a volume that could be mounted from multiple nodes at the same time. After the scan is finished, the <literal>ResultServer</literal> deployment is scaled down. The PVC with the raw results can be mounted from another custom pod and the results can be fetched or inspected. The traffic between the scanner pods and the <literal>ResultServer</literal> is protected by mutual TLS protocols.</simpara>
<simpara>Finally, the scanner pods are launched in this phase; one scanner pod for a <literal>Platform</literal> scan instance and one scanner pod per matching node for a <literal>node</literal> scan instance. The per-node pods are labeled with the node name. Each pod is always labeled with the <literal>ComplianceScan</literal> name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -lcompliance.openshift.io/scan-name=rhcos4-e8-worker,workload=scanner --show-labels</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                              READY   STATUS      RESTARTS   AGE   LABELS
rhcos4-e8-worker-ip-10-0-169-90.eu-north-1.compute.internal-pod   0/2     Completed   0          39m   compliance.openshift.io/scan-name=rhcos4-e8-worker,targetNode=ip-10-0-169-90.eu-north-1.compute.internal,workload=scanner</programlisting>
</para>
</formalpara>
<simpara>+
The scan then proceeds to the Running phase.</simpara>
</section>
<section xml:id="compliance-scan-running-phase_compliance-troubleshooting">
<title>Running phase</title>
<simpara>The running phase waits until the scanner pods finish. The following terms and processes are in use in the running phase:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">init container</emphasis>: There is one init container called <literal>content-container</literal>. It runs the <emphasis role="strong">contentImage</emphasis> container and executes a single command that copies the <emphasis role="strong">contentFile</emphasis> to the <literal>/content</literal> directory shared with the other containers in this pod.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">scanner</emphasis>: This container runs the scan. For node scans, the container mounts the node filesystem as <literal>/host</literal> and mounts the content delivered by the init container. The container also mounts the <literal>entrypoint</literal> <literal>ConfigMap</literal> created in the Launching phase and executes it. The default script in the entrypoint <literal>ConfigMap</literal> executes OpenSCAP and stores the result files in the <literal>/results</literal> directory shared between the pod&#8217;s containers. Logs from this pod can be viewed to determine what the OpenSCAP scanner checked. More verbose output can be viewed with the <literal>debug</literal> flag.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">logcollector</emphasis>: The logcollector container waits until the scanner container finishes. Then, it uploads the full ARF results to the <literal>ResultServer</literal> and separately uploads the XCCDF results along with scan result and OpenSCAP result code as a <literal>ConfigMap.</literal> These result config maps are labeled with the scan name (<literal>compliance.openshift.io/scan-name=rhcos4-e8-worker</literal>):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe cm/rhcos4-e8-worker-ip-10-0-169-90.eu-north-1.compute.internal-pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">      Name:         rhcos4-e8-worker-ip-10-0-169-90.eu-north-1.compute.internal-pod
      Namespace:    openshift-compliance
      Labels:       compliance.openshift.io/scan-name-scan=rhcos4-e8-worker
                    complianceoperator.openshift.io/scan-result=
      Annotations:  compliance-remediations/processed:
                    compliance.openshift.io/scan-error-msg:
                    compliance.openshift.io/scan-result: NON-COMPLIANT
                    OpenSCAP-scan-result/node: ip-10-0-169-90.eu-north-1.compute.internal

      Data
      ====
      exit-code:
      ----
      2
      results:
      ----
      &lt;?xml version="1.0" encoding="UTF-8"?&gt;
      ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>Scanner pods for <literal>Platform</literal> scans are similar, except:</simpara>
<itemizedlist>
<listitem>
<simpara>There is one extra init container called <literal>api-resource-collector</literal> that reads the OpenSCAP content provided by the content-container init, container, figures out which API resources the content needs to examine and stores those API resources to a shared directory where the <literal>scanner</literal> container would read them from.</simpara>
</listitem>
<listitem>
<simpara>The <literal>scanner</literal> container does not need to mount the host file system.</simpara>
</listitem>
</itemizedlist>
<simpara>When the scanner pods are done, the scans move on to the Aggregating phase.</simpara>
</section>
<section xml:id="compliance-scan-aggregating-phase_compliance-troubleshooting">
<title>Aggregating phase</title>
<simpara>In the aggregating phase, the scan controller spawns yet another pod called the aggregator pod. Its purpose it to take the result <literal>ConfigMap</literal> objects, read the results and for each check result create the corresponding Kubernetes object. If the check failure can be automatically remediated, a <literal>ComplianceRemediation</literal> object is created. To provide human-readable metadata for the checks and remediations, the aggregator pod also mounts the OpenSCAP content using an init container.</simpara>
<simpara>When a config map is processed by an aggregator pod, it is labeled the <literal>compliance-remediations/processed</literal> label. The result of this phase are <literal>ComplianceCheckResult</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get compliancecheckresults -lcompliance.openshift.io/scan-name=rhcos4-e8-worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       STATUS   SEVERITY
rhcos4-e8-worker-accounts-no-uid-except-zero               PASS     high
rhcos4-e8-worker-audit-rules-dac-modification-chmod        FAIL     medium</programlisting>
</para>
</formalpara>
<simpara>and <literal>ComplianceRemediation</literal> objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get complianceremediations -lcompliance.openshift.io/scan-name=rhcos4-e8-worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       STATE
rhcos4-e8-worker-audit-rules-dac-modification-chmod        NotApplied
rhcos4-e8-worker-audit-rules-dac-modification-chown        NotApplied
rhcos4-e8-worker-audit-rules-execution-chcon               NotApplied
rhcos4-e8-worker-audit-rules-execution-restorecon          NotApplied
rhcos4-e8-worker-audit-rules-execution-semanage            NotApplied
rhcos4-e8-worker-audit-rules-execution-setfiles            NotApplied</programlisting>
</para>
</formalpara>
<simpara>After these CRs are created, the aggregator pod exits and the scan moves on to the Done phase.</simpara>
</section>
<section xml:id="compliance-scan-done-phase_compliance-troubleshooting">
<title>Done phase</title>
<simpara>In the final scan phase, the scan resources are cleaned up if needed and the <literal>ResultServer</literal> deployment is either scaled down (if the scan was one-time) or deleted if the scan is continuous; the next scan instance would then recreate the deployment again.</simpara>
<simpara>It is also possible to trigger a re-run of a scan in the Done phase by annotating it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancescans/rhcos4-e8-worker compliance.openshift.io/rescan=</programlisting>
<simpara>After the scan reaches the Done phase, nothing else happens on its own unless the remediations are set to be applied automatically with <literal>autoApplyRemediations: true</literal>. The OpenShift Container Platform administrator would now review the remediations and apply them as needed. If the remediations are set to be applied automatically, the <literal>ComplianceSuite</literal> controller takes over in the Done phase, pauses the machine config pool to which the scan maps to and applies all the remediations in one go. If a remediation is applied, the <literal>ComplianceRemediation</literal> controller takes over.</simpara>
</section>
</section>
<section xml:id="compliance-remediation-lifecycle-debugging_compliance-troubleshooting">
<title>ComplianceRemediation controller lifecycle and debugging</title>
<simpara>The example scan has reported some findings. One of the remediations can be enabled by toggling its <literal>apply</literal> attribute to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch complianceremediations/rhcos4-e8-worker-audit-rules-dac-modification-chmod --patch '{"spec":{"apply":true}}' --type=merge</programlisting>
<simpara>The <literal>ComplianceRemediation</literal> controller (<literal>logger=remediationctrl</literal>) reconciles the modified object. The result of the reconciliation is change of status of the remediation object that is reconciled, but also a change of the rendered per-suite <literal>MachineConfig</literal> object that contains all the applied remediations.</simpara>
<simpara>The <literal>MachineConfig</literal> object always begins with <literal>75-</literal> and is named after the scan and the suite:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mc | grep 75-</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">75-rhcos4-e8-worker-my-companys-compliance-requirements                                                3.2.0             2m46s</programlisting>
</para>
</formalpara>
<simpara>The remediations the <literal>mc</literal> currently consists of are listed in the machine config&#8217;s annotations:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe mc/75-rhcos4-e8-worker-my-companys-compliance-requirements</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         75-rhcos4-e8-worker-my-companys-compliance-requirements
Labels:       machineconfiguration.openshift.io/role=worker
Annotations:  remediation/rhcos4-e8-worker-audit-rules-dac-modification-chmod:</programlisting>
</para>
</formalpara>
<simpara>The <literal>ComplianceRemediation</literal> controller&#8217;s algorithm works like this:</simpara>
<itemizedlist>
<listitem>
<simpara>All currently applied remediations are read into an initial remediation set.</simpara>
</listitem>
<listitem>
<simpara>If the reconciled remediation is supposed to be applied, it is added to the set.</simpara>
</listitem>
<listitem>
<simpara>A <literal>MachineConfig</literal> object is rendered from the set and annotated with names  of remediations in the set. If the set is empty (the last remediation was unapplied), the rendered <literal>MachineConfig</literal> object is removed.</simpara>
</listitem>
<listitem>
<simpara>If and only if the rendered machine config is different from the one already applied in the cluster, the applied MC is updated (or created, or deleted).</simpara>
</listitem>
<listitem>
<simpara>Creating or modifying a <literal>MachineConfig</literal> object triggers a reboot of nodes that match the <literal>machineconfiguration.openshift.io/role</literal> label - see the Machine Config Operator documentation for more details.</simpara>
</listitem>
</itemizedlist>
<simpara>The remediation loop ends once the rendered machine config is updated, if needed, and the reconciled remediation object status is updated. In our case, applying the remediation would trigger a reboot. After the reboot, annotate the scan to re-run it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
annotate compliancescans/rhcos4-e8-worker compliance.openshift.io/rescan=</programlisting>
<simpara>The scan will run and finish. Check for the remediation to pass:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-compliance \
get compliancecheckresults/rhcos4-e8-worker-audit-rules-dac-modification-chmod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                  STATUS   SEVERITY
rhcos4-e8-worker-audit-rules-dac-modification-chmod   PASS     medium</programlisting>
</para>
</formalpara>
</section>
<section xml:id="compliance-operator-useful-labels_compliance-troubleshooting">
<title>Useful labels</title>
<simpara>Each pod that is spawned by the Compliance Operator is labeled specifically with the scan it belongs to and the work it does. The scan identifier is labeled with the <literal>compliance.openshift.io/scan-name</literal> label. The workload identifier is labeled with the <literal>workload</literal> label.</simpara>
<simpara>The Compliance Operator schedules the following workloads:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">scanner</emphasis>: Performs the compliance scan.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">resultserver</emphasis>: Stores the raw results for the compliance scan.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">aggregator</emphasis>: Aggregates the results, detects inconsistencies and outputs result objects (checkresults and remediations).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">suitererunner</emphasis>: Will tag a suite to be re-run (when a schedule is set).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">profileparser</emphasis>: Parses a datastream and creates the appropriate profiles, rules and variables.</simpara>
</listitem>
</itemizedlist>
<simpara>When debugging and logs are required for a certain workload, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -l workload=&lt;workload_name&gt; -c &lt;container_name&gt;</programlisting>
</section>
</section>
<section xml:id="compliance-increasing-operator-limits_compliance-troubleshooting">
<title>Increasing Compliance Operator resource limits</title>
<simpara>In some cases, the Compliance Operator might require more memory than the default limits allow. The best way to mitigate this issue is to set custom resource limits.</simpara>
<simpara>To increase the default memory and CPU limits of scanner pods, see <emphasis>`ScanSetting` Custom resource</emphasis>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To increase the Operator&#8217;s memory limits to 500 Mi, create the following patch file named <literal>co-memlimit-patch.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  config:
    resources:
      limits:
        memory: 500Mi</programlisting>
</listitem>
<listitem>
<simpara>Apply the patch file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch sub compliance-operator -nopenshift-compliance --patch-file co-memlimit-patch.yaml --type=merge</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="operator-resource-constraints_compliance-troubleshooting">
<title>Configuring Operator resource constraints</title>
<simpara>The <literal>resources</literal> field defines Resource Constraints for all the containers in the Pod created by the Operator Lifecycle Manager (OLM).</simpara>
<note>
<simpara>Resource Constraints applied in this process overwrites the existing resource constraints.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Inject a request of 0.25 cpu and 64 Mi of memory, and a limit of 0.5 cpu and 128 Mi of memory in each container by editing the <literal>Subscription</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Subscription
metadata:
  name: custom-operator
spec:
  package: etcd
  channel: alpha
  config:
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="compliance-timeout_compliance-troubleshooting">
<title>Configuring ScanSetting timeout</title>
<simpara>The <literal>ScanSetting</literal> object has a timeout option that can be specified in the <literal>ComplianceScanSetting</literal> object as a duration string, such as <literal>1h30m</literal>. If the scan does not finish within the specified timeout, the scan reattempts until the <literal>maxRetryOnTimeout</literal> limit is reached.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To set a <literal>timeout</literal> and <literal>maxRetryOnTimeout</literal> in ScanSetting, modify an existing <literal>ScanSetting</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: compliance.openshift.io/v1alpha1
kind: ScanSetting
metadata:
  name: default
  namespace: openshift-compliance
rawResultStorage:
  rotation: 3
  size: 1Gi
roles:
- worker
- master
scanTolerations:
- effect: NoSchedule
  key: node-role.kubernetes.io/master
  operator: Exists
schedule: '0 1 * * *'
timeout: '10m0s' <co xml:id="CO45-1"/>
maxRetryOnTimeout: 3 <co xml:id="CO45-2"/></programlisting>
<calloutlist>
<callout arearefs="CO45-1">
<para>The <literal>timeout</literal> variable is defined as a duration string, such as <literal>1h30m</literal>. The default value is <literal>30m</literal>. To disable the timeout, set the value to <literal>0s</literal>.</para>
</callout>
<callout arearefs="CO45-2">
<para>The <literal>maxRetryOnTimeout</literal> variable defines how many times a retry is attempted. The default value is <literal>3</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="support_compliance-troubleshooting">
<title>Getting support</title>
<simpara>If you experience difficulty with a procedure described in this documentation, or with OpenShift Container Platform in general, visit the <link xlink:href="http://access.redhat.com">Red Hat Customer Portal</link>.</simpara>
<simpara>From the Customer Portal, you can:</simpara>
<itemizedlist>
<listitem>
<simpara>Search or browse through the Red Hat Knowledgebase of articles and solutions relating to Red Hat products.</simpara>
</listitem>
<listitem>
<simpara>Submit a support case to Red Hat Support.</simpara>
</listitem>
<listitem>
<simpara>Access other product documentation.</simpara>
</listitem>
</itemizedlist>
<simpara>To identify issues with your cluster, you can use Insights in <link xlink:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link>. Insights provides details about issues and, if available, information on how to solve a problem.</simpara>
<simpara>If you have a suggestion for improving this documentation or have found an
error, submit a <link xlink:href="https://issues.redhat.com/secure/CreateIssueDetails!init.jspa?pid=12332330&amp;summary=Documentation_issue&amp;issuetype=1&amp;components=12367614&amp;priority=10200&amp;versions=12385624">Jira issue</link> for the most relevant documentation component. Please provide specific details, such as the section name and OpenShift Container Platform version.</simpara>
</section>
</section>
<section xml:id="using-oc-compliance-plug-in">
<title>Using the oc-compliance plugin</title>

<simpara>Although the <link xlink:href="../../../security/compliance_operator/co-concepts/compliance-operator-understanding.xml#understanding-compliance-operator">Compliance Operator</link> automates many of the checks and remediations for the cluster, the full process of bringing a cluster into compliance often requires administrator interaction with the Compliance Operator API and other components. The <literal>oc-compliance</literal> plugin makes the process easier.</simpara>
<section xml:id="installing-oc-compliance_oc-compliance-plug-in-understanding">
<title>Installing the oc-compliance plugin</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Extract the <literal>oc-compliance</literal> image to get the <literal>oc-compliance</literal> binary:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run --rm -v ~/.local/bin:/mnt/out:Z registry.redhat.io/compliance/oc-compliance-rhel8:stable /bin/cp /usr/bin/oc-compliance /mnt/out/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">W0611 20:35:46.486903   11354 manifest.go:440] Chose linux/amd64 manifest from the manifest list.</programlisting>
</para>
</formalpara>
<simpara>You can now run <literal>oc-compliance</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="fetching-raw-results_oc-compliance-plug-in-understanding">
<title>Fetching raw results</title>
<simpara>When a compliance scan finishes, the results of the individual checks are listed in the resulting <literal>ComplianceCheckResult</literal> custom resource (CR). However, an administrator or auditor might require the complete details of the scan. The OpenSCAP tool creates an Advanced Recording Format (ARF) formatted file with the detailed results. This ARF file is too large to store in a config map or other standard Kubernetes resource, so a persistent volume (PV) is created to contain it.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Fetching the results from the PV with the Compliance Operator is a four-step process. However, with the <literal>oc-compliance</literal> plugin, you can use a single command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance fetch-raw &lt;object-type&gt; &lt;object-name&gt; -o &lt;output-path&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>&lt;object-type&gt;</literal> can be either <literal>scansettingbinding</literal>, <literal>compliancescan</literal> or <literal>compliancesuite</literal>, depending on which of these objects the scans were launched with.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;object-name&gt;</literal> is the name of the binding, suite, or scan object to gather the ARF file for, and <literal>&lt;output-path&gt;</literal> is the local directory to place the results.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance fetch-raw scansettingbindings my-binding -o /tmp/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Fetching results for my-binding scans: ocp4-cis, ocp4-cis-node-worker, ocp4-cis-node-master
Fetching raw compliance results for scan 'ocp4-cis'.......
The raw compliance results are available in the following directory: /tmp/ocp4-cis
Fetching raw compliance results for scan 'ocp4-cis-node-worker'...........
The raw compliance results are available in the following directory: /tmp/ocp4-cis-node-worker
Fetching raw compliance results for scan 'ocp4-cis-node-master'......
The raw compliance results are available in the following directory: /tmp/ocp4-cis-node-master</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>View the list of files in the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls /tmp/ocp4-cis-node-master/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ocp4-cis-node-master-ip-10-0-128-89.ec2.internal-pod.xml.bzip2  ocp4-cis-node-master-ip-10-0-150-5.ec2.internal-pod.xml.bzip2  ocp4-cis-node-master-ip-10-0-163-32.ec2.internal-pod.xml.bzip2</programlisting>
</para>
</formalpara>
<simpara>Extract the results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ bunzip2 -c resultsdir/worker-scan/worker-scan-stage-459-tqkg7-compute-0-pod.xml.bzip2 &gt; resultsdir/worker-scan/worker-scan-ip-10-0-170-231.us-east-2.compute.internal-pod.xml</programlisting>
<simpara>View the results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls resultsdir/worker-scan/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">worker-scan-ip-10-0-170-231.us-east-2.compute.internal-pod.xml
worker-scan-stage-459-tqkg7-compute-0-pod.xml.bzip2
worker-scan-stage-459-tqkg7-compute-1-pod.xml.bzip2</programlisting>
</para>
</formalpara>
</section>
<section xml:id="re-running-scans_oc-compliance-plug-in-understanding">
<title>Re-running scans</title>
<simpara>Although it is possible to run scans as scheduled jobs, you must often re-run a scan on demand, particularly after remediations are applied or when other changes to the cluster are made.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Rerunning a scan with the Compliance Operator requires use of an annotation on the scan object. However, with the <literal>oc-compliance</literal> plugin you can rerun a scan with a single command. Enter the following command to rerun the scans for the <literal>ScanSettingBinding</literal> object named <literal>my-binding</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance rerun-now scansettingbindings my-binding</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Rerunning scans from 'my-binding': ocp4-cis
Re-running scan 'openshift-compliance/ocp4-cis'</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="using-scan-setting-bindings_oc-compliance-plug-in-understanding">
<title>Using ScanSettingBinding custom resources</title>
<simpara>When using the <literal>ScanSetting</literal> and <literal>ScanSettingBinding</literal> custom resources (CRs) that the Compliance Operator provides, it is possible to run scans for multiple profiles while using a common set of scan options, such as <literal>schedule</literal>, <literal>machine roles</literal>, <literal>tolerations</literal>, and so on. While that is easier than working with multiple <literal>ComplianceSuite</literal> or <literal>ComplianceScan</literal> objects, it can confuse new users.</simpara>
<simpara>The <literal>oc compliance bind</literal> subcommand helps you create a <literal>ScanSettingBinding</literal> CR.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance bind [--dry-run] -N &lt;binding name&gt; [-S &lt;scansetting name&gt;] &lt;objtype/objname&gt; [..&lt;objtype/objname&gt;]</programlisting>
<itemizedlist>
<listitem>
<simpara>If you omit the <literal>-S</literal> flag, the <literal>default</literal> scan setting provided by the Compliance Operator is used.</simpara>
</listitem>
<listitem>
<simpara>The object type is the Kubernetes object type, which  can be <literal>profile</literal> or <literal>tailoredprofile</literal>. More than one object can be provided.</simpara>
</listitem>
<listitem>
<simpara>The object name is the name of the Kubernetes resource, such as <literal>.metadata.name</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>--dry-run</literal> option to display the YAML file of the objects that are created.</simpara>
<simpara>For example, given the following profiles and scan settings:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get profile.compliance -n openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              AGE
ocp4-cis          9m54s
ocp4-cis-node     9m54s
ocp4-e8           9m54s
ocp4-moderate     9m54s
ocp4-ncp          9m54s
rhcos4-e8         9m54s
rhcos4-moderate   9m54s
rhcos4-ncp        9m54s
rhcos4-ospp       9m54s
rhcos4-stig       9m54s</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scansettings -n openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 AGE
default              10m
default-auto-apply   10m</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To apply the <literal>default</literal> settings to the <literal>ocp4-cis</literal> and <literal>ocp4-cis-node</literal> profiles, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance bind -N my-binding profile/ocp4-cis profile/ocp4-cis-node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Creating ScanSettingBinding my-binding</programlisting>
</para>
</formalpara>
<simpara>Once the <literal>ScanSettingBinding</literal> CR is created, the bound profile begins scanning for both profiles with the related settings. Overall, this is the fastest way to begin scanning with the Compliance Operator.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="printing-controls_oc-compliance-plug-in-understanding">
<title>Printing controls</title>
<simpara>Compliance standards are generally organized into a hierarchy as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>A benchmark is the top-level definition of a set of controls for a particular standard. For example, FedRAMP Moderate or Center for Internet Security (CIS) v.1.6.0.</simpara>
</listitem>
<listitem>
<simpara>A control describes a family of requirements that must be met in order to be in compliance with the benchmark. For example, FedRAMP AC-01 (access control policy and procedures).</simpara>
</listitem>
<listitem>
<simpara>A rule is a single check that is specific for the system being brought into compliance, and one or more of these rules map to a control.</simpara>
</listitem>
<listitem>
<simpara>The Compliance Operator handles the grouping of rules into a profile for a single benchmark. It can be difficult to determine which controls that the set of rules in a profile satisfy.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>The <literal>oc compliance</literal> <literal>controls</literal> subcommand provides a report of the standards and controls that a given profile satisfies:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance controls profile ocp4-cis-node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">+-----------+----------+
| FRAMEWORK | CONTROLS |
+-----------+----------+
| CIS-OCP   | 1.1.1    |
+           +----------+
|           | 1.1.10   |
+           +----------+
|           | 1.1.11   |
+           +----------+
...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="fetching-compliance-remediation-details_oc-compliance-plug-in-understanding">
<title>Fetching compliance remediation details</title>
<simpara>The Compliance Operator provides remediation objects that are used to automate the changes required to make the cluster compliant. The <literal>fetch-fixes</literal> subcommand can help you understand exactly which configuration remediations are used. Use the <literal>fetch-fixes</literal> subcommand to extract the remediation objects from a profile, rule, or <literal>ComplianceRemediation</literal> object into a directory to inspect.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the remediations for a profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance fetch-fixes profile ocp4-cis -o /tmp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">No fixes to persist for rule 'ocp4-api-server-api-priority-flowschema-catch-all' <co xml:id="CO46-1"/>
No fixes to persist for rule 'ocp4-api-server-api-priority-gate-enabled'
No fixes to persist for rule 'ocp4-api-server-audit-log-maxbackup'
Persisted rule fix to /tmp/ocp4-api-server-audit-log-maxsize.yaml
No fixes to persist for rule 'ocp4-api-server-audit-log-path'
No fixes to persist for rule 'ocp4-api-server-auth-mode-no-aa'
No fixes to persist for rule 'ocp4-api-server-auth-mode-node'
No fixes to persist for rule 'ocp4-api-server-auth-mode-rbac'
No fixes to persist for rule 'ocp4-api-server-basic-auth'
No fixes to persist for rule 'ocp4-api-server-bind-address'
No fixes to persist for rule 'ocp4-api-server-client-ca'
Persisted rule fix to /tmp/ocp4-api-server-encryption-provider-cipher.yaml
Persisted rule fix to /tmp/ocp4-api-server-encryption-provider-config.yaml</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO46-1">
<para>The <literal>No fixes to persist</literal> warning is expected whenever there are rules in a profile that do not have a corresponding remediation, because either the rule cannot be remediated automatically or a remediation was not provided.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>You can view a sample of the YAML file. The <literal>head</literal> command will show you the first 10 lines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ head /tmp/ocp4-api-server-audit-log-maxsize.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
  name: cluster
spec:
  maximumFileSizeMegabytes: 100</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the remediation from a <literal>ComplianceRemediation</literal> object created after a scan:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get complianceremediations -n openshift-compliance</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                             STATE
ocp4-cis-api-server-encryption-provider-cipher   NotApplied
ocp4-cis-api-server-encryption-provider-config   NotApplied</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance fetch-fixes complianceremediations ocp4-cis-api-server-encryption-provider-cipher -o /tmp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Persisted compliance remediation fix to /tmp/ocp4-cis-api-server-encryption-provider-cipher.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can view a sample of the YAML file. The <literal>head</literal> command will show you the first 10 lines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ head /tmp/ocp4-cis-api-server-encryption-provider-cipher.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
  name: cluster
spec:
  encryption:
    type: aescbc</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<warning>
<simpara>Use caution before applying remediations directly. Some remediations might not be applicable in bulk, such as the usbguard rules in the moderate profile. In these cases, allow the Compliance Operator to apply the rules because it addresses the dependencies and ensures that the cluster remains in a good state.</simpara>
</warning>
</section>
<section xml:id="viewing-compliance-remediation-details_oc-compliance-plug-in-understanding">
<title>Viewing ComplianceCheckResult object details</title>
<simpara>When scans are finished running, <literal>ComplianceCheckResult</literal> objects are created for the individual scan rules. The <literal>view-result</literal> subcommand provides a human-readable output of the <literal>ComplianceCheckResult</literal> object details.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc compliance view-result ocp4-cis-scheduler-no-bind-address</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_file_integrity_operator">
<title>File Integrity Operator</title>
<section xml:id="file-integrity-operator-release-notes">
<title>File Integrity Operator release notes</title>

<simpara>The File Integrity Operator for OpenShift Container Platform continually runs file integrity checks on RHCOS nodes.</simpara>
<simpara>These release notes track the development of the File Integrity Operator in the OpenShift Container Platform.</simpara>
<simpara>For an overview of the File Integrity Operator, see <link xlink:href="../../security/file_integrity_operator/file-integrity-operator-understanding.xml#understanding-file-integrity-operator">Understanding the File Integrity Operator</link>.</simpara>
<simpara>To access the latest release, see <link xlink:href="../../security/file_integrity_operator/file-integrity-operator-updating.xml#olm-preparing-upgrade_file-integrity-operator-updating">Updating the File Integrity Operator</link>.</simpara>
<section xml:id="file-integrity-operator-release-notes-1-3-3">
<title>OpenShift File Integrity Operator 1.3.3</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.3.3:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:5652">RHBA-2023:5652 OpenShift File Integrity Operator Bug Fix and Enhancement Update</link></simpara>
</listitem>
</itemizedlist>
<simpara>This update addresses a CVE in an underlying dependency.</simpara>
<section xml:id="file-integrity-operator-1-3-3-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>You can install and use the File Integrity Operator in an OpenShift Container Platform cluster running in FIPS mode.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>To enable FIPS mode for your cluster, you must run the installation program from a RHEL computer configured to operate in FIPS mode. For more information about configuring FIPS mode on RHEL, see (<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/assembly_installing-the-system-in-fips-mode_security-hardening">Installing the system in FIPS mode</link>)</simpara>
</important>
</section>
<section xml:id="file-integrity-operator-1-3-3-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, some FIO pods with private default mount propagation in combination with <literal>hostPath: path: /</literal> volume mounts would break the CSI driver relying on multipath. This problem has been fixed and the CSI driver works correctly. (<link xlink:href="https://access.redhat.com/solutions/7017081">Some OpenShift Operator pods blocking unmounting of CSI volumes when multipath is in use</link>)</simpara>
</listitem>
<listitem>
<simpara>This update resolves CVE-2023-39325. (<link xlink:href="https://access.redhat.com/security/cve/CVE-2023-39325"><emphasis role="strong">CVE-2023-39325</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-1-3-2">
<title>OpenShift File Integrity Operator 1.3.2</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.3.2:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:5107">RHBA-2023:5107 OpenShift File Integrity Operator Bug Fix Update</link></simpara>
</listitem>
</itemizedlist>
<simpara>This update addresses a CVE in an underlying dependency.</simpara>
</section>
<section xml:id="file-integrity-operator-release-notes-1-3-1">
<title>OpenShift File Integrity Operator 1.3.1</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.3.1:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:3600">RHBA-2023:3600 OpenShift File Integrity Operator Bug Fix Update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-1-3-1-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>FIO now includes kubelet certificates as default files, excluding them from issuing warnings when they&#8217;re managed by OpenShift Container Platform. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-14348"><emphasis role="strong">OCPBUGS-14348</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>FIO now correctly directs email to the address for Red Hat Technical Support. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-5023"><emphasis role="strong">OCPBUGS-5023</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-1-3-1-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, FIO would not clean up <literal>FileIntegrityNodeStatus</literal> CRDs when nodes are removed from the cluster. FIO has been updated to correctly clean up node status CRDs on node removal.  (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4321"><emphasis role="strong">OCPBUGS-4321</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, FIO would also erroneously indicate that new nodes failed integrity checks. FIO has been updated to correctly show node status CRDs when adding new nodes to the cluster. This provides correct node status notifications. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-8502"><emphasis role="strong">OCPBUGS-8502</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, when FIO was reconciling <literal>FileIntegrity</literal> CRDs, it would pause scanning until the reconciliation was done. This caused an overly aggressive re-initiatization process on nodes not impacted by the reconciliation. This problem also resulted in unnecessary daemonsets for machine config pools which are unrelated to the <literal>FileIntegrity</literal> being changed. FIO correctly handles these cases and only pauses AIDE scanning for nodes that are affected by file integrity changes. (<link xlink:href="https://issues.redhat.com/browse/CMP-1097"><emphasis role="strong">CMP-1097</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-1-3-1-known-issues">
<title>Known Issues</title>
<simpara>In FIO 1.3.1, increasing nodes in IBM Z&#174; clusters might result in <literal>Failed</literal> File Integrity node status. For more information, see <link xlink:href="https://access.redhat.com/solutions/7028861">Adding nodes in IBM Power&#174; clusters can result in failed File Integrity node status</link>.</simpara>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-1-2-1">
<title>OpenShift File Integrity Operator 1.2.1</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.2.1:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:1684">RHBA-2023:1684 OpenShift File Integrity Operator Bug Fix Update</link></simpara>
</listitem>
<listitem>
<simpara>This release includes updated container dependencies.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-release-notes-1-2-0">
<title>OpenShift File Integrity Operator 1.2.0</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.2.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:1273">RHBA-2023:1273 OpenShift File Integrity Operator Enhancement Update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-1-2-0-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The File Integrity Operator Custom Resource (CR) now contains an <literal>initialDelay</literal> feature that specifies the number of seconds to wait before starting the first AIDE integrity check. For more information, see <link xlink:href="../../security/file_integrity_operator/file-integrity-operator-understanding.xml#understanding-file-integrity-custom-resource_file-integrity-operator">Creating the FileIntegrity custom resource</link>.</simpara>
</listitem>
<listitem>
<simpara>The File Integrity Operator is now stable and the release channel is upgraded to <literal>stable</literal>. Future releases will follow <link xlink:href="https://semver.org/">Semantic Versioning</link>. To access the latest release, see <link xlink:href="../../security/file_integrity_operator/file-integrity-operator-updating.xml#olm-preparing-upgrade_file-integrity-operator-updating">Updating the File Integrity Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-1-0-0">
<title>OpenShift File Integrity Operator 1.0.0</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 1.0.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:0037">RHBA-2023:0037 OpenShift File Integrity Operator Bug Fix Update</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-release-notes-0-1-32">
<title>OpenShift File Integrity Operator 0.1.32</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 0.1.32:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:7095">RHBA-2022:7095 OpenShift File Integrity Operator Bug Fix Update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-0-1-32-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, alerts issued by the File Integrity Operator did not set a namespace, making it difficult to understand from which namespace the alert originated. Now, the Operator sets the appropriate namespace, providing more information about the alert. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2112394"><emphasis role="strong">BZ#2112394</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, The File Integrity Operator did not update the metrics service on Operator startup, causing the metrics targets to be unreachable. With this release, the File Integrity Operator now ensures the metrics service is updated on Operator startup. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2115821"><emphasis role="strong">BZ#2115821</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-0-1-30">
<title>OpenShift File Integrity Operator 0.1.30</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 0.1.30:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:5538">RHBA-2022:5538 OpenShift File Integrity Operator Bug Fix and Enhancement Update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-0-1-30-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The File Integrity Operator is now supported on the following architectures:</simpara>
<itemizedlist>
<listitem>
<simpara>IBM Power&#174;</simpara>
</listitem>
<listitem>
<simpara>IBM Z&#174; and IBM&#174; LinuxONE</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-0-1-30-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, alerts issued by the File Integrity Operator did not set a namespace, making it difficult to understand where the alert originated. Now, the Operator sets the appropriate namespace, increasing understanding of the alert. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2101393"><emphasis role="strong">BZ#2101393</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-0-1-24">
<title>OpenShift File Integrity Operator 0.1.24</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 0.1.24:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:1331">RHBA-2022:1331 OpenShift File Integrity Operator Bug Fix</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-0-1-24-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>You can now configure the maximum number of backups stored in the <literal>FileIntegrity</literal> Custom Resource (CR) with the <literal>config.maxBackups</literal> attribute. This attribute specifies the number of AIDE database and log backups left over from the <literal>re-init</literal> process to keep on the node. Older backups beyond the configured number are automatically pruned. The default is set to five backups.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-file-integrity-operator-0-1-24-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, upgrading the Operator from versions older than 0.1.21 to 0.1.22 could cause the <literal>re-init</literal> feature to fail. This was a result of the Operator failing to update <literal>configMap</literal> resource labels. Now, upgrading to the latest version fixes the resource labels. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2049206"><emphasis role="strong">BZ#2049206</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, when enforcing the default <literal>configMap</literal> script contents, the wrong data keys were compared. This resulted in the <literal>aide-reinit</literal> script not being updated properly after an Operator upgrade, and caused the <literal>re-init</literal> process to fail. Now,<literal>daemonSets</literal> run to completion and the AIDE database <literal>re-init</literal> process executes successfully. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2072058"><emphasis role="strong">BZ#2072058</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-0-1-22">
<title>OpenShift File Integrity Operator 0.1.22</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 0.1.22:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:0142">RHBA-2022:0142 OpenShift File Integrity Operator Bug Fix</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="openshift-file-integrity-operator-0-1-22-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, a system with a File Integrity Operator installed might interrupt the OpenShift Container Platform update, due to the  <literal>/etc/kubernetes/aide.reinit</literal> file. This occurred if the <literal>/etc/kubernetes/aide.reinit</literal> file was present, but later removed prior to the <literal>ostree</literal> validation. With this update, <literal>/etc/kubernetes/aide.reinit</literal> is moved to the <literal>/run</literal> directory so that it does not conflict with the OpenShift Container Platform update. (<link xlink:href="https://bugzilla.redhat.com/show_bug.cgi?id=2033311"><emphasis role="strong">BZ#2033311</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes-0-1-21">
<title>OpenShift File Integrity Operator 0.1.21</title>
<simpara>The following advisory is available for the OpenShift File Integrity Operator 0.1.21:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2021:4631">RHBA-2021:4631 OpenShift File Integrity Operator Bug Fix and Enhancement Update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-operator-0-1-21-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>The metrics related to <literal>FileIntegrity</literal> scan results and processing metrics are displayed on the monitoring dashboard on the web console. The results are labeled with the prefix of <literal>file_integrity_operator_</literal>.</simpara>
</listitem>
<listitem>
<simpara>If a node has an integrity failure for more than 1 second, the default <literal>PrometheusRule</literal> provided in the operator namespace alerts with a warning.</simpara>
</listitem>
<listitem>
<simpara>The following dynamic Machine Config Operator and Cluster Version Operator related filepaths are excluded from the default AIDE policy to help prevent false positives during node updates:</simpara>
<itemizedlist>
<listitem>
<simpara>/etc/machine-config-daemon/currentconfig</simpara>
</listitem>
<listitem>
<simpara>/etc/pki/ca-trust/extracted/java/cacerts</simpara>
</listitem>
<listitem>
<simpara>/etc/cvo/updatepayloads</simpara>
</listitem>
<listitem>
<simpara>/root/.kube</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The AIDE daemon process has stability improvements over v0.1.16, and is more resilient to errors that might occur when the AIDE database is initialized.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-file-integrity-operator-0-1-21-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, when the Operator automatically upgraded, outdated daemon sets were not removed. With this release, outdated daemon sets are removed during the automatic upgrade.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-release-notes_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<simpara><link xlink:href="../../security/file_integrity_operator/file-integrity-operator-understanding.xml#understanding-file-integrity-operator">Understanding the File Integrity Operator</link></simpara>
</section>
</section>
<section xml:id="installing-file-integrity-operator">
<title>Installing the File Integrity Operator</title>

<section xml:id="installing-file-integrity-operator-using-web-console_file-integrity-operator-installation">
<title>Installing the File Integrity Operator using the web console</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Search for the File Integrity Operator, then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Keep the default selection of <emphasis role="strong">Installation mode</emphasis> and <emphasis role="strong">namespace</emphasis> to ensure that the Operator will be installed to the <literal>openshift-file-integrity</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To confirm that the installation is successful:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Check that the Operator is installed in the <literal>openshift-file-integrity</literal> namespace and its status is <literal>Succeeded</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If the Operator is not installed successfully:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <literal>Status</literal> column for any errors or failures.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs in any pods in the <literal>openshift-file-integrity</literal> project that are reporting issues.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="installing-file-integrity-operator-using-cli_file-integrity-operator-installation">
<title>Installing the File Integrity Operator using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Namespace</literal> object YAML file by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  labels:
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: privileged <co xml:id="CO47-1"/>
  name: openshift-file-integrity</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO47-1">
<para>In OpenShift Container Platform 4.14, the pod security label must be set to <literal>privileged</literal> at the namespace level.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: file-integrity-operator
  namespace: openshift-file-integrity
spec:
  targetNamespaces:
  - openshift-file-integrity</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: file-integrity-operator
  namespace: openshift-file-integrity
spec:
  channel: "stable"
  installPlanApproval: Automatic
  name: file-integrity-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the installation succeeded by inspecting the CSV file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-file-integrity</programlisting>
</listitem>
<listitem>
<simpara>Verify that the File Integrity Operator is up and running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n openshift-file-integrity</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources-installing-the-file-integrity-operator" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>The File Integrity Operator is supported in a restricted network environment. For more information, see <link xlink:href="../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="file-integrity-operator-updating">
<title>Updating the File Integrity Operator</title>

<simpara>As a cluster administrator, you can update the File Integrity Operator on your OpenShift Container Platform cluster.</simpara>
<section xml:id="olm-preparing-upgrade_file-integrity-operator-updating">
<title>Preparing for an Operator update</title>
<simpara>The subscription of an installed Operator specifies an update channel that tracks and receives updates for the Operator. You can change the update channel to start tracking and receiving updates from a newer channel.</simpara>
<simpara>The names of update channels in a subscription can differ between Operators, but the naming scheme typically follows a common convention within a given Operator. For example, channel names might follow a minor release update stream for the application provided by the Operator (<literal>1.2</literal>, <literal>1.3</literal>) or a release frequency (<literal>stable</literal>, <literal>fast</literal>).</simpara>
<note>
<simpara>You cannot change installed Operators to a channel that is older than the current channel.</simpara>
</note>
<simpara>Red Hat Customer Portal Labs include the following application that helps administrators prepare to update their Operators:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/labs/ocpouic/">Red Hat OpenShift Container Platform Operator Update Information Checker</link></simpara>
</listitem>
</itemizedlist>
<simpara>You can use the application to search for Operator Lifecycle Manager-based Operators and verify the available Operator version per update channel across different versions of OpenShift Container Platform. Cluster Version Operator-based Operators are not included.</simpara>
</section>
<section xml:id="olm-changing-update-channel_file-integrity-operator-updating">
<title>Changing the update channel for an Operator</title>
<simpara>You can change the update channel for an Operator by using the OpenShift Container Platform web console.</simpara>
<tip>
<simpara>If the approval strategy in the subscription is set to <emphasis role="strong">Automatic</emphasis>, the update process initiates as soon as a new Operator version is available in the selected channel. If the approval strategy is set to <emphasis role="strong">Manual</emphasis>, you must manually approve pending updates.</simpara>
</tip>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the Operator you want to change the update channel for.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the update channel under <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the newer update channel that you want to change to, then click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>For subscriptions with an <emphasis role="strong">Automatic</emphasis> approval strategy, the update begins automatically. Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
<simpara>For subscriptions with a <emphasis role="strong">Manual</emphasis> approval strategy, you can manually approve the update from the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-approving-pending-upgrade_file-integrity-operator-updating">
<title>Manually approving a pending Operator update</title>
<simpara>If an installed Operator has the approval strategy in its subscription set to <emphasis role="strong">Manual</emphasis>, when new updates are released in its current update channel, the update must be manually approved before installation can begin.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Operators that have a pending update display a status with <emphasis role="strong">Upgrade available</emphasis>. Click the name of the Operator you want to update.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab. Any updates requiring approval are displayed next to <emphasis role="strong">Upgrade status</emphasis>. For example, it might display <emphasis role="strong">1 requires approval</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">1 requires approval</emphasis>, then click <emphasis role="strong">Preview Install Plan</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Review the resources that are listed as available for update. When satisfied, click <emphasis role="strong">Approve</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="understanding-file-integrity-operator">
<title>Understanding the File Integrity Operator</title>

<simpara>The File Integrity Operator is an OpenShift Container Platform Operator that continually runs file integrity checks on the cluster nodes. It deploys a daemon set that initializes and runs privileged advanced intrusion detection environment (AIDE) containers on each node, providing a status object with a log of files that are modified during the initial run of the daemon set pods.</simpara>
<important>
<simpara>Currently, only Red Hat Enterprise Linux CoreOS (RHCOS) nodes are supported.</simpara>
</important>
<section xml:id="understanding-file-integrity-custom-resource_file-integrity-operator">
<title>Creating the FileIntegrity custom resource</title>
<simpara>An instance of a <literal>FileIntegrity</literal> custom resource (CR) represents a set of continuous file integrity scans for one or more nodes.</simpara>
<simpara>Each <literal>FileIntegrity</literal> CR is backed by a daemon set running AIDE on the nodes matching the <literal>FileIntegrity</literal> CR specification.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the following example <literal>FileIntegrity</literal> CR named <literal>worker-fileintegrity.yaml</literal> to enable scans on worker nodes:</simpara>
<formalpara>
<title>Example FileIntegrity CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: fileintegrity.openshift.io/v1alpha1
kind: FileIntegrity
metadata:
  name: worker-fileintegrity
  namespace: openshift-file-integrity
spec:
  nodeSelector: <co xml:id="CO48-1"/>
      node-role.kubernetes.io/worker: ""
  tolerations: <co xml:id="CO48-2"/>
  - key: "myNode"
    operator: "Exists"
    effect: "NoSchedule"
  config: <co xml:id="CO48-3"/>
    name: "myconfig"
    namespace: "openshift-file-integrity"
    key: "config"
    gracePeriod: 20 <co xml:id="CO48-4"/>
    maxBackups: 5 <co xml:id="CO48-5"/>
    initialDelay: 60 <co xml:id="CO48-6"/>
  debug: false
status:
  phase: Active <co xml:id="CO48-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO48-1">
<para>Defines the selector for scheduling node scans.</para>
</callout>
<callout arearefs="CO48-2">
<para>Specify <literal>tolerations</literal> to schedule on nodes with custom taints. When not specified, a default toleration allowing running on main and infra nodes is applied.</para>
</callout>
<callout arearefs="CO48-3">
<para>Define a <literal>ConfigMap</literal> containing an AIDE configuration to use.</para>
</callout>
<callout arearefs="CO48-4">
<para>The number of seconds to pause in between AIDE integrity checks. Frequent AIDE checks on a node might be resource intensive, so it can be useful to specify a longer interval. Default is 900 seconds (15 minutes).</para>
</callout>
<callout arearefs="CO48-5">
<para>The maximum number of AIDE database and log backups (leftover from the re-init process) to keep on a node. Older backups beyond this number are automatically pruned by the daemon. Default is set to 5.</para>
</callout>
<callout arearefs="CO48-6">
<para>The number of seconds to wait before starting the first AIDE integrity check. Default is set to 0.</para>
</callout>
<callout arearefs="CO48-7">
<para>The running status of the <literal>FileIntegrity</literal> instance. Statuses are <literal>Initializing</literal>, <literal>Pending</literal>, or <literal>Active</literal>.</para>
</callout>
</calloutlist>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara><literal>Initializing</literal></simpara>
</entry>
<entry>
<simpara>The <literal>FileIntegrity</literal> object is currently initializing or re-initializing the AIDE database.</simpara>
</entry>
</row>
<row>
<entry>
<simpara><literal>Pending</literal></simpara>
</entry>
<entry>
<simpara>The <literal>FileIntegrity</literal> deployment is still being created.</simpara>
</entry>
</row>
<row>
<entry>
<simpara><literal>Active</literal></simpara>
</entry>
<entry>
<simpara>The scans are active and ongoing.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Apply the YAML file to the <literal>openshift-file-integrity</literal> namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f worker-fileintegrity.yaml -n openshift-file-integrity</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Confirm the <literal>FileIntegrity</literal> object was created successfully by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegrities -n openshift-file-integrity</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   AGE
worker-fileintegrity   14s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="checking-the-file-integrity-CR-status_file-integrity-operator">
<title>Checking the FileIntegrity custom resource status</title>
<simpara>The <literal>FileIntegrity</literal> custom resource (CR) reports its status through the .<literal>status.phase</literal> subresource.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To query the <literal>FileIntegrity</literal> CR status, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegrities/worker-fileintegrity  -o jsonpath="{ .status.phase }"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Active</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-CR-phases_file-integrity-operator">
<title>FileIntegrity custom resource phases</title>
<itemizedlist>
<listitem>
<simpara><literal>Pending</literal> - The phase after the custom resource (CR) is created.</simpara>
</listitem>
<listitem>
<simpara><literal>Active</literal> -  The phase when the backing daemon set is up and running.</simpara>
</listitem>
<listitem>
<simpara><literal>Initializing</literal> - The phase when the AIDE database is being reinitialized.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="understanding-file-integrity-node-statuses-object_file-integrity-operator">
<title>Understanding the FileIntegrityNodeStatuses object</title>
<simpara>The scan results of the <literal>FileIntegrity</literal> CR are reported in another object called <literal>FileIntegrityNodeStatuses</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegritynodestatuses</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                AGE
worker-fileintegrity-ip-10-0-130-192.ec2.internal   101s
worker-fileintegrity-ip-10-0-147-133.ec2.internal   109s
worker-fileintegrity-ip-10-0-165-160.ec2.internal   102s</programlisting>
</para>
</formalpara>
<note>
<simpara>It might take some time for the <literal>FileIntegrityNodeStatus</literal> object results to be available.</simpara>
</note>
<simpara>There is one result object per node. The <literal>nodeName</literal> attribute of each <literal>FileIntegrityNodeStatus</literal> object corresponds to the node being scanned. The
status of the file integrity scan is represented in the <literal>results</literal> array, which holds scan conditions.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegritynodestatuses.fileintegrity.openshift.io -ojsonpath='{.items[*].results}' | jq</programlisting>
<simpara>The <literal>fileintegritynodestatus</literal> object reports the latest status of an AIDE run and exposes the status as <literal>Failed</literal>, <literal>Succeeded</literal>, or <literal>Errored</literal> in a <literal>status</literal> field.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegritynodestatuses -w</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                               NODE                                         STATUS
example-fileintegrity-ip-10-0-134-186.us-east-2.compute.internal   ip-10-0-134-186.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-150-230.us-east-2.compute.internal   ip-10-0-150-230.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-169-137.us-east-2.compute.internal   ip-10-0-169-137.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-180-200.us-east-2.compute.internal   ip-10-0-180-200.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-194-66.us-east-2.compute.internal    ip-10-0-194-66.us-east-2.compute.internal    Failed
example-fileintegrity-ip-10-0-222-188.us-east-2.compute.internal   ip-10-0-222-188.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-134-186.us-east-2.compute.internal   ip-10-0-134-186.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-222-188.us-east-2.compute.internal   ip-10-0-222-188.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-194-66.us-east-2.compute.internal    ip-10-0-194-66.us-east-2.compute.internal    Failed
example-fileintegrity-ip-10-0-150-230.us-east-2.compute.internal   ip-10-0-150-230.us-east-2.compute.internal   Succeeded
example-fileintegrity-ip-10-0-180-200.us-east-2.compute.internal   ip-10-0-180-200.us-east-2.compute.internal   Succeeded</programlisting>
</para>
</formalpara>
</section>
<section xml:id="file-integrity-node-status-types_file-integrity-operator">
<title>FileIntegrityNodeStatus CR status types</title>
<simpara>These conditions are reported in the results array of the corresponding <literal>FileIntegrityNodeStatus</literal> CR status:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Succeeded</literal> - The integrity check passed; the files and directories covered by the AIDE check have not been modified since the database was last initialized.</simpara>
</listitem>
<listitem>
<simpara><literal>Failed</literal> - The integrity check failed; some files or directories covered by the AIDE check have been modified since the database was last initialized.</simpara>
</listitem>
<listitem>
<simpara><literal>Errored</literal> - The AIDE scanner encountered an internal error.</simpara>
</listitem>
</itemizedlist>
<section xml:id="file-integrity-node-status-success_file-integrity-operator">
<title>FileIntegrityNodeStatus CR success example</title>
<formalpara>
<title>Example output of a condition with a success status</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[
  {
    "condition": "Succeeded",
    "lastProbeTime": "2020-09-15T12:45:57Z"
  }
]
[
  {
    "condition": "Succeeded",
    "lastProbeTime": "2020-09-15T12:46:03Z"
  }
]
[
  {
    "condition": "Succeeded",
    "lastProbeTime": "2020-09-15T12:45:48Z"
  }
]</programlisting>
</para>
</formalpara>
<simpara>In this case, all three scans succeeded and so far there are no other conditions.</simpara>
</section>
<section xml:id="file-integrity-node-status-failure_file-integrity-operator">
<title>FileIntegrityNodeStatus CR failure status example</title>
<simpara>To simulate a failure condition, modify one of the files AIDE tracks. For example, modify <literal>/etc/resolv.conf</literal> on one of the worker nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/ip-10-0-130-192.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Creating debug namespace/openshift-debug-node-ldfbj ...
Starting pod/ip-10-0-130-192ec2internal-debug ...
To use host binaries, run `chroot /host`
Pod IP: 10.0.130.192
If you don't see a command prompt, try pressing enter.
sh-4.2# echo "# integrity test" &gt;&gt; /host/etc/resolv.conf
sh-4.2# exit

Removing debug pod ...
Removing debug namespace/openshift-debug-node-ldfbj ...</programlisting>
</para>
</formalpara>
<simpara>After some time, the <literal>Failed</literal> condition is reported in the results array of the corresponding <literal>FileIntegrityNodeStatus</literal> object. The previous <literal>Succeeded</literal> condition is retained, which allows you to pinpoint the time the check failed.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegritynodestatuses.fileintegrity.openshift.io/worker-fileintegrity-ip-10-0-130-192.ec2.internal -ojsonpath='{.results}' | jq -r</programlisting>
<simpara>Alternatively, if you are not mentioning the object name, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegritynodestatuses.fileintegrity.openshift.io -ojsonpath='{.items[*].results}' | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[
  {
    "condition": "Succeeded",
    "lastProbeTime": "2020-09-15T12:54:14Z"
  },
  {
    "condition": "Failed",
    "filesChanged": 1,
    "lastProbeTime": "2020-09-15T12:57:20Z",
    "resultConfigMapName": "aide-ds-worker-fileintegrity-ip-10-0-130-192.ec2.internal-failed",
    "resultConfigMapNamespace": "openshift-file-integrity"
  }
]</programlisting>
</para>
</formalpara>
<simpara>The <literal>Failed</literal> condition points to a config map that gives more details about what exactly failed and why:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe cm aide-ds-worker-fileintegrity-ip-10-0-130-192.ec2.internal-failed</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         aide-ds-worker-fileintegrity-ip-10-0-130-192.ec2.internal-failed
Namespace:    openshift-file-integrity
Labels:       file-integrity.openshift.io/node=ip-10-0-130-192.ec2.internal
              file-integrity.openshift.io/owner=worker-fileintegrity
              file-integrity.openshift.io/result-log=
Annotations:  file-integrity.openshift.io/files-added: 0
              file-integrity.openshift.io/files-changed: 1
              file-integrity.openshift.io/files-removed: 0

Data

integritylog:
------
AIDE 0.15.1 found differences between database and filesystem!!
Start timestamp: 2020-09-15 12:58:15

Summary:
  Total number of files:  31553
  Added files:                0
  Removed files:            0
  Changed files:            1


---------------------------------------------------
Changed files:
---------------------------------------------------

changed: /hostroot/etc/resolv.conf

---------------------------------------------------
Detailed information about changes:
---------------------------------------------------


File: /hostroot/etc/resolv.conf
 SHA512   : sTQYpB/AL7FeoGtu/1g7opv6C+KT1CBJ , qAeM+a8yTgHPnIHMaRlS+so61EN8VOpg

Events:  &lt;none&gt;</programlisting>
</para>
</formalpara>
<simpara>Due to the config map data size limit, AIDE logs over 1 MB are added to the failure config map as a base64-encoded gzip archive. In this case, you want to pipe the output of the above command to <literal>base64 --decode | gunzip</literal>. Compressed logs are indicated by the presence of a <literal>file-integrity.openshift.io/compressed</literal> annotation key in the config map.</simpara>
</section>
</section>
<section xml:id="file-integrity-events_file-integrity-operator">
<title>Understanding events</title>
<simpara>Transitions in the status of the <literal>FileIntegrity</literal> and <literal>FileIntegrityNodeStatus</literal> objects are logged by <emphasis>events</emphasis>. The creation time of the event reflects the latest transition, such as <literal>Initializing</literal> to <literal>Active</literal>, and not necessarily the latest scan result. However, the newest event always reflects the most recent status.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events --field-selector reason=FileIntegrityStatus</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">LAST SEEN   TYPE     REASON                OBJECT                                MESSAGE
97s         Normal   FileIntegrityStatus   fileintegrity/example-fileintegrity   Pending
67s         Normal   FileIntegrityStatus   fileintegrity/example-fileintegrity   Initializing
37s         Normal   FileIntegrityStatus   fileintegrity/example-fileintegrity   Active</programlisting>
</para>
</formalpara>
<simpara>When a node scan fails, an event is created with the <literal>add/changed/removed</literal> and config map information.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events --field-selector reason=NodeIntegrityStatus</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">LAST SEEN   TYPE      REASON                OBJECT                                MESSAGE
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-134-173.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-168-238.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-169-175.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-152-92.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-158-144.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-131-30.ec2.internal
87m         Warning   NodeIntegrityStatus   fileintegrity/example-fileintegrity   node ip-10-0-152-92.ec2.internal has changed! a:1,c:1,r:0 \ log:openshift-file-integrity/aide-ds-example-fileintegrity-ip-10-0-152-92.ec2.internal-failed</programlisting>
</para>
</formalpara>
<simpara>Changes to the number of added, changed, or removed files results in a new event, even if the status of the node has not transitioned.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events --field-selector reason=NodeIntegrityStatus</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">LAST SEEN   TYPE      REASON                OBJECT                                MESSAGE
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-134-173.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-168-238.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-169-175.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-152-92.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-158-144.ec2.internal
114m        Normal    NodeIntegrityStatus   fileintegrity/example-fileintegrity   no changes to node ip-10-0-131-30.ec2.internal
87m         Warning   NodeIntegrityStatus   fileintegrity/example-fileintegrity   node ip-10-0-152-92.ec2.internal has changed! a:1,c:1,r:0 \ log:openshift-file-integrity/aide-ds-example-fileintegrity-ip-10-0-152-92.ec2.internal-failed
40m         Warning   NodeIntegrityStatus   fileintegrity/example-fileintegrity   node ip-10-0-152-92.ec2.internal has changed! a:3,c:1,r:0 \ log:openshift-file-integrity/aide-ds-example-fileintegrity-ip-10-0-152-92.ec2.internal-failed</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="configuring-file-integrity-operator">
<title>Configuring the Custom File Integrity Operator</title>

<section xml:id="viewing-file-integrity-object-attributes_file-integrity-operator">
<title>Viewing FileIntegrity object attributes</title>
<simpara>As with any Kubernetes custom resources (CRs), you can run <literal>oc explain fileintegrity</literal>, and then look at the individual attributes using:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain fileintegrity.spec</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain fileintegrity.spec.config</programlisting>
</section>
<section xml:id="important-file-integrity-object-attributes_file-integrity-operator">
<title>Important attributes</title>
<table frame="all" rowsep="1" colsep="1">
<title>Important <literal>spec</literal> and <literal>spec.config</literal> attributes</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Attribute</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.nodeSelector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A map of key-values pairs that must match with node&#8217;s labels in order for the
AIDE pods to be schedulable on that node. The typical use is to set only a
single key-value pair where <literal>node-role.kubernetes.io/worker: ""</literal> schedules AIDE on
all worker nodes, <literal>node.openshift.io/os_id: "rhcos"</literal> schedules on all
Red Hat Enterprise Linux CoreOS (RHCOS) nodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.debug</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A boolean attribute. If set to <literal>true</literal>, the daemon running in the AIDE deamon set&#8217;s
pods would output extra information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.tolerations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify tolerations to schedule on nodes with custom taints. When not specified,
a default toleration is applied, which allows tolerations to run on control plane nodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config.gracePeriod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of seconds to pause in between AIDE integrity checks. Frequent AIDE
checks on a node can be resource intensive, so it can be useful to specify a
longer interval. Defaults to <literal>900</literal>, or 15 minutes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>maxBackups</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum number of AIDE database and log backups leftover from the <literal>re-init</literal> process to keep on a node. Older backups beyond this number are automatically pruned by the daemon.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of a configMap that contains custom AIDE configuration. If omitted, a default configuration is created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config.namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Namespace of a configMap that contains custom AIDE configuration. If unset, the FIO generates a default configuration suitable for RHCOS systems.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config.key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Key that contains actual AIDE configuration in a config map specified by <literal>name</literal> and <literal>namespace</literal>. The default value is <literal>aide.conf</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.config.initialDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of seconds to wait before starting the first AIDE integrity check. Default is set to 0. This attribute is optional.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="file-integrity-examine-default-config_file-integrity-operator">
<title>Examine the default configuration</title>
<simpara>The default File Integrity Operator configuration is stored in a config map with
the same name as the <literal>FileIntegrity</literal> CR.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To examine the default config, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe cm/worker-fileintegrity</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-understanding-default-config_file-integrity-operator">
<title>Understanding the default File Integrity Operator configuration</title>
<simpara>Below is an excerpt from the <literal>aide.conf</literal> key of the config map:</simpara>
<programlisting language="bash" linenumbering="unnumbered">@@define DBDIR /hostroot/etc/kubernetes
@@define LOGDIR /hostroot/etc/kubernetes
database=file:@@{DBDIR}/aide.db.gz
database_out=file:@@{DBDIR}/aide.db.gz
gzip_dbout=yes
verbose=5
report_url=file:@@{LOGDIR}/aide.log
report_url=stdout
PERMS = p+u+g+acl+selinux+xattrs
CONTENT_EX = sha512+ftype+p+u+g+n+acl+selinux+xattrs

/hostroot/boot/    	CONTENT_EX
/hostroot/root/\..* PERMS
/hostroot/root/   CONTENT_EX</programlisting>
<simpara>The default configuration for a <literal>FileIntegrity</literal> instance provides coverage for
files under the following directories:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/root</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/boot</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/usr</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/etc</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The following directories are not covered:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>/var</literal></simpara>
</listitem>
<listitem>
<simpara><literal>/opt</literal></simpara>
</listitem>
<listitem>
<simpara>Some OpenShift Container Platform-specific excludes under <literal>/etc/</literal></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-supplying-custom-aide-config_file-integrity-operator">
<title>Supplying a custom AIDE configuration</title>
<simpara>Any entries that configure AIDE internal behavior such as <literal>DBDIR</literal>, <literal>LOGDIR</literal>,
<literal>database</literal>, and <literal>database_out</literal> are overwritten by the Operator. The Operator
would add a prefix to <literal>/hostroot/</literal> before all paths to be watched for integrity
changes. This makes reusing existing AIDE configs that might often not be
tailored for a containerized environment and start from the root directory
easier.</simpara>
<note>
<simpara><literal>/hostroot</literal> is the directory where the pods running AIDE mount the host&#8217;s
file system. Changing the configuration triggers a reinitializing of the database.</simpara>
</note>
</section>
<section xml:id="file-integrity-operator-defining-custom-config_file-integrity-operator">
<title>Defining a custom File Integrity Operator configuration</title>
<simpara>This example focuses on defining a custom configuration for a scanner that runs
on the control plane nodes based on the default configuration provided for the
<literal>worker-fileintegrity</literal> CR. This workflow might be useful if you are planning
to deploy a custom software running as a daemon set and storing its data under
<literal>/opt/mydaemon</literal> on the control plane nodes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Make a copy of the default configuration.</simpara>
</listitem>
<listitem>
<simpara>Edit the default configuration with the files that must be watched or excluded.</simpara>
</listitem>
<listitem>
<simpara>Store the edited contents in a new config map.</simpara>
</listitem>
<listitem>
<simpara>Point the <literal>FileIntegrity</literal> object to the new config map through the attributes in
<literal>spec.config</literal>.</simpara>
</listitem>
<listitem>
<simpara>Extract the default configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc extract cm/worker-fileintegrity --keys=aide.conf</programlisting>
<simpara>This creates a file named <literal>aide.conf</literal> that you can edit. To illustrate how the
Operator post-processes the paths, this example adds an exclude directory
without the prefix:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ vim aide.conf</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/hostroot/etc/kubernetes/static-pod-resources
!/hostroot/etc/kubernetes/aide.*
!/hostroot/etc/kubernetes/manifests
!/hostroot/etc/docker/certs.d
!/hostroot/etc/selinux/targeted
!/hostroot/etc/openvswitch/conf.db</programlisting>
</para>
</formalpara>
<simpara>Exclude a path specific to control plane nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">!/opt/mydaemon/</programlisting>
<simpara>Store the other content in <literal>/etc</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/hostroot/etc/	CONTENT_EX</programlisting>
</listitem>
<listitem>
<simpara>Create a config map based on this file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create cm master-aide-conf --from-file=aide.conf</programlisting>
</listitem>
<listitem>
<simpara>Define a <literal>FileIntegrity</literal> CR manifest that references the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: fileintegrity.openshift.io/v1alpha1
kind: FileIntegrity
metadata:
  name: master-fileintegrity
  namespace: openshift-file-integrity
spec:
  nodeSelector:
      node-role.kubernetes.io/master: ""
  config:
      name: master-aide-conf
      namespace: openshift-file-integrity</programlisting>
<simpara>The Operator processes the provided config map file and stores the result in a
config map with the same name as the <literal>FileIntegrity</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe cm/master-fileintegrity | grep /opt/mydaemon</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">!/hostroot/opt/mydaemon</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="file-integrity-operator-changing-custom-config_file-integrity-operator">
<title>Changing the custom File Integrity configuration</title>
<simpara>To change the File Integrity configuration, never change the generated
config map. Instead, change the config map that is linked to the <literal>FileIntegrity</literal>
object through the <literal>spec.name</literal>, <literal>namespace</literal>, and <literal>key</literal> attributes.</simpara>
</section>
</section>
<section xml:id="file-integrity-operator-advanced-usage">
<title>Performing advanced Custom File Integrity Operator tasks</title>

<section xml:id="file-integrity-operator-reinitializing-database_file-integrity-operator">
<title>Reinitializing the database</title>
<simpara>If the File Integrity Operator detects a change that was planned, it might be required to reinitialize the database.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Annotate the <literal>FileIntegrity</literal> custom resource (CR) with <literal>file-integrity.openshift.io/re-init</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate fileintegrities/worker-fileintegrity file-integrity.openshift.io/re-init=</programlisting>
<simpara>The old database and log files are backed up and a new database is initialized. The old database and logs are retained on the nodes under <literal>/etc/kubernetes</literal>, as
seen in the following output from a pod spawned using <literal>oc debug</literal>:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"> ls -lR /host/etc/kubernetes/aide.*
-rw-------. 1 root root 1839782 Sep 17 15:08 /host/etc/kubernetes/aide.db.gz
-rw-------. 1 root root 1839783 Sep 17 14:30 /host/etc/kubernetes/aide.db.gz.backup-20200917T15_07_38
-rw-------. 1 root root   73728 Sep 17 15:07 /host/etc/kubernetes/aide.db.gz.backup-20200917T15_07_55
-rw-r--r--. 1 root root       0 Sep 17 15:08 /host/etc/kubernetes/aide.log
-rw-------. 1 root root     613 Sep 17 15:07 /host/etc/kubernetes/aide.log.backup-20200917T15_07_38
-rw-r--r--. 1 root root       0 Sep 17 15:07 /host/etc/kubernetes/aide.log.backup-20200917T15_07_55</programlisting>
</para>
</formalpara>
<simpara>To provide some permanence of record, the resulting config maps are not owned by the <literal>FileIntegrity</literal> object, so manual cleanup is necessary. As a
result, any previous integrity failures would still be visible in the <literal>FileIntegrityNodeStatus</literal> object.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="file-integrity-operator-machine-config-integration_file-integrity-operator">
<title>Machine config integration</title>
<simpara>In OpenShift Container Platform 4, the cluster node configuration is delivered through
<literal>MachineConfig</literal> objects. You can assume that the changes to files that are
caused by a <literal>MachineConfig</literal> object are expected and should not cause the file
integrity scan to fail. To suppress changes to files caused by <literal>MachineConfig</literal>
object updates, the File Integrity Operator watches the node objects; when a
node is being updated, the AIDE scans are suspended for the duration of the
update. When the update finishes, the database is reinitialized and the scans
resume.</simpara>
<simpara>This pause and resume logic only applies to updates through the <literal>MachineConfig</literal>
API, as they are reflected in the node object annotations.</simpara>
</section>
<section xml:id="file-integrity-operator-exploring-daemon-sets_file-integrity-operator">
<title>Exploring the daemon sets</title>
<simpara>Each <literal>FileIntegrity</literal> object represents a scan on a number of nodes. The scan
itself is performed by pods managed by a daemon set.</simpara>
<simpara>To find the daemon set that represents a <literal>FileIntegrity</literal> object, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-file-integrity get ds/aide-worker-fileintegrity</programlisting>
<simpara>To list the pods in that daemon set, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-file-integrity get pods -lapp=aide-worker-fileintegrity</programlisting>
<simpara>To view logs of a single AIDE pod, call <literal>oc logs</literal> on one of the pods.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-file-integrity logs pod/aide-worker-fileintegrity-mr8x6</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting the AIDE runner daemon
initializing AIDE db
initialization finished
running aide check
...</programlisting>
</para>
</formalpara>
<simpara>The config maps created by the AIDE daemon are not retained and are deleted
after the File Integrity Operator processes them. However, on failure and error,
the contents of these config maps are copied to the config map that the
<literal>FileIntegrityNodeStatus</literal> object points to.</simpara>
</section>
</section>
<section xml:id="troubleshooting-file-integrity-operator">
<title>Troubleshooting the File Integrity Operator</title>

<section xml:id="_general_troubleshooting">
<title>General troubleshooting</title>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to generally troubleshoot issues with the File Integrity Operator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Enable the debug flag in the <literal>FileIntegrity</literal> object. The <literal>debug</literal> flag increases
the verbosity of the daemons that run in the <literal>DaemonSet</literal> pods and run the AIDE
checks.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_checking_the_aide_configuration">
<title>Checking the AIDE configuration</title>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to check the AIDE configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>The AIDE configuration is stored in a config map with the same name as the
<literal>FileIntegrity</literal> object. All AIDE configuration config maps are labeled
with <literal>file-integrity.openshift.io/aide-conf</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_determining_the_fileintegrity_objects_phase">
<title>Determining the FileIntegrity object&#8217;s phase</title>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to determine if the <literal>FileIntegrity</literal> object exists and see its current
status.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>To see the <literal>FileIntegrity</literal> object&#8217;s current status, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get fileintegrities/worker-fileintegrity  -o jsonpath="{ .status }"</programlisting>
<simpara>Once the <literal>FileIntegrity</literal> object and the backing daemon set are created, the status
should switch to <literal>Active</literal>. If it does not, check the Operator pod logs.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_determining_that_the_daemon_sets_pods_are_running_on_the_expected_nodes">
<title>Determining that the daemon set&#8217;s pods are running on the expected nodes</title>
<variablelist>
<varlistentry>
<term>Issue</term>
<listitem>
<simpara>You want to confirm that the daemon set exists and that its pods are running on
the nodes you expect them to run on.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Resolution</term>
<listitem>
<simpara>Run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-file-integrity get pods -lapp=aide-worker-fileintegrity</programlisting>
<note>
<simpara>Adding <literal>-owide</literal> includes the IP address of the node that the pod is running on.</simpara>
</note>
<simpara>To check the logs of the daemon pods, run <literal>oc logs</literal>.</simpara>
<simpara>Check the return value of the AIDE command to see if the check passed or failed.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
</chapter>
<chapter xml:id="_security_profiles_operator">
<title>Security Profiles Operator</title>
<section xml:id="spo-overview">
<title>Security Profiles Operator overview</title>
<simpara>OpenShift Container Platform Security Profiles Operator (SPO) provides a way to define secure computing (<link xlink:href="https://kubernetes.io/docs/tutorials/security/seccomp/">seccomp</link>) profiles and SELinux profiles as custom resources, synchronizing profiles to every node in a given namespace. For the latest updates, see the <link xlink:href="../../security/security_profiles_operator/spo-release-notes.xml#spo-release-notes">release notes</link>.</simpara>
<simpara>The SPO can distribute custom resources to each node while a reconciliation loop ensures that the profiles stay up-to-date. See <link xlink:href="../../security/security_profiles_operator/spo-understanding.xml#spo-understanding">Understanding the Security Profiles Operator</link>.</simpara>
<simpara>The SPO manages SELinux policies and seccomp profiles for namespaced workloads. For more information, see <link xlink:href="../../security/security_profiles_operator/spo-enabling.xml#spo-enabling">Enabling the Security Profiles Operator</link>.</simpara>
<simpara>You can create <link xlink:href="../../security/security_profiles_operator/spo-seccomp.xml#spo-seccomp">seccomp</link> and <link xlink:href="../../security/security_profiles_operator/spo-selinux.xml#spo-selinux">SELinux</link> profiles, bind policies to pods, record workloads, and synchronize all worker nodes in a namespace.</simpara>
<simpara>Use <link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-advanced">Advanced Security Profile Operator tasks</link> to enable the log enricher, configure webhooks and metrics, or restrict profiles to a single namespace.</simpara>
<simpara><link xlink:href="../../security/security_profiles_operator/spo-troubleshooting.xml">Troubleshoot the Security Profiles Operator</link> as needed, or engage <link xlink:href="https://access.redhat.com/support/">Red Hat support</link>.</simpara>
<simpara>You can <link xlink:href="../../security/security_profiles_operator/spo-uninstalling.xml#spo-uninstalling">Uninstall the Security Profiles Operator</link> by removing the profiles before removing the Operator.</simpara>
</section>
<section xml:id="spo-release-notes">
<title>Security Profiles Operator release notes</title>

<simpara>The Security Profiles Operator provides a way to define secure computing (<link xlink:href="https://kubernetes.io/docs/tutorials/security/seccomp/">seccomp</link>) and SELinux profiles as custom resources, synchronizing profiles to every node in a given namespace.</simpara>
<simpara>These release notes track the development of the Security Profiles Operator in OpenShift Container Platform.</simpara>
<simpara>For an overview of the Security Profiles Operator, see <link xlink:href="../../security/security_profiles_operator/spo-overview.xml">Security Profiles Operator Overview</link>.</simpara>
<section xml:id="spo-release-notes-0-8-2">
<title>Security Profiles Operator 0.8.2</title>
<simpara>The following advisory is available for the Security Profiles Operator 0.8.2:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:5958">RHBA-2023:5958 - OpenShift Security Profiles Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="spo-0-8-2-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, <literal>SELinuxProfile</literal> objects did not inherit custom attributes from the same namespace. With this update, the issue has now been resolved and <literal>SELinuxProfile</literal> object attributes are inherited from the same namespace as expected. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-17164"><emphasis role="strong">OCPBUGS-17164</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, RawSELinuxProfiles would hang during the creation process and would not reach an <literal>Installed</literal> state. With this update, the issue has been resolved and RawSELinuxProfiles are created successfully. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-19744"><emphasis role="strong">OCPBUGS-19744</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, patching the <literal>enableLogEnricher</literal> to <literal>true</literal> would cause the <literal>seccompProfile</literal> <literal>log-enricher-trace</literal> pods to be stuck in a <literal>Pending</literal> state. With this update, <literal>log-enricher-trace</literal> pods reach an <literal>Installed</literal> state as expected. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-22182"><emphasis role="strong">OCPBUGS-22182</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Security Profiles Operator generated high cardinality metrics, causing Prometheus pods using high amounts of memory. With this update, the following metrics will no longer apply in the Security Profiles Operator namespace:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rest_client_request_duration_seconds</literal></simpara>
</listitem>
<listitem>
<simpara><literal>rest_client_request_size_bytes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>rest_client_response_size_bytes</literal></simpara>
<simpara>(<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-22406"><emphasis role="strong">OCPBUGS-22406</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-release-notes-0-8-0">
<title>Security Profiles Operator 0.8.0</title>
<simpara>The following advisory is available for the Security Profiles Operator 0.8.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:4689">RHBA-2023:4689 - OpenShift Security Profiles Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="spo-0-8-0-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, while trying to install Security Profiles Operator in a disconnected cluster, the secure hashes provided were incorrect due to a SHA relabeling issue. With this update, the SHAs provided work consistently with disconnected environments. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-14404"><emphasis role="strong">OCPBUGS-14404</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-release-notes-0-7-1">
<title>Security Profiles Operator 0.7.1</title>
<simpara>The following advisory is available for the Security Profiles Operator 0.7.1:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHSA-2023:2029">RHSA-2023:2029 - OpenShift Security Profiles Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="spo-0-7-1-new-features-and-enhancements">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>Security Profiles Operator (SPO) now automatically selects the appropriate <literal>selinuxd</literal> image for RHEL 8- and 9-based RHCOS systems.</simpara>
<important>
<simpara>Users that mirror images for disconnected environments must mirror both <literal>selinuxd</literal> images provided by the Security Profiles Operator.</simpara>
</important>
</listitem>
<listitem>
<simpara>You can now enable memory optimization inside of an <literal>spod</literal> daemon. For more information, see <link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-memory-optimization_spo-advanced">Enabling memory optimization in the spod daemon</link>.</simpara>
<note>
<simpara>SPO memory optimization is not enabled by default.</simpara>
</note>
</listitem>
<listitem>
<simpara>The daemon resource requirements are now configurable. For more information, see <link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-daemon-requirements_spo-advanced">Customizing daemon resource requirements</link>.</simpara>
</listitem>
<listitem>
<simpara>The priority class name is now configurable in the <literal>spod</literal> configuration. For more information, see <link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-custom-priority-class_spo-advanced">Setting a custom priority class name for the spod daemon pod</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-0-7-1-deprecations">
<title>Deprecated and removed features</title>
<itemizedlist>
<listitem>
<simpara>The default <literal>nginx-1.19.1</literal> seccomp profile is now removed from the Security Profiles Operator deployment.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-0-7-1-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, a Security Profiles Operator (SPO) SELinux policy did not inherit low-level policy definitions from the container template. If you selected another template, such as net_container, the policy would not work because it required low-level policy definitions that only existed in the container template. This issue occurred when the SPO SELinux policy attempted to translate SELinux policies from the SPO custom format to the Common Intermediate Language (CIL) format. With this update, the container template appends to any SELinux policies that require translation from SPO to CIL. Additionally, the SPO SELinux policy can inherit low-level policy definitions from any supported policy template. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-12879"><emphasis role="strong">OCPBUGS-12879</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="spo-0-7-1-known-issue" renderas="sect4">Known issue</bridgehead>
<itemizedlist>
<listitem>
<simpara>When uninstalling the Security Profiles Operator, the <literal>MutatingWebhookConfiguration</literal> object is not deleted and must be manually removed. As a workaround, delete the <literal>MutatingWebhookConfiguration</literal> object after uninstalling the Security Profiles Operator. These steps are defined in <link xlink:href="../../security/security_profiles_operator/spo-uninstalling.xml#spo-uninstalling">Uninstalling the Security Profiles Operator</link>. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4687"><emphasis role="strong">OCPBUGS-4687</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-release-notes-0-5-2">
<title>Security Profiles Operator 0.5.2</title>
<simpara>The following advisory is available for the Security Profiles Operator 0.5.2:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2023:0788">RHBA-2023:0788 - OpenShift Security Profiles Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<simpara>This update addresses a CVE in an underlying dependency.</simpara>
<bridgehead xml:id="spo-0-5-2-known-issue" renderas="sect4">Known issue</bridgehead>
<itemizedlist>
<listitem>
<simpara>When uninstalling the Security Profiles Operator, the <literal>MutatingWebhookConfiguration</literal> object is not deleted and must be manually removed. As a workaround, delete the <literal>MutatingWebhookConfiguration</literal> object after uninstalling the Security Profiles Operator. These steps are defined in <link xlink:href="../../security/security_profiles_operator/spo-uninstalling.xml#spo-uninstalling">Uninstalling the Security Profiles Operator</link>. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4687"><emphasis role="strong">OCPBUGS-4687</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-release-notes-0-5-0">
<title>Security Profiles Operator 0.5.0</title>
<simpara>The following advisory is available for the Security Profiles Operator 0.5.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHBA-2022:8762">RHBA-2022:8762 - OpenShift Security Profiles Operator bug fix update</link></simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="spo-0-5-0-known-issue" renderas="sect4">Known issue</bridgehead>
<itemizedlist>
<listitem>
<simpara>When uninstalling the Security Profiles Operator, the <literal>MutatingWebhookConfiguration</literal> object is not deleted and must be manually removed. As a workaround, delete the <literal>MutatingWebhookConfiguration</literal> object after uninstalling the Security Profiles Operator. These steps are defined in <link xlink:href="../../security/security_profiles_operator/spo-uninstalling.xml#spo-uninstalling">Uninstalling the Security Profiles Operator</link>. (<link xlink:href="https://issues.redhat.com/browse/OCPBUGS-4687"><emphasis role="strong">OCPBUGS-4687</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-understanding">
<title>Understanding the Security Profiles Operator</title>

<simpara>OpenShift Container Platform administrators can use the Security Profiles Operator to define increased security measures in clusters.</simpara>
<important>
<simpara>The Security Profiles Operator supports only Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes. Red Hat Enterprise Linux (RHEL) nodes are not supported.</simpara>
</important>
<section xml:id="spo-about_spo-understanding">
<title>About Security Profiles</title>
<simpara>Security profiles can increase security at the container level in your cluster.</simpara>
<simpara>Seccomp security profiles list the syscalls a process can make. Permissions are broader than SELinux, enabling users to restrict operations system-wide, such as <literal>write</literal>.</simpara>
<simpara>SELinux security profiles provide a label-based system that restricts the access and usage of processes, applications, or files in a system. All files in an environment have labels that define permissions. SELinux profiles can define access within a given structure, such as directories.</simpara>
</section>
</section>
<section xml:id="spo-enabling">
<title>Enabling the Security Profiles Operator</title>

<simpara>Before you can use the Security Profiles Operator, you must ensure the Operator is deployed in the cluster.</simpara>
<important>
<simpara>The Security Profiles Operator supports only Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes. Red Hat Enterprise Linux (RHEL) nodes are not supported.</simpara>
</important>
<important>
<simpara>The Security Profiles Operator only supports <literal>x86_64</literal> architecture.</simpara>
</important>
<section xml:id="spo-installing_spo-enabling">
<title>Installing the Security Profiles Operator</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Search for the Security Profiles Operator, then click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Keep the default selection of <emphasis role="strong">Installation mode</emphasis> and <emphasis role="strong">namespace</emphasis> to ensure that the Operator will be installed to the <literal>openshift-security-profiles</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To confirm that the installation is successful:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Check that the Security Profiles Operator is installed in the <literal>openshift-security-profiles</literal> namespace and its status is <literal>Succeeded</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If the Operator is not installed successfully:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page and inspect the <literal>Status</literal> column for any errors or failures.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> page and check the logs in any pods in the <literal>openshift-security-profiles</literal> project that are reporting issues.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="spo-installing-cli_spo-enabling">
<title>Installing the Security Profiles Operator using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a <literal>Namespace</literal> object:</simpara>
<formalpara>
<title>Example <literal>namespace-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
    name: openshift-security-profiles
labels:
  openshift.io/cluster-monitoring: "true"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f namespace-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> object:</simpara>
<formalpara>
<title>Example <literal>operator-group-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: security-profiles-operator
  namespace: openshift-security-profiles</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f operator-group-object.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a <literal>Subscription</literal> object:</simpara>
<formalpara>
<title>Example <literal>subscription-object.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: security-profiles-operator-sub
  namespace: openshift-security-profiles
spec:
  channel: release-alpha-rhel-8
  installPlanApproval: Automatic
  name: security-profiles-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f subscription-object.yaml</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>If you are setting the global scheduler feature and enable <literal>defaultNodeSelector</literal>, you must create the namespace manually and update the annotations of the <literal>openshift-security-profiles</literal> namespace, or the namespace where the Security Profiles Operator was installed, with <literal>openshift.io/node-selector: “”</literal>. This removes the default node selector and prevents deployment failures.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the installation succeeded by inspecting the following CSV file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-security-profiles</programlisting>
</listitem>
<listitem>
<simpara>Verify that the Security Profiles Operator is operational by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deploy -n openshift-security-profiles</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="logging-verbosity_spo-enabling">
<title>Configuring logging verbosity</title>
<simpara>The Security Profiles Operator supports the default logging verbosity of <literal>0</literal> and an enhanced verbosity of <literal>1</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To enable enhanced logging verbosity, patch the <literal>spod</literal> configuration and adjust the value by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod \
    spod --type=merge -p '{"spec":{"verbosity":1}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">securityprofilesoperatordaemon.security-profiles-operator.x-k8s.io/spod patched</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-seccomp">
<title>Managing seccomp profiles</title>

<simpara>Create and manage seccomp profiles and bind them to workloads.</simpara>
<important>
<simpara>The Security Profiles Operator supports only Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes. Red Hat Enterprise Linux (RHEL) nodes are not supported.</simpara>
</important>
<section xml:id="spo-creating-profiles_spo-seccomp">
<title>Creating seccomp profiles</title>
<simpara>Use the <literal>SeccompProfile</literal> object to create profiles.</simpara>
<simpara><literal>SeccompProfile</literal> objects can restrict syscalls within a container, limiting the access of your application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-namespace</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>SeccompProfile</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1beta1
kind: SeccompProfile
metadata:
  namespace: my-namespace
  name: profile1
spec:
  defaultAction: SCMP_ACT_LOG</programlisting>
</listitem>
</orderedlist>
<simpara>The seccomp profile will be saved in <literal>/var/lib/kubelet/seccomp/operator/&lt;namespace&gt;/&lt;name&gt;.json</literal>.</simpara>
<simpara>An <literal>init</literal> container creates the root directory of the Security Profiles Operator to run the Operator without <literal>root</literal> group or user ID privileges. A symbolic link is created from the rootless profile storage <literal>/var/lib/openshift-security-profiles</literal> to the default <literal>seccomp</literal> root path inside of the kubelet root <literal>/var/lib/kubelet/seccomp/operator</literal>.</simpara>
</section>
<section xml:id="spo-applying-profiles_spo-seccomp">
<title>Applying seccomp profiles to a pod</title>
<simpara>Create a pod to apply one of the created profiles.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod object that defines a <literal>securityContext</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  securityContext:
    seccompProfile:
      type: Localhost
      localhostProfile: operator/my-namespace/profile1.json
  containers:
    - name: test-container
      image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
</listitem>
<listitem>
<simpara>View the profile path of the <literal>seccompProfile.localhostProfile</literal> attribute by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace get seccompprofile profile1 --output wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       STATUS     AGE   SECCOMPPROFILE.LOCALHOSTPROFILE
profile1   Installed  14s   operator/my-namespace/profile1.json</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the path to the localhost profile by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sp profile1 --output=jsonpath='{.status.localhostProfile}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">operator/my-namespace/profile1.json</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the <literal>localhostProfile</literal> output to the patch file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  template:
    spec:
      securityContext:
        seccompProfile:
          type: Localhost
          localhostProfile: operator/my-namespace/profile1.json</programlisting>
</listitem>
<listitem>
<simpara>Apply the profile to any other workload, such as a <literal>Deployment</literal> object, by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace patch deployment myapp --patch-file patch.yaml --type=merge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">deployment.apps/myapp patched</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Confirm the profile was applied correctly by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace get deployment myapp --output=jsonpath='{.spec.template.spec.securityContext}' | jq .</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "seccompProfile": {
    "localhostProfile": "operator/my-namespace/profile1.json",
    "type": "localhost"
  }
}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<section xml:id="spo-binding-workloads_spo-seccomp">
<title>Binding workloads to profiles with ProfileBindings</title>
<simpara>You can use the <literal>ProfileBinding</literal> resource to bind a security profile to the <literal>SecurityContext</literal> of a container.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To bind a pod that uses a <literal>quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</literal> image to the example <literal>SeccompProfile</literal> profile, create a <literal>ProfileBinding</literal> object in the same namespace with the pod and the <literal>SeccompProfile</literal> objects:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileBinding
metadata:
  namespace: my-namespace
  name: nginx-binding
spec:
  profileRef:
    kind: SeccompProfile <co xml:id="CO49-1"/>
    name: profile <co xml:id="CO49-2"/>
  image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
<calloutlist>
<callout arearefs="CO49-1">
<para>The <literal>kind:</literal> variable refers to the name of the profile.</para>
</callout>
<callout arearefs="CO49-2">
<para>The <literal>name:</literal> variable refers to the name of the profile.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Label the namespace with <literal>enable-binding=true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace spo.x-k8s.io/enable-binding=true</programlisting>
</listitem>
<listitem>
<simpara>Define a pod named <literal>test-pod.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  containers:
  - name: test-container
    image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f test-pod.yaml</programlisting>
<note>
<simpara>If the pod already exists, you must re-create the pod for the binding to work properly.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Confirm the pod inherits the <literal>ProfileBinding</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test-pod -o jsonpath='{.spec.containers[*].securityContext.seccompProfile}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"localhostProfile":"operator/my-namespace/profile.json","type":"Localhost"}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="spo-recording-profiles_spo-seccomp">
<title>Recording profiles from workloads</title>
<simpara>The Security Profiles Operator can record system calls with <literal>ProfileRecording</literal> objects, making it easier to create baseline profiles for applications.</simpara>
<simpara>When using the log enricher for recording seccomp profiles, verify the log enricher feature is enabled. See <emphasis>Additional resources</emphasis> for more information.</simpara>
<note>
<simpara>A container with <literal>privileged: true</literal> security context restraints prevents log-based recording. Privileged containers are not subject to seccomp policies, and log-based recording makes use of a special seccomp profile to record events.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-namespace</programlisting>
</listitem>
<listitem>
<simpara>Label the namespace with <literal>enable-recording=true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace spo.x-k8s.io/enable-recording=true</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ProfileRecording</literal> object containing a <literal>recorder: logs</literal> variable:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileRecording
metadata:
  namespace: my-namespace
  name: test-recording
spec:
  kind: SeccompProfile
  recorder: logs
  podSelector:
    matchLabels:
      app: my-app</programlisting>
</listitem>
<listitem>
<simpara>Create a workload to record:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  namespace: my-namespace
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
    - name: nginx
      image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21
      ports:
        - containerPort: 8080
    - name: redis
      image: quay.io/security-profiles-operator/redis:6.2.1</programlisting>
</listitem>
<listitem>
<simpara>Confirm the pod is in a <literal>Running</literal> state by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     READY   STATUS    RESTARTS   AGE
my-pod   2/2     Running   0          18s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Confirm the enricher indicates that it receives audit logs for those containers:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles logs --since=1m --selector name=spod -c log-enricher</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">I0523 14:19:08.747313  430694 enricher.go:445] log-enricher "msg"="audit" "container"="redis" "executable"="/usr/local/bin/redis-server" "namespace"="my-namespace" "node"="xiyuan-23-5g2q9-worker-eastus2-6rpgf" "pid"=656802 "pod"="my-pod" "syscallID"=0 "syscallName"="read" "timestamp"="1684851548.745:207179" "type"="seccomp"</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Remove the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namepace delete pod my-pod</programlisting>
</listitem>
<listitem>
<simpara>Confirm the Security Profiles Operator reconciles the two seccomp profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get seccompprofiles -lspo.x-k8s.io/recording-id=test-recording -n my-namespace</programlisting>
<formalpara>
<title>Example output for seccompprofile</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   STATUS      AGE
test-recording-nginx   Installed   2m48s
test-recording-redis   Installed   2m48s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="spo-container-profile-instances_spo-seccomp">
<title>Merging per-container profile instances</title>
<simpara>By default, each container instance records into a separate profile. The Security Profiles Operator can merge the per-container profiles into a single profile. Merging profiles is useful when deploying applications using <literal>ReplicaSet</literal> or <literal>Deployment</literal> objects.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit a <literal>ProfileRecording</literal> object to include a <literal>mergeStrategy: containers</literal> variable:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileRecording
metadata:
  # The name of the Recording is the same as the resulting SeccompProfile CRD
  # after reconciliation.
  name: test-recording
  namespace: my-namespace
spec:
  kind: SeccompProfile
  recorder: logs
  mergeStrategy: containers
  podSelector:
    matchLabels:
      app: sp-record</programlisting>
</listitem>
<listitem>
<simpara>Label the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace security.openshift.io/scc.podSecurityLabelSync=false pod-security.kubernetes.io/enforce=privileged pod-security.kubernetes.io/audit=privileged pod-security.kubernetes.io/warn=privileged --overwrite=true</programlisting>
</listitem>
<listitem>
<simpara>Create the workload with the following YAML:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  namespace: my-namespace
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sp-record
  template:
    metadata:
      labels:
        app: sp-record
    spec:
      serviceAccountName: spo-record-sa
      containers:
      - name: nginx-record
        image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21
        ports:
        - containerPort: 8080</programlisting>
</listitem>
<listitem>
<simpara>To record the individual profiles, delete the deployment by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete deployment nginx-deploy -n my-namespace</programlisting>
</listitem>
<listitem>
<simpara>To merge the profiles, delete the profile recording by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete profilerecording test-recording -n my-namespace</programlisting>
</listitem>
<listitem>
<simpara>To start the merge operation and generate the results profile, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get seccompprofiles -lspo.x-k8s.io/recording-id=test-recording -n my-namespace</programlisting>
<formalpara>
<title>Example output for seccompprofiles</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          STATUS       AGE
test-recording-nginx-record   Installed    55s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view the permissions used by any of the containers, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get seccompprofiles test-recording-nginx-record -o yaml</programlisting>
</listitem>
</orderedlist>
<bridgehead xml:id="additional-resources_spo-seccomp" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../authentication/managing-security-context-constraints.xml">Managing security context constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.redhat.com/blog/managing-sccs-in-openshift">Managing SCCs in OpenShift</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-log-enricher_spo-advanced">Using the log enricher</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/security_profiles_operator/spo-understanding.xml#spo-about_spo-understanding">About security profiles</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="spo-selinux">
<title>Managing SELinux profiles</title>

<simpara>Create and manage SELinux profiles and bind them to workloads.</simpara>
<important>
<simpara>The Security Profiles Operator supports only Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes. Red Hat Enterprise Linux (RHEL) nodes are not supported.</simpara>
</important>
<section xml:id="spo-creating-profiles_spo-selinux">
<title>Creating SELinux profiles</title>
<simpara>Use the <literal>SelinuxProfile</literal> object to create profiles.</simpara>
<simpara>The <literal>SelinuxProfile</literal> object has several features that allow for better security hardening and readability:</simpara>
<itemizedlist>
<listitem>
<simpara>Restricts the profiles to inherit from to the current namespace or a system-wide profile. Because there are typically many profiles installed on the system, but only a subset should be used by cluster workloads, the inheritable system profiles are listed in the <literal>spod</literal> instance in <literal>spec.selinuxOptions.allowedSystemProfiles</literal>.</simpara>
</listitem>
<listitem>
<simpara>Performs basic validation of the permissions, classes and labels.</simpara>
</listitem>
<listitem>
<simpara>Adds a new keyword <literal>@self</literal> that describes the process using the policy. This allows reusing a policy between workloads and namespaces easily, as the usage of the policy is based on the name and namespace.</simpara>
</listitem>
<listitem>
<simpara>Adds features for better security hardening and readability compared to writing a profile directly in the SELinux CIL language.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project nginx-deploy</programlisting>
</listitem>
<listitem>
<simpara>Create a policy that can be used with a non-privileged workload by creating the following <literal>SelinuxProfile</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha2
kind: SelinuxProfile
metadata:
  name: nginx-secure
  namespace: nginx-deploy
spec:
  allow:
    '@self':
      tcp_socket:
      - listen
    http_cache_port_t:
      tcp_socket:
      - name_bind
    node_t:
      tcp_socket:
      - node_bind
  inherit:
  - kind: System
    name: container</programlisting>
</listitem>
<listitem>
<simpara>Wait for <literal>selinuxd</literal> to install the policy by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc wait --for=condition=ready -n nginx-deploy selinuxprofile nginx-secure</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">selinuxprofile.security-profiles-operator.x-k8s.io/nginx-secure condition met</programlisting>
</para>
</formalpara>
<simpara>The policies are placed into an <literal>emptyDir</literal> in the container owned by the Security Profiles Operator. The policies are saved in Common Intermediate Language (CIL) format in <literal>/etc/selinux.d/&lt;name&gt;_&lt;namespace&gt;.cil</literal>.</simpara>
</listitem>
<listitem>
<simpara>Access the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles rsh -c selinuxd ds/spod</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the file contents with <literal>cat</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /etc/selinux.d/nginx-secure_nginx-deploy.cil</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">(block nginx-secure_nginx-deploy
(blockinherit container)
(allow process nginx-secure_nginx-deploy.process ( tcp_socket ( listen )))
(allow process http_cache_port_t ( tcp_socket ( name_bind )))
(allow process node_t ( tcp_socket ( node_bind )))
)</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that a policy has been installed by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ semodule -l | grep nginx-secure</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">nginx-secure_nginx-deploy</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="spo-applying-profiles_spo-selinux">
<title>Applying SELinux profiles to a pod</title>
<simpara>Create a pod to apply one of the created profiles.</simpara>
<simpara>For SELinux profiles, the namespace must be labelled to allow <link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">privileged</link> workloads.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the <literal>scc.podSecurityLabelSync=false</literal> label to the <literal>nginx-deploy</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns nginx-deploy security.openshift.io/scc.podSecurityLabelSync=false</programlisting>
</listitem>
<listitem>
<simpara>Apply the <literal>privileged</literal> label to the <literal>nginx-deploy</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns nginx-deploy --overwrite=true pod-security.kubernetes.io/enforce=privileged</programlisting>
</listitem>
<listitem>
<simpara>Obtain the SELinux profile usage string by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get selinuxprofile.security-profiles-operator.x-k8s.io/nginx-secure -n nginx-deploy -ojsonpath='{.status.usage}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">nginx-secure_nginx-deploy.process</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the output string in the workload manifest in the <literal>.spec.containers[].securityContext.seLinuxOptions</literal> attribute:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx-secure
  namespace: nginx-deploy
spec:
  containers:
    - image: nginxinc/nginx-unprivileged:1.21
      name: nginx
      securityContext:
        seLinuxOptions:
          # NOTE: This uses an appropriate SELinux type
          type: nginx-secure_nginx-deploy.process</programlisting>
<important>
<simpara>The SELinux <literal>type</literal> must exist before creating the workload.</simpara>
</important>
</listitem>
</orderedlist>
<section xml:id="spo-selinux-permissive_spo-selinux">
<title>Applying SELinux log policies</title>
<simpara>To log policy violations or AVC denials, set the <literal>SElinuxProfile</literal> profile to <literal>permissive</literal>.</simpara>
<important>
<simpara>This procedure defines logging policies. It does not set enforcement policies.</simpara>
</important>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add <literal>permissive: true</literal> to an <literal>SElinuxProfile</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha2
kind: SelinuxProfile
metadata:
  name: nginx-secure
  namespace: nginx-deploy
spec:
  permissive: true</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-binding-workloads_spo-selinux">
<title>Binding workloads to profiles with ProfileBindings</title>
<simpara>You can use the <literal>ProfileBinding</literal> resource to bind a security profile to the <literal>SecurityContext</literal> of a container.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To bind a pod that uses a <literal>quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</literal> image to the example <literal>SelinuxProfile</literal> profile, create a <literal>ProfileBinding</literal> object in the same namespace with the pod and the <literal>SelinuxProfile</literal> objects:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileBinding
metadata:
  namespace: my-namespace
  name: nginx-binding
spec:
  profileRef:
    kind: SelinuxProfile <co xml:id="CO50-1"/>
    name: profile <co xml:id="CO50-2"/>
  image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
<calloutlist>
<callout arearefs="CO50-1">
<para>The <literal>kind:</literal> variable refers to the name of the profile.</para>
</callout>
<callout arearefs="CO50-2">
<para>The <literal>name:</literal> variable refers to the name of the profile.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Label the namespace with <literal>enable-binding=true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace spo.x-k8s.io/enable-binding=true</programlisting>
</listitem>
<listitem>
<simpara>Define a pod named <literal>test-pod.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: test-pod
spec:
  containers:
  - name: test-container
    image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f test-pod.yaml</programlisting>
<note>
<simpara>If the pod already exists, you must re-create the pod for the binding to work properly.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Confirm the pod inherits the <literal>ProfileBinding</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test-pod -o jsonpath='{.spec.containers[*].securityContext.seLinuxOptions.type}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">profile_nginx-binding.process</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-replicating-controllers_spo-selinux">
<title>Replicating controllers and SecurityContextConstraints</title>
<simpara>When you deploy SELinux policies for replicating controllers, such as deployments or daemon sets, note that the <literal>Pod</literal> objects spawned by the controllers are not running with the identity of the user who creates the workload. Unless a <literal>ServiceAccount</literal> is selected, the pods might revert to using a restricted <literal>SecurityContextConstraints</literal> (SCC) which does not allow use of custom security policies.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project nginx-secure</programlisting>
</listitem>
<listitem>
<simpara>Create the following <literal>RoleBinding</literal> object to allow SELinux policies to be used in the <literal>nginx-secure</literal> namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: spo-nginx
  namespace: nginx-secure
subjects:
- kind: ServiceAccount
  name: spo-deploy-test
roleRef:
  kind: Role
  name: spo-nginx
  apiGroup: rbac.authorization.k8s.io</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Role</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  creationTimestamp: null
  name: spo-nginx
  namespace: nginx-secure
rules:
- apiGroups:
  - security.openshift.io
  resources:
  - securitycontextconstraints
  resourceNames:
  - privileged
  verbs:
  - use</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>ServiceAccount</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: null
  name: spo-deploy-test
  namespace: nginx-secure</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: selinux-test
  namespace: nginx-secure
  metadata:
    labels:
      app: selinux-test
spec:
  replicas: 3
  selector:
    matchLabels:
      app: selinux-test
  template:
    metadata:
      labels:
        app: selinux-test
    spec:
      serviceAccountName: spo-deploy-test
      securityContext:
        seLinuxOptions:
          type: nginx-secure_nginx-secure.process <co xml:id="CO51-1"/>
      containers:
      - name: nginx-unpriv
        image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21
        ports:
        - containerPort: 8080</programlisting>
<calloutlist>
<callout arearefs="CO51-1">
<para>The <literal>.seLinuxOptions.type</literal> must exist before the Deployment is created.</para>
</callout>
</calloutlist>
<note>
<simpara>The SELinux type is not specified in the workload and is handled by the SCC. When the pods are created by the deployment and the <literal>ReplicaSet</literal>, the pods will run with the appropriate profile.</simpara>
</note>
</listitem>
</orderedlist>
<simpara>Ensure that your SCC is usable by only the correct service account. Refer to <emphasis>Additional resources</emphasis> for more information.</simpara>
</section>
</section>
<section xml:id="spo-recording-profiles_spo-selinux">
<title>Recording profiles from workloads</title>
<simpara>The Security Profiles Operator can record system calls with <literal>ProfileRecording</literal> objects, making it easier to create baseline profiles for applications.</simpara>
<simpara>When using the log enricher for recording SELinux profiles, verify the log enricher feature is enabled. See <emphasis>Additional resources</emphasis> for more information.</simpara>
<note>
<simpara>A container with <literal>privileged: true</literal> security context restraints prevents log-based recording. Privileged containers are not subject to SELinux policies, and log-based recording makes use of a special SELinux profile to record events.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-namespace</programlisting>
</listitem>
<listitem>
<simpara>Label the namespace with <literal>enable-recording=true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace spo.x-k8s.io/enable-recording=true</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ProfileRecording</literal> object containing a <literal>recorder: logs</literal> variable:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileRecording
metadata:
  namespace: my-namespace
  name: test-recording
spec:
  kind: SelinuxProfile
  recorder: logs
  podSelector:
    matchLabels:
      app: my-app</programlisting>
</listitem>
<listitem>
<simpara>Create a workload to record:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  namespace: my-namespace
  name: my-pod
  labels:
    app: my-app
spec:
  containers:
    - name: nginx
      image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21
      ports:
        - containerPort: 8080
    - name: redis
      image: quay.io/security-profiles-operator/redis:6.2.1</programlisting>
</listitem>
<listitem>
<simpara>Confirm the pod is in a <literal>Running</literal> state by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     READY   STATUS    RESTARTS   AGE
my-pod   2/2     Running   0          18s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Confirm the enricher indicates that it receives audit logs for those containers:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles logs --since=1m --selector name=spod -c log-enricher</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">I0517 13:55:36.383187  348295 enricher.go:376] log-enricher "msg"="audit" "container"="redis" "namespace"="my-namespace" "node"="ip-10-0-189-53.us-east-2.compute.internal" "perm"="name_bind" "pod"="my-pod" "profile"="test-recording_redis_6kmrb_1684331729" "scontext"="system_u:system_r:selinuxrecording.process:s0:c4,c27" "tclass"="tcp_socket" "tcontext"="system_u:object_r:redis_port_t:s0" "timestamp"="1684331735.105:273965" "type"="selinux"</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Remove the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namepace delete pod my-pod</programlisting>
</listitem>
<listitem>
<simpara>Confirm the Security Profiles Operator reconciles the two SELinux profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get selinuxprofiles -lspo.x-k8s.io/recording-id=test-recording -n my-namespace</programlisting>
<formalpara>
<title>Example output for selinuxprofile</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   USAGE                                       STATE
test-recording-nginx   test-recording-nginx_my-namespace.process   Installed
test-recording-redis   test-recording-redis_my-namespace.process   Installed</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="spo-container-profile-instances_spo-selinux">
<title>Merging per-container profile instances</title>
<simpara>By default, each container instance records into a separate profile. The Security Profiles Operator can merge the per-container profiles into a single profile. Merging profiles is useful when deploying applications using <literal>ReplicaSet</literal> or <literal>Deployment</literal> objects.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit a <literal>ProfileRecording</literal> object to include a <literal>mergeStrategy: containers</literal> variable:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1alpha1
kind: ProfileRecording
metadata:
  # The name of the Recording is the same as the resulting SelinuxProfile CRD
  # after reconciliation.
  name: test-recording
  namespace: my-namespace
spec:
  kind: SelinuxProfile
  recorder: logs
  mergeStrategy: containers
  podSelector:
    matchLabels:
      app: sp-record</programlisting>
</listitem>
<listitem>
<simpara>Label the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label ns my-namespace security.openshift.io/scc.podSecurityLabelSync=false pod-security.kubernetes.io/enforce=privileged pod-security.kubernetes.io/audit=privileged pod-security.kubernetes.io/warn=privileged --overwrite=true</programlisting>
</listitem>
<listitem>
<simpara>Create the workload with the following YAML:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deploy
  namespace: my-namespace
spec:
  replicas: 3
  selector:
    matchLabels:
      app: sp-record
  template:
    metadata:
      labels:
        app: sp-record
    spec:
      serviceAccountName: spo-record-sa
      containers:
      - name: nginx-record
        image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21
        ports:
        - containerPort: 8080</programlisting>
</listitem>
<listitem>
<simpara>To record the individual profiles, delete the deployment by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete deployment nginx-deploy -n my-namespace</programlisting>
</listitem>
<listitem>
<simpara>To merge the profiles, delete the profile recording by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete profilerecording test-recording -n my-namespace</programlisting>
</listitem>
<listitem>
<simpara>To start the merge operation and generate the results profile, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get selinuxprofiles -lspo.x-k8s.io/recording-id=test-recording -n my-namespace</programlisting>
<formalpara>
<title>Example output for selinuxprofiles</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          USAGE                                              STATE
test-recording-nginx-record   test-recording-nginx-record_my-namespace.process   Installed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view the permissions used by any of the containers, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get selinuxprofiles test-recording-nginx-record -o yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="spo-selinux-runasany_spo-selinux">
<title>About seLinuxContext: RunAsAny</title>
<simpara>Recording of SELinux policies is implemented with a webhook that injects a special SELinux type to the pods being recorded. The SELinux type makes the pod run in <literal>permissive</literal> mode, logging all the AVC denials into <literal>audit.log</literal>. By default, a workload is not allowed to run with a custom SELinux policy, but uses an auto-generated type.</simpara>
<simpara>To record a workload, the workload must use a service account that has permissions to use an SCC that allows the webhook to inject the permissive SELinux type. The <literal>privileged</literal> SCC contains <literal>seLinuxContext: RunAsAny</literal>.</simpara>
<simpara>In addition, the namespace must be labeled with <literal>pod-security.kubernetes.io/enforce: privileged</literal> if your cluster enables the <link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-admission/">Pod Security Admission</link> because only the <literal>privileged</literal> <link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-standards/#privileged">Pod Security Standard</link> allows using a custom SELinux policy.</simpara>
<bridgehead xml:id="additional-resources_spo-selinux" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../authentication/managing-security-context-constraints.xml">Managing security context constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cloud.redhat.com/blog/managing-sccs-in-openshift">Managing SCCs in OpenShift</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/security_profiles_operator/spo-advanced.xml#spo-log-enricher_spo-advanced">Using the log enricher</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/security_profiles_operator/spo-understanding.xml#spo-about_spo-understanding">About security profiles</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="spo-advanced">
<title>Advanced Security Profiles Operator tasks</title>

<simpara>Use advanced tasks to enable metrics, configure webhooks, or restrict syscalls.</simpara>
<section xml:id="spo-restrict-syscalls_spo-advanced">
<title>Restrict the allowed syscalls in seccomp profiles</title>
<simpara>The Security Profiles Operator does not restrict <literal>syscalls</literal> in <literal>seccomp</literal> profiles by default. You can define the list of allowed <literal>syscalls</literal> in the <literal>spod</literal> configuration.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To define the list of <literal>allowedSyscalls</literal>, adjust the <literal>spec</literal> parameter by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod spod --type merge \
    -p '{"spec":{"allowedSyscalls": ["exit", "exit_group", "futex", "nanosleep"]}}'</programlisting>
</listitem>
</itemizedlist>
<important>
<simpara>The Operator will install only the <literal>seccomp</literal> profiles, which have a subset of <literal>syscalls</literal> defined into the allowed list. All profiles not complying with this ruleset are rejected.</simpara>
<simpara>When the list of allowed <literal>syscalls</literal> is modified in the <literal>spod</literal> configuration, the Operator will identify the already installed profiles which are non-compliant and remove them automatically.</simpara>
</important>
</section>
<section xml:id="spo-base-syscalls_spo-advanced">
<title>Base syscalls for a container runtime</title>
<simpara>You can use the <literal>baseProfileName</literal> attribute to establish the minimum required <literal>syscalls</literal> for a given runtime to start a container.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>SeccompProfile</literal> kind object and add <literal>baseProfileName: runc-v1.0.0</literal> to the <literal>spec</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1beta1
kind: SeccompProfile
metadata:
  namespace: my-namespace
  name: example-name
spec:
  defaultAction: SCMP_ACT_ERRNO
  baseProfileName: runc-v1.0.0
  syscalls:
    - action: SCMP_ACT_ALLOW
      names:
        - exit_group</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-memory-optimization_spo-advanced">
<title>Enabling memory optimization in the spod daemon</title>
<simpara>The controller running inside of <literal>spod</literal> daemon process watches all pods available in the cluster when profile recording is enabled. This can lead to very high memory usage in large clusters, resulting in the <literal>spod</literal> daemon running out of memory or crashing.</simpara>
<simpara>To prevent crashes, the <literal>spod</literal> daemon can be configured to only load the pods labeled for profile recording into the cache memory.</simpara>
<simpara>+</simpara>
<note>
<simpara>SPO memory optimization is not enabled by default.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Enable memory optimization by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod spod --type=merge -p '{"spec":{"enableMemoryOptimization":true}}'</programlisting>
</listitem>
<listitem>
<simpara>To record a security profile for a pod, the pod must be labeled with <literal>spo.x-k8s.io/enable-recording: "true"</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-recording-pod
  labels:
    spo.x-k8s.io/enable-recording: "true"</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="spo-daemon-requirements_spo-advanced">
<title>Customizing daemon resource requirements</title>
<simpara>The default resource requirements of the daemon container can be adjusted by using the field <literal>daemonResourceRequirements</literal>
from the <literal>spod</literal> configuration.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To specify the memory and cpu requests and limits of the daemon container, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod spod --type merge -p \
    '{"spec":{"daemonResourceRequirements": { \
    "requests": {"memory": "256Mi", "cpu": "250m"}, \
    "limits": {"memory": "512Mi", "cpu": "500m"}}}}'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-custom-priority-class_spo-advanced">
<title>Setting a custom priority class name for the spod daemon pod</title>
<simpara>The default priority class name of the <literal>spod</literal> daemon pod is set to <literal>system-node-critical</literal>. A custom priority class name can be configured in the <literal>spod</literal> configuration by setting a value in the <literal>priorityClassName</literal> field.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Configure the priority class name by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod spod --type=merge -p '{"spec":{"priorityClassName":"my-priority-class"}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">securityprofilesoperatordaemon.openshift-security-profiles.x-k8s.io/spod patched</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="spo-using-metrics_spo-advanced">
<title>Using metrics</title>
<simpara>The <literal>openshift-security-profiles</literal> namespace provides metrics endpoints, which are secured by the <link xlink:href="https://github.com/brancz/kube-rbac-proxy">kube-rbac-proxy</link> container. All metrics are exposed by the <literal>metrics</literal> service within the <literal>openshift-security-profiles</literal> namespace.</simpara>
<simpara>The Security Profiles Operator includes a cluster role and corresponding binding <literal>spo-metrics-client</literal> to retrieve the metrics from within the cluster. There are two metrics paths available:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>metrics.openshift-security-profiles/metrics</literal>: for controller runtime metrics</simpara>
</listitem>
<listitem>
<simpara><literal>metrics.openshift-security-profiles/metrics-spod</literal>: for the Operator daemon metrics</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To view the status of the metrics service, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get svc/metrics -n openshift-security-profiles</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
metrics   ClusterIP   10.0.0.228   &lt;none&gt;        443/TCP   43s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To retrieve the metrics, query the service endpoint using the default <literal>ServiceAccount</literal> token in the <literal>openshift-security-profiles</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc run --rm -i --restart=Never --image=registry.fedoraproject.org/fedora-minimal:latest \
    -n openshift-security-profiles metrics-test -- bash -c \
    'curl -ks -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" https://metrics.openshift-security-profiles/metrics-spod'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># HELP security_profiles_operator_seccomp_profile_total Counter about seccomp profile operations.
# TYPE security_profiles_operator_seccomp_profile_total counter
security_profiles_operator_seccomp_profile_total{operation="delete"} 1
security_profiles_operator_seccomp_profile_total{operation="update"} 2</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To retrieve metrics from a different namespace, link the <literal>ServiceAccount</literal> to the <literal>spo-metrics-client</literal> <literal>ClusterRoleBinding</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterrolebinding spo-metrics-client -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 ROLE                             AGE   USERS   GROUPS   SERVICEACCOUNTS
spo-metrics-client   ClusterRole/spo-metrics-client   35m                    openshift-security-profiles/default</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="spo-runtime-metrics_spo-advanced">
<title>controller-runtime metrics</title>
<simpara>The controller-runtime <literal>metrics</literal> and the DaemonSet endpoint <literal>metrics-spod</literal> provide a set of default metrics. Additional metrics are provided by the daemon, which are always prefixed with <literal>security_profiles_operator_</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Available controller-runtime metrics</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Metric key</entry>
<entry align="left" valign="top">Possible labels</entry>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>seccomp_profile_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>operation={delete,update}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of seccomp profile operations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>seccomp_profile_audit_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>node</literal>, <literal>namespace</literal>, <literal>pod</literal>, <literal>container</literal>, <literal>executable</literal>, <literal>syscall</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of seccomp profile audit operations. Requires the log enricher to be enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>seccomp_profile_bpf_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>node</literal>, <literal>mount_namespace</literal>, <literal>profile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of seccomp profile bpf operations. Requires the bpf recorder to be enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>seccomp_profile_error_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>reason={</literal><?asciidoc-br?>
<literal>SeccompNotSupportedOnNode,</literal><?asciidoc-br?>
<literal>InvalidSeccompProfile,</literal><?asciidoc-br?>
<literal>CannotSaveSeccompProfile,</literal><?asciidoc-br?>
<literal>CannotRemoveSeccompProfile,</literal><?asciidoc-br?>
<literal>CannotUpdateSeccompProfile,</literal><?asciidoc-br?>
<literal>CannotUpdateNodeStatus</literal><?asciidoc-br?>
<literal>}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of seccomp profile errors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>selinux_profile_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>operation={delete,update}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of SELinux profile operations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>selinux_profile_audit_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>node</literal>, <literal>namespace</literal>, <literal>pod</literal>, <literal>container</literal>, <literal>executable</literal>, <literal>scontext</literal>,<literal>tcontext</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of SELinux profile audit operations. Requires the log enricher to be enabled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>selinux_profile_error_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>reason={</literal><?asciidoc-br?>
<literal>CannotSaveSelinuxPolicy,</literal><?asciidoc-br?>
<literal>CannotUpdatePolicyStatus,</literal><?asciidoc-br?>
<literal>CannotRemoveSelinuxPolicy,</literal><?asciidoc-br?>
<literal>CannotContactSelinuxd,</literal><?asciidoc-br?>
<literal>CannotWritePolicyFile,</literal><?asciidoc-br?>
<literal>CannotGetPolicyStatus</literal><?asciidoc-br?>
<literal>}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Counter</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of SELinux profile errors.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="spo-log-enricher_spo-advanced">
<title>Using the log enricher</title>
<simpara>The Security Profiles Operator contains a log enrichment feature, which is disabled by default. The log enricher container runs with <literal>privileged</literal> permissions to read the audit logs from the local node. The log enricher runs within the host PID namespace, <literal>hostPID</literal>.</simpara>
<important>
<simpara>The log enricher must have permissions to read the host processes.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Patch the <literal>spod</literal> configuration to enable the log enricher by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod spod \
    --type=merge -p '{"spec":{"enableLogEnricher":true}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">securityprofilesoperatordaemon.security-profiles-operator.x-k8s.io/spod patched</programlisting>
</para>
</formalpara>
<note>
<simpara>The Security Profiles Operator will re-deploy the <literal>spod</literal> daemon set automatically.</simpara>
</note>
</listitem>
<listitem>
<simpara>View the audit logs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles logs -f ds/spod log-enricher</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">I0623 12:51:04.257814 1854764 deleg.go:130] setup "msg"="starting component: log-enricher"  "buildDate"="1980-01-01T00:00:00Z" "compiler"="gc" "gitCommit"="unknown" "gitTreeState"="clean" "goVersion"="go1.16.2" "platform"="linux/amd64" "version"="0.4.0-dev"
I0623 12:51:04.257890 1854764 enricher.go:44] log-enricher "msg"="Starting log-enricher on node: 127.0.0.1"
I0623 12:51:04.257898 1854764 enricher.go:46] log-enricher "msg"="Connecting to local GRPC server"
I0623 12:51:04.258061 1854764 enricher.go:69] log-enricher "msg"="Reading from file /var/log/audit/audit.log"
2021/06/23 12:51:04 Seeked /var/log/audit/audit.log - &amp;{Offset:0 Whence:2}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="spo-log-enricher-app-trace_spo-advanced">
<title>Using the log enricher to trace an application</title>
<simpara>You can use the Security Profiles Operator log enricher to trace an application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To trace an application, create a <literal>SeccompProfile</literal> logging profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: security-profiles-operator.x-k8s.io/v1beta1
kind: SeccompProfile
metadata:
  name: log
  namespace: default
spec:
  defaultAction: SCMP_ACT_LOG</programlisting>
</listitem>
<listitem>
<simpara>Create a pod object to use the profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: log-pod
spec:
  securityContext:
    seccompProfile:
      type: Localhost
      localhostProfile: operator/default/log.json
  containers:
    - name: log-container
      image: quay.io/security-profiles-operator/test-nginx-unprivileged:1.21</programlisting>
</listitem>
<listitem>
<simpara>Examine the log enricher output by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles logs -f ds/spod log-enricher</programlisting>
<example>
<title>Example output</title>
<programlisting language="terminal" linenumbering="unnumbered">…
I0623 12:59:11.479869 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=3 "syscallName"="close" "timestamp"="1624453150.205:1061" "type"="seccomp"
I0623 12:59:11.487323 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=157 "syscallName"="prctl" "timestamp"="1624453150.205:1062" "type"="seccomp"
I0623 12:59:11.492157 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=157 "syscallName"="prctl" "timestamp"="1624453150.205:1063" "type"="seccomp"
…
I0623 12:59:20.258523 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=12 "syscallName"="brk" "timestamp"="1624453150.235:2873" "type"="seccomp"
I0623 12:59:20.263349 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=21 "syscallName"="access" "timestamp"="1624453150.235:2874" "type"="seccomp"
I0623 12:59:20.354091 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=257 "syscallName"="openat" "timestamp"="1624453150.235:2875" "type"="seccomp"
I0623 12:59:20.358844 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=5 "syscallName"="fstat" "timestamp"="1624453150.235:2876" "type"="seccomp"
I0623 12:59:20.363510 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=9 "syscallName"="mmap" "timestamp"="1624453150.235:2877" "type"="seccomp"
I0623 12:59:20.454127 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=3 "syscallName"="close" "timestamp"="1624453150.235:2878" "type"="seccomp"
I0623 12:59:20.458654 1854764 enricher.go:111] log-enricher "msg"="audit"  "container"="log-container" "executable"="/usr/sbin/nginx" "namespace"="default" "node"="127.0.0.1" "pid"=1905792 "pod"="log-pod" "syscallID"=257 "syscallName"="openat" "timestamp"="1624453150.235:2879" "type"="seccomp"
…</programlisting>
</example>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="spo-configuring-webhooks_spo-advanced">
<title>Configuring webhooks</title>
<simpara>Profile binding and profile recording objects can use webhooks. Profile binding and recording object configurations are <literal>MutatingWebhookConfiguration</literal> CRs, managed by the Security Profiles Operator.</simpara>
<simpara>To change the webhook configuration, the <literal>spod</literal> CR exposes a <literal>webhookOptions</literal> field that allows modification of the <literal>failurePolicy</literal>, <literal>namespaceSelector</literal>, and <literal>objectSelector</literal> variables. This allows you to set the webhooks to "soft-fail" or restrict them to a subset of a namespaces so that even if the webhooks failed, other namespaces or resources are not affected.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the <literal>recording.spo.io</literal> webhook configuration to record only pods labeled with <literal>spo-record=true</literal> by creating the following patch file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  webhookOptions:
    - name: recording.spo.io
      objectSelector:
        matchExpressions:
          - key: spo-record
            operator: In
            values:
              - "true"</programlisting>
</listitem>
<listitem>
<simpara>Patch the <literal>spod/spod</literal> instance by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles patch spod \
    spod -p $(cat /tmp/spod-wh.patch) --type=merge</programlisting>
</listitem>
<listitem>
<simpara>To view the resulting <literal>MutatingWebhookConfiguration</literal> object, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MutatingWebhookConfiguration \
    spo-mutating-webhook-configuration -oyaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="spo-troubleshooting">
<title>Troubleshooting the Security Profiles Operator</title>

<simpara>Troubleshoot the Security Profiles Operator to diagnose a problem or provide information in a bug report.</simpara>
<section xml:id="spo-inspecting-seccomp-profiles_spo-troubleshooting">
<title>Inspecting seccomp profiles</title>
<simpara>Corrupted <literal>seccomp</literal> profiles can disrupt your workloads. Ensure that the user cannot abuse the system by not allowing other workloads to map any part of the path <literal>/var/lib/kubelet/seccomp/operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the profile is reconciled by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-security-profiles logs openshift-security-profiles-&lt;id&gt;</programlisting>
<example>
<title>Example output</title>
<programlisting language="terminal" linenumbering="unnumbered">I1019 19:34:14.942464       1 main.go:90] setup "msg"="starting openshift-security-profiles"  "buildDate"="2020-10-19T19:31:24Z" "compiler"="gc" "gitCommit"="a3ef0e1ea6405092268c18f240b62015c247dd9d" "gitTreeState"="dirty" "goVersion"="go1.15.1" "platform"="linux/amd64" "version"="0.2.0-dev"
I1019 19:34:15.348389       1 listener.go:44] controller-runtime/metrics "msg"="metrics server is starting to listen"  "addr"=":8080"
I1019 19:34:15.349076       1 main.go:126] setup "msg"="starting manager"
I1019 19:34:15.349449       1 internal.go:391] controller-runtime/manager "msg"="starting metrics server"  "path"="/metrics"
I1019 19:34:15.350201       1 controller.go:142] controller "msg"="Starting EventSource" "controller"="profile" "reconcilerGroup"="security-profiles-operator.x-k8s.io" "reconcilerKind"="SeccompProfile" "source"={"Type":{"metadata":{"creationTimestamp":null},"spec":{"defaultAction":""}}}
I1019 19:34:15.450674       1 controller.go:149] controller "msg"="Starting Controller" "controller"="profile" "reconcilerGroup"="security-profiles-operator.x-k8s.io" "reconcilerKind"="SeccompProfile"
I1019 19:34:15.450757       1 controller.go:176] controller "msg"="Starting workers" "controller"="profile" "reconcilerGroup"="security-profiles-operator.x-k8s.io" "reconcilerKind"="SeccompProfile" "worker count"=1
I1019 19:34:15.453102       1 profile.go:148] profile "msg"="Reconciled profile from SeccompProfile" "namespace"="openshift-security-profiles" "profile"="nginx-1.19.1" "name"="nginx-1.19.1" "resource version"="728"
I1019 19:34:15.453618       1 profile.go:148] profile "msg"="Reconciled profile from SeccompProfile" "namespace"="openshift-security-profiles" "profile"="openshift-security-profiles" "name"="openshift-security-profiles" "resource version"="729"</programlisting>
</example>
</listitem>
<listitem>
<simpara>Confirm that the <literal>seccomp</literal> profiles are saved into the correct path by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -t -n openshift-security-profiles openshift-security-profiles-&lt;id&gt; \
    -- ls /var/lib/kubelet/seccomp/operator/my-namespace/my-workload</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">profile-block.json
profile-complain.json</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="spo-uninstalling">
<title>Uninstalling the Security Profiles Operator</title>
<simpara>You can remove the Security Profiles Operator from your cluster by using the OpenShift Container Platform web console.</simpara>

<section xml:id="spo-uninstall-console_spo-uninstalling">
<title>Uninstall the Security Profiles Operator using the web console</title>
<simpara>To remove the Security Profiles Operator, you must first delete the <literal>seccomp</literal> and SELinux profiles. After the profiles are removed, you can then remove the Operator and its namespace by deleting the <emphasis role="strong">openshift-security-profiles</emphasis> project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an OpenShift Container Platform cluster that uses an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>The Security Profiles Operator is installed.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To remove the Security Profiles Operator by using the OpenShift Container Platform web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Delete all <literal>seccomp</literal> profiles, SELinux profiles, and webhook configurations.</simpara>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> on the <emphasis role="strong">Security Profiles Operator</emphasis> entry and select <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Search for <literal>security profiles</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">openshift-security-profiles</emphasis> project, and select <emphasis role="strong">Delete Project</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Confirm the deletion by typing <literal>openshift-security-profiles</literal> in the dialog box, and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>MutatingWebhookConfiguration</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete MutatingWebhookConfiguration spo-mutating-webhook-configuration</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="_nbde_tang_server_operator">
<title>NBDE Tang Server Operator</title>
<section xml:id="nbde-tang-server-operator-overview">
<title>NBDE Tang Server Operator overview</title>

<simpara>Network-bound Disk Encryption (NBDE) provides an automated unlocking of LUKS-encrypted volumes using one or more dedicated network-binding servers. The client side of NBDE is called the Clevis decryption policy framework and the server side is represented by Tang.</simpara>
<simpara>The NBDE Tang Server Operator allows the automation of deployments of one or several Tang servers in the OpenShift Container Platform (OCP) environment.</simpara>
</section>
<section xml:id="nbde-tang-server-operator-release-notes">
<title>NBDE Tang Server Operator release notes</title>

<simpara>The following release notes track the development of the Security Profiles Operator in the OpenShift Container Platform.</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHEA-2023:7491">RHEA-2023:7491 - Release of the NBDE Tang Server Operator 1.0</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="understanding-nbde-tang-server-operator">
<title>Understanding the NBDE Tang Server Operator</title>

<simpara>You can use the NBDE Tang Server Operator to automate the deployment of a Tang server in an OpenShift Container Platform cluster that requires Network Bound Disk Encryption (NBDE) internally, leveraging the tools that OpenShift Container Platform provides to achieve this automation.</simpara>
<simpara>The NBDE Tang Server Operator simplifies the installation process and uses native features provided by the OpenShift Container Platform environment, such as multi-replica deployment, scaling, traffic load balancing, and so on. The Operator also provides automation of certain operations that are error-prone when you perform them manually, for example:</simpara>
<itemizedlist>
<listitem>
<simpara>server deployment and configuration</simpara>
</listitem>
<listitem>
<simpara>key rotation</simpara>
</listitem>
<listitem>
<simpara>hidden keys deletion</simpara>
</listitem>
</itemizedlist>
<simpara>The NBDE Tang Server Operator is implemented using the Operator SDK and allows the deployment of one or more Tang servers in OpenShift through custom resource definitions (CRDs).</simpara>
<section xml:id="understanding-nbde-tang-server-operator_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://cloud.redhat.com/blog/tang-operator-providing-nbde-in-openshift">Tang-Operator: Providing NBDE in OpenShift</link> Red Hat Hybrid Cloud blog article</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/latchset/tang-operator">tang-operator</link> Github project</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening">Configuring automated unlocking of encrypted volumes using policy-based decryption</link> chapter in the RHEL 9 Security hardening document</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="installing-nbde-tang-server-operator">
<title>Installing the NBDE Tang Server Operator</title>

<simpara>You can install the NBDE Tang Operator either by using the web console or through the <literal>oc</literal> command from CLI.</simpara>
<section xml:id="installing-nbde-tang-server-operator-using-web-console_installing-nbde-tang-server-operator">
<title>Installing the NBDE Tang Server Operator using the web console</title>
<simpara>You can install the NBDE Tang Server Operator from the OperatorHub using the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Search for the NBDE Tang Server Operator:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-01-operatorhub.png"/>
</imageobject>
<textobject><phrase>NBDE Tang Server Operator in OperatorHub</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Installation</emphasis> screen, keep the <emphasis role="strong">Update channel</emphasis>, <emphasis role="strong">Version</emphasis>, <emphasis role="strong">Installation mode</emphasis>, <emphasis role="strong">Installed Namespace</emphasis>, and <emphasis role="strong">Update approval</emphasis> fields on the default values.</simpara>
</listitem>
<listitem>
<simpara>After you confirm the installation options by clicking <emphasis role="strong">Install</emphasis>, the console displays the installation confirmation.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-03-confirmation.png"/>
</imageobject>
<textobject><phrase>Confirmation of a NBDE Tang Server Operator installation</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Check that the NBDE Tang Server Operator is installed and its status is <literal>Succeeded</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-05-succeeded.png"/>
</imageobject>
<textobject><phrase>NBDE Tang Server Operator status</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</orderedlist>
</section>
<section xml:id="installing-nbde-tang-server-operator-using-cli_installing-nbde-tang-server-operator">
<title>Installing the NBDE Tang Server Operator using CLI</title>
<simpara>You can install the NBDE Tang Server Operator from the OperatorHub using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the following command to list available Operators on OperatorHub, and limit the output to Tang-related results:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests -n openshift-marketplace | grep tang</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">tang-operator           Red Hat</programlisting>
</para>
</formalpara>
<simpara>In this case, the corresponding packagemanifest name is <literal>tang-operator</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file to subscribe a namespace to the NBDE Tang Server Operator, for example, <literal>tang-operator.yaml</literal>:</simpara>
<formalpara>
<title>Example subscription YAML for tang-operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: tang-operator
  namespace: openshift-operators
spec:
  channel: stable <co xml:id="CO52-1"/>
  installPlanApproval: Automatic
  name: tang-operator <co xml:id="CO52-2"/>
  source: redhat-operators <co xml:id="CO52-3"/>
  sourceNamespace: openshift-marketplace <co xml:id="CO52-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO52-1">
<para>Specify the channel name from where you want to subscribe the Operator.</para>
</callout>
<callout arearefs="CO52-2">
<para>Specify the name of the Operator to subscribe to.</para>
</callout>
<callout arearefs="CO52-3">
<para>Specify the name of the CatalogSource that provides the Operator.</para>
</callout>
<callout arearefs="CO52-4">
<para>The namespace of the CatalogSource. Use <literal>openshift-marketplace</literal> for the default OperatorHub CatalogSources.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the <literal>Subscription</literal> to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f tang-operator.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the NBDE Tang Server Operator controller runs in the <literal>openshift-operators</literal> namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-operators get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                READY   STATUS    RESTARTS   AGE
tang-operator-controller-manager-694b754bd6-4zk7x   2/2     Running   0          12s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="configuring-and-managing-nbde-tang-server-operator">
<title>Configuring and managing Tang servers using the NBDE Tang Server Operator</title>

<simpara>With the NBDE Tang Server Operator, you can deploy and quickly configure Tang servers. On the deployed Tang servers, you can list existing keys and rotate them.</simpara>
<section xml:id="deploying-nbde-tang-server_configuring-and-managing-nbde-tang-server-operator">
<title>Deploying a Tang server using the NBDE Tang Server Operator</title>
<simpara>You can deploy and quickly configure one or more Tang servers using the NBDE Tang Server Operator in the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the NBDE Tang Server Operator on your OCP cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Project</emphasis>, and click <emphasis role="strong">Create Project</emphasis>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-07-create-project.png"/>
</imageobject>
<textobject><phrase>Create Project in the web console</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>On the <literal>Create Project</literal> page, fill in the required information, for example:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-09-project-values.png"/>
</imageobject>
<textobject><phrase>Example values on the Create Project page</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>NBDE Tang Server replicas require a Persistent Volume Claim (PVC) for storing encryption keys. In the web console, navigate to <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">PersistentVolumeClaims</emphasis>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-11-pvc.png"/>
</imageobject>
<textobject><phrase>PersistentVolumeClaims in the Storage menu</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>On the following <literal>PersistentVolumeClaims</literal> screen, click <emphasis role="strong">Create PersistentVolumeClaim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <literal>Create PersistentVolumeClaim</literal> page, select a storage that fits your deployment scenario. Consider how often you want to rotate the encryption keys. Name your PVC and choose the claimed storage capacity, for example:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-13-create-pvc.png"/>
</imageobject>
<textobject><phrase>Create PersistentVolumeClaims page</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>, and click <emphasis role="strong">NBDE Tang Server</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create instance</emphasis>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-15-create-instance.png"/>
</imageobject>
<textobject><phrase>Create NBDE Tang Server instance</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>On the <literal>Create TangServer</literal> page, choose the name of the Tang Server instance, amount of replicas, and specify the name of the previously created Persistent Volume Claim, for example:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-17-create-tangserver.png"/>
</imageobject>
<textobject><phrase>Create TangServer page</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>After you enter the required values a change settings that differ from the default values in your scenario, click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="rotating-keys-using-nbde-tang-server-operator_configuring-and-managing-nbde-tang-server-operator">
<title>Rotating keys using the NBDE Tang Server Operator</title>
<simpara>With the NBDE Tang Server Operator, you also can rotate your Tang server keys. The precise interval at which you should rotate them depends on your application, key sizes, and institutional policy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You deployed a Tang server using the NBDE Tang Server Operator on your OpenShift cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the existing keys on your Tang server, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n nbde describe tangserver</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">…
Status:
  Active Keys:
	File Name:  	QS82aXnPKA4XpfHr3umbA0r2iTbRcpWQ0VI2Qdhi6xg
	Generated:  	2022-02-08 15:44:17.030090484 +0000
	sha1:       	PvYQKtrTuYsMV2AomUeHrUWkCGg
	sha256:     	QS82aXnPKA4XpfHr3umbA0r2iTbRcpWQ0VI2Qdhi6xg
…</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a YAML file for moving your active keys to hidden keys, for example, <literal>minimal-keyretrieve-rotate-tangserver.yaml</literal>:</simpara>
<formalpara>
<title>Example key-rotation YAML for tang-operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: daemons.redhat.com/v1alpha1
kind: TangServer
metadata:
  name: tangserver
  namespace: nbde
  finalizers:
    - finalizer.daemons.tangserver.redhat.com
spec:
  replicas: 1
  hiddenKeys:
    - sha1: "PvYQKtrTuYsMV2AomUeHrUWkCGg" <co xml:id="CO53-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO53-1">
<para>Specify the SHA-1 thumbprint of your active key to rotate it.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f minimal-keyretrieve-rotate-tangserver.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After a certain amount of time depending on your configuration, check that the previous <literal>activeKey</literal> value is the new <literal>hiddenKey</literal> value and the <literal>activeKey</literal> key file is newly generated, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n nbde describe tangserver</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">…
Spec:
  Hidden Keys:
    sha1:    PvYQKtrTuYsMV2AomUeHrUWkCGg
  Replicas:  1
Status:
  Active Keys:
    File Name:  T-0wx1HusMeWx4WMOk4eK97Q5u4dY5tamdDs7_ughnY.jwk
    Generated:  2023-10-25 15:38:18.134939752 +0000
    sha1:       vVxkNCNq7gygeeA9zrHrbc3_NZ4
    sha256:     T-0wx1HusMeWx4WMOk4eK97Q5u4dY5tamdDs7_ughnY
  Hidden Keys:
    File Name:           .QS82aXnPKA4XpfHr3umbA0r2iTbRcpWQ0VI2Qdhi6xg.jwk
    Generated:           2023-10-25 15:37:29.126928965 +0000
    Hidden:              2023-10-25 15:38:13.515467436 +0000
    sha1:                PvYQKtrTuYsMV2AomUeHrUWkCGg
    sha256:              QS82aXnPKA4XpfHr3umbA0r2iTbRcpWQ0VI2Qdhi6xg
…</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="deleting-hidden-keys-with-nbde-tang-server-operator_configuring-and-managing-nbde-tang-server-operator">
<title>Deleting hidden keys with the NBDE Tang Server Operator</title>
<simpara>After you rotate your Tang server keys, the previously active keys become hidden and are no longer advertised by the Tang instance. You can use the NBDE Tang Server Operator to remove encryption keys no longer used.</simpara>
<variablelist>
<varlistentry>
<term>WARNING</term>
<listitem>
<simpara>Do not remove any hidden keys unless you are sure that all bound Clevis clients already use new keys.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You deployed a Tang server using the NBDE Tang Server Operator on your OpenShift cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the existing keys on your Tang server, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n nbde describe tangserver</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">…
Status:
  Active Keys:
	File Name:  	PvYQKtrTuYsMV2AomUeHrUWkCGg.jwk
	Generated:  	2022-02-08 15:44:17.030090484 +0000
	sha1:	    	PvYQKtrTuYsMV2AomUeHrUWkCGg
	sha256:	    	QS82aXnPKA4XpfHr3umbA0r2iTbRcpWQ0VI2Qdhi6xg
…</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a YAML file for removing all hidden keys, for example, <literal>hidden-keys-deletion-tangserver.yaml</literal>:</simpara>
<formalpara>
<title>Example hidden-keys-deletion YAML for tang-operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: daemons.redhat.com/v1alpha1
kind: TangServer
metadata:
  name: tangserver
  namespace: nbde
  finalizers:
    - finalizer.daemons.tangserver.redhat.com
spec:
  replicas: 1
  hiddenKeys: [] <co xml:id="CO54-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>The empty array as the value of the <literal>hiddenKeys</literal> entry indicates you want to preserve no hidden keys on your Tang server.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f hidden-keys-deletion-tangserver.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>After a certain amount of time depending on your configuration, check that the previous active key still exists, but no hidden key is available, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n nbde describe tangserver</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">…
Spec:
  Hidden Keys:
    sha1:    PvYQKtrTuYsMV2AomUeHrUWkCGg
  Replicas:  1
Status:
  Active Keys:
    File Name:  T-0wx1HusMeWx4WMOk4eK97Q5u4dY5tamdDs7_ughnY.jwk
    Generated:  2023-10-25 15:38:18.134939752 +0000
    sha1:       vVxkNCNq7gygeeA9zrHrbc3_NZ4
    sha256:     T-0wx1HusMeWx4WMOk4eK97Q5u4dY5tamdDs7_ughnY
Status:
  Ready:                 1
  Running:               1
  Service External URL:  http://35.222.247.84:7500/adv
  Tang Server Error:     No
Events:
…</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="identifying-url-nbde-tang-server-operator">
<title>Identifying URL of a Tang server deployed with the NBDE Tang Server Operator</title>

<simpara>Before you can configure your Clevis clients to use encryption keys advertised by your Tang servers, you must identify the URLs of the servers.</simpara>
<section xml:id="identifying-url-nbde-tang-server-operator-using-web-console_identifying-url-nbde-tang-server-operator">
<title>Identifying URL of the NBDE Tang Server Operator using the web console</title>
<simpara>You can identify the URLs of Tang servers deployed with the NBDE Tang Server Operator from the OperatorHub by using the OpenShift Container Platform web console. After you identify the URLs, you use the <literal>clevis luks bind</literal> command on your clients containing LUKS-encrypted volumes that you want to unlock automatically by using keys advertised by the Tang servers. See the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#configuring-manual-enrollment-of-volumes-using-clevis_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Configuring manual enrollment of LUKS-encrypted volumes</link> section in the RHEL 9 Security hardening document for detailed steps describing the configuration of clients with Clevis.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You deployed a Tang server by using the NBDE Tang Server Operator on your OpenShift cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> &#8594; <emphasis role="strong">Tang Server</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the NBDE Tang Server Operator details page, select <emphasis role="strong">Tang Server</emphasis>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-19-tangserver-details.png"/>
</imageobject>
<textobject><phrase>NBDE Tang Server Operator details</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
<listitem>
<simpara>The list of Tang servers deployed and available for your cluster appears. Click the name of the Tang server you want to bind with a Clevis client.</simpara>
</listitem>
<listitem>
<simpara>The web console displays an overview of the selected Tang server. You can find the URL of your Tang server in the <literal>Tang Server External Url</literal> section of the screen:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/nbde-tang-server-operator-21-tangserver-overview.png"/>
</imageobject>
<textobject><phrase>NBDE Tang Server Operator overview of a Tang server</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In this example, the URL of the Tang server is <literal>http://34.28.173.205:7500</literal>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>You can check that the Tang server is advertising by using <literal>curl</literal>, <literal>wget</literal>, or similar tools, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl 2&gt; /dev/null http://34.28.173.205:7500/adv  | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "payload": "eyJrZXlzIj…eSJdfV19",
  "protected": "eyJhbGciOiJFUzUxMiIsImN0eSI6Imp3ay1zZXQranNvbiJ9",
  "signature": "AUB0qSFx0FJLeTU…aV_GYWlDx50vCXKNyMMCRx"
}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="identifying-url-nbde-tang-server-operator-using-cli_identifying-url-nbde-tang-server-operator">
<title>Identifying URL of the NBDE Tang Server Operator using CLI</title>
<simpara>You can identify the URLs of Tang servers deployed with the NBDE Tang Server Operator from the OperatorHub by using the CLI. After you identify the URLs, you use the <literal>clevis luks bind</literal> command on your clients containing LUKS-encrypted volumes that you want to unlock automatically by using keys advertised by the Tang servers. See the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#configuring-manual-enrollment-of-volumes-using-clevis_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Configuring manual enrollment of LUKS-encrypted volumes</link> section in the RHEL 9 Security hardening document for detailed steps describing the configuration of clients with Clevis.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-admin</literal> privileges on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You deployed a Tang server by using the NBDE Tang Server Operator on your OpenShift cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List details about your Tang server, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n nbde describe tangserver</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">…
Spec:
…
Status:
  Ready:                 1
  Running:               1
  Service External URL:  http://34.28.173.205:7500/adv
  Tang Server Error:     No
Events:
…</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the value of the <literal>Service External URL:</literal> item without the <literal>/adv</literal> part. In this example, the URL of the Tang server is <literal>http://34.28.173.205:7500</literal>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>You can check that the Tang server is advertising by using <literal>curl</literal>, <literal>wget</literal>, or similar tools, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl 2&gt; /dev/null http://34.28.173.205:7500/adv  | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "payload": "eyJrZXlzIj…eSJdfV19",
  "protected": "eyJhbGciOiJFUzUxMiIsImN0eSI6Imp3ay1zZXQranNvbiJ9",
  "signature": "AUB0qSFx0FJLeTU…aV_GYWlDx50vCXKNyMMCRx"
}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources-identifying-url-nbde-tang-server-operator" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#configuring-manual-enrollment-of-volumes-using-clevis_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Configuring manual enrollment of LUKS-encrypted volumes</link> section in the RHEL 9 Security hardening document.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_cert_manager_operator_for_red_hat_openshift">
<title>cert-manager Operator for Red Hat OpenShift</title>
<section xml:id="cert-manager-operator-about">
<title>cert-manager Operator for Red Hat OpenShift overview</title>

<simpara>The cert-manager Operator for Red Hat OpenShift is a cluster-wide service that provides application certificate lifecycle management. The cert-manager Operator for Red Hat OpenShift allows you to integrate with external certificate authorities and provides certificate provisioning, renewal, and retirement.</simpara>
<section xml:id="cert-manager-about_cert-manager-operator-about">
<title>About the cert-manager Operator for Red Hat OpenShift</title>
<simpara>The <link xlink:href="https://cert-manager.io/">cert-manager</link> project introduces certificate authorities and certificates as resource types in the Kubernetes API, which makes it possible to provide certificates on demand to developers working within your cluster. The cert-manager Operator for Red Hat OpenShift provides a supported way to integrate cert-manager into your OpenShift Container Platform cluster.</simpara>
<simpara>The cert-manager Operator for Red Hat OpenShift provides the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Support for integrating with external certificate authorities</simpara>
</listitem>
<listitem>
<simpara>Tools to manage certificates</simpara>
</listitem>
<listitem>
<simpara>Ability for developers to self-serve certificates</simpara>
</listitem>
<listitem>
<simpara>Automatic certificate renewal</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Do not attempt to use more than one cert-manager Operator in your cluster. If you have a community cert-manager Operator installed in your cluster, you must uninstall it before installing the cert-manager Operator for Red Hat OpenShift.</simpara>
</important>
</section>
<section xml:id="cert-manager-issuer-types_cert-manager-operator-about">
<title>Supported issuer types</title>
<simpara>The cert-manager Operator for Red Hat OpenShift supports the following issuer types:</simpara>
<itemizedlist>
<listitem>
<simpara>Automated Certificate Management Environment (ACME)</simpara>
</listitem>
<listitem>
<simpara>Certificate authority (CA)</simpara>
</listitem>
<listitem>
<simpara>Self-signed</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cert-manager.io/docs/configuration/vault/">Vault</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://cert-manager.io/docs/configuration/venafi/">Venafi</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-request-methods_cert-manager-operator-about">
<title>Certificate request methods</title>
<simpara>There are two ways to request a certificate using the cert-manager Operator for Red Hat OpenShift:</simpara>
<variablelist>
<varlistentry>
<term>Using the <literal>cert-manager.io/CertificateRequest</literal> object</term>
<listitem>
<simpara>With this method a service developer creates a <literal>CertificateRequest</literal> object with a valid <literal>issuerRef</literal> pointing to a configured issuer (configured by a service infrastructure administrator). A service infrastructure administrator then accepts or denies the certificate request. Only accepted certificate requests create a corresponding certificate.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Using the <literal>cert-manager.io/Certificate</literal> object</term>
<listitem>
<simpara>With this method, a service developer creates a <literal>Certificate</literal> object with a valid <literal>issuerRef</literal> and obtains a certificate from a secret that they pointed to the <literal>Certificate</literal> object.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="cert-manager-operator-about_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://cert-manager.io/docs/">cert-manager project documentation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-operator-release-notes">
<title>cert-manager Operator for Red Hat OpenShift release notes</title>

<simpara>The cert-manager Operator for Red Hat OpenShift is a cluster-wide service that provides application certificate lifecycle management.</simpara>
<simpara>These release notes track the development of cert-manager Operator for Red Hat OpenShift.</simpara>
<simpara>For more information, see <link xlink:href="../../security/cert_manager_operator/index.xml#cert-manager-operator-about">About the cert-manager Operator for Red Hat OpenShift</link>.</simpara>
<section xml:id="cert-manager-operator-release-notes-1-13">
<title>Release notes for cert-manager Operator for Red Hat OpenShift 1.13.0</title>
<simpara>Issued: 2024-01-16</simpara>
<simpara>The following advisory is available for the cert-manager Operator for Red Hat OpenShift 1.13.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/errata/RHEA-2024:0259">RHEA-2024:0259</link></simpara>
</listitem>
</itemizedlist>
<simpara>Version <literal>1.13.0</literal> of the cert-manager Operator for Red Hat OpenShift is based on the upstream cert-manager version <literal>v1.13.3</literal>. For more information, see the <link xlink:href="https://cert-manager.io/docs/release-notes/release-notes-1.13/#v1133">cert-manager project release notes for v1.13.0</link>.</simpara>
<section xml:id="cert-manager-operator-new-features-1-13">
<title>New features and enhancements</title>
<itemizedlist>
<listitem>
<simpara>You can now manage certificates for API Server and Ingress Controller by using the cert-manager Operator for Red Hat OpenShift.
For more information, see <link xlink:href="../../security/cert_manager_operator/cert-manager-creating-certificate.xml#cert-manager-creating-certificate">Configuring certificates with an issuer</link>.</simpara>
</listitem>
<listitem>
<simpara>With this release, the scope of the cert-manager Operator for Red Hat OpenShift, which was previously limited to the OpenShift Container Platform on AMD64 architecture, has now been expanded to include support for managing certificates on OpenShift Container Platform running on IBM Z&#174; (<literal>s390x</literal>), IBM Power&#174; (<literal>ppc64le</literal>) and ARM64 architectures.</simpara>
</listitem>
<listitem>
<simpara>With this release, you can use DNS over HTTPS (DoH) for performing the self-checks during the ACME DNS-01 challenge verification. The DNS self-check method can be controlled by using the command line flags, <literal>--dns01-recursive-nameservers-only</literal> and <literal>--dns01-recursive-nameservers</literal>.
For more information, see <link xlink:href="../../security/cert_manager_operator/cert-manager-customizing-api-fields.html#cert-manager-override-arguments_cert-manager-customizing-api-fields">Customizing cert-manager by overriding arguments from the cert-manager Operator API</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-operator-1-13-CVEs">
<title>CVEs</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/security/cve/CVE-2023-39615">CVE-2023-39615</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/security/cve/CVE-2023-3978">CVE-2023-3978</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/security/cve/CVE-2023-37788">CVE-2023-37788</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/security/cve/CVE-2023-29406">CVE-2023-29406</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="cert-manager-operator-install">
<title>Installing the cert-manager Operator for Red Hat OpenShift</title>

<simpara>The cert-manager Operator for Red Hat OpenShift is not installed in OpenShift Container Platform by default. You can install the cert-manager Operator for Red Hat OpenShift by using the web console.</simpara>
<section xml:id="cert-manager-install-console_cert-manager-operator-install">
<title>Installing the cert-manager Operator for Red Hat OpenShift using the web console</title>
<simpara>You can use the web console to install the cert-manager Operator for Red Hat OpenShift.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <emphasis role="strong">cert-manager Operator for Red Hat OpenShift</emphasis> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">cert-manager Operator for Red Hat OpenShift</emphasis> and click <emphasis role="strong">Install</emphasis>.</simpara>
<note>
<simpara>From the cert-manager Operator for Red Hat OpenShift <literal>1.12.0</literal> and later, the z-stream versions of the upstream cert-manager operands such as cert-manager controller, CA injector, Webhook, and cert-manager Operator for Red Hat OpenShift are decoupled. For example, for the cert-manager Operator for Red Hat OpenShift <literal>1.12.0</literal>, the cert-manager operand version is <literal>v1.12.4</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the <emphasis role="strong">Update channel</emphasis>, if necessary. The channel defaults to <emphasis role="strong">stable-v1</emphasis>, which installs the latest stable release of the cert-manager Operator for Red Hat OpenShift.</simpara>
</listitem>
<listitem>
<simpara>Choose the <emphasis role="strong">Installed Namespace</emphasis> for the Operator. The default Operator namespace is <literal>cert-manager-operator</literal>.</simpara>
<simpara>If the <literal>cert-manager-operator</literal> namespace does not exist, it is created for you.</simpara>
</listitem>
<listitem>
<simpara>Select an <emphasis role="strong">Update approval</emphasis> strategy.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Automatic</emphasis> strategy allows Operator Lifecycle Manager (OLM) to automatically update the Operator when a new version is available.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Manual</emphasis> strategy requires a user with appropriate credentials to approve the Operator update.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify that <emphasis role="strong">cert-manager Operator for Red Hat OpenShift</emphasis> is listed with a <emphasis role="strong">Status</emphasis> of <emphasis role="strong">Succeeded</emphasis> in the <literal>cert-manager-operator</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Verify that cert-manager pods are up and running by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt               1/1     Running   0          3m39s
cert-manager-cainjector-56cc5f9868-7g9z7   1/1     Running   0          4m5s
cert-manager-webhook-d4f79d7f7-9dg9w       1/1     Running   0          4m9s</programlisting>
</para>
</formalpara>
<simpara>You can use the cert-manager Operator for Red Hat OpenShift only after cert-manager pods are up and running.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-operator-update-channels_cert-manager-operator-install">
<title>Understanding update channels of the cert-manager Operator for Red Hat OpenShift</title>
<simpara>Update channels are the mechanism by which you can declare the version of your cert-manager Operator for Red Hat OpenShift in your cluster. The cert-manager Operator for Red Hat OpenShift offers the following update channels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>stable-v1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>stable-v1.y</literal></simpara>
</listitem>
</itemizedlist>
<section xml:id="stable-v1-channel_cert-manager-operator-install">
<title>stable-v1 channel</title>
<simpara>The <literal>stable-v1</literal> channel is the default and suggested channel while installing the cert-manager Operator for Red Hat OpenShift. The <literal>stable-v1</literal> channel installs and updates the latest release version of the cert-manager Operator for Red Hat OpenShift. Select the <literal>stable-v1</literal> channel if you want to use the latest stable release of the cert-manager Operator for Red Hat OpenShift.</simpara>
<simpara>The <literal>stable-v1</literal> channel offers the following update approval strategies:</simpara>
<variablelist>
<varlistentry>
<term>Automatic</term>
<listitem>
<simpara>If you choose automatic updates for an installed cert-manager Operator for Red Hat OpenShift, a new version of the cert-manager Operator for Red Hat OpenShift is available in the <literal>stable-v1</literal> channel. The Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Manual</term>
<listitem>
<simpara>If you select manual updates, when a newer version of the cert-manager Operator for Red Hat OpenShift is available, OLM creates an update request. As a cluster administrator, you must then manually approve that update request to have the cert-manager Operator for Red Hat OpenShift updated to the new version.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="stable-v1-y-channel_cert-manager-operator-install">
<title>stable-v1.y channel</title>
<simpara>The y-stream version of the cert-manager Operator for Red Hat OpenShift installs updates from the <literal>stable-v1.y</literal> channels such as <literal>stable-v1.10</literal>, <literal>stable-v1.11</literal>, and <literal>stable-v1.12</literal>. Select the <literal>stable-v1.y</literal> channel if you want to use the y-stream version and stay updated to the z-stream version of the cert-manager Operator for Red Hat OpenShift.</simpara>
<simpara>The <literal>stable-v1.y</literal> channel offers the following update approval strategies:</simpara>
<variablelist>
<varlistentry>
<term>Automatic</term>
<listitem>
<simpara>If you choose automatic updates for an installed cert-manager Operator for Red Hat OpenShift, a new z-stream version of the cert-manager Operator for Red Hat OpenShift is available in the <literal>stable-v1.y</literal> channel. OLM automatically upgrades the running instance of your Operator without human intervention.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Manual</term>
<listitem>
<simpara>If you select manual updates, when a newer version of the cert-manager Operator for Red Hat OpenShift is available, OLM creates an update request. As a cluster administrator, you must then manually approve that update request to have the cert-manager Operator for Red Hat OpenShift updated to the new version of the z-stream releases.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="cert-manager-operator-install_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-adding-operators-to-a-cluster">Adding Operators to a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer</title>

<simpara>The cert-manager Operator for Red Hat OpenShift supports using Automated Certificate Management Environment (ACME) CA servers, such as <emphasis>Let&#8217;s Encrypt</emphasis>, to issue certificates. Explicit credentials are configured by specifying the secret details in the <literal>Issuer</literal> API object. Ambient credentials are extracted from the environment, metadata services, or local files which are not explicitly configured in the <literal>Issuer</literal> API object.</simpara>
<note>
<simpara>The <literal>Issuer</literal> object is namespace scoped. It can only issue certificates from the same namespace. You can also use the <literal>ClusterIssuer</literal> object to issue certificates across all namespaces in the cluster.</simpara>
<formalpara>
<title>Example YAML file that defines the <literal>ClusterIssuer</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: acme-cluster-issuer
spec:
  acme:
    ...</programlisting>
</para>
</formalpara>
</note>
<note>
<simpara>By default, you can use the <literal>ClusterIssuer</literal> object with ambient credentials. To use the <literal>Issuer</literal> object with ambient credentials, you must enable the <literal>--issuer-ambient-credentials</literal> setting for the cert-manager controller.</simpara>
</note>
<section xml:id="cert-manager-acme-about_cert-manager-operator-issuer-acme">
<title>About ACME issuers</title>
<simpara>The ACME issuer type for the cert-manager Operator for Red Hat OpenShift represents an Automated Certificate Management Environment (ACME) certificate authority (CA) server. ACME CA servers rely on a <emphasis>challenge</emphasis> to verify that a client owns the domain names that the certificate is being requested for. If the challenge is successful, the cert-manager Operator for Red Hat OpenShift can issue the certificate. If the challenge fails, the cert-manager Operator for Red Hat OpenShift does not issue the certificate.</simpara>
<note>
<simpara>Private DNS zones are not supported with <emphasis>Let’s Encrypt</emphasis> and internet ACME servers.</simpara>
</note>
<section xml:id="cert-manager-acme-challenges-types_cert-manager-operator-issuer-acme">
<title>Supported ACME challenges types</title>
<simpara>The cert-manager Operator for Red Hat OpenShift supports the following challenge types for ACME issuers:</simpara>
<variablelist>
<varlistentry>
<term>HTTP-01</term>
<listitem>
<simpara>With the HTTP-01 challenge type, you provide a computed key at an HTTP URL endpoint in your domain. If the ACME CA server can get the key from the URL, it can validate you as the owner of the domain.</simpara>
<simpara>For more information, see <link xlink:href="https://cert-manager.io/docs/configuration/acme/http01/">HTTP01</link> in the upstream cert-manager documentation.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>DNS-01</term>
<listitem>
<simpara>With the DNS-01 challenge type, you provide a computed key at a DNS TXT record. If the ACME CA server can get the key by DNS lookup, it can validate you as the owner of the domain.</simpara>
<simpara>For more information, see <link xlink:href="https://cert-manager.io/docs/configuration/acme/dns01/">DNS01</link> in the upstream cert-manager documentation.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="cert-manager-acme-dns-providers_cert-manager-operator-issuer-acme">
<title>Supported DNS-01 providers</title>
<simpara>The cert-manager Operator for Red Hat OpenShift supports the following DNS-01 providers for ACME issuers:</simpara>
<itemizedlist>
<listitem>
<simpara>Amazon Route 53</simpara>
</listitem>
<listitem>
<simpara>Azure DNS</simpara>
<note>
<simpara>The cert-manager Operator for Red Hat OpenShift does not support using Azure Active Directory (Azure AD) pod identities to assign a managed identity to a pod.</simpara>
</note>
</listitem>
<listitem>
<simpara>Google Cloud DNS</simpara>
</listitem>
<listitem>
<simpara>Webhook</simpara>
<simpara>Red Hat tests and supports DNS providers using an external webhook with cert-manager on OpenShift Container Platform. The following DNS providers are tested and supported with OpenShift Container Platform:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://github.com/jb-dk/cert-manager-webhook-ibmcis">cert-manager-webhook-ibmcis</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Using a DNS provider that is not listed might work with OpenShift Container Platform, but the provider was not tested by Red Hat and therefore is not supported by Red Hat.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-acme-http01_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer to solve HTTP-01 challenges</title>
<simpara>You can use cert-manager Operator for Red Hat OpenShift to set up an ACME issuer to solve HTTP-01 challenges. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME CA server.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have a service that you want to expose. In this procedure, the service is named <literal>sample-workload</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an ACME cluster issuer.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>ClusterIssuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>acme-cluster-issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-staging                                        <co xml:id="CO55-1"/>
spec:
  acme:
    preferredChain: ""
    privateKeySecretRef:
      name: &lt;secret_for_private_key&gt;                               <co xml:id="CO55-2"/>
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO55-3"/>
    solvers:
    - http01:
        ingress:
          class: openshift-default                                 <co xml:id="CO55-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO55-1">
<para>Provide a name for the cluster issuer.</para>
</callout>
<callout arearefs="CO55-2">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO55-3">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO55-4">
<para>Specify the Ingress class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterIssuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f acme-cluster-issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an Ingress to expose the service of the user workload.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines a <literal>Namespace</literal> object:</simpara>
<formalpara>
<title>Example <literal>namespace.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: my-ingress-namespace <co xml:id="CO56-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO56-1">
<para>Specify the namespace for the Ingress.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f namespace.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file that defines the <literal>Ingress</literal> object:</simpara>
<formalpara>
<title>Example <literal>ingress.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: sample-ingress                                           <co xml:id="CO57-1"/>
  namespace: my-ingress-namespace                                <co xml:id="CO57-2"/>
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-staging          <co xml:id="CO57-3"/>
    acme.cert-manager.io/http01-ingress-class: openshift-default <co xml:id="CO57-4"/>
spec:
  ingressClassName: openshift-default                            <co xml:id="CO57-5"/>
  tls:
  - hosts:
    - &lt;hostname&gt;                                                 <co xml:id="CO57-6"/>
    secretName: sample-tls                                       <co xml:id="CO57-7"/>
  rules:
  - host: &lt;hostname&gt;                                             <co xml:id="CO57-8"/>
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: sample-workload                                <co xml:id="CO57-9"/>
            port:
              number: 80</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO57-1">
<para>Specify the name of the Ingress.</para>
</callout>
<callout arearefs="CO57-2">
<para>Specify the namespace that you created for the Ingress.</para>
</callout>
<callout arearefs="CO57-3">
<para>Specify the cluster issuer that you created.</para>
</callout>
<callout arearefs="CO57-4">
<para>Specify the Ingress class.</para>
</callout>
<callout arearefs="CO57-5">
<para>Specify the Ingress class.</para>
</callout>
<callout arearefs="CO57-6">
<para>Replace <literal>&lt;hostname&gt;</literal> with the Subject Alternative Name to be associated with the certificate. This name is used to add DNS names to the certificate.</para>
</callout>
<callout arearefs="CO57-7">
<para>Specify the secret to store the created certificate in.</para>
</callout>
<callout arearefs="CO57-8">
<para>Replace <literal>&lt;hostname&gt;</literal> with the hostname. You can use the <literal>&lt;host_name&gt;.&lt;cluster_ingress_domain&gt;</literal> syntax to take advantage of the <literal>*.&lt;cluster_ingress_domain&gt;</literal> wildcard DNS record and serving certificate for the cluster. For example, you might use <literal>apps.&lt;cluster_base_domain&gt;</literal>. Otherwise, you must ensure that a DNS record exists for the chosen hostname.</para>
</callout>
<callout arearefs="CO57-9">
<para>Specify the name of the service to expose. This example uses a service named <literal>sample-workload</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Ingress</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ingress.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-acme-dns01-explicit-aws_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer by using explicit credentials for AWS Route53</title>
<simpara>You can use cert-manager Operator for Red Hat OpenShift to set up an Automated Certificate Management Environment (ACME) issuer to solve DNS-01 challenges by using explicit credentials on AWS. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME certificate authority (CA) server and shows how to solve DNS-01 challenges with Amazon Route 53.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must provide the explicit <literal>accessKeyID</literal> and <literal>secretAccessKey</literal> credentials. For more information, see <link xlink:href="https://cert-manager.io/docs/configuration/acme/dns01/route53/">Route53</link> in the upstream cert-manager documentation.</simpara>
<note>
<simpara>You can use Amazon Route 53 with explicit credentials in an OpenShift Container Platform cluster that is not running on AWS.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Override the nameserver settings for the DNS-01 self check.</simpara>
<simpara>This step is required only when the target public-hosted zone overlaps with the cluster&#8217;s default private-hosted zone.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:                                <co xml:id="CO58-1"/>
    overrideArgs:
      - '--dns01-recursive-nameservers-only'       <co xml:id="CO58-2"/>
      - '--dns01-recursive-nameservers=1.1.1.1:53' <co xml:id="CO58-3"/></programlisting>
<calloutlist>
<callout arearefs="CO58-1">
<para>Add the <literal>spec.controllerConfig</literal> section.</para>
</callout>
<callout arearefs="CO58-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO58-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the DNS-01 self check. You must use a <literal>1.1.1.1:53</literal> value to avoid the public and private zones overlapping.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a namespace for the issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;issuer_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Create a secret to store your AWS credentials in by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic aws-secret --from-literal=awsSecretAccessKey=&lt;aws_secret_access_key&gt; \ <co xml:id="CO59-1"/>
    -n my-issuer-namespace</programlisting>
<calloutlist>
<callout arearefs="CO59-1">
<para>Replace <literal>&lt;aws_secret_access_key&gt;</literal> with your AWS secret access key.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create an issuer:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Issuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: &lt;letsencrypt_staging&gt;                                        <co xml:id="CO60-1"/>
  namespace: &lt;issuer_namespace&gt;                                   <co xml:id="CO60-2"/>
spec:
  acme:
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO60-3"/>
    email: "&lt;email_address&gt;"                                       <co xml:id="CO60-4"/>
    privateKeySecretRef:
      name: &lt;secret_private_key&gt;                                   <co xml:id="CO60-5"/>
    solvers:
    - dns01:
        route53:
          accessKeyID: &lt;aws_key_id&gt;                                <co xml:id="CO60-6"/>
          hostedZoneID: &lt;hosted_zone_id&gt;                           <co xml:id="CO60-7"/>
          region: &lt;region_name&gt;                                    <co xml:id="CO60-8"/>
          secretAccessKeySecretRef:
            name: "aws-secret"                                     <co xml:id="CO60-9"/>
            key: "awsSecretAccessKey"                              <co xml:id="CO60-10"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO60-1">
<para>Provide a name for the issuer.</para>
</callout>
<callout arearefs="CO60-2">
<para>Specify the namespace that you created for the issuer.</para>
</callout>
<callout arearefs="CO60-3">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO60-4">
<para>Replace <literal>&lt;email_address&gt;</literal> with your email address.</para>
</callout>
<callout arearefs="CO60-5">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of the secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO60-6">
<para>Replace <literal>&lt;aws_key_id&gt;</literal> with your AWS key ID.</para>
</callout>
<callout arearefs="CO60-7">
<para>Replace <literal>&lt;hosted_zone_id&gt;</literal> with your hosted zone ID.</para>
</callout>
<callout arearefs="CO60-8">
<para>Replace <literal>&lt;region_name&gt;</literal> with the AWS region name. For example, <literal>us-east-1</literal>.</para>
</callout>
<callout arearefs="CO60-9">
<para>Specify the name of the secret you created.</para>
</callout>
<callout arearefs="CO60-10">
<para>Specify the key in the secret you created that stores your AWS secret access key.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Issuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-acme-dns01-ambient-aws_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer by using ambient credentials on AWS</title>
<simpara>You can use cert-manager Operator for Red Hat OpenShift to set up an ACME issuer to solve DNS-01 challenges by using ambient credentials on AWS. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME CA server and shows how to solve DNS-01 challenges with Amazon Route 53.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>If your cluster is configured to use the AWS Security Token Service (STS), you followed the instructions from the <emphasis>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift for the AWS Security Token Service cluster</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>If your cluster does not use the AWS STS, you followed the instructions from the <emphasis>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on AWS</emphasis> section.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Override the nameserver settings for the DNS-01 self check.</simpara>
<simpara>This step is required only when the target public-hosted zone overlaps with the cluster&#8217;s default private-hosted zone.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:                                <co xml:id="CO61-1"/>
    overrideArgs:
      - '--dns01-recursive-nameservers-only'       <co xml:id="CO61-2"/>
      - '--dns01-recursive-nameservers=1.1.1.1:53' <co xml:id="CO61-3"/></programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>Add the <literal>spec.controllerConfig</literal> section.</para>
</callout>
<callout arearefs="CO61-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO61-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the DNS-01 self check. You must use a <literal>1.1.1.1:53</literal> value to avoid the public and private zones overlapping.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a namespace for the issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;issuer_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Modify the <literal>CertManager</literal> resource to add the <literal>--issuer-ambient-credentials</literal> argument:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch certmanager/cluster \
  --type=merge \
  -p='{"spec":{"controllerConfig":{"overrideArgs":["--issuer-ambient-credentials"]}}}'</programlisting>
</listitem>
<listitem>
<simpara>Create an issuer:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Issuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: &lt;letsencrypt_staging&gt;                                        <co xml:id="CO62-1"/>
  namespace: &lt;issuer_namespace&gt;                                   <co xml:id="CO62-2"/>
spec:
  acme:
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO62-3"/>
    email: "&lt;email_address&gt;"                                       <co xml:id="CO62-4"/>
    privateKeySecretRef:
      name: &lt;secret_private_key&gt;                                   <co xml:id="CO62-5"/>
    solvers:
    - dns01:
        route53:
          hostedZoneID: &lt;hosted_zone_id&gt;                           <co xml:id="CO62-6"/>
          region: us-east-1</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO62-1">
<para>Provide a name for the issuer.</para>
</callout>
<callout arearefs="CO62-2">
<para>Specify the namespace that you created for the issuer.</para>
</callout>
<callout arearefs="CO62-3">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO62-4">
<para>Replace <literal>&lt;email_address&gt;</literal> with your email address.</para>
</callout>
<callout arearefs="CO62-5">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of the secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO62-6">
<para>Replace <literal>&lt;hosted_zone_id&gt;</literal> with your hosted zone ID.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Issuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-acme-dns01-explicit-gcp_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer by using explicit credentials for GCP Cloud DNS</title>
<simpara>You can use the cert-manager Operator for Red Hat OpenShift to set up an ACME issuer to solve DNS-01 challenges by using explicit credentials on GCP. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME CA server and shows how to solve DNS-01 challenges with Google CloudDNS.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have set up Google Cloud service account with a desired role for Google CloudDNS. For more information, see <link xlink:href="https://cert-manager.io/docs/configuration/acme/dns01/google/">Google CloudDNS</link> in the upstream cert-manager documentation.</simpara>
<note>
<simpara>You can use Google CloudDNS with explicit credentials in an OpenShift Container Platform cluster that is not running on GCP.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Override the nameserver settings for the DNS-01 self check.</simpara>
<simpara>This step is required only when the target public-hosted zone overlaps with the cluster&#8217;s default private-hosted zone.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:                                <co xml:id="CO63-1"/>
    overrideArgs:
      - '--dns01-recursive-nameservers-only'       <co xml:id="CO63-2"/>
      - '--dns01-recursive-nameservers=1.1.1.1:53' <co xml:id="CO63-3"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>Add the <literal>spec.controllerConfig</literal> section.</para>
</callout>
<callout arearefs="CO63-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO63-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the DNS-01 self check. You must use a <literal>1.1.1.1:53</literal> value to avoid the public and private zones overlapping.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a namespace for the issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-issuer-namespace</programlisting>
</listitem>
<listitem>
<simpara>Create a secret to store your GCP credentials by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic clouddns-dns01-solver-svc-acct --from-file=service_account.json=&lt;path/to/gcp_service_account.json&gt; -n my-issuer-namespace</programlisting>
</listitem>
<listitem>
<simpara>Create an issuer:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Issuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: &lt;acme_dns01_clouddns_issuer&gt; <co xml:id="CO64-1"/>
  namespace: &lt;issuer_namespace&gt; <co xml:id="CO64-2"/>
spec:
  acme:
    preferredChain: ""
    privateKeySecretRef:
      name: &lt;secret_private_key&gt; <co xml:id="CO64-3"/>
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO64-4"/>
    solvers:
    - dns01:
        cloudDNS:
          project: &lt;project_id&gt; <co xml:id="CO64-5"/>
          serviceAccountSecretRef:
            name: clouddns-dns01-solver-svc-acct <co xml:id="CO64-6"/>
            key: service_account.json <co xml:id="CO64-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO64-1">
<para>Provide a name for the issuer.</para>
</callout>
<callout arearefs="CO64-2">
<para>Replace <literal>&lt;issuer_namespace&gt;</literal> with your issuer namespace.</para>
</callout>
<callout arearefs="CO64-3">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of the secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO64-4">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO64-5">
<para>Replace <literal>&lt;project_id&gt;</literal> with the name of the GCP project that contains the Cloud DNS zone.</para>
</callout>
<callout arearefs="CO64-6">
<para>Specify the name of the secret you created.</para>
</callout>
<callout arearefs="CO64-7">
<para>Specify the key in the secret you created that stores your GCP secret access key.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Issuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-acme-dns01-ambient-gcp_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer by using ambient credentials on GCP</title>
<simpara>You can use the cert-manager Operator for Red Hat OpenShift to set up an ACME issuer to solve DNS-01 challenges by using ambient credentials on GCP. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME CA server and shows how to solve DNS-01 challenges with Google CloudDNS.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>If your cluster is configured to use GCP Workload Identity, you followed the instructions from the <emphasis>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift with GCP Workload Identity</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>If your cluster does not use GCP Workload Identity, you followed the instructions from the <emphasis>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on GCP</emphasis> section.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Override the nameserver settings for the DNS-01 self check.</simpara>
<simpara>This step is required only when the target public-hosted zone overlaps with the cluster&#8217;s default private-hosted zone.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:                                <co xml:id="CO65-1"/>
    overrideArgs:
      - '--dns01-recursive-nameservers-only'       <co xml:id="CO65-2"/>
      - '--dns01-recursive-nameservers=1.1.1.1:53' <co xml:id="CO65-3"/></programlisting>
<calloutlist>
<callout arearefs="CO65-1">
<para>Add the <literal>spec.controllerConfig</literal> section.</para>
</callout>
<callout arearefs="CO65-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO65-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the DNS-01 self check. You must use a <literal>1.1.1.1:53</literal> value to avoid the public and private zones overlapping.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a namespace for the issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project &lt;issuer_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Modify the <literal>CertManager</literal> resource to add the <literal>--issuer-ambient-credentials</literal> argument:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch certmanager/cluster \
  --type=merge \
  -p='{"spec":{"controllerConfig":{"overrideArgs":["--issuer-ambient-credentials"]}}}'</programlisting>
</listitem>
<listitem>
<simpara>Create an issuer:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Issuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: &lt;acme_dns01_clouddns_issuer&gt; <co xml:id="CO66-1"/>
  namespace: &lt;issuer_namespace&gt;
spec:
  acme:
    preferredChain: ""
    privateKeySecretRef:
      name: &lt;secret_private_key&gt; <co xml:id="CO66-2"/>
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO66-3"/>
    solvers:
    - dns01:
        cloudDNS:
          project: &lt;gcp_project_id&gt; <co xml:id="CO66-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1">
<para>Provide a name for the issuer.</para>
</callout>
<callout arearefs="CO66-2">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of the secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO66-3">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO66-4">
<para>Replace <literal>&lt;gcp_project_id&gt;</literal> with the name of the GCP project that contains the Cloud DNS zone.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Issuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-acme-dns01-explicit-azure_cert-manager-operator-issuer-acme">
<title>Configuring an ACME issuer by using explicit credentials for Microsoft Azure DNS</title>
<simpara>You can use cert-manager Operator for Red Hat OpenShift to set up an ACME issuer to solve DNS-01 challenges by using explicit credentials on Microsoft Azure. This procedure uses <emphasis>Let&#8217;s Encrypt</emphasis> as the ACME CA server and shows how to solve DNS-01 challenges with Azure DNS.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have set up a service principal with desired role for Azure DNS. For more information, see <link xlink:href="https://cert-manager.io/docs/configuration/acme/dns01/azuredns/">Azure DNS</link> in the upstream cert-manager documentation.</simpara>
<note>
<simpara>You can follow this procedure for an OpenShift Container Platform cluster that is not running on Microsoft Azure.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Override the nameserver settings for the DNS-01 self check.</simpara>
<simpara>This step is required only when the target public-hosted zone overlaps with the cluster&#8217;s default private-hosted zone.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:                                <co xml:id="CO67-1"/>
    overrideArgs:
      - '--dns01-recursive-nameservers-only'       <co xml:id="CO67-2"/>
      - '--dns01-recursive-nameservers=1.1.1.1:53' <co xml:id="CO67-3"/></programlisting>
<calloutlist>
<callout arearefs="CO67-1">
<para>Add the <literal>spec.controllerConfig</literal> section.</para>
</callout>
<callout arearefs="CO67-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO67-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the DNS-01 self check. You must use a <literal>1.1.1.1:53</literal> value to avoid the public and private zones overlapping.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Create a namespace for the issuer:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project my-issuer-namespace</programlisting>
</listitem>
<listitem>
<simpara>Create a secret to store your Azure credentials in by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-literal=&lt;azure_secret_access_key_name&gt;=&lt;azure_secret_access_key_value&gt; \ <co xml:id="CO68-1"/> <co xml:id="CO68-2"/> <co xml:id="CO68-3"/>
    -n my-issuer-namespace</programlisting>
<calloutlist>
<callout arearefs="CO68-1">
<para>Replace <literal>&lt;secret_name&gt;</literal> with your secret name.</para>
</callout>
<callout arearefs="CO68-2">
<para>Replace <literal>&lt;azure_secret_access_key_name&gt;</literal> with your Azure secret access key name.</para>
</callout>
<callout arearefs="CO68-3">
<para>Replace <literal>&lt;azure_secret_access_key_value&gt;</literal> with your Azure secret key.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create an issuer:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Issuer</literal> object:</simpara>
<formalpara>
<title>Example <literal>issuer.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: &lt;acme-dns01-azuredns-issuer&gt;   <co xml:id="CO69-1"/>
  namespace: &lt;issuer_namespace&gt;   <co xml:id="CO69-2"/>
spec:
  acme:
    preferredChain: ""
    privateKeySecretRef:
      name: &lt;secret_private_key&gt; <co xml:id="CO69-3"/>
    server: https://acme-staging-v02.api.letsencrypt.org/directory <co xml:id="CO69-4"/>
    solvers:
    - dns01:
        azureDNS:
          clientID: &lt;azure_client_id&gt; <co xml:id="CO69-5"/>
          clientSecretSecretRef:
            name: &lt;secret_name&gt; <co xml:id="CO69-6"/>
            key: &lt;azure_secret_access_key_name&gt; <co xml:id="CO69-7"/>
          subscriptionID: &lt;azure_subscription_id&gt; <co xml:id="CO69-8"/>
          tenantID: &lt;azure_tenant_id&gt; <co xml:id="CO69-9"/>
          resourceGroupName: &lt;azure_dns_zone_resource_group&gt; <co xml:id="CO69-10"/>
          hostedZoneName: &lt;azure_dns_zone&gt; <co xml:id="CO69-11"/>
          environment: AzurePublicCloud</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO69-1">
<para>Provide a name for the issuer.</para>
</callout>
<callout arearefs="CO69-2">
<para>Replace <literal>&lt;issuer_namespace&gt;</literal> with your issuer namespace.</para>
</callout>
<callout arearefs="CO69-3">
<para>Replace <literal>&lt;secret_private_key&gt;</literal> with the name of the secret to store the ACME account private key in.</para>
</callout>
<callout arearefs="CO69-4">
<para>Specify the URL to access the ACME server&#8217;s <literal>directory</literal> endpoint. This example uses the <emphasis>Let&#8217;s Encrypt</emphasis> staging environment.</para>
</callout>
<callout arearefs="CO69-5">
<para>Replace <literal>&lt;azure_client_id&gt;</literal> with your Azure client ID.</para>
</callout>
<callout arearefs="CO69-6">
<para>Replace <literal>&lt;secret_name&gt;</literal> with a name of the client secret.</para>
</callout>
<callout arearefs="CO69-7">
<para>Replace <literal>&lt;azure_secret_access_key_name&gt;</literal> with the client secret key name.</para>
</callout>
<callout arearefs="CO69-8">
<para>Replace <literal>&lt;azure_subscription_id&gt;</literal> with your Azure subscription ID.</para>
</callout>
<callout arearefs="CO69-9">
<para>Replace <literal>&lt;azure_tenant_id&gt;</literal> with your Azure tenant ID.</para>
</callout>
<callout arearefs="CO69-10">
<para>Replace <literal>&lt;azure_dns_zone_resource_group&gt;</literal> with the name of the Azure DNS zone resource group.</para>
</callout>
<callout arearefs="CO69-11">
<para>Replace <literal>&lt;azure_dns_zone&gt;</literal> with the name of Azure DNS zone.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Issuer</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f issuer.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_cert-manager-operator-issuer-acme" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-authenticate-aws.xml#cert-manager-configure-cloud-credentials-aws-sts_cert-manager-authenticate-aws">Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift for the AWS Security Token Service cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-authentication-non-sts.xml#cert-manager-configure-cloud-credentials-aws-non-sts_cert-manager-authentication-non-sts">Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-authenticate-gcp.xml#cert-manager-configure-cloud-credentials-gcp-sts_cert-manager-authenticate-gcp">Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift with GCP Workload Identity</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-authenticate-non-sts-gcp.xml#cert-manager-configure-cloud-credentials-gcp-non-sts_cert-manager-authenticate-non-sts-gcp">Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on GCP</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-creating-certificate">
<title>Configuring certificates with an issuer</title>

<simpara>By using the cert-manager Operator for Red Hat OpenShift, you can manage certificates, handling tasks such as renewal and issuance, for workloads within the cluster, as well as components interacting externally to the cluster.</simpara>
<section xml:id="cert-manager-certificate-mgmt_cert-manager-creating-certificate">
<title>Creating certificates for user workloads</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an issuer. For more information, see "Configuring an issuer" in the "Additional Resources" section.</simpara>
</listitem>
<listitem>
<simpara>Create a certificate:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, for example, <literal>certificate.yaml</literal>, that defines the <literal>Certificate</literal> object:</simpara>
<formalpara>
<title>Example <literal>certificate.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: &lt;tls_cert&gt; <co xml:id="CO70-1"/>
  namespace: &lt;issuer_namespace&gt; <co xml:id="CO70-2"/>
spec:
  isCA: false
  commonName: '&lt;common_name&gt;' <co xml:id="CO70-3"/>
  secretName: &lt;secret_name&gt; <co xml:id="CO70-4"/>
  dnsNames:
  - "&lt;domain_name&gt;" <co xml:id="CO70-5"/>
  issuerRef:
    name: &lt;issuer_name&gt; <co xml:id="CO70-6"/>
    kind: Issuer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO70-1">
<para>Provide a name for the certificate.</para>
</callout>
<callout arearefs="CO70-2">
<para>Specify the namespace of the issuer.</para>
</callout>
<callout arearefs="CO70-3">
<para>Specify the common name (CN).</para>
</callout>
<callout arearefs="CO70-4">
<para>Specify the name of the secret to create that contains the certificate.</para>
</callout>
<callout arearefs="CO70-5">
<para>Specify the domain name.</para>
</callout>
<callout arearefs="CO70-6">
<para>Specify the name of the issuer.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Certificate</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f certificate.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the certificate is created and ready to use by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get certificate -w -n &lt;issuer_namespace&gt;</programlisting>
<simpara>Once certificate is in <literal>Ready</literal> status, workloads on your cluster can start using the generated certificate secret.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-certificate-api-server_cert-manager-creating-certificate">
<title>Creating certificates for the API server</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.13.0 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an issuer. For more information, see "Configuring an issuer" in the "Additional Resources" section.</simpara>
</listitem>
<listitem>
<simpara>Create a certificate:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, for example, <literal>certificate.yaml</literal>, that defines the <literal>Certificate</literal> object:</simpara>
<formalpara>
<title>Example <literal>certificate.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: &lt;tls_cert&gt; <co xml:id="CO71-1"/>
  namespace: openshift-config
spec:
  isCA: false
  commonName: "api.&lt;cluster_base_domain&gt;" <co xml:id="CO71-2"/>
  secretName: &lt;secret_name&gt; <co xml:id="CO71-3"/>
  dnsNames:
  - "api.&lt;cluster_base_domain&gt;" <co xml:id="CO71-4"/>
  issuerRef:
    name: &lt;issuer_name&gt; <co xml:id="CO71-5"/>
    kind: Issuer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO71-1">
<para>Provide a name for the certificate.</para>
</callout>
<callout arearefs="CO71-2">
<para>Specify the common name (CN).</para>
</callout>
<callout arearefs="CO71-3">
<para>Specify the name of the secret to create that contains the certificate.</para>
</callout>
<callout arearefs="CO71-4">
<para>Specify the DNS name of the API server.</para>
</callout>
<callout arearefs="CO71-5">
<para>Specify the name of the issuer.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Certificate</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f certificate.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add the API server named certificate. For more information, see "Adding an API server named certificate" section in the "Additional resources" section.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>To ensure the certificates are updated, run the <literal>oc login</literal> command again after the certificate is created.</simpara>
</note>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the certificate is created and ready to use by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get certificate -w -n openshift-config</programlisting>
<simpara>Once certificate is in <literal>Ready</literal> status, API server on your cluster can start using the generated certificate secret.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-certificate-ingress_cert-manager-creating-certificate">
<title>Creating certificates for the Ingress Controller</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.13.0 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an issuer. For more information, see "Configuring an issuer" in the "Additional Resources" section.</simpara>
</listitem>
<listitem>
<simpara>Create a certificate:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file, for example, <literal>certificate.yaml</literal>, that defines the <literal>Certificate</literal> object:</simpara>
<formalpara>
<title>Example <literal>certificate.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: &lt;tls_cert&gt; <co xml:id="CO72-1"/>
  namespace: openshift-ingress
spec:
  isCA: false
  commonName: "apps.&lt;cluster_base_domain&gt;" <co xml:id="CO72-2"/>
  secretName: &lt;secret_name&gt; <co xml:id="CO72-3"/>
  dnsNames:
  - "apps.&lt;cluster_base_domain&gt;" <co xml:id="CO72-4"/>
  - "*.apps.&lt;cluster_base_domain&gt;" <co xml:id="CO72-5"/>
  issuerRef:
    name: &lt;issuer_name&gt; <co xml:id="CO72-6"/>
    kind: Issuer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO72-1">
<para>Provide a name for the certificate.</para>
</callout>
<callout arearefs="CO72-2">
<para>Specify the common name (CN).</para>
</callout>
<callout arearefs="CO72-3">
<para>Specify the name of the secret to create that contains the certificate.</para>
</callout>
<callout arearefs="CO72-4 CO72-5">
<para>Specify the DNS name of the ingress.</para>
</callout>
<callout arearefs="CO72-6">
<para>Specify the name of the issuer.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Certificate</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f certificate.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Replace the default ingress certificate. For more information, see "Replacing the default ingress certificate" section in the "Additional resources" section.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the certificate is created and ready to use by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get certificate -w -n openshift-ingress</programlisting>
<simpara>Once certificate is in <literal>Ready</literal> status, Ingress Controller on your cluster can start using the generated certificate secret.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_cert-manager-creating-certificate" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>Configuring an issuer</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/index.xml#cert-manager-issuer-types_cert-manager-operator-about">Supported issuer types</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-operator-issuer-acme.xml#cert-manager-operator-issuer-acme">Configuring an ACME issuer</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificates/api-server.xml#customize-certificates-api-add-named_api-server-certificates">Adding an API server named certificate</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../security/certificates/replacing-default-ingress-certificate.xml#replacing-default-ingress">Replacing the default ingress certificate</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-monitoring">
<title>Enabling monitoring for the cert-manager Operator for Red Hat OpenShift</title>

<simpara>You can expose controller metrics for the cert-manager Operator for Red Hat OpenShift in the format provided by the Prometheus Operator.</simpara>
<section xml:id="cert-manager-enable-metrics_cert-manager-monitoring">
<title>Enabling monitoring by using a service monitor for the cert-manager Operator for Red Hat OpenShift</title>
<simpara>You can enable monitoring and metrics collection for the cert-manager Operator for Red Hat OpenShift by using a service monitor to perform the custom metrics scraping.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>The cert-manager Operator for Red Hat OpenShift is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the label to enable cluster monitoring by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace cert-manager openshift.io/cluster-monitoring=true</programlisting>
</listitem>
<listitem>
<simpara>Create a service monitor:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Role</literal>, <literal>RoleBinding</literal>, and <literal>ServiceMonitor</literal> objects:</simpara>
<formalpara>
<title>Example <literal>monitoring.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: prometheus-k8s
  namespace: cert-manager
rules:
- apiGroups:
  - ""
  resources:
  - services
  - endpoints
  - pods
  verbs:
  - get
  - list
  - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: prometheus-k8s
  namespace: cert-manager
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: prometheus-k8s
subjects:
- kind: ServiceAccount
  name: prometheus-k8s
  namespace: openshift-monitoring
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: cert-manager
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: cert-manager
    app.kubernetes.io/name: cert-manager
  name: cert-manager
  namespace: cert-manager
spec:
  endpoints:
  - interval: 30s
    port: tcp-prometheus-servicemonitor
    scheme: http
  selector:
    matchLabels:
      app.kubernetes.io/component: controller
      app.kubernetes.io/instance: cert-manager
      app.kubernetes.io/name: cert-manager</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>Role</literal>, <literal>RoleBinding</literal>, and <literal>ServiceMonitor</literal> objects by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f monitoring.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../monitoring/managing-metrics.xml#setting-up-metrics-collection-for-user-defined-projects_managing-metrics">Setting up metrics collection for user-defined projects</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-query-metrics_cert-manager-monitoring">
<title>Querying metrics for the cert-manager Operator for Red Hat OpenShift</title>
<simpara>After you have enabled monitoring for the cert-manager Operator for Red Hat OpenShift, you can query its metrics by using the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift.</simpara>
</listitem>
<listitem>
<simpara>You have enabled monitoring and metrics collection for the cert-manager Operator for Red Hat OpenShift.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the OpenShift Container Platform web console, navigate to <emphasis role="strong">Observe</emphasis> &#8594; <emphasis role="strong">Metrics</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Add a query by using one of the following formats:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify the endpoints:</simpara>
<programlisting language="promql" linenumbering="unnumbered">{instance="&lt;endpoint&gt;"} <co xml:id="CO73-1"/></programlisting>
<calloutlist>
<callout arearefs="CO73-1">
<para>Replace <literal>&lt;endpoint&gt;</literal> with the value of the endpoint for the <literal>cert-manager</literal> service. You can find the endpoint value by running the following command: <literal>oc describe service cert-manager -n cert-manager</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Specify the <literal>tcp-prometheus-servicemonitor</literal> port:</simpara>
<programlisting language="promql" linenumbering="unnumbered">{endpoint="tcp-prometheus-servicemonitor"}</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cert-manager-operator-proxy">
<title>Configuring the egress proxy for the cert-manager Operator for Red Hat OpenShift</title>

<simpara>If a cluster-wide egress proxy is configured in OpenShift Container Platform, Operator Lifecycle Manager (OLM) automatically configures Operators that it manages with the cluster-wide proxy. OLM automatically updates all of the Operator&#8217;s deployments with the <literal>HTTP_PROXY</literal>, <literal>HTTPS_PROXY</literal>, <literal>NO_PROXY</literal> environment variables.</simpara>
<simpara>You can inject any CA certificates that are required for proxying HTTPS connections into the cert-manager Operator for Red Hat OpenShift.</simpara>
<section xml:id="cert-manager-proxy-support_cert-manager-operator-proxy">
<title>Injecting a custom CA certificate for the cert-manager Operator for Red Hat OpenShift</title>
<simpara>If your OpenShift Container Platform cluster has the cluster-wide proxy enabled, you can inject any CA certificates that are required for proxying HTTPS connections into the cert-manager Operator for Red Hat OpenShift.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have enabled the cluster-wide proxy for OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a config map in the <literal>cert-manager</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap trusted-ca -n cert-manager</programlisting>
</listitem>
<listitem>
<simpara>Inject the CA bundle that is trusted by OpenShift Container Platform into the config map by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label cm trusted-ca config.openshift.io/inject-trusted-cabundle=true -n cert-manager</programlisting>
</listitem>
<listitem>
<simpara>Update the deployment for the cert-manager Operator for Red Hat OpenShift to use the config map by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager-operator patch subscription openshift-cert-manager-operator --type='merge' -p '{"spec":{"config":{"env":[{"name":"TRUSTED_CA_CONFIGMAP_NAME","value":"trusted-ca"}]}}}'</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the deployments have finished rolling out by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rollout status deployment/cert-manager-operator-controller-manager -n cert-manager-operator &amp;&amp; \
oc rollout status deployment/cert-manager -n cert-manager &amp;&amp; \
oc rollout status deployment/cert-manager-webhook -n cert-manager &amp;&amp; \
oc rollout status deployment/cert-manager-cainjector -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">deployment "cert-manager-operator-controller-manager" successfully rolled out
deployment "cert-manager" successfully rolled out
deployment "cert-manager-webhook" successfully rolled out
deployment "cert-manager-cainjector" successfully rolled out</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the CA bundle was mounted as a volume by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment cert-manager -n cert-manager -o=jsonpath={.spec.template.spec.'containers[0].volumeMounts'}</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[{"mountPath":"/etc/pki/tls/certs/cert-manager-tls-ca-bundle.crt","name":"trusted-ca","subPath":"ca-bundle.crt"}]</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the source of the CA bundle is the <literal>trusted-ca</literal> config map by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment cert-manager -n cert-manager -o=jsonpath={.spec.template.spec.volumes}</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[{"configMap":{"defaultMode":420,"name":"trusted-ca"},"name":"trusted-ca"}]</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-operator-proxy_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">Configuring proxy support in Operator Lifecycle Manager</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-customizing-api-fields">
<title>Customizing cert-manager Operator API fields</title>

<simpara>You can customize the cert-manager Operator for Red Hat OpenShift API fields by overriding environment variables and arguments.</simpara>
<warning>
<simpara>To override unsupported arguments, you can add <literal>spec.unsupportedConfigOverrides</literal> section in the <literal>CertManager</literal> resource, but using <literal>spec.unsupportedConfigOverrides</literal> is unsupported.</simpara>
</warning>
<section xml:id="cert-manager-override-environment-variables_cert-manager-customizing-api-fields">
<title>Customizing cert-manager by overriding environment variables from the cert-manager Operator API</title>
<simpara>You can override the supported environment variables for the cert-manager Operator for Red Hat OpenShift by adding a <literal>spec.controllerConfig</literal> section in the <literal>CertManager</literal> resource.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:
    overrideEnv:
      - name: HTTP_PROXY
        value: http://&lt;proxy_url&gt; <co xml:id="CO74-1"/>
      - name: HTTPS_PROXY
        value: https://&lt;proxy_url&gt; <co xml:id="CO74-2"/>
      - name: NO_PROXY
        value: &lt;ignore_proxy_domains&gt; <co xml:id="CO74-3"/></programlisting>
<calloutlist>
<callout arearefs="CO74-1 CO74-2">
<para>Replace <literal>&lt;proxy_url&gt;</literal> with the proxy server URL.</para>
</callout>
<callout arearefs="CO74-3">
<para>Replace <literal>&lt;ignore_proxy_domains&gt;</literal> with a comma separated list of domains. These domains are ignored by the proxy server.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save your changes and quit the text editor to apply your changes.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the cert-manager controller pod is redeployed by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt  1/1     Running   0          39s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that environment variables are updated for the cert-manager pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod &lt;redeployed_cert-manager_controller_pod&gt; -n cert-manager -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">    env:
    ...
    - name: HTTP_PROXY
      value: http://&lt;PROXY_URL&gt;
    - name: HTTPS_PROXY
      value: https://&lt;PROXY_URL&gt;
    - name: NO_PROXY
      value: &lt;IGNORE_PROXY_DOMAINS&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-override-arguments_cert-manager-customizing-api-fields">
<title>Customizing cert-manager by overriding arguments from the cert-manager Operator API</title>
<simpara>You can override the supported arguments for the cert-manager Operator for Red Hat OpenShift by adding a <literal>spec.controllerConfig</literal> section in the <literal>CertManager</literal> resource.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
  ...
spec:
  ...
  controllerConfig:
    overrideArgs:
      - '--dns01-recursive-nameservers=&lt;server_address&gt;' <co xml:id="CO75-1"/>
      - '--dns01-recursive-nameservers-only' <co xml:id="CO75-2"/>
      - '--acme-http01-solver-nameservers=&lt;host&gt;:&lt;port&gt;' <co xml:id="CO75-3"/>
      - '--v=&lt;verbosity_level&gt;' <co xml:id="CO75-4"/>
      - '--metrics-listen-address=&lt;host&gt;:&lt;port&gt;' <co xml:id="CO75-5"/>
      - '--issuer-ambient-credentials' <co xml:id="CO75-6"/>
  webhookConfig:
    overrideArgs:
      - '--v=4' <co xml:id="CO75-7"/>
  cainjectorConfig:
    overrideArgs:
      - '--v=2' <co xml:id="CO75-8"/></programlisting>
<calloutlist>
<callout arearefs="CO75-1">
<para>Provide a comma-separated list of nameservers to query for the DNS-01 self check. The nameservers can be specified either as <literal>&lt;host&gt;:&lt;port&gt;</literal>, for example, <literal>1.1.1.1:53</literal>, or use DNS over HTTPS (DoH), for example, <literal><link xlink:href="https://1.1.1.1/dns-query">https://1.1.1.1/dns-query</link></literal>.</para>
</callout>
<callout arearefs="CO75-2">
<para>Specify to only use recursive nameservers instead of checking the authoritative nameservers associated with that domain.</para>
</callout>
<callout arearefs="CO75-3">
<para>Provide a comma-separated list of <literal>&lt;host&gt;:&lt;port&gt;</literal> nameservers to query for the Automated Certificate Management Environment (ACME) HTTP01 self check. For example, <literal>--acme-http01-solver-nameservers=1.1.1.1:53</literal>.</para>
</callout>
<callout arearefs="CO75-4 CO75-7 CO75-8">
<para>Specify to set the log level verbosity to determine the verbosity of log messages.</para>
</callout>
<callout arearefs="CO75-5">
<para>Specify the host and port for the metrics endpoint. The default value is <literal>--metrics-listen-address=0.0.0.0:9402</literal>.</para>
</callout>
<callout arearefs="CO75-6">
<para>You must use the <literal>--issuer-ambient-credentials</literal> argument when configuring an ACME Issuer to solve DNS-01 challenges by using ambient credentials.</para>
</callout>
</calloutlist>
<note>
<simpara>DNS over HTTPS (DoH) is supported starting only from cert-manager Operator for Red Hat OpenShift version 1.13.0 and later.</simpara>
</note>
</listitem>
<listitem>
<simpara>Save your changes and quit the text editor to apply your changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that arguments are updated for cert-manager pods by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n cert-manager -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
  metadata:
    name: cert-manager-6d4b5d4c97-kldwl
    namespace: cert-manager
...
  spec:
    containers:
    - args:
      - --acme-http01-solver-nameservers=1.1.1.1:53
      - --cluster-resource-namespace=$(POD_NAMESPACE)
      - --dns01-recursive-nameservers=1.1.1.1:53
      - --dns01-recursive-nameservers-only
      - --leader-election-namespace=kube-system
      - --max-concurrent-challenges=60
      - --metrics-listen-address=0.0.0.0:9042
      - --v=6
...
  metadata:
    name: cert-manager-cainjector-866c4fd758-ltxxj
    namespace: cert-manager
...
  spec:
    containers:
    - args:
      - --leader-election-namespace=kube-system
      - --v=2
...
  metadata:
    name: cert-manager-webhook-6d48f88495-c88gd
    namespace: cert-manager
...
  spec:
    containers:
    - args:
      ...
      - --v=4</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-override-flag-controller_cert-manager-customizing-api-fields">
<title>Deleting a TLS secret automatically upon Certificate removal</title>
<simpara>You can enable the <literal>--enable-certificate-owner-ref</literal> flag for the cert-manager Operator for Red Hat OpenShift by adding a <literal>spec.controllerConfig</literal> section in the <literal>CertManager</literal> resource. The <literal>--enable-certificate-owner-ref</literal> flag sets the certificate resource as an owner of the secret where the TLS certificate is stored.</simpara>
<warning>
<simpara>If you uninstall the cert-manager Operator for Red Hat OpenShift or delete certificate resources from the cluster, the secret is deleted automatically. This might cause network connectivity issues depending upon where the certificate TLS secret is being used.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.12.0 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check that the <literal>Certificate</literal> object and its secret are available by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get certificate</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                             READY   SECRET                                           AGE
certificate-from-clusterissuer-route53-ambient   True    certificate-from-clusterissuer-route53-ambient   8h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager cluster</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>spec.controllerConfig</literal> section with the following override arguments:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
metadata:
  name: cluster
# ...
spec:
# ...
  controllerConfig:
    overrideArgs:
      - '--enable-certificate-owner-ref'</programlisting>
</listitem>
<listitem>
<simpara>Save your changes and quit the text editor to apply your changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the <literal>--enable-certificate-owner-ref</literal> flag is updated for cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># ...
  metadata:
    name: cert-manager-6e4b4d7d97-zmdnb
    namespace: cert-manager
# ...
  spec:
    containers:
    - args:
      - --enable-certificate-owner-ref</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cert-manager-configure-cpu-memory_cert-manager-customizing-api-fields">
<title>Overriding CPU and memory limits for the cert-manager components</title>
<simpara>After installing the cert-manager Operator for Red Hat OpenShift, you can configure the CPU and memory limits from the cert-manager Operator for Red Hat OpenShift API for the cert-manager components such as cert-manager controller, CA injector, and Webhook.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the OpenShift Container Platform cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.12.0 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check that the deployments of the cert-manager controller, CA injector, and Webhook are available by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
cert-manager              1/1     1            1           53m
cert-manager-cainjector   1/1     1            1           53m
cert-manager-webhook      1/1     1            1           53m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Before setting the CPU and memory limit, check the existing configuration for the cert-manager controller, CA injector, and Webhook by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n cert-manager -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># ...
  metadata:
    name: cert-manager
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-controller
          resources: {} <co xml:id="CO76-1"/>
# ...
  metadata:
    name: cert-manager-cainjector
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-cainjector
          resources: {} <co xml:id="CO76-2"/>
# ...
  metadata:
    name: cert-manager-webhook
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-webhook
          resources: {} <co xml:id="CO76-3"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO76-1 CO76-2 CO76-3">
<para>The <literal>spec.resources</literal> field is empty by default. The cert-manager components do not have CPU and memory limits.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To configure the CPU and memory limits for the cert-manager controller, CA injector, and Webhook, enter the following command:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ oc patch certmanager.operator cluster --type=merge -p="
spec:
  controllerConfig:
    overrideResources:
      limits: <co xml:id="CO77-1"/>
        cpu: 200m <co xml:id="CO77-2"/>
        memory: 64Mi <co xml:id="CO77-3"/>
      requests: <co xml:id="CO77-4"/>
        cpu: 10m <co xml:id="CO77-5"/>
        memory: 16Mi <co xml:id="CO77-6"/>
  webhookConfig:
    overrideResources:
      limits: <co xml:id="CO77-7"/>
        cpu: 200m <co xml:id="CO77-8"/>
        memory: 64Mi <co xml:id="CO77-9"/>
      requests: <co xml:id="CO77-10"/>
        cpu: 10m <co xml:id="CO77-11"/>
        memory: 16Mi <co xml:id="CO77-12"/>
  cainjectorConfig:
    overrideResources:
      limits: <co xml:id="CO77-13"/>
        cpu: 200m <co xml:id="CO77-14"/>
        memory: 64Mi <co xml:id="CO77-15"/>
      requests: <co xml:id="CO77-16"/>
        cpu: 10m <co xml:id="CO77-17"/>
        memory: 16Mi <co xml:id="CO77-18"/>
"</programlisting>
<calloutlist>
<callout arearefs="CO77-1">
<para>Defines the maximum amount of CPU and memory that a single container in a cert-manager controller pod can request.</para>
</callout>
<callout arearefs="CO77-2 CO77-5">
<para>You can specify the CPU limit that a cert-manager controller pod can request. The default value is <literal>10m</literal>.</para>
</callout>
<callout arearefs="CO77-3 CO77-6">
<para>You can specify the memory limit that a cert-manager controller pod can request. The default value is <literal>32Mi</literal>.</para>
</callout>
<callout arearefs="CO77-4">
<para>Defines the amount of CPU and memory set by scheduler for the cert-manager controller pod.</para>
</callout>
<callout arearefs="CO77-7">
<para>Defines the maximum amount of CPU and memory that a single container in a CA injector pod can request.</para>
</callout>
<callout arearefs="CO77-8 CO77-11">
<para>You can specify the CPU limit that a CA injector pod can request. The default value is <literal>10m</literal>.</para>
</callout>
<callout arearefs="CO77-9 CO77-12">
<para>You can specify the memory limit that a CA injector pod can request. The default value is <literal>32Mi</literal>.</para>
</callout>
<callout arearefs="CO77-10">
<para>Defines the amount of CPU and memory set by scheduler for the CA injector pod.</para>
</callout>
<callout arearefs="CO77-13">
<para>Defines the maximum amount of CPU and memory Defines the maximum amount of CPU and memory that a single container in a Webhook pod can request.</para>
</callout>
<callout arearefs="CO77-14 CO77-17">
<para>You can specify the CPU limit that a Webhook pod can request. The default value is <literal>10m</literal>.</para>
</callout>
<callout arearefs="CO77-15 CO77-18">
<para>You can specify the memory limit that a Webhook pod can request. The default value is <literal>32Mi</literal>.</para>
</callout>
<callout arearefs="CO77-16">
<para>Defines the amount of CPU and memory set by scheduler for the Webhook pod.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="termnal" linenumbering="unnumbered">certmanager.operator.openshift.io/cluster patched</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the CPU and memory limits are updated for the cert-manager components:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n cert-manager -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># ...
  metadata:
    name: cert-manager
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-controller
          resources:
            limits:
              cpu: 200m
              memory: 64Mi
            requests:
              cpu: 10m
              memory: 16Mi
# ...
  metadata:
    name: cert-manager-cainjector
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-cainjector
          resources:
            limits:
              cpu: 200m
              memory: 64Mi
            requests:
              cpu: 10m
              memory: 16Mi
# ...
  metadata:
    name: cert-manager-webhook
    namespace: cert-manager
# ...
  spec:
    template:
      spec:
        containers:
        - name: cert-manager-webhook
          resources:
            limits:
              cpu: 200m
              memory: 64Mi
            requests:
              cpu: 10m
              memory: 16Mi
# ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cert-manager-authenticate-aws">
<title>Authenticating the cert-manager Operator for Red Hat OpenShift with AWS Security Token Service</title>

<simpara>You can authenticate the cert-manager Operator for Red Hat OpenShift on the AWS Security Token Service (STS) cluster. You can configure cloud credentials for the cert-manager Operator for Red Hat OpenShift by using the <literal>ccoctl</literal> binary.</simpara>
<section xml:id="cert-manager-configure-cloud-credentials-aws-sts_cert-manager-authenticate-aws">
<title>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift for the AWS Security Token Service cluster</title>
<simpara>To configure the cloud credentials for the cert-manager Operator for Red Hat OpenShift on the AWS Security Token Service (STS) cluster with the cloud credentials. You must generate the cloud credentials manually, and apply it on the cluster by using the <literal>ccoctl</literal> binary.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have extracted and prepared the <literal>ccoctl</literal> binary.</simpara>
</listitem>
<listitem>
<simpara>You have configured an OpenShift Container Platform cluster with AWS STS by using the Cloud Credential Operator in manual mode.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory to store a <literal>CredentialsRequest</literal> resource YAML file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir credentials-request</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>CredentialsRequest</literal> resource YAML file under the <literal>credentials-request</literal> directory, such as, <literal>sample-credential-request.yaml</literal>, by applying the following yaml:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: cert-manager
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - "route53:GetChange"
      effect: Allow
      resource: "arn:aws:route53:::change/*"
    - action:
      - "route53:ChangeResourceRecordSets"
      - "route53:ListResourceRecordSets"
      effect: Allow
      resource: "arn:aws:route53:::hostedzone/*"
    - action:
      - "route53:ListHostedZonesByName"
      effect: Allow
      resource: "*"
  secretRef:
    name: aws-creds
    namespace: cert-manager
  serviceAccountNames:
  - cert-manager</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>ccoctl</literal> tool to process <literal>CredentialsRequest</literal> objects by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-iam-roles \
    --name &lt;user_defined_name&gt; --region=&lt;aws_region&gt; \
    --credentials-requests-dir=&lt;path_to_credrequests_dir&gt; \
    --identity-provider-arn &lt;oidc_provider_arn&gt; --output-dir=&lt;path_to_output_dir&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2023/05/15 18:10:34 Role arn:aws:iam::XXXXXXXXXXXX:role/&lt;user_defined_name&gt;-cert-manager-aws-creds created
2023/05/15 18:10:34 Saved credentials configuration to: &lt;path_to_output_dir&gt;/manifests/cert-manager-aws-creds-credentials.yaml
2023/05/15 18:10:35 Updated Role policy for Role &lt;user_defined_name&gt;-cert-manager-aws-creds</programlisting>
</para>
</formalpara>
<simpara>Copy the <literal>&lt;aws_role_arn&gt;</literal> from the output to use in the next step. For example, <literal>"arn:aws:iam::XXXXXXXXXXXX:role/&lt;user_defined_name&gt;-cert-manager-aws-creds"</literal></simpara>
</listitem>
<listitem>
<simpara>Add the <literal>eks.amazonaws.com/role-arn="&lt;aws_role_arn&gt;"</literal> annotation to the service account by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager annotate serviceaccount cert-manager eks.amazonaws.com/role-arn="&lt;aws_role_arn&gt;"</programlisting>
</listitem>
<listitem>
<simpara>To create a new pod, delete the existing cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<simpara>The AWS credentials are applied to a new cert-manager controller pod within a minute.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Get the name of the updated cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt  1/1     Running   0          39s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that AWS credentials are updated by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set env -n cert-manager po/&lt;cert_manager_controller_pod_name&gt; --list</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># pods/cert-manager-57f9555c54-vbcpg, container cert-manager-controller
# POD_NAMESPACE from field path metadata.namespace
AWS_ROLE_ARN=XXXXXXXXXXXX
AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_cert-manager-authenticate-gcp" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#cco-ccoctl-configuring_installing-aws-customizations">Configuring the Cloud Credential Operator utility</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-log-levels">
<title>Configuring log levels for cert-manager and the cert-manager Operator for Red Hat OpenShift</title>

<simpara>To troubleshoot issues with the cert-manager components and the cert-manager Operator for Red Hat OpenShift, you can configure the log level verbosity.</simpara>
<note>
<simpara>To use different log levels for different cert-manager components, see <emphasis>Customizing cert-manager Operator API fields</emphasis>.</simpara>
</note>
<section xml:id="cert-manager-enable-operand-log-level_cert-manager-log-levels">
<title>Setting a log level for cert-manager</title>
<simpara>You can set a log level for cert-manager to determine the verbosity of log messages.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.11.1 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CertManager</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit certmanager.operator cluster</programlisting>
</listitem>
<listitem>
<simpara>Set the log level value by editing the <literal>spec.logLevel</literal> section:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: CertManager
...
spec:
  logLevel: Normal <co xml:id="CO78-1"/></programlisting>
<calloutlist>
<callout arearefs="CO78-1">
<para>The default <literal>logLevel</literal> is <literal>Normal</literal>. Replace <literal>Normal</literal> with the desired log level value. The valid log level values for the <literal>CertManager</literal> resource are <literal>Normal</literal>, <literal>Debug</literal>, <literal>Trace</literal>, and <literal>TraceAll</literal>. To audit logs and perform common operations when everything is fine, set <literal>logLevel</literal> to <literal>Normal</literal> . To troubleshoot a minor issue by viewing verbose logs, set <literal>logLevel</literal> to <literal>Debug</literal> . To troubleshoot a major issue by viewing more verbose logs, you can set <literal>logLevel</literal> to <literal>Trace</literal>. To troubleshoot serious issues, set <literal>logLevel</literal> to <literal>TraceAll</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara><literal>TraceAll</literal> generates huge amount of logs. After setting <literal>logLevel</literal> to <literal>TraceAll</literal>, you might experience performance issues.</simpara>
</note>
</listitem>
<listitem>
<simpara>Save your changes and quit the text editor to apply your changes.</simpara>
<simpara>After applying the changes, the verbosity level for the cert-manager components controller, CA injector, and webhook is updated.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-enable-operator-log-level_cert-manager-log-levels">
<title>Setting a log level for the cert-manager Operator for Red Hat OpenShift</title>
<simpara>You can set a log level for the cert-manager Operator for Red Hat OpenShift to determine the verbosity of the operator log messages.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.11.1 or later.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Update the subscription object for cert-manager Operator for Red Hat OpenShift to provide the verbosity level for the operator logs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager-operator patch subscription openshift-cert-manager-operator --type='merge' -p '{"spec":{"config":{"env":[{"name":"OPERATOR_LOG_LEVEL","value":"v"}]}}}' <co xml:id="CO79-1"/></programlisting>
<calloutlist>
<callout arearefs="CO79-1">
<para>Replace <literal>v</literal> with the desired log level number. The valid values for <literal>v</literal> can range from <literal>1`to `10</literal>. The default value is <literal>2</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>The cert-manager Operator pod is redeployed. Verify that the log level of the cert-manager Operator for Red Hat OpenShift is updated by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set env deploy/cert-manager-operator-controller-manager -n cert-manager-operator --list | grep -e OPERATOR_LOG_LEVEL -e container</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># deployments/cert-manager-operator-controller-manager, container kube-rbac-proxy
OPERATOR_LOG_LEVEL=9
# deployments/cert-manager-operator-controller-manager, container cert-manager-operator
OPERATOR_LOG_LEVEL=9</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the log level of the cert-manager Operator for Red Hat OpenShift is updated by running the <literal>oc logs</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deploy/cert-manager-operator-controller-manager -n cert-manager-operator</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-log-levels_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../security/cert_manager_operator/cert-manager-customizing-api-fields.xml#cert-manager-customizing-api-fields">Customizing cert-manager Operator API fields</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-authenticate-gcp">
<title>Authenticating the cert-manager Operator for Red Hat OpenShift with GCP Workload Identity</title>

<simpara>You can authenticate the cert-manager Operator for Red Hat OpenShift on the GCP Workload Identity cluster by using the cloud credentials. You can configure the cloud credentials by using the <literal>ccoctl</literal> binary.</simpara>
<section xml:id="cert-manager-configure-cloud-credentials-gcp-sts_cert-manager-authenticate-gcp">
<title>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift with GCP Workload Identity</title>
<simpara>Generate the cloud credentials for the cert-manager Operator for Red Hat OpenShift by using the <literal>ccoctl</literal> binary. Then, apply them to the GCP Workload Identity cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You extracted and prepared the <literal>ccoctl</literal> binary.</simpara>
</listitem>
<listitem>
<simpara>The cert-manager Operator for Red Hat OpenShift 1.11.1 or later is installed.</simpara>
</listitem>
<listitem>
<simpara>You have configured an OpenShift Container Platform cluster with GCP Workload Identity by using the Cloud Credential Operator in a manual mode.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory to store a <literal>CredentialsRequest</literal> resource YAML file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir credentials-request</programlisting>
</listitem>
<listitem>
<simpara>In the <literal>credentials-request</literal> directory, create a YAML file that contains the following <literal>CredentialsRequest</literal> manifest:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: cert-manager
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: GCPProviderSpec
    predefinedRoles:
    - roles/dns.admin
  secretRef:
    name: gcp-credentials
    namespace: cert-manager
  serviceAccountNames:
  - cert-manager</programlisting>
<note>
<simpara>The <literal>dns.admin</literal> role provides admin privileges to the service account for managing Google Cloud DNS resources. To ensure that the cert-manager runs with the service account that has the least privilege, you can create a custom role with the following permissions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>dns.resourceRecordSets.*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>dns.changes.*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>dns.managedZones.list</literal></simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Use the <literal>ccoctl</literal> tool to process <literal>CredentialsRequest</literal> objects by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl gcp create-service-accounts \
    --name &lt;user_defined_name&gt; --output-dir=&lt;path_to_output_dir&gt; \
    --credentials-requests-dir=&lt;path_to_credrequests_dir&gt; \
    --workload-identity-pool &lt;workload_identity_pool&gt; \
    --workload-identity-provider &lt;workload_identity_provider&gt; \
    --project &lt;gcp_project_id&gt;</programlisting>
<formalpara>
<title>Example command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl gcp create-service-accounts \
    --name abcde-20230525-4bac2781 --output-dir=/home/outputdir \
    --credentials-requests-dir=/home/credentials-requests \
    --workload-identity-pool abcde-20230525-4bac2781 \
    --workload-identity-provider abcde-20230525-4bac2781 \
    --project openshift-gcp-devel</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Apply the secrets generated in the manifests directory of your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls &lt;path_to_output_dir&gt;/manifests/*-credentials.yaml | xargs -I{} oc apply -f {}</programlisting>
</listitem>
<listitem>
<simpara>Update the subscription object for cert-manager Operator for Red Hat OpenShift by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager-operator patch subscription openshift-cert-manager-operator --type=merge -p '{"spec":{"config":{"env":[{"name":"CLOUD_CREDENTIALS_SECRET_NAME","value":"gcp-credentials"}]}}}'</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Get the name of the redeployed cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt  1/1     Running   0          15m39s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the cert-manager controller pod is updated with GCP workload identity credential volumes that are mounted under the path specified in <literal>mountPath</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n cert-manager pod/&lt;cert-manager_controller_pod_name&gt; -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">spec:
  containers:
  - args:
    ...
    volumeMounts:
    - mountPath: /var/run/secrets/openshift/serviceaccount
      name: bound-sa-token
      ...
    - mountPath: /.config/gcloud
      name: cloud-credentials
  ...
  volumes:
  - name: bound-sa-token
    projected:
      ...
      sources:
      - serviceAccountToken:
          audience: openshift
          ...
          path: token
  - name: cloud-credentials
    secret:
      ...
      items:
      - key: service_account.json
        path: application_default_credentials.json
      secretName: gcp-credentials</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_cert-manager-authenticate-gcp-workload-identity" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#cco-ccoctl-configuring_installing-gcp-customizations">Configuring the Cloud Credential Operator utility</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cert-manager-authentication-non-sts">
<title>Authenticating the cert-manager Operator for Red Hat OpenShift on AWS</title>

<simpara>You can configure the cloud credentials for the cert-manager Operator for Red Hat OpenShift on the AWS cluster. The cloud credentials are generated by the Cloud Credential Operator.</simpara>
<section xml:id="cert-manager-configure-cloud-credentials-aws-non-sts_cert-manager-authentication-non-sts">
<title>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on AWS</title>
<simpara>To configure the cloud credentials for the cert-manager Operator for Red Hat OpenShift on the AWS cluster you must generate the cloud credentials secret by creating a <literal>CredentialsRequest</literal> object, and allowing the Cloud Credential Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.11.1 or later.</simpara>
</listitem>
<listitem>
<simpara>You have configured the Cloud Credential Operator to operate in <emphasis>mint</emphasis> or <emphasis>passthrough</emphasis> mode.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>CredentialsRequest</literal> resource YAML file, for example, <literal>sample-credential-request.yaml</literal>, as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: cert-manager
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - "route53:GetChange"
      effect: Allow
      resource: "arn:aws:route53:::change/*"
    - action:
      - "route53:ChangeResourceRecordSets"
      - "route53:ListResourceRecordSets"
      effect: Allow
      resource: "arn:aws:route53:::hostedzone/*"
    - action:
      - "route53:ListHostedZonesByName"
      effect: Allow
      resource: "*"
  secretRef:
    name: aws-creds
    namespace: cert-manager
  serviceAccountNames:
  - cert-manager</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>CredentialsRequest</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f sample-credential-request.yaml</programlisting>
</listitem>
<listitem>
<simpara>Update the subscription object for cert-manager Operator for Red Hat OpenShift by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager-operator patch subscription openshift-cert-manager-operator --type=merge -p '{"spec":{"config":{"env":[{"name":"CLOUD_CREDENTIALS_SECRET_NAME","value":"aws-creds"}]}}}'</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Get the name of the redeployed cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt  1/1     Running   0          15m39s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the cert-manager controller pod is updated with AWS credential volumes that are mounted under the path specified in <literal>mountPath</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n cert-manager pod/&lt;cert-manager_controller_pod_name&gt; -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
spec:
  containers:
  - args:
    ...
    - mountPath: /.aws
      name: cloud-credentials
  ...
  volumes:
  ...
  - name: cloud-credentials
    secret:
      ...
      secretName: aws-creds</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cert-manager-authenticate-non-sts-gcp">
<title>Authenticating the cert-manager Operator for Red Hat OpenShift on GCP</title>

<simpara>You can configure cloud credentials for the cert-manager Operator for Red Hat OpenShift on a GCP cluster. The cloud credentials are generated by the Cloud Credential Operator.</simpara>
<section xml:id="cert-manager-configure-cloud-credentials-gcp-non-sts_cert-manager-authenticate-non-sts-gcp">
<title>Configuring cloud credentials for the cert-manager Operator for Red Hat OpenShift on GCP</title>
<simpara>To configure the cloud credentials for the cert-manager Operator for Red Hat OpenShift on a GCP cluster you must create a <literal>CredentialsRequest</literal> object, and allow the Cloud Credential Operator to generate the cloud credentials secret.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the cert-manager Operator for Red Hat OpenShift 1.11.1 or later.</simpara>
</listitem>
<listitem>
<simpara>You have configured the Cloud Credential Operator to operate in <emphasis>mint</emphasis> or <emphasis>passthrough</emphasis> mode.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>CredentialsRequest</literal> resource YAML file, such as, <literal>sample-credential-request.yaml</literal> by applying the following yaml:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: cert-manager
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: GCPProviderSpec
    predefinedRoles:
    - roles/dns.admin
  secretRef:
    name: gcp-credentials
    namespace: cert-manager
  serviceAccountNames:
  - cert-manager</programlisting>
<note>
<simpara>The <literal>dns.admin</literal> role provides admin privileges to the service account for managing Google Cloud DNS resources. To ensure that the cert-manager runs with the service account that has the least privilege, you can create a custom role with the following permissions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>dns.resourceRecordSets.*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>dns.changes.*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>dns.managedZones.list</literal></simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Create a <literal>CredentialsRequest</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f sample-credential-request.yaml</programlisting>
</listitem>
<listitem>
<simpara>Update the subscription object for cert-manager Operator for Red Hat OpenShift by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n cert-manager-operator patch subscription openshift-cert-manager-operator --type=merge -p '{"spec":{"config":{"env":[{"name":"CLOUD_CREDENTIALS_SECRET_NAME","value":"gcp-credentials"}]}}}'</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Get the name of the redeployed cert-manager controller pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -l app.kubernetes.io/name=cert-manager -n cert-manager</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       READY   STATUS    RESTARTS   AGE
cert-manager-bd7fbb9fc-wvbbt               1/1     Running   0          15m39s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the cert-manager controller pod is updated with GCP credential volumes that are mounted under the path specified in <literal>mountPath</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n cert-manager pod/&lt;cert-manager_controller_pod_name&gt; -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">spec:
  containers:
  - args:
    ...
    volumeMounts:
    ...
    - mountPath: /.config/gcloud
      name: cloud-credentials
    ....
  volumes:
  ...
  - name: cloud-credentials
    secret:
      ...
      items:
      - key: service_account.json
        path: application_default_credentials.json
      secretName: gcp-credentials</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cert-manager-operator-uninstall">
<title>Uninstalling the cert-manager Operator for Red Hat OpenShift</title>

<simpara>You can remove the cert-manager Operator for Red Hat OpenShift from OpenShift Container Platform by uninstalling the Operator and removing its related resources.</simpara>
<section xml:id="cert-manager-uninstall-console_cert-manager-operator-uninstall">
<title>Uninstalling the cert-manager Operator for Red Hat OpenShift</title>
<simpara>You can uninstall the cert-manager Operator for Red Hat OpenShift by using the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>The cert-manager Operator for Red Hat OpenShift is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Uninstall the cert-manager Operator for Red Hat OpenShift Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">cert-manager Operator for Red Hat OpenShift</emphasis> entry and click <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cert-manager-remove-resources-console_cert-manager-operator-uninstall">
<title>Removing cert-manager Operator for Red Hat OpenShift resources</title>
<simpara>Once you have uninstalled the cert-manager Operator for Red Hat OpenShift, you have the option to eliminate its associated resources from your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Remove the deployments of the cert-manager components, such as <literal>cert-manager</literal>, <literal>cainjector</literal>, and <literal>webhook</literal>, present in the <literal>cert-manager</literal> namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the <emphasis role="strong">Project</emphasis> drop-down menu to see a list of all available projects, and select the <emphasis role="strong">cert-manager</emphasis> project.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Deployments</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the deployment that you want to delete.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Actions</emphasis> drop-down menu, and select <emphasis role="strong">Delete Deployment</emphasis> to see a confirmation dialog box.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Delete</emphasis> to delete the deployment.</simpara>
</listitem>
<listitem>
<simpara>Alternatively, delete deployments of the cert-manager components such as <literal>cert-manager</literal>, <literal>cainjector</literal> and <literal>webhook</literal> present in the <literal>cert-manager</literal> namespace by using the command-line interface (CLI).</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete deployment -n cert-manager -l app.kubernetes.io/instance=cert-manager</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Remove the custom resource definitions (CRDs) that were installed by the cert-manager Operator for Red Hat OpenShift:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>certmanager</literal> in the <emphasis role="strong">Name</emphasis> field to filter the CRDs.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to each of the following CRDs, and select <emphasis role="strong">Delete Custom Resource Definition</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Certificate</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CertificateRequest</literal></simpara>
</listitem>
<listitem>
<simpara><literal>CertManager</literal> (<literal>operator.openshift.io</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>Challenge</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClusterIssuer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Issuer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Order</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Remove the <literal>cert-manager-operator</literal> namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">cert-manager-operator</emphasis> and select <emphasis role="strong">Delete Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, enter <literal>cert-manager-operator</literal> in the field and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="audit-log-view">
<title>Viewing audit logs</title>

<simpara>OpenShift Container Platform auditing provides a security-relevant chronological set of records documenting the sequence of activities that have affected the system by individual users, administrators, or other components of the system.</simpara>
<section xml:id="nodes-pods-audit-log-basic_audit-log-view">
<title>About the API audit log</title>
<simpara>Audit works at the API server level, logging all requests coming to the server. Each audit log contains the following information:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Audit log fields</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>level</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The audit level at which the event was generated.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>auditID</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A unique audit ID, generated for each request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>stage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The stage of the request handling when this event instance was generated.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>requestURI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The request URI as sent by the client to a server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>verb</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Kubernetes verb associated with the request. For non-resource requests, this is the lowercase HTTP method.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>user</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The authenticated user information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>impersonatedUser</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The impersonated user information, if the request is impersonating another user.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sourceIPs</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The source IPs, from where the request originated and any intermediate proxies.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>userAgent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The user agent string reported by the client. Note that the user agent is provided by the client, and must not be trusted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>objectRef</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The object reference this request is targeted at. This does not apply for <literal>List</literal>-type requests, or non-resource requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>responseStatus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The response status, populated even when the <literal>ResponseObject</literal> is not a <literal>Status</literal> type. For successful responses, this will only include the code. For non-status type error responses, this will be auto-populated with the error message.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>requestObject</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The API object from the request, in JSON format. The <literal>RequestObject</literal> is recorded as is in the request (possibly re-encoded as JSON), prior to version conversion, defaulting, admission or merging. It is an external versioned object type, and might not be a valid object on its own. This is omitted for non-resource requests and is only logged at request level and higher.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>responseObject</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. The API object returned in the response, in JSON format. The <literal>ResponseObject</literal> is recorded after conversion to the external type, and serialized as JSON. This is omitted for non-resource requests and is only logged at response level.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>requestReceivedTimestamp</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time that the request reached the API server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>stageTimestamp</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The time that the request reached the current audit stage.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional. An unstructured key value map stored with an audit event that may be set by plugins invoked in the request serving chain, including authentication, authorization and admission plugins. Note that these annotations are for the audit event, and do not correspond to the <literal>metadata.annotations</literal> of the submitted object. Keys should uniquely identify the informing component to avoid name collisions, for example <literal>podsecuritypolicy.admission.k8s.io/policy</literal>. Values should be short. Annotations are included in the metadata level.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Example output for the Kubernetes API server:</simpara>
<programlisting language="json" linenumbering="unnumbered">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"ad209ce1-fec7-4130-8192-c4cc63f1d8cd","stage":"ResponseComplete","requestURI":"/api/v1/namespaces/openshift-kube-controller-manager/configmaps/cert-recovery-controller-lock?timeout=35s","verb":"update","user":{"username":"system:serviceaccount:openshift-kube-controller-manager:localhost-recovery-client","uid":"dd4997e3-d565-4e37-80f8-7fc122ccd785","groups":["system:serviceaccounts","system:serviceaccounts:openshift-kube-controller-manager","system:authenticated"]},"sourceIPs":["::1"],"userAgent":"cluster-kube-controller-manager-operator/v0.0.0 (linux/amd64) kubernetes/$Format","objectRef":{"resource":"configmaps","namespace":"openshift-kube-controller-manager","name":"cert-recovery-controller-lock","uid":"5c57190b-6993-425d-8101-8337e48c7548","apiVersion":"v1","resourceVersion":"574307"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2020-04-02T08:27:20.200962Z","stageTimestamp":"2020-04-02T08:27:20.206710Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC: allowed by ClusterRoleBinding \"system:openshift:operator:kube-controller-manager-recovery\" of ClusterRole \"cluster-admin\" to ServiceAccount \"localhost-recovery-client/openshift-kube-controller-manager\""}}</programlisting>
</section>
<section xml:id="nodes-nodes-audit-log-basic-viewing_audit-log-view">
<title>Viewing the audit logs</title>
<simpara>You can view the logs for the OpenShift API server, Kubernetes API server, OpenShift OAuth API server, and OpenShift OAuth server for each control plane node.</simpara>
<formalpara>
<title>Procedure</title>
<para>To view the audit logs:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>View the OpenShift API server audit logs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the OpenShift API server audit logs that are available for each control plane node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs --role=master --path=openshift-apiserver/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit-2021-03-09T00-12-19.834.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit-2021-03-09T00-11-49.835.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit-2021-03-09T00-13-00.128.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit.log</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a specific OpenShift API server audit log by providing the node name and the log name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs &lt;node_name&gt; --path=openshift-apiserver/&lt;log_name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs ci-ln-m0wpfjb-f76d1-vnb5x-master-0 --path=openshift-apiserver/audit-2021-03-09T00-12-19.834.log</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"381acf6d-5f30-4c7d-8175-c9c317ae5893","stage":"ResponseComplete","requestURI":"/metrics","verb":"get","user":{"username":"system:serviceaccount:openshift-monitoring:prometheus-k8s","uid":"825b60a0-3976-4861-a342-3b2b561e8f82","groups":["system:serviceaccounts","system:serviceaccounts:openshift-monitoring","system:authenticated"]},"sourceIPs":["10.129.2.6"],"userAgent":"Prometheus/2.23.0","responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2021-03-08T18:02:04.086545Z","stageTimestamp":"2021-03-08T18:02:04.107102Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC: allowed by ClusterRoleBinding \"prometheus-k8s\" of ClusterRole \"prometheus-k8s\" to ServiceAccount \"prometheus-k8s/openshift-monitoring\""}}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>View the Kubernetes API server audit logs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the Kubernetes API server audit logs that are available for each control plane node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs --role=master --path=kube-apiserver/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit-2021-03-09T14-07-27.129.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit-2021-03-09T19-24-22.620.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit-2021-03-09T18-37-07.511.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit.log</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a specific Kubernetes API server audit log by providing the node name and the log name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs &lt;node_name&gt; --path=kube-apiserver/&lt;log_name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs ci-ln-m0wpfjb-f76d1-vnb5x-master-0 --path=kube-apiserver/audit-2021-03-09T14-07-27.129.log</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"cfce8a0b-b5f5-4365-8c9f-79c1227d10f9","stage":"ResponseComplete","requestURI":"/api/v1/namespaces/openshift-kube-scheduler/serviceaccounts/openshift-kube-scheduler-sa","verb":"get","user":{"username":"system:serviceaccount:openshift-kube-scheduler-operator:openshift-kube-scheduler-operator","uid":"2574b041-f3c8-44e6-a057-baef7aa81516","groups":["system:serviceaccounts","system:serviceaccounts:openshift-kube-scheduler-operator","system:authenticated"]},"sourceIPs":["10.128.0.8"],"userAgent":"cluster-kube-scheduler-operator/v0.0.0 (linux/amd64) kubernetes/$Format","objectRef":{"resource":"serviceaccounts","namespace":"openshift-kube-scheduler","name":"openshift-kube-scheduler-sa","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2021-03-08T18:06:42.512619Z","stageTimestamp":"2021-03-08T18:06:42.516145Z","annotations":{"authentication.k8s.io/legacy-token":"system:serviceaccount:openshift-kube-scheduler-operator:openshift-kube-scheduler-operator","authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC: allowed by ClusterRoleBinding \"system:openshift:operator:cluster-kube-scheduler-operator\" of ClusterRole \"cluster-admin\" to ServiceAccount \"openshift-kube-scheduler-operator/openshift-kube-scheduler-operator\""}}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>View the OpenShift OAuth API server audit logs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the OpenShift OAuth API server audit logs that are available for each control plane node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs --role=master --path=oauth-apiserver/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit-2021-03-09T13-06-26.128.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit-2021-03-09T18-23-21.619.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit-2021-03-09T17-36-06.510.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit.log</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a specific OpenShift OAuth API server audit log by providing the node name and the log name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs &lt;node_name&gt; --path=oauth-apiserver/&lt;log_name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs ci-ln-m0wpfjb-f76d1-vnb5x-master-0 --path=oauth-apiserver/audit-2021-03-09T13-06-26.128.log</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"dd4c44e2-3ea1-4830-9ab7-c91a5f1388d6","stage":"ResponseComplete","requestURI":"/apis/user.openshift.io/v1/users/~","verb":"get","user":{"username":"system:serviceaccount:openshift-monitoring:prometheus-k8s","groups":["system:serviceaccounts","system:serviceaccounts:openshift-monitoring","system:authenticated"]},"sourceIPs":["10.0.32.4","10.128.0.1"],"userAgent":"dockerregistry/v0.0.0 (linux/amd64) kubernetes/$Format","objectRef":{"resource":"users","name":"~","apiGroup":"user.openshift.io","apiVersion":"v1"},"responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2021-03-08T17:47:43.653187Z","stageTimestamp":"2021-03-08T17:47:43.660187Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC: allowed by ClusterRoleBinding \"basic-users\" of ClusterRole \"basic-user\" to Group \"system:authenticated\""}}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>View the OpenShift OAuth server audit logs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the OpenShift OAuth server audit logs that are available for each control plane node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs --role=master --path=oauth-server/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit-2022-05-11T18-57-32.395.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-0 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit-2022-05-11T19-07-07.021.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-1 audit.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit-2022-05-11T19-06-51.844.log
ci-ln-m0wpfjb-f76d1-vnb5x-master-2 audit.log</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a specific OpenShift OAuth server audit log by providing the node name and the log name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs &lt;node_name&gt; --path=oauth-server/&lt;log_name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs ci-ln-m0wpfjb-f76d1-vnb5x-master-0 --path=oauth-server/audit-2022-05-11T18-57-32.395.log</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"13c20345-f33b-4b7d-b3b6-e7793f805621","stage":"ResponseComplete","requestURI":"/login","verb":"post","user":{"username":"system:anonymous","groups":["system:unauthenticated"]},"sourceIPs":["10.128.2.6"],"userAgent":"Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0","responseStatus":{"metadata":{},"code":302},"requestReceivedTimestamp":"2022-05-11T17:31:16.280155Z","stageTimestamp":"2022-05-11T17:31:16.297083Z","annotations":{"authentication.openshift.io/decision":"error","authentication.openshift.io/username":"kubeadmin","authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":""}}</programlisting>
</para>
</formalpara>
<simpara>The possible values for the <literal>authentication.openshift.io/decision</literal> annotation are <literal>allow</literal>, <literal>deny</literal>, or <literal>error</literal>.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-audit-log-basic-filtering_audit-log-view">
<title>Filtering audit logs</title>
<simpara>You can use <literal>jq</literal> or another JSON parsing tool to filter the API server audit logs.</simpara>
<note>
<simpara>The amount of information logged to the API server audit logs is controlled by the audit log policy that is set.</simpara>
</note>
<simpara>The following procedure provides examples of using <literal>jq</literal> to filter audit logs on control plane node <literal>node-1.example.com</literal>. See the <link xlink:href="https://stedolan.github.io/jq/manual/">jq Manual</link> for detailed information on using <literal>jq</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed <literal>jq</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Filter OpenShift API server audit logs by user:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs node-1.example.com  \
  --path=openshift-apiserver/audit.log \
  | jq 'select(.user.username == "myusername")'</programlisting>
</listitem>
<listitem>
<simpara>Filter OpenShift API server audit logs by user agent:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs node-1.example.com  \
  --path=openshift-apiserver/audit.log \
  | jq 'select(.userAgent == "cluster-version-operator/v0.0.0 (linux/amd64) kubernetes/$Format")'</programlisting>
</listitem>
<listitem>
<simpara>Filter Kubernetes API server audit logs by a certain API version and only output the user agent:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs node-1.example.com  \
  --path=kube-apiserver/audit.log \
  | jq 'select(.requestURI | startswith("/apis/apiextensions.k8s.io/v1beta1")) | .userAgent'</programlisting>
</listitem>
<listitem>
<simpara>Filter OpenShift OAuth API server audit logs by excluding a verb:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs node-1.example.com  \
  --path=oauth-apiserver/audit.log \
  | jq 'select(.verb != "get")'</programlisting>
</listitem>
<listitem>
<simpara>Filter OpenShift OAuth server audit logs by events that identified a username and failed with an error:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm node-logs node-1.example.com  \
  --path=oauth-server/audit.log \
  | jq 'select(.annotations["authentication.openshift.io/username"] != null and .annotations["authentication.openshift.io/decision"] == "error")'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="gathering-data-audit-logs_audit-log-view">
<title>Gathering audit logs</title>
<simpara>You can use the must-gather tool to collect the audit logs for debugging your cluster, which you can review or send to Red Hat Support.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the <literal>oc adm must-gather</literal> command with <literal>-- /usr/bin/gather_audit_logs</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather -- /usr/bin/gather_audit_logs</programlisting>
</listitem>
<listitem>
<simpara>Create a compressed file from the <literal>must-gather</literal> directory that was just created in your working directory. For example, on a computer that uses a Linux operating system, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar cvaf must-gather.tar.gz must-gather.local.472290403699006248 <co xml:id="CO80-1"/></programlisting>
<calloutlist>
<callout arearefs="CO80-1">
<para>Replace <literal>must-gather-local.472290403699006248</literal> with the actual directory name.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Attach the compressed file to your support case on the <link xlink:href="https://access.redhat.com/support/cases/#/case/list">the <emphasis role="strong">Customer Support</emphasis> page</link> of the Red Hat Customer Portal.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="viewing-audit-logs-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../support/gathering-cluster-data.xml#about-must-gather_gathering-cluster-data">Must-gather tool</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://github.com/kubernetes/apiserver/blob/master/pkg/apis/audit/v1/types.go#L72">API audit log event structure</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../security/audit-log-policy-config.xml#audit-log-policy-config">Configuring the audit log policy</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../logging/log_collection_forwarding/log-forwarding.xml#log-forwarding">About log forwarding</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="audit-log-policy-config">
<title>Configuring the audit log policy</title>

<simpara>You can control the amount of information that is logged to the API server audit logs by choosing the audit log policy profile to use.</simpara>
<section xml:id="about-audit-log-profiles_audit-log-policy-config">
<title>About audit log policy profiles</title>
<simpara>Audit log profiles define how to log requests that come to the OpenShift API server, Kubernetes API server, OpenShift OAuth API server, and OpenShift OAuth server.</simpara>
<simpara>OpenShift Container Platform provides the following predefined audit policy profiles:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Default</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs only metadata for read and write requests; does not log request bodies except for OAuth access token requests. This is the default policy.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>WriteRequestBodies</literal></simpara></entry>
<entry align="left" valign="top"><simpara>In addition to logging metadata for all requests, logs request bodies for every write request to the API servers (<literal>create</literal>, <literal>update</literal>, <literal>patch</literal>, <literal>delete</literal>, <literal>deletecollection</literal>). This profile has more resource overhead than the <literal>Default</literal> profile. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AllRequestBodies</literal></simpara></entry>
<entry align="left" valign="top"><simpara>In addition to logging metadata for all requests, logs request bodies for  every read and write request to the API servers (<literal>get</literal>, <literal>list</literal>, <literal>create</literal>, <literal>update</literal>, <literal>patch</literal>). This profile has the most resource overhead. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>None</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No requests are logged; even OAuth access token requests and OAuth authorize token requests are not logged. Custom rules are ignored when this profile is set.</simpara>
<warning>
<simpara>It is not recommended to disable audit logging by using the <literal>None</literal> profile unless you are fully aware of the risks of not logging data that can be beneficial when troubleshooting issues. If you disable audit logging and a support situation arises, you might need to enable audit logging and reproduce the issue in order to troubleshoot properly.</simpara>
</warning></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Sensitive resources, such as <literal>Secret</literal>, <literal>Route</literal>, and <literal>OAuthClient</literal> objects, are only ever logged at the metadata level. OpenShift OAuth server events are only ever logged at the metadata level.</simpara>
</listitem>
</orderedlist>
</para>
<simpara>By default, OpenShift Container Platform uses the <literal>Default</literal> audit log profile. You can use another audit policy profile that also logs request bodies, but be aware of the increased resource usage (CPU, memory, and I/O).</simpara>
</section>
<section xml:id="configuring-audit-policy_audit-log-policy-config">
<title>Configuring the audit log policy</title>
<simpara>You can configure the audit log policy to use when logging requests that come to the API servers.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>APIServer</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver cluster</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>spec.audit.profile</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
...
spec:
  audit:
    profile: WriteRequestBodies    <co xml:id="CO81-1"/></programlisting>
<calloutlist>
<callout arearefs="CO81-1">
<para>Set to <literal>Default</literal>, <literal>WriteRequestBodies</literal>, <literal>AllRequestBodies</literal>, or <literal>None</literal>. The default profile is <literal>Default</literal>.</para>
</callout>
</calloutlist>
<warning>
<simpara>It is not recommended to disable audit logging by using the <literal>None</literal> profile unless you are fully aware of the risks of not logging data that can be beneficial when troubleshooting issues. If you disable audit logging and a support situation arises, you might need to enable audit logging and reproduce the issue in order to troubleshoot properly.</simpara>
</warning>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that a new revision of the Kubernetes API server pods is rolled out. It can take several minutes for all nodes to update to the new revision.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="NodeInstallerProgressing")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>Review the <literal>NodeInstallerProgressing</literal> status condition for the Kubernetes API server to verify that all nodes are at the latest revision. The output shows <literal>AllNodesAtLatestRevision</literal> upon successful update:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">AllNodesAtLatestRevision
3 nodes are at revision 12 <co xml:id="CO82-1"/></programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>In this example, the latest revision number is <literal>12</literal>.</para>
</callout>
</calloutlist>
<simpara>If the output shows a message similar to one of the following messages, the update is still in progress. Wait a few minutes and try again.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>3 nodes are at revision 11; 0 nodes have achieved new revision 12</literal></simpara>
</listitem>
<listitem>
<simpara><literal>2 nodes are at revision 11; 1 nodes are at revision 12</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-audit-policy-custom_audit-log-policy-config">
<title>Configuring the audit log policy with custom rules</title>
<simpara>You can configure an audit log policy that defines custom rules. You can specify multiple groups and define which profile to use for that group.</simpara>
<simpara>These custom rules take precedence over the top-level profile field. The custom rules are evaluated from top to bottom, and the first that matches is applied.</simpara>
<important>
<simpara>Custom rules are ignored if the top-level profile field is set to <literal>None</literal>.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>APIServer</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>spec.audit.customRules</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
...
spec:
  audit:
    customRules:                        <co xml:id="CO83-1"/>
    - group: system:authenticated:oauth
      profile: WriteRequestBodies
    - group: system:authenticated
      profile: AllRequestBodies
    profile: Default                    <co xml:id="CO83-2"/></programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para>Add one or more groups and specify the profile to use for that group. These custom rules take precedence over the top-level profile field. The custom rules are evaluated from top to bottom, and the first that matches is applied.</para>
</callout>
<callout arearefs="CO83-2">
<para>Set to <literal>Default</literal>, <literal>WriteRequestBodies</literal>, or <literal>AllRequestBodies</literal>. If you do not set this top-level profile field, it defaults to the <literal>Default</literal> profile.</para>
</callout>
</calloutlist>
<warning>
<simpara>Do not set the top-level profile field to <literal>None</literal> if you want to use custom rules. Custom rules are ignored if the top-level profile field is set to <literal>None</literal>.</simpara>
</warning>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that a new revision of the Kubernetes API server pods is rolled out. It can take several minutes for all nodes to update to the new revision.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="NodeInstallerProgressing")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>Review the <literal>NodeInstallerProgressing</literal> status condition for the Kubernetes API server to verify that all nodes are at the latest revision. The output shows <literal>AllNodesAtLatestRevision</literal> upon successful update:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">AllNodesAtLatestRevision
3 nodes are at revision 12 <co xml:id="CO84-1"/></programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para>In this example, the latest revision number is <literal>12</literal>.</para>
</callout>
</calloutlist>
<simpara>If the output shows a message similar to one of the following messages, the update is still in progress. Wait a few minutes and try again.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>3 nodes are at revision 11; 0 nodes have achieved new revision 12</literal></simpara>
</listitem>
<listitem>
<simpara><literal>2 nodes are at revision 11; 1 nodes are at revision 12</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-audit-policy-disable_audit-log-policy-config">
<title>Disabling audit logging</title>
<simpara>You can disable audit logging for OpenShift Container Platform. When you disable audit logging, even OAuth access token requests and OAuth authorize token requests are not logged.</simpara>
<warning>
<simpara>It is not recommended to disable audit logging by using the <literal>None</literal> profile unless you are fully aware of the risks of not logging data that can be beneficial when troubleshooting issues. If you disable audit logging and a support situation arises, you might need to enable audit logging and reproduce the issue in order to troubleshoot properly.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>APIServer</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver cluster</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>spec.audit.profile</literal> field to <literal>None</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
...
spec:
  audit:
    profile: None</programlisting>
<note>
<simpara>You can also disable audit logging only for specific groups by specifying custom rules in the <literal>spec.audit.customRules</literal> field.</simpara>
</note>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that a new revision of the Kubernetes API server pods is rolled out. It can take several minutes for all nodes to update to the new revision.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="NodeInstallerProgressing")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>Review the <literal>NodeInstallerProgressing</literal> status condition for the Kubernetes API server to verify that all nodes are at the latest revision. The output shows <literal>AllNodesAtLatestRevision</literal> upon successful update:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">AllNodesAtLatestRevision
3 nodes are at revision 12 <co xml:id="CO85-1"/></programlisting>
<calloutlist>
<callout arearefs="CO85-1">
<para>In this example, the latest revision number is <literal>12</literal>.</para>
</callout>
</calloutlist>
<simpara>If the output shows a message similar to one of the following messages, the update is still in progress. Wait a few minutes and try again.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>3 nodes are at revision 11; 0 nodes have achieved new revision 12</literal></simpara>
</listitem>
<listitem>
<simpara><literal>2 nodes are at revision 11; 1 nodes are at revision 12</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="tls-security-profiles">
<title>Configuring TLS security profiles</title>

<simpara>TLS security profiles provide a way for servers to regulate which ciphers a client can use when connecting to the server. This ensures that OpenShift Container Platform components use cryptographic libraries that do not allow known insecure protocols, ciphers, or algorithms.</simpara>
<simpara>Cluster administrators can choose which TLS security profile to use for each of the following components:</simpara>
<itemizedlist>
<listitem>
<simpara>the Ingress Controller</simpara>
</listitem>
<listitem>
<simpara>the control plane</simpara>
<simpara>This includes the Kubernetes API server, Kubernetes controller manager, Kubernetes scheduler, OpenShift API server, OpenShift OAuth API server, OpenShift OAuth server, and etcd.</simpara>
</listitem>
<listitem>
<simpara>the kubelet, when it acts as an HTTP server for the Kubernetes API server</simpara>
</listitem>
</itemizedlist>
<section xml:id="tls-profiles-understanding_tls-security-profiles">
<title>Understanding TLS security profiles</title>
<simpara>You can use a TLS (Transport Layer Security) security profile to define which TLS ciphers are required by various OpenShift Container Platform components. The OpenShift Container Platform TLS security profiles are based on <link xlink:href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla recommended configurations</link>.</simpara>
<simpara>You can specify one of the following TLS security profiles for each component:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>TLS security profiles</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Old</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is intended for use with legacy clients or libraries. The profile is based on the <link xlink:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Old_backward_compatibility">Old backward compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Old</literal> profile requires a minimum TLS version of 1.0.</simpara>
<note>
<simpara>For the Ingress Controller, the minimum TLS version is converted from 1.0 to 1.1.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Intermediate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is the recommended configuration for the majority of clients. It is the  default TLS security profile for the Ingress Controller, kubelet, and control plane. The profile is based on the <link xlink:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29">Intermediate compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Intermediate</literal> profile requires a minimum TLS version of 1.2.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Modern</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is intended for use with modern clients that have no need for backwards compatibility. This profile is based on the <link xlink:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Modern compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Modern</literal> profile requires a minimum TLS version of 1.3.</simpara>
<note>
<simpara>In OpenShift Container Platform 4.6, 4.7, and 4.8, the <literal>Modern</literal> profile is unsupported. If selected, the <literal>Intermediate</literal> profile is enabled.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Custom</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile allows you to define the TLS version and ciphers to use.</simpara>
<warning>
<simpara>Use caution when using a <literal>Custom</literal> profile, because invalid configurations can cause problems.</simpara>
</warning></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>When using one of the predefined profile types, the effective profile configuration is subject to change between releases. For example, given a specification to use the Intermediate profile deployed on release X.Y.Z, an upgrade to release X.Y.Z+1 might cause a new profile configuration to be applied, resulting in a rollout.</simpara>
</note>
</section>
<section xml:id="tls-profiles-view-details_tls-security-profiles">
<title>Viewing TLS security profile details</title>
<simpara>You can view the minimum TLS version and ciphers for the predefined TLS security profiles for each of the following components: Ingress Controller, control plane, and kubelet.</simpara>
<important>
<simpara>The effective configuration of minimum TLS version and list of ciphers for a profile might differ between components.</simpara>
</important>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>View details for a specific TLS security profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain &lt;component&gt;.spec.tlsSecurityProfile.&lt;profile&gt; <co xml:id="CO86-1"/></programlisting>
<calloutlist>
<callout arearefs="CO86-1">
<para>For <literal>&lt;component&gt;</literal>, specify <literal>ingresscontroller</literal>, <literal>apiserver</literal>, or <literal>kubeletconfig</literal>. For <literal>&lt;profile&gt;</literal>, specify <literal>old</literal>, <literal>intermediate</literal>, or <literal>custom</literal>.</para>
</callout>
</calloutlist>
<simpara>For example, to check the ciphers included for the <literal>intermediate</literal> profile for the control plane:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain apiserver.spec.tlsSecurityProfile.intermediate</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">KIND:     APIServer
VERSION:  config.openshift.io/v1

DESCRIPTION:
    intermediate is a TLS security profile based on:
    https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29
    and looks like this (yaml):
    ciphers: - TLS_AES_128_GCM_SHA256 - TLS_AES_256_GCM_SHA384 -
    TLS_CHACHA20_POLY1305_SHA256 - ECDHE-ECDSA-AES128-GCM-SHA256 -
    ECDHE-RSA-AES128-GCM-SHA256 - ECDHE-ECDSA-AES256-GCM-SHA384 -
    ECDHE-RSA-AES256-GCM-SHA384 - ECDHE-ECDSA-CHACHA20-POLY1305 -
    ECDHE-RSA-CHACHA20-POLY1305 - DHE-RSA-AES128-GCM-SHA256 -
    DHE-RSA-AES256-GCM-SHA384 minTLSVersion: TLSv1.2</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View all details for the <literal>tlsSecurityProfile</literal> field of a component:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain &lt;component&gt;.spec.tlsSecurityProfile <co xml:id="CO87-1"/></programlisting>
<calloutlist>
<callout arearefs="CO87-1">
<para>For <literal>&lt;component&gt;</literal>, specify <literal>ingresscontroller</literal>, <literal>apiserver</literal>, or <literal>kubeletconfig</literal>.</para>
</callout>
</calloutlist>
<simpara>For example, to check all details for the <literal>tlsSecurityProfile</literal> field for the Ingress Controller:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc explain ingresscontroller.spec.tlsSecurityProfile</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">KIND:     IngressController
VERSION:  operator.openshift.io/v1

RESOURCE: tlsSecurityProfile &lt;Object&gt;

DESCRIPTION:
     ...

FIELDS:
   custom	&lt;&gt;
     custom is a user-defined TLS security profile. Be extremely careful using a
     custom profile as invalid configurations can be catastrophic. An example
     custom profile looks like this:
     ciphers: - ECDHE-ECDSA-CHACHA20-POLY1305 - ECDHE-RSA-CHACHA20-POLY1305 -
     ECDHE-RSA-AES128-GCM-SHA256 - ECDHE-ECDSA-AES128-GCM-SHA256 minTLSVersion:
     TLSv1.1

   intermediate	&lt;&gt;
     intermediate is a TLS security profile based on:
     https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29
     and looks like this (yaml):
     ... <co xml:id="CO88-1"/>

   modern	&lt;&gt;
     modern is a TLS security profile based on:
     https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility and
     looks like this (yaml):
     ... <co xml:id="CO88-2"/>
     NOTE: Currently unsupported.

   old	&lt;&gt;
     old is a TLS security profile based on:
     https://wiki.mozilla.org/Security/Server_Side_TLS#Old_backward_compatibility
     and looks like this (yaml):
     ... <co xml:id="CO88-3"/>

   type	&lt;string&gt;
     ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO88-1">
<para>Lists ciphers and minimum version for the <literal>intermediate</literal> profile here.</para>
</callout>
<callout arearefs="CO88-2">
<para>Lists ciphers and minimum version for the <literal>modern</literal> profile here.</para>
</callout>
<callout arearefs="CO88-3">
<para>Lists ciphers and minimum version for the <literal>old</literal> profile here.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="tls-profiles-ingress-configuring_tls-security-profiles">
<title>Configuring the TLS security profile for the Ingress Controller</title>
<simpara>To configure a TLS security profile for an Ingress Controller, edit the <literal>IngressController</literal> custom resource (CR) to specify a predefined or custom TLS security profile. If a TLS security profile is not configured, the default value is based on the TLS security profile set for the API server.</simpara>
<formalpara>
<title>Sample <literal>IngressController</literal> CR that configures the <literal>Old</literal> TLS security profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: IngressController
 ...
spec:
  tlsSecurityProfile:
    old: {}
    type: Old
 ...</programlisting>
</para>
</formalpara>
<simpara>The TLS security profile defines the minimum TLS version and the TLS ciphers for TLS connections for Ingress Controllers.</simpara>
<simpara>You can see the ciphers and the minimum TLS version of the configured TLS security profile in the <literal>IngressController</literal> custom resource (CR) under <literal>Status.Tls Profile</literal> and the configured TLS security profile under <literal>Spec.Tls Security Profile</literal>. For the <literal>Custom</literal> TLS security profile, the specific ciphers and minimum TLS version are listed under both parameters.</simpara>
<note>
<simpara>The HAProxy Ingress Controller image supports TLS <literal>1.3</literal> and the <literal>Modern</literal> profile.</simpara>
<simpara>The Ingress Operator also converts the TLS <literal>1.0</literal> of an <literal>Old</literal> or <literal>Custom</literal> profile to <literal>1.1</literal>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>IngressController</literal> CR in the <literal>openshift-ingress-operator</literal> project to configure the TLS security profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit IngressController default -n openshift-ingress-operator</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>spec.tlsSecurityProfile</literal> field:</simpara>
<formalpara>
<title>Sample <literal>IngressController</literal> CR for a <literal>Custom</literal> profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: IngressController
 ...
spec:
  tlsSecurityProfile:
    type: Custom <co xml:id="CO89-1"/>
    custom: <co xml:id="CO89-2"/>
      ciphers: <co xml:id="CO89-3"/>
      - ECDHE-ECDSA-CHACHA20-POLY1305
      - ECDHE-RSA-CHACHA20-POLY1305
      - ECDHE-RSA-AES128-GCM-SHA256
      - ECDHE-ECDSA-AES128-GCM-SHA256
      minTLSVersion: VersionTLS11
 ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO89-1">
<para>Specify the TLS security profile type (<literal>Old</literal>, <literal>Intermediate</literal>, or <literal>Custom</literal>). The default is <literal>Intermediate</literal>.</para>
</callout>
<callout arearefs="CO89-2">
<para>Specify the appropriate field for the selected type:</para>
<itemizedlist>
<listitem>
<simpara><literal>old: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>intermediate: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>custom:</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO89-3">
<para>For the <literal>custom</literal> type, specify a list of TLS ciphers and minimum accepted TLS version.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the profile is set in the <literal>IngressController</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe IngressController default -n openshift-ingress-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         default
Namespace:    openshift-ingress-operator
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  operator.openshift.io/v1
Kind:         IngressController
 ...
Spec:
 ...
  Tls Security Profile:
    Custom:
      Ciphers:
        ECDHE-ECDSA-CHACHA20-POLY1305
        ECDHE-RSA-CHACHA20-POLY1305
        ECDHE-RSA-AES128-GCM-SHA256
        ECDHE-ECDSA-AES128-GCM-SHA256
      Min TLS Version:  VersionTLS11
    Type:               Custom
 ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="tls-profiles-kubernetes-configuring_tls-security-profiles">
<title>Configuring the TLS security profile for the control plane</title>
<simpara>To configure a TLS security profile for the control plane, edit the <literal>APIServer</literal> custom resource (CR) to specify a predefined or custom TLS security profile. Setting the TLS security profile in the <literal>APIServer</literal> CR propagates the setting to the following control plane components:</simpara>
<itemizedlist>
<listitem>
<simpara>Kubernetes API server</simpara>
</listitem>
<listitem>
<simpara>Kubernetes controller manager</simpara>
</listitem>
<listitem>
<simpara>Kubernetes scheduler</simpara>
</listitem>
<listitem>
<simpara>OpenShift API server</simpara>
</listitem>
<listitem>
<simpara>OpenShift OAuth API server</simpara>
</listitem>
<listitem>
<simpara>OpenShift OAuth server</simpara>
</listitem>
<listitem>
<simpara>etcd</simpara>
</listitem>
</itemizedlist>
<simpara>If a TLS security profile is not configured, the default TLS security profile is <literal>Intermediate</literal>.</simpara>
<note>
<simpara>The default TLS security profile for the Ingress Controller is based on the TLS security profile set for the API server.</simpara>
</note>
<formalpara>
<title>Sample <literal>APIServer</literal> CR that configures the <literal>Old</literal> TLS security profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
 ...
spec:
  tlsSecurityProfile:
    old: {}
    type: Old
 ...</programlisting>
</para>
</formalpara>
<simpara>The TLS security profile defines the minimum TLS version and the TLS ciphers required to communicate with the control plane components.</simpara>
<simpara>You can see the configured TLS security profile in the <literal>APIServer</literal> custom resource (CR) under <literal>Spec.Tls Security Profile</literal>. For the <literal>Custom</literal> TLS security profile, the specific ciphers and minimum TLS version are listed.</simpara>
<note>
<simpara>The control plane does not support TLS <literal>1.3</literal> as the minimum TLS version; the <literal>Modern</literal> profile is not supported because it requires TLS <literal>1.3</literal>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the default <literal>APIServer</literal> CR to configure the TLS security profile:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit APIServer cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>spec.tlsSecurityProfile</literal> field:</simpara>
<formalpara>
<title>Sample <literal>APIServer</literal> CR for a <literal>Custom</literal> profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
  name: cluster
spec:
  tlsSecurityProfile:
    type: Custom <co xml:id="CO90-1"/>
    custom: <co xml:id="CO90-2"/>
      ciphers: <co xml:id="CO90-3"/>
      - ECDHE-ECDSA-CHACHA20-POLY1305
      - ECDHE-RSA-CHACHA20-POLY1305
      - ECDHE-RSA-AES128-GCM-SHA256
      - ECDHE-ECDSA-AES128-GCM-SHA256
      minTLSVersion: VersionTLS11</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO90-1">
<para>Specify the TLS security profile type (<literal>Old</literal>, <literal>Intermediate</literal>, or <literal>Custom</literal>). The default is <literal>Intermediate</literal>.</para>
</callout>
<callout arearefs="CO90-2">
<para>Specify the appropriate field for the selected type:</para>
<itemizedlist>
<listitem>
<simpara><literal>old: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>intermediate: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>custom:</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO90-3">
<para>For the <literal>custom</literal> type, specify a list of TLS ciphers and minimum accepted TLS version.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the TLS security profile is set in the <literal>APIServer</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe apiserver cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         cluster
Namespace:
 ...
API Version:  config.openshift.io/v1
Kind:         APIServer
 ...
Spec:
  Audit:
    Profile:  Default
  Tls Security Profile:
    Custom:
      Ciphers:
        ECDHE-ECDSA-CHACHA20-POLY1305
        ECDHE-RSA-CHACHA20-POLY1305
        ECDHE-RSA-AES128-GCM-SHA256
        ECDHE-ECDSA-AES128-GCM-SHA256
      Min TLS Version:  VersionTLS11
    Type:               Custom
 ...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the TLS security profile is set in the <literal>etcd</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe etcd cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         cluster
Namespace:
 ...
API Version:  operator.openshift.io/v1
Kind:         Etcd
 ...
Spec:
  Log Level:         Normal
  Management State:  Managed
  Observed Config:
    Serving Info:
      Cipher Suites:
        TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
        TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
        TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
      Min TLS Version:           VersionTLS12
 ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="tls-profiles-kubelet-configuring_tls-security-profiles">
<title>Configuring the TLS security profile for the kubelet</title>
<simpara>To configure a TLS security profile for the kubelet when it is acting as an HTTP server, create a <literal>KubeletConfig</literal> custom resource (CR) to specify a predefined or custom TLS security profile for specific nodes. If a TLS security profile is not configured, the default TLS security profile is <literal>Intermediate</literal>.</simpara>
<simpara>The kubelet uses its HTTP/GRPC server to communicate with the Kubernetes API server, which sends commands to pods, gathers logs, and run exec commands on pods through the kubelet.</simpara>
<formalpara>
<title>Sample <literal>KubeletConfig</literal> CR that configures the <literal>Old</literal> TLS security profile on worker nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: KubeletConfig
 ...
spec:
  tlsSecurityProfile:
    old: {}
    type: Old
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: ""
#...</programlisting>
</para>
</formalpara>
<simpara>You can see the ciphers and the minimum TLS version of the configured TLS security profile in the <literal>kubelet.conf</literal> file on a configured node.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to OpenShift Container Platform as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>KubeletConfig</literal> CR to configure the TLS security profile:</simpara>
<formalpara>
<title>Sample <literal>KubeletConfig</literal> CR for a <literal>Custom</literal> profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: set-kubelet-tls-security-profile
spec:
  tlsSecurityProfile:
    type: Custom <co xml:id="CO91-1"/>
    custom: <co xml:id="CO91-2"/>
      ciphers: <co xml:id="CO91-3"/>
      - ECDHE-ECDSA-CHACHA20-POLY1305
      - ECDHE-RSA-CHACHA20-POLY1305
      - ECDHE-RSA-AES128-GCM-SHA256
      - ECDHE-ECDSA-AES128-GCM-SHA256
      minTLSVersion: VersionTLS11
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO91-4"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO91-1">
<para>Specify the TLS security profile type (<literal>Old</literal>, <literal>Intermediate</literal>, or <literal>Custom</literal>). The default is <literal>Intermediate</literal>.</para>
</callout>
<callout arearefs="CO91-2">
<para>Specify the appropriate field for the selected type:</para>
<itemizedlist>
<listitem>
<simpara><literal>old: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>intermediate: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>custom:</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO91-3">
<para>For the <literal>custom</literal> type, specify a list of TLS ciphers and minimum accepted TLS version.</para>
</callout>
<callout arearefs="CO91-4">
<para>Optional: Specify the machine config pool label for the nodes you want to apply the TLS security profile.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>KubeletConfig</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;</programlisting>
<simpara>Depending on the number of worker nodes in the cluster, wait for the configured nodes to be rebooted one by one.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the profile is set,  perform the following steps after the nodes are in the <literal>Ready</literal> state:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start a debug session for a configured node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>kubelet.conf</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# cat /etc/kubernetes/kubelet.conf</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  "kind": "KubeletConfiguration",
  "apiVersion": "kubelet.config.k8s.io/v1beta1",
#...
  "tlsCipherSuites": [
    "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
  ],
  "tlsMinVersion": "VersionTLS12",
#...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="seccomp-profiles">
<title>Configuring seccomp profiles</title>

<simpara>An OpenShift Container Platform container or a pod runs a single application that performs one or more well-defined tasks. The application usually requires only a small subset of the underlying operating system kernel APIs.
Secure computing mode, seccomp, is a  Linux kernel feature that can be used to limit the process running in a container to only using a subset of the available system calls.</simpara>
<simpara>The <literal>restricted-v2</literal> SCC applies to all newly created pods in 4.14. The default seccomp profile <literal>runtime/default</literal> is applied to these pods.</simpara>
<simpara>Seccomp profiles are stored as JSON files on the disk.</simpara>
<important>
<simpara>Seccomp profiles cannot be applied to privileged containers.</simpara>
</important>
<section xml:id="verifying-default-seccomp-profile_configuring-seccomp-profiles">
<title>Verifying the default seccomp profile applied to a pod</title>
<simpara>OpenShift Container Platform ships with a default seccomp profile that is referenced as <literal>runtime/default</literal>. In 4.14, newly created pods have the Security Context Constraint (SCC) set to <literal>restricted-v2</literal> and the default seccomp profile applies to the pod.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>You can verify the Security Context Constraint (SCC) and the default seccomp profile set on a pod by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Verify what pods are running in the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;namespace&gt;</programlisting>
<simpara>For example, to verify what pods are running in the <literal>workshop</literal> namespace run the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n workshop</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                READY   STATUS      RESTARTS   AGE
parksmap-1-4xkwf    1/1     Running     0          2m17s
parksmap-1-deploy   0/1     Completed   0          2m22s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Inspect the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod parksmap-1-4xkwf -n workshop -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  annotations:
    k8s.v1.cni.cncf.io/network-status: |-
      [{
          "name": "openshift-sdn",
          "interface": "eth0",
          "ips": [
              "10.131.0.18"
          ],
          "default": true,
          "dns": {}
      }]
    k8s.v1.cni.cncf.io/network-status: |-
      [{
          "name": "openshift-sdn",
          "interface": "eth0",
          "ips": [
              "10.131.0.18"
          ],
          "default": true,
          "dns": {}
      }]
    openshift.io/deployment-config.latest-version: "1"
    openshift.io/deployment-config.name: parksmap
    openshift.io/deployment.name: parksmap-1
    openshift.io/generated-by: OpenShiftWebConsole
    openshift.io/scc: restricted-v2 <co xml:id="CO92-1"/>
    seccomp.security.alpha.kubernetes.io/pod: runtime/default <co xml:id="CO92-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO92-1">
<para>The <literal>restricted-v2</literal> SCC is added by default if your workload does not have access to a different SCC.</para>
</callout>
<callout arearefs="CO92-2">
<para>Newly created pods in 4.14 will have the seccomp profile configured to <literal>runtime/default</literal> as mandated by the SCC.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<section xml:id="upgraded_cluster_configuring-seccomp-profiles">
<title>Upgraded cluster</title>
<simpara>In clusters upgraded to 4.14 all authenticated users have access to the <literal>restricted</literal> and <literal>restricted-v2</literal> SCC.</simpara>
<simpara>A workload admitted by the SCC <literal>restricted</literal> for example, on a OpenShift Container Platform v4.10 cluster when upgraded may get admitted by <literal>restricted-v2</literal>. This is because <literal>restricted-v2</literal> is the more restrictive SCC between <literal>restricted</literal> and <literal>restricted-v2</literal>.</simpara>
<note>
<simpara>The workload must be able to run with <literal>retricted-v2</literal>.</simpara>
</note>
<simpara>Conversely with a workload that requires <literal>privilegeEscalation: true</literal> this workload will continue to have the <literal>restricted</literal> SCC available for any authenticated user. This is because <literal>restricted-v2</literal> does not allow <literal>privilegeEscalation</literal>.</simpara>
</section>
<section xml:id="newly_installed_configuring-seccomp-profiles">
<title>Newly installed cluster</title>
<simpara>For newly installed OpenShift Container Platform 4.11 or later clusters, the <literal>restricted-v2</literal> replaces the <literal>restricted</literal> SCC as an SCC that is available to be used by any authenticated user. A workload with <literal>privilegeEscalation: true</literal>, is not admitted into the cluster since <literal>restricted-v2</literal> is the only SCC available for authenticated users by default.</simpara>
<simpara>The feature <literal>privilegeEscalation</literal> is allowed by <literal>restricted</literal> but not by <literal>restricted-v2</literal>. More features are denied by <literal>restricted-v2</literal> than were allowed by <literal>restricted</literal> SCC.</simpara>
<simpara>A workload with <literal>privilegeEscalation: true</literal> may be admitted into a newly installed OpenShift Container Platform 4.11 or later cluster. To give access to the <literal>restricted</literal> SCC to the ServiceAccount running the workload (or any other SCC that can admit this workload) using a RoleBinding run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n &lt;workload-namespace&gt; adm policy add-scc-to-user &lt;scc-name&gt; -z &lt;serviceaccount_name&gt;</programlisting>
<simpara>In OpenShift Container Platform 4.14 the ability to add the pod annotations <literal>seccomp.security.alpha.kubernetes.io/pod: runtime/default</literal> and <literal>container.seccomp.security.alpha.kubernetes.io/&lt;container_name&gt;: runtime/default</literal> is deprecated.</simpara>
</section>
</section>
<section xml:id="custom-seccomp-profile">
<title>Configuring a custom seccomp profile</title>
<simpara>You can configure a custom seccomp profile, which allows you to update the filters based on the application requirements. This allows cluster administrators to have greater control over the security of workloads running in OpenShift Container Platform.</simpara>
<simpara>Seccomp security profiles list the system calls (syscalls) a process can make. Permissions are broader than SELinux, which restrict operations, such as <literal>write</literal>, system-wide.</simpara>
<section xml:id="creating-custom-seccomp-profile_configuring-seccomp-profiles">
<title>Creating seccomp profiles</title>
<simpara>You can use the <literal>MachineConfig</literal> object to create profiles.</simpara>
<simpara>Seccomp can restrict system calls (syscalls) within a container, limiting the access of your application.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have cluster admin permissions.</simpara>
</listitem>
<listitem>
<simpara>You have created a custom security context constraints (SCC). For more information, see <emphasis>Additional resources</emphasis>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>MachineConfig</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: custom-seccomp
spec:
  config:
    ignition:
      version: 3.2.0
    storage:
      files:
      - contents:
          source: data:text/plain;charset=utf-8;base64,&lt;hash&gt;
        filesystem: root
        mode: 0644
        path: /var/lib/kubelet/seccomp/seccomp-nostat.json</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="setting-custom-seccomp-profile_configuring-seccomp-profiles">
<title>Setting up the custom seccomp profile</title>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>You have cluster administrator permissions.</simpara>
</listitem>
<listitem>
<simpara>You have created a custom security context constraints (SCC). For more information, see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>You have created a custom seccomp profile.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Upload your custom seccomp profile to <literal>/var/lib/kubelet/seccomp/&lt;custom-name&gt;.json</literal> by using the Machine Config. See "Additional resources" for detailed steps.</simpara>
</listitem>
<listitem>
<simpara>Update the custom SCC by providing reference to the created custom seccomp profile:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">seccompProfiles:
- localhost/&lt;custom-name&gt;.json <co xml:id="CO93-1"/></programlisting>
<calloutlist>
<callout arearefs="CO93-1">
<para>Provide the name of your custom seccomp profile.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="applying-custom-seccomp-profile_configuring-seccomp-profiles">
<title>Applying the custom seccomp profile to the workload</title>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>The cluster administrator has set up the custom seccomp profile. For more details, see "Setting up the custom seccomp profile".</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Apply the seccomp profile to the workload by setting the <literal>securityContext.seccompProfile.type</literal> field as following:</simpara>
<formalpara>
<title>Example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  securityContext:
    seccompProfile:
      type: Localhost
      localhostProfile: &lt;custom-name&gt;.json <co xml:id="CO94-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO94-1">
<para>Provide the name of your custom seccomp profile.</para>
</callout>
</calloutlist>
<simpara>Alternatively, you can use the pod annotations <literal>seccomp.security.alpha.kubernetes.io/pod: localhost/&lt;custom-name&gt;.json</literal>. However, this method is deprecated in OpenShift Container Platform 4.14.</simpara>
</listitem>
</itemizedlist>
<simpara>During deployment, the admission controller validates the following:</simpara>
<itemizedlist>
<listitem>
<simpara>The annotations against the current SCCs allowed by the user role.</simpara>
</listitem>
<listitem>
<simpara>The SCC, which includes the seccomp profile, is allowed for the pod.</simpara>
</listitem>
</itemizedlist>
<simpara>If the SCC is allowed for the pod, the kubelet runs the pod with the specified seccomp profile.</simpara>
<important>
<simpara>Ensure that the seccomp profile is deployed to all worker nodes.</simpara>
</important>
<note>
<simpara>The custom SCC must have the appropriate priority to be automatically assigned to the pod or meet other conditions required by the pod, such as allowing CAP_NET_ADMIN.</simpara>
</note>
</section>
</section>
<section xml:id="additional-resources_configuring-seccomp-profiles" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../authentication/managing-security-context-constraints.xml">Managing security context constraints</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../post_installation_configuration/machine-configuration-tasks.xml">Postinstallation machine configuration tasks</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="allowing-javascript-based-access-api-server">
<title>Allowing JavaScript-based access to the API server from additional hosts</title>

<section xml:id="auth-allowing-javascript-access-api-server_auth-allowed-origins">
<title>Allowing JavaScript-based access to the API server from additional hosts</title>
<simpara>The default OpenShift Container Platform configuration only allows the web console to send requests to the API server.</simpara>
<simpara>If you need to access the API server or OAuth server from a JavaScript
application using a different hostname, you can configure additional hostnames
to allow.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>APIServer</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver.config.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>additionalCORSAllowedOrigins</literal> field under the <literal>spec</literal> section and
specify one or more additional hostnames:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: APIServer
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-07-11T17:35:37Z"
  generation: 1
  name: cluster
  resourceVersion: "907"
  selfLink: /apis/config.openshift.io/v1/apiservers/cluster
  uid: 4b45a8dd-a402-11e9-91ec-0219944e0696
spec:
  additionalCORSAllowedOrigins:
  - (?i)//my\.subdomain\.domain\.com(:|\z) <co xml:id="CO95-1"/></programlisting>
<calloutlist>
<callout arearefs="CO95-1">
<para>The hostname is specified as a <link xlink:href="https://github.com/google/re2/wiki/Syntax">Golang regular expression</link> that matches
against CORS headers from HTTP requests against the API server and OAuth server.</para>
</callout>
</calloutlist>
<note>
<simpara>This example uses the following syntax:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>(?i)</literal> makes it case-insensitive.</simpara>
</listitem>
<listitem>
<simpara>The <literal>//</literal> pins to the beginning of the domain and matches the double slash
following <literal>http:</literal> or <literal>https:</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>\.</literal> escapes dots in the domain name.</simpara>
</listitem>
<listitem>
<simpara>The <literal>(:|\z)</literal> matches the end of the domain name <literal>(\z)</literal> or a port separator
<literal>(:)</literal>.</simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="encrypting-etcd">
<title>Encrypting etcd data</title>

<section xml:id="about-etcd_encrypting-etcd">
<title>About etcd encryption</title>
<simpara>By default, etcd data is not encrypted in OpenShift Container Platform. You can enable etcd encryption for your cluster to provide an additional layer of data security. For example, it can help protect the loss of sensitive data if an etcd backup is exposed to the incorrect parties.</simpara>
<simpara>When you enable etcd encryption, the following OpenShift API server and Kubernetes API server resources are encrypted:</simpara>
<itemizedlist>
<listitem>
<simpara>Secrets</simpara>
</listitem>
<listitem>
<simpara>Config maps</simpara>
</listitem>
<listitem>
<simpara>Routes</simpara>
</listitem>
<listitem>
<simpara>OAuth access tokens</simpara>
</listitem>
<listitem>
<simpara>OAuth authorize tokens</simpara>
</listitem>
</itemizedlist>
<simpara>When you enable etcd encryption, encryption keys are created. You must have these keys to restore from an etcd backup.</simpara>
<note>
<simpara>Etcd encryption only encrypts values, not keys. Resource types, namespaces, and object names are unencrypted.</simpara>
<simpara>If etcd encryption is enabled during a backup, the <literal><emphasis>static_kuberesources_&lt;datetimestamp&gt;.tar.gz</emphasis></literal> file contains the encryption keys for the etcd snapshot. For security reasons, store this file separately from the etcd snapshot. However, this file is required to restore a previous state of etcd from the respective etcd snapshot.</simpara>
</note>
</section>
<section xml:id="etcd-encryption-types_encrypting-etcd">
<title>Supported encryption types</title>
<simpara>The following encryption types are supported for encrypting etcd data in OpenShift Container Platform:</simpara>
<variablelist>
<varlistentry>
<term>AES-CBC</term>
<listitem>
<simpara>Uses AES-CBC with PKCS#7 padding and a 32 byte key to perform the encryption. The encryption keys are rotated weekly.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AES-GCM</term>
<listitem>
<simpara>Uses AES-GCM with a random nonce and a 32 byte key to perform the encryption. The encryption keys are rotated weekly.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="enabling-etcd-encryption_encrypting-etcd">
<title>Enabling etcd encryption</title>
<simpara>You can enable etcd encryption to encrypt sensitive resources in your cluster.</simpara>
<warning>
<simpara>Do not back up etcd resources until the initial encryption process is completed. If the encryption process is not completed, the backup might be only partially encrypted.</simpara>
<simpara>After you enable etcd encryption, several changes can occur:</simpara>
<itemizedlist>
<listitem>
<simpara>The etcd encryption might affect the memory consumption of a few resources.</simpara>
</listitem>
<listitem>
<simpara>You might notice a transient affect on backup performance because the leader must serve the backup.</simpara>
</listitem>
<listitem>
<simpara>A disk I/O can affect the node that receives the backup state.</simpara>
</listitem>
</itemizedlist>
</warning>
<simpara>You can encrypt the etcd database in either AES-GCM or AES-CBC encryption.</simpara>
<note>
<simpara>To migrate your etcd database from one encryption type to the other, you can modify the API server&#8217;s <literal>spec.encryption.type</literal> field. Migration of the etcd data to the new encryption type occurs automatically.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Modify the <literal>APIServer</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>spec.encryption.type</literal> field to <literal>aesgcm</literal> or <literal>aescbc</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  encryption:
    type: aesgcm <co xml:id="CO96-1"/></programlisting>
<calloutlist>
<callout arearefs="CO96-1">
<para>Set to <literal>aesgcm</literal> for AES-GCM encryption or <literal>aescbc</literal> for AES-CBC encryption.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
<simpara>The encryption process starts. It can take 20 minutes or longer for this process to complete, depending on the size of the etcd database.</simpara>
</listitem>
<listitem>
<simpara>Verify that etcd encryption was successful.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the OpenShift API server to verify that its resources were successfully encrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get openshiftapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>EncryptionCompleted</literal> upon successful encryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">EncryptionCompleted
All resources encrypted: routes.route.openshift.io</programlisting>
<simpara>If the output shows <literal>EncryptionInProgress</literal>, encryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the Kubernetes API server to verify that its resources were successfully encrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>EncryptionCompleted</literal> upon successful encryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">EncryptionCompleted
All resources encrypted: secrets, configmaps</programlisting>
<simpara>If the output shows <literal>EncryptionInProgress</literal>, encryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the OpenShift OAuth API server to verify that its resources were successfully encrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get authentication.operator.openshift.io -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>EncryptionCompleted</literal> upon successful encryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">EncryptionCompleted
All resources encrypted: oauthaccesstokens.oauth.openshift.io, oauthauthorizetokens.oauth.openshift.io</programlisting>
<simpara>If the output shows <literal>EncryptionInProgress</literal>, encryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="disabling-etcd-encryption_encrypting-etcd">
<title>Disabling etcd encryption</title>
<simpara>You can disable encryption of etcd data in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Modify the <literal>APIServer</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit apiserver</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>encryption</literal> field type to <literal>identity</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  encryption:
    type: identity <co xml:id="CO97-1"/></programlisting>
<calloutlist>
<callout arearefs="CO97-1">
<para>The <literal>identity</literal> type is the default value and means that no encryption is performed.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
<simpara>The decryption process starts. It can take 20 minutes or longer for this process to complete, depending on the size of your cluster.</simpara>
</listitem>
<listitem>
<simpara>Verify that etcd decryption was successful.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the OpenShift API server to verify that its resources were successfully decrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get openshiftapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>DecryptionCompleted</literal> upon successful decryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">DecryptionCompleted
Encryption mode set to identity and everything is decrypted</programlisting>
<simpara>If the output shows <literal>DecryptionInProgress</literal>, decryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the Kubernetes API server to verify that its resources were successfully decrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>DecryptionCompleted</literal> upon successful decryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">DecryptionCompleted
Encryption mode set to identity and everything is decrypted</programlisting>
<simpara>If the output shows <literal>DecryptionInProgress</literal>, decryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
<listitem>
<simpara>Review the <literal>Encrypted</literal> status condition for the OpenShift OAuth API server to verify that its resources were successfully decrypted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get authentication.operator.openshift.io -o=jsonpath='{range .items[0].status.conditions[?(@.type=="Encrypted")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>The output shows <literal>DecryptionCompleted</literal> upon successful decryption:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">DecryptionCompleted
Encryption mode set to identity and everything is decrypted</programlisting>
<simpara>If the output shows <literal>DecryptionInProgress</literal>, decryption is still in progress. Wait a few minutes and try again.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="pod-vulnerability-scan">
<title>Scanning pods for vulnerabilities</title>

<simpara>Using the Red Hat Quay Container Security Operator, you can access vulnerability
scan results from the OpenShift Container Platform web console for container images
used in active pods on the cluster. The Red Hat Quay Container Security Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Watches containers associated with pods on all or specified namespaces</simpara>
</listitem>
<listitem>
<simpara>Queries the container registry where the containers came from for
vulnerability information, provided an image&#8217;s registry is running image
scanning (such as
<link xlink:href="https://quay.io">Quay.io</link> or a
<link xlink:href="https://access.redhat.com/products/red-hat-quay">Red Hat Quay</link> registry with Clair scanning)</simpara>
</listitem>
<listitem>
<simpara>Exposes vulnerabilities via the <literal>ImageManifestVuln</literal> object in the Kubernetes API</simpara>
</listitem>
</itemizedlist>
<simpara>Using the instructions here, the Red Hat Quay Container Security Operator is installed in the <literal>openshift-operators</literal>
namespace, so it is available to all namespaces on your OpenShift Container Platform cluster.</simpara>
<section xml:id="security-pod-scan-cso_pod-vulnerability-scan">
<title>Installing the Red Hat Quay Container Security Operator</title>
<simpara>You can install the Red Hat Quay Container Security Operator from the OpenShift Container Platform web console Operator Hub, or by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the <literal>oc</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>You have administrator privileges to the OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You have containers that come from a Red Hat Quay or Quay.io registry running on your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>You can install the Red Hat Quay Container Security Operator by using the OpenShift Container Platform web console:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the web console, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> and select <emphasis role="strong">Security</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Red Hat Quay Container Security Operator</emphasis> Operator, and then select <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Red Hat Quay Container Security Operator</emphasis> page, select <emphasis role="strong">Install</emphasis>. <emphasis role="strong">Update channel</emphasis>, <emphasis role="strong">Installation mode</emphasis>, and <emphasis role="strong">Update approval</emphasis> are selected automatically. The <emphasis role="strong">Installed Namespace</emphasis> field defaults to <literal>openshift-operators</literal>. You can adjust these settings as needed.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Install</emphasis>. The <emphasis role="strong">Red Hat Quay Container Security Operator</emphasis> appears after a few moments on the <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Optional: You can add custom certificates to the Red Hat Quay Container Security Operator. For example, create a certificate named <literal>quay.crt</literal> in the current directory. Then, run the following command to add the custom certificate to the Red Hat Quay Container Security Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic container-security-operator-extra-certs --from-file=quay.crt -n openshift-operators</programlisting>
</listitem>
<listitem>
<simpara>Optional: If you added a custom certificate, restart the Red Hat Quay Container Security Operator pod for the new certificates to take effect.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Alternatively, you can install the Red Hat Quay Container Security Operator by using the CLI:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Retrieve the latest version of the Container Security Operator and its channel by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests container-security-operator \
  -o jsonpath='{range .status.channels[*]}{@.currentCSV} {@.name}{"\n"}{end}' \
  | awk '{print "STARTING_CSV=" $1 " CHANNEL=" $2 }' \
  | sort -nr \
  | head -1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">STARTING_CSV=container-security-operator.v3.8.9 CHANNEL=stable-3.8</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Using the output from the previous command, create a <literal>Subscription</literal> custom resource for the Red Hat Quay Container Security Operator and save it as <literal>container-security-operator.yaml</literal>. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: container-security-operator
  namespace: openshift-operators
spec:
  channel: ${CHANNEL} <co xml:id="CO98-1"/>
  installPlanApproval: Automatic
  name: container-security-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  startingCSV: ${STARTING_CSV} <co xml:id="CO98-2"/></programlisting>
<calloutlist>
<callout arearefs="CO98-1">
<para>Specify the value you obtained in the previous step for the <literal>spec.channel</literal> parameter.</para>
</callout>
<callout arearefs="CO98-2">
<para>Specify the value you obtained in the previous step for the <literal>spec.startingCSV</literal> parameter.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enter the following command to apply the configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f container-security-operator.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">subscription.operators.coreos.com/container-security-operator created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="security-pod-scan-cso-using_pod-vulnerability-scan">
<title>Using the Red Hat Quay Container Security Operator</title>
<simpara>The following procedure shows you how to use the Red Hat Quay Container Security Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat Quay Container Security Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>On the OpenShift Container Platform web console, navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Overview</emphasis>. Under the <emphasis role="strong">Status</emphasis> section, <emphasis role="strong">Quay Image Security</emphasis> provides the number of vulnerabilities found.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Quay Image Security</emphasis> to reveal the <emphasis role="strong">Quay Image Security breakdown</emphasis>, which details the severity of the vulnerabilities, whether the vulnerabilities can be fixed, and the total number of vulnerabilities. For example:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/image_security.png"/>
</imageobject>
<textobject><phrase>Access image scanning data from OpenShift Container Platform dashboard</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>You can address detected vulnerabilities in one of two ways:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the link to the vulnerability. This takes you to the container registry that the container came from, where you can see information about the vulnerability. The following example shows detected vulnerabilities from a Quay.io registry:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/cso-registry-vulnerable.png"/>
</imageobject>
<textobject><phrase>The Red Hat Quay Container Security Operator points you to a registry containing the vulnerable image</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">namespace</emphasis> link. This takes you to the <emphasis role="strong">ImageManifestVuln</emphasis> page, where you can see the name of the selected image and all of the namespaces where that image is running. For example, the following image shows you that a particular vulnerable image is running in the <literal>quay-enterprise</literal> namespace:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="images/cso-namespace-vulnerable.png"/>
</imageobject>
<textobject><phrase>View namespaces a vulnerable image is running in</phrase></textobject>
</inlinemediaobject></simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After you have learned what images are vulnerable, how to fix those vulnerabilities, and the namespaces that the images are being run in, you can improve security by performing the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Alert anyone in your organization who is running the image and request that they correct the vulnerability.</simpara>
</listitem>
<listitem>
<simpara>Stop the images from running by deleting the deployment or other object that started the pod that the image is in.</simpara>
<note>
<simpara>If you delete the pod, it might take several minutes for the vulnerability information to reset on the dashboard.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="security-pod-scan-query-cli_pod-vulnerability-scan">
<title>Querying image vulnerabilities from the CLI</title>
<simpara>Using the <literal>oc</literal> command, you can display information about vulnerabilities detected by the Red Hat Quay Container Security Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Red Hat Quay Container Security Operator on your OpenShift Container Platform instance.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to query for detected container image vulnerabilities:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get vuln --all-namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE     NAME              AGE
default       sha256.ca90...    6m56s
skynet        sha256.ca90...    9m37s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To display details for a particular vulnerability, append the vulnerability name and its namespace to the <literal>oc describe</literal> command. The following example shows an active container whose image includes an RPM package with a vulnerability:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe vuln --namespace mynamespace sha256.ac50e3752...</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         sha256.ac50e3752...
Namespace:    quay-enterprise
...
Spec:
  Features:
    Name:            nss-util
    Namespace Name:  centos:7
    Version:         3.44.0-3.el7
    Versionformat:   rpm
    Vulnerabilities:
      Description: Network Security Services (NSS) is a set of libraries...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="_network_bound_disk_encryption_nbde">
<title>Network-Bound Disk Encryption (NBDE)</title>
<section xml:id="nbde-about-disk-encryption-technology">
<title>About disk encryption technology</title>

<simpara>Network-Bound Disk Encryption (NBDE) allows you to encrypt root volumes of hard drives on physical and virtual
machines without having to manually enter a password when restarting machines.</simpara>
<section xml:id="nbde-disk-encryption-technology-comparison_nbde-implementation">
<title>Disk encryption technology comparison</title>
<simpara>To understand the merits of Network-Bound Disk Encryption (NBDE) for securing data at rest on edge servers, compare key escrow and TPM disk encryption without Clevis to NBDE on systems running Red Hat Enterprise Linux (RHEL).</simpara>
<simpara>The following table presents some tradeoffs to consider around the threat model and the complexity of each encryption solution.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Scenario</entry>
<entry align="left" valign="top">Key escrow</entry>
<entry align="left" valign="top">TPM disk encryption (without Clevis)</entry>
<entry align="left" valign="top">NBDE</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Protects against single-disk theft</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Protects against entire-server theft</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Systems can reboot independently from the network</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>No periodic rekeying</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Key is never transmitted over a network</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Supported by OpenShift</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
<entry align="left" valign="top"><simpara>X</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="nbde-key-escrow_nbde-implementation">
<title>Key escrow</title>
<simpara>Key escrow is the traditional system for storing cryptographic keys. The key server on the network stores the encryption key for a node with an encrypted boot disk and returns it when queried. The complexities around key management, transport encryption, and authentication do not make this a reasonable choice for boot disk encryption.</simpara>
<simpara>Although available in Red Hat Enterprise Linux (RHEL), key escrow-based disk encryption setup and management is a manual process and not suited to OpenShift Container Platform automation operations, including automated addition of nodes, and currently not supported by OpenShift Container Platform.</simpara>
</section>
<section xml:id="nbde-tpm-encryption_nbde-implementation">
<title>TPM encryption</title>
<simpara>Trusted Platform Module (TPM) disk encryption is best suited for data centers or installations in remote protected locations. Full disk encryption utilities such as dm-crypt and BitLocker encrypt disks with a TPM bind key, and then store the TPM bind key in the TPM, which is attached to the motherboard of the node. The main benefit of this method is that there is no external dependency, and the node is able to decrypt its own disks at boot time without any external interaction.</simpara>
<simpara>TPM disk encryption protects against decryption of data if the disk is stolen from the node and analyzed externally. However, for insecure locations this may not be sufficient. For example, if an attacker steals the entire node, the attacker can intercept the data when powering on the node, because the node decrypts its own disks. This applies to nodes with physical TPM2 chips as well as virtual machines with Virtual Trusted Platform Module (VTPM) access.</simpara>
</section>
<section xml:id="nbde-network-bound-disk-encryption_nbde-implementation">
<title>Network-Bound Disk Encryption (NBDE)</title>
<simpara>Network-Bound Disk Encryption (NBDE) effectively ties the encryption key to an external server or set of servers in a secure and anonymous way across the network. This is not a key escrow, in that the nodes do not store the encryption key or transfer it over the network, but otherwise behaves in a similar fashion.</simpara>
<simpara>Clevis and Tang are generic client and server components that provide network-bound encryption. Red Hat Enterprise Linux CoreOS (RHCOS)
uses these components in conjunction with Linux Unified Key Setup-on-disk-format (LUKS) to encrypt and decrypt root and non-root storage volumes to accomplish
Network-Bound Disk Encryption.</simpara>
<simpara>When a node starts, it attempts to contact a predefined set of Tang servers by performing a cryptographic handshake. If it can reach the required number of Tang servers, the node can construct its disk decryption key and unlock the disks to continue booting. If the node cannot access a Tang server due to a network outage or server unavailability, the node cannot boot and continues retrying indefinitely until the Tang servers become available again. Because the key is effectively tied to the node’s presence in a network, an attacker attempting to gain access to the data at rest would need to obtain both the disks on the node, and  network access to the Tang server as well.</simpara>
<simpara>The following figure illustrates the deployment model for NBDE.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/179_OpenShift_NBDE_implementation_0821_1.png"/>
</imageobject>
<textobject><phrase>NBDE deployment model</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following figure illustrates NBDE behavior during a reboot.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/179_OpenShift_NBDE_implementation_0821_2.png"/>
</imageobject>
<textobject><phrase>NBDE reboot behavior</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="nbde-secret-sharing-encryption_nbde-implementation">
<title>Secret sharing encryption</title>
<simpara>Shamir’s secret sharing (sss) is a cryptographic algorithm to securely divide up, distribute, and re-assemble keys. Using this algorithm, OpenShift Container Platform can support more complicated mixtures of key protection.</simpara>
<simpara>When you configure a cluster node to use multiple Tang servers, OpenShift Container Platform uses sss to set up a decryption policy that will succeed if at least one of the specified servers is available. You can create layers for additional security. For example, you can define a policy where OpenShift Container Platform requires both the TPM and one of the given list of Tang servers to decrypt the disk.</simpara>
</section>
</section>
<section xml:id="nbde-using-tang-servers-for-disk-encryption_nbde-implementation">
<title>Tang server disk encryption</title>
<simpara>The following components and technologies implement Network-Bound Disk Encryption (NBDE).</simpara>
<figure xml:id="fig-NBDE-Clevis-Tang">
<title>NBDE scheme when using a LUKS1-encrypted volume. The luksmeta package is not used for LUKS2 volumes.</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/179_OpenShift_NBDE_implementation_0821_3.png" contentwidth="Clevis framework" contentdepth="Tang server"/>
</imageobject>
<textobject><phrase>Network-Bound Disk Encryption (NBDE)</phrase></textobject>
</mediaobject>
</figure>
<simpara><emphasis>Tang</emphasis> is a server for binding data to network presence. It makes a node containing the data available when the node is bound to a certain secure network. Tang is stateless and does not require Transport Layer Security (TLS) or authentication. Unlike escrow-based solutions, where the key server stores all encryption keys and has knowledge of every encryption key, Tang never interacts with any node keys, so it never gains any identifying information from the node.</simpara>
<simpara><emphasis>Clevis</emphasis> is a pluggable framework for automated decryption that provides automated unlocking of Linux Unified Key Setup-on-disk-format (LUKS) volumes. The Clevis package runs on the node and provides the client side of the feature.</simpara>
<simpara>A <emphasis>Clevis pin</emphasis> is a plugin into the Clevis framework. There are three pin types:</simpara>
<variablelist>
<varlistentry>
<term>TPM2</term>
<listitem>
<simpara>Binds the disk encryption to the TPM2.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Tang</term>
<listitem>
<simpara>Binds the disk encryption to a Tang server to enable NBDE.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Shamir’s secret sharing (sss)</term>
<listitem>
<simpara>Allows more complex combinations of other pins. It allows more nuanced policies such as the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Must be able to reach one of these three Tang servers</simpara>
</listitem>
<listitem>
<simpara>Must be able to reach three of these five Tang servers</simpara>
</listitem>
<listitem>
<simpara>Must be able to reach the TPM2 AND at least one of these three Tang servers</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nbde-locating-the-tang-servers_nbde-implementation">
<title>Tang server location planning</title>
<simpara>When planning your Tang server environment, consider the physical and network locations of the Tang servers.</simpara>
<variablelist>
<varlistentry>
<term>Physical location</term>
<listitem>
<simpara>The geographic location of the Tang servers is relatively unimportant, as long as they are suitably secured from unauthorized access or theft and offer the required availability and accessibility to run a critical service.</simpara>
<simpara>Nodes with Clevis clients do not require local Tang servers as long as the Tang servers are available at all times.  Disaster recovery requires both redundant power and redundant network connectivity to Tang servers regardless of their location.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Network location</term>
<listitem>
<simpara>Any node with network access to the Tang servers can decrypt their own disk partitions, or any other disks encrypted by the same Tang servers.</simpara>
<simpara>Select network locations for the Tang servers that ensure the presence or absence of network connectivity from a given host allows for permission to decrypt.  For example, firewall protections might be in place to prohibit access from any type of guest or public network, or any network jack located in an unsecured area of the building.</simpara>
<simpara>Additionally, maintain network segregation between production and development networks. This assists in defining appropriate network locations and adds an additional layer of security.</simpara>
<simpara>Do not deploy Tang servers on the same resource, for example, the same <literal>rolebindings.rbac.authorization.k8s.io</literal> cluster, that they are responsible for unlocking. However, a cluster of Tang servers and other security resources can be a useful configuration to enable support of multiple additional clusters and cluster resources.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nbde-deciding-the-number-of-tang-servers-to-use_nbde-implementation">
<title>Tang server sizing requirements</title>
<simpara>The requirements around availability, network, and physical location drive the decision of how many Tang servers to use, rather than any concern over server capacity.</simpara>
<simpara>Tang servers do not maintain the state of data encrypted using Tang resources. Tang servers are either fully independent or share only their key material, which enables them to scale well.</simpara>
<simpara>There are two ways Tang servers handle key material:</simpara>
<itemizedlist>
<listitem>
<simpara>Multiple Tang servers share key material:</simpara>
<itemizedlist>
<listitem>
<simpara>You must load balance Tang servers sharing keys behind the same URL. The configuration can be as simple as round-robin DNS, or you can use physical load balancers.</simpara>
</listitem>
<listitem>
<simpara>You can scale from a single Tang server to multiple Tang servers. Scaling Tang servers does not require rekeying or client reconfiguration on the node when the Tang servers share key material and the same URL.</simpara>
</listitem>
<listitem>
<simpara>Client node setup and key rotation only requires one Tang server.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Multiple Tang servers generate their own key material:</simpara>
<itemizedlist>
<listitem>
<simpara>You can configure multiple Tang servers at installation time.</simpara>
</listitem>
<listitem>
<simpara>You can scale an individual Tang server behind a load balancer.</simpara>
</listitem>
<listitem>
<simpara>All Tang servers must be available during client node setup or key rotation.</simpara>
</listitem>
<listitem>
<simpara>When a client node boots using the default configuration, the Clevis client contacts all Tang servers. Only <emphasis>n</emphasis> Tang servers must be online to proceed with decryption. The default value for <emphasis>n</emphasis> is 1.</simpara>
</listitem>
<listitem>
<simpara>Red Hat does not support postinstallation configuration that changes the behavior of the Tang servers.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-logging-considerations_nbde-implementation">
<title>Logging considerations</title>
<simpara>Centralized logging of Tang traffic is advantageous because it might allow you to detect such things as unexpected decryption requests. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>A node requesting decryption of a passphrase that does not correspond to its boot sequence</simpara>
</listitem>
<listitem>
<simpara>A node requesting decryption outside of a known maintenance activity, such as cycling keys</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nbde-tang-server-installation-considerations">
<title>Tang server installation considerations</title>

<simpara>Network-Bound Disk Encryption (NBDE) must be enabled when a cluster node is installed. However, you can change the disk encryption policy at any time after it was initialized at installation.</simpara>
<section xml:id="nbde-installation-scenarios_nbde-implementation">
<title>Installation scenarios</title>
<simpara>Consider the following recommendations when planning Tang server installations:</simpara>
<itemizedlist>
<listitem>
<simpara>Small environments can use a single set of key material, even when using multiple Tang servers:</simpara>
<itemizedlist>
<listitem>
<simpara>Key rotations are easier.</simpara>
</listitem>
<listitem>
<simpara>Tang servers can scale easily to permit high availability.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Large environments can benefit from multiple sets of key material:</simpara>
<itemizedlist>
<listitem>
<simpara>Physically diverse installations do not require the copying and synchronizing of key material between geographic regions.</simpara>
</listitem>
<listitem>
<simpara>Key rotations are more complex in large environments.</simpara>
</listitem>
<listitem>
<simpara>Node installation and rekeying require network connectivity to all Tang servers.</simpara>
</listitem>
<listitem>
<simpara>A small increase in network traffic can occur due to a booting node querying all Tang servers during decryption. Note that while only one Clevis client query must succeed, Clevis queries all Tang servers.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Further complexity:</simpara>
<itemizedlist>
<listitem>
<simpara>Additional manual reconfiguration can permit the Shamir’s secret sharing (sss) of <literal>any N of M servers online</literal> in order to decrypt the disk partition.  Decrypting disks in this scenario requires multiple sets of key material, and manual management of Tang servers and nodes with Clevis clients after the initial installation.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>High level recommendations:</simpara>
<itemizedlist>
<listitem>
<simpara>For a single RAN deployment, a limited set of Tang servers can run in the corresponding domain controller (DC).</simpara>
</listitem>
<listitem>
<simpara>For multiple RAN deployments, you must decide whether to run Tang servers in each corresponding DC or whether a global Tang environment better suits the other needs and requirements of the system.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-installing-a-tang-server_nbde-implementation">
<title>Installing a Tang server</title>
<simpara>To deploy one or more Tang servers, you can choose from the following options depending on your scenario:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xlink:href="../../security/nbde_tang_server_operator/nbde-tang-server-operator-configuring-managing.xml#deploying-nbde-tang-server_configuring-and-managing-nbde-tang-server-operator">Deploying a Tang server using the NBDE Tang Server Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#deploying-a-tang-server-with-selinux-in-enforcing-mode_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Deploying a Tang server with SELinux in enforcing mode on RHEL systems</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#configuring-automated-unlocking-using-a-tang-key-in-the-web-console_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Configuring a Tang server in the RHEL web console</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#proc_deploying-tang-as-a-container_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Deploying Tang as a container</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening#using-the-nbde_server-system-role-for-setting-up-multiple-tang-servers_configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption">Using the nbde_server System Role for setting up multiple Tang servers</link></simpara>
</listitem>
</orderedlist>
<section xml:id="nbde-compute-requirements_nbde-implementation">
<title>Compute requirements</title>
<simpara>The computational requirements for the Tang server are very low. Any typical server grade configuration that you would use to deploy a server into production can provision sufficient compute capacity.</simpara>
<simpara>High availability considerations are solely for availability and not additional compute power to satisfy client demands.</simpara>
</section>
<section xml:id="nbde-automatic-start-at-boot_nbde-implementation">
<title>Automatic start at boot</title>
<simpara>Due to the sensitive nature of the key material the Tang server uses, you should keep in mind that the overhead of manual intervention during the Tang server’s boot sequence can be beneficial.</simpara>
<simpara>By default, if a Tang server starts and does not have key material present in the expected local volume, it will create fresh material and serve it.  You can avoid this default behavior by either starting with pre-existing key material or aborting the startup and waiting for manual intervention.</simpara>
</section>
<section xml:id="nbde-http-versus-https_nbde-implementation">
<title>HTTP versus HTTPS</title>
<simpara>Traffic to the Tang server can be encrypted (HTTPS) or plaintext (HTTP). There are no significant security advantages of encrypting this traffic, and leaving it decrypted removes any complexity or failure conditions related to Transport Layer Security (TLS) certificate checking in the node running a Clevis client.</simpara>
<simpara>While it is possible to perform passive monitoring of unencrypted traffic between the node’s Clevis client and the Tang server, the ability to use this traffic to determine the key material is at best a future theoretical concern. Any such traffic analysis would require large quantities of captured data. Key rotation would immediately invalidate it. Finally, any threat actor able to perform passive monitoring has already obtained the necessary network access to perform manual connections to the Tang server and can perform the simpler manual decryption of captured Clevis headers.</simpara>
<simpara>However, because other network policies in place at the installation site might require traffic encryption regardless of application, consider leaving this decision to the cluster administrator.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/configuring-automated-unlocking-of-encrypted-volumes-using-policy-based-decryption_security-hardening">Configuring automated unlocking of encrypted volumes using policy-based decryption</link> in the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/security_hardening/index">RHEL 8 Security hardening</link> document</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://catalog.redhat.com/software/containers/detail/5fbc405674aa0cc23b445f8f?container-tabs=overview&amp;gti-tabs=registry-tokens">Official Tang server container</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/install_config/installing-customizing.xml#installation-special-config-storage_installing-customizing">Encrypting and mirroring disks during installation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="nbde-managing-encryption-keys">
<title>Tang server encryption key management</title>

<simpara>The cryptographic mechanism to recreate the encryption key is based on the <emphasis>blinded key</emphasis> stored on the node and the private key of the involved Tang servers. To protect against the possibility of an attacker who has obtained both the Tang server private key and the node’s encrypted disk, periodic rekeying is advisable.</simpara>
<simpara>You must perform the rekeying operation for every node before you can delete the old key from the Tang server. The following sections provide procedures for rekeying and deleting old keys.</simpara>
<section xml:id="nbde-backing-up-server-keys_nbde-implementation">
<title>Backing up keys for a Tang server</title>
<simpara>The Tang server uses <literal>/usr/libexec/tangd-keygen</literal> to generate new keys and stores them in the <literal>/var/db/tang</literal> directory by default. To recover the Tang server in the event of a failure, back up this directory. The keys are sensitive and because they are able to perform the boot disk decryption of all hosts that have used them, the keys must be protected accordingly.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Copy the backup key from the <literal>/var/db/tang</literal> directory to the temp directory from which you can restore the key.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-recovering-server-keys_nbde-implementation">
<title>Recovering keys for a Tang server</title>
<simpara>You can recover the keys for a Tang server by accessing the keys from a backup.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Restore the key from your backup folder to the <literal>/var/db/tang/</literal> directory.</simpara>
<simpara>When the Tang server starts up, it advertises and uses these restored keys.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-rekeying-tang-servers_nbde-implementation">
<title>Rekeying Tang servers</title>
<simpara>This procedure uses a set of three Tang servers, each with unique keys, as an example.</simpara>
<simpara>Using redundant Tang servers reduces the chances of nodes failing to boot automatically.</simpara>
<simpara>Rekeying a Tang server, and all associated NBDE-encrypted nodes, is a three-step procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A working Network-Bound Disk Encryption (NBDE) installation on one or more nodes.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Generate a new Tang server key.</simpara>
</listitem>
<listitem>
<simpara>Rekey all NBDE-encrypted nodes so they use the new key.</simpara>
</listitem>
<listitem>
<simpara>Delete the old Tang server key.</simpara>
<note>
<simpara>Deleting the old key before all NBDE-encrypted nodes have completed their rekeying causes those nodes to become overly dependent on any other configured Tang servers.</simpara>
</note>
</listitem>
</orderedlist>
<figure>
<title>Example workflow for rekeying a Tang server</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/179_OpenShift_NBDE_implementation_0821_4.png"/>
</imageobject>
<textobject><phrase>Rekeying a Tang server</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="nbde-generating-a-new-tang-server-key_nbde-implementation">
<title>Generating a new Tang server key</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A root shell on the Linux machine running the Tang server.</simpara>
</listitem>
<listitem>
<simpara>To facilitate verification of the Tang server key rotation, encrypt a small test file with the old key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># echo plaintext | clevis encrypt tang '{"url":"http://localhost:7500”}' -y &gt;/tmp/encrypted.oldkey</programlisting>
</listitem>
<listitem>
<simpara>Verify that the encryption succeeded and the file can be decrypted to produce the same string <literal>plaintext</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># clevis decrypt &lt;/tmp/encrypted.oldkey</programlisting>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Locate and access the directory that stores the Tang server key. This is usually the <literal>/var/db/tang</literal> directory. Check the currently advertised key thumbprint:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># tang-show-keys 7500</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">36AHjNH3NZDSnlONLz1-V4ie6t8</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Enter the Tang server key directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cd /var/db/tang/</programlisting>
</listitem>
<listitem>
<simpara>List the current Tang server keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># ls -A1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">36AHjNH3NZDSnlONLz1-V4ie6t8.jwk
gJZiNPMLRBnyo_ZKfK4_5SrnHYo.jwk</programlisting>
</para>
</formalpara>
<simpara>During normal Tang server operations, there are two <literal>.jwk</literal> files in this directory: one for signing and verification, and another for key derivation.</simpara>
</listitem>
<listitem>
<simpara>Disable advertisement of the old keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># for key in *.jwk; do \
  mv -- "$key" ".$key"; \
done</programlisting>
<simpara>New clients setting up Network-Bound Disk Encryption (NBDE) or requesting keys will no longer see the old keys. Existing clients can still access and use the old keys until they are deleted. The Tang server reads but does not advertise keys stored in UNIX hidden files, which start with the <literal>.</literal> character.</simpara>
</listitem>
<listitem>
<simpara>Generate a new key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># /usr/libexec/tangd-keygen /var/db/tang</programlisting>
</listitem>
<listitem>
<simpara>List the current Tang server keys to verify the old keys are no longer advertised, as they are now hidden files, and new keys are present:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># ls -A1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">.36AHjNH3NZDSnlONLz1-V4ie6t8.jwk
.gJZiNPMLRBnyo_ZKfK4_5SrnHYo.jwk
Bp8XjITceWSN_7XFfW7WfJDTomE.jwk
WOjQYkyK7DxY_T5pMncMO5w0f6E.jwk</programlisting>
</para>
</formalpara>
<simpara>Tang automatically advertises the new keys.</simpara>
<note>
<simpara>More recent Tang server installations include a helper <literal>/usr/libexec/tangd-rotate-keys</literal> directory that takes care of disabling advertisement and generating the new keys simultaneously.</simpara>
</note>
</listitem>
<listitem>
<simpara>If you are running multiple Tang servers behind a load balancer that share the same key material, ensure the changes made here are properly synchronized across the entire set of servers before proceeding.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the Tang server is advertising the new key, and not advertising the old key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># tang-show-keys 7500</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">WOjQYkyK7DxY_T5pMncMO5w0f6E</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the old key, while not advertised, is still available to decryption requests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># clevis decrypt &lt;/tmp/encrypted.oldkey</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nbde-rekeying-all-nbde-nodes_nbde-implementation">
<title>Rekeying all NBDE nodes</title>
<simpara>You can rekey all of the nodes on a remote cluster by using a <literal>DaemonSet</literal> object without incurring any downtime to the remote cluster.</simpara>
<note>
<simpara>If a node loses power during the rekeying, it is possible that it might become unbootable, and must be redeployed via
Red Hat Advanced Cluster Management (RHACM) or a GitOps pipeline.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><literal>cluster-admin</literal> access to all clusters with Network-Bound Disk Encryption (NBDE) nodes.</simpara>
</listitem>
<listitem>
<simpara>All Tang servers must be accessible to every NBDE node undergoing rekeying, even if the keys of a Tang server have not changed.</simpara>
</listitem>
<listitem>
<simpara>Obtain the Tang server URL and key thumbprint for every Tang server.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>DaemonSet</literal> object based on the following template. This template sets up three redundant Tang servers, but can be easily adapted to other situations. Change the Tang server URLs and thumbprints in the <literal>NEW_TANG_PIN</literal> environment to suit your environment:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: tang-rekey
  namespace: openshift-machine-config-operator
spec:
  selector:
    matchLabels:
      name: tang-rekey
  template:
    metadata:
      labels:
        name: tang-rekey
    spec:
      containers:
      - name: tang-rekey
        image: registry.access.redhat.com/ubi9/ubi-minimal:latest
        imagePullPolicy: IfNotPresent
        command:
        - "/sbin/chroot"
        - "/host"
        - "/bin/bash"
        - "-ec"
        args:
        - |
          rm -f /tmp/rekey-complete || true
          echo "Current tang pin:"
          clevis-luks-list -d $ROOT_DEV -s 1
          echo "Applying new tang pin: $NEW_TANG_PIN"
          clevis-luks-edit -f -d $ROOT_DEV -s 1 -c "$NEW_TANG_PIN"
          echo "Pin applied successfully"
          touch /tmp/rekey-complete
          sleep infinity
        readinessProbe:
          exec:
            command:
            - cat
            - /host/tmp/rekey-complete
          initialDelaySeconds: 30
          periodSeconds: 10
        env:
        - name: ROOT_DEV
          value: /dev/disk/by-partlabel/root
        - name: NEW_TANG_PIN
          value: &gt;-
            {"t":1,"pins":{"tang":[
              {"url":"http://tangserver01:7500","thp":"WOjQYkyK7DxY_T5pMncMO5w0f6E"},
              {"url":"http://tangserver02:7500","thp":"I5Ynh2JefoAO3tNH9TgI4obIaXI"},
              {"url":"http://tangserver03:7500","thp":"38qWZVeDKzCPG9pHLqKzs6k1ons"}
            ]}}
        volumeMounts:
        - name: hostroot
          mountPath: /host
        securityContext:
          privileged: true
      volumes:
      - name: hostroot
        hostPath:
          path: /
      nodeSelector:
        kubernetes.io/os: linux
      priorityClassName: system-node-critical
      restartPolicy: Always
      serviceAccount: machine-config-daemon
      serviceAccountName: machine-config-daemon</programlisting>
<simpara>In this case, even though you are rekeying <literal>tangserver01</literal>, you must specify not only the new thumbprint for <literal>tangserver01</literal>, but also the current thumbprints for all other Tang servers.  Failure to specify all thumbprints for a rekeying operation opens up the opportunity for a man-in-the-middle attack.</simpara>
</listitem>
<listitem>
<simpara>To distribute the daemon set to every cluster that must be rekeyed, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f tang-rekey.yaml</programlisting>
<simpara>However, to run at scale, wrap the daemon set in an ACM policy. This ACM configuration must contain one policy to deploy the daemon set,
a second policy to check that all the daemon set pods are READY, and a placement rule to apply it to the appropriate set of clusters.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>After validating that the daemon set has successfully rekeyed all servers, delete the daemon set. If you do not delete the daemon set, it must be deleted before the next rekeying operation.</simpara>
</note>
<formalpara>
<title>Verification</title>
<para>After you distribute the daemon set, monitor the daemon sets to ensure that the rekeying has completed successfully. The script in the example daemon set terminates with an error if the rekeying failed, and remains in the <literal>CURRENT</literal> state if successful. There is also a readiness probe that marks the pod as <literal>READY</literal> when the rekeying has completed successfully.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>This is an example of the output listing for the daemon set before the rekeying has completed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-machine-config-operator ds tang-rekey</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE
tang-rekey   1         1         0       1            0           kubernetes.io/os=linux   11s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>This is an example of the output listing for the daemon set after the rekeying has completed successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -n openshift-machine-config-operator ds tang-rekey</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE
tang-rekey   1         1         1       1            1           kubernetes.io/os=linux   13h</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>Rekeying usually takes a few minutes to complete.</simpara>
<note>
<simpara>If you use ACM policies to distribute the daemon sets to multiple clusters, you must include a compliance policy that checks every daemon set’s READY count is equal to the DESIRED count. In this way, compliance to such a policy demonstrates that all daemon set pods are READY and the rekeying has completed successfully. You could also use an ACM search to query all of the daemon sets' states.</simpara>
</note>
</section>
<section xml:id="nbde-troubleshooting-temporary-error-conditions_nbde-implementation">
<title>Troubleshooting temporary rekeying errors for Tang servers</title>
<simpara>To determine if the error condition from rekeying the Tang servers is temporary, perform the following procedure. Temporary error conditions might include:</simpara>
<itemizedlist>
<listitem>
<simpara>Temporary network outages</simpara>
</listitem>
<listitem>
<simpara>Tang server maintenance</simpara>
</listitem>
</itemizedlist>
<simpara>Generally, when these types of temporary error conditions occur, you can wait until the daemon set succeeds in resolving the error or you can delete the daemon set and not try again until the temporary error condition has been resolved.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Restart the pod that performs the rekeying operation using the normal Kubernetes pod restart policy.</simpara>
</listitem>
<listitem>
<simpara>If any of the associated Tang servers are unavailable, try rekeying until all the servers are back online.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nbde-troubleshooting-permanent-error-conditions_nbde-implementation">
<title>Troubleshooting permanent rekeying errors for Tang servers</title>
<simpara>If, after rekeying the Tang servers, the <literal>READY</literal> count does not equal the <literal>DESIRED</literal> count after an extended period of time, it might indicate a permanent failure condition. In this case, the following conditions might apply:</simpara>
<itemizedlist>
<listitem>
<simpara>A typographical error in the Tang server URL or thumbprint in the <literal>NEW_TANG_PIN</literal> definition.</simpara>
</listitem>
<listitem>
<simpara>The Tang server is decommissioned or the keys are permanently lost.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The commands shown in this procedure can be run on the Tang server or on any Linux system that has network
access to the Tang server.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Validate the Tang server configuration by performing a simple encrypt and decrypt operation on each Tang
server’s configuration as defined in the daemon set.</simpara>
<simpara>This is an example of an encryption and decryption attempt with a bad thumbprint:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo "okay" | clevis encrypt tang \
  '{"url":"http://tangserver02:7500","thp":"badthumbprint"}' | \
  clevis decrypt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Unable to fetch advertisement: 'http://tangserver02:7500/adv/badthumbprint'!</programlisting>
</para>
</formalpara>
<simpara>This is an example of an encryption and decryption attempt with a good thumbprint:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo "okay" | clevis encrypt tang \
  '{"url":"http://tangserver03:7500","thp":"goodthumbprint"}' | \
  clevis decrypt</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">okay</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After you identify the root cause, remedy the underlying situation:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the non-working daemon set.</simpara>
</listitem>
<listitem>
<simpara>Edit the daemon set definition to fix the underlying issue.  This might include any of the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Edit a Tang server entry to correct the URL and thumbprint.</simpara>
</listitem>
<listitem>
<simpara>Remove a Tang server that is no longer in service.</simpara>
</listitem>
<listitem>
<simpara>Add a new Tang server that is a replacement for a decommissioned server.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Distribute the updated daemon set again.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>When replacing, removing, or adding a Tang server from a configuration, the rekeying operation will succeed as long as at least one original server is still functional, including the server currently being rekeyed. If none of the original Tang servers are functional or can be recovered, recovery of the system is impossible and you must redeploy the affected nodes.</simpara>
</note>
<formalpara>
<title>Verification</title>
<para>Check the logs from each pod in the daemon set to determine whether the rekeying completed successfully. If the rekeying is not successful, the logs might indicate the failure condition.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Locate the name of the container that was created by the daemon set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -A | grep tang-rekey</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">openshift-machine-config-operator  tang-rekey-7ks6h  1/1  Running   20 (8m39s ago)  89m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Print the logs from the container. The following log is from a completed successful rekeying operation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs tang-rekey-7ks6h</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Current tang pin:
1: sss '{"t":1,"pins":{"tang":[{"url":"http://10.46.55.192:7500"},{"url":"http://10.46.55.192:7501"},{"url":"http://10.46.55.192:7502"}]}}'
Applying new tang pin: {"t":1,"pins":{"tang":[
  {"url":"http://tangserver01:7500","thp":"WOjQYkyK7DxY_T5pMncMO5w0f6E"},
  {"url":"http://tangserver02:7500","thp":"I5Ynh2JefoAO3tNH9TgI4obIaXI"},
  {"url":"http://tangserver03:7500","thp":"38qWZVeDKzCPG9pHLqKzs6k1ons"}
]}}
Updating binding...
Binding edited successfully
Pin applied successfully</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nbde-deleting-old-tang-server-keys_nbde-implementation">
<title>Deleting old Tang server keys</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A root shell on the Linux machine running the Tang server.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Locate and access the directory where the Tang server key is stored. This is usually the <literal>/var/db/tang</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># cd /var/db/tang/</programlisting>
</listitem>
<listitem>
<simpara>List the current Tang server keys, showing the advertised and unadvertised keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># ls -A1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">.36AHjNH3NZDSnlONLz1-V4ie6t8.jwk
.gJZiNPMLRBnyo_ZKfK4_5SrnHYo.jwk
Bp8XjITceWSN_7XFfW7WfJDTomE.jwk
WOjQYkyK7DxY_T5pMncMO5w0f6E.jwk</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the old keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># rm .*.jwk</programlisting>
</listitem>
<listitem>
<simpara>List the current Tang server keys to verify the unadvertised keys are no longer present:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># ls -A1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Bp8XjITceWSN_7XFfW7WfJDTomE.jwk
WOjQYkyK7DxY_T5pMncMO5w0f6E.jwk</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>At this point, the server still advertises the new keys, but an attempt to decrypt based on the old key will fail.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Query the Tang server for the current advertised key thumbprints:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># tang-show-keys 7500</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">WOjQYkyK7DxY_T5pMncMO5w0f6E</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Decrypt the test file created earlier to verify decryption against the old keys fails:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># clevis decrypt &lt;/tmp/encryptValidation</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error communicating with the server!</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>If you are running multiple Tang servers behind a load balancer that share the same key material, ensure the changes made are properly synchronized across the entire set of servers before proceeding.</simpara>
</section>
</section>
<section xml:id="nbde-disaster-recovery-considerations">
<title>Disaster recovery considerations</title>

<simpara>This section describes several potential disaster situations and the procedures to respond to each of them. Additional situations will be added here as they are discovered or presumed likely to be possible.</simpara>
<section xml:id="nbde-loss-of-a-client-machine_nbde-implementation">
<title>Loss of a client machine</title>
<simpara>The loss of a cluster node that uses the Tang server to decrypt its disk partition is <emphasis>not</emphasis> a disaster. Whether the machine was stolen, suffered hardware failure, or another loss scenario is not important: the disks are encrypted and considered unrecoverable.</simpara>
<simpara>However, in the event of theft, a precautionary rotation of the Tang server’s keys and rekeying of all remaining nodes would be prudent to ensure the disks remain unrecoverable even in the event the thieves subsequently gain access to the Tang servers.</simpara>
<simpara>To recover from this situation, either reinstall or replace the node.</simpara>
</section>
<section xml:id="nbde-loss-of-client-connectivity_nbde-implementation">
<title>Planning for a loss of client network connectivity</title>
<simpara>The loss of network connectivity to an individual node will cause it to become unable to boot in an unattended fashion.</simpara>
<simpara>If you are planning work that might cause a loss of network connectivity,
you can reveal the passphrase for an onsite technician to use manually,
and then rotate the keys afterwards to invalidate it:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Before the network becomes unavailable, show the password used in the first slot <literal>-s 1</literal> of device <literal>/dev/vda2</literal> with this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo clevis luks pass -d /dev/vda2 -s 1</programlisting>
</listitem>
<listitem>
<simpara>Invalidate that value and regenerate a new random boot-time passphrase with this command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo clevis luks regen -d /dev/vda2 -s 1</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nbde-unexpected-loss-of-network-connectivity_nbde-implementation">
<title>Unexpected loss of network connectivity</title>
<simpara>If the network disruption is unexpected and a node reboots, consider the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>If any nodes are still online, ensure that they do not reboot until network connectivity is restored. This is not applicable for single-node clusters.</simpara>
</listitem>
<listitem>
<simpara>The node will remain offline until such time that either network connectivity is restored, or a pre-established passphrase is entered manually at the console. In exceptional circumstances, network administrators might be able to reconfigure network segments to reestablish access, but this is counter to the intent of NBDE, which is that lack of network access means lack of ability to boot.</simpara>
</listitem>
<listitem>
<simpara>The lack of network access at the node can reasonably be expected to impact that node’s ability to function as well as its ability to boot. Even if the node were to boot via manual intervention, the lack of network access would make it effectively useless.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-recovering-network-connectivity-manually_nbde-implementation">
<title>Recovering network connectivity manually</title>
<simpara>A somewhat complex and manually intensive process is also available to the onsite technician for network recovery.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>The onsite technician extracts the Clevis header from the hard disks. Depending on BIOS lockdown, this might involve removing the disks and installing them in a lab machine.</simpara>
</listitem>
<listitem>
<simpara>The onsite technician transmits the Clevis headers to a colleague with legitimate access to the Tang network who then performs the decryption.</simpara>
</listitem>
<listitem>
<simpara>Due to the necessity of limited access to the Tang network, the technician should not be able to access that network via VPN or other remote connectivity.  Similarly, the technician cannot patch the remote server through to this network in order to decrypt the disks automatically.</simpara>
</listitem>
<listitem>
<simpara>The technician reinstalls the disk and manually enters the plain text passphrase provided by their colleague.</simpara>
</listitem>
<listitem>
<simpara>The machine successfully starts even without direct access to the Tang servers.  Note that the transmission of the key material from the install site to another site with network access must be done carefully.</simpara>
</listitem>
<listitem>
<simpara>When network connectivity is restored, the technician rotates the encryption keys.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nbde-emergency-recovery-of-network-connectivity_nbde-implementation">
<title>Emergency recovery of network connectivity</title>
<simpara>If you are unable to recover network connectivity manually, consider the following steps. Be aware that these steps are discouraged if other methods to recover network connectivity are available.</simpara>
<itemizedlist>
<listitem>
<simpara>This method must only be performed by a highly trusted technician.</simpara>
</listitem>
<listitem>
<simpara>Taking the Tang server’s key material to the remote site is considered to be a breach of the key material and all servers must be rekeyed and re-encrypted.</simpara>
</listitem>
<listitem>
<simpara>This method must be used in extreme cases only, or as a proof of concept recovery method to demonstrate its viability.</simpara>
</listitem>
<listitem>
<simpara>Equally extreme, but theoretically possible, is to power the server in question with an Uninterruptible Power Supply (UPS), transport the server to a location with network connectivity to boot and decrypt the disks, and then restore the server at the original location on battery power to continue operation.</simpara>
</listitem>
<listitem>
<simpara>If you want to use a backup manual passphrase, you must create it before the failure situation occurs.</simpara>
</listitem>
<listitem>
<simpara>Just as attack scenarios become more complex with TPM and Tang compared to a stand-alone Tang installation, so emergency disaster recovery processes are also made more complex if leveraging the same method.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nbde-loss-of-a-network-segment_nbde-implementation">
<title>Loss of a network segment</title>
<simpara>The loss of a network segment, making a Tang server temporarily unavailable, has the following consequences:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform nodes continue to boot as normal, provided other servers are available.</simpara>
</listitem>
<listitem>
<simpara>New nodes cannot establish their encryption keys until the network segment is restored. In this case, ensure connectivity to remote geographic locations for the purposes of high availability and redundancy. This is because when you are installing a new node or rekeying an existing node, all of the Tang servers you are referencing in that operation must be available.</simpara>
</listitem>
</itemizedlist>
<simpara>A hybrid model for a vastly diverse network, such as five geographic regions in which each client is connected to the closest three clients is worth investigating.</simpara>
<simpara>In this scenario, new clients are able to establish their encryption keys with the subset of servers that are reachable. For example, in the set of <literal>tang1</literal>, <literal>tang2</literal> and <literal>tang3</literal> servers, if <literal>tang2</literal> becomes unreachable clients can still establish their encryption keys with <literal>tang1</literal> and <literal>tang3</literal>, and at a later time re-establish with the full set. This can involve either a manual intervention or a more complex automation to be available.</simpara>
</section>
<section xml:id="nbde-loss-of-a-tang-server_nbde-implementation">
<title>Loss of a Tang server</title>
<simpara>The loss of an individual Tang server within a load balanced set of servers with identical key material is completely transparent to the clients.</simpara>
<simpara>The temporary failure of all Tang servers associated with the same URL, that is, the entire load balanced set, can be considered the same as the loss of a network segment. Existing clients have the ability to decrypt their disk partitions so long as another preconfigured Tang server is available. New clients cannot enroll until at least one of these servers comes back online.</simpara>
<simpara>You can mitigate the physical loss of a Tang server by either reinstalling the server or restoring the server from backups. Ensure that the backup and restore processes of the key material is adequately protected from unauthorized access.</simpara>
</section>
<section xml:id="nbde-compromise-of-key-material_nbde-implementation">
<title>Rekeying compromised key material</title>
<simpara>If key material is potentially exposed to unauthorized third parties, such as through the physical theft of a Tang server or associated data, immediately rotate the keys.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Rekey any Tang server holding the affected material.</simpara>
</listitem>
<listitem>
<simpara>Rekey all clients using the Tang server.</simpara>
</listitem>
<listitem>
<simpara>Destroy the original key material.</simpara>
</listitem>
<listitem>
<simpara>Scrutinize any incidents that result in unintended exposure of the master encryption key. If possible, take compromised nodes offline and re-encrypt their disks.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>Reformatting and reinstalling on the same physical hardware, although slow, is easy to automate and test.</simpara>
</tip>
</section>
</section>
</chapter>
</book>