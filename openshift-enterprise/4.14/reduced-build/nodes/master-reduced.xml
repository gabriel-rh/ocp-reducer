<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Nodes</title>
<date>2024-02-13</date>
</info>
<chapter xml:id="overview-of-nodes">
<title>Overview of nodes</title>

<section xml:id="nodes-overview">
<title>About nodes</title>
<simpara>A node is a virtual or bare-metal machine in a Kubernetes cluster. Worker nodes host your application containers, grouped as pods. The control plane nodes run services that are required to control the Kubernetes cluster. In {product-title}, the control plane nodes contain more than just the Kubernetes services for managing the {product-title} cluster.</simpara>
<simpara>Having stable and healthy nodes in a cluster is fundamental to the smooth functioning of your hosted application.
In {product-title}, you can access, manage, and monitor a node through the <literal>Node</literal> object representing the node.
Using the OpenShift CLI (<literal>oc</literal>) or the web console, you can perform the following operations on a node.</simpara>
<simpara>The following components of a node are responsible for maintaining the running of pods and providing the Kubernetes runtime environment.</simpara>
<itemizedlist>
<listitem>
<simpara>Container runtime:: The container runtime is responsible for running containers. Kubernetes offers several runtimes such as containerd, cri-o, rktlet, and Docker.</simpara>
</listitem>
<listitem>
<simpara>Kubelet:: Kubelet runs on nodes and reads the container manifests. It ensures that the defined containers have started and are running. The kubelet process maintains the state of work and the node server. Kubelet manages network rules and port forwarding. The kubelet manages containers that are created by Kubernetes only.</simpara>
</listitem>
<listitem>
<simpara>Kube-proxy:: Kube-proxy runs on every node in the cluster and maintains the network traffic between the Kubernetes resources. A Kube-proxy ensures that the networking environment is isolated and accessible.</simpara>
</listitem>
<listitem>
<simpara>DNS:: Cluster DNS is a DNS server which serves DNS records for Kubernetes services. Containers started by Kubernetes automatically include this DNS server in their DNS searches.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/295_OpenShift_Nodes_Overview_1222.png"/>
</imageobject>
<textobject><phrase>Overview of control plane and worker node</phrase></textobject>
</mediaobject>
</informalfigure>
<bridgehead xml:id="_read_operations" renderas="sect3">Read operations</bridgehead>
<simpara>The read operations allow an administrator or a developer to get information about nodes in an {product-title} cluster.</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-viewing.xml#nodes-nodes-viewing-listing_nodes-nodes-viewing">List all the nodes in a cluster</link>.</simpara>
</listitem>
<listitem>
<simpara>Get information about a node, such as memory and CPU usage, health, status, and age.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-viewing.xml#nodes-nodes-viewing-listing-pods_nodes-nodes-viewing">List pods running on a node</link>.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_management_operations" renderas="sect3">Management operations</bridgehead>
<simpara>As an administrator, you can easily manage a node in an {product-title} cluster
through several tasks:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-updating_nodes-nodes-working">Add or update node labels</link>. A label is a key-value pair applied to a <literal>Node</literal> object. You can control the scheduling of pods using labels.</simpara>
</listitem>
<listitem>
<simpara>Change node configuration using a custom resource definition (CRD), or the <literal>kubeletConfig</literal> object.</simpara>
</listitem>
<listitem>
<simpara>Configure nodes to allow or disallow the scheduling of pods. Healthy worker nodes with a <literal>Ready</literal> status allow pod placement by default while the control plane nodes do not; you can change this default behavior by <link xl:href="../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-marking_nodes-nodes-working">configuring the worker nodes to be unschedulable</link> and <link xl:href="../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-marking_nodes-nodes-working">the control plane nodes to be schedulable</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-resources-configuring.xml#nodes-nodes-resources-configuring">Allocate resources for nodes</link> using the <literal>system-reserved</literal> setting. You can allow {product-title} to automatically determine the optimal <literal>system-reserved</literal> CPU and memory resources for your nodes, or you can manually determine and set the best resources for your nodes.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-managing-max-pods.xml#nodes-nodes-managing-max-pods-proc_nodes-nodes-managing-max-pods">Configure the number of pods that can run on a node</link> based on the number of processor cores on the node, a hard limit, or both.</simpara>
</listitem>
<listitem>
<simpara>Reboot a node gracefully using <link xl:href="../nodes/nodes/nodes-nodes-rebooting.xml#nodes-nodes-rebooting-affinity_nodes-nodes-rebooting">pod anti-affinity</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-working.xml#deleting-nodes">Delete a node from a cluster</link> by scaling down the cluster using a compute machine set. To delete a node from a bare-metal cluster, you must first drain all pods on the node and then manually delete the node.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_enhancement_operations" renderas="sect3">Enhancement operations</bridgehead>
<simpara>{product-title} allows you to do more than just access and manage nodes; as an administrator, you can perform the following tasks on nodes to make the cluster more efficient, application-friendly, and to provide a better environment for your developers.</simpara>
<itemizedlist>
<listitem>
<simpara>Manage node-level tuning for high-performance applications that require some level of kernel tuning by <link xl:href="../nodes/nodes/nodes-node-tuning-operator.xml#nodes-node-tuning-operator">using the Node Tuning Operator</link>.</simpara>
</listitem>
<listitem>
<simpara>Enable TLS security profiles on the node to protect communication between the kubelet and the Kubernetes API server.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/jobs/nodes-pods-daemonsets.xml#nodes-pods-daemonsets">Run background tasks on nodes automatically with daemon sets</link>. You can create and use daemon sets to create shared storage, run a logging pod on every node, or deploy a monitoring agent on all nodes.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-garbage-collection.xml#nodes-nodes-garbage-collection">Free node resources using garbage collection</link>. You can ensure that your nodes are running efficiently by removing terminated containers and the images not referenced by any running pods.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/nodes/nodes-nodes-managing.xml#nodes-nodes-kernel-arguments_nodes-nodes-managing">Add kernel arguments to a set of nodes</link>.</simpara>
</listitem>
<listitem>
<simpara>Configure an {product-title} cluster to have worker nodes at the network edge (remote worker nodes). For information on the challenges of having remote worker nodes in an {product-title} cluster and some recommended approaches for managing pods on a remote worker node, see <link xl:href="../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers">Using remote worker nodes at the network edge</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="pods-overview">
<title>About pods</title>
<simpara>A pod is one or more containers deployed together on a node. As a cluster administrator, you can define a pod, assign it to run on a healthy node that is ready for scheduling, and manage. A pod runs as long as the containers are running. You cannot change a pod once it is defined and is running. Some operations you can perform when working with pods are:</simpara>
<bridgehead xml:id="_read_operations_2" renderas="sect3">Read operations</bridgehead>
<simpara>As an administrator, you can get information about pods in a project through the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../nodes/pods/nodes-pods-viewing.xml#nodes-pods-viewing-project_nodes-pods-viewing">List pods associated with a project</link>, including information such as the number of replicas and restarts, current status, and age.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/pods/nodes-pods-viewing.xml#nodes-pods-viewing-usage_nodes-pods-viewing">View pod usage statistics</link> such as CPU, memory, and storage consumption.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_management_operations_2" renderas="sect3">Management operations</bridgehead>
<simpara>The following list of tasks provides an overview of how an administrator can manage pods in an {product-title} cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>Control scheduling of pods using the advanced scheduling features available in {product-title}:</simpara>
<itemizedlist>
<listitem>
<simpara>Node-to-pod binding rules such as <link xl:href="../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity-example-affinity_nodes-scheduler-pod-affinity">pod affinity</link>, <link xl:href="../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity">node affinity</link>, and <link xl:href="../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-anti-affinity-configuring_nodes-scheduler-pod-affinity">anti-affinity</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/nodes-scheduler-node-selectors.xml#nodes-scheduler-node-selectors">Node labels and selectors</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations">Taints and tolerations</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/nodes-scheduler-pod-topology-spread-constraints.xml#nodes-scheduler-pod-topology-spread-constraints">Pod topology spread constraints</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/secondary_scheduler/index.xml#nodes-secondary-scheduler-about">Secondary scheduling</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/scheduling/descheduler/index.xml#nodes-descheduler-about">Configure the descheduler to evict pods</link> based on specific strategies so that the scheduler reschedules the pods to more appropriate nodes.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/pods/nodes-pods-configuring.xml#nodes-pods-configuring-restart_nodes-pods-configuring">Configure how pods behave after a restart using pod controllers and restart policies</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/pods/nodes-pods-configuring.xml#nodes-pods-configuring-bandwidth_nodes-pods-configuring">Limit both egress and ingress traffic on a pod</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/containers/nodes-containers-volumes.xml#nodes-containers-volumes">Add and remove volumes to and from any object that has a pod template</link>. A volume is a mounted file system available to all the containers in a pod. Container storage is ephemeral; you can use volumes to persist container data.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_enhancement_operations_2" renderas="sect3">Enhancement operations</bridgehead>
<simpara>You can work with pods more easily and efficiently with the help of various tools and features available in {product-title}. The following operations involve using those tools and features to better manage pods.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Operation</entry>
<entry align="left" valign="top">User</entry>
<entry align="left" valign="top">More information</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Create and use a horizontal pod autoscaler.</simpara></entry>
<entry align="left" valign="top"><simpara>Developer</simpara></entry>
<entry align="left" valign="top"><simpara>You can use a horizontal pod autoscaler to specify the minimum and the maximum number of pods you want to run, as well as the CPU utilization or memory utilization your pods should target. Using a horizontal pod autoscaler, you can <link xl:href="../nodes/pods/nodes-pods-autoscaling.xml#nodes-pods-autoscaling">automatically scale pods</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xl:href="../nodes/pods/nodes-pods-vertical-autoscaler.xml#nodes-pods-vpa">Install and use a vertical pod autoscaler</link>.</simpara></entry>
<entry align="left" valign="top"><simpara>Administrator and developer</simpara></entry>
<entry align="left" valign="top"><simpara>As an administrator, use a vertical pod autoscaler to better use cluster resources by monitoring the resources and the resource requirements of workloads.</simpara><simpara>As a developer, use a vertical pod autoscaler to ensure your pods stay up during periods of high demand by scheduling pods to nodes that have enough resources for each pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Provide access to external resources using device plugins.</simpara></entry>
<entry align="left" valign="top"><simpara>Administrator</simpara></entry>
<entry align="left" valign="top"><simpara>A <link xl:href="../nodes/pods/nodes-pods-plugins.xml#nodes-pods-device">device plugin</link> is a gRPC service running on nodes (external to the kubelet), which manages specific hardware resources. You can <link xl:href="../nodes/pods/nodes-pods-plugins.xml#methods-for-deploying-a-device-plugin_nodes-pods-device">deploy a device plugin</link> to provide a consistent and portable solution to consume hardware devices across clusters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Provide sensitive data to pods <link xl:href="../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets">using the <literal>Secret</literal> object</link>.</simpara></entry>
<entry align="left" valign="top"><simpara>Administrator</simpara></entry>
<entry align="left" valign="top"><simpara>Some applications need sensitive information, such as passwords and usernames. You can use the <literal>Secret</literal> object to provide such information to an application pod.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="containers-overview">
<title>About containers</title>
<simpara>A container is the basic unit of an {product-title} application, which comprises the application code packaged along with its dependencies, libraries, and binaries. Containers provide consistency across environments and multiple deployment targets: physical servers, virtual machines (VMs), and private or public cloud.</simpara>
<simpara>Linux container technologies are lightweight mechanisms for isolating running processes and limiting access to only designated resources.
As an administrator, You can perform various tasks on a Linux container, such as:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../nodes/containers/nodes-containers-copying-files.xml#nodes-containers-copying-files">Copy files to and from a container</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/containers/nodes-containers-downward-api.xml#nodes-containers-downward-api">Allow containers to consume API objects</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/containers/nodes-containers-remote-commands.xml#nodes-containers-remote-commands">Execute remote commands in a container</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../nodes/containers/nodes-containers-port-forwarding.xml#nodes-containers-port-forwarding">Use port forwarding to access applications in a container</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>{product-title} provides specialized containers called <link xl:href="../nodes/containers/nodes-containers-init.xml#nodes-containers-init">Init containers</link>. Init containers run before application containers and can contain utilities or setup scripts not present in an application image. You can use an Init container to perform tasks before the rest of a pod is deployed.</simpara>
<simpara>Apart from performing specific tasks on nodes, pods, and containers, you can work with the overall {product-title} cluster to keep the cluster efficient and the application pods highly available.</simpara>
</section>
<section xml:id="nodes-about-autoscaling-pod_overview-of-nodes">
<title>About autoscaling pods on a node</title>
<simpara>{product-title} offers three tools that you can use to automatically scale the number of pods on your nodes and the resources allocated to pods.</simpara>
<variablelist>
<varlistentry>
<term>Horizontal Pod Autoscaler</term>
<listitem>
<simpara>The Horizontal Pod Autoscaler (HPA) can automatically increase or decrease the scale of a replication controller or deployment configuration, based on metrics collected from the pods that belong to that replication controller or deployment configuration.</simpara>
<simpara>For more information, see <link xl:href="../nodes/pods/nodes-pods-autoscaling.xml#nodes-pods-autoscaling">Automatically scaling pods with the horizontal pod autoscaler</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Custom Metrics Autoscaler</term>
<listitem>
<simpara>The Custom Metrics Autoscaler can automatically increase or decrease the number of pods for a deployment, stateful set, custom resource, or job based on custom metrics that are not based only on CPU or memory.</simpara>
<simpara>For more information, see <link xl:href="../nodes/cma/nodes-cma-autoscaling-custom.xml#nodes-cma-autoscaling-custom">Custom Metrics Autoscaler Operator overview</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Vertical Pod Autoscaler</term>
<listitem>
<simpara>The Vertical Pod Autoscaler (VPA) can automatically review the historic and current CPU and memory resources for containers in pods and can update the resource limits and requests based on the usage values it learns.</simpara>
<simpara>For more information, see <link xl:href="../nodes/pods/nodes-pods-vertical-autoscaler.xml#nodes-pods-vpa">Automatically adjust pod resource levels with the vertical pod autoscaler</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="commonterms-node">
<title>Glossary of common terms for {product-title} nodes</title>
<simpara>This glossary defines common terms that are used in the <emphasis>node</emphasis> content.</simpara>
<variablelist xml:id="commonterms-node-container">
<varlistentry>
<term>Container</term>
<listitem>
<simpara>It is a lightweight and executable image that comprises software and all its dependencies. Containers virtualize the operating system, as a result, you can run containers anywhere from a data center to a public or private cloud to even a developer&#8217;s laptop.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-daemonset">
<varlistentry>
<term>Daemon set</term>
<listitem>
<simpara>Ensures that a replica of the pod runs on eligible nodes in an {product-title} cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-egress">
<varlistentry>
<term>egress</term>
<listitem>
<simpara>The process of data sharing externally through a network’s outbound traffic from a pod.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-gc">
<varlistentry>
<term>garbage collection</term>
<listitem>
<simpara>The process of cleaning up cluster resources, such as terminated containers and images that are not referenced by any running pods.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-hpa">
<varlistentry>
<term>Horizontal Pod Autoscaler(HPA)</term>
<listitem>
<simpara>Implemented as a Kubernetes API resource and a controller. You can use the HPA to specify the minimum and maximum number of pods that you want to run. You can also specify the CPU or memory utilization that your pods should target. The HPA scales out and scales in pods when a given CPU or memory threshold is crossed.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-ingress">
<varlistentry>
<term>Ingress</term>
<listitem>
<simpara>Incoming traffic to a pod.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-job">
<varlistentry>
<term>Job</term>
<listitem>
<simpara>A process that runs to completion. A job creates one or more pod objects and ensures that the specified pods are successfully completed.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-label">
<varlistentry>
<term>Labels</term>
<listitem>
<simpara>You can use labels, which are key-value pairs, to organise and select subsets of objects, such as a pod.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-nodenew">
<varlistentry>
<term>Node</term>
<listitem>
<simpara>A worker machine in the {product-title} cluster. A node can be either be a virtual machine (VM) or a physical machine.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-tuningop">
<varlistentry>
<term>Node Tuning Operator</term>
<listitem>
<simpara>You can use the Node Tuning Operator to manage node-level tuning by using the TuneD daemon. It ensures custom tuning specifications are passed to all containerized TuneD daemons running in the cluster in the format that the daemons understand. The daemons run on all nodes in the cluster, one per node.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-self-remediationop">
<varlistentry>
<term>Self Node Remediation Operator</term>
<listitem>
<simpara>The Operator runs on the cluster nodes and identifies and reboots nodes that are unhealthy.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-podnew">
<varlistentry>
<term>Pod</term>
<listitem>
<simpara>One or more containers with shared resources, such as volume and IP addresses, running in your {product-title} cluster.
A pod is the smallest compute unit defined, deployed, and managed.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-toleration">
<varlistentry>
<term>Toleration</term>
<listitem>
<simpara>Indicates that the pod is allowed (but not required) to be scheduled on nodes or node groups with matching taints. You can use tolerations to enable the scheduler to schedule pods with matching taints.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="commonterms-node-taint">
<varlistentry>
<term>Taint</term>
<listitem>
<simpara>A core object that comprises a key,value, and effect. Taints and tolerations work together to ensure that pods are not scheduled on irrelevant nodes.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</chapter>
<chapter xml:id="_working_with_pods">
<title>Working with pods</title>
<section xml:id="nodes-pods-using-pp">
<title>Using pods</title>

<simpara>A <emphasis>pod</emphasis> is one or more containers deployed together on one host, and the smallest compute unit that can be defined,
deployed, and managed.</simpara>
<section xml:id="nodes-pods-using-about_nodes-pods-using-ssy">
<title>Understanding pods</title>
<simpara>Pods are the rough equivalent of a machine instance (physical or virtual) to a Container. Each pod is allocated its own internal IP address, therefore owning its entire port space, and containers within pods can share their local storage and networking.</simpara>
<simpara>Pods have a lifecycle; they are defined, then they are assigned to run on
a node, then they run until their container(s) exit or they are removed
for some other reason. Pods, depending on policy and exit code, might be
removed after exiting, or can be retained to enable access to
the logs of their containers.</simpara>
<simpara>{product-title} treats pods as largely immutable; changes cannot be made to
a pod definition while it is running. {product-title} implements changes by
terminating an existing pod and recreating it with modified configuration,
base image(s), or both. Pods are also treated as expendable, and do not
maintain state when recreated. Therefore pods should usually be managed by
higher-level controllers, rather than directly by users.</simpara>
<note>
<simpara>For the maximum number of pods per {product-title} node host, see the Cluster Limits.</simpara>
</note>
<warning>
<simpara>Bare pods that are not managed by a replication controller will be not rescheduled upon node disruption.</simpara>
</warning>
</section>
<section xml:id="nodes-pods-using-example_nodes-pods-using-ssy">
<title>Example pod configurations</title>
<simpara>{product-title} leverages the Kubernetes concept of a <emphasis>pod</emphasis>, which is one or more containers deployed together on one host, and the smallest compute unit that can be defined, deployed, and managed.</simpara>
<simpara>The following is an example definition of a pod from a Rails application. It demonstrates many features of pods, most of which are discussed in other topics and thus only briefly mentioned here:</simpara>
<formalpara xml:id="example-pod-definition_nodes-pods-using-ssy">
<title><literal>Pod</literal> object definition (YAML)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: example
  namespace: default
  selfLink: /api/v1/namespaces/default/pods/example
  uid: 5cc30063-0265780783bc
  resourceVersion: '165032'
  creationTimestamp: '2019-02-13T20:31:37Z'
  labels:
    app: hello-openshift <co xml:id="CO1-1"/>
  annotations:
    openshift.io/scc: anyuid
spec:
  restartPolicy: Always <co xml:id="CO1-2"/>
  serviceAccountName: default
  imagePullSecrets:
    - name: default-dockercfg-5zrhb
  priority: 0
  schedulerName: default-scheduler
  terminationGracePeriodSeconds: 30
  nodeName: ip-10-0-140-16.us-east-2.compute.internal
  securityContext: <co xml:id="CO1-3"/>
    seLinuxOptions:
      level: 's0:c11,c10'
  containers: <co xml:id="CO1-4"/>
    - resources: {}
      terminationMessagePath: /dev/termination-log
      name: hello-openshift
      securityContext:
        capabilities:
          drop:
            - MKNOD
        procMount: Default
      ports:
        - containerPort: 8080
          protocol: TCP
      imagePullPolicy: Always
      volumeMounts: <co xml:id="CO1-5"/>
        - name: default-token-wbqsl
          readOnly: true
          mountPath: /var/run/secrets/kubernetes.io/serviceaccount <co xml:id="CO1-6"/>
      terminationMessagePolicy: File
      image: registry.redhat.io/openshift4/ose-ogging-eventrouter:v4.3 <co xml:id="CO1-7"/>
  serviceAccount: default <co xml:id="CO1-8"/>
  volumes: <co xml:id="CO1-9"/>
    - name: default-token-wbqsl
      secret:
        secretName: default-token-wbqsl
        defaultMode: 420
  dnsPolicy: ClusterFirst
status:
  phase: Pending
  conditions:
    - type: Initialized
      status: 'True'
      lastProbeTime: null
      lastTransitionTime: '2019-02-13T20:31:37Z'
    - type: Ready
      status: 'False'
      lastProbeTime: null
      lastTransitionTime: '2019-02-13T20:31:37Z'
      reason: ContainersNotReady
      message: 'containers with unready status: [hello-openshift]'
    - type: ContainersReady
      status: 'False'
      lastProbeTime: null
      lastTransitionTime: '2019-02-13T20:31:37Z'
      reason: ContainersNotReady
      message: 'containers with unready status: [hello-openshift]'
    - type: PodScheduled
      status: 'True'
      lastProbeTime: null
      lastTransitionTime: '2019-02-13T20:31:37Z'
  hostIP: 10.0.140.16
  startTime: '2019-02-13T20:31:37Z'
  containerStatuses:
    - name: hello-openshift
      state:
        waiting:
          reason: ContainerCreating
      lastState: {}
      ready: false
      restartCount: 0
      image: openshift/hello-openshift
      imageID: ''
  qosClass: BestEffort</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Pods can be "tagged" with one or more labels, which can then be used to select and manage groups of pods in a single operation. The labels are stored in key/value format in the <literal>metadata</literal> hash.</para>
</callout>
<callout arearefs="CO1-2">
<para>The pod restart policy with possible values <literal>Always</literal>, <literal>OnFailure</literal>, and <literal>Never</literal>. The default value is <literal>Always</literal>.</para>
</callout>
<callout arearefs="CO1-3">
<para>{product-title} defines a security context for containers which specifies whether they are allowed to run as privileged containers, run as a user of their choice, and more. The default context is very restrictive but administrators can modify this as needed.</para>
</callout>
<callout arearefs="CO1-4">
<para><literal>containers</literal> specifies an array of one or more container definitions.</para>
</callout>
<callout arearefs="CO1-5">
<para>The container specifies where external storage volumes are mounted within the container. In this case, there is a volume for storing access to credentials the registry needs for making requests against the {product-title} API.</para>
</callout>
<callout arearefs="CO1-6">
<para>Specify the volumes to provide for the pod. Volumes mount at the specified path. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
<callout arearefs="CO1-7">
<para>Each container in the pod is instantiated from its own container image.</para>
</callout>
<callout arearefs="CO1-8">
<para>Pods making requests against the {product-title} API is a common enough pattern that there is a <literal>serviceAccount</literal> field for specifying which service account user the pod should authenticate as when making the requests. This enables fine-grained access control for custom infrastructure components.</para>
</callout>
<callout arearefs="CO1-9">
<para>The pod defines storage volumes that are available to its container(s) to use. In this case, it provides an ephemeral volume for a <literal>secret</literal> volume containing the default service account tokens.</para>
<simpara>If you attach persistent volumes that have high file counts to pods, those pods can fail or can take a long time to start. For
more information, see <link xl:href="https://access.redhat.com/solutions/6221251">When using Persistent Volumes with high file counts in OpenShift, why do pods fail to start or take an excessive amount of time to achieve "Ready" state?</link>.</simpara>
</callout>
</calloutlist>
<note>
<simpara>This pod definition does not include attributes that are filled by {product-title} automatically after the pod is created and its lifecycle begins. The <link xl:href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">Kubernetes pod documentation</link> has details about the functionality and purpose of pods.</simpara>
</note>
</section>
<section xml:id="_additional_resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>For more information on pods and storage see <link xl:href="../../storage/understanding-persistent-storage.xml#understanding-persistent-storage">Understanding persistent storage</link> and <link xl:href="../../storage/understanding-persistent-storage.xml#understanding-ephemeral-storage">Understanding ephemeral storage</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-viewing">
<title>Viewing pods</title>

<simpara>As an administrator, you can view the pods in your cluster and to determine the health of those pods and the cluster as a whole.</simpara>
<section xml:id="nodes-pods-about_nodes-pods-viewing">
<title>About pods</title>
<simpara>{product-title} leverages the Kubernetes concept of a <emphasis>pod</emphasis>, which is one or more containers deployed
together on one host, and the smallest compute unit that can be defined,
deployed, and managed. Pods are the rough equivalent of a machine instance (physical or virtual) to a container.</simpara>
<simpara>You can view a list of pods associated with a specific project or view usage statistics about pods.</simpara>
</section>
<section xml:id="nodes-pods-viewing-project_nodes-pods-viewing">
<title>Viewing pods in a project</title>
<simpara>You can view a list of pods associated with the current project, including the number of replica, the current status, number or restarts and the age of the pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>To view the pods in a project:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Change to the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project &lt;project-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                       READY   STATUS    RESTARTS   AGE
console-698d866b78-bnshf   1/1     Running   2          165m
console-698d866b78-m87pm   1/1     Running   2          165m</programlisting>
</para>
</formalpara>
<simpara>Add the <literal>-o wide</literal> flags to view the pod IP address and the node where the pod is located.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                       READY   STATUS    RESTARTS   AGE    IP            NODE                           NOMINATED NODE
console-698d866b78-bnshf   1/1     Running   2          166m   10.128.0.24   ip-10-0-152-71.ec2.internal    &lt;none&gt;
console-698d866b78-m87pm   1/1     Running   2          166m   10.129.0.23   ip-10-0-173-237.ec2.internal   &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-viewing-usage_nodes-pods-viewing">
<title>Viewing pod usage statistics</title>
<simpara>You can display usage statistics about pods, which provide the runtime
environments for containers. These usage statistics include CPU, memory, and
storage consumption.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-reader</literal> permission to view the usage statistics.</simpara>
</listitem>
<listitem>
<simpara>Metrics must be installed to view the usage statistics.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To view the usage statistics:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top pods</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top pods -n openshift-console</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                         CPU(cores)   MEMORY(bytes)
console-7f58c69899-q8c8k     0m           22Mi
console-7f58c69899-xhbgg     0m           25Mi
downloads-594fcccf94-bcxk8   3m           18Mi
downloads-594fcccf94-kv4p6   2m           15Mi</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to view the usage statistics for pods with labels:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top pod --selector=''</programlisting>
<simpara>You must choose the selector (label query) to filter on. Supports <literal>=</literal>, <literal>==</literal>, and <literal>!=</literal>.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top pod --selector='name=my-pod'</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="viewing-resource-logs-cli-console_nodes-pods-viewing">
<title>Viewing resource logs</title>
<simpara>You can view the log for various resources in the OpenShift CLI (<literal>oc</literal>) and web console. Logs read from the tail, or end, of the log.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure (UI)</title>
<listitem>
<simpara>In the {product-title} console, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis> or navigate to the pod through the resource you want to investigate.</simpara>
<note>
<simpara>Some resources, such as builds, do not have pods to query directly. In such instances, you can locate the <emphasis role="strong">Logs</emphasis> link on the <emphasis role="strong">Details</emphasis> page for the resource.</simpara>
</note>
</listitem>
<listitem>
<simpara>Select a project from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the pod you want to investigate.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Logs</emphasis>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Procedure (CLI)</title>
<listitem>
<simpara>View the log for a specific pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -f &lt;pod_name&gt; -c &lt;container_name&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>-f</literal></term>
<listitem>
<simpara>Optional: Specifies that the output follows what is being written into the logs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;pod_name&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;container_name&gt;</literal></term>
<listitem>
<simpara>Optional: Specifies the name of a container. When a pod has more than one container, you must specify the container name.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs ruby-58cd97df55-mww7r</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -f ruby-57f7f4855b-znl92 -c ruby</programlisting>
<simpara>The contents of log files are printed out.</simpara>
</listitem>
<listitem>
<simpara>View the log for a specific resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs &lt;object_type&gt;/&lt;resource_name&gt; <co xml:id="CO2-1"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Specifies the resource type and name.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment/ruby</programlisting>
<simpara>The contents of log files are printed out.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-configuring">
<title>Configuring an {product-title} cluster for pods</title>

<simpara>As an administrator, you can create and maintain an efficient cluster for pods.</simpara>
<simpara>By keeping your cluster efficient, you can provide a better environment for your developers using
such tools as what a pod does when it exits, ensuring that the required number of pods is always running,
when to restart pods designed to run only once, limit the bandwidth available to pods, and how to keep
pods running during disruptions.</simpara>
<section xml:id="nodes-pods-configuring-restart_nodes-pods-configuring">
<title>Configuring how pods behave after restart</title>
<simpara>A pod restart policy determines how {product-title} responds when Containers in that pod exit.
The policy applies to all Containers in that pod.</simpara>
<simpara>The possible values are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Always</literal> - Tries restarting a successfully exited Container on the pod continuously, with an exponential back-off delay (10s, 20s, 40s) capped at 5 minutes. The default is <literal>Always</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>OnFailure</literal> - Tries restarting a failed Container on the pod with an exponential back-off delay (10s, 20s, 40s) capped at 5 minutes.</simpara>
</listitem>
<listitem>
<simpara><literal>Never</literal> - Does not try to restart exited or failed Containers on the pod. Pods immediately fail and exit.</simpara>
</listitem>
</itemizedlist>
<simpara>After the pod is bound to a node, the pod will never be bound to another node. This means that a controller is necessary in order for a pod to survive node failure:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Condition</entry>
<entry align="left" valign="top">Controller Type</entry>
<entry align="left" valign="top">Restart Policy</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Pods that are expected to terminate (such as batch computations)</simpara></entry>
<entry align="left" valign="top"><simpara>Job</simpara></entry>
<entry align="left" valign="top"><simpara><literal>OnFailure</literal> or <literal>Never</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pods that are expected to not terminate (such as web servers)</simpara></entry>
<entry align="left" valign="top"><simpara>Replication controller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Always</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pods that must run one-per-machine</simpara></entry>
<entry align="left" valign="top"><simpara>Daemon set</simpara></entry>
<entry align="left" valign="top"><simpara>Any</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If a Container on a pod fails and the restart policy is set to <literal>OnFailure</literal>, the pod stays on the node and the Container is restarted. If you do not want the Container to
restart, use a restart policy of <literal>Never</literal>.</simpara>
<simpara>If an entire pod fails, {product-title} starts a new pod. Developers must address the possibility that applications might be restarted in a new pod. In particular,
applications must handle temporary files, locks, incomplete output, and so forth caused by previous runs.</simpara>
<note>
<simpara>Kubernetes architecture expects reliable endpoints from cloud providers. When a cloud provider is down, the kubelet prevents {product-title} from restarting.</simpara>
<simpara>If the underlying cloud provider endpoints are not reliable, do not install a cluster using cloud provider integration. Install the cluster as if it was in a no-cloud environment. It is not recommended to toggle cloud provider integration on or off in an installed cluster.</simpara>
</note>
<simpara>For details on how {product-title} uses restart policy with failed Containers, see
the <link xl:href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states">Example States</link> in the Kubernetes documentation.</simpara>
</section>
<section xml:id="nodes-pods-configuring-bandwidth_nodes-pods-configuring">
<title>Limiting the bandwidth available to pods</title>
<simpara>You can apply quality-of-service traffic shaping to a pod and effectively limit
its available bandwidth. Egress traffic (from the pod) is handled by policing,
which simply drops packets in excess of the configured rate. Ingress traffic (to
the pod) is handled by shaping queued packets to effectively handle data. The
limits you place on a pod do not affect the bandwidth of other pods.</simpara>
<formalpara>
<title>Procedure</title>
<para>To limit the bandwidth on a pod:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Write an object definition JSON file, and specify the data traffic speed using
<literal>kubernetes.io/ingress-bandwidth</literal> and <literal>kubernetes.io/egress-bandwidth</literal>
annotations. For example, to limit both pod egress and ingress bandwidth to 10M/s:</simpara>
<formalpara>
<title>Limited <literal>Pod</literal> object definition</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "kind": "Pod",
    "spec": {
        "containers": [
            {
                "image": "openshift/hello-openshift",
                "name": "hello-openshift"
            }
        ]
    },
    "apiVersion": "v1",
    "metadata": {
        "name": "iperf-slow",
        "annotations": {
            "kubernetes.io/ingress-bandwidth": "10M",
            "kubernetes.io/egress-bandwidth": "10M"
        }
    }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the pod using the object definition:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_or_dir_path&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-pod-distruption-about_nodes-pods-configuring">
<title>Understanding how to use pod disruption budgets to specify the number of pods that must be up</title>
<simpara>A <emphasis>pod disruption budget</emphasis> allows the specification of safety constraints on pods during operations, such as draining a node for maintenance.</simpara>
<simpara><literal>PodDisruptionBudget</literal> is an API object that specifies the minimum number or
percentage of replicas that must be up at a time. Setting these in projects can
be helpful during node maintenance (such as scaling a cluster down or a cluster
upgrade) and is only honored on voluntary evictions (not on node failures).</simpara>
<simpara>A <literal>PodDisruptionBudget</literal> object&#8217;s configuration consists of the following key
parts:</simpara>
<itemizedlist>
<listitem>
<simpara>A label selector, which is a label query over a set of pods.</simpara>
</listitem>
<listitem>
<simpara>An availability level, which specifies the minimum number of pods that must be
available simultaneously, either:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>minAvailable</literal> is the number of pods must always be available, even during a disruption.</simpara>
</listitem>
<listitem>
<simpara><literal>maxUnavailable</literal> is the number of pods can be unavailable during a disruption.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara><literal>Available</literal> refers to the number of pods that has condition <literal>Ready=True</literal>.
<literal>Ready=True</literal> refers to the pod that is able to serve requests and should be added to the load balancing pools of all matching services.</simpara>
<simpara>A <literal>maxUnavailable</literal> of <literal>0%</literal> or <literal>0</literal> or a <literal>minAvailable</literal> of <literal>100%</literal> or equal to the number of replicas
is permitted but can block nodes from being drained.</simpara>
</note>
<simpara>You can check for pod disruption budgets across all projects with the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get poddisruptionbudget --all-namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAMESPACE                              NAME                                    MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
openshift-apiserver                    openshift-apiserver-pdb                 N/A             1                 1                     121m
openshift-cloud-controller-manager     aws-cloud-controller-manager            1               N/A               1                     125m
openshift-cloud-credential-operator    pod-identity-webhook                    1               N/A               1                     117m
openshift-cluster-csi-drivers          aws-ebs-csi-driver-controller-pdb       N/A             1                 1                     121m
openshift-cluster-storage-operator     csi-snapshot-controller-pdb             N/A             1                 1                     122m
openshift-cluster-storage-operator     csi-snapshot-webhook-pdb                N/A             1                 1                     122m
openshift-console                      console                                 N/A             1                 1                     116m
#...</programlisting>
</para>
</formalpara>
<simpara>The <literal>PodDisruptionBudget</literal> is considered healthy when there are at least
<literal>minAvailable</literal> pods running in the system. Every pod above that limit can be evicted.</simpara>
<note>
<simpara>Depending on your pod priority and preemption settings,
lower-priority pods might be removed despite their pod disruption budget requirements.</simpara>
</note>
<section xml:id="nodes-pods-pod-disruption-configuring_nodes-pods-configuring">
<title>Specifying the number of pods that must be up with pod disruption budgets</title>
<simpara>You can use a <literal>PodDisruptionBudget</literal> object to specify the minimum number or
percentage of replicas that must be up at a time.</simpara>
<formalpara>
<title>Procedure</title>
<para>To configure a pod disruption budget:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML file with the an object definition similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy/v1 <co xml:id="CO3-1"/>
kind: PodDisruptionBudget
metadata:
  name: my-pdb
spec:
  minAvailable: 2  <co xml:id="CO3-2"/>
  selector:  <co xml:id="CO3-3"/>
    matchLabels:
      name: my-pod</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para><literal>PodDisruptionBudget</literal> is part of the <literal>policy/v1</literal> API group.</para>
</callout>
<callout arearefs="CO3-2">
<para>The minimum number of pods that must be available simultaneously. This can
be either an integer or a string specifying a percentage, for example, <literal>20%</literal>.</para>
</callout>
<callout arearefs="CO3-3">
<para>A label query over a set of resources. The result of <literal>matchLabels</literal> and
<literal>matchExpressions</literal> are logically conjoined. Leave this parameter blank, for example <literal>selector {}</literal>, to select all pods in the project.</para>
</callout>
</calloutlist>
<simpara>Or:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy/v1 <co xml:id="CO4-1"/>
kind: PodDisruptionBudget
metadata:
  name: my-pdb
spec:
  maxUnavailable: 25% <co xml:id="CO4-2"/>
  selector: <co xml:id="CO4-3"/>
    matchLabels:
      name: my-pod</programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para><literal>PodDisruptionBudget</literal> is part of the <literal>policy/v1</literal> API group.</para>
</callout>
<callout arearefs="CO4-2">
<para>The maximum number of pods that can be unavailable simultaneously. This can
be either an integer or a string specifying a percentage, for example, <literal>20%</literal>.</para>
</callout>
<callout arearefs="CO4-3">
<para>A label query over a set of resources. The result of <literal>matchLabels</literal> and
<literal>matchExpressions</literal> are logically conjoined. Leave this parameter blank, for example <literal>selector {}</literal>, to select all pods in the project.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the following command to add the object to project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;/path/to/file&gt; -n &lt;project_name&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="pod-disruption-eviction-policy_nodes-pods-configuring">
<title>Specifying the eviction policy for unhealthy pods</title>
<simpara>When you use pod disruption budgets (PDBs) to specify how many pods must be available simultaneously, you can also define the criteria for how unhealthy pods are considered for eviction.</simpara>
<simpara>You can choose one of the following policies:</simpara>
<variablelist>
<varlistentry>
<term>IfHealthyBudget</term>
<listitem>
<simpara>Running pods that are not yet healthy can be evicted only if the guarded application is not disrupted.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>AlwaysAllow</term>
<listitem>
<simpara>Running pods that are not yet healthy can be evicted regardless of whether the criteria in the pod disruption budget is met. This policy can help evict malfunctioning applications, such as ones with pods stuck in the <literal>CrashLoopBackOff</literal> state or failing to report the <literal>Ready</literal> status.</simpara>
<note>
<simpara>It is recommended to set the <literal>unhealthyPodEvictionPolicy</literal> field to <literal>AlwaysAllow</literal> in the <literal>PodDisruptionBudget</literal> object to support the eviction of misbehaving applications during a node drain. The default behavior is to wait for the application pods to become healthy before the drain can proceed.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file that defines a <literal>PodDisruptionBudget</literal> object and specify the unhealthy pod eviction policy:</simpara>
<formalpara>
<title>Example <literal>pod-disruption-budget.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: my-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      name: my-pod
  unhealthyPodEvictionPolicy: AlwaysAllow <co xml:id="CO5-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>Choose either <literal>IfHealthyBudget</literal> or <literal>AlwaysAllow</literal> as the unhealthy pod eviction policy. The default is <literal>IfHealthyBudget</literal> when the <literal>unhealthyPodEvictionPolicy</literal> field is empty.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>PodDisruptionBudget</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod-disruption-budget.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>With a PDB that has the <literal>AlwaysAllow</literal> unhealthy pod eviction policy set, you can now drain nodes and evict the pods for a malfunctioning application guarded by this PDB.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-enabling-features.xml#nodes-cluster-enabling">Enabling features using feature gates</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/tasks/run-application/configure-pdb/#unhealthy-pod-eviction-policy">Unhealthy Pod Eviction Policy</link> in the Kubernetes documentation</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-configuring-critical_nodes-pods-configuring">
<title>Preventing pod removal using critical pods</title>
<simpara>There are a number of core components that are critical to a fully functional cluster,
but, run on a regular cluster node rather than the master. A cluster might stop working properly if a critical add-on is evicted.</simpara>
<simpara>Pods marked as critical are not allowed to be evicted.</simpara>
<formalpara>
<title>Procedure</title>
<para>To make a pod critical:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a <literal>Pod</literal> spec or edit existing pods to include the <literal>system-cluster-critical</literal> priority class:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pdb
spec:
  template:
    metadata:
      name: critical-pod
    priorityClassName: system-cluster-critical <co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Default priority class for pods that should never be evicted from a node.</para>
</callout>
</calloutlist>
<simpara>Alternatively, you can specify <literal>system-node-critical</literal> for pods that are important to the cluster
but can be removed if necessary.</simpara>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-configuring-reducing_nodes-pods-configuring">
<title>Reducing pod timeouts when using persistent volumes with high file counts</title>
<simpara>If a storage volume contains many files (~1,000,000 or greater), you might experience pod timeouts.</simpara>
<simpara>This can occur because, when volumes are mounted, {product-title} recursively changes the ownership and permissions of the contents of each volume in order to match the <literal>fsGroup</literal> specified in a pod&#8217;s <literal>securityContext</literal>. For large volumes, checking and changing the ownership and permissions can be time consuming, resulting in a very slow pod startup.</simpara>
<simpara>You can reduce this delay by applying one of the following workarounds:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a security context constraint (SCC) to skip the SELinux relabeling for a volume.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>fsGroupChangePolicy</literal> field inside an SCC to control the way that {product-title} checks and manages ownership and permissions for a volume.</simpara>
</listitem>
<listitem>
<simpara>Use the Cluster Resource Override Operator to automatically apply an SCC to skip the SELinux relabeling.</simpara>
</listitem>
<listitem>
<simpara>Use a runtime class to skip the SELinux relabeling for a volume.</simpara>
</listitem>
</itemizedlist>
<simpara>For information, see <link xl:href="https://access.redhat.com/solutions/6221251">When using Persistent Volumes with high file counts in OpenShift, why do pods fail to start or take an excessive amount of time to achieve "Ready" state?</link>.</simpara>
</section>
</section>
<section xml:id="nodes-pods-autoscaling">
<title>Automatically scaling pods with the horizontal pod autoscaler</title>

<simpara>As a developer, you can use a horizontal pod autoscaler (HPA) to
specify how {product-title} should automatically increase or decrease the scale of
a replication controller or deployment configuration, based on metrics collected
from the pods that belong to that replication controller or deployment
configuration. You can create an HPA for any deployment, deployment config, replica set, replication controller, or stateful set.</simpara>
<simpara>For information on scaling pods based on custom metrics, see <link xl:href="../../nodes/cma/nodes-cma-autoscaling-custom.xml#nodes-cma-autoscaling-custom">Automatically scaling pods based on custom metrics</link>.</simpara>
<note>
<simpara>It is recommended to use a <literal>Deployment</literal> object or <literal>ReplicaSet</literal> object unless you need a specific feature or behavior provided by other objects. For more information on
these objects, see <link xl:href="../../applications/deployments/what-deployments-are.xml#what-deployments-are">Understanding deployments</link>.</simpara>
</note>
<section xml:id="nodes-pods-autoscaling-about_nodes-pods-autoscaling">
<title>Understanding horizontal pod autoscalers</title>
<simpara>You can create a horizontal pod autoscaler to specify the minimum and maximum number of pods
you want to run, as well as the CPU utilization or memory utilization your pods should target.</simpara>
<simpara>After you create a horizontal pod autoscaler, {product-title} begins to query the CPU and/or memory resource metrics on the pods.
When these metrics are available, the horizontal pod autoscaler computes
the ratio of the current metric utilization with the desired metric utilization,
and scales up or down accordingly. The query and scaling occurs at a regular interval,
but can take one to two minutes before metrics become available.</simpara>
<simpara>For replication controllers, this scaling corresponds directly to the replicas
of the replication controller. For deployment configurations, scaling corresponds
directly to the replica count of the deployment configuration. Note that autoscaling
applies only to the latest deployment in the <literal>Complete</literal> phase.</simpara>
<simpara>{product-title} automatically accounts for resources and prevents unnecessary autoscaling
during resource spikes, such as during start up. Pods in the <literal>unready</literal> state
have <literal>0 CPU</literal> usage when scaling up and the autoscaler ignores the pods when scaling down.
Pods without known metrics have <literal>0% CPU</literal> usage when scaling up and <literal>100% CPU</literal> when scaling down.
This allows for more stability during the HPA decision. To use this feature, you must configure
readiness checks to determine if a new pod is ready for use.</simpara>
<simpara>To use horizontal pod autoscalers, your cluster administrator must have
properly configured cluster metrics.</simpara>
<section xml:id="_supported_metrics">
<title>Supported metrics</title>
<simpara>The following metrics are supported by horizontal pod autoscalers:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Metrics</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="23.0769*"/>
<colspec colname="col_2" colwidth="38.4615*"/>
<colspec colname="col_3" colwidth="38.4616*"/>
<thead>
<row>
<entry align="left" valign="top">Metric</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">API version</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>CPU utilization</simpara></entry>
<entry align="left" valign="top"><simpara>Number of CPU cores used. Can be used to calculate a percentage of the pod&#8217;s requested CPU.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>autoscaling/v1</literal>, <literal>autoscaling/v2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Memory utilization</simpara></entry>
<entry align="left" valign="top"><simpara>Amount of memory used. Can be used to calculate a percentage of the pod&#8217;s requested memory.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>autoscaling/v2</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<important>
<simpara>For memory-based autoscaling, memory usage must increase and decrease
proportionally to the replica count. On average:</simpara>
<itemizedlist>
<listitem>
<simpara>An increase in replica count must lead to an overall decrease in memory
(working set) usage per-pod.</simpara>
</listitem>
<listitem>
<simpara>A decrease in replica count must lead to an overall increase in per-pod memory
usage.</simpara>
</listitem>
</itemizedlist>
<simpara>Use the {product-title} web console to check the memory behavior of your application
and ensure that your application meets these requirements before using
memory-based autoscaling.</simpara>
</important>
<simpara>The following example shows autoscaling for the <literal>image-registry</literal> <literal>Deployment</literal> object. The initial deployment requires 3 pods. The HPA object increases the minimum to 5. If CPU usage on the pods reaches 75%, the pods increase to 7:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc autoscale deployment/image-registry --min=5 --max=7 --cpu-percent=75</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">horizontalpodautoscaler.autoscaling/image-registry autoscaled</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample HPA for the <literal>image-registry</literal> <literal>Deployment</literal> object with <literal>minReplicas</literal> set to 3</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: image-registry
  namespace: default
spec:
  maxReplicas: 7
  minReplicas: 3
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: image-registry
  targetCPUUtilizationPercentage: 75
status:
  currentReplicas: 5
  desiredReplicas: 0</programlisting>
</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>View the new state of the deployment:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment image-registry</programlisting>
<simpara>There are now 5 pods in the deployment:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             REVISION   DESIRED   CURRENT   TRIGGERED BY
image-registry   1          5         5         config</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-autoscaling-workflow-hpa_nodes-pods-autoscaling">
<title>How does the HPA work?</title>
<simpara>The horizontal pod autoscaler (HPA) extends the concept of pod auto-scaling. The HPA lets you create and manage a group of load-balanced nodes. The HPA automatically increases or decreases the number of pods when a given CPU or memory threshold is crossed.</simpara>
<figure>
<title>High level workflow of the HPA</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/HPAflow.png"/>
</imageobject>
<textobject><phrase>workflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>The HPA is an API resource in the Kubernetes autoscaling API group. The autoscaler works as a control loop with a default of 15 seconds for the sync period. During this period, the controller manager queries the CPU, memory utilization, or both, against what is defined in the YAML file for the HPA.
The controller manager obtains the utilization metrics from the resource metrics API for per-pod resource metrics like CPU or memory, for each pod that is targeted by the HPA.</simpara>
<simpara>If a utilization value target is set, the controller calculates the utilization value as a percentage of the equivalent resource request on the containers in each pod. The controller then takes the average of utilization across all targeted pods and produces a ratio that is used to scale the number of desired replicas.
The HPA is configured to fetch metrics from <literal>metrics.k8s.io</literal>, which is provided by the metrics server. Because of the dynamic nature of metrics evaluation, the number of replicas can fluctuate during scaling for a group of replicas.</simpara>
<note>
<simpara>To implement the HPA, all targeted pods must have a resource request set on their containers.</simpara>
</note>
</section>
<section xml:id="nodes-pods-autoscaling-requests-and-limits-hpa_nodes-pods-autoscaling">
<title>About requests and limits</title>
<simpara>The scheduler uses the resource request that you specify for containers in a pod, to decide which node to place the pod on. The kubelet enforces the resource limit that you specify for a container to ensure that the container is not allowed to use more than the specified limit.
The kubelet also reserves the request amount of that system resource specifically for that container to use.</simpara>
<formalpara>
<title>How to use resource metrics?</title>
<para>In the pod specifications, you must specify the resource requests, such as CPU and memory. The HPA uses this specification to determine the resource utilization and then scales the target up or down.</para>
</formalpara>
<simpara>For example, the HPA object uses the following metric source:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">type: Resource
resource:
  name: cpu
  target:
    type: Utilization
    averageUtilization: 60</programlisting>
<simpara>In this example, the HPA keeps the average utilization of the pods in the scaling target at 60%. Utilization is the ratio between the current resource usage to the requested resource of the pod.</simpara>
</section>
<section xml:id="nodes-pods-autoscaling-best-practices-hpa_nodes-pods-autoscaling">
<title>Best practices</title>
<formalpara>
<title>All pods must have resource requests configured</title>
<para>The HPA makes a scaling decision based on the observed CPU or memory utilization values of pods in an {product-title} cluster. Utilization values are calculated as a percentage of the resource requests of each pod.
Missing resource request values can affect the optimal performance of the HPA.</para>
</formalpara>
<formalpara>
<title>Configure the cool down period</title>
<para>During horizontal pod autoscaling, there might be a rapid scaling of events without a time gap. Configure the cool down period to prevent frequent replica fluctuations.
You can specify a cool down period by configuring the <literal>stabilizationWindowSeconds</literal> field. The stabilization window is used to restrict the fluctuation of replicas count when the metrics used for scaling keep fluctuating.
The autoscaling algorithm uses this window to infer a previous desired state and avoid unwanted changes to workload scale.</para>
</formalpara>
<simpara>For example, a stabilization window is specified for the <literal>scaleDown</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">behavior:
  scaleDown:
    stabilizationWindowSeconds: 300</programlisting>
<simpara>In the above example, all desired states for the past 5 minutes are considered. This approximates a rolling maximum, and avoids having the scaling algorithm frequently remove pods only to trigger recreating an equivalent pod just moments later.</simpara>
<section xml:id="nodes-pods-autoscaling-policies_nodes-pods-autoscaling">
<title>Scaling policies</title>
<simpara>The <literal>autoscaling/v2</literal> API allows you to add <emphasis>scaling policies</emphasis> to a horizontal pod autoscaler. A scaling policy controls how the {product-title} horizontal pod autoscaler (HPA) scales pods. Scaling policies allow you to restrict the rate that HPAs scale pods up or down by setting a specific number or specific percentage to scale in a specified period of time. You can also define a <emphasis>stabilization window</emphasis>, which uses previously computed desired states to control scaling if the metrics are fluctuating. You can create multiple policies for the same scaling direction, and determine which policy is used, based on the amount of change. You can also restrict the scaling by timed iterations. The HPA scales pods during an iteration, then performs scaling, as needed, in further iterations.</simpara>
<formalpara>
<title>Sample HPA object with a scaling policy</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: hpa-resource-metrics-memory
  namespace: default
spec:
  behavior:
    scaleDown: <co xml:id="CO7-1"/>
      policies: <co xml:id="CO7-2"/>
      - type: Pods <co xml:id="CO7-3"/>
        value: 4 <co xml:id="CO7-4"/>
        periodSeconds: 60 <co xml:id="CO7-5"/>
      - type: Percent
        value: 10 <co xml:id="CO7-6"/>
        periodSeconds: 60
      selectPolicy: Min <co xml:id="CO7-7"/>
      stabilizationWindowSeconds: 300 <co xml:id="CO7-8"/>
    scaleUp: <co xml:id="CO7-9"/>
      policies:
      - type: Pods
        value: 5 <co xml:id="CO7-10"/>
        periodSeconds: 70
      - type: Percent
        value: 12 <co xml:id="CO7-11"/>
        periodSeconds: 80
      selectPolicy: Max
      stabilizationWindowSeconds: 0
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para>Specifies the direction for the scaling policy, either <literal>scaleDown</literal> or <literal>scaleUp</literal>. This example creates a policy for scaling down.</para>
</callout>
<callout arearefs="CO7-2">
<para>Defines the scaling policy.</para>
</callout>
<callout arearefs="CO7-3">
<para>Determines if the policy scales by a specific number of pods or a percentage of pods during each iteration. The default value is <literal>pods</literal>.</para>
</callout>
<callout arearefs="CO7-4">
<para>Limits the amount of scaling, either the number of pods or percentage of pods, during each iteration. There is no default value for scaling down by number of pods.</para>
</callout>
<callout arearefs="CO7-5">
<para>Determines the length of a scaling iteration. The default value is <literal>15</literal> seconds.</para>
</callout>
<callout arearefs="CO7-6">
<para>The default value for scaling down by percentage is 100%.</para>
</callout>
<callout arearefs="CO7-7">
<para>Determines which policy to use first, if multiple policies are defined. Specify <literal>Max</literal> to use the policy that allows the highest amount of change, <literal>Min</literal> to use the policy that allows the lowest amount of change, or <literal>Disabled</literal> to prevent the HPA from scaling in that policy direction. The default value is <literal>Max</literal>.</para>
</callout>
<callout arearefs="CO7-8">
<para>Determines the time period the HPA should look back at desired states. The default value is <literal>0</literal>.</para>
</callout>
<callout arearefs="CO7-9">
<para>This example creates a policy for scaling up.</para>
</callout>
<callout arearefs="CO7-10">
<para>Limits the amount of scaling up by the number of pods. The default value for scaling up the number of pods is 4%.</para>
</callout>
<callout arearefs="CO7-11">
<para>Limits the amount of scaling up by the percentage of pods. The default value for scaling up by percentage is 100%.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example policy for scaling down</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: hpa-resource-metrics-memory
  namespace: default
spec:
...
  minReplicas: 20
...
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Pods
        value: 4
        periodSeconds: 30
      - type: Percent
        value: 10
        periodSeconds: 60
      selectPolicy: Max
    scaleUp:
      selectPolicy: Disabled</programlisting>
</para>
</formalpara>
<simpara>In this example, when the number of pods is greater than 40, the percent-based policy is used for scaling down, as that policy results in a larger change, as required by the <literal>selectPolicy</literal>.</simpara>
<simpara>If there are 80 pod replicas, in the first iteration the HPA reduces the pods by 8, which is 10% of the 80 pods (based on the <literal>type: Percent</literal> and <literal>value: 10</literal> parameters), over one minute (<literal>periodSeconds: 60</literal>). For the next iteration, the number of pods is 72. The HPA calculates that 10% of the remaining pods is 7.2, which it rounds up to 8 and scales down 8 pods. On each subsequent iteration, the number of pods to be scaled is re-calculated based on the number of remaining pods. When the number of pods falls below 40, the pods-based policy is applied, because the pod-based number is greater than the percent-based number. The HPA reduces 4 pods at a time (<literal>type: Pods</literal> and <literal>value: 4</literal>), over 30 seconds (<literal>periodSeconds: 30</literal>), until there are 20 replicas remaining (<literal>minReplicas</literal>).</simpara>
<simpara>The <literal>selectPolicy: Disabled</literal> parameter prevents the HPA from scaling up the pods. You can manually scale up by adjusting the number of replicas in the replica set or deployment set, if needed.</simpara>
<simpara>If set, you can view the scaling policy by using the <literal>oc edit</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit hpa hpa-resource-metrics-memory</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  annotations:
    autoscaling.alpha.kubernetes.io/behavior:\
'{"ScaleUp":{"StabilizationWindowSeconds":0,"SelectPolicy":"Max","Policies":[{"Type":"Pods","Value":4,"PeriodSeconds":15},{"Type":"Percent","Value":100,"PeriodSeconds":15}]},\
"ScaleDown":{"StabilizationWindowSeconds":300,"SelectPolicy":"Min","Policies":[{"Type":"Pods","Value":4,"PeriodSeconds":60},{"Type":"Percent","Value":10,"PeriodSeconds":60}]}}'
...</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="nodes-pods-autoscaling-creating-web-console_nodes-pods-autoscaling">
<title>Creating a horizontal pod autoscaler by using the web console</title>
<simpara>From the web console, you can create a horizontal pod autoscaler (HPA) that specifies the minimum and maximum number of pods you want to run on a <literal>Deployment</literal> or <literal>DeploymentConfig</literal> object. You can also define the amount of CPU or memory usage that your pods should target.</simpara>
<note>
<simpara>An HPA cannot be added to deployments that are part of an Operator-backed service, Knative service, or Helm chart.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To create an HPA in the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <emphasis role="strong">Topology</emphasis> view, click the node to reveal the side pane.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Actions</emphasis> drop-down list, select <emphasis role="strong">Add HorizontalPodAutoscaler</emphasis> to open the <emphasis role="strong">Add HorizontalPodAutoscaler</emphasis> form.</simpara>
<figure>
<title>Add HorizontalPodAutoscaler</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/node-add-hpa-action.png"/>
</imageobject>
<textobject><phrase>Add HorizontalPodAutoscaler form</phrase></textobject>
</mediaobject>
</figure>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Add HorizontalPodAutoscaler</emphasis> form, define the name, minimum and maximum pod limits, the CPU and memory usage, and click <emphasis role="strong">Save</emphasis>.</simpara>
<note>
<simpara>If any of the values for CPU and memory usage are missing, a warning is displayed.</simpara>
</note>
</listitem>
</orderedlist>
<simpara>To edit an HPA in the web console:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <emphasis role="strong">Topology</emphasis> view, click the node to reveal the side pane.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Actions</emphasis> drop-down list, select <emphasis role="strong">Edit HorizontalPodAutoscaler</emphasis> to open the <emphasis role="strong">Edit Horizontal Pod Autoscaler</emphasis> form.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Edit Horizontal Pod Autoscaler</emphasis> form, edit the minimum and maximum pod limits and the CPU and memory usage, and click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>While creating or editing the horizontal pod autoscaler in the web console, you can switch from <emphasis role="strong">Form view</emphasis> to <emphasis role="strong">YAML view</emphasis>.</simpara>
</note>
<simpara>To remove an HPA in the web console:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <emphasis role="strong">Topology</emphasis> view, click the node to reveal the side panel.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Actions</emphasis> drop-down list, select <emphasis role="strong">Remove HorizontalPodAutoscaler</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation pop-up window, click <emphasis role="strong">Remove</emphasis> to remove the HPA.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-autoscaling-creating-cpu_nodes-pods-autoscaling">
<title>Creating a horizontal pod autoscaler for CPU utilization by using the CLI</title>
<simpara>Using the {product-title} CLI, you can create a horizontal pod autoscaler (HPA) to automatically scale an existing <literal>Deployment</literal>, <literal>DeploymentConfig</literal>, <literal>ReplicaSet</literal>, <literal>ReplicationController</literal>, or <literal>StatefulSet</literal> object. The HPA scales the pods associated with that object to maintain the CPU usage you specify.</simpara>
<note>
<simpara>It is recommended to use a <literal>Deployment</literal> object or <literal>ReplicaSet</literal> object unless you need a specific feature or behavior provided by other objects.</simpara>
</note>
<simpara>The HPA increases and decreases the number of replicas between the minimum and maximum numbers to maintain the specified CPU utilization across all pods.</simpara>
<simpara>When autoscaling for CPU utilization, you can use the <literal>oc autoscale</literal> command and specify the minimum and maximum number of pods you want to run at any given time and the average CPU utilization your pods should target. If you do not specify a minimum, the pods are given default values from the {product-title} server.</simpara>
<simpara>To autoscale for a specific CPU value, create a <literal>HorizontalPodAutoscaler</literal> object with the target CPU and pod limits.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>To use horizontal pod autoscalers, your cluster administrator must have properly configured cluster metrics.
You can use the <literal>oc describe PodMetrics &lt;pod-name&gt;</literal> command to determine if metrics are configured. If metrics are
configured, the output appears similar to the following, with <literal>Cpu</literal> and <literal>Memory</literal> displayed under <literal>Usage</literal>.</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe PodMetrics openshift-kube-scheduler-ip-10-0-135-131.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:         openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Namespace:    openshift-kube-scheduler
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  metrics.k8s.io/v1beta1
Containers:
  Name:  wait-for-host-port
  Usage:
    Memory:  0
  Name:      scheduler
  Usage:
    Cpu:     8m
    Memory:  45440Ki
Kind:        PodMetrics
Metadata:
  Creation Timestamp:  2019-05-23T18:47:56Z
  Self Link:           /apis/metrics.k8s.io/v1beta1/namespaces/openshift-kube-scheduler/pods/openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Timestamp:             2019-05-23T18:47:56Z
Window:                1m0s
Events:                &lt;none&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>To create a horizontal pod autoscaler for CPU utilization:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Perform one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>To scale based on the percent of CPU utilization, create a <literal>HorizontalPodAutoscaler</literal> object for an existing object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc autoscale &lt;object_type&gt;/&lt;name&gt; \<co xml:id="CO8-1"/>
  --min &lt;number&gt; \<co xml:id="CO8-2"/>
  --max &lt;number&gt; \<co xml:id="CO8-3"/>
  --cpu-percent=&lt;percent&gt; <co xml:id="CO8-4"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Specify the type and name of the object to autoscale. The object must exist and be a <literal>Deployment</literal>, <literal>DeploymentConfig</literal>/<literal>dc</literal>, <literal>ReplicaSet</literal>/<literal>rs</literal>, <literal>ReplicationController</literal>/<literal>rc</literal>, or <literal>StatefulSet</literal>.</para>
</callout>
<callout arearefs="CO8-2">
<para>Optionally, specify the minimum number of replicas when scaling down.</para>
</callout>
<callout arearefs="CO8-3">
<para>Specify the maximum number of replicas when scaling up.</para>
</callout>
<callout arearefs="CO8-4">
<para>Specify the target average CPU utilization over all the pods, represented as a percent of requested CPU. If not specified or negative, a default autoscaling policy is used.</para>
</callout>
</calloutlist>
<simpara>For example, the following command shows autoscaling for the <literal>image-registry</literal> <literal>Deployment</literal> object. The initial deployment requires 3 pods. The HPA object increases the minimum to 5. If CPU usage on the pods reaches 75%, the pods will increase to 7:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc autoscale deployment/image-registry --min=5 --max=7 --cpu-percent=75</programlisting>
</listitem>
<listitem>
<simpara>To scale for a specific CPU value, create a YAML file similar to the following for an existing object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2 <co xml:id="CO9-1"/>
kind: HorizontalPodAutoscaler
metadata:
  name: cpu-autoscale <co xml:id="CO9-2"/>
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1 <co xml:id="CO9-3"/>
    kind: Deployment <co xml:id="CO9-4"/>
    name: example <co xml:id="CO9-5"/>
  minReplicas: 1 <co xml:id="CO9-6"/>
  maxReplicas: 10 <co xml:id="CO9-7"/>
  metrics: <co xml:id="CO9-8"/>
  - type: Resource
    resource:
      name: cpu <co xml:id="CO9-9"/>
      target:
        type: AverageValue <co xml:id="CO9-10"/>
        averageValue: 500m <co xml:id="CO9-11"/></programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>Use the <literal>autoscaling/v2</literal> API.</para>
</callout>
<callout arearefs="CO9-2">
<para>Specify a name for this horizontal pod autoscaler object.</para>
</callout>
<callout arearefs="CO9-3">
<para>Specify the API version of the object to scale:</para>
<itemizedlist>
<listitem>
<simpara>For a <literal>Deployment</literal>, <literal>ReplicaSet</literal>, <literal>Statefulset</literal> object, use <literal>apps/v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a <literal>ReplicationController</literal>, use <literal>v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a <literal>DeploymentConfig</literal>, use <literal>apps.openshift.io/v1</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO9-4">
<para>Specify the type of object. The object must be a <literal>Deployment</literal>, <literal>DeploymentConfig</literal>/<literal>dc</literal>, <literal>ReplicaSet</literal>/<literal>rs</literal>, <literal>ReplicationController</literal>/<literal>rc</literal>, or <literal>StatefulSet</literal>.</para>
</callout>
<callout arearefs="CO9-5">
<para>Specify the name of the object to scale. The object must exist.</para>
</callout>
<callout arearefs="CO9-6">
<para>Specify the minimum number of replicas when scaling down.</para>
</callout>
<callout arearefs="CO9-7">
<para>Specify the maximum number of replicas when scaling up.</para>
</callout>
<callout arearefs="CO9-8">
<para>Use the <literal>metrics</literal> parameter for memory utilization.</para>
</callout>
<callout arearefs="CO9-9">
<para>Specify <literal>cpu</literal> for CPU utilization.</para>
</callout>
<callout arearefs="CO9-10">
<para>Set to <literal>AverageValue</literal>.</para>
</callout>
<callout arearefs="CO9-11">
<para>Set to <literal>averageValue</literal> with the targeted CPU value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the horizontal pod autoscaler:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Verify that the horizontal pod autoscaler was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get hpa cpu-autoscale</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            REFERENCE            TARGETS         MINPODS   MAXPODS   REPLICAS   AGE
cpu-autoscale   Deployment/example   173m/500m       1         10        1          20m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-autoscaling-creating-memory_nodes-pods-autoscaling">
<title>Creating a horizontal pod autoscaler object for memory utilization by using the CLI</title>
<simpara>Using the {product-title} CLI, you can create a horizontal pod autoscaler (HPA) to automatically scale an existing
<literal>Deployment</literal>, <literal>DeploymentConfig</literal>, <literal>ReplicaSet</literal>, <literal>ReplicationController</literal>, or <literal>StatefulSet</literal> object. The HPA
scales the pods associated with that object to maintain the average memory utilization you specify, either a direct value or a percentage
of requested memory.</simpara>
<note>
<simpara>It is recommended to use a <literal>Deployment</literal> object or <literal>ReplicaSet</literal> object unless you need a specific feature or behavior provided by other objects.</simpara>
</note>
<simpara>The HPA increases and decreases the number of replicas between the minimum and maximum numbers to maintain
the specified memory utilization across all pods.</simpara>
<simpara>For memory utilization, you can specify the minimum and maximum number of pods and the average memory utilization
your pods should target. If you do not specify a minimum, the pods are given default values from the {product-title} server.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>To use horizontal pod autoscalers, your cluster administrator must have properly configured cluster metrics.
You can use the <literal>oc describe PodMetrics &lt;pod-name&gt;</literal> command to determine if metrics are configured. If metrics are
configured, the output appears similar to the following, with <literal>Cpu</literal> and <literal>Memory</literal> displayed under <literal>Usage</literal>.</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe PodMetrics openshift-kube-scheduler-ip-10-0-129-223.compute.internal -n openshift-kube-scheduler</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:         openshift-kube-scheduler-ip-10-0-129-223.compute.internal
Namespace:    openshift-kube-scheduler
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  metrics.k8s.io/v1beta1
Containers:
  Name:  wait-for-host-port
  Usage:
    Cpu:     0
    Memory:  0
  Name:      scheduler
  Usage:
    Cpu:     8m
    Memory:  45440Ki
Kind:        PodMetrics
Metadata:
  Creation Timestamp:  2020-02-14T22:21:14Z
  Self Link:           /apis/metrics.k8s.io/v1beta1/namespaces/openshift-kube-scheduler/pods/openshift-kube-scheduler-ip-10-0-129-223.compute.internal
Timestamp:             2020-02-14T22:21:14Z
Window:                5m0s
Events:                &lt;none&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>To create a horizontal pod autoscaler for memory utilization:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML file for one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>To scale for a specific memory value, create a <literal>HorizontalPodAutoscaler</literal> object similar to the following for an existing object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2 <co xml:id="CO10-1"/>
kind: HorizontalPodAutoscaler
metadata:
  name: hpa-resource-metrics-memory <co xml:id="CO10-2"/>
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1 <co xml:id="CO10-3"/>
    kind: Deployment <co xml:id="CO10-4"/>
    name: example <co xml:id="CO10-5"/>
  minReplicas: 1 <co xml:id="CO10-6"/>
  maxReplicas: 10 <co xml:id="CO10-7"/>
  metrics: <co xml:id="CO10-8"/>
  - type: Resource
    resource:
      name: memory <co xml:id="CO10-9"/>
      target:
        type: AverageValue <co xml:id="CO10-10"/>
        averageValue: 500Mi <co xml:id="CO10-11"/>
  behavior: <co xml:id="CO10-12"/>
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Pods
        value: 4
        periodSeconds: 60
      - type: Percent
        value: 10
        periodSeconds: 60
      selectPolicy: Max</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>Use the <literal>autoscaling/v2</literal> API.</para>
</callout>
<callout arearefs="CO10-2">
<para>Specify a name for this horizontal pod autoscaler object.</para>
</callout>
<callout arearefs="CO10-3">
<para>Specify the API version of the object to scale:</para>
<itemizedlist>
<listitem>
<simpara>For a <literal>Deployment</literal>, <literal>ReplicaSet</literal>, or <literal>Statefulset</literal> object, use <literal>apps/v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a <literal>ReplicationController</literal>, use <literal>v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a <literal>DeploymentConfig</literal>, use <literal>apps.openshift.io/v1</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO10-4">
<para>Specify the type of object. The object must be a <literal>Deployment</literal>, <literal>DeploymentConfig</literal>,
<literal>ReplicaSet</literal>, <literal>ReplicationController</literal>, or <literal>StatefulSet</literal>.</para>
</callout>
<callout arearefs="CO10-5">
<para>Specify the name of the object to scale. The object must exist.</para>
</callout>
<callout arearefs="CO10-6">
<para>Specify the minimum number of replicas when scaling down.</para>
</callout>
<callout arearefs="CO10-7">
<para>Specify the maximum number of replicas when scaling up.</para>
</callout>
<callout arearefs="CO10-8">
<para>Use the <literal>metrics</literal> parameter for memory utilization.</para>
</callout>
<callout arearefs="CO10-9">
<para>Specify <literal>memory</literal> for memory utilization.</para>
</callout>
<callout arearefs="CO10-10">
<para>Set the type to <literal>AverageValue</literal>.</para>
</callout>
<callout arearefs="CO10-11">
<para>Specify <literal>averageValue</literal> and a specific memory value.</para>
</callout>
<callout arearefs="CO10-12">
<para>Optional: Specify a scaling policy to control the rate of scaling up or down.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To scale for a percentage, create a <literal>HorizontalPodAutoscaler</literal> object similar to the following for an existing object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling/v2 <co xml:id="CO11-1"/>
kind: HorizontalPodAutoscaler
metadata:
  name: memory-autoscale <co xml:id="CO11-2"/>
  namespace: default
spec:
  scaleTargetRef:
    apiVersion: apps/v1 <co xml:id="CO11-3"/>
    kind: Deployment <co xml:id="CO11-4"/>
    name: example <co xml:id="CO11-5"/>
  minReplicas: 1 <co xml:id="CO11-6"/>
  maxReplicas: 10 <co xml:id="CO11-7"/>
  metrics: <co xml:id="CO11-8"/>
  - type: Resource
    resource:
      name: memory <co xml:id="CO11-9"/>
      target:
        type: Utilization <co xml:id="CO11-10"/>
        averageUtilization: 50 <co xml:id="CO11-11"/>
  behavior: <co xml:id="CO11-12"/>
    scaleUp:
      stabilizationWindowSeconds: 180
      policies:
      - type: Pods
        value: 6
        periodSeconds: 120
      - type: Percent
        value: 10
        periodSeconds: 120
      selectPolicy: Max</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Use the <literal>autoscaling/v2</literal> API.</para>
</callout>
<callout arearefs="CO11-2">
<para>Specify a name for this horizontal pod autoscaler object.</para>
</callout>
<callout arearefs="CO11-3">
<para>Specify the API version of the object to scale:</para>
<itemizedlist>
<listitem>
<simpara>For a ReplicationController, use <literal>v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a DeploymentConfig, use <literal>apps.openshift.io/v1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For a Deployment, ReplicaSet, Statefulset object, use <literal>apps/v1</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO11-4">
<para>Specify the type of object. The object must be a <literal>Deployment</literal>, <literal>DeploymentConfig</literal>,
<literal>ReplicaSet</literal>, <literal>ReplicationController</literal>, or <literal>StatefulSet</literal>.</para>
</callout>
<callout arearefs="CO11-5">
<para>Specify the name of the object to scale. The object must exist.</para>
</callout>
<callout arearefs="CO11-6">
<para>Specify the minimum number of replicas when scaling down.</para>
</callout>
<callout arearefs="CO11-7">
<para>Specify the maximum number of replicas when scaling up.</para>
</callout>
<callout arearefs="CO11-8">
<para>Use the <literal>metrics</literal> parameter for memory utilization.</para>
</callout>
<callout arearefs="CO11-9">
<para>Specify <literal>memory</literal> for memory utilization.</para>
</callout>
<callout arearefs="CO11-10">
<para>Set to <literal>Utilization</literal>.</para>
</callout>
<callout arearefs="CO11-11">
<para>Specify <literal>averageUtilization</literal> and a target average memory utilization over all the pods,
represented as a percent of requested memory. The target pods must have memory requests configured.</para>
</callout>
<callout arearefs="CO11-12">
<para>Optional: Specify a scaling policy to control the rate of scaling up or down.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create the horizontal pod autoscaler:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f hpa.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">horizontalpodautoscaler.autoscaling/hpa-resource-metrics-memory created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the horizontal pod autoscaler was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get hpa hpa-resource-metrics-memory</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          REFERENCE            TARGETS         MINPODS   MAXPODS   REPLICAS   AGE
hpa-resource-metrics-memory   Deployment/example   2441216/500Mi   1         10        1          20m</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe hpa hpa-resource-metrics-memory</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:                        hpa-resource-metrics-memory
Namespace:                   default
Labels:                      &lt;none&gt;
Annotations:                 &lt;none&gt;
CreationTimestamp:           Wed, 04 Mar 2020 16:31:37 +0530
Reference:                   Deployment/example
Metrics:                     ( current / target )
  resource memory on pods:   2441216 / 500Mi
Min replicas:                1
Max replicas:                10
ReplicationController pods:  1 current / 1 desired
Conditions:
  Type            Status  Reason              Message
  ----            ------  ------              -------
  AbleToScale     True    ReadyForNewScale    recommended size matches current size
  ScalingActive   True    ValidMetricFound    the HPA was able to successfully calculate a replica count from memory resource
  ScalingLimited  False   DesiredWithinRange  the desired count is within the acceptable range
Events:
  Type     Reason                   Age                 From                       Message
  ----     ------                   ----                ----                       -------
  Normal   SuccessfulRescale        6m34s               horizontal-pod-autoscaler  New size: 1; reason: All metrics below target</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-autoscaling-status-about_nodes-pods-autoscaling">
<title>Understanding horizontal pod autoscaler status conditions by using the CLI</title>
<simpara>You can use the status conditions set to determine
whether or not the horizontal pod autoscaler (HPA) is able to scale and whether or not it is currently restricted
in any way.</simpara>
<simpara>The HPA status conditions are available with the <literal>v2</literal> version of the
autoscaling API.</simpara>
<simpara>The HPA responds with the following status conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>AbleToScale</literal> condition indicates whether HPA is able to fetch and update metrics, as well as whether any backoff-related conditions could prevent scaling.</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>True</literal> condition indicates scaling is allowed.</simpara>
</listitem>
<listitem>
<simpara>A <literal>False</literal> condition indicates scaling is not allowed for the reason specified.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <literal>ScalingActive</literal> condition indicates whether the HPA is enabled (for example, the replica count of the target is not zero) and is able to calculate desired metrics.</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>True</literal> condition indicates metrics is working properly.</simpara>
</listitem>
<listitem>
<simpara>A <literal>False</literal> condition generally indicates a problem with fetching metrics.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <literal>ScalingLimited</literal> condition indicates that the desired scale was capped by the maximum or minimum of the horizontal pod autoscaler.</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>True</literal> condition indicates that you need to raise or lower the minimum or maximum replica count in order to scale.</simpara>
</listitem>
<listitem>
<simpara>A <literal>False</literal> condition indicates that the requested scaling is allowed.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe hpa cm-test</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  "http_requests" on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions: <co xml:id="CO12-1"/>
  Type              Status    Reason              Message
  ----              ------    ------              -------
  AbleToScale       True      ReadyForNewScale    the last scale time was sufficiently old as to warrant a new scale
  ScalingActive     True      ValidMetricFound    the HPA was able to successfully calculate a replica count from pods metric http_request
  ScalingLimited    False     DesiredWithinRange  the desired replica count is within the acceptable range
Events:</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>The horizontal pod autoscaler status messages.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The following is an example of a pod that is unable to scale:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Conditions:
  Type         Status  Reason          Message
  ----         ------  ------          -------
  AbleToScale  False   FailedGetScale  the HPA controller was unable to get the target's current scale: no matches for kind "ReplicationController" in group "apps"
Events:
  Type     Reason          Age               From                       Message
  ----     ------          ----              ----                       -------
  Warning  FailedGetScale  6s (x3 over 36s)  horizontal-pod-autoscaler  no matches for kind "ReplicationController" in group "apps"</programlisting>
</para>
</formalpara>
<simpara>The following is an example of a pod that could not obtain the needed metrics for scaling:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Conditions:
  Type                  Status    Reason                    Message
  ----                  ------    ------                    -------
  AbleToScale           True     SucceededGetScale          the HPA controller was able to get the target's current scale
  ScalingActive         False    FailedGetResourceMetric    the HPA was unable to compute the replica count: failed to get cpu utilization: unable to get metrics for resource cpu: no metrics returned from resource metrics API</programlisting>
</para>
</formalpara>
<simpara>The following is an example of a pod where the requested autoscaling was less than the required minimums:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Conditions:
  Type              Status    Reason              Message
  ----              ------    ------              -------
  AbleToScale       True      ReadyForNewScale    the last scale time was sufficiently old as to warrant a new scale
  ScalingActive     True      ValidMetricFound    the HPA was able to successfully calculate a replica count from pods metric http_request
  ScalingLimited    False     DesiredWithinRange  the desired replica count is within the acceptable range</programlisting>
</para>
</formalpara>
<section xml:id="nodes-pods-autoscaling-status-viewing_nodes-pods-autoscaling">
<title>Viewing horizontal pod autoscaler status conditions by using the CLI</title>
<simpara>You can view the status conditions set on a pod by the horizontal pod autoscaler (HPA).</simpara>
<note>
<simpara>The horizontal pod autoscaler status conditions are available with the <literal>v2</literal> version of the autoscaling API.</simpara>
</note>
<formalpara>
<title>Prerequisites</title>
<para>To use horizontal pod autoscalers, your cluster administrator must have properly configured cluster metrics.
You can use the <literal>oc describe PodMetrics &lt;pod-name&gt;</literal> command to determine if metrics are configured.  If metrics are
configured, the output appears similar to the following, with <literal>Cpu</literal> and <literal>Memory</literal> displayed under <literal>Usage</literal>.</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe PodMetrics openshift-kube-scheduler-ip-10-0-135-131.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Namespace:    openshift-kube-scheduler
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  metrics.k8s.io/v1beta1
Containers:
  Name:  wait-for-host-port
  Usage:
    Memory:  0
  Name:      scheduler
  Usage:
    Cpu:     8m
    Memory:  45440Ki
Kind:        PodMetrics
Metadata:
  Creation Timestamp:  2019-05-23T18:47:56Z
  Self Link:           /apis/metrics.k8s.io/v1beta1/namespaces/openshift-kube-scheduler/pods/openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Timestamp:             2019-05-23T18:47:56Z
Window:                1m0s
Events:                &lt;none&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>To view the status conditions on a pod, use the following command with the name of the pod:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe hpa &lt;pod-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe hpa cm-test</programlisting>
<simpara>The conditions appear in the <literal>Conditions</literal> field in the output.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  "http_requests" on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions: <co xml:id="CO13-1"/>
  Type              Status    Reason              Message
  ----              ------    ------              -------
  AbleToScale       True      ReadyForNewScale    the last scale time was sufficiently old as to warrant a new scale
  ScalingActive     True      ValidMetricFound    the HPA was able to successfully calculate a replica count from pods metric http_request
  ScalingLimited    False     DesiredWithinRange  the desired replica count is within the acceptable range</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="_additional_resources_2" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../applications/deployments/what-deployments-are.xml#what-deployments-are">Understanding deployments and deployment configs</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://cloud.redhat.com/blog/horizontal-pod-autoscaling-of-quarkus-application-based-on-memory-utilization">Horizontal Pod Autoscaling of Quarkus Application Based on Memory Utilization</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-vpa">
<title>Automatically adjust pod resource levels with the vertical pod autoscaler</title>

<simpara>The {product-title} Vertical Pod Autoscaler Operator (VPA) automatically reviews the historic and current CPU and memory resources for containers in pods and can update the resource limits and requests based on the usage values it learns. The VPA uses individual custom resources (CR) to update all of the pods associated with a workload object, such as a <literal>Deployment</literal>, <literal>DeploymentConfig</literal>, <literal>StatefulSet</literal>, <literal>Job</literal>, <literal>DaemonSet</literal>, <literal>ReplicaSet</literal>, or <literal>ReplicationController</literal>, in a project.</simpara>
<simpara>The VPA helps you to understand the optimal CPU and memory usage for your pods and can automatically maintain pod resources through the pod lifecycle.</simpara>
<section xml:id="nodes-pods-vertical-autoscaler-about_nodes-pods-vertical-autoscaler">
<title>About the Vertical Pod Autoscaler Operator</title>
<simpara>The Vertical Pod Autoscaler Operator (VPA) is implemented as an API resource and a custom resource (CR). The CR determines the actions that the VPA Operator should take with the pods associated with a specific workload object, such as a daemon set, replication controller, and so forth, in a project.</simpara>
<simpara>The VPA Operator consists of three components, each of which has its own pod in the VPA namespace:</simpara>
<variablelist>
<varlistentry>
<term>Recommender</term>
<listitem>
<simpara>The VPA recommender monitors the current and past resource consumption and, based on this data, determines the optimal CPU and memory resources for the pods in the associated workload object.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Updater</term>
<listitem>
<simpara>The VPA updater checks if the pods in the associated workload object have the correct resources. If the resources are correct, the updater takes no action. If the resources are not correct, the updater kills the pod so that they can be recreated by their controllers with the updated requests.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Admission controller</term>
<listitem>
<simpara>The VPA admission controller sets the correct resource requests on each new pod in the associated workload object, whether the pod is new or was recreated by its controller due to the VPA updater actions.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>You can use the default recommender or use your own alternative recommender to autoscale based on your own algorithms.</simpara>
<simpara>The default recommender automatically computes historic and current CPU and memory usage for the containers in those pods and uses this data to determine optimized resource limits and requests to ensure that these pods are operating efficiently at all times. For example, the default recommender suggests reduced resources for pods that are requesting more resources than they are using and increased resources for pods that are not requesting enough.</simpara>
<simpara>The VPA then automatically deletes any pods that are out of alignment with these recommendations one at a time, so that your applications can continue to serve requests with no downtime. The workload objects then re-deploy the pods with the original resource limits and requests. The VPA uses a mutating admission webhook to update the pods with optimized resource limits and requests before the pods are admitted to a node. If you do not want the VPA to delete pods, you can view the VPA resource limits and requests and manually update the pods as needed.</simpara>
<note>
<simpara>By default, workload objects must specify a minimum of two replicas in order for the VPA to automatically delete their pods. Workload objects that specify fewer replicas than this minimum are not deleted. If you manually delete these pods, when the workload object redeploys the pods, the VPA does update the new pods with its recommendations. You can change this minimum by modifying the <literal>VerticalPodAutoscalerController</literal> object as shown shown in <emphasis>Changing the VPA minimum value</emphasis>.</simpara>
</note>
<simpara>For example, if you have a pod that uses 50% of the CPU but only requests 10%, the VPA determines that the pod is consuming more CPU than requested and deletes the pod. The workload object, such as replica set, restarts the pods and the VPA updates the new pod with its recommended resources.</simpara>
<simpara>For developers, you can use the VPA to help ensure your pods stay up during periods of high demand by scheduling pods onto nodes that have appropriate resources for each pod.</simpara>
<simpara>Administrators can use the VPA to better utilize cluster resources, such as preventing pods from reserving more CPU resources than needed. The VPA monitors the resources that workloads are actually using and adjusts the resource requirements so capacity is available to other workloads. The VPA also maintains the ratios between limits and requests that are specified in initial container configuration.</simpara>
<note>
<simpara>If you stop running the VPA or delete a specific VPA CR in your cluster, the resource requests for the pods already modified by the VPA do not change. Any new pods get the resources defined in the workload object, not the previous recommendations made by the VPA.</simpara>
</note>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-install_nodes-pods-vertical-autoscaler">
<title>Installing the Vertical Pod Autoscaler Operator</title>
<simpara>You can use the {product-title} web console to install the Vertical Pod Autoscaler Operator (VPA).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the {product-title} web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose  <emphasis role="strong">VerticalPodAutoscaler</emphasis> from the list of available Operators, and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that the <emphasis role="strong">Operator recommended namespace</emphasis> option
is selected. This installs the Operator in the mandatory <literal>openshift-vertical-pod-autoscaler</literal> namespace, which
is automatically created if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify the installation by listing the VPA Operator components:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <literal>openshift-vertical-pod-autoscaler</literal> project from the drop-down menu and verify that there are four pods running.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Deployments</emphasis> to verify that there are four deployments running.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional. Verify the installation in the {product-title} CLI using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n openshift-vertical-pod-autoscaler</programlisting>
<simpara>The output shows four pods and four deplyoments:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                    READY   STATUS    RESTARTS   AGE
pod/vertical-pod-autoscaler-operator-85b4569c47-2gmhc   1/1     Running   0          3m13s
pod/vpa-admission-plugin-default-67644fc87f-xq7k9       1/1     Running   0          2m56s
pod/vpa-recommender-default-7c54764b59-8gckt            1/1     Running   0          2m56s
pod/vpa-updater-default-7f6cc87858-47vw9                1/1     Running   0          2m56s

NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
service/vpa-webhook   ClusterIP   172.30.53.206   &lt;none&gt;        443/TCP   2m56s

NAME                                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/vertical-pod-autoscaler-operator   1/1     1            1           3m13s
deployment.apps/vpa-admission-plugin-default       1/1     1            1           2m56s
deployment.apps/vpa-recommender-default            1/1     1            1           2m56s
deployment.apps/vpa-updater-default                1/1     1            1           2m56s

NAME                                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/vertical-pod-autoscaler-operator-85b4569c47   1         1         1       3m13s
replicaset.apps/vpa-admission-plugin-default-67644fc87f       1         1         1       2m56s
replicaset.apps/vpa-recommender-default-7c54764b59            1         1         1       2m56s
replicaset.apps/vpa-updater-default-7f6cc87858                1         1         1       2m56s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-using-about_nodes-pods-vertical-autoscaler">
<title>About Using the Vertical Pod Autoscaler Operator</title>
<simpara>To use the Vertical Pod Autoscaler Operator (VPA), you create a VPA custom resource (CR) for a workload object in your cluster. The VPA learns and applies the optimal CPU and memory resources for the pods associated with that workload object. You can use a VPA with a deployment, stateful set, job, daemon set, replica set, or replication controller workload object. The VPA CR must be in the same project as the pods you want to monitor.</simpara>
<simpara>You use the VPA CR to associate a workload object and specify which mode the VPA operates in:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>Auto</literal> and <literal>Recreate</literal> modes automatically apply the VPA CPU and memory recommendations throughout the pod lifetime. The VPA deletes any pods in the project that are out of alignment with its recommendations. When redeployed by the workload object, the VPA updates the new pods with its recommendations.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Initial</literal> mode automatically applies VPA recommendations only at pod creation.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Off</literal> mode only provides recommended resource limits and requests, allowing you to manually apply the recommendations. The <literal>off</literal> mode does not update pods.</simpara>
</listitem>
</itemizedlist>
<simpara>You can also use the CR to opt-out certain containers from VPA evaluation and updates.</simpara>
<simpara>For example, a pod has the following limits and requests:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">resources:
  limits:
    cpu: 1
    memory: 500Mi
  requests:
    cpu: 500m
    memory: 100Mi</programlisting>
<simpara>After creating a VPA that is set to <literal>auto</literal>, the VPA learns the resource usage and deletes the pod. When redeployed, the pod uses the new resource limits and requests:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">resources:
  limits:
    cpu: 50m
    memory: 1250Mi
  requests:
    cpu: 25m
    memory: 262144k</programlisting>
<simpara>You can view the VPA recommendations using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get vpa &lt;vpa-name&gt; --output yaml</programlisting>
<simpara>After a few minutes, the output shows the recommendations for CPU and memory requests, similar to the following:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:
...
  recommendation:
    containerRecommendations:
    - containerName: frontend
      lowerBound:
        cpu: 25m
        memory: 262144k
      target:
        cpu: 25m
        memory: 262144k
      uncappedTarget:
        cpu: 25m
        memory: 262144k
      upperBound:
        cpu: 262m
        memory: "274357142"
    - containerName: backend
      lowerBound:
        cpu: 12m
        memory: 131072k
      target:
        cpu: 12m
        memory: 131072k
      uncappedTarget:
        cpu: 12m
        memory: 131072k
      upperBound:
        cpu: 476m
        memory: "498558823"
...</programlisting>
</para>
</formalpara>
<simpara>The output shows the recommended resources, <literal>target</literal>, the minimum recommended resources, <literal>lowerBound</literal>, the highest recommended resources, <literal>upperBound</literal>, and the most recent  resource recommendations, <literal>uncappedTarget</literal>.</simpara>
<simpara>The VPA uses the <literal>lowerBound</literal> and <literal>upperBound</literal> values to determine if a pod needs to be updated. If a pod has resource requests below the <literal>lowerBound</literal> values or above the <literal>upperBound</literal> values, the VPA terminates and recreates the pod with the <literal>target</literal> values.</simpara>
<section xml:id="nodes-pods-vertical-autoscaler-using-one-pod_nodes-pods-vertical-autoscaler">
<title>Changing the VPA minimum value</title>
<simpara>By default, workload objects must specify a minimum of two replicas in order for the VPA to automatically delete and update their pods. As a result, workload objects that specify fewer than two replicas are not automatically acted upon by the VPA. The VPA does update new pods from these workload objects if the pods are restarted by some process external to the VPA.  You can change this cluster-wide minimum value by modifying the <literal>minReplicas</literal> parameter in the <literal>VerticalPodAutoscalerController</literal> custom resource (CR).</simpara>
<simpara>For example, if you set <literal>minReplicas</literal> to <literal>3</literal>, the VPA does not delete and update pods for workload objects that specify fewer than three replicas.</simpara>
<note>
<simpara>If you set <literal>minReplicas</literal> to <literal>1</literal>, the VPA can delete the only pod for a workload object that specifies only one replica. You should use this setting with one-replica objects only if your workload can tolerate downtime whenever the VPA deletes a pod to adjust its resources. To avoid unwanted downtime with one-replica objects, configure the VPA CRs with the <literal>podUpdatePolicy</literal> set to <literal>Initial</literal>, which automatically updates the pod only when it is restarted by some process external to the VPA, or <literal>Off</literal>, which allows you to update the pod manually at an appropriate time for your application.</simpara>
</note>
<formalpara>
<title>Example <literal>VerticalPodAutoscalerController</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.openshift.io/v1
kind: VerticalPodAutoscalerController
metadata:
  creationTimestamp: "2021-04-21T19:29:49Z"
  generation: 2
  name: default
  namespace: openshift-vertical-pod-autoscaler
  resourceVersion: "142172"
  uid: 180e17e9-03cc-427f-9955-3b4d7aeb2d59
spec:
  minReplicas: 3 <co xml:id="CO13-2"/>
  podMinCPUMillicores: 25
  podMinMemoryMb: 250
  recommendationOnly: false
  safetyMarginFraction: 0.15</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO13-1 CO13-2">
<para>Specify the minimum number of replicas in a workload object for the VPA to act on. Any objects with replicas fewer than the minimum are not automatically deleted by the VPA.</para>
</callout>
</calloutlist>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-using-auto_nodes-pods-vertical-autoscaler">
<title>Automatically applying VPA recommendations</title>
<simpara>To use the VPA to automatically update pods, create a VPA CR for a specific workload object with <literal>updateMode</literal> set to <literal>Auto</literal> or <literal>Recreate</literal>.</simpara>
<simpara>When the pods are created for the workload object, the VPA constantly monitors the containers to analyze their CPU and memory needs. The VPA deletes any pods that do not meet the VPA recommendations for CPU and memory. When redeployed, the pods use the new resource limits and requests based on the VPA recommendations, honoring any pod disruption budget set for your applications. The recommendations are added to the <literal>status</literal> field of the VPA CR for reference.</simpara>
<note>
<simpara>By default, workload objects must specify a minimum of two replicas in order for the VPA to automatically delete their pods. Workload objects that specify fewer replicas than this minimum are not deleted. If you manually delete these pods, when the workload object redeploys the pods, the VPA does update the new pods with its recommendations. You can change this minimum by modifying the <literal>VerticalPodAutoscalerController</literal> object as shown shown in <emphasis>Changing the VPA minimum value</emphasis>.</simpara>
</note>
<formalpara>
<title>Example VPA CR for the <literal>Auto</literal> mode</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO14-1"/>
    name:       frontend <co xml:id="CO14-2"/>
  updatePolicy:
    updateMode: "Auto" <co xml:id="CO14-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO14-1">
<para>The type of workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO14-2">
<para>The name of the workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO14-3">
<para>Set the mode to <literal>Auto</literal> or <literal>Recreate</literal>:</para>
<itemizedlist>
<listitem>
<simpara><literal>Auto</literal>. The VPA assigns resource requests on pod creation and updates the existing pods by terminating them when the requested resources differ significantly from the new recommendation.</simpara>
</listitem>
<listitem>
<simpara><literal>Recreate</literal>. The VPA assigns resource requests on pod creation and updates the existing pods by terminating them when the requested resources differ significantly from the new recommendation. This mode should be used rarely, only if you need to ensure that the pods are restarted whenever the resource request changes.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<note>
<simpara>Before a VPA can determine recommendations for resources and apply the recommended resources to new pods, operating pods must exist and be running in the project.</simpara>
<simpara>If a workload&#8217;s resource usage, such as CPU and memory, is consistent, the VPA can determine recommendations for resources in a few minutes. If a workload&#8217;s resource usage is inconsistent, the VPA must collect metrics at various resource usage intervals for the VPA to make an accurate recommendation.</simpara>
</note>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-using-pod_nodes-pods-vertical-autoscaler">
<title>Automatically applying VPA recommendations on pod creation</title>
<simpara>To use the VPA to apply the recommended resources only when a pod is first deployed, create a VPA CR for a specific workload object with <literal>updateMode</literal> set to <literal>Initial</literal>.</simpara>
<simpara>Then, manually delete any pods associated with the workload object that you want to use the VPA recommendations. In the <literal>Initial</literal> mode, the VPA does not delete pods and does not update the pods as it learns new resource recommendations.</simpara>
<formalpara>
<title>Example VPA CR for the <literal>Initial</literal> mode</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO15-1"/>
    name:       frontend <co xml:id="CO15-2"/>
  updatePolicy:
    updateMode: "Initial" <co xml:id="CO15-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>The type of workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO15-2">
<para>The name of the workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO15-3">
<para>Set the mode to <literal>Initial</literal>. The VPA assigns resources when pods are created and does not change the resources during the lifetime of the pod.</para>
</callout>
</calloutlist>
<note>
<simpara>Before a VPA can determine recommended resources and apply the recommendations to new pods, operating pods must exist and be running in the project.</simpara>
<simpara>To obtain the most accurate recommendations from the VPA, wait at least 8 days for the pods to run and for the VPA to stabilize.</simpara>
</note>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-using-manual_nodes-pods-vertical-autoscaler">
<title>Manually applying VPA recommendations</title>
<simpara>To use the VPA to only determine the recommended CPU and memory values, create a VPA CR for a specific workload object with <literal>updateMode</literal> set to <literal>off</literal>.</simpara>
<simpara>When the pods are created for that workload object, the VPA analyzes the CPU and memory needs of the containers and records those recommendations in the <literal>status</literal> field of the VPA CR. The VPA does not update the pods as it determines new resource recommendations.</simpara>
<formalpara>
<title>Example VPA CR for the <literal>Off</literal> mode</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO16-1"/>
    name:       frontend <co xml:id="CO16-2"/>
  updatePolicy:
    updateMode: "Off" <co xml:id="CO16-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO16-1">
<para>The type of workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO16-2">
<para>The name of the workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO16-3">
<para>Set the mode to <literal>Off</literal>.</para>
</callout>
</calloutlist>
<simpara>You can view the recommendations using the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get vpa &lt;vpa-name&gt; --output yaml</programlisting>
<simpara>With the recommendations, you can edit the workload object to add CPU and memory requests, then delete and redeploy the pods using the recommended resources.</simpara>
<note>
<simpara>Before a VPA can determine recommended resources and apply the recommendations to new pods, operating pods must exist and be running in the project.</simpara>
<simpara>To obtain the most accurate recommendations from the VPA, wait at least 8 days for the pods to run and for the VPA to stabilize.</simpara>
</note>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-using-exempt_nodes-pods-vertical-autoscaler">
<title>Exempting containers from applying VPA recommendations</title>
<simpara>If your workload object has multiple containers and you do not want the VPA to evaluate and act on all of the containers, create a VPA CR for a specific workload object and add a <literal>resourcePolicy</literal> to opt-out specific containers.</simpara>
<simpara>When the VPA updates the pods with recommended resources, any containers with a <literal>resourcePolicy</literal> are not updated and the VPA does not present recommendations for those containers in the pod.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO17-1"/>
    name:       frontend <co xml:id="CO17-2"/>
  updatePolicy:
    updateMode: "Auto" <co xml:id="CO17-3"/>
  resourcePolicy: <co xml:id="CO17-4"/>
    containerPolicies:
    - containerName: my-opt-sidecar
      mode: "Off"</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>The type of workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO17-2">
<para>The name of the workload object you want this VPA CR to manage.</para>
</callout>
<callout arearefs="CO17-3">
<para>Set the mode to <literal>Auto</literal>, <literal>Recreate</literal>, or <literal>Off</literal>. The <literal>Recreate</literal> mode should be used rarely, only if you need to ensure that the pods are restarted whenever the resource request changes.</para>
</callout>
<callout arearefs="CO17-4">
<para>Specify the containers you want to opt-out and set <literal>mode</literal> to <literal>Off</literal>.</para>
</callout>
</calloutlist>
<simpara>For example, a pod has two containers, the same resource requests and limits:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># ...
spec:
  containers:
  - name: frontend
    resources:
      limits:
        cpu: 1
        memory: 500Mi
      requests:
        cpu: 500m
        memory: 100Mi
  - name: backend
    resources:
      limits:
        cpu: "1"
        memory: 500Mi
      requests:
        cpu: 500m
        memory: 100Mi
# ...</programlisting>
<simpara>After launching a VPA CR with the <literal>backend</literal> container set to opt-out, the VPA terminates and recreates the pod with the recommended resources applied only to the <literal>frontend</literal> container:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
  containers:
    name: frontend
    resources:
      limits:
        cpu: 50m
        memory: 1250Mi
      requests:
        cpu: 25m
        memory: 262144k
...
    name: backend
    resources:
      limits:
        cpu: "1"
        memory: 500Mi
      requests:
        cpu: 500m
        memory: 100Mi
...</programlisting>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-tuning_nodes-pods-vertical-autoscaler">
<title>Performance tuning the VPA Operator</title>
<simpara>As a cluster administrator, you can tune the performance of your Vertical Pod Autoscaler Operator (VPA) to limit the rate at which the VPA makes requests of the Kubernetes API server and to specify the CPU and memory resources for the VPA recommender, updater, and admission controller component pods.</simpara>
<simpara>Additionally, you can configure the VPA Operator to monitor only those workloads that are being managed by a VPA custom resource (CR). By default, the VPA Operator monitors every workload in the cluster. This allows the VPA Operator to accrue and store 8 days of historical data for all workloads, which the Operator can use if a new VPA CR is created for a workload. However, this causes the VPA Operator to use significant CPU and memory, which could cause the Operator to fail, particularly on larger clusters. By configuring the VPA Operator to monitor only workloads with a VPA CR, you can save on CPU and memory resources. One trade-off is that if you have a workload that has been running, and you create a VPA CR to manage that workload, the VPA Operator does not have any historical data for that workload. As a result, the initial recommendations are not as useful as those after the workload had been running for some time.</simpara>
<simpara>These tunings allow you to ensure the VPA has sufficient resources to operate at peak efficiency and to prevent throttling and a possible delay in pod admissions.</simpara>
<simpara>You can perform the following tunings on the VPA components by editing the <literal>VerticalPodAutoscalerController</literal> custom resource (CR):</simpara>
<itemizedlist>
<listitem>
<simpara>To prevent throttling and pod admission delays, set the queries-per-second (QPS) and burst rates for VPA requests of the Kubernetes API server by using the <literal>kube-api-qps</literal> and <literal>kube-api-burst</literal> parameters.</simpara>
</listitem>
<listitem>
<simpara>To ensure sufficient CPU and memory, set the CPU and memory requests for VPA component pods by using the standard <literal>cpu</literal> and <literal>memory</literal> resource requests.</simpara>
</listitem>
<listitem>
<simpara>To configure the VPA Operator to monitor only workloads that are being managed by a VPA CR, set the <literal>memory-saver</literal> parameter to <literal>true</literal> for the recommender component.</simpara>
</listitem>
</itemizedlist>
<simpara>The following example VPA controller CR sets the VPA API QPS and burts rates, configures the component pod resource requests, and sets <literal>memory-saver</literal> to <literal>true</literal> for the recommender:</simpara>
<formalpara>
<title>Example <literal>VerticalPodAutoscalerController</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.openshift.io/v1
kind: VerticalPodAutoscalerController
metadata:
  name: default
  namespace: openshift-vertical-pod-autoscaler
spec:
  deploymentOverrides:
    admission: <co xml:id="CO18-1"/>
      container:
        args: <co xml:id="CO18-2"/>
          - '--kube-api-qps=30.0'
          - '--kube-api-burst=40.0'
        resources:
          requests: <co xml:id="CO18-3"/>
            cpu: 40m
            memory: 40Mi
    recommender: <co xml:id="CO18-4"/>
      container:
        args:
          - '--kube-api-qps=20.0'
          - '--kube-api-burst=60.0'
          - '--memory-saver=true' <co xml:id="CO18-5"/>
        resources:
          requests:
            cpu: 60m
            memory: 60Mi
    updater: <co xml:id="CO18-6"/>
      container:
        args:
          - '--kube-api-qps=20.0'
          - '--kube-api-burst=80.0'
        resources:
          requests:
            cpu: 80m
            memory: 80Mi
  minReplicas: 2
  podMinCPUMillicores: 25
  podMinMemoryMb: 250
  recommendationOnly: false
  safetyMarginFraction: 0.15</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO18-1">
<para>Specifies the tuning parameters for the VPA admission controller.</para>
</callout>
<callout arearefs="CO18-2">
<para>Specifies the API QPS and burst rates for the VPA admission controller.</para>
<itemizedlist>
<listitem>
<simpara><literal>kube-api-qps</literal>: Specifies the queries per second (QPS) limit when making requests to Kubernetes API server. The default is <literal>5.0</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>kube-api-burst</literal>: Specifies the burst limit when making requests to Kubernetes API server. The default is <literal>10.0</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO18-3">
<para>Specifies the CPU and memory requests for the VPA admission controller pod.</para>
</callout>
<callout arearefs="CO18-4">
<para>Specifies the tuning parameters for the VPA recommender.</para>
</callout>
<callout arearefs="CO18-5">
<para>Specifies that the VPA Operator monitors only workloads with a VPA CR. The default is <literal>false</literal>.</para>
</callout>
<callout arearefs="CO18-6">
<para>Specifies the tuning parameters for the VPA updater.</para>
</callout>
</calloutlist>
<simpara>You can verify that the settings were applied to each VPA component pod.</simpara>
<formalpara>
<title>Example updater pod</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: vpa-updater-default-d65ffb9dc-hgw44
  namespace: openshift-vertical-pod-autoscaler
# ...
spec:
  containers:
  - args:
    - --logtostderr
    - --v=1
    - --min-replicas=2
    - --kube-api-qps=20.0
    - --kube-api-burst=80.0
# ...
    resources:
      requests:
        cpu: 80m
        memory: 80Mi
# ...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example admission controller pod</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: vpa-admission-plugin-default-756999448c-l7tsd
  namespace: openshift-vertical-pod-autoscaler
# ...
spec:
  containers:
  - args:
    - --logtostderr
    - --v=1
    - --tls-cert-file=/data/tls-certs/tls.crt
    - --tls-private-key=/data/tls-certs/tls.key
    - --client-ca-file=/data/tls-ca-certs/service-ca.crt
    - --webhook-timeout-seconds=10
    - --kube-api-qps=30.0
    - --kube-api-burst=40.0
# ...
    resources:
      requests:
        cpu: 40m
        memory: 40Mi
# ...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example recommender pod</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: vpa-recommender-default-74c979dbbc-znrd2
  namespace: openshift-vertical-pod-autoscaler
# ...
spec:
  containers:
  - args:
    - --logtostderr
    - --v=1
    - --recommendation-margin-fraction=0.15
    - --pod-recommendation-min-cpu-millicores=25
    - --pod-recommendation-min-memory-mb=250
    - --kube-api-qps=20.0
    - --kube-api-burst=60.0
    - --memory-saver=true
# ...
    resources:
      requests:
        cpu: 60m
        memory: 60Mi
# ...</programlisting>
</para>
</formalpara>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-custom_nodes-pods-vertical-autoscaler">
<title>Using an alternative recommender</title>
<simpara>You can use your own recommender to autoscale based on your own algorithms. If you do not specify an alternative recommender, {product-title} uses the default recommender, which suggests CPU and memory requests based on historical usage. Because there is no universal recommendation policy that applies to all types of workloads, you might want to create and deploy different recommenders for specific workloads.</simpara>
<simpara>For example, the default recommender might not accurately predict future resource usage when containers exhibit certain resource behaviors, such as cyclical patterns that alternate between usage spikes and idling as used by monitoring applications, or recurring and repeating patterns used with deep learning applications. Using the default recommender with these usage behaviors might result in significant over-provisioning and Out of Memory (OOM) kills for your applications.</simpara>
<note>
<simpara>Instructions for how to create a recommender are beyond the scope of this documentation,</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To use an alternative recommender for your pods:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a service account for the alternative recommender and bind that service account to the required cluster role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1 <co xml:id="CO19-1"/>
kind: ServiceAccount
metadata:
  name: alt-vpa-recommender-sa
  namespace: &lt;namespace_name&gt;
---
apiVersion: rbac.authorization.k8s.io/v1 <co xml:id="CO19-2"/>
kind: ClusterRoleBinding
metadata:
  name: system:example-metrics-reader
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:metrics-reader
subjects:
- kind: ServiceAccount
  name: alt-vpa-recommender-sa
  namespace: &lt;namespace_name&gt;
---
apiVersion: rbac.authorization.k8s.io/v1 <co xml:id="CO19-3"/>
kind: ClusterRoleBinding
metadata:
  name: system:example-vpa-actor
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:vpa-actor
subjects:
- kind: ServiceAccount
  name: alt-vpa-recommender-sa
  namespace: &lt;namespace_name&gt;
---
apiVersion: rbac.authorization.k8s.io/v1 <co xml:id="CO19-4"/>
kind: ClusterRoleBinding
metadata:
  name: system:example-vpa-target-reader-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:vpa-target-reader
subjects:
- kind: ServiceAccount
  name: alt-vpa-recommender-sa
  namespace: &lt;namespace_name&gt;</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Creates a service accocunt for the recommender in the namespace where the recommender is deployed.</para>
</callout>
<callout arearefs="CO19-2">
<para>Binds the recommender service account to the <literal>metrics-reader</literal> role. Specify the namespace where the recommender is to be deployed.</para>
</callout>
<callout arearefs="CO19-3">
<para>Binds the recommender service account to the <literal>vpa-actor</literal> role. Specify the namespace where the recommender is to be deployed.</para>
</callout>
<callout arearefs="CO19-4">
<para>Binds the recommender service account to the <literal>vpa-target-reader</literal> role. Specify the namespace where the recommender is to be deployed.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To add the alternative recommender to the cluster, create a Deployment object similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: alt-vpa-recommender
  namespace: &lt;namespace_name&gt;
spec:
  replicas: 1
  selector:
    matchLabels:
      app: alt-vpa-recommender
  template:
    metadata:
      labels:
        app: alt-vpa-recommender
    spec:
      containers: <co xml:id="CO20-1"/>
      - name: recommender
        image: quay.io/example/alt-recommender:latest <co xml:id="CO20-2"/>
        imagePullPolicy: Always
        resources:
          limits:
            cpu: 200m
            memory: 1000Mi
          requests:
            cpu: 50m
            memory: 500Mi
        ports:
        - name: prometheus
          containerPort: 8942
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
              - ALL
          seccompProfile:
            type: RuntimeDefault
      serviceAccountName: alt-vpa-recommender-sa <co xml:id="CO20-3"/>
      securityContext:
        runAsNonRoot: true</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Creates a container for your alternative recommender.</para>
</callout>
<callout arearefs="CO20-2">
<para>Specifies your recommender image.</para>
</callout>
<callout arearefs="CO20-3">
<para>Associates the service account that you created for the recommender.</para>
</callout>
</calloutlist>
<simpara>A new pod is created for the alternative recommender in the same namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                        READY   STATUS    RESTARTS   AGE
frontend-845d5478d-558zf                    1/1     Running   0          4m25s
frontend-845d5478d-7z9gx                    1/1     Running   0          4m25s
frontend-845d5478d-b7l4j                    1/1     Running   0          4m25s
vpa-alt-recommender-55878867f9-6tp5v        1/1     Running   0          9s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Configure a VPA CR that includes the name of the alternative recommender <literal>Deployment</literal> object.</simpara>
<formalpara>
<title>Example VPA CR to include the alternative recommender</title>
<para>
<programlisting language="yml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
  namespace: &lt;namespace_name&gt;
spec:
  recommenders:
    - name: alt-vpa-recommender <co xml:id="CO21-1"/>
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO21-2"/>
    name:       frontend</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>Specifies the name of the alternative recommender deployment.</para>
</callout>
<callout arearefs="CO21-2">
<para>Specifies the name of an existing workload object you want this VPA to manage.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-configuring_nodes-pods-vertical-autoscaler">
<title>Using the Vertical Pod Autoscaler Operator</title>
<simpara>You can use the Vertical Pod Autoscaler Operator (VPA) by creating a VPA custom resource (CR). The CR indicates which pods it should analyze and determines the actions the VPA should take with those pods.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The workload object that you want to autoscale must exist.</simpara>
</listitem>
<listitem>
<simpara>If you want to use an alternative recommender, a deployment including that recommender must exist.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To create a VPA CR for a specific workload object:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Change to the project where the workload object you want to scale is located.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a VPA CR YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind:       Deployment <co xml:id="CO22-1"/>
    name:       frontend <co xml:id="CO22-2"/>
  updatePolicy:
    updateMode: "Auto" <co xml:id="CO22-3"/>
  resourcePolicy: <co xml:id="CO22-4"/>
    containerPolicies:
    - containerName: my-opt-sidecar
      mode: "Off"
  recommenders: <co xml:id="CO22-5"/>
    - name: my-recommender</programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>Specify the type of workload object you want this VPA to manage: <literal>Deployment</literal>, <literal>StatefulSet</literal>, <literal>Job</literal>, <literal>DaemonSet</literal>, <literal>ReplicaSet</literal>, or <literal>ReplicationController</literal>.</para>
</callout>
<callout arearefs="CO22-2">
<para>Specify the name of an existing workload object you want this VPA to manage.</para>
</callout>
<callout arearefs="CO22-3">
<para>Specify the VPA mode:</para>
<itemizedlist>
<listitem>
<simpara><literal>auto</literal> to automatically apply the recommended resources on pods associated with the controller. The VPA terminates existing pods and creates new pods with the recommended resource limits and requests.</simpara>
</listitem>
<listitem>
<simpara><literal>recreate</literal> to automatically apply the recommended resources on pods associated with the workload object. The VPA terminates existing pods and creates new pods with the recommended resource limits and requests. The <literal>recreate</literal> mode should be used rarely, only if you need to ensure that the pods are restarted whenever the resource request changes.</simpara>
</listitem>
<listitem>
<simpara><literal>initial</literal> to automatically apply the recommended resources when pods associated with the workload object are created. The VPA does not update the pods as it learns new resource recommendations.</simpara>
</listitem>
<listitem>
<simpara><literal>off</literal> to only generate resource recommendations for the pods associated with the workload object. The VPA does not update the pods as it learns new resource recommendations and does not apply the recommendations to new pods.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO22-4">
<para>Optional. Specify the containers you want to opt-out and set the mode to <literal>Off</literal>.</para>
</callout>
<callout arearefs="CO22-5">
<para>Optional. Specify an alternative recommender.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the VPA CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>After a few moments, the VPA learns the resource usage of the containers in the pods associated with the workload object.</simpara>
<simpara>You can view the VPA recommendations using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get vpa &lt;vpa-name&gt; --output yaml</programlisting>
<simpara>The output shows the recommendations for CPU and memory requests, similar to the following:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:

...

  recommendation:
    containerRecommendations:
    - containerName: frontend
      lowerBound: <co xml:id="CO23-1"/>
        cpu: 25m
        memory: 262144k
      target: <co xml:id="CO23-2"/>
        cpu: 25m
        memory: 262144k
      uncappedTarget: <co xml:id="CO23-3"/>
        cpu: 25m
        memory: 262144k
      upperBound: <co xml:id="CO23-4"/>
        cpu: 262m
        memory: "274357142"
    - containerName: backend
      lowerBound:
        cpu: 12m
        memory: 131072k
      target:
        cpu: 12m
        memory: 131072k
      uncappedTarget:
        cpu: 12m
        memory: 131072k
      upperBound:
        cpu: 476m
        memory: "498558823"

...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para><literal>lowerBound</literal> is the minimum recommended resource levels.</para>
</callout>
<callout arearefs="CO23-2">
<para><literal>target</literal> is the recommended resource levels.</para>
</callout>
<callout arearefs="CO23-3">
<para><literal>upperBound</literal> is the highest recommended resource levels.</para>
</callout>
<callout arearefs="CO23-4">
<para><literal>uncappedTarget</literal> is the most recent resource recommendations.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-vertical-autoscaler-uninstall_nodes-pods-vertical-autoscaler">
<title>Uninstalling the Vertical Pod Autoscaler Operator</title>
<simpara>You can remove the Vertical Pod Autoscaler Operator (VPA) from your {product-title} cluster. After uninstalling, the resource requests for the pods already modified by an existing VPA CR do not change. Any new pods get the resources defined in the workload object, not the previous recommendations made by the Vertical Pod Autoscaler Operator.</simpara>
<note>
<simpara>You can remove a specific VPA CR by using the <literal>oc delete vpa &lt;vpa-name&gt;</literal> command. The same actions apply for resource requests as uninstalling the vertical pod autoscaler.</simpara>
</note>
<simpara>After removing the VPA Operator, it is recommended that you remove the other components associated with the Operator to avoid potential issues.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Vertical Pod Autoscaler Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the {product-title} web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">openshift-vertical-pod-autoscaler</emphasis> project.</simpara>
</listitem>
<listitem>
<simpara>For the <emphasis role="strong">VerticalPodAutoscaler</emphasis>  Operator, click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> and select <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Optional: To remove all operands associated with the Operator, in the dialog box, select <emphasis role="strong">Delete all operand instances for this operator</emphasis> checkbox.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Optional: Use the OpenShift CLI to remove the VPA components:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the VPA namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete namespace openshift-vertical-pod-autoscaler</programlisting>
</listitem>
<listitem>
<simpara>Delete the VPA custom resource definition (CRD) objects:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd verticalpodautoscalercheckpoints.autoscaling.k8s.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd verticalpodautoscalercontrollers.autoscaling.openshift.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd verticalpodautoscalers.autoscaling.k8s.io</programlisting>
<simpara>Deleting the CRDs removes the associated roles, cluster roles, and role bindings.</simpara>
<note>
<simpara>This action removes from the cluster all user-created VPA CRs. If you re-install the VPA, you must create these objects again.</simpara>
</note>
</listitem>
<listitem>
<simpara>Delete the VPA Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete operator/vertical-pod-autoscaler.openshift-vertical-pod-autoscaler</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-secrets">
<title>Providing sensitive data to pods by using secrets</title>

<simpara>Some applications need sensitive information, such as passwords and user names, that you do not want developers to have.</simpara>
<simpara>As an administrator, you can use <literal>Secret</literal> objects to provide this information without exposing that information in clear text.</simpara>
<section xml:id="nodes-pods-secrets-about_nodes-pods-secrets">
<title>Understanding secrets</title>
<simpara>The <literal>Secret</literal> object type provides a mechanism to hold sensitive information such
as passwords, {product-title} client configuration files,
private source repository credentials, and so on. Secrets decouple sensitive
content from the pods. You can mount secrets into containers using a volume
plugin or the system can use secrets to perform actions on behalf of a pod.</simpara>
<simpara>Key properties include:</simpara>
<itemizedlist>
<listitem>
<simpara>Secret data can be referenced independently from its definition.</simpara>
</listitem>
<listitem>
<simpara>Secret data volumes are backed by temporary file-storage facilities (tmpfs) and never come to rest on a node.</simpara>
</listitem>
<listitem>
<simpara>Secret data can be shared within a namespace.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>YAML <literal>Secret</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: test-secret
  namespace: my-namespace
type: Opaque <co xml:id="CO24-1"/>
data: <co xml:id="CO24-2"/>
  username: &lt;username&gt; <co xml:id="CO24-3"/>
  password: &lt;password&gt;
stringData: <co xml:id="CO24-4"/>
  hostname: myapp.mydomain.com <co xml:id="CO24-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO24-1">
<para>Indicates the structure of the secret&#8217;s key names and values.</para>
</callout>
<callout arearefs="CO24-2">
<para>The allowable format for the keys in the <literal>data</literal> field must meet the
guidelines in the <emphasis role="strong">DNS_SUBDOMAIN</emphasis> value in
<link xl:href="https://github.com/kubernetes/kubernetes/blob/v1.0.0/docs/design/identifiers.md">the
Kubernetes identifiers glossary</link>.</para>
</callout>
<callout arearefs="CO24-3">
<para>The value associated with keys in the <literal>data</literal> map must be base64 encoded.</para>
</callout>
<callout arearefs="CO24-4">
<para>Entries in the <literal>stringData</literal> map are converted to base64
and the entry will then be moved to the <literal>data</literal> map automatically. This field
is write-only; the value will only be returned via the <literal>data</literal> field.</para>
</callout>
<callout arearefs="CO24-5">
<para>The value associated with keys in the <literal>stringData</literal> map is made up of
plain text strings.</para>
</callout>
</calloutlist>
<simpara>You must create a secret before creating the pods that depend on that secret.</simpara>
<simpara>When creating secrets:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a secret object with secret data.</simpara>
</listitem>
<listitem>
<simpara>Update the pod&#8217;s service account to allow the reference to the secret.</simpara>
</listitem>
<listitem>
<simpara>Create a pod, which consumes the secret as an environment variable or as a file
(using a <literal>secret</literal> volume).</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-pods-secrets-about-types_nodes-pods-secrets">
<title>Types of secrets</title>
<simpara>The value in the <literal>type</literal> field indicates the structure of the secret&#8217;s key names and values. The type can be used to
enforce the presence of user names and keys in the secret object. If you do not want validation, use the <literal>opaque</literal> type,
which is the default.</simpara>
<simpara>Specify one of the following types to trigger minimal server-side validation to ensure the presence of specific key names in the secret data:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kubernetes.io/service-account-token</literal>. Uses a service account token.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/basic-auth</literal>. Use with Basic Authentication.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/ssh-auth</literal>. Use with SSH Key Authentication.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/tls</literal>. Use with TLS certificate authorities.</simpara>
</listitem>
</itemizedlist>
<simpara>Specify <literal>type: Opaque</literal> if you do not want validation, which means the secret does not claim to conform to any convention for key names or values.
An <emphasis>opaque</emphasis> secret, allows for unstructured <literal>key:value</literal> pairs that can contain arbitrary values.</simpara>
<note>
<simpara>You can specify other arbitrary types, such as <literal>example.com/my-secret-type</literal>. These types are not enforced server-side,
but indicate that the creator of the secret intended to conform to the key/value requirements of that type.</simpara>
</note>
<simpara>For examples of different secret types, see the code samples in <emphasis>Using Secrets</emphasis>.</simpara>
</section>
<section xml:id="nodes-pods-secrets-about-keys_nodes-pods-secrets">
<title>Secret data keys</title>
<simpara>Secret keys must be in a DNS subdomain.</simpara>
</section>
<section xml:id="auto-generated-sa-token-secrets_nodes-pods-secrets">
<title>Automatically generated secrets</title>
<simpara>By default, {product-title} creates the following secrets for each service account:</simpara>
<itemizedlist>
<listitem>
<simpara>A dockercfg image pull secret</simpara>
</listitem>
<listitem>
<simpara>A service account token secret</simpara>
<note>
<simpara>Prior to {product-title} 4.11, a second service account token secret was generated when a service account was created. This service account token secret was used to access the Kubernetes API.</simpara>
<simpara>Starting with {product-title} 4.11, this second service account token secret is no longer created. This is because the <literal>LegacyServiceAccountTokenNoAutoGeneration</literal> upstream Kubernetes feature gate was enabled, which stops the automatic generation of secret-based service account tokens to access the Kubernetes API.</simpara>
<simpara>After upgrading to {product-version}, any existing service account token secrets are not deleted and continue to function.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>This service account token secret and docker configuration image pull secret are necessary to integrate the OpenShift image registry into the cluster&#8217;s user authentication and authorization system.</simpara>
<simpara>However, if you do not enable the <literal>ImageRegistry</literal> capability or if you disable the integrated OpenShift image registry in the Cluster Image Registry Operator&#8217;s configuration, these secrets are not generated for each service account.</simpara>
<warning>
<simpara>Do not rely on these automatically generated secrets for your own use; they might be removed in a future {product-title} release.</simpara>
</warning>
<simpara>Workloads are automatically injected with a projected volume to obtain a bound service account token. If your workload needs an additional service account token, add an additional projected volume in your workload manifest. Bound service account tokens are more secure than service account token secrets for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>Bound service account tokens have a bounded lifetime.</simpara>
</listitem>
<listitem>
<simpara>Bound service account tokens contain audiences.</simpara>
</listitem>
<listitem>
<simpara>Bound service account tokens can be bound to pods or secrets and the bound tokens are invalidated when the bound object is removed.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see <emphasis>Configuring bound service account tokens using volume projection</emphasis>.</simpara>
<simpara>You can also manually create a service account token secret to obtain a token, if the security exposure of a non-expiring token in a readable API object is acceptable to you. For more information, see <emphasis>Creating a service account token secret</emphasis>.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>For information about requesting bound service account tokens, see <link xl:href="../../authentication/bound-service-account-tokens.xml#bound-sa-tokens-configuring_bound-service-account-tokens">Using bound service account tokens</link></simpara>
</listitem>
<listitem>
<simpara>For information about creating a service account token secret, see <link xl:href="../../nodes/pods/nodes-pods-secrets.doc#nodes-pods-secrets-creating-sa_nodes-pods-secrets">Creating a service account token secret</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-secrets-creating_nodes-pods-secrets">
<title>Understanding how to create secrets</title>
<simpara>As an administrator you must create a secret before developers can create the pods that depend on that secret.</simpara>
<simpara>When creating secrets:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a secret object that contains the data you want to keep secret. The specific data required for each secret type is descibed in the following sections.</simpara>
<formalpara>
<title>Example YAML object that creates an opaque secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: test-secret
type: Opaque <co xml:id="CO25-1"/>
data: <co xml:id="CO25-2"/>
  username: &lt;username&gt;
  password: &lt;password&gt;
stringData: <co xml:id="CO25-3"/>
  hostname: myapp.mydomain.com
  secret.properties: |
    property1=valueA
    property2=valueB</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO25-1">
<para>Specifies the type of secret.</para>
</callout>
<callout arearefs="CO25-2">
<para>Specifies encoded string and data.</para>
</callout>
<callout arearefs="CO25-3">
<para>Specifies decoded string and data.</para>
</callout>
</calloutlist>
<simpara>Use either the <literal>data</literal> or <literal>stringdata</literal> fields, not both.</simpara>
</listitem>
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret:</simpara>
<formalpara>
<title>YAML of a service account that uses a secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
 ...
secrets:
- name: test-secret</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a pod, which consumes the secret as an environment variable or as a file
(using a <literal>secret</literal> volume):</simpara>
<formalpara>
<title>YAML of a pod populating files in a volume with secret data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: secret-example-pod
spec:
  containers:
    - name: secret-test-container
      image: busybox
      command: [ "/bin/sh", "-c", "cat /etc/secret-volume/*" ]
      volumeMounts: <co xml:id="CO26-1"/>
          - name: secret-volume
            mountPath: /etc/secret-volume <co xml:id="CO26-2"/>
            readOnly: true <co xml:id="CO26-3"/>
  volumes:
    - name: secret-volume
      secret:
        secretName: test-secret <co xml:id="CO26-4"/>
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO26-1">
<para>Add a <literal>volumeMounts</literal> field to each container that needs the secret.</para>
</callout>
<callout arearefs="CO26-2">
<para>Specifies an unused directory name where you would like the secret to appear. Each key in the secret data map becomes the filename under <literal>mountPath</literal>.</para>
</callout>
<callout arearefs="CO26-3">
<para>Set to <literal>true</literal>.  If true, this instructs the driver to provide a read-only volume.</para>
</callout>
<callout arearefs="CO26-4">
<para>Specifies the name of the secret.</para>
</callout>
</calloutlist>
<formalpara>
<title>YAML of a pod populating environment variables with secret data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: secret-example-pod
spec:
  containers:
    - name: secret-test-container
      image: busybox
      command: [ "/bin/sh", "-c", "export" ]
      env:
        - name: TEST_SECRET_USERNAME_ENV_VAR
          valueFrom:
            secretKeyRef: <co xml:id="CO27-1"/>
              name: test-secret
              key: username
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO27-1">
<para>Specifies the environment variable that consumes the secret key.</para>
</callout>
</calloutlist>
<formalpara>
<title>YAML of a build config populating environment variables with secret data</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: secret-example-bc
spec:
  strategy:
    sourceStrategy:
      env:
      - name: TEST_SECRET_USERNAME_ENV_VAR
        valueFrom:
          secretKeyRef: <co xml:id="CO28-1"/>
            name: test-secret
            key: username
      from:
        kind: ImageStreamTag
        namespace: openshift
        name: 'cli:latest'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO28-1">
<para>Specifies the environment variable that consumes the secret key.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<section xml:id="_secret_creation_restrictions">
<title>Secret creation restrictions</title>
<simpara>To use a secret, a pod needs to reference the secret. A secret can be used with
a pod in three ways:</simpara>
<itemizedlist>
<listitem>
<simpara>To populate environment variables for containers.</simpara>
</listitem>
<listitem>
<simpara>As files in a volume mounted on one or more of its containers.</simpara>
</listitem>
<listitem>
<simpara>By kubelet when pulling images for the pod.</simpara>
</listitem>
</itemizedlist>
<simpara>Volume type secrets write data into the container as a file using the volume
mechanism. Image pull secrets use service accounts for the automatic injection of
the secret into all pods in a namespace.</simpara>
<simpara>When a template contains a secret definition, the only way for the template to
use the provided secret is to ensure that the secret volume sources are
validated and that the specified object reference actually points to a <literal>Secret</literal> object. Therefore, a secret needs to be created before any pods that
depend on it. The most effective way to ensure this is to have it get injected
automatically through the use of a service account.</simpara>
<simpara>Secret API objects reside in a namespace. They can only be referenced by pods in
that same namespace.</simpara>
<simpara>Individual secrets are limited to 1MB in size. This is to discourage the
creation of large secrets that could exhaust apiserver and kubelet memory.
However, creation of a number of smaller secrets could also exhaust memory.</simpara>
</section>
<section xml:id="nodes-pods-secrets-creating-opaque_nodes-pods-secrets">
<title>Creating an opaque secret</title>
<simpara>As an administrator, you can create an opaque secret, which allows you to store unstructured <literal>key:value</literal> pairs that can contain arbitrary values.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object in a YAML file on a control plane node.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque <co xml:id="CO29-1"/>
data:
  username: &lt;username&gt;
  password: &lt;password&gt;</programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>Specifies an opaque secret.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the following command to create a <literal>Secret</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>To use the secret in a pod:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret, as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
<listitem>
<simpara>Create the pod, which consumes the secret as an environment variable or as a file (using a <literal>secret</literal> volume), as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on using secrets in pods, see <link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating_nodes-pods-secrets">Understanding how to create secrets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-secrets-creating-sa_nodes-pods-secrets">
<title>Creating a service account token secret</title>
<simpara>As an administrator, you can create a service account token secret, which allows you to distribute a service account token to applications that must authenticate to the API.</simpara>
<note>
<simpara>It is recommended to obtain bound service account tokens using the TokenRequest API instead of using service account token secrets. The tokens obtained from the TokenRequest API are more secure than the tokens stored in secrets, because they have a bounded lifetime and are not readable by other API clients.</simpara>
<simpara>You should create a service account token secret only if you cannot use the TokenRequest API and if the security exposure of a non-expiring token in a readable API object is acceptable to you.</simpara>
<simpara>See the Additional resources section that follows for information on creating bound service account tokens.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object in a YAML file on a control plane node:</simpara>
<formalpara>
<title>Example <literal>secret</literal> object:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: secret-sa-sample
  annotations:
    kubernetes.io/service-account.name: "sa-name" <co xml:id="CO30-1"/>
type: kubernetes.io/service-account-token <co xml:id="CO30-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO30-1">
<para>Specifies an existing service account name. If you are creating both the <literal>ServiceAccount</literal> and the <literal>Secret</literal> objects, create the <literal>ServiceAccount</literal> object first.</para>
</callout>
<callout arearefs="CO30-2">
<para>Specifies a service account token secret.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the following command to create the <literal>Secret</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>To use the secret in a pod:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret, as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
<listitem>
<simpara>Create the pod, which consumes the secret as an environment variable or as a file (using a <literal>secret</literal> volume), as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on using secrets in pods, see <link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating_nodes-pods-secrets">Understanding how to create secrets</link>.</simpara>
</listitem>
<listitem>
<simpara>For information on requesting bound service account tokens, see <link xl:href="../../authentication/bound-service-account-tokens.xml#bound-sa-tokens-configuring_bound-service-account-tokens">Using bound service account tokens</link></simpara>
</listitem>
<listitem>
<simpara>For information on creating service accounts, see <link xl:href="../../authentication/understanding-and-creating-service-accounts.xml#understanding-and-creating-service-accounts">Understanding and creating service accounts</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-secrets-creating-basic_nodes-pods-secrets">
<title>Creating a basic authentication secret</title>
<simpara>As an administrator, you can create a basic authentication secret, which allows you to store the credentials needed for basic authentication. When using this secret type, the <literal>data</literal> parameter of the <literal>Secret</literal> object must contain the following keys encoded in the base64 format:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>username</literal>: the user name for authentication</simpara>
</listitem>
<listitem>
<simpara><literal>password</literal>: the password or token for authentication</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You can use the <literal>stringData</literal> parameter to use clear text content.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object in a YAML file on a control plane node:</simpara>
<formalpara>
<title>Example <literal>secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: secret-basic-auth
type: kubernetes.io/basic-auth <co xml:id="CO31-1"/>
data:
stringData: <co xml:id="CO31-2"/>
  username: admin
  password: &lt;password&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO31-1">
<para>Specifies a basic authentication secret.</para>
</callout>
<callout arearefs="CO31-2">
<para>Specifies the basic authentication values to use.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the following command to create the <literal>Secret</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>To use the secret in a pod:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret, as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
<listitem>
<simpara>Create the pod, which consumes the secret as an environment variable or as a file (using a <literal>secret</literal> volume), as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on using secrets in pods, see <link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating_nodes-pods-secrets">Understanding how to create secrets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-secrets-creating-ssh_nodes-pods-secrets">
<title>Creating an SSH authentication secret</title>
<simpara>As an administrator, you can create an SSH authentication secret, which allows you to store data used for SSH authentication. When using this secret type, the <literal>data</literal> parameter of the <literal>Secret</literal> object must contain the SSH credential to use.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object in a YAML file on a control plane node:</simpara>
<formalpara>
<title>Example <literal>secret</literal> object:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: secret-ssh-auth
type: kubernetes.io/ssh-auth <co xml:id="CO32-1"/>
data:
  ssh-privatekey: | <co xml:id="CO32-2"/>
          MIIEpQIBAAKCAQEAulqb/Y ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO32-1">
<para>Specifies an SSH authentication secret.</para>
</callout>
<callout arearefs="CO32-2">
<para>Specifies the SSH key/value pair as the SSH credentials to use.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the following command to create the <literal>Secret</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>To use the secret in a pod:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret, as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
<listitem>
<simpara>Create the pod, which consumes the secret as an environment variable or as a file (using a <literal>secret</literal> volume), as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating_nodes-pods-secrets">Understanding how to create secrets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-secrets-creating-docker_nodes-pods-secrets">
<title>Creating a Docker configuration secret</title>
<simpara>As an administrator, you can create a Docker configuration secret, which allows you to store the credentials for accessing a container image registry.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kubernetes.io/dockercfg</literal>. Use this secret type to store your local Docker configuration file. The <literal>data</literal> parameter of the <literal>secret</literal> object must contain the contents of a <literal>.dockercfg</literal> file encoded in the base64 format.</simpara>
</listitem>
<listitem>
<simpara><literal>kubernetes.io/dockerconfigjson</literal>. Use this secret type to store your local Docker configuration JSON file. The <literal>data</literal> parameter of the <literal>secret</literal> object must contain the contents of a <literal>.docker/config.json</literal> file encoded in the base64 format.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object in a YAML file on a control plane node.</simpara>
<formalpara>
<title>Example Docker configuration <literal>secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: secret-docker-cfg
  namespace: my-project
type: kubernetes.io/dockerconfig <co xml:id="CO33-1"/>
data:
  .dockerconfig:bm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg== <co xml:id="CO33-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO33-1">
<para>Specifies that the secret is using a Docker configuration file.</para>
</callout>
<callout arearefs="CO33-2">
<para>The output of a base64-encoded Docker configuration file</para>
</callout>
</calloutlist>
<formalpara>
<title>Example Docker configuration JSON <literal>secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: secret-docker-json
  namespace: my-project
type: kubernetes.io/dockerconfig <co xml:id="CO34-1"/>
data:
  .dockerconfigjson:bm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg== <co xml:id="CO34-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>Specifies that the secret is using a Docker configuration JSONfile.</para>
</callout>
<callout arearefs="CO34-2">
<para>The output of a base64-encoded Docker configuration JSON file</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the following command to create the <literal>Secret</literal> object</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>To use the secret in a pod:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the pod&#8217;s service account to reference the secret, as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
<listitem>
<simpara>Create the pod, which consumes the secret as an environment variable or as a file (using a <literal>secret</literal> volume), as shown in the "Understanding how to create secrets" section.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on using secrets in pods, see <link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating_nodes-pods-secrets">Understanding how to create secrets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-secrets-creating-web-console-secrets_nodes-pods-secrets">
<title>Creating a secret using the web console</title>
<simpara>You can create secrets using the web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> &#8594; <emphasis role="strong">From YAML</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the YAML manually to your specifications, or drag and drop a file into the YAML editor.
For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: example
  namespace: &lt;namespace&gt;
type: Opaque <co xml:id="CO35-1"/>
data:
  username: &lt;base64 encoded username&gt;
  password: &lt;base64 encoded password&gt;
stringData: <co xml:id="CO35-2"/>
  hostname: myapp.mydomain.com</programlisting>
<calloutlist>
<callout arearefs="CO35-1">
<para>This example specifies an opaque secret; however, you may see other secret types such as service account token secret, basic authentication secret, SSH authentication secret, or a secret that uses Docker configuration.</para>
</callout>
<callout arearefs="CO35-2">
<para>Entries in the <literal>stringData</literal> map are converted to base64 and the entry will then be moved to the <literal>data</literal> map automatically. This field is write-only; the value will only be returned via the <literal>data</literal> field.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add Secret to workload</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the drop-down menu, select the workload to add.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-secrets-updating_nodes-pods-secrets">
<title>Understanding how to update secrets</title>
<simpara>When you modify the value of a secret, the value (used by an already running pod) will not dynamically change. To change a secret, you must delete the
original pod and create a new pod (perhaps with an identical PodSpec).</simpara>
<simpara>Updating a secret follows the same workflow as deploying a new Container image. You can use the <literal>kubectl rolling-update</literal> command.</simpara>
<simpara>The <literal>resourceVersion</literal> value in a secret is not specified when it is referenced. Therefore, if a secret is updated at the same time as pods are starting, the version of the secret that is used for the pod is not defined.</simpara>
<note>
<simpara>Currently, it is not possible to check the resource version of a secret object that was used when a pod was created. It is planned that pods will report this information, so that a controller could restart ones using an old <literal>resourceVersion</literal>. In the interim, do not update the data of existing secrets, but create new ones with distinct names.</simpara>
</note>
</section>
<section xml:id="nodes-application-secrets-creating-using-sa_nodes-pods-secrets">
<title>Creating and using secrets</title>
<simpara>As an administrator, you can create a service account token secret. This allows you to distribute a service account token to applications that must authenticate to the API.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a service account in your namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create sa &lt;service_account_name&gt; -n &lt;your_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Save the following YAML example to a file named <literal>service-account-token-secret.yaml</literal>. The example includes a <literal>Secret</literal> object configuration that you can use to generate a service account token:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt; <co xml:id="CO36-1"/>
  annotations:
    kubernetes.io/service-account.name: "sa-name" <co xml:id="CO36-2"/>
type: kubernetes.io/service-account-token <co xml:id="CO36-3"/></programlisting>
<calloutlist>
<callout arearefs="CO36-1">
<para>Replace <literal>&lt;secret_name&gt;</literal> with the name of your service token secret.</para>
</callout>
<callout arearefs="CO36-2">
<para>Specifies an existing service account name. If you are creating both the <literal>ServiceAccount</literal> and the <literal>Secret</literal> objects, create the <literal>ServiceAccount</literal> object first.</para>
</callout>
<callout arearefs="CO36-3">
<para>Specifies a service account token secret type.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Generate the service account token by applying the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f service-account-token-secret.yaml</programlisting>
</listitem>
<listitem>
<simpara>Get the service account token from the secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;sa_token_secret&gt; -o jsonpath='{.data.token}' | base64 --decode <co xml:id="CO37-1"/></programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ayJhbGciOiJSUzI1NiIsImtpZCI6IklOb2dtck1qZ3hCSWpoNnh5YnZhSE9QMkk3YnRZMVZoclFfQTZfRFp1YlUifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImJ1aWxkZXItdG9rZW4tdHZrbnIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiYnVpbGRlciIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjNmZGU2MGZmLTA1NGYtNDkyZi04YzhjLTNlZjE0NDk3MmFmNyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmJ1aWxkZXIifQ.OmqFTDuMHC_lYvvEUrjr1x453hlEEHYcxS9VKSzmRkP1SiVZWPNPkTWlfNRp6bIUZD3U6aN3N7dMSN0eI5hu36xPgpKTdvuckKLTCnelMx6cxOdAbrcw1mCmOClNscwjS1KO1kzMtYnnq8rXHiMJELsNlhnRyyIXRTtNBsy4t64T3283s3SLsancyx0gy0ujx-Ch3uKAKdZi5iT-I8jnnQ-ds5THDs2h65RJhgglQEmSxpHrLGZFmyHAQI-_SjvmHZPXEc482x3SkaQHNLqpmrpJorNqh1M8ZHKzlujhZgVooMvJmWPXTb2vnvi3DGn2XI-hZxl1yD2yGH1RBpYUHA</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO37-1">
<para>Replace &lt;sa_token_secret&gt; with the name of your service token secret.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use your service account token to authenticate with the API of your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -X GET &lt;openshift_cluster_api&gt; --header "Authorization: Bearer &lt;token&gt;" <co xml:id="CO38-1"/> <co xml:id="CO38-2"/></programlisting>
<calloutlist>
<callout arearefs="CO38-1">
<para>Replace <literal>&lt;openshift_cluster_api&gt;</literal> with the OpenShift cluster API.</para>
</callout>
<callout arearefs="CO38-2">
<para>Replace <literal>&lt;token&gt;</literal> with the service account token that is output in the preceding command.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-pods-secrets-certificates-about_nodes-pods-secrets">
<title>About using signed certificates with secrets</title>
<simpara>To secure communication to your service, you can configure {product-title} to generate a signed
serving certificate/key pair that you can add into a secret in a project.</simpara>
<simpara>A <emphasis>service serving certificate secret</emphasis> is intended to support complex middleware
applications that need out-of-the-box certificates. It has the same settings as
the server certificates generated by the administrator tooling for nodes and
masters.</simpara>
<formalpara>
<title>Service <literal>Pod</literal> spec configured for a service serving certificates secret.</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Service
metadata:
  name: registry
  annotations:
    service.beta.openshift.io/serving-cert-secret-name: registry-cert<co xml:id="CO39-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO39-1">
<para>Specify the name for the certificate</para>
</callout>
</calloutlist>
<simpara>Other pods can trust cluster-created certificates (which are only signed for
internal DNS names), by using the CA bundle in the
<emphasis role="strong"><emphasis>/var/run/secrets/kubernetes.io/serviceaccount/service-ca.crt</emphasis></emphasis> file that is
automatically mounted in their pod.</simpara>
<simpara>The signature algorithm for this feature is <literal>x509.SHA256WithRSA</literal>. To manually
rotate, delete the generated secret. A new certificate is created.</simpara>
<section xml:id="nodes-pods-secrets-certificates-creating_nodes-pods-secrets">
<title>Generating signed certificates for use with secrets</title>
<simpara>To use a signed serving certificate/key pair with a pod, create or edit the service to add
the <literal>service.beta.openshift.io/serving-cert-secret-name</literal> annotation, then add the secret to the pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>To create a <emphasis>service serving certificate secret</emphasis>:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the <literal>Pod</literal> spec for your service.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>service.beta.openshift.io/serving-cert-secret-name</literal> annotation
with the name you want to use for your secret.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Service
apiVersion: v1
metadata:
  name: my-service
  annotations:
      service.beta.openshift.io/serving-cert-secret-name: my-cert <co xml:id="CO40-1"/>
spec:
  selector:
    app: MyApp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376</programlisting>
<simpara>The certificate and key are in PEM format, stored in <literal>tls.crt</literal> and <literal>tls.key</literal>
respectively.</simpara>
</listitem>
<listitem>
<simpara>Create the service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the secret to make sure it was created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>View a list of all secrets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secrets</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                     TYPE                                  DATA      AGE
my-cert                  kubernetes.io/tls                     2         9m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View details on your secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe secret my-cert</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         my-cert
Namespace:    openshift-console
Labels:       &lt;none&gt;
Annotations:  service.beta.openshift.io/expiry: 2023-03-08T23:22:40Z
              service.beta.openshift.io/originating-service-name: my-service
              service.beta.openshift.io/originating-service-uid: 640f0ec3-afc2-4380-bf31-a8c784846a11
              service.beta.openshift.io/expiry: 2023-03-08T23:22:40Z

Type:  kubernetes.io/tls

Data
====
tls.key:  1679 bytes
tls.crt:  2595 bytes</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Edit your <literal>Pod</literal> spec with that secret.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-service-pod
spec:
  containers:
  - name: mypod
    image: redis
    volumeMounts:
    - name: my-container
      mountPath: "/etc/my-path"
  volumes:
  - name: my-volume
    secret:
      secretName: my-cert
      items:
      - key: username
        path: my-group/my-username
        mode: 511</programlisting>
<simpara>When it is available, your pod will run.
The certificate will be good for the internal service DNS name,
<literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal>.</simpara>
<simpara>The certificate/key pair is automatically replaced when it gets
close to expiration. View the expiration date in the
<literal>service.beta.openshift.io/expiry</literal> annotation on the secret, which is in
RFC3339 format.</simpara>
<note>
<simpara>In most cases, the service DNS name
<literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal> is not externally routable. The
primary use of <literal>&lt;service.name&gt;.&lt;service.namespace&gt;.svc</literal> is for intracluster or
intraservice communication, and with re-encrypt routes.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-secrets-troubleshooting_nodes-pods-secrets">
<title>Troubleshooting secrets</title>
<simpara>If a service certificate generation fails with (service&#8217;s
<literal>service.beta.openshift.io/serving-cert-generation-error</literal> annotation
contains):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">secret/ssl-key references serviceUID 62ad25ca-d703-11e6-9d6f-0e9c0057b608, which does not match 77b6dd80-d716-11e6-9d6f-0e9c0057b60</programlisting>
<simpara>The service that generated the certificate no longer exists, or has a different
<literal>serviceUID</literal>. You must force certificates regeneration by removing the old
secret, and clearing the following annotations on the service
<literal>service.beta.openshift.io/serving-cert-generation-error</literal>,
<literal>service.beta.openshift.io/serving-cert-generation-error-num</literal>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Delete the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret &lt;secret_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Clear the annotations:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service &lt;service_name&gt; service.beta.openshift.io/serving-cert-generation-error-</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate service &lt;service_name&gt; service.beta.openshift.io/serving-cert-generation-error-num-</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>The command removing annotation has a <literal>-</literal> after the annotation name to be
removed.</simpara>
</note>
</section>
</section>
<section xml:id="nodes-pods-secrets-store">
<title>Providing sensitive data to pods by using an external secrets store</title>

<simpara>Some applications need sensitive information, such as passwords and user names, that you do not want developers to have.</simpara>
<simpara>As an alternative to using Kubernetes <literal>Secret</literal> objects to provide sensitive information, you can use an external secrets store to store the sensitive information. You can use the Secrets Store CSI Driver Operator to integrate with an external secrets store and mount the secret content as a pod volume.</simpara>
<important>
<simpara>The Secrets Store CSI Driver Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="persistent-storage-csi-secrets-store-driver-overview_nodes-pods-secrets-store">
<title>About the Secrets Store CSI Driver Operator</title>
<simpara>Kubernetes secrets are stored with Base64 encoding. etcd provides encryption at rest for these secrets, but when secrets are retrieved, they are decrypted and presented to the user. If role-based access control is not configured properly on your cluster, anyone with API or etcd access can retrieve or modify a secret. Additionally, anyone who is authorized to create a pod in a namespace can use that access to read any secret in that namespace.</simpara>
<simpara>To store and manage your secrets securely, you can configure the {product-title} Secrets Store Container Storage Interface (CSI) Driver Operator to mount secrets from an external secret management system, such as Azure Key Vault, by using a provider plugin. Applications can then use the secret, but the secret does not persist on the system after the application pod is destroyed.</simpara>
<simpara>The Secrets Store CSI Driver Operator, <literal>secrets-store.csi.k8s.io</literal>, enables {product-title} to mount multiple secrets, keys, and certificates stored in enterprise-grade external secrets stores into pods as a volume. The Secrets Store CSI Driver Operator communicates with the provider using gRPC to fetch the mount contents from the specified external secrets store. After the volume is attached, the data in it is mounted into the container&#8217;s file system. Secrets store volumes are mounted in-line.</simpara>
<section xml:id="secrets-store-providers_nodes-pods-secrets-store">
<title>Secrets store providers</title>
<simpara>The following secrets store providers are available for use with the Secrets Store CSI Driver Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS Secrets Manager</simpara>
</listitem>
<listitem>
<simpara>AWS Systems Manager Parameter Store</simpara>
</listitem>
<listitem>
<simpara>Azure Key Vault</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="secrets-store-auto-rotation_nodes-pods-secrets-store">
<title>Automatic rotation</title>
<simpara>The Secrets Store CSI driver periodically rotates the content in the mounted volume with the content from the external secrets store. If a secret is updated in the external secrets store, the secret will be updated in the mounted volume. The Secrets Store CSI Driver Operator polls for updates every 2 minutes.</simpara>
<simpara>If you enabled synchronization of mounted content as Kubernetes secrets, the Kubernetes secrets are also rotated.</simpara>
<simpara>Applications consuming the secret data must watch for updates to the secrets.</simpara>
</section>
</section>
<section xml:id="persistent-storage-csi-secrets-store-driver-install_nodes-pods-secrets-store">
<title>Installing the Secrets Store CSI driver</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Administrator access to the cluster.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the Secrets Store CSI driver:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Secrets Store CSI Driver Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Locate the Secrets Store CSI Driver Operator by typing "Secrets Store CSI" in the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Secrets Store CSI Driver Operator</emphasis> button.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Secrets Store CSI Driver Operator</emphasis> page, click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">All namespaces on the cluster (default)</emphasis> is selected.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installed Namespace</emphasis> is set to <emphasis role="strong">openshift-cluster-csi-drivers</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
<simpara>After the installation finishes, the Secrets Store CSI Driver Operator is listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterCSIDriver</literal> instance for the driver (<literal>secrets-store.csi.k8s.io</literal>):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis> &#8594; <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, click <emphasis role="strong">Create ClusterCSIDriver</emphasis>.</simpara>
<simpara>Use the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: secrets-store.csi.k8s.io
spec:
  managementState: Managed</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="mounting-secrets-external-secrets-store">
<title>Mounting secrets from an external secrets store to a CSI volume</title>
<simpara>After installing the Secrets Store CSI Driver Operator, you can mount secrets from one of the following external secrets stores to a CSI volume:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-secrets-store.xml#secrets-store-aws_nodes-pods-secrets-store">AWS Secrets Manager</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-secrets-store.xml#secrets-store-aws_nodes-pods-secrets-store-parameter-store">AWS Systems Manager Parameter Store</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-secrets-store.xml#secrets-store-azure_nodes-pods-secrets-store">Azure Key Vault</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="secrets-store-aws_nodes-pods-secrets-store">
<title>Mounting secrets from AWS Secrets Manager</title>
<simpara>You can use the Secrets Store CSI Driver Operator to mount secrets from AWS Secrets Manager to a CSI volume in {product-title}. To mount secrets from AWS Secrets Manager, your cluster must be installed on AWS and use AWS Security Token Service (STS).</simpara>
<important>
<simpara>It is not supported to use the Secrets Store CSI Driver Operator with AWS Secrets Manager in a hosted control plane cluster.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster is installed on AWS and uses AWS Security Token Service (STS).</simpara>
</listitem>
<listitem>
<simpara>You have installed the Secrets Store CSI Driver Operator. See <emphasis>Installing the Secrets Store CSI driver</emphasis> for instructions.</simpara>
</listitem>
<listitem>
<simpara>You have configured AWS Secrets Manager to store the required secrets.</simpara>
</listitem>
<listitem>
<simpara>You have extracted and prepared the <literal>ccoctl</literal> binary.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>jq</literal> CLI tool.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the AWS Secrets Manager provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following configuration for the provider resources:</simpara>
<important>
<simpara>The AWS Secrets Manager provider for the Secrets Store CSI driver is an upstream provider.</simpara>
<simpara>This configuration is modified from the configuration provided in the upstream <link xl:href="https://github.com/aws/secrets-store-csi-driver-provider-aws#installing-the-aws-provider">AWS documentation</link> so that it works properly with {product-title}. Changes to this configuration might impact functionality.</simpara>
</important>
<formalpara>
<title>Example <literal>aws-provider.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-secrets-store-provider-aws
  namespace: openshift-cluster-csi-drivers
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csi-secrets-store-provider-aws-cluster-role
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: csi-secrets-store-provider-aws-cluster-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: csi-secrets-store-provider-aws-cluster-role
subjects:
- kind: ServiceAccount
  name: csi-secrets-store-provider-aws
  namespace: openshift-cluster-csi-drivers
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: openshift-cluster-csi-drivers
  name: csi-secrets-store-provider-aws
  labels:
    app: csi-secrets-store-provider-aws
spec:
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: csi-secrets-store-provider-aws
  template:
    metadata:
      labels:
        app: csi-secrets-store-provider-aws
    spec:
      serviceAccountName: csi-secrets-store-provider-aws
      hostNetwork: false
      containers:
        - name: provider-aws-installer
          image: public.ecr.aws/aws-secrets-manager/secrets-store-csi-driver-provider-aws:1.0.r2-50-g5b4aca1-2023.06.09.21.19
          imagePullPolicy: Always
          args:
              - --provider-volume=/etc/kubernetes/secrets-store-csi-providers
          resources:
            requests:
              cpu: 50m
              memory: 100Mi
            limits:
              cpu: 50m
              memory: 100Mi
          securityContext:
            privileged: true
          volumeMounts:
            - mountPath: "/etc/kubernetes/secrets-store-csi-providers"
              name: providervol
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: HostToContainer
      tolerations:
      - operator: Exists
      volumes:
        - name: providervol
          hostPath:
            path: "/etc/kubernetes/secrets-store-csi-providers"
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: DirectoryOrCreate
      nodeSelector:
        kubernetes.io/os: linux</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Grant privileged access to the <literal>csi-secrets-store-provider-aws</literal> service account by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user privileged -z csi-secrets-store-provider-aws -n openshift-cluster-csi-drivers</programlisting>
</listitem>
<listitem>
<simpara>Create the provider resources by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f aws-provider.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Grant permission to allow the service account to read the AWS secret object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a directory to contain the credentials request by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir credentialsrequest-dir-aws</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file with the following configuration for the credentials request:</simpara>
<formalpara>
<title>Example <literal>credentialsrequest.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: aws-provider-test
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - "secretsmanager:GetSecretValue"
      - "secretsmanager:DescribeSecret"
      effect: Allow
      resource: "arn:*:secretsmanager:*:*:secret:testSecret-??????"
  secretRef:
    name: aws-creds
    namespace: my-namespace
  serviceAccountNames:
  - aws-provider</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Retrieve the OIDC provider by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get --raw=/.well-known/openid-configuration | jq -r '.issuer'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;oidc_provider_name&gt;</programlisting>
</para>
</formalpara>
<simpara>Copy the OIDC provider name <literal>&lt;oidc_provider_name&gt;</literal> from the output to use in the next step.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>ccoctl</literal> tool to process the credentials request by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-iam-roles \
    --name my-role --region=&lt;aws_region&gt; \
    --credentials-requests-dir=credentialsrequest-dir-aws \
    --identity-provider-arn arn:aws:iam::&lt;aws_account&gt;:oidc-provider/&lt;oidc_provider_name&gt; --output-dir=credrequests-ccoctl-output</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2023/05/15 18:10:34 Role arn:aws:iam::&lt;aws_account_id&gt;:role/my-role-my-namespace-aws-creds created
2023/05/15 18:10:34 Saved credentials configuration to: credrequests-ccoctl-output/manifests/my-namespace-aws-creds-credentials.yaml
2023/05/15 18:10:35 Updated Role policy for Role my-role-my-namespace-aws-creds</programlisting>
</para>
</formalpara>
<simpara>Copy the <literal>&lt;aws_role_arn&gt;</literal> from the output to use in the next step. For example, <literal>arn:aws:iam::&lt;aws_account_id&gt;:role/my-role-my-namespace-aws-creds</literal>.</simpara>
</listitem>
<listitem>
<simpara>Bind the service account with the role ARN by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate -n my-namespace sa/aws-provider eks.amazonaws.com/role-arn="&lt;aws_role_arn&gt;"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a secret provider class to define your secrets store provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>SecretProviderClass</literal> object:</simpara>
<formalpara>
<title>Example <literal>secret-provider-class-aws.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-aws-provider                   <co xml:id="CO40-2"/>
  namespace: my-namespace                 <co xml:id="CO40-3"/>
spec:
  provider: aws                           <co xml:id="CO40-4"/>
  parameters:                             <co xml:id="CO40-5"/>
    objects: |
      - objectName: "testSecret"
        objectType: "secretsmanager"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO40-1 CO40-2">
<para>Specify the name for the secret provider class.</para>
</callout>
<callout arearefs="CO40-3">
<para>Specify the namespace for the secret provider class.</para>
</callout>
<callout arearefs="CO40-4">
<para>Specify the provider as <literal>aws</literal>.</para>
</callout>
<callout arearefs="CO40-5">
<para>Specify the provider-specific configuration parameters.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>SecretProviderClass</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret-provider-class-aws.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a deployment to use this secret provider class:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Deployment</literal> object:</simpara>
<formalpara>
<title>Example <literal>deployment.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-aws-deployment                              <co xml:id="CO41-1"/>
  namespace: my-namespace                              <co xml:id="CO41-2"/>
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-storage
  template:
    metadata:
      labels:
        app: my-storage
    spec:
      containers:
      - name: busybox
        image: k8s.gcr.io/e2e-test-images/busybox:1.29
        command:
          - "/bin/sleep"
          - "10000"
        volumeMounts:
        - name: secrets-store-inline
          mountPath: "/mnt/secrets-store"
          readOnly: true
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "my-aws-provider" <co xml:id="CO41-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO41-1">
<para>Specify the name for the deployment.</para>
</callout>
<callout arearefs="CO41-2">
<para>Specify the namespace for the deployment. This must be the same namespace as the secret provider class.</para>
</callout>
<callout arearefs="CO41-3">
<para>Specify the name of the secret provider class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f deployment.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that you can access the secrets from AWS Secrets Manager in the pod volume mount:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the secrets in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- ls /mnt/secrets-store/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">testSecret</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a secret in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- cat /mnt/secrets-store/testSecret</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">&lt;secret_value&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_aws/installing-aws-customizations.xml#cco-ccoctl-configuring_installing-aws-customizations">Configuring the Cloud Credential Operator utility</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="secrets-store-aws_nodes-pods-secrets-store-parameter-store">
<title>Mounting secrets from AWS Systems Manager Parameter Store</title>
<simpara>You can use the Secrets Store CSI Driver Operator to mount secrets from AWS Systems Manager Parameter Store to a CSI volume in {product-title}. To mount secrets from AWS Systems Manager Parameter Store, your cluster must be installed on AWS and use AWS Security Token Service (STS).</simpara>
<important>
<simpara>It is not supported to use the Secrets Store CSI Driver Operator with AWS Systems Manager Parameter Store in a hosted control plane cluster.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster is installed on AWS and uses AWS Security Token Service (STS).</simpara>
</listitem>
<listitem>
<simpara>You have installed the Secrets Store CSI Driver Operator. See <emphasis>Installing the Secrets Store CSI driver</emphasis> for instructions.</simpara>
</listitem>
<listitem>
<simpara>You have configured AWS Systems Manager Parameter Store to store the required secrets.</simpara>
</listitem>
<listitem>
<simpara>You have extracted and prepared the <literal>ccoctl</literal> binary.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>jq</literal> CLI tool.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the AWS Systems Manager Parameter Store provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following configuration for the provider resources:</simpara>
<important>
<simpara>The AWS Systems Manager Parameter Store provider for the Secrets Store CSI driver is an upstream provider.</simpara>
<simpara>This configuration is modified from the configuration provided in the upstream <link xl:href="https://github.com/aws/secrets-store-csi-driver-provider-aws#installing-the-aws-provider">AWS documentation</link> so that it works properly with {product-title}. Changes to this configuration might impact functionality.</simpara>
</important>
<formalpara>
<title>Example <literal>aws-provider.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-secrets-store-provider-aws
  namespace: openshift-cluster-csi-drivers
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csi-secrets-store-provider-aws-cluster-role
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: csi-secrets-store-provider-aws-cluster-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: csi-secrets-store-provider-aws-cluster-role
subjects:
- kind: ServiceAccount
  name: csi-secrets-store-provider-aws
  namespace: openshift-cluster-csi-drivers
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: openshift-cluster-csi-drivers
  name: csi-secrets-store-provider-aws
  labels:
    app: csi-secrets-store-provider-aws
spec:
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: csi-secrets-store-provider-aws
  template:
    metadata:
      labels:
        app: csi-secrets-store-provider-aws
    spec:
      serviceAccountName: csi-secrets-store-provider-aws
      hostNetwork: false
      containers:
        - name: provider-aws-installer
          image: public.ecr.aws/aws-secrets-manager/secrets-store-csi-driver-provider-aws:1.0.r2-50-g5b4aca1-2023.06.09.21.19
          imagePullPolicy: Always
          args:
              - --provider-volume=/etc/kubernetes/secrets-store-csi-providers
          resources:
            requests:
              cpu: 50m
              memory: 100Mi
            limits:
              cpu: 50m
              memory: 100Mi
          securityContext:
            privileged: true
          volumeMounts:
            - mountPath: "/etc/kubernetes/secrets-store-csi-providers"
              name: providervol
            - name: mountpoint-dir
              mountPath: /var/lib/kubelet/pods
              mountPropagation: HostToContainer
      tolerations:
      - operator: Exists
      volumes:
        - name: providervol
          hostPath:
            path: "/etc/kubernetes/secrets-store-csi-providers"
        - name: mountpoint-dir
          hostPath:
            path: /var/lib/kubelet/pods
            type: DirectoryOrCreate
      nodeSelector:
        kubernetes.io/os: linux</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Grant privileged access to the <literal>csi-secrets-store-provider-aws</literal> service account by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user privileged -z csi-secrets-store-provider-aws -n openshift-cluster-csi-drivers</programlisting>
</listitem>
<listitem>
<simpara>Create the provider resources by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f aws-provider.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Grant permission to allow the service account to read the AWS secret object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a directory to contain the credentials request by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir credentialsrequest-dir-aws</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file with the following configuration for the credentials request:</simpara>
<formalpara>
<title>Example <literal>credentialsrequest.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: aws-provider-test
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - "ssm:GetParameter"
      - "ssm:GetParameters"
      effect: Allow
      resource: "arn:*:ssm:*:*:parameter/testParameter*"
  secretRef:
    name: aws-creds
    namespace: my-namespace
  serviceAccountNames:
  - aws-provider</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Retrieve the OIDC provider by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get --raw=/.well-known/openid-configuration | jq -r '.issuer'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://&lt;oidc_provider_name&gt;</programlisting>
</para>
</formalpara>
<simpara>Copy the OIDC provider name <literal>&lt;oidc_provider_name&gt;</literal> from the output to use in the next step.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>ccoctl</literal> tool to process the credentials request by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-iam-roles \
    --name my-role --region=&lt;aws_region&gt; \
    --credentials-requests-dir=credentialsrequest-dir-aws \
    --identity-provider-arn arn:aws:iam::&lt;aws_account&gt;:oidc-provider/&lt;oidc_provider_name&gt; --output-dir=credrequests-ccoctl-output</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2023/05/15 18:10:34 Role arn:aws:iam::&lt;aws_account_id&gt;:role/my-role-my-namespace-aws-creds created
2023/05/15 18:10:34 Saved credentials configuration to: credrequests-ccoctl-output/manifests/my-namespace-aws-creds-credentials.yaml
2023/05/15 18:10:35 Updated Role policy for Role my-role-my-namespace-aws-creds</programlisting>
</para>
</formalpara>
<simpara>Copy the <literal>&lt;aws_role_arn&gt;</literal> from the output to use in the next step. For example, <literal>arn:aws:iam::&lt;aws_account_id&gt;:role/my-role-my-namespace-aws-creds</literal>.</simpara>
</listitem>
<listitem>
<simpara>Bind the service account with the role ARN by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate -n my-namespace sa/aws-provider eks.amazonaws.com/role-arn="&lt;aws_role_arn&gt;"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a secret provider class to define your secrets store provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>SecretProviderClass</literal> object:</simpara>
<formalpara>
<title>Example <literal>secret-provider-class-aws.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-aws-provider                   <co xml:id="CO42-1"/>
  namespace: my-namespace                 <co xml:id="CO42-2"/>
spec:
  provider: aws                           <co xml:id="CO42-3"/>
  parameters:                             <co xml:id="CO42-4"/>
    objects: |
      - objectName: "testParameter"
        objectType: "ssmparameter"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO42-1">
<para>Specify the name for the secret provider class.</para>
</callout>
<callout arearefs="CO42-2">
<para>Specify the namespace for the secret provider class.</para>
</callout>
<callout arearefs="CO42-3">
<para>Specify the provider as <literal>aws</literal>.</para>
</callout>
<callout arearefs="CO42-4">
<para>Specify the provider-specific configuration parameters.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>SecretProviderClass</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret-provider-class-aws.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a deployment to use this secret provider class:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Deployment</literal> object:</simpara>
<formalpara>
<title>Example <literal>deployment.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-aws-deployment                              <co xml:id="CO43-1"/>
  namespace: my-namespace                              <co xml:id="CO43-2"/>
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-storage
  template:
    metadata:
      labels:
        app: my-storage
    spec:
      containers:
      - name: busybox
        image: k8s.gcr.io/e2e-test-images/busybox:1.29
        command:
          - "/bin/sleep"
          - "10000"
        volumeMounts:
        - name: secrets-store-inline
          mountPath: "/mnt/secrets-store"
          readOnly: true
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "my-aws-provider" <co xml:id="CO43-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO43-1">
<para>Specify the name for the deployment.</para>
</callout>
<callout arearefs="CO43-2">
<para>Specify the namespace for the deployment. This must be the same namespace as the secret provider class.</para>
</callout>
<callout arearefs="CO43-3">
<para>Specify the name of the secret provider class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f deployment.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that you can access the secrets from AWS Systems Manager Parameter Store in the pod volume mount:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the secrets in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- ls /mnt/secrets-store/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">testParameter</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a secret in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- cat /mnt/secrets-store/testSecret</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">&lt;secret_value&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_aws/installing-aws-customizations.xml#cco-ccoctl-configuring_installing-aws-customizations">Configuring the Cloud Credential Operator utility</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="secrets-store-azure_nodes-pods-secrets-store">
<title>Mounting secrets from Azure Key Vault</title>
<simpara>You can use the Secrets Store CSI Driver Operator to mount secrets from Azure Key Vault to a CSI volume in {product-title}. To mount secrets from Azure Key Vault, your cluster must be installed on Microsoft Azure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster is installed on Azure.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Secrets Store CSI Driver Operator. See <emphasis>Installing the Secrets Store CSI driver</emphasis> for instructions.</simpara>
</listitem>
<listitem>
<simpara>You have configured Azure Key Vault to store the required secrets.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Azure CLI (<literal>az</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Azure Key Vault provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following configuration for the provider resources:</simpara>
<important>
<simpara>The Azure Key Vault provider for the Secrets Store CSI driver is an upstream provider.</simpara>
<simpara>This configuration is modified from the configuration provided in the upstream <link xl:href="https://azure.github.io/secrets-store-csi-driver-provider-azure/docs/getting-started/installation/">Azure documentation</link> so that it works properly with {product-title}. Changes to this configuration might impact functionality.</simpara>
</important>
<formalpara>
<title>Example <literal>azure-provider.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  name: csi-secrets-store-provider-azure
  namespace: openshift-cluster-csi-drivers
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: csi-secrets-store-provider-azure-cluster-role
rules:
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: csi-secrets-store-provider-azure-cluster-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: csi-secrets-store-provider-azure-cluster-role
subjects:
- kind: ServiceAccount
  name: csi-secrets-store-provider-azure
  namespace: openshift-cluster-csi-drivers
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  namespace: openshift-cluster-csi-drivers
  name: csi-secrets-store-provider-azure
  labels:
    app: csi-secrets-store-provider-azure
spec:
  updateStrategy:
    type: RollingUpdate
  selector:
    matchLabels:
      app: csi-secrets-store-provider-azure
  template:
    metadata:
      labels:
        app: csi-secrets-store-provider-azure
    spec:
      serviceAccountName: csi-secrets-store-provider-azure
      hostNetwork: true
      containers:
        - name: provider-azure-installer
          image: mcr.microsoft.com/oss/azure/secrets-store/provider-azure:v1.4.1
          imagePullPolicy: IfNotPresent
          args:
            - --endpoint=unix:///provider/azure.sock
            - --construct-pem-chain=true
            - --healthz-port=8989
            - --healthz-path=/healthz
            - --healthz-timeout=5s
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8989
            failureThreshold: 3
            initialDelaySeconds: 5
            timeoutSeconds: 10
            periodSeconds: 30
          resources:
            requests:
              cpu: 50m
              memory: 100Mi
            limits:
              cpu: 50m
              memory: 100Mi
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            runAsUser: 0
            capabilities:
              drop:
              - ALL
          volumeMounts:
            - mountPath: "/provider"
              name: providervol
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: type
                operator: NotIn
                values:
                - virtual-kubelet
      volumes:
        - name: providervol
          hostPath:
            path: "/var/run/secrets-store-csi-providers"
      tolerations:
      - operator: Exists
      nodeSelector:
        kubernetes.io/os: linux</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Grant privileged access to the <literal>csi-secrets-store-provider-azure</literal> service account by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user privileged -z csi-secrets-store-provider-azure -n openshift-cluster-csi-drivers</programlisting>
</listitem>
<listitem>
<simpara>Create the provider resources by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f azure-provider.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a service principal to access the key vault:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the service principal client secret as an environment variable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ SERVICE_PRINCIPAL_CLIENT_SECRET="$(az ad sp create-for-rbac --name https://$KEYVAULT_NAME --query 'password' -otsv)"</programlisting>
</listitem>
<listitem>
<simpara>Set the service principal client ID as an environment variable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ SERVICE_PRINCIPAL_CLIENT_ID="$(az ad sp list --display-name https://$KEYVAULT_NAME --query '[0].appId' -otsv)"</programlisting>
</listitem>
<listitem>
<simpara>Create a generic secret with the service principal client secret and ID by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic secrets-store-creds -n my-namespace --from-literal clientid=${SERVICE_PRINCIPAL_CLIENT_ID} --from-literal clientsecret=${SERVICE_PRINCIPAL_CLIENT_SECRET}</programlisting>
</listitem>
<listitem>
<simpara>Apply the <literal>secrets-store.csi.k8s.io/used=true</literal> label to allow the provider to find this <literal>nodePublishSecretRef</literal> secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n my-namespace label secret secrets-store-creds secrets-store.csi.k8s.io/used=true</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a secret provider class to define your secrets store provider:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>SecretProviderClass</literal> object:</simpara>
<formalpara>
<title>Example <literal>secret-provider-class-azure.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-azure-provider                 <co xml:id="CO44-1"/>
  namespace: my-namespace                 <co xml:id="CO44-2"/>
spec:
  provider: azure                         <co xml:id="CO44-3"/>
  parameters:                             <co xml:id="CO44-4"/>
    usePodIdentity: "false"
    useVMManagedIdentity: "false"
    userAssignedIdentityID: ""
    keyvaultName: "kvname"
    objects: |
      array:
        - |
          objectName: secret1
          objectType: secret
    tenantId: "tid"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>Specify the name for the secret provider class.</para>
</callout>
<callout arearefs="CO44-2">
<para>Specify the namespace for the secret provider class.</para>
</callout>
<callout arearefs="CO44-3">
<para>Specify the provider as <literal>azure</literal>.</para>
</callout>
<callout arearefs="CO44-4">
<para>Specify the provider-specific configuration parameters.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>SecretProviderClass</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret-provider-class-azure.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a deployment to use this secret provider class:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the <literal>Deployment</literal> object:</simpara>
<formalpara>
<title>Example <literal>deployment.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-azure-deployment                            <co xml:id="CO45-1"/>
  namespace: my-namespace                              <co xml:id="CO45-2"/>
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-storage
  template:
    metadata:
      labels:
        app: my-storage
    spec:
      containers:
      - name: busybox
        image: k8s.gcr.io/e2e-test-images/busybox:1.29
        command:
          - "/bin/sleep"
          - "10000"
        volumeMounts:
        - name: secrets-store-inline
          mountPath: "/mnt/secrets-store"
          readOnly: true
      volumes:
        - name: secrets-store-inline
          csi:
            driver: secrets-store.csi.k8s.io
            readOnly: true
            volumeAttributes:
              secretProviderClass: "my-azure-provider" <co xml:id="CO45-3"/>
            nodePublishSecretRef:
              name: secrets-store-creds                <co xml:id="CO45-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO45-1">
<para>Specify the name for the deployment.</para>
</callout>
<callout arearefs="CO45-2">
<para>Specify the namespace for the deployment. This must be the same namespace as the secret provider class.</para>
</callout>
<callout arearefs="CO45-3">
<para>Specify the name of the secret provider class.</para>
</callout>
<callout arearefs="CO45-4">
<para>Specify the name of the Kubernetes secret that contains the service principal credentials to access Azure Key Vault.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Deployment</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f deployment.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that you can access the secrets from Azure Key Vault in the pod volume mount:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the secrets in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- ls /mnt/secrets-store/</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">secret1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View a secret in the pod mount:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec busybox-&lt;hash&gt; -n my-namespace -- cat /mnt/secrets-store/secret1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">my-secret-value</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="secrets-store-sync-secrets_nodes-pods-secrets-store">
<title>Enabling synchronization of mounted content as Kubernetes secrets</title>
<simpara>You can enable synchronization to create Kubernetes secrets from the content on a mounted volume. An example where you might want to enable synchronization is to use an environment variable in your deployment to reference the Kubernetes secret.</simpara>
<warning>
<simpara>Do not enable synchronization if you do not want to store your secrets on your {product-title} cluster and in etcd. Enable this functionality only if you require it, such as when you want to use environment variables to refer to the secret.</simpara>
</warning>
<simpara>If you enable synchronization, the secrets from the mounted volume are synchronized as Kubernetes secrets after you start a pod that mounts the secrets.</simpara>
<simpara>The synchronized Kubernetes secret is deleted when all pods that mounted the content are deleted.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Secrets Store CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>You have installed a secrets store provider.</simpara>
</listitem>
<listitem>
<simpara>You have created the secret provider class.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>SecretProviderClass</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit secretproviderclass my-azure-provider <co xml:id="CO46-1"/></programlisting>
<calloutlist>
<callout arearefs="CO46-1">
<para>Replace <literal>my-azure-provider</literal> with the name of your secret provider class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the <literal>secretsObjects</literal> section with the configuration for the synchronized Kubernetes secrets:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: my-azure-provider
  namespace: my-namespace
spec:
  provider: azure
  secretObjects:                                   <co xml:id="CO47-1"/>
    - secretName: tlssecret                        <co xml:id="CO47-2"/>
      type: kubernetes.io/tls                      <co xml:id="CO47-3"/>
      labels:
        environment: "test"
      data:
        - objectName: tlskey                       <co xml:id="CO47-4"/>
          key: tls.key                             <co xml:id="CO47-5"/>
        - objectName: tlscrt
          key: tls.crt
  parameters:
    usePodIdentity: "false"
    keyvaultName: "kvname"
    objects:  |
      array:
        - |
          objectName: tlskey
          objectType: secret
        - |
          objectName: tlscrt
          objectType: secret
    tenantId: "tid"</programlisting>
<calloutlist>
<callout arearefs="CO47-1">
<para>Specify the configuration for synchronized Kubernetes secrets.</para>
</callout>
<callout arearefs="CO47-2">
<para>Specify the name of the Kubernetes <literal>Secret</literal> object to create.</para>
</callout>
<callout arearefs="CO47-3">
<para>Specify the type of Kubernetes <literal>Secret</literal> object to create. For example, <literal>Opaque</literal> or <literal>kubernetes.io/tls</literal>.</para>
</callout>
<callout arearefs="CO47-4">
<para>Specify the object name or alias of the mounted content to synchronize.</para>
</callout>
<callout arearefs="CO47-5">
<para>Specify the data field from the specified <literal>objectName</literal> to populate the Kubernetes secret with.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="secrets-store-viewing-secret-versions_nodes-pods-secrets-store">
<title>Viewing the status of secrets in the pod volume mount</title>
<simpara>You can view detailed information, including the versions, of the secrets in the pod volume mount.</simpara>
<simpara>The Secrets Store CSI Driver Operator creates a <literal>SecretProviderClassPodStatus</literal> resource in the same namespace as the pod. You can review this resource to see detailed information, including versions, about the secrets in the pod volume mount.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the Secrets Store CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>You have installed a secrets store provider.</simpara>
</listitem>
<listitem>
<simpara>You have created the secret provider class.</simpara>
</listitem>
<listitem>
<simpara>You have deployed a pod that mounts a volume from the Secrets Store CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>View detailed information about the secrets in a pod volume mount by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secretproviderclasspodstatus &lt;secret_provider_class_pod_status_name&gt; -o yaml <co xml:id="CO48-1"/></programlisting>
<calloutlist>
<callout arearefs="CO48-1">
<para>The name of the secret provider class pod status object is in the format of <literal>&lt;pod_name&gt;-&lt;namespace&gt;-&lt;secret_provider_class_name&gt;</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
status:
  mounted: true
  objects:
  - id: secret/tlscrt
    version: f352293b97da4fa18d96a9528534cb33
  - id: secret/tlskey
    version: 02534bc3d5df481cb138f8b2a13951ef
  podName: busybox-&lt;hash&gt;
  secretProviderClassName: my-azure-provider
  targetPath: /var/lib/kubelet/pods/f0d49c1e-c87a-4beb-888f-37798456a3e7/volumes/kubernetes.io~csi/secrets-store-inline/mount</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-secrets-store-driver-uninstall_nodes-pods-secrets-store">
<title>Uninstalling the Secrets Store CSI Driver Operator</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Administrator access to the cluster.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To uninstall the Secrets Store CSI Driver Operator:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Stop all application pods that use the <literal>secrets-store.csi.k8s.io</literal> provider.</simpara>
</listitem>
<listitem>
<simpara>Remove any third-party provider plug-in for your chosen secret store.</simpara>
</listitem>
<listitem>
<simpara>Remove the Container Storage Interface (CSI) driver and associated manifests:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> → <emphasis role="strong">CustomResourceDefinitions</emphasis> → <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, for <emphasis role="strong">secrets-store.csi.k8s.io</emphasis>, on the far left side, click the drop-down menu, and then click <emphasis role="strong">Delete ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify that the CSI driver pods are no longer running.</simpara>
</listitem>
<listitem>
<simpara>Uninstall the Secrets Store CSI Driver Operator:</simpara>
<note>
<simpara>Before you can uninstall the Operator, you must remove the CSI driver first.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, scroll or type "Secrets Store CSI" into the <emphasis role="strong">Search by name</emphasis> box to find the Operator, and then click it.</simpara>
</listitem>
<listitem>
<simpara>On the upper, right of the <emphasis role="strong">Installed Operators</emphasis> &gt; <emphasis role="strong">Operator details</emphasis> page, click <emphasis role="strong">Actions</emphasis> → <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted on the <emphasis role="strong">Uninstall Operator</emphasis> window, click the <emphasis role="strong">Uninstall</emphasis> button to remove the Operator from the namespace. Any applications deployed by the Operator on the cluster need to be cleaned up manually.</simpara>
<simpara>After uninstalling, the Secrets Store CSI Driver Operator is no longer listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configmaps">
<title>Creating and using config maps</title>

<simpara>The following sections define config maps and how to create and use them.</simpara>
<section xml:id="nodes-pods-configmap-overview_configmaps">
<title>Understanding config maps</title>
<simpara>Many applications require configuration by using some combination of configuration files, command line arguments, and environment variables. In {product-title}, these configuration artifacts are decoupled from image content to keep containerized applications portable.</simpara>
<simpara>The <literal>ConfigMap</literal> object provides mechanisms to inject containers with configuration data while keeping containers agnostic of {product-title}. A config map can be used to store fine-grained information like individual properties or coarse-grained information like entire configuration files or JSON blobs.</simpara>
<simpara>The <literal>ConfigMap</literal> object holds key-value pairs of configuration data that can be consumed in pods or used to store configuration data for system components such as controllers. For example:</simpara>
<formalpara>
<title><literal>ConfigMap</literal> Object Definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: example-config
  namespace: my-namespace
data: <co xml:id="CO49-1"/>
  example.property.1: hello
  example.property.2: world
  example.property.file: |-
    property.1=value-1
    property.2=value-2
    property.3=value-3
binaryData:
  bar: L3Jvb3QvMTAw <co xml:id="CO49-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO49-1">
<para>Contains the configuration data.</para>
</callout>
<callout arearefs="CO49-2">
<para>Points to a file that contains non-UTF8 data, for example, a binary Java keystore file. Enter the file data in Base 64.</para>
</callout>
</calloutlist>
<note>
<simpara>You can use the <literal>binaryData</literal> field when you create a config map from a binary file, such as an image.</simpara>
</note>
<simpara>Configuration data can be consumed in pods in a variety of ways. A config map can be used to:</simpara>
<itemizedlist>
<listitem>
<simpara>Populate environment variable values in containers</simpara>
</listitem>
<listitem>
<simpara>Set command-line arguments in a container</simpara>
</listitem>
<listitem>
<simpara>Populate configuration files in a volume</simpara>
</listitem>
</itemizedlist>
<simpara>Users and system components can store configuration data in a config map.</simpara>
<simpara>A config map is similar to a secret, but designed to more conveniently support working with strings that do not contain sensitive information.</simpara>
<bridgehead xml:id="_config_map_restrictions" renderas="sect4">Config map restrictions</bridgehead>
<simpara><emphasis role="strong">A config map must be created before its contents can be consumed in pods.</emphasis></simpara>
<simpara>Controllers can be written to tolerate missing configuration data. Consult individual components configured by using config maps on a case-by-case basis.</simpara>
<simpara><emphasis role="strong"><literal>ConfigMap</literal> objects reside in a project.</emphasis></simpara>
<simpara>They can only be referenced by pods in the same project.</simpara>
<simpara><emphasis role="strong">The Kubelet only supports the use of a config map for pods it gets from the API server.</emphasis></simpara>
<simpara>This includes any pods created by using the CLI, or indirectly from a replication controller. It does not include pods created by using the {product-title} node&#8217;s <literal>--manifest-url</literal> flag, its <literal>--config</literal> flag, or its REST API because these are not common ways to create pods.</simpara>
</section>
<section xml:id="nodes-pods-configmap-create-from-console_configmaps">
<title>Creating a config map in the {product-title} web console</title>
<simpara>You can create a config map in the {product-title} web console.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To create a config map as a cluster administrator:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the Administrator perspective, select <literal>Workloads</literal> &#8594; <literal>Config Maps</literal>.</simpara>
</listitem>
<listitem>
<simpara>At the top right side of the page, select <emphasis role="strong">Create Config Map</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter the contents of your config map.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To create a config map as a developer:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the Developer perspective, select <literal>Config Maps</literal>.</simpara>
</listitem>
<listitem>
<simpara>At the top right side of the page, select <emphasis role="strong">Create Config Map</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter the contents of your config map.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-configmap-create_configmaps">
<title>Creating a config map by using the CLI</title>
<simpara>You can use the following command to create a config map from directories, specific files, or literal values.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap &lt;configmap_name&gt; [options]</programlisting>
</listitem>
</itemizedlist>
<section xml:id="nodes-pods-configmap-creating-from-directories_configmaps">
<title>Creating a config map from a directory</title>
<simpara>You can create a config map from a directory by using the <literal>--from-file</literal> flag. This method allows you to use multiple files within a directory to create a config map.</simpara>
<simpara>Each file in the directory is used to populate a key in the config map, where the name of the key is the file name, and the value of the key is the content of the file.</simpara>
<simpara>For example, the following command creates a config map with the contents of the <literal>example-files</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap game-config --from-file=example-files/</programlisting>
<simpara>View the keys in the config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe configmaps game-config</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:           game-config
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;

Data

game.properties:        158 bytes
ui.properties:          83 bytes</programlisting>
</para>
</formalpara>
<simpara>You can see that the two keys in the map are created from the file names in the directory specified in the command. The content of those keys might be large, so the output of <literal>oc describe</literal> only shows the names of the keys and their sizes.</simpara>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>You must have a directory with files that contain the data you want to populate a config map with.</simpara>
<simpara>The following procedure uses these example files: <literal>game.properties</literal> and <literal>ui.properties</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat example-files/game.properties</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat example-files/ui.properties</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a config map holding the content of each file in this directory by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap game-config \
    --from-file=example-files/</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the <literal>oc get</literal> command for the object with the <literal>-o</literal> option to see the values of the keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps game-config -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  game.properties: |-
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:34:05Z
  name: game-config
  namespace: default
  resourceVersion: "407"
  selflink: /api/v1/namespaces/default/configmaps/game-config
  uid: 30944725-d66e-11e5-8cd0-68f728db1985</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-configmap-creating-from-files_configmaps">
<title>Creating a config map from a file</title>
<simpara>You can create a config map from a file by using the <literal>--from-file</literal> flag. You can pass the <literal>--from-file</literal> option multiple times to the CLI.</simpara>
<simpara>You can also specify the key to set in a config map for content imported from a file by passing a <literal>key=value</literal> expression to the <literal>--from-file</literal> option. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap game-config-3 --from-file=game-special-key=example-files/game.properties</programlisting>
<note>
<simpara>If you create a config map from a file, you can include files containing non-UTF8 data that are placed in this field without corrupting the non-UTF8 data. {product-title} detects binary files and transparently encodes the file as <literal>MIME</literal>. On the server, the <literal>MIME</literal> payload is decoded and stored without corrupting the data.</simpara>
</note>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>You must have a directory with files that contain the data you want to populate a config map with.</simpara>
<simpara>The following procedure uses these example files: <literal>game.properties</literal> and <literal>ui.properties</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat example-files/game.properties</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat example-files/ui.properties</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a config map by specifying a specific file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap game-config-2 \
    --from-file=example-files/game.properties \
    --from-file=example-files/ui.properties</programlisting>
</listitem>
<listitem>
<simpara>Create a config map by specifying a key-value pair:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap game-config-3 \
    --from-file=game-special-key=example-files/game.properties</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the <literal>oc get</literal> command for the object with the <literal>-o</literal> option to see the values of the keys from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps game-config-2 -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  game.properties: |-
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:52:05Z
  name: game-config-2
  namespace: default
  resourceVersion: "516"
  selflink: /api/v1/namespaces/default/configmaps/game-config-2
  uid: b4952dc3-d670-11e5-8cd0-68f728db1985</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Enter the <literal>oc get</literal> command for the object with the <literal>-o</literal> option to see the values of the keys from the key-value pair:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps game-config-3 -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  game-special-key: |- <co xml:id="CO50-1"/>
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T18:54:22Z
  name: game-config-3
  namespace: default
  resourceVersion: "530"
  selflink: /api/v1/namespaces/default/configmaps/game-config-3
  uid: 05f8da22-d671-11e5-8cd0-68f728db1985</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO50-1">
<para>This is the key that you set in the preceding step.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-configmap-creating-from-literal-values_configmaps">
<title>Creating a config map from literal values</title>
<simpara>You can supply literal values for a config map.</simpara>
<simpara>The <literal>--from-literal</literal> option takes a <literal>key=value</literal> syntax, which allows literal values to be supplied directly on the command line.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a config map by specifying a literal value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap special-config \
    --from-literal=special.how=very \
    --from-literal=special.type=charm</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the <literal>oc get</literal> command for the object with the <literal>-o</literal> option to see the values of the keys:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps special-config -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  special.how: very
  special.type: charm
kind: ConfigMap
metadata:
  creationTimestamp: 2016-02-18T19:14:38Z
  name: special-config
  namespace: default
  resourceVersion: "651"
  selflink: /api/v1/namespaces/default/configmaps/special-config
  uid: dadce046-d673-11e5-8cd0-68f728db1985</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-configmaps-consuming-configmap-in-pods">
<title>Use cases: Consuming config maps in pods</title>
<simpara>The following sections describe some uses cases when consuming <literal>ConfigMap</literal>
objects in pods.</simpara>
<section xml:id="nodes-pods-configmaps-use-case-consuming-in-env-vars_configmaps">
<title>Populating environment variables in containers by using config maps</title>
<simpara>You can use config maps to populate individual environment variables in containers or to populate environment variables in containers from all keys that form valid environment variable names.</simpara>
<simpara>As an example, consider the following config map:</simpara>
<formalpara>
<title><literal>ConfigMap</literal> with two environment variables</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config <co xml:id="CO51-1"/>
  namespace: default <co xml:id="CO51-2"/>
data:
  special.how: very <co xml:id="CO51-3"/>
  special.type: charm <co xml:id="CO51-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO51-1">
<para>Name of the config map.</para>
</callout>
<callout arearefs="CO51-2">
<para>The project in which the config map resides. Config maps can only be referenced by pods in the same project.</para>
</callout>
<callout arearefs="CO51-3 CO51-4">
<para>Environment variables to inject.</para>
</callout>
</calloutlist>
<formalpara>
<title><literal>ConfigMap</literal> with one environment variable</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config <co xml:id="CO52-1"/>
  namespace: default
data:
  log_level: INFO <co xml:id="CO52-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO52-1">
<para>Name of the config map.</para>
</callout>
<callout arearefs="CO52-2">
<para>Environment variable to inject.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>You can consume the keys of this <literal>ConfigMap</literal> in a pod using <literal>configMapKeyRef</literal> sections.</simpara>
<formalpara>
<title>Sample <literal>Pod</literal> specification configured to inject specific environment variables</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env: <co xml:id="CO53-1"/>
        - name: SPECIAL_LEVEL_KEY <co xml:id="CO53-2"/>
          valueFrom:
            configMapKeyRef:
              name: special-config <co xml:id="CO53-3"/>
              key: special.how <co xml:id="CO53-4"/>
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config <co xml:id="CO53-5"/>
              key: special.type <co xml:id="CO53-6"/>
              optional: true <co xml:id="CO53-7"/>
      envFrom: <co xml:id="CO53-8"/>
        - configMapRef:
            name: env-config <co xml:id="CO53-9"/>
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO53-1">
<para>Stanza to pull the specified environment variables from a <literal>ConfigMap</literal>.</para>
</callout>
<callout arearefs="CO53-2">
<para>Name of a pod environment variable that you are injecting a key&#8217;s value into.</para>
</callout>
<callout arearefs="CO53-3 CO53-5">
<para>Name of the <literal>ConfigMap</literal> to pull specific environment variables from.</para>
</callout>
<callout arearefs="CO53-4 CO53-6">
<para>Environment variable to pull from the <literal>ConfigMap</literal>.</para>
</callout>
<callout arearefs="CO53-7">
<para>Makes the environment variable optional. As optional, the pod will be started even if the specified <literal>ConfigMap</literal> and keys do not exist.</para>
</callout>
<callout arearefs="CO53-8">
<para>Stanza to pull all environment variables from a <literal>ConfigMap</literal>.</para>
</callout>
<callout arearefs="CO53-9">
<para>Name of the <literal>ConfigMap</literal> to pull all environment variables from.</para>
</callout>
</calloutlist>
<simpara>When this pod is run, the pod logs will include the following output:</simpara>
<screen>SPECIAL_LEVEL_KEY=very
log_level=INFO</screen>
</listitem>
</itemizedlist>
<note>
<simpara><literal>SPECIAL_TYPE_KEY=charm</literal> is not listed in the example output because <literal>optional: true</literal> is set.</simpara>
</note>
</section>
<section xml:id="nodes-pods-configmaps-use-case-setting-command-line-arguments_configmaps">
<title>Setting command-line arguments for container commands with config maps</title>
<simpara>You can use a config map to set the value of the commands or arguments in a container by using the Kubernetes substitution syntax <literal>$(VAR_NAME)</literal>.</simpara>
<simpara>As an example, consider the following config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm</programlisting>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To inject values into a command in a container, you must consume the keys you want to use as environment variables. Then you can refer to them in a container&#8217;s command using the <literal>$(VAR_NAME)</literal> syntax.</simpara>
<formalpara>
<title>Sample pod specification configured to inject specific environment variables</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)" ] <co xml:id="CO54-1"/>
      env:
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.how
        - name: SPECIAL_TYPE_KEY
          valueFrom:
            configMapKeyRef:
              name: special-config
              key: special.type
  restartPolicy: Never</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>Inject the values into a command in a container using the keys you want to use as environment variables.</para>
</callout>
</calloutlist>
<simpara>When this pod is run, the output from the echo command run in the test-container container is as follows:</simpara>
<screen>very charm</screen>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-pods-configmaps-use-case-consuming-in-volumes_configmaps">
<title>Injecting content into a volume by using config maps</title>
<simpara>You can inject content into a volume by using config maps.</simpara>
<formalpara>
<title>Example <literal>ConfigMap</literal> custom resource (CR)</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm</programlisting>
</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>You have a couple different options for injecting content into a volume by using config maps.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>The most basic way to inject content into a volume by using a config map is to populate the volume with files where the key is the file name and the content of the file is the value of the key:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "cat", "/etc/config/special.how" ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config <co xml:id="CO55-1"/>
  restartPolicy: Never</programlisting>
<calloutlist>
<callout arearefs="CO55-1">
<para>File containing key.</para>
</callout>
</calloutlist>
<simpara>When this pod is run, the output of the cat command will be:</simpara>
<screen>very</screen>
</listitem>
<listitem>
<simpara>You can also control the paths within the volume where config map keys are projected:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "cat", "/etc/config/path/to/special-key" ]
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config
  volumes:
    - name: config-volume
      configMap:
        name: special-config
        items:
        - key: special.how
          path: path/to/special-key <co xml:id="CO56-1"/>
  restartPolicy: Never</programlisting>
<calloutlist>
<callout arearefs="CO56-1">
<para>Path to config map key.</para>
</callout>
</calloutlist>
<simpara>When this pod is run, the output of the cat command will be:</simpara>
<screen>very</screen>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="nodes-pods-device">
<title>Using device plugins to access external resources with pods</title>

<simpara>Device plugins allow you to use a particular device type (GPU, InfiniBand,
or other similar computing resources that require vendor-specific initialization
and setup) in your {product-title} pod without needing to write custom code.</simpara>
<section xml:id="nodes-pods-plugins-about_nodes-pods-device">
<title>Understanding device plugins</title>
<simpara>The device plugin provides a consistent and portable solution to consume hardware
devices across clusters. The device plugin provides support for these devices
through an extension mechanism, which makes these devices available to
Containers, provides health checks of these devices, and securely shares them.</simpara>
<important>
<simpara>{product-title} supports the device plugin API, but the device plugin
Containers are supported by individual vendors.</simpara>
</important>
<simpara>A device plugin is a gRPC service running on the nodes (external to
the <literal>kubelet</literal>) that is responsible for managing specific
hardware resources. Any device plugin must support following remote procedure
calls (RPCs):</simpara>
<programlisting language="golang" linenumbering="unnumbered">service DevicePlugin {
      // GetDevicePluginOptions returns options to be communicated with Device
      // Manager
      rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

      // ListAndWatch returns a stream of List of Devices
      // Whenever a Device state change or a Device disappears, ListAndWatch
      // returns the new list
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

      // Allocate is called during container creation so that the Device
      // Plug-in can run device specific operations and instruct Kubelet
      // of the steps to make the Device available in the container
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

      // PreStartcontainer is called, if indicated by Device Plug-in during
      // registration phase, before each container start. Device plug-in
      // can run device specific operations such as resetting the device
      // before making devices available to the container
      rpc PreStartcontainer(PreStartcontainerRequest) returns (PreStartcontainerResponse) {}
}</programlisting>
<bridgehead xml:id="_example_device_plugins" renderas="sect5">Example device plugins</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://github.com/GoogleCloudPlatform/Container-engine-accelerators/tree/master/cmd/nvidia_gpu">Nvidia GPU device plugin for COS-based operating system</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/NVIDIA/k8s-device-plugin">Nvidia official GPU device plugin</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/vikaschoudhary16/sfc-device-plugin">Solarflare device plugin</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/kubevirt/kubernetes-device-plugins">KubeVirt device plugins: vfio and kvm</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/ibm-s390-cloud/k8s-cex-dev-plugin">Kubernetes device plugin for IBM&#174; Crypto Express (CEX) cards</link></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For easy device plugin reference implementation, there is a stub device plugin
in the Device Manager code:
<emphasis role="strong"><emphasis>vendor/k8s.io/kubernetes/pkg/kubelet/cm/deviceplugin/device_plugin_stub.go</emphasis></emphasis>.</simpara>
</note>
<section xml:id="methods-for-deploying-a-device-plugin_nodes-pods-device">
<title>Methods for deploying a device plugin</title>
<itemizedlist>
<listitem>
<simpara>Daemon sets are the recommended approach for device plugin deployments.</simpara>
</listitem>
<listitem>
<simpara>Upon start, the device plugin will try to create a UNIX domain socket at
<emphasis role="strong"><emphasis>/var/lib/kubelet/device-plugin/</emphasis></emphasis> on the node to serve RPCs from Device Manager.</simpara>
</listitem>
<listitem>
<simpara>Since device plugins must manage hardware resources, access to the host
file system, as well as socket creation, they must be run in a privileged
security context.</simpara>
</listitem>
<listitem>
<simpara>More specific details regarding deployment steps can be found with each device
plugin implementation.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-plugins-device-mgr_nodes-pods-device">
<title>Understanding the Device Manager</title>
<simpara>Device Manager provides a mechanism for advertising specialized node hardware resources
with the help of plugins known as device plugins.</simpara>
<simpara>You can advertise specialized hardware without requiring any upstream code changes.</simpara>
<important>
<simpara>{product-title} supports the device plugin API, but the device plugin
Containers are supported by individual vendors.</simpara>
</important>
<simpara>Device Manager advertises devices as <emphasis role="strong">Extended Resources</emphasis>. User pods can consume
devices, advertised by Device Manager, using the same <emphasis role="strong">Limit/Request</emphasis> mechanism,
which is used for requesting any other <emphasis role="strong">Extended Resource</emphasis>.</simpara>
<simpara>Upon start, the device plugin registers itself with Device Manager invoking <literal>Register</literal> on the
<emphasis role="strong"><emphasis>/var/lib/kubelet/device-plugins/kubelet.sock</emphasis></emphasis> and starts a gRPC service at
<emphasis role="strong"><emphasis>/var/lib/kubelet/device-plugins/&lt;plugin&gt;.sock</emphasis></emphasis> for serving Device Manager
requests.</simpara>
<simpara>Device Manager, while processing a new registration request, invokes
<literal>ListAndWatch</literal> remote procedure call (RPC) at the device plugin service. In
response, Device Manager gets a list of <emphasis role="strong">Device</emphasis> objects from the plugin over a
gRPC stream. Device Manager will keep watching on the stream for new updates
from the plugin. On the plugin side, the plugin will also keep the stream
open and whenever there is a change in the state of any of the devices, a new
device list is sent to the Device Manager over the same streaming connection.</simpara>
<simpara>While handling a new pod admission request, Kubelet passes requested <literal>Extended
Resources</literal> to the Device Manager for device allocation. Device Manager checks in
its database to verify if a corresponding plugin exists or not. If the plugin exists
and there are free allocatable devices as well as per local cache, <literal>Allocate</literal>
RPC is invoked at that particular device plugin.</simpara>
<simpara>Additionally, device plugins can also perform several other device-specific
operations, such as driver installation, device initialization, and device
resets. These functionalities vary from implementation to implementation.</simpara>
</section>
<section xml:id="nodes-pods-plugins-install_nodes-pods-device">
<title>Enabling Device Manager</title>
<simpara>Enable Device Manager to implement a device plugin to advertise specialized
hardware without any upstream code changes.</simpara>
<simpara>Device Manager provides a mechanism for advertising specialized node hardware resources
with the help of plugins known as device plugins.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> CRD for the type of node you want to configure by entering the following command.
Perform one of the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>View the machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc describe machineconfig &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc describe machineconfig 00-worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         00-worker
Namespace:
Labels:       machineconfiguration.openshift.io/role=worker <co xml:id="CO57-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO57-1">
<para>Label required for the Device Manager.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change.</simpara>
<formalpara>
<title>Sample configuration for a Device Manager CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: devicemgr <co xml:id="CO58-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
       machineconfiguration.openshift.io: devicemgr <co xml:id="CO58-2"/>
  kubeletConfig:
    feature-gates:
      - DevicePlugins=true <co xml:id="CO58-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO58-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO58-2">
<para>Enter the label from the Machine Config Pool.</para>
</callout>
<callout arearefs="CO58-3">
<para>Set <literal>DevicePlugins</literal> to 'true`.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the Device Manager:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f devicemgr.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kubeletconfig.machineconfiguration.openshift.io/devicemgr created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Ensure that Device Manager was actually enabled by confirming that
<emphasis role="strong"><emphasis>/var/lib/kubelet/device-plugins/kubelet.sock</emphasis></emphasis> is created on the node. This is
the UNIX domain socket on which the Device Manager gRPC server listens for new
plugin registrations. This sock file is created when the Kubelet is started
only if Device Manager is enabled.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-priority">
<title>Including pod priority in pod scheduling decisions</title>

<simpara>You can enable pod priority and preemption in your cluster. Pod priority indicates the importance of a pod relative to other pods and queues the pods based on that priority. pod preemption allows the cluster to evict, or preempt, lower-priority pods so that higher-priority pods can be scheduled if there is no available space on a suitable node
pod priority also affects the scheduling order of pods and out-of-resource eviction ordering on the node.</simpara>
<simpara>To use priority and preemption, you create priority classes that define the relative weight of your pods. Then, reference a priority class in the pod specification to apply that weight for scheduling.</simpara>
<section xml:id="nodes-pods-priority-about_nodes-pods-priority">
<title>Understanding pod priority</title>
<simpara>When you use the Pod Priority and Preemption feature, the scheduler orders pending pods by their priority, and a pending pod is placed ahead of other pending pods with lower priority in the scheduling queue. As a result, the higher priority pod might be scheduled sooner than pods with lower priority if its scheduling requirements are met. If a pod cannot be scheduled, scheduler continues to schedule other lower priority pods.</simpara>
<section xml:id="admin-guide-priority-preemption-priority-class_nodes-pods-priority">
<title>Pod priority classes</title>
<simpara>You can assign pods a priority class, which is a non-namespaced object that defines a mapping from a name to the integer value of the priority. The higher the value, the higher the priority.</simpara>
<simpara>A priority class object can take any 32-bit integer value smaller than or equal to 1000000000 (one billion). Reserve numbers larger than or equal to one billion for critical pods that must not be preempted or evicted. By default, {product-title} has two reserved priority classes for critical system pods to have guaranteed scheduling.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get priorityclasses</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                      VALUE        GLOBAL-DEFAULT   AGE
system-node-critical      2000001000   false            72m
system-cluster-critical   2000000000   false            72m
openshift-user-critical   1000000000   false            3d13h
cluster-logging           1000000      false            29s</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">system-node-critical</emphasis> - This priority class has a value of 2000001000 and is used for all pods that should never be evicted from a node. Examples of pods that have this priority class are <literal>sdn-ovs</literal>, <literal>sdn</literal>, and so forth. A number of critical components include the <literal>system-node-critical</literal> priority class by default, for example:</simpara>
<itemizedlist>
<listitem>
<simpara>master-api</simpara>
</listitem>
<listitem>
<simpara>master-controller</simpara>
</listitem>
<listitem>
<simpara>master-etcd</simpara>
</listitem>
<listitem>
<simpara>sdn</simpara>
</listitem>
<listitem>
<simpara>sdn-ovs</simpara>
</listitem>
<listitem>
<simpara>sync</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">system-cluster-critical</emphasis> - This priority class has a value of 2000000000 (two billion) and is used with pods that are important for the cluster. Pods with this priority class can be evicted from a node in certain circumstances. For example, pods configured with the <literal>system-node-critical</literal> priority class can take priority. However, this priority class does ensure guaranteed scheduling. Examples of pods that can have this priority class are fluentd, add-on components like descheduler, and so forth.
A number of critical components include the <literal>system-cluster-critical</literal> priority class by default, for example:</simpara>
<itemizedlist>
<listitem>
<simpara>fluentd</simpara>
</listitem>
<listitem>
<simpara>metrics-server</simpara>
</listitem>
<listitem>
<simpara>descheduler</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">openshift-user-critical</emphasis> - You can use the <literal>priorityClassName</literal> field with important pods that cannot bind their resource consumption and do not have predictable resource consumption behavior. Prometheus pods under the <literal>openshift-monitoring</literal> and <literal>openshift-user-workload-monitoring</literal> namespaces use the <literal>openshift-user-critical</literal> <literal>priorityClassName</literal>. Monitoring workloads use <literal>system-critical</literal> as their first <literal>priorityClass</literal>, but this causes problems when monitoring uses excessive memory and the nodes cannot evict them. As a result, monitoring drops priority to give the scheduler flexibility, moving heavy workloads around to keep critical nodes operating.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">cluster-logging</emphasis> - This priority is used by Fluentd to make sure Fluentd pods are scheduled to nodes over other apps.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="admin-guide-priority-preemption-names_nodes-pods-priority">
<title>Pod priority names</title>
<simpara>After you have one or more priority classes, you can create pods that specify a priority class name in a <literal>Pod</literal> spec. The priority admission controller uses the priority class name field to populate the integer value of the priority. If the named priority class is not found, the pod is rejected.</simpara>
</section>
</section>
<section xml:id="nodes-pods-priority-preempt-about_nodes-pods-priority">
<title>Understanding pod preemption</title>
<simpara>When a developer creates a pod, the pod goes into a queue. If the developer configured the pod for pod priority or preemption, the scheduler picks a pod from the queue and tries to schedule the pod on a node. If the scheduler cannot find space on an appropriate node that satisfies all the specified requirements of the pod, preemption logic is triggered for the pending pod.</simpara>
<simpara>When the scheduler preempts one or more pods on a node, the <literal>nominatedNodeName</literal> field of higher-priority <literal>Pod</literal> spec is set to the name of the node, along with the <literal>nodename</literal> field. The scheduler uses the <literal>nominatedNodeName</literal> field to keep track of the resources reserved for pods and also provides information to the user about preemptions in the clusters.</simpara>
<simpara>After the scheduler preempts a lower-priority pod, the scheduler honors the graceful termination period of the pod. If another node becomes available while scheduler is waiting for the lower-priority pod to terminate, the scheduler can schedule the higher-priority pod on that node. As a result, the <literal>nominatedNodeName</literal> field and <literal>nodeName</literal> field of the <literal>Pod</literal> spec might be different.</simpara>
<simpara>Also, if the scheduler preempts pods on a node and is waiting for termination, and a pod with a higher-priority pod than the pending pod needs to be scheduled, the scheduler can schedule the higher-priority pod instead. In such a case, the scheduler clears the <literal>nominatedNodeName</literal> of the pending pod, making the pod eligible for another node.</simpara>
<simpara>Preemption does not necessarily remove all lower-priority pods from a node. The scheduler can schedule a pending pod by removing a portion of the lower-priority pods.</simpara>
<simpara>The scheduler considers a node for pod preemption only if the pending pod can be scheduled on the node.</simpara>
<section xml:id="non-preempting-priority-class_nodes-pods-priority">
<title>Non-preempting priority classes</title>
<simpara>Pods with the preemption policy set to <literal>Never</literal> are placed in the scheduling queue ahead of lower-priority pods, but they cannot preempt other pods. A non-preempting pod waiting to be scheduled stays in the scheduling queue until sufficient resources are free and it can be scheduled. Non-preempting pods, like other pods, are subject to scheduler back-off. This means that if the scheduler tries unsuccessfully to schedule these pods, they are retried with lower frequency, allowing other pods with lower priority to be scheduled before them.</simpara>
<simpara>Non-preempting pods can still be preempted by other, high-priority pods.</simpara>
</section>
<section xml:id="priority-preemption-other_nodes-pods-priority">
<title>Pod preemption and other scheduler settings</title>
<simpara>If you enable pod priority and preemption, consider your other scheduler settings:</simpara>
<variablelist>
<varlistentry>
<term>Pod priority and pod disruption budget</term>
<listitem>
<simpara>A pod disruption budget specifies the minimum number or percentage of replicas that must be up at a time. If you specify pod disruption budgets, {product-title} respects them when preempting pods at a best effort level. The scheduler attempts to preempt pods without violating the pod disruption budget. If no such pods are found, lower-priority pods might be preempted despite their pod disruption budget requirements.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Pod priority and pod affinity</term>
<listitem>
<simpara>Pod affinity requires a new pod to be scheduled on the same node as other pods with the same label.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>If a pending pod has inter-pod affinity with one or more of the lower-priority pods on a node, the scheduler cannot preempt the lower-priority pods without violating the affinity requirements.  In this case, the scheduler looks for another node to schedule the pending pod. However, there is no guarantee that the scheduler can find an appropriate node and pending pod might not be scheduled.</simpara>
<simpara>To prevent this situation, carefully configure pod affinity with equal-priority pods.</simpara>
</section>
<section xml:id="priority-preemption-graceful_nodes-pods-priority">
<title>Graceful termination of preempted pods</title>
<simpara>When preempting a pod, the scheduler waits for the pod graceful termination period to expire, allowing the pod to finish working and exit. If the pod does not exit after the period, the scheduler kills the pod. This graceful termination period creates a time gap between the point that the scheduler preempts the pod and the time when the pending pod can be scheduled on the node.</simpara>
<simpara>To minimize this gap, configure a small graceful termination period for lower-priority pods.</simpara>
</section>
</section>
<section xml:id="nodes-pods-priority-configuring_nodes-pods-priority">
<title>Configuring priority and preemption</title>
<simpara>You apply pod priority and preemption by creating a priority class object and associating pods to the priority by using the
<literal>priorityClassName</literal> in your pod specs.</simpara>
<note>
<simpara>You cannot add a priority class directly to an existing scheduled pod.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To configure your cluster to use priority and preemption:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create one or more priority classes:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority <co xml:id="CO59-1"/>
value: 1000000 <co xml:id="CO59-2"/>
preemptionPolicy: PreemptLowerPriority <co xml:id="CO59-3"/>
globalDefault: false <co xml:id="CO59-4"/>
description: "This priority class should be used for XYZ service pods only." <co xml:id="CO59-5"/></programlisting>
<calloutlist>
<callout arearefs="CO59-1">
<para>The name of the priority class object.</para>
</callout>
<callout arearefs="CO59-2">
<para>The priority value of the object.</para>
</callout>
<callout arearefs="CO59-3">
<para>Optional. Specifies whether this priority class is preempting or non-preempting. The preemption policy defaults to <literal>PreemptLowerPriority</literal>, which allows pods of that priority class to preempt lower-priority pods. If the preemption policy is set to <literal>Never</literal>, pods in that priority class are non-preempting.</para>
</callout>
<callout arearefs="CO59-4">
<para>Optional. Specifies whether this priority class should be used for pods without a priority class name specified. This field is <literal>false</literal> by default. Only one priority class with <literal>globalDefault</literal> set to <literal>true</literal> can exist in the cluster. If there is no priority class with <literal>globalDefault:true</literal>, the priority of pods with no priority class name is zero. Adding a priority class with <literal>globalDefault:true</literal> affects only pods created after the priority class is added and does not change the priorities of existing pods.</para>
</callout>
<callout arearefs="CO59-5">
<para>Optional. Describes which pods developers should use with this priority class. Enter an arbitrary text string.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the priority class:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a pod spec to include the name of a priority class:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: high-priority <co xml:id="CO60-1"/></programlisting>
<calloutlist>
<callout arearefs="CO60-1">
<para>Specify the priority class to use with this pod.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>You can add the priority name directly to the pod configuration or to a pod template.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-pods-node-selectors">
<title>Placing pods on specific nodes using node selectors</title>

<simpara>A <emphasis>node selector</emphasis> specifies a map of key-value pairs. The rules are defined using custom labels on nodes and selectors specified in pods.</simpara>
<simpara>For the pod to be eligible to run on a node, the pod must have the indicated key-value pairs as the label on the node.</simpara>
<simpara>If you are using node affinity and node selectors in the same pod configuration, see the important considerations below.</simpara>
<section xml:id="nodes-scheduler-node-selectors-pod_nodes-pods-node-selectors">
<title>Using node selectors to control pod placement</title>
<simpara>You can use node selectors on pods and labels on nodes to control where the pod is scheduled. With node selectors, {product-title} schedules the pods on nodes that contain matching labels.</simpara>
<simpara>You add labels to a node, a compute machine set, or a machine config. Adding the label to the compute machine set ensures that if the node or machine goes down, new nodes have the label. Labels added to a node or machine config do not persist if the node or machine goes down.</simpara>
<simpara>To add node selectors to an existing pod, add a node selector to the controlling object for that pod, such as a <literal>ReplicaSet</literal> object, <literal>DaemonSet</literal> object, <literal>StatefulSet</literal> object, <literal>Deployment</literal> object, or <literal>DeploymentConfig</literal> object.
Any existing pods under that controlling object are recreated on a node with a matching label. If you are creating a new pod, you can add the node selector directly to the pod spec. If the pod does not have a controlling object, you must delete the pod, edit the pod spec, and recreate the pod.</simpara>
<note>
<simpara>You cannot add a node selector directly to an existing scheduled pod.</simpara>
</note>
<formalpara>
<title>Prerequisites</title>
<para>To add a node selector to existing pods, determine the controlling object for that pod.
For example, the <literal>router-default-66d5cf9464-m2g75</literal> pod is controlled by the <literal>router-default-66d5cf9464</literal>
replica set:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod router-default-66d5cf9464-7pwkc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
# ...
Name:               router-default-66d5cf9464-7pwkc
Namespace:          openshift-ingress
# ...
Controlled By:      ReplicaSet/router-default-66d5cf9464
# ...</programlisting>
</para>
</formalpara>
<simpara>The web console lists the controlling object under <literal>ownerReferences</literal> in the pod YAML:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: router-default-66d5cf9464-7pwkc
# ...
  ownerReferences:
    - apiVersion: apps/v1
      kind: ReplicaSet
      name: router-default-66d5cf9464
      uid: d81dd094-da26-11e9-a48a-128e7edf0312
      controller: true
      blockOwnerDeletion: true
# ...</programlisting>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add labels to a node by using a compute machine set or editing the node directly:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a <literal>MachineSet</literal> object to add labels to nodes managed by the compute machine set when a node is created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to add labels to a <literal>MachineSet</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet &lt;name&gt; --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"&lt;key&gt;"="&lt;value&gt;","&lt;key&gt;"="&lt;value&gt;"}}]'  -n openshift-machine-api</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet abc612-msrtw-worker-us-east-1c  --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"type":"user-node","region":"east"}}]'  -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: xf2bd-infra-us-east-2a
  namespace: openshift-machine-api
spec:
  template:
    spec:
      metadata:
        labels:
          region: "east"
          type: "user-node"
# ...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the <literal>MachineSet</literal> object by using the <literal>oc edit</literal> command:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit MachineSet abc612-msrtw-worker-us-east-1c -n openshift-machine-api</programlisting>
<formalpara>
<title>Example <literal>MachineSet</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet

# ...

spec:
# ...
  template:
    metadata:
# ...
    spec:
      metadata:
        labels:
          region: east
          type: user-node
# ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add labels directly to a node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Node</literal> object for the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes &lt;name&gt; &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example, to label a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes ip-10-0-142-25.ec2.internal type=user-node region=east</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a node:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: hello-node-6fbccf8d9
  labels:
    type: "user-node"
    region: "east"
# ...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node,region=east</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          STATUS   ROLES    AGE   VERSION
ip-10-0-142-25.ec2.internal   Ready    worker   17m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Add the matching node selector to a pod:</simpara>
<itemizedlist>
<listitem>
<simpara>To add a node selector to existing and future pods, add a node selector to the controlling object for the pods:</simpara>
<formalpara>
<title>Example <literal>ReplicaSet</literal> object with labels</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ReplicaSet
apiVersion: apps/v1
metadata:
  name: hello-node-6fbccf8d9
# ...
spec:
# ...
  template:
    metadata:
      creationTimestamp: null
      labels:
        ingresscontroller.operator.openshift.io/deployment-ingresscontroller: default
        pod-template-hash: 66d5cf9464
    spec:
      nodeSelector:
        kubernetes.io/os: linux
        node-role.kubernetes.io/worker: ''
        type: user-node <co xml:id="CO61-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO61-1">
<para>Add the node selector.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To add a node selector to a specific, new pod, add the selector to the <literal>Pod</literal> object directly:</simpara>
<formalpara>
<title>Example <literal>Pod</literal> object with a node selector</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: hello-node-6fbccf8d9
# ...
spec:
  nodeSelector:
    region: east
    type: user-node
# ...</programlisting>
</para>
</formalpara>
<note>
<simpara>You cannot add a node selector directly to an existing scheduled pod.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_run_once_duration_override_operator">
<title>Run Once Duration Override Operator</title>
<section xml:id="run-once-duration-override-about">
<title>Run Once Duration Override Operator overview</title>

<simpara>You can use the Run Once Duration Override Operator to specify a maximum time limit that run-once pods can be active for.</simpara>
<important>
<simpara>The Run Once Duration Override Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="run-once-about_run-once-duration-override-about">
<title>About the Run Once Duration Override Operator</title>
<simpara>{product-title} relies on run-once pods to perform tasks such as deploying a pod or performing a build. Run-once pods are pods that have a <literal>RestartPolicy</literal> of <literal>Never</literal> or <literal>OnFailure</literal>.</simpara>
<simpara>Cluster administrators can use the Run Once Duration Override Operator to force a limit on the time that those run-once pods can be active. After the time limit expires, the cluster will try to actively terminate those pods. The main reason to have such a limit is to prevent tasks such as builds to run for an excessive amount of time.</simpara>
<simpara>To apply the run-once duration override from the Run Once Duration Override Operator to run-once pods, you must enable it on each applicable namespace.</simpara>
<simpara>If both the run-once pod and the Run Once Duration Override Operator have their <literal>activeDeadlineSeconds</literal> value set, the lower of the two values is used.</simpara>
</section>
</section>
<section xml:id="run-once-duration-override-release-notes">
<title>Run Once Duration Override Operator release notes</title>

<simpara>Cluster administrators can use the Run Once Duration Override Operator to force a limit on the time that run-once pods can be active. After the time limit expires, the cluster tries to terminate the run-once pods. The main reason to have such a limit is to prevent tasks such as builds to run for an excessive amount of time.</simpara>
<simpara>To apply the run-once duration override from the Run Once Duration Override Operator to run-once pods, you must enable it on each applicable namespace.</simpara>
<simpara>These release notes track the development of the Run Once Duration Override Operator for {product-title}.</simpara>
<important>
<simpara>The Run Once Duration Override Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
</section>
<section xml:id="run-once-duration-override-install">
<title>Overriding the active deadline for run-once pods</title>

<simpara>You can use the Run Once Duration Override Operator to specify a maximum time limit that run-once pods can be active for. By enabling the run-once duration override on a namespace, all future run-once pods created or updated in that namespace have their <literal>activeDeadlineSeconds</literal> field set to the value specified by the Run Once Duration Override Operator.</simpara>
<important>
<simpara>The Run Once Duration Override Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="rodoo-install-operator_run-once-duration-override-install">
<title>Installing the Run Once Duration Override Operator</title>
<simpara>You can use the web console to install the Run Once Duration Override Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Create the required namespace for the Run Once Duration Override Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis> and click <emphasis role="strong">Create Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>openshift-run-once-duration-override-operator</literal> in the <emphasis role="strong">Name</emphasis> field and click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the Run Once Duration Override Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <emphasis role="strong">Run Once Duration Override Operator</emphasis> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Run Once Duration Override Operator</emphasis> and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>The <emphasis role="strong">Update channel</emphasis> is set to <emphasis role="strong">stable</emphasis>, which installs the latest stable release of the Run Once Duration Override Operator.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">A specific namespace on the cluster</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">openshift-run-once-duration-override-operator</emphasis> from the dropdown menu under <emphasis role="strong">Installed namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select an <emphasis role="strong">Update approval</emphasis> strategy.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Automatic</emphasis> strategy allows Operator Lifecycle Manager (OLM) to automatically update the Operator when a new version is available.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Manual</emphasis> strategy requires a user with appropriate credentials to approve the Operator update.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>RunOnceDurationOverride</literal> instance.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page, click <emphasis role="strong">Run Once Duration Override Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Run Once Duration Override</emphasis> tab and click <emphasis role="strong">Create RunOnceDurationOverride</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Edit the settings as necessary.</simpara>
<simpara>Under the <literal>runOnceDurationOverride</literal> section, you can update the <literal>spec.activeDeadlineSeconds</literal> value, if required. The predefined value is <literal>3600</literal> seconds, or 1 hour.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Log in to the OpenShift CLI.</simpara>
</listitem>
<listitem>
<simpara>Verify all pods are created and running properly.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-run-once-duration-override-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                   READY   STATUS    RESTARTS   AGE
run-once-duration-override-operator-7b88c676f6-lcxgc   1/1     Running   0          7m46s
runoncedurationoverride-62blp                          1/1     Running   0          41s
runoncedurationoverride-h8h8b                          1/1     Running   0          41s
runoncedurationoverride-tdsqk                          1/1     Running   0          41s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="rodoo-enable-override_run-once-duration-override-install">
<title>Enabling the run-once duration override on a namespace</title>
<simpara>To apply the run-once duration override from the Run Once Duration Override Operator to run-once pods, you must enable it on each applicable namespace.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Run Once Duration Override Operator is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift CLI.</simpara>
</listitem>
<listitem>
<simpara>Add the label to enable the run-once duration override to your namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;namespace&gt; \ <co xml:id="CO62-1"/>
    runoncedurationoverrides.admission.runoncedurationoverride.openshift.io/enabled=true</programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para>Specify the namespace to enable the run-once duration override on.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<simpara>After you enable the run-once duration override on this namespace, future run-once pods that are created in this namespace will have their <literal>activeDeadlineSeconds</literal> field set to the override value from the Run Once Duration Override Operator. Existing pods in this namespace will also have their <literal>activeDeadlineSeconds</literal> value set when they are updated next.</simpara>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Create a test run-once pod in the namespace that you enabled the run-once duration override on:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: example
  namespace: &lt;namespace&gt;                 <co xml:id="CO63-1"/>
spec:
  restartPolicy: Never                   <co xml:id="CO63-2"/>
  containers:
    - name: busybox
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop: ["ALL"]
        runAsNonRoot:
          true
        seccompProfile:
          type: "RuntimeDefault"
      image: busybox:1.25
      command:
        - /bin/sh
        - -ec
        - |
          while sleep 5; do date; done</programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>Replace <literal>&lt;namespace&gt;</literal> with the name of your namespace.</para>
</callout>
<callout arearefs="CO63-2">
<para>The <literal>restartPolicy</literal> must be <literal>Never</literal> or <literal>OnFailure</literal> to be a run-once pod.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify that the pod has its <literal>activeDeadlineSeconds</literal> field set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;namespace&gt; -o yaml | grep activeDeadlineSeconds</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">    activeDeadlineSeconds: 3600</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="rodoo-update-active-deadline-seconds_run-once-duration-override-install">
<title>Updating the run-once active deadline override value</title>
<simpara>You can customize the override value that the Run Once Duration Override Operator applies to run-once pods. The predefined value is <literal>3600</literal> seconds, or 1 hour.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Run Once Duration Override Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift CLI.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>RunOnceDurationOverride</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit runoncedurationoverride cluster</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>activeDeadlineSeconds</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: RunOnceDurationOverride
metadata:
# ...
spec:
  runOnceDurationOverride:
    spec:
      activeDeadlineSeconds: 1800 <co xml:id="CO64-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO64-1">
<para>Set the <literal>activeDeadlineSeconds</literal> field to the desired value, in seconds.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
<simpara>Any future run-once pods created in namespaces where the run-once duration override is enabled will have their <literal>activeDeadlineSeconds</literal> field set to this new value. Existing run-once pods in these namespaces will receive this new value when they are updated.</simpara>
</section>
</section>
<section xml:id="run-once-duration-override-uninstall">
<title>Uninstalling the Run Once Duration Override Operator</title>

<simpara>You can remove the Run Once Duration Override Operator from {product-title} by uninstalling the Operator and removing its related resources.</simpara>
<important>
<simpara>The Run Once Duration Override Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="rodoo-uninstall-operator_run-once-duration-override-uninstall">
<title>Uninstalling the Run Once Duration Override Operator</title>
<simpara>You can use the web console to uninstall the Run Once Duration Override Operator. Uninstalling the Run Once Duration Override Operator does not unset the <literal>activeDeadlineSeconds</literal> field for run-once pods, but it will no longer apply the override value to future run-once pods.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Run Once Duration Override Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <literal>openshift-run-once-duration-override-operator</literal> from the <emphasis role="strong">Project</emphasis> dropdown list.</simpara>
</listitem>
<listitem>
<simpara>Delete the <literal>RunOnceDurationOverride</literal> instance.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Run Once Duration Override Operator</emphasis> and select the <emphasis role="strong">Run Once Duration Override</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">cluster</emphasis> entry and select <emphasis role="strong">Delete RunOnceDurationOverride</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Uninstall the Run Once Duration Override Operator Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">Run Once Duration Override Operator</emphasis> entry and click <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="rodoo-uninstall-resources_run-once-duration-override-uninstall">
<title>Uninstalling Run Once Duration Override Operator resources</title>
<simpara>Optionally, after uninstalling the Run Once Duration Override Operator, you can remove its related resources from your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>You have uninstalled the Run Once Duration Override Operator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Remove CRDs that were created when the Run Once Duration Override Operator was installed:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>RunOnceDurationOverride</literal> in the <emphasis role="strong">Name</emphasis> field to filter the CRDs.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">RunOnceDurationOverride</emphasis> CRD and select <emphasis role="strong">Delete CustomResourceDefinition</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>openshift-run-once-duration-override-operator</literal> namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>openshift-run-once-duration-override-operator</literal> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">openshift-run-once-duration-override-operator</emphasis> entry and select <emphasis role="strong">Delete Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, enter <literal>openshift-run-once-duration-override-operator</literal> and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the run-once duration override label from the namespaces that it was enabled on.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select your namespace.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Edit</emphasis> next to the <emphasis role="strong">Labels</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Remove the <emphasis role="strong">runoncedurationoverrides.admission.runoncedurationoverride.openshift.io/enabled=true</emphasis> label and click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_automatically_scaling_pods_with_the_custom_metrics_autoscaler_operator">
<title>Automatically scaling pods with the Custom Metrics Autoscaler Operator</title>
<section xml:id="nodes-cma-autoscaling-custom">
<title>Custom Metrics Autoscaler Operator overview</title>

<simpara>As a developer, you can use Custom Metrics Autoscaler Operator for Red Hat OpenShift to specify how {product-title} should automatically increase or decrease the number of pods for a deployment, stateful set, custom resource, or job based on custom metrics that are not based only on CPU or memory.</simpara>
<simpara>The Custom Metrics Autoscaler Operator is an optional operator, based on the Kubernetes Event Driven Autoscaler (KEDA), that allows workloads to be scaled using additional metrics sources other than pod metrics.</simpara>
<simpara>The custom metrics autoscaler currently supports only the Prometheus, CPU, memory, and Apache Kafka metrics.</simpara>
<simpara>The Custom Metrics Autoscaler Operator scales your pods up and down based on custom, external metrics from specific applications. Your other applications continue to use other scaling methods. You configure <emphasis>triggers</emphasis>, also known as scalers, which are the source of events and metrics that the custom metrics autoscaler uses to determine how to scale. The custom metrics autoscaler uses a metrics API to convert the external metrics to a form that {product-title} can use. The custom metrics autoscaler creates a horizontal pod autoscaler (HPA) that performs the actual scaling.</simpara>
<simpara>To use the custom metrics autoscaler, you create a <literal>ScaledObject</literal> or <literal>ScaledJob</literal> object, which is a custom resource (CR) that defines the scaling metadata. You specify the deployment or job to scale, the source of the metrics to scale on (trigger), and other parameters such as the minimum and maximum replica counts allowed.</simpara>
<note>
<simpara>You can create only one scaled object or scaled job for each workload that you want to scale. Also, you cannot use a scaled object or scaled job and the horizontal pod autoscaler (HPA) on the same workload.</simpara>
</note>
<simpara>The custom metrics autoscaler, unlike the HPA, can scale to zero. If you set the <literal>minReplicaCount</literal> value in the custom metrics autoscaler CR to <literal>0</literal>, the custom metrics autoscaler scales the workload down from 1 to 0 replicas to or up from 0 replicas to 1. This is known as the <emphasis>activation phase</emphasis>. After scaling up to 1 replica, the HPA takes control of the scaling. This is known as the <emphasis>scaling phase</emphasis>.</simpara>
<simpara>Some triggers allow you to change the number of replicas that are scaled by the cluster metrics autoscaler.  In all cases, the parameter to configure the activation phase always uses the same phrase, prefixed with <emphasis>activation</emphasis>. For example, if the <literal>threshold</literal> parameter configures scaling, <literal>activationThreshold</literal> would configure activation. Configuring the activation and scaling phases allows you more flexibility with your scaling policies. For example, you can configure a higher activation phase to prevent scaling up or down if the metric is particularly low.</simpara>
<simpara>The activation value has more priority than the scaling value in case of different decisions for each. For example, if the <literal>threshold</literal> is set to <literal>10</literal>, and the <literal>activationThreshold</literal> is <literal>50</literal>, if the metric reports <literal>40</literal>, the scaler is not active and the pods are scaled to zero even if the HPA requires 4 instances.</simpara>
<simpara>You can verify that the autoscaling has taken place by reviewing the number of pods in your custom resource or by reviewing the Custom Metrics Autoscaler Operator logs for messages similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">Successfully set ScaleTarget replica count</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">Successfully updated ScaleTarget</programlisting>
<simpara>You can temporarily pause the autoscaling of a workload object, if needed. For example, you could pause autoscaling before performing cluster maintenance.</simpara>
</section>
<section xml:id="nodes-cma-autoscaling-custom-rn_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator release notes</title>

<simpara>The release notes for the Custom Metrics Autoscaler Operator for Red Hat OpenShift describe new features and enhancements, deprecated features, and known issues.</simpara>
<simpara>The Custom Metrics Autoscaler Operator uses the Kubernetes-based Event Driven Autoscaler (KEDA) and is built on top of the {product-title} horizontal pod autoscaler (HPA).</simpara>
<note>
<simpara>The Custom Metrics Autoscaler Operator for Red Hat OpenShift is provided as an installable component, with a distinct release cycle from the core {product-title}. The <link xl:href="https://access.redhat.com/support/policy/updates/openshift#cma">Red Hat OpenShift Container Platform Life Cycle Policy</link> outlines release compatibility.</simpara>
</note>
<section xml:id="nodes-pods-autoscaling-custom-rn-versions_nodes-cma-autoscaling-custom-removing">
<title>Supported versions</title>
<simpara>The following table defines the Custom Metrics Autoscaler Operator versions for each {product-title} version.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="23.0769*"/>
<colspec colname="col_2" colwidth="53.8461*"/>
<colspec colname="col_3" colwidth="23.077*"/>
<thead>
<row>
<entry align="left" valign="top">Version</entry>
<entry align="left" valign="top">{product-title} version</entry>
<entry align="left" valign="top">General availability</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>2.11.2</simpara></entry>
<entry align="left" valign="top"><simpara>4.13</simpara></entry>
<entry align="left" valign="top"><simpara>General availability</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2.11.2</simpara></entry>
<entry align="left" valign="top"><simpara>4.12</simpara></entry>
<entry align="left" valign="top"><simpara>General availability</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2.11.2</simpara></entry>
<entry align="left" valign="top"><simpara>4.11</simpara></entry>
<entry align="left" valign="top"><simpara>General availability</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2.11.2</simpara></entry>
<entry align="left" valign="top"><simpara>4.10</simpara></entry>
<entry align="left" valign="top"><simpara>General availability</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-2112_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator 2.11.2-311 release notes</title>
<simpara>This release of the Custom Metrics Autoscaler Operator 2.11.2-311 provides new features and bug fixes for running the Operator in an {product-title} cluster. The components of the Custom Metrics Autoscaler Operator 2.11.2-311 were released in <link xl:href="https://access.redhat.com/errata/RHBA-2023:5981">RHBA-2023:5981</link>.</simpara>
<important>
<simpara>Before installing this version of the Custom Metrics Autoscaler Operator, remove any previously installed Technology Preview versions or the community-supported version of KEDA.</simpara>
</important>
<section xml:id="nodes-pods-autoscaling-custom-rn-2112-new_nodes-cma-autoscaling-custom-removing">
<title>New features and enhancements</title>
<section xml:id="nodes-pods-autoscaling-custom-rn-2112-new-rosa-osd_nodes-cma-autoscaling-custom-removing">
<title>Red Hat OpenShift Service on AWS (ROSA) and OpenShift Dedicated are now supported</title>
<simpara>The Custom Metrics Autoscaler Operator 2.11.2-311 can be installed on OpenShift ROSA and OpenShift Dedicated managed clusters. Previous versions of the Custom Metrics Autoscaler Operator could be installed only in the <literal>openshift-keda</literal> namespace. This prevented the Operator from being installed on OpenShift ROSA and OpenShift Dedicated clusters. This version of Custom Metrics Autoscaler allows installation to other namespaces such as <literal>openshift-operators</literal> or <literal>keda</literal>, enabling installation into ROSA and Dedicated clusters.</simpara>
</section>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-2112-bugs_nodes-cma-autoscaling-custom-removing">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, if the Custom Metrics Autoscaler Operator was installed and configured, but not in use, the OpenShift CLI reported the <literal>couldn&#8217;t get resource list for external.metrics.k8s.io/v1beta1: Got empty response for: external.metrics.k8s.io/v1beta1</literal> error after any <literal>oc</literal> command was entered. The message, although harmless, could have caused confusion. With this fix, the <literal>Got empty response for: external.metrics&#8230;&#8203;</literal> error no longer appears inappropriately. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15779"><emphasis role="strong">OCPBUGS-15779</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, any annotation or label change to objects managed by the Custom Metrics Autoscaler were reverted by Custom Metrics Autoscaler Operator any time the Keda Controller was modified, for example after a configuration change. This caused continuous changing of labels in your objects. The Custom Metrics Autoscaler now uses its own annotation to manage labels and annotations, and annotation or label are no longer inappropriately reverted. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15590"><emphasis role="strong">OCPBUGS-15590</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-267_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator 2.10.1-267 release notes</title>
<simpara>This release of the Custom Metrics Autoscaler Operator 2.10.1-267 provides new features and bug fixes for running the Operator in an {product-title} cluster. The components of the Custom Metrics Autoscaler Operator 2.10.1-267 were released in <link xl:href="https://access.redhat.com/errata/RHBA-2023:4089">RHBA-2023:4089</link>.</simpara>
<important>
<simpara>Before installing this version of the Custom Metrics Autoscaler Operator, remove any previously installed Technology Preview versions or the community-supported version of KEDA.</simpara>
</important>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-267-bugs_nodes-cma-autoscaling-custom-removing">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>Previously, the <literal>custom-metrics-autoscaler</literal> and <literal>custom-metrics-autoscaler-adapter</literal> images did not contain time zone information. Because of this, scaled objects with cron triggers failed to work because the controllers were unable to find time zone information. With this fix, the image builds now include time zone information. As a result, scaled objects containing cron triggers now function properly. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15264"><emphasis role="strong">OCPBUGS-15264</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Custom Metrics Autoscaler Operator would attempt to take ownership of all managed objects, including objects in other namespaces and cluster-scoped objects. Because of this, the Custom Metrics Autoscaler Operator was unable to create the role binding for reading the credentials necessary to be an API server. This caused errors in the <literal>kube-system</literal> namespace. With this fix, the Custom Metrics Autoscaler Operator skips adding the <literal>ownerReference</literal> field to any object in another namespace or any cluster-scoped object. As a result, the role binding is now created without any errors. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15038"><emphasis role="strong">OCPBUGS-15038</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, the Custom Metrics Autoscaler Operator added an <literal>ownerReferences</literal> field to the <literal>openshift-keda</literal> namespace. While this did not cause functionality problems, the presence of this field could have caused confusion for cluster administrators. With this fix, the Custom Metrics Autoscaler Operator does not add the <literal>ownerReference</literal> field to the <literal>openshift-keda</literal> namespace. As a result, the <literal>openshift-keda</literal> namespace no longer has a superfluous <literal>ownerReference</literal> field. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15293"><emphasis role="strong">OCPBUGS-15293</emphasis></link>)</simpara>
</listitem>
<listitem>
<simpara>Previously, if you used a Prometheus trigger configured with authentication method other than pod identity, and the <literal>podIdentity</literal> parameter was set to <literal>none</literal>, the trigger would fail to scale. With this fix, the Custom Metrics Autoscaler for OpenShift now properly handles the <literal>none</literal> pod identity provider type. As a result, a Prometheus trigger configured with authentication method other than pod identity, and the <literal>podIdentity</literal> parameter sset to <literal>none</literal> now properly scales. (<link xl:href="https://issues.redhat.com/browse/OCPBUGS-15274"><emphasis role="strong">OCPBUGS-15274</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator 2.10.1 release notes</title>
<simpara>This release of the Custom Metrics Autoscaler Operator 2.10.1 provides new features and bug fixes for running the Operator in an {product-title} cluster. The components of the Custom Metrics Autoscaler Operator 2.10.1 were released in <link xl:href="https://access.redhat.com/errata/RHEA-2023:3199">RHEA-2023:3199</link>.</simpara>
<important>
<simpara>Before installing this version of the Custom Metrics Autoscaler Operator, remove any previously installed Technology Preview versions or the community-supported version of KEDA.</simpara>
</important>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-new_nodes-cma-autoscaling-custom-removing">
<title>New features and enhancements</title>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-ga_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator general availability</title>
<simpara>The Custom Metrics Autoscaler Operator is now generally available as of Custom Metrics Autoscaler Operator version 2.10.1.</simpara>
<important>
<simpara>Scaling by using a scaled job is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-metrics_nodes-cma-autoscaling-custom-removing">
<title>Performance metrics</title>
<simpara>You can now use the Prometheus Query Language (PromQL) to query metrics on the Custom Metrics Autoscaler Operator.</simpara>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-pause_nodes-cma-autoscaling-custom-removing">
<title>Pausing the custom metrics autoscaling for scaled objects</title>
<simpara>You can now pause the autoscaling of a scaled object, as needed, and resume autoscaling when ready.</simpara>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-fall-back_nodes-cma-autoscaling-custom-removing">
<title>Replica fall back for scaled objects</title>
<simpara>You can now specify the number of replicas to fall back to if a scaled object fails to get metrics from the source.</simpara>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-hpa-name_nodes-cma-autoscaling-custom-removing">
<title>Customizable HPA naming for scaled objects</title>
<simpara>You can now specify a custom name for the horizontal pod autoscaler in scaled objects.</simpara>
</section>
<section xml:id="nodes-pods-autoscaling-custom-rn-210-activation_nodes-cma-autoscaling-custom-removing">
<title>Activation and scaling thresholds</title>
<simpara>Because the horizontal pod autoscaler (HPA) cannot scale to or from 0 replicas, the Custom Metrics Autoscaler Operator does that scaling, after which the HPA performs the scaling. You can now specify when the  HPA takes over autoscaling, based on the number of replicas. This allows for more flexibility with your scaling policies.</simpara>
</section>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-rn-282-174_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator 2.8.2-174 release notes</title>
<simpara>This release of the Custom Metrics Autoscaler Operator 2.8.2-174 provides new features and bug fixes for running the Operator in an {product-title} cluster. The components of the Custom Metrics Autoscaler Operator 2.8.2-174 were released in <link xl:href="https://access.redhat.com/errata/RHEA-2023:1683">RHEA-2023:1683</link>.</simpara>
<important>
<simpara>The Custom Metrics Autoscaler Operator version 2.8.2-174 is a <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview</link> feature.</simpara>
</important>
<section xml:id="nodes-cma-autoscaling-custom-rn-282-174-new_nodes-cma-autoscaling-custom-removing">
<title>New features and enhancements</title>
<section xml:id="autoscaling-custom-2-8-2-upgrade-operator">
<title>Operator upgrade support</title>
<simpara>You can now upgrade from a prior version of the Custom Metrics Autoscaler Operator. See "Changing the update channel for an Operator" in the "Additional resources" for information on upgrading an Operator.</simpara>
</section>
<section xml:id="autoscaling-custom-2-8-2-must-gather">
<title>must-gather support</title>
<simpara>You can now collect data about the Custom Metrics Autoscaler Operator and its components by using the {product-title} <literal>must-gather</literal> tool. Currently, the process for using the <literal>must-gather</literal> tool with the Custom Metrics Autoscaler is different than for other operators. See "Gathering debugging data in the "Additional resources" for more information.</simpara>
</section>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-rn-282_nodes-cma-autoscaling-custom-removing">
<title>Custom Metrics Autoscaler Operator 2.8.2 release notes</title>
<simpara>This release of the Custom Metrics Autoscaler Operator 2.8.2 provides new features and bug fixes for running the Operator in an {product-title} cluster. The components of the Custom Metrics Autoscaler Operator 2.8.2 were released in <link xl:href="https://access.redhat.com/errata/RHSA-2023:1042">RHSA-2023:1042</link>.</simpara>
<important>
<simpara>The Custom Metrics Autoscaler Operator version 2.8.2 is a <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview</link> feature.</simpara>
</important>
<section xml:id="nodes-cma-autoscaling-custom-rn-282-new_nodes-cma-autoscaling-custom-removing">
<title>New features and enhancements</title>
<section xml:id="autoscaling-custom-2-8-2-audit-log">
<title>Audit Logging</title>
<simpara>You can now gather and view audit logs for the Custom Metrics Autoscaler Operator and its associated components. Audit logs are security-relevant chronological sets of records that document the sequence of activities that have affected the system by individual users, administrators, or other components of the system.</simpara>
</section>
<section xml:id="autoscaling-custom-2-8-2-kafka-metrics">
<title>Scale applications based on Apache Kafka metrics</title>
<simpara>You can now use the KEDA Apache kafka trigger/scaler to scale deployments based on an Apache Kafka topic.</simpara>
</section>
<section xml:id="autoscaling-custom-2-8-2-cpu-metrics">
<title>Scale applications based on CPU metrics</title>
<simpara>You can now use the KEDA CPU trigger/scaler to scale deployments based on CPU metrics.</simpara>
</section>
<section xml:id="autoscaling-custom-2-8-2-memory-metrics">
<title>Scale applications based on memory metrics</title>
<simpara>You can now use the KEDA memory trigger/scaler to scale deployments based on memory metrics.</simpara>
</section>
</section>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-install">
<title>Installing the custom metrics autoscaler</title>

<simpara>You can use the {product-title} web console to install the Custom Metrics Autoscaler Operator.</simpara>
<simpara>The installation creates the following five CRDs:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ClusterTriggerAuthentication</literal></simpara>
</listitem>
<listitem>
<simpara><literal>KedaController</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ScaledJob</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ScaledObject</literal></simpara>
</listitem>
<listitem>
<simpara><literal>TriggerAuthentication</literal></simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-cma-autoscaling-custom-install_nodes-cma-autoscaling-custom-install">
<title>Installing the custom metrics autoscaler</title>
<simpara>You can use the following procedure to install the Custom Metrics Autoscaler Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Remove any previously-installed Technology Preview versions of the Cluster Metrics Autoscaler Operator.</simpara>
</listitem>
<listitem>
<simpara>Remove any versions of the community-based KEDA.</simpara>
<simpara>Also, remove the KEDA 1.x custom resource definitions by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd scaledobjects.keda.k8s.io</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd triggerauthentications.keda.k8s.io</programlisting>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the {product-title} web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">Custom Metrics Autoscaler</emphasis> from the list of available Operators, and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that the <emphasis role="strong">All namespaces on the cluster (default)</emphasis> option
is selected for <emphasis role="strong">Installation Mode</emphasis>. This installs the Operator in all namespaces.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the <emphasis role="strong">openshift-keda</emphasis> namespace is selected for <emphasis role="strong">Installed Namespace</emphasis>. {product-title} creates the namespace, if not present in your cluster.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify the installation by listing the Custom Metrics Autoscaler Operator components:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <literal>openshift-keda</literal> project from the drop-down menu and verify that the <literal>custom-metrics-autoscaler-operator-*</literal> pod is running.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Deployments</emphasis> to verify that the <literal>custom-metrics-autoscaler-operator</literal> deployment is running.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Verify the installation in the OpenShift CLI using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n openshift-keda</programlisting>
<simpara>The output appears similar to the following:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                      READY   STATUS    RESTARTS   AGE
pod/custom-metrics-autoscaler-operator-5fd8d9ffd8-xt4xp   1/1     Running   0          18m

NAME                                                 READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/custom-metrics-autoscaler-operator   1/1     1            1           18m

NAME                                                            DESIRED   CURRENT   READY   AGE
replicaset.apps/custom-metrics-autoscaler-operator-5fd8d9ffd8   1         1         1       18m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Install the <literal>KedaController</literal> custom resource, which creates the required CRDs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the {product-title} web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Custom Metrics Autoscaler</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Operator Details</emphasis> page, click the <emphasis role="strong">KedaController</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">KedaController</emphasis> tab, click <emphasis role="strong">Create KedaController</emphasis> and edit the file.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: KedaController
apiVersion: keda.sh/v1alpha1
metadata:
  name: keda
  namespace: openshift-keda
spec:
  watchNamespace: '' <co xml:id="CO65-1"/>
  operator:
    logLevel: info <co xml:id="CO65-2"/>
    logEncoder: console <co xml:id="CO65-3"/>
  metricsServer:
    logLevel: '0' <co xml:id="CO65-4"/>
    auditConfig: <co xml:id="CO65-5"/>
      logFormat: "json"
      logOutputVolumeClaim: "persistentVolumeClaimName"
      policy:
        rules:
        - level: Metadata
        omitStages: ["RequestReceived"]
        omitManagedFields: false
      lifetime:
        maxAge: "2"
        maxBackup: "1"
        maxSize: "50"
  serviceAccount: {}</programlisting>
<calloutlist>
<callout arearefs="CO65-1">
<para>Specifies the namespaces that the custom autoscaler should watch. Enter names in a comma-separated list. Omit or set empty to watch all namespaces. The default is empty.</para>
</callout>
<callout arearefs="CO65-2">
<para>Specifies the level of verbosity for the Custom Metrics Autoscaler Operator log messages. The allowed values are <literal>debug</literal>, <literal>info</literal>, <literal>error</literal>. The default is <literal>info</literal>.</para>
</callout>
<callout arearefs="CO65-3">
<para>Specifies the logging format for the Custom Metrics Autoscaler Operator log messages. The allowed values are <literal>console</literal> or <literal>json</literal>. The default is <literal>console</literal>.</para>
</callout>
<callout arearefs="CO65-4">
<para>Specifies the logging level for the Custom Metrics Autoscaler Metrics Server. The allowed values are <literal>0</literal> for <literal>info</literal> and <literal>4</literal> or <literal>debug</literal>. The default is <literal>0</literal>.</para>
</callout>
<callout arearefs="CO65-5">
<para>Activates audit logging for the Custom Metrics Autoscaler Operator and specifies the audit policy to use, as described in the "Configuring audit logging" section.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the KEDA controller.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-overview-trigger">
<title>Understanding custom metrics autoscaler triggers</title>

<simpara>Triggers, also known as scalers, provide the metrics that the Custom Metrics Autoscaler Operator uses to scale your pods.</simpara>
<simpara>The custom metrics autoscaler currently supports only the Prometheus, CPU, memory, and Apache Kafka triggers.</simpara>
<simpara>You use a <literal>ScaledObject</literal> or <literal>ScaledJob</literal> custom resource to configure triggers for specific objects, as described in the sections that follow.</simpara>
<section xml:id="nodes-cma-autoscaling-custom-trigger-prom_nodes-cma-autoscaling-custom-trigger">
<title>Understanding the Prometheus trigger</title>
<simpara>You can scale pods based on Prometheus metrics, which can use the installed {product-title} monitoring or an external Prometheus server as the metrics source. See "Additional resources" for information on the configurations required to use the {product-title} monitoring as a source for metrics.</simpara>
<note>
<simpara>If Prometheus is collecting metrics from the application that the custom metrics autoscaler is scaling, do not set the minimum replicas to <literal>0</literal> in the custom resource. If there are no application pods, the custom metrics autoscaler does not have any metrics to scale on.</simpara>
</note>
<formalpara>
<title>Example scaled object with a Prometheus target</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: prom-scaledobject
  namespace: my-namespace
spec:
# ...
  triggers:
  - type: prometheus <co xml:id="CO66-1"/>
    metadata:
      serverAddress: https://thanos-querier.openshift-monitoring.svc.cluster.local:9092 <co xml:id="CO66-2"/>
      namespace: kedatest <co xml:id="CO66-3"/>
      metricName: http_requests_total <co xml:id="CO66-4"/>
      threshold: '5' <co xml:id="CO66-5"/>
      query: sum(rate(http_requests_total{job="test-app"}[1m])) <co xml:id="CO66-6"/>
      authModes: basic <co xml:id="CO66-7"/>
      cortexOrgID: my-org <co xml:id="CO66-8"/>
      ignoreNullValues: false <co xml:id="CO66-9"/>
      unsafeSsl: false <co xml:id="CO66-10"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1">
<para>Specifies Prometheus as the trigger type.</para>
</callout>
<callout arearefs="CO66-2">
<para>Specifies the address of the Prometheus server. This example uses  {product-title} monitoring.</para>
</callout>
<callout arearefs="CO66-3">
<para>Optional: Specifies the namespace of the object you want to scale. This parameter is mandatory if using {product-title} monitoring as a source for the metrics.</para>
</callout>
<callout arearefs="CO66-4">
<para>Specifies the name to identify the metric in the <literal>external.metrics.k8s.io</literal> API. If you are using more than one trigger, all metric names must be unique.</para>
</callout>
<callout arearefs="CO66-5">
<para>Specifies the value that triggers scaling. Must be specified as a quoted string value.</para>
</callout>
<callout arearefs="CO66-6">
<para>Specifies the Prometheus query to use.</para>
</callout>
<callout arearefs="CO66-7">
<para>Specifies the authentication method to use. Prometheus scalers support bearer authentication (<literal>bearer</literal>), basic authentication (<literal>basic</literal>), or TLS authentication (<literal>tls</literal>). You configure the specific authentication parameters in a trigger authentication, as discussed in a following section. As needed, you can also use a secret.</para>
</callout>
<callout arearefs="CO66-8">
<para>Optional: Passes the <literal>X-Scope-OrgID</literal> header to multi-tenant <link xl:href="https://cortexmetrics.io/">Cortex</link> or <link xl:href="https://grafana.com/oss/mimir/">Mimir</link> storage for Prometheus. This parameter is required only with multi-tenant Prometheus storage, to indicate which data Prometheus should return.</para>
</callout>
<callout arearefs="CO66-9">
<para>Optional: Specifies how the trigger should proceed if the Prometheus target is lost.</para>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal>, the trigger continues to operate if the Prometheus target is lost. This is the default behavior.</simpara>
</listitem>
<listitem>
<simpara>If <literal>false</literal>, the trigger returns an error if the Prometheus target is lost.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO66-10">
<para>Optional: Specifies whether the certificate check should be skipped. For example, you might skip the check if you use self-signed certificates at the Prometheus endpoint.</para>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal>, the certificate check is performed.</simpara>
</listitem>
<listitem>
<simpara>If <literal>false</literal>, the certificate check is not performed. This is the default behavior.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<section xml:id="nodes-cma-autoscaling-custom-prometheus-config_nodes-cma-autoscaling-custom-trigger">
<title>Configuring the custom metrics autoscaler to use {product-title} monitoring</title>
<simpara>You can use the installed {product-title} Prometheus monitoring as a source for the metrics used by the custom metrics autoscaler. However, there are some additional configurations you must perform.</simpara>
<note>
<simpara>These steps are not required for an external Prometheus source.</simpara>
</note>
<simpara>You must perform the following tasks, as described in this section:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a service account to get a token.</simpara>
</listitem>
<listitem>
<simpara>Create a role.</simpara>
</listitem>
<listitem>
<simpara>Add that role to the service account.</simpara>
</listitem>
<listitem>
<simpara>Reference the token in the trigger authentication object used by Prometheus.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>{product-title} monitoring must be installed.</simpara>
</listitem>
<listitem>
<simpara>Monitoring of user-defined workloads must be enabled in {product-title} monitoring, as described in the <emphasis role="strong">Creating a user-defined workload monitoring config map</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the project with the object you want to scale:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project my-project</programlisting>
</listitem>
<listitem>
<simpara>Use the following command to create a service account, if your cluster does not have one:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create serviceaccount &lt;service_account&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;service_account&gt;</term>
<listitem>
<simpara>Specifies the name of the service account.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Use the following command to locate the token assigned to the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe serviceaccount &lt;service_account&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;service_account&gt;</term>
<listitem>
<simpara>Specifies the name of the service account.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                thanos
Namespace:           my-project
Labels:              &lt;none&gt;
Annotations:         &lt;none&gt;
Image pull secrets:  thanos-dockercfg-nnwgj
Mountable secrets:   thanos-dockercfg-nnwgj
Tokens:              thanos-token-9g4n5 <co xml:id="CO67-1"/>
Events:              &lt;none&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO67-1">
<para>Use this token in the trigger authentication.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a trigger authentication with the service account token:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: TriggerAuthentication
metadata:
  name: keda-trigger-auth-prometheus
spec:
  secretTargetRef: <co xml:id="CO68-1"/>
  - parameter: bearerToken <co xml:id="CO68-2"/>
    name: thanos-token-9g4n5 <co xml:id="CO68-3"/>
    key: token <co xml:id="CO68-4"/>
  - parameter: ca
    name: thanos-token-9g4n5
    key: ca.crt</programlisting>
<calloutlist>
<callout arearefs="CO68-1">
<para>Specifies that this object uses a secret for authorization.</para>
</callout>
<callout arearefs="CO68-2">
<para>Specifies the authentication parameter to supply by using the token.</para>
</callout>
<callout arearefs="CO68-3">
<para>Specifies the name of the token to use.</para>
</callout>
<callout arearefs="CO68-4">
<para>Specifies the key in the token to use with the specified parameter.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the CR object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a role for reading Thanos metrics:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following parameters:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: thanos-metrics-reader
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
- apiGroups:
  - metrics.k8s.io
  resources:
  - pods
  - nodes
  verbs:
  - get
  - list
  - watch</programlisting>
</listitem>
<listitem>
<simpara>Create the CR object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a role binding for reading Thanos metrics:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: thanos-metrics-reader <co xml:id="CO69-1"/>
  namespace: my-project <co xml:id="CO69-2"/>
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: thanos-metrics-reader
subjects:
- kind: ServiceAccount
  name: thanos <co xml:id="CO69-3"/>
  namespace: my-project <co xml:id="CO69-4"/></programlisting>
<calloutlist>
<callout arearefs="CO69-1">
<para>Specifies the name of the role you created.</para>
</callout>
<callout arearefs="CO69-2">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
<callout arearefs="CO69-3">
<para>Specifies the name of the service account to bind to the role.</para>
</callout>
<callout arearefs="CO69-4">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the CR object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now deploy a scaled object or scaled job to enable autoscaling for your application, as described in "Understanding how to add custom metrics autoscalers". To use {product-title} monitoring as the source, in the trigger, or scaler, you must include the following parameters:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>triggers.type</literal> must be <literal>prometheus</literal></simpara>
</listitem>
<listitem>
<simpara><literal>triggers.metadata.serverAddress</literal> must be <literal>https://thanos-querier.openshift-monitoring.svc.cluster.local:9092</literal></simpara>
</listitem>
<listitem>
<simpara><literal>triggers.metadata.authModes</literal> must be <literal>bearer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>triggers.metadata.namespace</literal> must be set to the namespace of the object to scale</simpara>
</listitem>
<listitem>
<simpara><literal>triggers.authenticationRef</literal> must point to the trigger authentication resource specified in the previous step</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-trigger-cpu_nodes-cma-autoscaling-custom-trigger">
<title>Understanding the CPU trigger</title>
<simpara>You can scale pods based on CPU metrics. This trigger uses cluster metrics as the source for metrics.</simpara>
<simpara>The custom metrics autoscaler scales the pods associated with an object to maintain the CPU usage that you specify. The autoscaler increases or decreases the number of replicas between the minimum and maximum numbers to maintain the specified CPU utilization across all pods. The memory trigger considers the memory utilization of the entire pod. If the pod has multiple containers, the memory trigger considers the total memory utilization of all containers in the pod.</simpara>
<note>
<itemizedlist>
<listitem>
<simpara>This trigger cannot be used with the <literal>ScaledJob</literal> custom resource.</simpara>
</listitem>
<listitem>
<simpara>When using a memory trigger to scale an object, the object does not scale to <literal>0</literal>, even if you are using multiple triggers.</simpara>
</listitem>
</itemizedlist>
</note>
<formalpara>
<title>Example scaled object with a CPU target</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: cpu-scaledobject
  namespace: my-namespace
spec:
# ...
  triggers:
  - type: cpu <co xml:id="CO70-1"/>
    metricType: Utilization <co xml:id="CO70-2"/>
    metadata:
      value: '60' <co xml:id="CO70-3"/>
  minReplicaCount: 1 <co xml:id="CO70-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO70-1">
<para>Specifies CPU as the trigger type.</para>
</callout>
<callout arearefs="CO70-2">
<para>Specifies the type of metric to use, either <literal>Utilization</literal> or <literal>AverageValue</literal>.</para>
</callout>
<callout arearefs="CO70-3">
<para>Specifies the value that triggers scaling. Must be specified as a quoted string value.</para>
<itemizedlist>
<listitem>
<simpara>When using <literal>Utilization</literal>, the target value is the average of the resource metrics across all relevant pods, represented as a percentage of the requested value of the resource for the pods.</simpara>
</listitem>
<listitem>
<simpara>When using <literal>AverageValue</literal>, the target value is the average of the metrics across all relevant pods.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO70-4">
<para>Specifies the minimum number of replicas when scaling down. For a CPU trigger, enter a value of <literal>1</literal> or greater, because the HPA cannot scale to zero if you are using only CPU metrics.</para>
</callout>
</calloutlist>
</section>
<section xml:id="nodes-cma-autoscaling-custom-trigger-memory_nodes-cma-autoscaling-custom-trigger">
<title>Understanding the memory trigger</title>
<simpara>You can scale pods based on memory metrics. This trigger uses cluster metrics as the source for metrics.</simpara>
<simpara>The custom metrics autoscaler scales the pods associated with an object to maintain the average memory usage that you specify. The autoscaler increases and decreases the number of replicas between the minimum and maximum numbers to maintain the specified memory utilization across all pods. The memory trigger considers the memory utilization of entire pod. If the pod has multiple containers, the memory utilization is the sum of all of the containers.</simpara>
<note>
<itemizedlist>
<listitem>
<simpara>This trigger cannot be used with the <literal>ScaledJob</literal> custom resource.</simpara>
</listitem>
<listitem>
<simpara>When using a memory trigger to scale an object, the object does not scale to <literal>0</literal>, even if you are using multiple triggers.</simpara>
</listitem>
</itemizedlist>
</note>
<formalpara>
<title>Example scaled object with a memory target</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: memory-scaledobject
  namespace: my-namespace
spec:
# ...
  triggers:
  - type: memory <co xml:id="CO71-1"/>
    metricType: Utilization <co xml:id="CO71-2"/>
    metadata:
      value: '60' <co xml:id="CO71-3"/>
      containerName: api <co xml:id="CO71-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO71-1">
<para>Specifies memory as the trigger type.</para>
</callout>
<callout arearefs="CO71-2">
<para>Specifies the type of metric to use, either <literal>Utilization</literal> or <literal>AverageValue</literal>.</para>
</callout>
<callout arearefs="CO71-3">
<para>Specifies the value that triggers scaling. Must be specified as a quoted string value.</para>
<itemizedlist>
<listitem>
<simpara>When using <literal>Utilization</literal>, the target value is the average of the resource metrics across all relevant pods, represented as a percentage of the requested value of the resource for the pods.</simpara>
</listitem>
<listitem>
<simpara>When using <literal>AverageValue</literal>, the target value is the average of the metrics across all relevant pods.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO71-4">
<para>Optional: Specifies an individual container to scale, based on the memory utilization of only that container, rather than the entire pod. In this example, only the container named <literal>api</literal> is to be scaled.</para>
</callout>
</calloutlist>
</section>
<section xml:id="nodes-cma-autoscaling-custom-trigger-kafka_nodes-cma-autoscaling-custom-trigger">
<title>Understanding the Kafka trigger</title>
<simpara>You can scale pods based on an Apache Kafka topic or other services that support the Kafka protocol. The custom metrics autoscaler does not scale higher than the number of Kafka partitions, unless you set the <literal>allowIdleConsumers</literal> parameter to <literal>true</literal> in the scaled object or scaled job.</simpara>
<note>
<simpara>If the number of consumer groups exceeds the number of partitions in a topic, the extra consumer groups remain idle. To avoid this, by default the number of replicas does not exceed:</simpara>
<itemizedlist>
<listitem>
<simpara>The number of partitions on a topic, if a topic is specified</simpara>
</listitem>
<listitem>
<simpara>The number of partitions of all topics in the consumer group, if no topic is specified</simpara>
</listitem>
<listitem>
<simpara>The <literal>maxReplicaCount</literal> specified in scaled object or scaled job CR</simpara>
</listitem>
</itemizedlist>
<simpara>You can use the <literal>allowIdleConsumers</literal> parameter to disable these default behaviors.</simpara>
</note>
<formalpara>
<title>Example scaled object with a Kafka target</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: kafka-scaledobject
  namespace: my-namespace
spec:
# ...
  triggers:
  - type: kafka <co xml:id="CO72-1"/>
    metadata:
      topic: my-topic <co xml:id="CO72-2"/>
      bootstrapServers: my-cluster-kafka-bootstrap.openshift-operators.svc:9092 <co xml:id="CO72-3"/>
      consumerGroup: my-group <co xml:id="CO72-4"/>
      lagThreshold: '10' <co xml:id="CO72-5"/>
      activationLagThreshold: '5' <co xml:id="CO72-6"/>
      offsetResetPolicy: latest <co xml:id="CO72-7"/>
      allowIdleConsumers: true <co xml:id="CO72-8"/>
      scaleToZeroOnInvalidOffset: false <co xml:id="CO72-9"/>
      excludePersistentLag: false <co xml:id="CO72-10"/>
      version: '1.0.0' <co xml:id="CO72-11"/>
      partitionLimitation: '1,2,10-20,31' <co xml:id="CO72-12"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO72-1">
<para>Specifies Kafka as the trigger type.</para>
</callout>
<callout arearefs="CO72-2">
<para>Specifies the name of the Kafka topic on which Kafka is processing the offset lag.</para>
</callout>
<callout arearefs="CO72-3">
<para>Specifies a comma-separated list of Kafka brokers to connect to.</para>
</callout>
<callout arearefs="CO72-4">
<para>Specifies the name of the Kafka consumer group used for checking the offset on the topic and processing the related lag.</para>
</callout>
<callout arearefs="CO72-5">
<para>Optional: Specifies the average target value that triggers scaling. Must be specified as a quoted string value. The default is <literal>5</literal>.</para>
</callout>
<callout arearefs="CO72-6">
<para>Optional: Specifies the target value for the activation phase. Must be specified as a quoted string value.</para>
</callout>
<callout arearefs="CO72-7">
<para>Optional: Specifies the Kafka offset reset policy for the Kafka consumer. The available values are: <literal>latest</literal> and <literal>earliest</literal>. The default is <literal>latest</literal>.</para>
</callout>
<callout arearefs="CO72-8">
<para>Optional: Specifies whether the number of Kafka replicas can exceed the number of partitions on a topic.</para>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal>, the number of Kafka replicas can exceed the number of partitions on a topic. This allows for idle Kafka consumers.</simpara>
</listitem>
<listitem>
<simpara>If <literal>false</literal>, the number of Kafka replicas cannot exceed the number of partitions on a topic. This is the default.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO72-9">
<para>Specifies how the trigger behaves when a Kafka partition does not have a valid offset.</para>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal>, the consumers are scaled to zero for that partition.</simpara>
</listitem>
<listitem>
<simpara>If <literal>false</literal>, the scaler keeps a single consumer for that partition. This is the default.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO72-10">
<para>Optional: Specifies whether the trigger includes or excludes partition lag for partitions whose current offset is the same as the current offset of the previous polling cycle.</para>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal>, the scaler excludes partition lag in these partitions.</simpara>
</listitem>
<listitem>
<simpara>If <literal>false</literal>, the trigger includes all consumer lag in all partitions. This is the default.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO72-11">
<para>Optional: Specifies the version of your Kafka brokers. Must be specified as a quoted string value. The default is <literal>1.0.0</literal>.</para>
</callout>
<callout arearefs="CO72-12">
<para>Optional: Specifies a comma-separated list of partition IDs to scope the scaling on. If set, only the listed IDs are considered when calculating lag. Must be specified as a quoted string value. The default is to consider all partitions.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-trigger-auth">
<title>Understanding custom metrics autoscaler trigger authentications</title>

<simpara>A trigger authentication allows you to include authentication information in a scaled object or a scaled job that can be used by the associated containers. You can use trigger authentications to pass {product-title} secrets, platform-native pod authentication mechanisms, environment variables, and so on.</simpara>
<simpara>You define a <literal>TriggerAuthentication</literal> object in the same namespace as the object that you want to scale. That trigger authentication can be used only by objects in that namespace.</simpara>
<simpara>Alternatively, to share credentials between objects in multiple namespaces, you can create a <literal>ClusterTriggerAuthentication</literal> object that can be used across all namespaces.</simpara>
<simpara>Trigger authentications and cluster trigger authentication use the same configuration. However, a cluster trigger authentication requires an additional <literal>kind</literal> parameter in the authentication reference of the scaled object.</simpara>
<formalpara>
<title>Example trigger authentication with a secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: TriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata:
  name: secret-triggerauthentication
  namespace: my-namespace <co xml:id="CO73-1"/>
spec:
  secretTargetRef: <co xml:id="CO73-2"/>
  - parameter: user-name <co xml:id="CO73-3"/>
    name: my-secret <co xml:id="CO73-4"/>
    key: USER_NAME <co xml:id="CO73-5"/>
  - parameter: password
    name: my-secret
    key: USER_PASSWORD</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO73-1">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
<callout arearefs="CO73-2">
<para>Specifies that this trigger authentication uses a secret for authorization.</para>
</callout>
<callout arearefs="CO73-3">
<para>Specifies the authentication parameter to supply by using the secret.</para>
</callout>
<callout arearefs="CO73-4">
<para>Specifies the name of the secret to use.</para>
</callout>
<callout arearefs="CO73-5">
<para>Specifies the key in the secret to use with the specified parameter.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example cluster trigger authentication with a secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterTriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata: <co xml:id="CO74-1"/>
  name: secret-cluster-triggerauthentication
spec:
  secretTargetRef: <co xml:id="CO74-2"/>
  - parameter: user-name <co xml:id="CO74-3"/>
    name: secret-name <co xml:id="CO74-4"/>
    key: USER_NAME <co xml:id="CO74-5"/>
  - parameter: user-password
    name: secret-name
    key: USER_PASSWORD</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO74-1">
<para>Note that no namespace is used with a cluster trigger authentication.</para>
</callout>
<callout arearefs="CO74-2">
<para>Specifies that this trigger authentication uses a secret for authorization.</para>
</callout>
<callout arearefs="CO74-3">
<para>Specifies the authentication parameter to supply by using the secret.</para>
</callout>
<callout arearefs="CO74-4">
<para>Specifies the name of the secret to use.</para>
</callout>
<callout arearefs="CO74-5">
<para>Specifies the key in the secret to use with the specified parameter.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example trigger authentication with a token</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: TriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata:
  name: token-triggerauthentication
  namespace: my-namespace <co xml:id="CO75-1"/>
spec:
  secretTargetRef: <co xml:id="CO75-2"/>
  - parameter: bearerToken <co xml:id="CO75-3"/>
    name: my-token-2vzfq <co xml:id="CO75-4"/>
    key: token <co xml:id="CO75-5"/>
  - parameter: ca
    name: my-token-2vzfq
    key: ca.crt</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO75-1">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
<callout arearefs="CO75-2">
<para>Specifies that this trigger authentication uses a secret for authorization.</para>
</callout>
<callout arearefs="CO75-3">
<para>Specifies the authentication parameter to supply by using the token.</para>
</callout>
<callout arearefs="CO75-4">
<para>Specifies the name of the token to use.</para>
</callout>
<callout arearefs="CO75-5">
<para>Specifies the key in the token to use with the specified parameter.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example trigger authentication with an environment variable</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: TriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata:
  name: env-var-triggerauthentication
  namespace: my-namespace <co xml:id="CO76-1"/>
spec:
  env: <co xml:id="CO76-2"/>
  - parameter: access_key <co xml:id="CO76-3"/>
    name: ACCESS_KEY <co xml:id="CO76-4"/>
    containerName: my-container <co xml:id="CO76-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO76-1">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
<callout arearefs="CO76-2">
<para>Specifies that this trigger authentication uses environment variables for authorization.</para>
</callout>
<callout arearefs="CO76-3">
<para>Specify the parameter to set with this variable.</para>
</callout>
<callout arearefs="CO76-4">
<para>Specify the name of the environment variable.</para>
</callout>
<callout arearefs="CO76-5">
<para>Optional: Specify a container that requires authentication. The container must be in the same resource as referenced by <literal>scaleTargetRef</literal> in the scaled object.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example trigger authentication with pod authentication providers</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: TriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata:
  name: pod-id-triggerauthentication
  namespace: my-namespace <co xml:id="CO77-1"/>
spec:
  podIdentity: <co xml:id="CO77-2"/>
    provider: aws-eks <co xml:id="CO77-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO77-1">
<para>Specifies the namespace of the object you want to scale.</para>
</callout>
<callout arearefs="CO77-2">
<para>Specifies that this trigger authentication uses a platform-native pod authentication method for authorization.</para>
</callout>
<callout arearefs="CO77-3">
<para>Specifies a pod identity. Supported values are <literal>none</literal>, <literal>azure</literal>, <literal>aws-eks</literal>, or <literal>aws-kiam</literal>. The default is <literal>none</literal>.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>For information about {product-title} secrets, see <link xl:href="../../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets">Providing sensitive data to pods</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-cma-autoscaling-custom-trigger-auth-using_nodes-cma-autoscaling-custom-trigger-auth">
<title>Using trigger authentications</title>
<simpara>You use trigger authentications and cluster trigger authentications by using a custom resource to create the authentication,  then add a reference to a scaled object or scaled job.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>If you are using a secret, the <literal>Secret</literal> object must exist, for example:</simpara>
<formalpara>
<title>Example secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: my-secret
data:
  user-name: &lt;base64_USER_NAME&gt;
  password: &lt;base64_USER_PASSWORD&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>TriggerAuthentication</literal> or  <literal>ClusterTriggerAuthentication</literal> object.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the object:</simpara>
<formalpara>
<title>Example trigger authentication with a secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: TriggerAuthentication
apiVersion: keda.sh/v1alpha1
metadata:
  name: prom-triggerauthentication
  namespace: my-namespace
spec:
  secretTargetRef:
  - parameter: user-name
    name: my-secret
    key: USER_NAME
  - parameter: password
    name: my-secret
    key: USER_PASSWORD</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>TriggerAuthentication</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create or edit a <literal>ScaledObject</literal> YAML file that uses the trigger authentication:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file that defines the object by running the following command:</simpara>
<formalpara>
<title>Example scaled object with a trigger authentication</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: scaledobject
  namespace: my-namespace
spec:
  scaleTargetRef:
    name: example-deployment
  maxReplicaCount: 100
  minReplicaCount: 0
  pollingInterval: 30
  triggers:
  - type: prometheus
    metadata:
      serverAddress: https://thanos-querier.openshift-monitoring.svc.cluster.local:9092
      namespace: kedatest # replace &lt;NAMESPACE&gt;
      metricName: http_requests_total
      threshold: '5'
      query: sum(rate(http_requests_total{job="test-app"}[1m]))
      authModes: "basic"
    authenticationRef:
      name: prom-triggerauthentication <co xml:id="CO78-1"/>
      kind: TriggerAuthentication <co xml:id="CO78-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO78-1">
<para>Specify the name of your trigger authentication object.</para>
</callout>
<callout arearefs="CO78-2">
<para>Specify <literal>TriggerAuthentication</literal>. <literal>TriggerAuthentication</literal> is the default.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example scaled object with a cluster trigger authentication</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  name: scaledobject
  namespace: my-namespace
spec:
  scaleTargetRef:
    name: example-deployment
  maxReplicaCount: 100
  minReplicaCount: 0
  pollingInterval: 30
  triggers:
  - type: prometheus
    metadata:
      serverAddress: https://thanos-querier.openshift-monitoring.svc.cluster.local:9092
      namespace: kedatest # replace &lt;NAMESPACE&gt;
      metricName: http_requests_total
      threshold: '5'
      query: sum(rate(http_requests_total{job="test-app"}[1m]))
      authModes: "basic"
    authenticationRef:
      name: prom-cluster-triggerauthentication <co xml:id="CO79-1"/>
      kind: ClusterTriggerAuthentication <co xml:id="CO79-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO79-1">
<para>Specify the name of your trigger authentication object.</para>
</callout>
<callout arearefs="CO79-2">
<para>Specify <literal>ClusterTriggerAuthentication</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the scaled object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;filename&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-pausing">
<title>Pausing the custom metrics autoscaler for a scaled object</title>

<simpara>You can pause and restart the autoscaling of a workload, as needed.</simpara>
<simpara>For example, you might want to pause autoscaling before performing cluster maintenance or to avoid resource starvation by removing non-mission-critical workloads.</simpara>
<section xml:id="nodes-cma-autoscaling-custom-pausing-workload_nodes-cma-autoscaling-custom-pausing">
<title>Pausing a custom metrics autoscaler</title>
<simpara>You can pause the autoscaling of a scaled object by adding the <literal>autoscaling.keda.sh/paused-replicas</literal> annotation to the custom metrics autoscaler for that scaled object. The custom metrics autoscaler scales the replicas for that workload to the specified value and pauses autoscaling until the annotation is removed.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  annotations:
    autoscaling.keda.sh/paused-replicas: "4"
# ...</programlisting>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the following command to edit the <literal>ScaledObject</literal> CR for your workload:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit ScaledObject scaledobject</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>autoscaling.keda.sh/paused-replicas</literal> annotation with any value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  annotations:
    autoscaling.keda.sh/paused-replicas: "4" <co xml:id="CO80-1"/>
  creationTimestamp: "2023-02-08T14:41:01Z"
  generation: 1
  name: scaledobject
  namespace: my-project
  resourceVersion: '65729'
  uid: f5aec682-acdf-4232-a783-58b5b82f5dd0</programlisting>
<calloutlist>
<callout arearefs="CO80-1">
<para>Specifies that the Custom Metrics Autoscaler Operator is to scale the replicas to the specified value and stop autoscaling.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cma-autoscaling-custom-pausing-restart_nodes-cma-autoscaling-custom-pausing">
<title>Restarting the custom metrics autoscaler for a scaled object</title>
<simpara>You can restart a paused custom metrics autoscaler by removing the <literal>autoscaling.keda.sh/paused-replicas</literal> annotation for that <literal>ScaledObject</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  annotations:
    autoscaling.keda.sh/paused-replicas: "4"
# ...</programlisting>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the following command to edit the <literal>ScaledObject</literal> CR for your workload:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit ScaledObject scaledobject</programlisting>
</listitem>
<listitem>
<simpara>Remove the <literal>autoscaling.keda.sh/paused-replicas</literal> annotation.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  annotations:
    autoscaling.keda.sh/paused-replicas: "4" <co xml:id="CO81-1"/>
  creationTimestamp: "2023-02-08T14:41:01Z"
  generation: 1
  name: scaledobject
  namespace: my-project
  resourceVersion: '65729'
  uid: f5aec682-acdf-4232-a783-58b5b82f5dd0</programlisting>
<calloutlist>
<callout arearefs="CO81-1">
<para>Remove this annotation to restart a paused custom metrics autoscaler.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-audit-log">
<title>Gathering audit logs</title>

<simpara>You can gather audit logs, which are a security-relevant chronological set of records documenting the sequence of activities that have affected the system by individual users, administrators, or other components of the system.</simpara>
<simpara>For example, audit logs can help you understand where an autoscaling request is coming from. This is key information when backends are getting overloaded by autoscaling requests made by user applications and you need to determine which is the troublesome application.</simpara>
<section xml:id="nodes-cma-autoscaling-custom-audit_nodes-cma-autoscaling-custom-audit-log">
<title>Configuring audit logging</title>
<simpara>You can configure auditing for the Custom Metrics Autoscaler Operator by editing the <literal>KedaController</literal> custom resource. The logs are sent to an audit log file on a volume that is secured by using a persistent volume claim in the <literal>KedaController</literal> CR.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>KedaController</literal> custom resource to add the <literal>auditConfig</literal> stanza:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: KedaController
apiVersion: keda.sh/v1alpha1
metadata:
  name: keda
  namespace: openshift-keda
spec:
# ...
  metricsServer:
# ...
    auditConfig:
      logFormat: "json" <co xml:id="CO82-1"/>
      logOutputVolumeClaim: "pvc-audit-log" <co xml:id="CO82-2"/>
      policy:
        rules: <co xml:id="CO82-3"/>
        - level: Metadata
        omitStages: "RequestReceived" <co xml:id="CO82-4"/>
        omitManagedFields: false <co xml:id="CO82-5"/>
      lifetime: <co xml:id="CO82-6"/>
        maxAge: "2"
        maxBackup: "1"
        maxSize: "50"</programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>Specifies the output format of the audit log, either <literal>legacy</literal> or <literal>json</literal>.</para>
</callout>
<callout arearefs="CO82-2">
<para>Specifies an existing persistent volume claim for storing the log data. All requests coming to the API server are logged to this persistent volume claim. If you leave this field empty, the log data is sent to stdout.</para>
</callout>
<callout arearefs="CO82-3">
<para>Specifies which events should be recorded and what data they should include:</para>
<itemizedlist>
<listitem>
<simpara><literal>None</literal>: Do not log events.</simpara>
</listitem>
<listitem>
<simpara><literal>Metadata</literal>: Log only the metadata for the request, such as user, timestamp, and so forth. Do not log the request text and the response text. This is the default.</simpara>
</listitem>
<listitem>
<simpara><literal>Request</literal>: Log only the metadata and the request text but not the response text. This option does not apply for non-resource requests.</simpara>
</listitem>
<listitem>
<simpara><literal>RequestResponse</literal>: Log event metadata, request text, and response text. This option does not apply for non-resource requests.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO82-4">
<para>Specifies stages for which no event is created.</para>
</callout>
<callout arearefs="CO82-5">
<para>Specifies whether to omit the managed fields of the request and response bodies from being written to the API audit log, either <literal>true</literal> to omit the fields or <literal>false</literal> to include the fields.</para>
</callout>
<callout arearefs="CO82-6">
<para>Specifies the size and lifespan of the audit logs.</para>
<itemizedlist>
<listitem>
<simpara><literal>maxAge</literal>: The maximum number of days to retain audit log files, based on the timestamp encoded in their filename.</simpara>
</listitem>
<listitem>
<simpara><literal>maxBackup</literal>: The maximum number of audit log files to retain. Set to <literal>0</literal> to retain all audit log files.</simpara>
</listitem>
<listitem>
<simpara><literal>maxSize</literal>: The maximum size in megabytes of an audit log file before it gets rotated.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the audit log file directly:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Obtain the name of the <literal>keda-metrics-apiserver-*</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get pod -n openshift-keda</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                  READY   STATUS    RESTARTS   AGE
custom-metrics-autoscaler-operator-5cb44cd75d-9v4lv   1/1     Running   0          8m20s
keda-metrics-apiserver-65c7cc44fd-rrl4r               1/1     Running   0          2m55s
keda-operator-776cbb6768-zpj5b                        1/1     Running   0          2m55s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the log data by using a command similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs keda-metrics-apiserver-&lt;hash&gt;|grep -i metadata <co xml:id="CO83-1"/></programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para>Optional: You can use the <literal>grep</literal> command to specify the log level to display: <literal>Metadata</literal>, <literal>Request</literal>, <literal>RequestResponse</literal>.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs keda-metrics-apiserver-65c7cc44fd-rrl4r|grep -i metadata</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"> ...
{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Metadata","auditID":"4c81d41b-3dab-4675-90ce-20b87ce24013","stage":"ResponseComplete","requestURI":"/healthz","verb":"get","user":{"username":"system:anonymous","groups":["system:unauthenticated"]},"sourceIPs":["10.131.0.1"],"userAgent":"kube-probe/1.28","responseStatus":{"metadata":{},"code":200},"requestReceivedTimestamp":"2023-02-16T13:00:03.554567Z","stageTimestamp":"2023-02-16T13:00:03.555032Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":""}}
 ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Alternatively, you can view a specific log:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Use a command similar to the following to log into the <literal>keda-metrics-apiserver-*</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh pod/keda-metrics-apiserver-&lt;hash&gt; -n openshift-keda</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh pod/keda-metrics-apiserver-65c7cc44fd-rrl4r -n openshift-keda</programlisting>
</listitem>
<listitem>
<simpara>Change to the <literal>/var/audit-policy/</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4$ cd /var/audit-policy/</programlisting>
</listitem>
<listitem>
<simpara>List the available logs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4$ ls</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">log-2023.02.17-14:50  policy.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the log, as needed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4$ cat &lt;log_name&gt;/&lt;pvc_name&gt;|grep -i &lt;log_level&gt; <co xml:id="CO84-1"/></programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para>Optional: You can use the <literal>grep</literal> command to specify the log level to display: <literal>Metadata</literal>, <literal>Request</literal>, <literal>RequestResponse</literal>.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4$ cat log-2023.02.17-14:50/pvc-audit-log|grep -i Request</programlisting>
<formalpara>
<title>Example output</title>
<para>
<screen> ...
{"kind":"Event","apiVersion":"audit.k8s.io/v1","level":"Request","auditID":"63e7f68c-04ec-4f4d-8749-bf1656572a41","stage":"ResponseComplete","requestURI":"/openapi/v2","verb":"get","user":{"username":"system:aggregator","groups":["system:authenticated"]},"sourceIPs":["10.128.0.1"],"responseStatus":{"metadata":{},"code":304},"requestReceivedTimestamp":"2023-02-17T13:12:55.035478Z","stageTimestamp":"2023-02-17T13:12:55.038346Z","annotations":{"authorization.k8s.io/decision":"allow","authorization.k8s.io/reason":"RBAC: allowed by ClusterRoleBinding \"system:discovery\" of ClusterRole \"system:discovery\" to Group \"system:authenticated\""}}
 ...</screen>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-debugging">
<title>Gathering debugging data</title>

<simpara>When opening a support case, it is helpful to provide debugging information about your cluster to Red Hat Support.</simpara>
<simpara>To help troubleshoot your issue, provide the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>Data gathered using the <literal>must-gather</literal> tool.</simpara>
</listitem>
<listitem>
<simpara>The unique cluster ID.</simpara>
</listitem>
</itemizedlist>
<simpara>You can use the <literal>must-gather</literal> tool to collect data about the Custom Metrics Autoscaler Operator and its components, including the following items:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>openshift-keda</literal> namespace and its child objects.</simpara>
</listitem>
<listitem>
<simpara>The Custom Metric Autoscaler Operator installation objects.</simpara>
</listitem>
<listitem>
<simpara>The Custom Metric Autoscaler Operator CRD objects.</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-cma-autoscaling-custom-debugging-gather_nodes-cma-autoscaling-custom-debugging">
<title>Gathering debugging data</title>
<simpara>The following command runs the <literal>must-gather</literal> tool for the Custom Metrics Autoscaler Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image="$(oc get packagemanifests openshift-custom-metrics-autoscaler-operator \
-n openshift-marketplace \
-o jsonpath='{.status.channels[?(@.name=="stable")].currentCSVDesc.annotations.containerImage}')"</programlisting>
<note>
<simpara>The standard {product-title} <literal>must-gather</literal> command, <literal>oc adm must-gather</literal>, does not collect Custom Metrics Autoscaler Operator data.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>The {product-title} CLI (<literal>oc</literal>) installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the directory where you want to store the <literal>must-gather</literal> data.</simpara>
<note>
<simpara>If your cluster is using a restricted network, you must take additional steps. If your mirror registry has a trusted CA, you must first add the trusted CA to the cluster. For all clusters on restricted networks, you must import the default <literal>must-gather</literal> image as an image stream by running the following command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image is/must-gather -n openshift</programlisting>
</note>
</listitem>
<listitem>
<simpara>Perform one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>To get only the Custom Metrics Autoscaler Operator <literal>must-gather</literal> data, use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image="$(oc get packagemanifests openshift-custom-metrics-autoscaler-operator \
-n openshift-marketplace \
-o jsonpath='{.status.channels[?(@.name=="stable")].currentCSVDesc.annotations.containerImage}')"</programlisting>
<simpara>The custom image for the <literal>must-gather</literal> command is pulled directly from the Operator package manifests, so that it works on any cluster where the Custom Metric Autoscaler Operator is available.</simpara>
</listitem>
<listitem>
<simpara>To gather the default <literal>must-gather</literal> data in addition to the Custom Metric Autoscaler Operator information:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Use the following command to obtain the Custom Metrics Autoscaler Operator image and set it as an environment variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ IMAGE="$(oc get packagemanifests openshift-custom-metrics-autoscaler-operator \
  -n openshift-marketplace \
  -o jsonpath='{.status.channels[?(@.name=="stable")].currentCSVDesc.annotations.containerImage}')"</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>oc adm must-gather</literal> with the Custom Metrics Autoscaler Operator image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image-stream=openshift/must-gather --image=${IMAGE}</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<example>
<title>Example must-gather output for the Custom Metric Autoscaler:</title>
<programlisting language="terminal" linenumbering="unnumbered">└── openshift-keda
    ├── apps
    │   ├── daemonsets.yaml
    │   ├── deployments.yaml
    │   ├── replicasets.yaml
    │   └── statefulsets.yaml
    ├── apps.openshift.io
    │   └── deploymentconfigs.yaml
    ├── autoscaling
    │   └── horizontalpodautoscalers.yaml
    ├── batch
    │   ├── cronjobs.yaml
    │   └── jobs.yaml
    ├── build.openshift.io
    │   ├── buildconfigs.yaml
    │   └── builds.yaml
    ├── core
    │   ├── configmaps.yaml
    │   ├── endpoints.yaml
    │   ├── events.yaml
    │   ├── persistentvolumeclaims.yaml
    │   ├── pods.yaml
    │   ├── replicationcontrollers.yaml
    │   ├── secrets.yaml
    │   └── services.yaml
    ├── discovery.k8s.io
    │   └── endpointslices.yaml
    ├── image.openshift.io
    │   └── imagestreams.yaml
    ├── k8s.ovn.org
    │   ├── egressfirewalls.yaml
    │   └── egressqoses.yaml
    ├── keda.sh
    │   ├── kedacontrollers
    │   │   └── keda.yaml
    │   ├── scaledobjects
    │   │   └── example-scaledobject.yaml
    │   └── triggerauthentications
    │       └── example-triggerauthentication.yaml
    ├── monitoring.coreos.com
    │   └── servicemonitors.yaml
    ├── networking.k8s.io
    │   └── networkpolicies.yaml
    ├── openshift-keda.yaml
    ├── pods
    │   ├── custom-metrics-autoscaler-operator-58bd9f458-ptgwx
    │   │   ├── custom-metrics-autoscaler-operator
    │   │   │   └── custom-metrics-autoscaler-operator
    │   │   │       └── logs
    │   │   │           ├── current.log
    │   │   │           ├── previous.insecure.log
    │   │   │           └── previous.log
    │   │   └── custom-metrics-autoscaler-operator-58bd9f458-ptgwx.yaml
    │   ├── custom-metrics-autoscaler-operator-58bd9f458-thbsh
    │   │   └── custom-metrics-autoscaler-operator
    │   │       └── custom-metrics-autoscaler-operator
    │   │           └── logs
    │   ├── keda-metrics-apiserver-65c7cc44fd-6wq4g
    │   │   ├── keda-metrics-apiserver
    │   │   │   └── keda-metrics-apiserver
    │   │   │       └── logs
    │   │   │           ├── current.log
    │   │   │           ├── previous.insecure.log
    │   │   │           └── previous.log
    │   │   └── keda-metrics-apiserver-65c7cc44fd-6wq4g.yaml
    │   └── keda-operator-776cbb6768-fb6m5
    │       ├── keda-operator
    │       │   └── keda-operator
    │       │       └── logs
    │       │           ├── current.log
    │       │           ├── previous.insecure.log
    │       │           └── previous.log
    │       └── keda-operator-776cbb6768-fb6m5.yaml
    ├── policy
    │   └── poddisruptionbudgets.yaml
    └── route.openshift.io
        └── routes.yaml</programlisting>
</example>
</listitem>
<listitem>
<simpara>Create a compressed file from the <literal>must-gather</literal> directory that was created in your working directory. For example, on a computer that uses a Linux
operating system, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar cvaf must-gather.tar.gz must-gather.local.5421342344627712289/ <co xml:id="CO85-1"/></programlisting>
<calloutlist>
<callout arearefs="CO85-1">
<para>Replace <literal>must-gather-local.5421342344627712289/</literal> with the actual directory name.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Attach the compressed file to your support case on the <link xl:href="https://access.redhat.com">Red Hat Customer Portal</link>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-metrics">
<title>Viewing Operator metrics</title>

<simpara>The Custom Metrics Autoscaler Operator exposes ready-to-use metrics that it pulls from the on-cluster monitoring component. You can query the metrics by using the Prometheus Query Language (PromQL) to analyze and diagnose issues. All metrics are reset when the controller pod restarts.</simpara>
<section xml:id="nodes-cma-autoscaling-custom-metrics-access_nodes-cma-autoscaling-custom-metrics">
<title>Accessing performance metrics</title>
<simpara>You can access the metrics and run queries by using the {product-title} web console.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Select the <emphasis role="strong">Administrator</emphasis> perspective in the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Observe</emphasis> &#8594; <emphasis role="strong">Metrics</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To create a custom query, add your PromQL query to the <emphasis role="strong">Expression</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>To add multiple queries, select <emphasis role="strong">Add Query</emphasis>.</simpara>
</listitem>
</orderedlist>
<section xml:id="nodes-cma-autoscaling-custom-metrics-provided_nodes-cma-autoscaling-custom-metrics">
<title>Provided Operator metrics</title>
<simpara>The Custom Metrics Autoscaler Operator exposes the following metrics, which you can view by using the {product-title} web console.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Custom Metric Autoscaler Operator metrics</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Metric name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaler_activity</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Whether the particular scaler is active or inactive. A value of <literal>1</literal> indicates the scaler is active; a value of <literal>0</literal> indicates the scaler is inactive.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaler_metrics_value</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The current value for each scaler’s metric, which is used by the Horizontal Pod Autoscaler (HPA) in computing the target average.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaler_metrics_latency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The latency of retrieving the current metric from each scaler.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaler_errors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of errors that have occurred for each scaler.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaler_errors_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number of errors encountered for all scalers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaled_object_errors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of errors that have occurred for each scaled obejct.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_resource_totals</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number of Custom Metrics Autoscaler custom resources in each namespace for each custom resource type.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_trigger_totals</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The total number of triggers by trigger type.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Custom Metrics Autoscaler Admission webhook metrics</title>
<para>The Custom Metrics Autoscaler Admission webhook also exposes the following Prometheus metrics.</para>
</formalpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Metric name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaled_object_validation_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of scaled object validations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keda_scaled_object_validation_errors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The number of validation errors.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-adding">
<title>Understanding how to add custom metrics autoscalers</title>

<simpara>To add a custom metrics autoscaler, create a <literal>ScaledObject</literal> custom resource for a deployment, stateful set, or custom resource. Create a <literal>ScaledJob</literal> custom resource for a job.</simpara>
<simpara>You can create only one scaled object for each workload that you want to scale. Also, you cannot use a scaled object and the horizontal pod autoscaler (HPA) on the same workload.</simpara>
<section xml:id="nodes-cma-autoscaling-custom-creating-workload_nodes-cma-autoscaling-custom-adding">
<title>Adding a custom metrics autoscaler to a workload</title>
<simpara>You can create a custom metrics autoscaler for a workload that is created by a <literal>Deployment</literal>, <literal>StatefulSet</literal>, or <literal>custom resource</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
<listitem>
<simpara>If you use a custom metrics autoscaler for scaling based on CPU or memory:</simpara>
<itemizedlist>
<listitem>
<simpara>Your cluster administrator must have properly configured cluster metrics. You can use the <literal>oc describe PodMetrics &lt;pod-name&gt;</literal> command to determine if metrics are configured. If metrics are configured, the output appears similar to the following, with CPU and Memory displayed under Usage.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe PodMetrics openshift-kube-scheduler-ip-10-0-135-131.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">Name:         openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Namespace:    openshift-kube-scheduler
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  metrics.k8s.io/v1beta1
Containers:
  Name:  wait-for-host-port
  Usage:
    Memory:  0
  Name:      scheduler
  Usage:
    Cpu:     8m
    Memory:  45440Ki
Kind:        PodMetrics
Metadata:
  Creation Timestamp:  2019-05-23T18:47:56Z
  Self Link:           /apis/metrics.k8s.io/v1beta1/namespaces/openshift-kube-scheduler/pods/openshift-kube-scheduler-ip-10-0-135-131.ec2.internal
Timestamp:             2019-05-23T18:47:56Z
Window:                1m0s
Events:                &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The pods associated with the object you want to scale must include specified memory and CPU limits. For example:</simpara>
<formalpara>
<title>Example pod spec</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
# ...
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    resources:
      limits:
        memory: "128Mi"
        cpu: "500m"
# ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file similar to the following. Only the name <literal>&lt;2&gt;</literal>, object name <literal>&lt;4&gt;</literal>, and object kind <literal>&lt;5&gt;</literal> are required:</simpara>
<formalpara>
<title>Example scaled object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: keda.sh/v1alpha1
kind: ScaledObject
metadata:
  annotations:
    autoscaling.keda.sh/paused-replicas: "0" <co xml:id="CO86-1"/>
  name: scaledobject <co xml:id="CO86-2"/>
  namespace: my-namespace
spec:
  scaleTargetRef:
    apiVersion: apps/v1 <co xml:id="CO86-3"/>
    name: example-deployment <co xml:id="CO86-4"/>
    kind: Deployment <co xml:id="CO86-5"/>
    envSourceContainerName: .spec.template.spec.containers[0] <co xml:id="CO86-6"/>
  cooldownPeriod:  200 <co xml:id="CO86-7"/>
  maxReplicaCount: 100 <co xml:id="CO86-8"/>
  minReplicaCount: 0 <co xml:id="CO86-9"/>
  metricsServer: <co xml:id="CO86-10"/>
    auditConfig:
      logFormat: "json"
      logOutputVolumeClaim: "persistentVolumeClaimName"
      policy:
        rules:
        - level: Metadata
        omitStages: "RequestReceived"
        omitManagedFields: false
      lifetime:
        maxAge: "2"
        maxBackup: "1"
        maxSize: "50"
  fallback: <co xml:id="CO86-11"/>
    failureThreshold: 3
    replicas: 6
  pollingInterval: 30 <co xml:id="CO86-12"/>
  advanced:
    restoreToOriginalReplicaCount: false <co xml:id="CO86-13"/>
    horizontalPodAutoscalerConfig:
      name: keda-hpa-scale-down <co xml:id="CO86-14"/>
      behavior: <co xml:id="CO86-15"/>
        scaleDown:
          stabilizationWindowSeconds: 300
          policies:
          - type: Percent
            value: 100
            periodSeconds: 15
  triggers:
  - type: prometheus <co xml:id="CO86-16"/>
    metadata:
      serverAddress: https://thanos-querier.openshift-monitoring.svc.cluster.local:9092
      namespace: kedatest
      metricName: http_requests_total
      threshold: '5'
      query: sum(rate(http_requests_total{job="test-app"}[1m]))
      authModes: basic
    authenticationRef: <co xml:id="CO86-17"/>
      name: prom-triggerauthentication
      kind: TriggerAuthentication</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO86-1">
<para>Optional: Specifies that the Custom Metrics Autoscaler Operator is to scale the replicas to the specified value and stop autoscaling, as described in the "Pausing the custom metrics autoscaler for a workload" section.</para>
</callout>
<callout arearefs="CO86-2">
<para>Specifies a name for this custom metrics autoscaler.</para>
</callout>
<callout arearefs="CO86-3">
<para>Optional: Specifies the API version of the target resource. The default is <literal>apps/v1</literal>.</para>
</callout>
<callout arearefs="CO86-4">
<para>Specifies the name of the object that you want to scale.</para>
</callout>
<callout arearefs="CO86-5">
<para>Specifies the <literal>kind</literal> as <literal>Deployment</literal>, <literal>StatefulSet</literal> or <literal>CustomResource</literal>.</para>
</callout>
<callout arearefs="CO86-6">
<para>Optional: Specifies the name of the container in the target resource, from which the custom metrics autoscaler gets environment variables holding secrets and so forth. The default is <literal>.spec.template.spec.containers[0]</literal>.</para>
</callout>
<callout arearefs="CO86-7">
<para>Optional. Specifies the period in seconds to wait after the last trigger is reported before scaling the deployment back to <literal>0</literal> if the <literal>minReplicaCount</literal> is set to <literal>0</literal>. The default is <literal>300</literal>.</para>
</callout>
<callout arearefs="CO86-8">
<para>Optional: Specifies the maximum number of replicas when scaling up. The default is <literal>100</literal>.</para>
</callout>
<callout arearefs="CO86-9">
<para>Optional: Specifies the minimum number of replicas when scaling down.</para>
</callout>
<callout arearefs="CO86-10">
<para>Optional: Specifies the parameters for audit logs. as described in the "Configuring audit logging" section.</para>
</callout>
<callout arearefs="CO86-11">
<para>Optional: Specifies the number of replicas to fall back to if a scaler fails to get metrics from the source for the number of times defined by the <literal>failureThreshold</literal> parameter. For more information on fallback behavior, see the <link xl:href="https://keda.sh/docs/2.7/concepts/scaling-deployments/#fallback">KEDA documentation</link>.</para>
</callout>
<callout arearefs="CO86-12">
<para>Optional: Specifies the interval in seconds to check each trigger on. The default is <literal>30</literal>.</para>
</callout>
<callout arearefs="CO86-13">
<para>Optional: Specifies whether to scale back the target resource to the original replica count after the scaled object is deleted. The default is <literal>false</literal>, which keeps the replica count as it is when the scaled object is deleted.</para>
</callout>
<callout arearefs="CO86-14">
<para>Optional: Specifies a name for the horizontal pod autoscaler. The default is <literal>keda-hpa-{scaled-object-name}</literal>.</para>
</callout>
<callout arearefs="CO86-15">
<para>Optional: Specifies a scaling policy to use to control the rate to scale pods up or down, as described in the "Scaling policies" section.</para>
</callout>
<callout arearefs="CO86-16">
<para>Specifies the trigger to use as the basis for scaling, as described in the "Understanding the custom metrics autoscaler triggers" section. This example uses {product-title} monitoring.</para>
</callout>
<callout arearefs="CO86-17">
<para>Optional: Specifies a trigger authentication or a cluster trigger authentication. For more information, see <emphasis>Understanding the custom metrics autoscaler trigger authentication</emphasis> in the <emphasis>Additional resources</emphasis> section.</para>
<itemizedlist>
<listitem>
<simpara>Enter <literal>TriggerAuthentication</literal> to use a trigger authentication. This is the default.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>ClusterTriggerAuthentication</literal> to use a cluster trigger authentication.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the custom metrics autoscaler by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the command output to verify that the custom metrics autoscaler was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scaledobject &lt;scaled_object_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            SCALETARGETKIND      SCALETARGETNAME        MIN   MAX   TRIGGERS     AUTHENTICATION               READY   ACTIVE   FALLBACK   AGE
scaledobject    apps/v1.Deployment   example-deployment     0     50    prometheus   prom-triggerauthentication   True    True     True       17s</programlisting>
</para>
</formalpara>
<simpara>Note the following fields in the output:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>TRIGGERS</literal>: Indicates the trigger, or scaler, that is being used.</simpara>
</listitem>
<listitem>
<simpara><literal>AUTHENTICATION</literal>: Indicates the name of any trigger authentication being used.</simpara>
</listitem>
<listitem>
<simpara><literal>READY</literal>: Indicates whether the scaled object is ready to start scaling:</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>True</literal>, the scaled object is ready.</simpara>
</listitem>
<listitem>
<simpara>If <literal>False</literal>, the scaled object is not ready because of a problem in one or more of the objects you created.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ACTIVE</literal>: Indicates whether scaling is taking place:</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>True</literal>, scaling is taking place.</simpara>
</listitem>
<listitem>
<simpara>If <literal>False</literal>, scaling is not taking place because there are no metrics or there is a problem in one or more of the objects you created.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>FALLBACK</literal>: Indicates whether the custom metrics autoscaler is able to get metrics from the source</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>False</literal>, the custom metrics autoscaler is getting metrics.</simpara>
</listitem>
<listitem>
<simpara>If <literal>True</literal>, the custom metrics autoscaler is getting metrics because there are no metrics or there is a problem in one or more of the objects you created.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cma-autoscaling-custom-creating-job_nodes-cma-autoscaling-custom-adding">
<title>Adding a custom metrics autoscaler to a job</title>
<simpara>You can create a custom metrics autoscaler for any <literal>Job</literal> object.</simpara>
<important>
<simpara>Scaling by using a scaled job is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ScaledJob
apiVersion: keda.sh/v1alpha1
metadata:
  name: scaledjob
  namespace: my-namespace
spec:
  failedJobsHistoryLimit: 5
  jobTargetRef:
    activeDeadlineSeconds: 600 <co xml:id="CO87-1"/>
    backoffLimit: 6 <co xml:id="CO87-2"/>
    parallelism: 1 <co xml:id="CO87-3"/>
    completions: 1 <co xml:id="CO87-4"/>
    template:  <co xml:id="CO87-5"/>
      metadata:
        name: pi
      spec:
        containers:
        - name: pi
          image: perl
          command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
  maxReplicaCount: 100 <co xml:id="CO87-6"/>
  pollingInterval: 30 <co xml:id="CO87-7"/>
  successfulJobsHistoryLimit: 5 <co xml:id="CO87-8"/>
  failedJobsHistoryLimit: 5 <co xml:id="CO87-9"/>
  envSourceContainerName: <co xml:id="CO87-10"/>
  rolloutStrategy: gradual <co xml:id="CO87-11"/>
  scalingStrategy: <co xml:id="CO87-12"/>
    strategy: "custom"
    customScalingQueueLengthDeduction: 1
    customScalingRunningJobPercentage: "0.5"
    pendingPodConditions:
      - "Ready"
      - "PodScheduled"
      - "AnyOtherCustomPodCondition"
    multipleScalersCalculation : "max"
  triggers:
  - type: prometheus <co xml:id="CO87-13"/>
    metadata:
      serverAddress: https://thanos-querier.openshift-monitoring.svc.cluster.local:9092
      namespace: kedatest
      metricName: http_requests_total
      threshold: '5'
      query: sum(rate(http_requests_total{job="test-app"}[1m]))
      authModes: "bearer"
    authenticationRef: <co xml:id="CO87-14"/>
      name: prom-cluster-triggerauthentication</programlisting>
<calloutlist>
<callout arearefs="CO87-1">
<para>Specifies the maximum duration the job can run.</para>
</callout>
<callout arearefs="CO87-2">
<para>Specifies the number of retries for a job. The default is <literal>6</literal>.</para>
</callout>
<callout arearefs="CO87-3">
<para>Optional: Specifies how many pod replicas a job should run in parallel; defaults to <literal>1</literal>.</para>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset, the default is <literal>1</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO87-4">
<para>Optional: Specifies how many successful pod completions are needed to mark a job completed.</para>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset,  the default is <literal>1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a fixed completion count, specify the number of completions.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a work queue, leave unset. When unset the default is the value of the <literal>parallelism</literal> parameter.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO87-5">
<para>Specifies the template for the pod the controller creates.</para>
</callout>
<callout arearefs="CO87-6">
<para>Optional: Specifies the maximum number of replicas when scaling up. The default is <literal>100</literal>.</para>
</callout>
<callout arearefs="CO87-7">
<para>Optional: Specifies the interval in seconds to check each trigger on. The default is <literal>30</literal>.</para>
</callout>
<callout arearefs="CO87-8">
<para>Optional: Specifies the number of successful finished jobs should be kept. The default is <literal>100</literal>.</para>
</callout>
<callout arearefs="CO87-9">
<para>Optional: Specifies how many failed jobs should be kept. The default is <literal>100</literal>.</para>
</callout>
<callout arearefs="CO87-10">
<para>Optional: Specifies the name of the container in the target resource, from which the custom autoscaler gets environment variables holding secrets and so forth. The default is <literal>.spec.template.spec.containers[0]</literal>.</para>
</callout>
<callout arearefs="CO87-11">
<para>Optional: Specifies whether existing jobs are terminated whenever a scaled job is being updated:</para>
<itemizedlist>
<listitem>
<simpara><literal>default</literal>: The autoscaler terminates an existing job if its associated scaled job is updated. The autoscaler recreates the job with the latest specs.</simpara>
</listitem>
<listitem>
<simpara><literal>gradual</literal>: The autoscaler does not terminate an existing job if its associated scaled job is updated. The autoscaler creates new jobs with the latest specs.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO87-12">
<para>Optional: Specifies a scaling strategy: <literal>default</literal>, <literal>custom</literal>, or <literal>accurate</literal>. The default is <literal>default</literal>. For more information, see the link in the "Additional resources" section that follows.</para>
</callout>
<callout arearefs="CO87-13">
<para>Specifies the trigger to use as the basis for scaling, as described in the "Understanding the custom metrics autoscaler triggers" section.</para>
</callout>
<callout arearefs="CO87-14">
<para>Optional: Specifies a trigger authentication or a cluster trigger authentication. For more information, see <emphasis>Understanding the custom metrics autoscaler trigger authentication</emphasis> in the <emphasis>Additional resources</emphasis> section.</para>
<itemizedlist>
<listitem>
<simpara>Enter <literal>TriggerAuthentication</literal> to use a trigger authentication. This is the default.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>ClusterTriggerAuthentication</literal> to use a cluster trigger authentication.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the custom metrics autoscaler by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>View the command output to verify that the custom metrics autoscaler was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scaledjob &lt;scaled_job_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        MAX   TRIGGERS     AUTHENTICATION              READY   ACTIVE    AGE
scaledjob   100   prometheus   prom-triggerauthentication  True    True      8s</programlisting>
</para>
</formalpara>
<simpara>Note the following fields in the output:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>TRIGGERS</literal>: Indicates the trigger, or scaler, that is being used.</simpara>
</listitem>
<listitem>
<simpara><literal>AUTHENTICATION</literal>: Indicates the name of any trigger authentication being used.</simpara>
</listitem>
<listitem>
<simpara><literal>READY</literal>: Indicates whether the scaled object is ready to start scaling:</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>True</literal>, the scaled object is ready.</simpara>
</listitem>
<listitem>
<simpara>If <literal>False</literal>, the scaled object is not ready because of a problem in one or more of the objects you created.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ACTIVE</literal>: Indicates whether scaling is taking place:</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>True</literal>, scaling is taking place.</simpara>
</listitem>
<listitem>
<simpara>If <literal>False</literal>, scaling is not taking place because there are no metrics or there is a problem in one or more of the objects you created.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cma-autoscaling-custom-adding-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../nodes/cma/nodes-cma-autoscaling-custom-trigger-auth.xml#nodes-cma-autoscaling-custom-trigger-auth">Understanding custom metrics autoscaler trigger authentications</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cma-autoscaling-custom-removing">
<title>Removing the Custom Metrics Autoscaler Operator</title>

<simpara>You can remove the custom metrics autoscaler from your {product-title} cluster. After removing the Custom Metrics Autoscaler Operator, remove other components associated with the Operator to avoid potential issues.</simpara>
<note>
<simpara>Delete the <literal>KedaController</literal> custom resource (CR) first. If you do not delete the <literal>KedaController</literal> CR, {product-title} can hang when you delete the <literal>openshift-keda</literal> project. If you delete the Custom Metrics Autoscaler Operator before deleting the CR, you are not able to delete the CR.</simpara>
</note>
<section xml:id="nodes-cma-autoscaling-custom-uninstalling_nodes-cma-autoscaling-custom-removing">
<title>Uninstalling the Custom Metrics Autoscaler Operator</title>
<simpara>Use the following procedure to remove the custom metrics autoscaler from your {product-title} cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Custom Metrics Autoscaler Operator must be installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the {product-title} web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Switch to the <emphasis role="strong">openshift-keda</emphasis> project.</simpara>
</listitem>
<listitem>
<simpara>Remove the <literal>KedaController</literal> custom resource.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the <emphasis role="strong">CustomMetricsAutoscaler</emphasis>  Operator and click the <emphasis role="strong">KedaController</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Find the custom resource, and then click <emphasis role="strong">Delete KedaController</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the Custom Metrics Autoscaler Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Find the <emphasis role="strong">CustomMetricsAutoscaler</emphasis>  Operator and click the <emphasis role="strong">Options</emphasis> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> and select <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Use the OpenShift CLI to remove the custom metrics autoscaler components:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the custom metrics autoscaler CRDs:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>clustertriggerauthentications.keda.sh</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kedacontrollers.keda.sh</literal></simpara>
</listitem>
<listitem>
<simpara><literal>scaledjobs.keda.sh</literal></simpara>
</listitem>
<listitem>
<simpara><literal>scaledobjects.keda.sh</literal></simpara>
</listitem>
<listitem>
<simpara><literal>triggerauthentications.keda.sh</literal></simpara>
</listitem>
</itemizedlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd clustertriggerauthentications.keda.sh kedacontrollers.keda.sh scaledjobs.keda.sh scaledobjects.keda.sh triggerauthentications.keda.sh</programlisting>
<simpara>Deleting the CRDs removes the associated roles, cluster roles, and role bindings. However, there might be a few cluster roles that must be manually deleted.</simpara>
</listitem>
<listitem>
<simpara>List any custom metrics autoscaler cluster roles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterrole | grep keda.sh</programlisting>
</listitem>
<listitem>
<simpara>Delete the listed custom metrics autoscaler cluster roles. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrole.keda.sh-v1alpha1-admin</programlisting>
</listitem>
<listitem>
<simpara>List any custom metrics autoscaler cluster role bindings:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterrolebinding | grep keda.sh</programlisting>
</listitem>
<listitem>
<simpara>Delete the listed custom metrics autoscaler cluster role bindings. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterrolebinding.keda.sh-v1alpha1-admin</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the custom metrics autoscaler project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project openshift-keda</programlisting>
</listitem>
<listitem>
<simpara>Delete the Cluster Metric Autoscaler Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete operator/openshift-custom-metrics-autoscaler-operator.openshift-keda</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="_controlling_pod_placement_onto_nodes_scheduling">
<title>Controlling pod placement onto nodes (scheduling)</title>
<section xml:id="nodes-scheduler-about">
<title>Controlling pod placement using the scheduler</title>

<simpara>Pod scheduling is an internal process that determines placement of new
pods onto nodes within the cluster.</simpara>
<simpara>The scheduler code has a clean separation that watches new pods
as they get created and identifies the most suitable node to host them. It then
creates bindings (pod to node bindings) for the pods using the master API.</simpara>
<variablelist>
<varlistentry>
<term>Default pod scheduling</term>
<listitem>
<simpara>{product-title} comes with a default scheduler that serves the needs of most users. The default scheduler uses both inherent and customization tools to determine the best fit for a pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Advanced pod scheduling</term>
<listitem>
<simpara>In situations where you might want more control over where new pods are placed, the {product-title} advanced scheduling features allow you to configure a pod so that the pod is required or has a preference to run on a particular node or alongside a specific pod.</simpara>
<simpara>You can control pod placement by using the following scheduling features:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-profiles.xml#nodes-scheduler-profiles">Scheduler profiles</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity">Pod affinity and anti-affinity rules</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity-about_nodes-scheduler-node-affinity">Node affinity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-selectors.xml#nodes-scheduler-node-selectors">Node selectors</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations">Taints and tolerations</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-overcommit.xml#nodes-scheduler-overcommit">Node overcommitment</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="about-default-scheduler">
<title>About the default scheduler</title>
<simpara>The default {product-title} pod scheduler is responsible for determining the placement of new pods onto nodes within the cluster. It reads data from the pod and finds a node that is a good fit based on configured profiles. It is completely independent and exists as a standalone solution. It does not modify the pod; it creates a binding for the pod that ties the pod to the particular node.</simpara>
<section xml:id="nodes-scheduler-default-about_nodes-scheduler-about">
<title>Understanding default scheduling</title>
<simpara>The existing generic scheduler is the default platform-provided scheduler
<emphasis>engine</emphasis> that selects a node to host the pod in a three-step operation:</simpara>
<variablelist>
<varlistentry>
<term>Filters the nodes</term>
<listitem>
<simpara>The available nodes are filtered based on the constraints or requirements
specified. This is done by running each node through the list of filter
functions called <emphasis>predicates</emphasis>, or <emphasis>filters</emphasis>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Prioritizes the filtered list of nodes</term>
<listitem>
<simpara>This is achieved by passing each node through a series of <emphasis>priority</emphasis>, or <emphasis>scoring</emphasis>, functions
that assign it a score between 0 - 10, with 0 indicating a bad fit and 10
indicating a good fit to host the pod. The scheduler configuration can also take
in a simple <emphasis>weight</emphasis> (positive numeric value) for each scoring function. The
node score provided by each scoring function is multiplied by the weight
(default weight for most scores is 1) and then combined by adding the scores for each node
provided by all the scores. This weight attribute can be used by
administrators to give higher importance to some scores.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Selects the best fit node</term>
<listitem>
<simpara>The nodes are sorted based on their scores and the node with the highest score
is selected to host the pod. If multiple nodes have the same high score, then
one of them is selected at random.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="nodes-scheduler-about-use-cases_nodes-scheduler-about">
<title>Scheduler use cases</title>
<simpara>One of the important use cases for scheduling within {product-title} is to
support flexible affinity and anti-affinity policies.</simpara>
<section xml:id="infrastructure-topological-levels_nodes-scheduler-about">
<title>Infrastructure topological levels</title>
<simpara>Administrators can define multiple topological levels for their infrastructure
(nodes) by specifying labels on nodes. For example: <literal>region=r1</literal>, <literal>zone=z1</literal>, <literal>rack=s1</literal>.</simpara>
<simpara>These label names have no particular meaning and
administrators are free to name their infrastructure levels anything, such as
city/building/room. Also, administrators can define any number of levels
for their infrastructure topology, with three levels usually being adequate
(such as: <literal>regions</literal> &#8594; <literal>zones</literal> &#8594; <literal>racks</literal>).  Administrators can specify affinity
and anti-affinity rules at each of these levels in any combination.</simpara>
</section>
<section xml:id="affinity_nodes-scheduler-about">
<title>Affinity</title>
<simpara>Administrators should be able to configure the scheduler to specify affinity at
any topological level, or even at multiple levels. Affinity at a particular
level indicates that all pods that belong to the same service are scheduled
onto nodes that belong to the same level. This handles any latency requirements
of applications by allowing administrators to ensure that peer pods do not end
up being too geographically separated. If no node is available within the same
affinity group to host the pod, then the pod is not scheduled.</simpara>
<simpara>If you need greater control over where the pods are scheduled, see <link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity">Controlling pod placement on nodes using node affinity rules</link> and
<link xl:href="../../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity">Placing pods relative to other pods using affinity and anti-affinity rules</link>.</simpara>
<simpara>These advanced scheduling features allow administrators
to specify which node a pod can be scheduled on and to force or reject scheduling relative to other pods.</simpara>
</section>
<section xml:id="anti-affinity_nodes-scheduler-about">
<title>Anti-affinity</title>
<simpara>Administrators should be able to configure the scheduler to specify
anti-affinity at any topological level, or even at multiple levels.
Anti-affinity (or 'spread') at a particular level indicates that all pods that
belong to the same service are spread across nodes that belong to that
level. This ensures that the application is well spread for high availability
purposes. The scheduler tries to balance the service pods across all
applicable nodes as evenly as possible.</simpara>
<simpara>If you need greater control over where the pods are scheduled, see <link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity">Controlling pod placement on nodes using node affinity rules</link> and
<link xl:href="../../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity">Placing pods relative to other pods using affinity and anti-affinity rules</link>.</simpara>
<simpara>These advanced scheduling features allow administrators
to specify which node a pod can be scheduled on and to force or reject scheduling relative to other pods.</simpara>
</section>
</section>
</section>
<section xml:id="nodes-scheduler-profiles">
<title>Scheduling pods using a scheduler profile</title>

<simpara>You can configure {product-title} to use a scheduling profile to schedule pods onto nodes within the cluster.</simpara>
<section xml:id="nodes-scheduler-profiles-about_nodes-scheduler-profiles">
<title>About scheduler profiles</title>
<simpara>You can specify a scheduler profile to control how pods are scheduled onto nodes.</simpara>
<simpara>The following scheduler profiles are available:</simpara>
<variablelist>
<varlistentry>
<term><literal>LowNodeUtilization</literal></term>
<listitem>
<simpara>This profile attempts to spread pods evenly across nodes to get low resource usage per node. This profile provides the default scheduler behavior.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>HighNodeUtilization</literal></term>
<listitem>
<simpara>This profile attempts to place as many pods as possible on to as few nodes as possible. This minimizes node count and has high resource usage per node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>NoScoring</literal></term>
<listitem>
<simpara>This is a low-latency profile that strives for the quickest scheduling cycle by disabling all score plugins. This might sacrifice better scheduling decisions for faster ones.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-scheduler-profiles-configuring_nodes-scheduler-profiles">
<title>Configuring a scheduler profile</title>
<simpara>You can configure the scheduler to use a scheduler profile.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>Scheduler</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit scheduler cluster</programlisting>
</listitem>
<listitem>
<simpara>Specify the profile to use in the <literal>spec.profile</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  name: cluster
#...
spec:
  mastersSchedulable: false
  profile: HighNodeUtilization <co xml:id="CO88-1"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO88-1">
<para>Set to <literal>LowNodeUtilization</literal>, <literal>HighNodeUtilization</literal>, or <literal>NoScoring</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-scheduler-pod-affinity">
<title>Placing pods relative to other pods using affinity and anti-affinity rules</title>

<simpara>Affinity is a property of pods that controls the nodes on which they prefer to be scheduled. Anti-affinity is a property of pods
that prevents a pod from being scheduled on a node.</simpara>
<simpara>In {product-title}, <emphasis>pod affinity</emphasis> and <emphasis>pod anti-affinity</emphasis> allow you to constrain which nodes your pod is eligible to be scheduled on based on the key-value labels on other pods.</simpara>
<section xml:id="nodes-scheduler-pod-affinity-about_nodes-scheduler-pod-affinity">
<title>Understanding pod affinity</title>
<simpara><emphasis>Pod affinity</emphasis> and <emphasis>pod anti-affinity</emphasis> allow you to constrain which nodes your pod is eligible to be scheduled on based on the key/value labels on other pods.</simpara>
<itemizedlist>
<listitem>
<simpara>Pod affinity can tell the scheduler to locate a new pod on the same node as other pods if the label selector on the new pod matches the label on the current pod.</simpara>
</listitem>
<listitem>
<simpara>Pod anti-affinity can prevent the scheduler from locating a new pod on the same node as pods with the same labels if the label selector on the new pod matches the label on the current pod.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, using affinity rules, you could spread or pack pods within a service or relative to pods in other services. Anti-affinity rules allow you to prevent pods of a particular service  from scheduling  on the same nodes as pods of another service that are known to interfere with the performance of the pods of the first service. Or, you could spread the pods of a service across nodes, availability zones, or availability sets to reduce correlated failures.</simpara>
<note>
<simpara>A label selector might match pods with multiple pod deployments. Use unique combinations of labels when configuring anti-affinity rules to avoid matching pods.</simpara>
</note>
<simpara>There are two types of pod affinity rules: <emphasis>required</emphasis> and <emphasis>preferred</emphasis>.</simpara>
<simpara>Required rules <emphasis role="strong">must</emphasis> be met before a pod can be scheduled on a node. Preferred rules specify that, if the rule is met, the scheduler tries to enforce the rules, but does not guarantee enforcement.</simpara>
<note>
<simpara>Depending on your pod priority and preemption settings, the scheduler might not be able to find an appropriate node for a pod without violating affinity
requirements. If so, a pod might not be scheduled.</simpara>
<simpara>To prevent this situation, carefully configure pod affinity with equal-priority pods.</simpara>
</note>
<simpara>You configure pod affinity/anti-affinity through the <literal>Pod</literal> spec files. You can specify a required rule, a preferred rule, or both. If you specify both, the node must first meet the required rule, then attempts to meet the preferred rule.</simpara>
<simpara>The following example shows a <literal>Pod</literal> spec configured for pod affinity and anti-affinity.</simpara>
<simpara>In this example, the pod affinity rule indicates that the pod can schedule onto a node only if that node has at least one already-running pod with a label that has the key <literal>security</literal> and value <literal>S1</literal>. The pod anti-affinity rule says that the pod prefers to not schedule onto a node if that node is already running a pod with label having key <literal>security</literal> and value <literal>S2</literal>.</simpara>
<formalpara>
<title>Sample <literal>Pod</literal> config file with pod affinity</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: with-pod-affinity
spec:
  affinity:
    podAffinity: <co xml:id="CO89-1"/>
      requiredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO89-2"/>
      - labelSelector:
          matchExpressions:
          - key: security <co xml:id="CO89-3"/>
            operator: In <co xml:id="CO89-4"/>
            values:
            - S1 <co xml:id="CO89-5"/>
        topologyKey: topology.kubernetes.io/zone
  containers:
  - name: with-pod-affinity
    image: docker.io/ocpqe/hello-pod</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO89-1">
<para>Stanza to configure pod affinity.</para>
</callout>
<callout arearefs="CO89-2">
<para>Defines a required rule.</para>
</callout>
<callout arearefs="CO89-3 CO89-5">
<para>The key and value (label) that must be matched to apply the rule.</para>
</callout>
<callout arearefs="CO89-4">
<para>The operator represents the relationship between the label on the existing pod and the set of values in the <literal>matchExpression</literal> parameters in the specification for the new pod.  Can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Sample <literal>Pod</literal> config file with pod anti-affinity</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: with-pod-antiaffinity
spec:
  affinity:
    podAntiAffinity: <co xml:id="CO90-1"/>
      preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO90-2"/>
      - weight: 100  <co xml:id="CO90-3"/>
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: security <co xml:id="CO90-4"/>
              operator: In <co xml:id="CO90-5"/>
              values:
              - S2
          topologyKey: kubernetes.io/hostname
  containers:
  - name: with-pod-affinity
    image: docker.io/ocpqe/hello-pod</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO90-1">
<para>Stanza to configure pod anti-affinity.</para>
</callout>
<callout arearefs="CO90-2">
<para>Defines a preferred rule.</para>
</callout>
<callout arearefs="CO90-3">
<para>Specifies a weight for a preferred rule. The node with the highest weight is preferred.</para>
</callout>
<callout arearefs="CO90-4">
<para>Description of the pod label that determines when the anti-affinity rule applies. Specify a key and value for the label.</para>
</callout>
<callout arearefs="CO90-5">
<para>The operator represents the relationship between the label on the existing pod and the set of values in the <literal>matchExpression</literal> parameters in the specification for the new pod. Can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>If labels on a node change at runtime such that the affinity rules on a pod are no longer met, the pod continues to run on the node.</simpara>
</note>
</section>
<section xml:id="nodes-scheduler-pod-affinity-configuring_nodes-scheduler-pod-affinity">
<title>Configuring a pod affinity rule</title>
<simpara>The following steps demonstrate a simple two-pod configuration that creates pod with a label and a pod that uses affinity to allow scheduling with that pod.</simpara>
<note>
<simpara>You cannot add an affinity directly to a scheduled pod.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod with a specific label in the pod spec:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-s1
  labels:
    security: S1
spec:
  containers:
  - name: security-s1
    image: docker.io/ocpqe/hello-pod</programlisting>
</listitem>
<listitem>
<simpara>Create the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;pod-spec&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>When creating other pods, configure the following parameters to add the affinity:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-s1-east
#...
spec
  affinity <co xml:id="CO91-1"/>
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO91-2"/>
      - labelSelector:
          matchExpressions:
          - key: security <co xml:id="CO91-3"/>
            values:
            - S1
            operator: In <co xml:id="CO91-4"/>
        topologyKey: topology.kubernetes.io/zone <co xml:id="CO91-5"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO91-1">
<para>Adds a pod affinity.</para>
</callout>
<callout arearefs="CO91-2">
<para>Configures the <literal>requiredDuringSchedulingIgnoredDuringExecution</literal> parameter or the <literal>preferredDuringSchedulingIgnoredDuringExecution</literal> parameter.</para>
</callout>
<callout arearefs="CO91-3">
<para>Specifies the <literal>key</literal> and <literal>values</literal> that must be met. If you want the new pod to be scheduled with the other pod, use the same <literal>key</literal> and <literal>values</literal> parameters as the label on the first pod.</para>
</callout>
<callout arearefs="CO91-4">
<para>Specifies an <literal>operator</literal>. The operator can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>. For example, use the operator <literal>In</literal> to require the label to be in the node.</para>
</callout>
<callout arearefs="CO91-5">
<para>Specify a <literal>topologyKey</literal>, which is a prepopulated <link xl:href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#interlude-built-in-node-labels">Kubernetes label</link> that the system uses to denote such a topology domain.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;pod-spec&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-pod-anti-affinity-configuring_nodes-scheduler-pod-affinity">
<title>Configuring a pod anti-affinity rule</title>
<simpara>The following steps demonstrate a simple two-pod configuration that creates pod with a label and a pod that uses an anti-affinity preferred rule to attempt to prevent scheduling with that pod.</simpara>
<note>
<simpara>You cannot add an affinity directly to a scheduled pod.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod with a specific label in the pod spec:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-s1
  labels:
    security: S1
spec:
  containers:
  - name: security-s1
    image: docker.io/ocpqe/hello-pod</programlisting>
</listitem>
<listitem>
<simpara>Create the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;pod-spec&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>When creating other pods, configure the following parameters:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-s2-east
#...
spec
  affinity <co xml:id="CO92-1"/>
    podAntiAffinity:
      preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO92-2"/>
      - weight: 100 <co xml:id="CO92-3"/>
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: security <co xml:id="CO92-4"/>
              values:
              - S1
              operator: In <co xml:id="CO92-5"/>
          topologyKey: kubernetes.io/hostname <co xml:id="CO92-6"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO92-1">
<para>Adds a pod anti-affinity.</para>
</callout>
<callout arearefs="CO92-2">
<para>Configures the <literal>requiredDuringSchedulingIgnoredDuringExecution</literal> parameter or the <literal>preferredDuringSchedulingIgnoredDuringExecution</literal> parameter.</para>
</callout>
<callout arearefs="CO92-3">
<para>For a preferred rule, specifies a weight for the node, 1-100. The node that with highest weight is preferred.</para>
</callout>
<callout arearefs="CO92-4">
<para>Specifies the <literal>key</literal> and <literal>values</literal> that must be met. If you want the new pod to not be scheduled with the other pod, use the same <literal>key</literal> and <literal>values</literal> parameters as the label on the first pod.</para>
</callout>
<callout arearefs="CO92-5">
<para>Specifies an <literal>operator</literal>. The operator can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>. For example, use the operator <literal>In</literal> to require the label to be in the node.</para>
</callout>
<callout arearefs="CO92-6">
<para>Specifies a <literal>topologyKey</literal>, which is a prepopulated <link xl:href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#interlude-built-in-node-labels">Kubernetes label</link> that the system uses to denote such a topology domain.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;pod-spec&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-pod-affinity-example_nodes-scheduler-pod-affinity">
<title>Sample pod affinity and anti-affinity rules</title>
<simpara>The following examples demonstrate pod affinity and pod anti-affinity.</simpara>
<section xml:id="nodes-scheduler-pod-affinity-example-affinity_nodes-scheduler-pod-affinity">
<title>Pod Affinity</title>
<simpara>The following example demonstrates pod affinity for pods with matching labels and label selectors.</simpara>
<itemizedlist>
<listitem>
<simpara>The pod <emphasis role="strong">team4</emphasis> has the label <literal>team:4</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: team4
  labels:
     team: "4"
#...
spec:
  containers:
  - name: ocp
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The pod <emphasis role="strong">team4a</emphasis> has the label selector <literal>team:4</literal> under <literal>podAffinity</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: team4a
#...
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: team
            operator: In
            values:
            - "4"
        topologyKey: kubernetes.io/hostname
  containers:
  - name: pod-affinity
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">team4a</emphasis> pod is scheduled on the same node as the <emphasis role="strong">team4</emphasis> pod.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-scheduler-pod-affinity-example-antiaffinity_nodes-scheduler-pod-affinity">
<title>Pod Anti-affinity</title>
<simpara>The following example demonstrates pod anti-affinity for pods with matching labels and label selectors.</simpara>
<itemizedlist>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s1</emphasis> has the label <literal>security:s1</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s1
  labels:
    security: s1
#...
spec:
  containers:
  - name: ocp
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s2</emphasis> has the label selector <literal>security:s1</literal> under <literal>podAntiAffinity</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s2
#...
spec:
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - s1
        topologyKey: kubernetes.io/hostname
  containers:
  - name: pod-antiaffinity
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s2</emphasis> cannot be scheduled on the same node as <literal>pod-s1</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-scheduler-pod-affinity-example-no-labels_nodes-scheduler-pod-affinity">
<title>Pod Affinity with no Matching Labels</title>
<simpara>The following example demonstrates pod affinity for pods without matching labels and label selectors.</simpara>
<itemizedlist>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s1</emphasis> has the label <literal>security:s1</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s1
  labels:
    security: s1
#...
spec:
  containers:
  - name: ocp
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s2</emphasis> has the label selector <literal>security:s2</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s2
#...
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
          - key: security
            operator: In
            values:
            - s2
        topologyKey: kubernetes.io/hostname
  containers:
  - name: pod-affinity
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</listitem>
<listitem>
<simpara>The pod <emphasis role="strong">pod-s2</emphasis> is not scheduled unless there is a node with a pod that has the <literal>security:s2</literal> label. If there is no other pod with that label, the new pod remains in a pending state:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY     STATUS    RESTARTS   AGE       IP        NODE
pod-s2    0/1       Pending   0          32s       &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-overriding-operator-pod-affinity_nodes-scheduler-pod-affinity">
<title>Using pod affinity and anti-affinity to control where an Operator is installed</title>
<simpara>By default, when you install an Operator, {product-title} installs the Operator pod to one of your worker nodes randomly. However, there might be situations where you want that pod scheduled on a specific node or set of nodes.</simpara>
<simpara>The following examples describe situations where you might want to schedule an Operator pod to a specific node or set of nodes:</simpara>
<itemizedlist>
<listitem>
<simpara>If an Operator requires a particular platform, such as <literal>amd64</literal> or <literal>arm64</literal></simpara>
</listitem>
<listitem>
<simpara>If an Operator requires a particular operating system, such as Linux or Windows</simpara>
</listitem>
<listitem>
<simpara>If you want Operators that work together scheduled on the same host or on hosts located on the same rack</simpara>
</listitem>
<listitem>
<simpara>If you want Operators dispersed throughout the infrastructure to avoid downtime due to network or hardware issues</simpara>
</listitem>
</itemizedlist>
<simpara>You can control where an Operator pod is installed by adding a pod affinity or anti-affinity to the Operator&#8217;s <literal>Subscription</literal> object.</simpara>
<simpara>The following example shows how to use pod anti-affinity to prevent the installation the Custom Metrics Autoscaler Operator from any node that has pods with a specific label:</simpara>
<formalpara>
<title>Pod affinity example that places the Operator pod on one or more specific nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      podAffinity: <co xml:id="CO93-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - test
          topologyKey: kubernetes.io/hostname
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO93-1">
<para>A pod affinity that places the Operator&#8217;s pod on a node that has pods with the <literal>app=test</literal> label.</para>
</callout>
</calloutlist>
<formalpara>
<title>Pod anti-affinity example that prevents the Operator pod from one or more specific nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      podAntiAffinity: <co xml:id="CO94-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: cpu
              operator: In
              values:
              - high
          topologyKey: kubernetes.io/hostname
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO94-1">
<para>A pod anti-affinity that prevents the Operator&#8217;s pod from being scheduled on a node that has pods with the <literal>cpu=high</literal> label.</para>
</callout>
</calloutlist>
<formalpara>
<title>Procedure</title>
<para>To control the placement of an Operator pod, complete the following steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Operator as usual.</simpara>
</listitem>
<listitem>
<simpara>If needed, ensure that your nodes are labeled to properly respond to the affinity.</simpara>
</listitem>
<listitem>
<simpara>Edit the Operator <literal>Subscription</literal> object to add an affinity:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      podAntiAffinity: <co xml:id="CO95-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: kubernetes.io/hostname
                operator: In
                values:
                - ip-10-0-185-229.ec2.internal
            topologyKey: topology.kubernetes.io/zone
#...</programlisting>
<calloutlist>
<callout arearefs="CO95-1">
<para>Add a <literal>podAffinity</literal> or <literal>podAntiAffinity</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To ensure that the pod is deployed on the specific node, run the following command:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ oc get pods -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                  READY   STATUS    RESTARTS   AGE   IP            NODE                           NOMINATED NODE   READINESS GATES
custom-metrics-autoscaler-operator-5dcc45d656-bhshg   1/1     Running   0          50s   10.131.0.20   ip-10-0-185-229.ec2.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-scheduler-node-affinity">
<title>Controlling pod placement on nodes using node affinity rules</title>

<simpara>Affinity is a property of pods that controls the nodes on which they prefer to be scheduled.</simpara>
<simpara>In {product-title} node affinity is a set of rules used by the scheduler to determine where a pod can be placed.
The rules are defined using custom labels on the nodes and label selectors specified in pods.</simpara>
<section xml:id="nodes-scheduler-node-affinity-about_nodes-scheduler-node-affinity">
<title>Understanding node affinity</title>
<simpara>Node affinity allows a pod to specify an affinity towards a group of nodes it can be placed on. The node does not have control over the placement.</simpara>
<simpara>For example, you could configure a pod to only run on a node with a specific CPU or in a specific availability zone.</simpara>
<simpara>There are two types of node affinity rules: <emphasis>required</emphasis> and <emphasis>preferred</emphasis>.</simpara>
<simpara>Required rules <emphasis role="strong">must</emphasis> be met before a pod can be scheduled on a node. Preferred rules specify that, if the rule is met, the scheduler tries to enforce the rules, but does not guarantee enforcement.</simpara>
<note>
<simpara>If labels on a node change at runtime that results in an node affinity rule on a pod no longer being met, the pod continues to run on the node.</simpara>
</note>
<simpara>You configure node affinity through the <literal>Pod</literal> spec file. You can specify a required rule, a preferred rule, or both. If you specify both, the node must first meet the required rule, then attempts to meet the preferred rule.</simpara>
<simpara>The following example is a <literal>Pod</literal> spec with a rule that requires the pod be placed on a node with a label whose key is <literal>e2e-az-NorthSouth</literal> and whose value is either <literal>e2e-az-North</literal> or <literal>e2e-az-South</literal>:</simpara>
<formalpara>
<title>Example pod configuration file with a node affinity required rule</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: with-node-affinity
spec:
  affinity:
    nodeAffinity: <co xml:id="CO96-1"/>
      requiredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO96-2"/>
        nodeSelectorTerms:
        - matchExpressions:
          - key: e2e-az-NorthSouth <co xml:id="CO96-3"/>
            operator: In <co xml:id="CO96-4"/>
            values:
            - e2e-az-North <co xml:id="CO96-5"/>
            - e2e-az-South <co xml:id="CO96-6"/>
  containers:
  - name: with-node-affinity
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO96-1">
<para>The stanza to configure node affinity.</para>
</callout>
<callout arearefs="CO96-2">
<para>Defines a required rule.</para>
</callout>
<callout arearefs="CO96-3 CO96-5 CO96-6">
<para>The key/value pair (label) that must be matched to apply the rule.</para>
</callout>
<callout arearefs="CO96-4">
<para>The operator represents the relationship between the label on the node and the set of values in the <literal>matchExpression</literal> parameters in the <literal>Pod</literal> spec. This value can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>, <literal>Lt</literal>, or <literal>Gt</literal>.</para>
</callout>
</calloutlist>
<simpara>The following example is a node specification with a preferred rule that a node with a label whose key is <literal>e2e-az-EastWest</literal> and whose value is either <literal>e2e-az-East</literal> or <literal>e2e-az-West</literal> is preferred for the pod:</simpara>
<formalpara>
<title>Example pod configuration file with a node affinity preferred rule</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: with-node-affinity
spec:
  affinity:
    nodeAffinity: <co xml:id="CO97-1"/>
      preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO97-2"/>
      - weight: 1 <co xml:id="CO97-3"/>
        preference:
          matchExpressions:
          - key: e2e-az-EastWest <co xml:id="CO97-4"/>
            operator: In <co xml:id="CO97-5"/>
            values:
            - e2e-az-East <co xml:id="CO97-6"/>
            - e2e-az-West <co xml:id="CO97-7"/>
  containers:
  - name: with-node-affinity
    image: docker.io/ocpqe/hello-pod
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO97-1">
<para>The stanza to configure node affinity.</para>
</callout>
<callout arearefs="CO97-2">
<para>Defines a preferred rule.</para>
</callout>
<callout arearefs="CO97-3">
<para>Specifies a weight for a preferred rule. The node with highest weight is preferred.</para>
</callout>
<callout arearefs="CO97-4 CO97-6 CO97-7">
<para>The key/value pair (label) that must be matched to apply the rule.</para>
</callout>
<callout arearefs="CO97-5">
<para>The operator represents the relationship between the label on the node and
the set of values in the <literal>matchExpression</literal> parameters in the <literal>Pod</literal> spec.
This value can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>, <literal>Lt</literal>, or <literal>Gt</literal>.</para>
</callout>
</calloutlist>
<simpara>There is no explicit <emphasis>node anti-affinity</emphasis> concept, but using the <literal>NotIn</literal> or <literal>DoesNotExist</literal> operator replicates that behavior.</simpara>
<note>
<simpara>If you are using node affinity and node selectors in the same pod configuration, note the following:</simpara>
<itemizedlist>
<listitem>
<simpara>If you configure both <literal>nodeSelector</literal> and <literal>nodeAffinity</literal>, both conditions must be satisfied for the pod to be scheduled onto a candidate node.</simpara>
</listitem>
<listitem>
<simpara>If you specify multiple <literal>nodeSelectorTerms</literal> associated with <literal>nodeAffinity</literal> types, then the pod can be scheduled onto a node if one of the <literal>nodeSelectorTerms</literal> is satisfied.</simpara>
</listitem>
<listitem>
<simpara>If you specify multiple <literal>matchExpressions</literal> associated with <literal>nodeSelectorTerms</literal>, then the pod can be scheduled onto a node only if all <literal>matchExpressions</literal> are satisfied.</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="nodes-scheduler-node-affinity-configuring-required_nodes-scheduler-node-affinity">
<title>Configuring a required node affinity rule</title>
<simpara>Required rules <emphasis role="strong">must</emphasis> be met before a pod can be scheduled on a node.</simpara>
<formalpara>
<title>Procedure</title>
<para>The following steps demonstrate a simple configuration that creates a node and a pod that the scheduler is required to place on the node.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a label to a node using the <literal>oc label node</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node node1 e2e-az-name=e2e-az1</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the label:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    e2e-az-name: e2e-az1
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Create a pod with a specific label in the pod spec:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<note>
<simpara>You cannot add an affinity directly to a scheduled pod.</simpara>
</note>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  affinity: <co xml:id="CO98-1"/>
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO98-2"/>
        nodeSelectorTerms:
        - matchExpressions:
          - key: e2e-az-name <co xml:id="CO98-3"/>
            values:
            - e2e-az1
            - e2e-az2
            operator: In <co xml:id="CO98-4"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO98-1">
<para>Adds a pod affinity.</para>
</callout>
<callout arearefs="CO98-2">
<para>Configures the <literal>requiredDuringSchedulingIgnoredDuringExecution</literal> parameter.</para>
</callout>
<callout arearefs="CO98-3">
<para>Specifies the <literal>key</literal> and <literal>values</literal> that must be met. If you want the new pod to be scheduled on the node you edited, use the same <literal>key</literal> and <literal>values</literal> parameters as the label in the node.</para>
</callout>
<callout arearefs="CO98-4">
<para>Specifies an <literal>operator</literal>. The operator can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>. For example, use the operator <literal>In</literal> to require the label to be in the node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-node-affinity-configuring-preferred_nodes-scheduler-node-affinity">
<title>Configuring a preferred node affinity rule</title>
<simpara>Preferred rules specify that, if the rule is met, the scheduler tries to enforce the rules, but does not guarantee enforcement.</simpara>
<formalpara>
<title>Procedure</title>
<para>The following steps demonstrate a simple configuration that creates a node and a pod that the scheduler tries to place on the node.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a label to a node using the <literal>oc label node</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node node1 e2e-az-name=e2e-az3</programlisting>
</listitem>
<listitem>
<simpara>Create a pod with a specific label:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file with the following content:</simpara>
<note>
<simpara>You cannot add an affinity directly to a scheduled pod.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  affinity: <co xml:id="CO99-1"/>
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO99-2"/>
      - weight: <co xml:id="CO99-3"/>
        preference:
          matchExpressions:
          - key: e2e-az-name <co xml:id="CO99-4"/>
            values:
            - e2e-az3
            operator: In <co xml:id="CO99-5"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO99-1">
<para>Adds a pod affinity.</para>
</callout>
<callout arearefs="CO99-2">
<para>Configures the <literal>preferredDuringSchedulingIgnoredDuringExecution</literal> parameter.</para>
</callout>
<callout arearefs="CO99-3">
<para>Specifies a weight for the node, as a number 1-100. The node with highest weight is preferred.</para>
</callout>
<callout arearefs="CO99-4">
<para>Specifies the <literal>key</literal> and <literal>values</literal> that must be met. If you want the new pod to be scheduled on the node you edited, use the same <literal>key</literal> and <literal>values</literal> parameters as the label in the node.</para>
</callout>
<callout arearefs="CO99-5">
<para>Specifies an <literal>operator</literal>. The operator can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>. For example, use the operator <literal>In</literal> to require the label to be in the node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-node-affinity-example_nodes-scheduler-node-affinity">
<title>Sample node affinity rules</title>
<simpara>The following examples demonstrate node affinity.</simpara>
<section xml:id="admin-guide-sched-affinity-examples1_nodes-scheduler-node-affinity">
<title>Node affinity with matching labels</title>
<simpara>The following example demonstrates node affinity for a node and pod with matching labels:</simpara>
<itemizedlist>
<listitem>
<simpara>The Node1 node has the label <literal>zone:us</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node node1 zone=us</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the label:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    zone: us
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>The pod-s1 pod has the <literal>zone</literal> and <literal>us</literal> key/value pair under a required node affinity rule:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat pod-s1.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s1
spec:
  containers:
    - image: "docker.io/ocpqe/hello-pod"
      name: hello-pod
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
            - key: "zone"
              operator: In
              values:
              - us
#...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The pod-s1 pod can be scheduled on Node1:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     READY     STATUS       RESTARTS   AGE      IP      NODE
pod-s1   1/1       Running      0          4m       IP1     node1</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="admin-guide-sched-affinity-examples2_nodes-scheduler-node-affinity">
<title>Node affinity with no matching labels</title>
<simpara>The following example demonstrates node affinity for a node and pod without matching labels:</simpara>
<itemizedlist>
<listitem>
<simpara>The Node1 node has the label <literal>zone:emea</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node node1 zone=emea</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the label:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    zone: emea
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>The pod-s1 pod has the <literal>zone</literal> and <literal>us</literal> key/value pair under a required node affinity rule:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat pod-s1.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-s1
spec:
  containers:
    - image: "docker.io/ocpqe/hello-pod"
      name: hello-pod
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
            - key: "zone"
              operator: In
              values:
              - us
#...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The pod-s1 pod cannot be scheduled on Node1:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod pod-s1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...

Events:
 FirstSeen LastSeen Count From              SubObjectPath  Type                Reason
 --------- -------- ----- ----              -------------  --------            ------
 1m        33s      8     default-scheduler Warning        FailedScheduling    No nodes are available that match all of the following predicates:: MatchNodeSelector (1).</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-overriding-operator-pod-affinity_nodes-scheduler-node-affinity">
<title>Using node affinity to control where an Operator is installed</title>
<simpara>By default, when you install an Operator, {product-title} installs the Operator pod to one of your worker nodes randomly. However, there might be situations where you want that pod scheduled on a specific node or set of nodes.</simpara>
<simpara>The following examples describe situations where you might want to schedule an Operator pod to a specific node or set of nodes:</simpara>
<itemizedlist>
<listitem>
<simpara>If an Operator requires a particular platform, such as <literal>amd64</literal> or <literal>arm64</literal></simpara>
</listitem>
<listitem>
<simpara>If an Operator requires a particular operating system, such as Linux or Windows</simpara>
</listitem>
<listitem>
<simpara>If you want Operators that work together scheduled on the same host or on hosts located on the same rack</simpara>
</listitem>
<listitem>
<simpara>If you want Operators dispersed throughout the infrastructure to avoid downtime due to network or hardware issues</simpara>
</listitem>
</itemizedlist>
<simpara>You can control where an Operator pod is installed by adding a node affinity constraints to the Operator&#8217;s <literal>Subscription</literal> object.</simpara>
<simpara>The following examples show how to use node affinity to install an instance of the Custom Metrics Autoscaler Operator to a specific node in the cluster:</simpara>
<formalpara>
<title>Node affinity example that places the Operator pod on a specific node</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      nodeAffinity: <co xml:id="CO100-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values:
              - ip-10-0-163-94.us-west-2.compute.internal
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO100-1">
<para>A node affinity that requires the Operator&#8217;s pod to be scheduled on a node named <literal>ip-10-0-163-94.us-west-2.compute.internal</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Node affinity example that places the Operator pod on a node with a specific platform</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      nodeAffinity: <co xml:id="CO101-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/arch
              operator: In
              values:
              - arm64
            - key: kubernetes.io/os
              operator: In
              values:
              - linux
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO101-1">
<para>A node affinity that requires the Operator&#8217;s pod to be scheduled on a node with the <literal>kubernetes.io/arch=arm64</literal> and <literal>kubernetes.io/os=linux</literal> labels.</para>
</callout>
</calloutlist>
<formalpara>
<title>Procedure</title>
<para>To control the placement of an Operator pod, complete the following steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Operator as usual.</simpara>
</listitem>
<listitem>
<simpara>If needed, ensure that your nodes are labeled to properly respond to the affinity.</simpara>
</listitem>
<listitem>
<simpara>Edit the Operator <literal>Subscription</literal> object to add an affinity:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity: <co xml:id="CO102-1"/>
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values:
              - ip-10-0-185-229.ec2.internal
#...</programlisting>
<calloutlist>
<callout arearefs="CO102-1">
<para>Add a <literal>nodeAffinity</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To ensure that the pod is deployed on the specific node, run the following command:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ oc get pods -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                  READY   STATUS    RESTARTS   AGE   IP            NODE                           NOMINATED NODE   READINESS GATES
custom-metrics-autoscaler-operator-5dcc45d656-bhshg   1/1     Running   0          50s   10.131.0.20   ip-10-0-185-229.ec2.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-scheduler-node-affinity-addtl-resources_nodes-scheduler-node-affinity" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-updating_nodes-nodes-working">Understanding how to update labels on nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-scheduler-overcommit">
<title>Placing pods onto overcommited nodes</title>

<simpara>In an <emphasis>overcommited</emphasis> state, the sum of the container compute resource requests and limits exceeds the resources available on the system.
Overcommitment might be desirable in development environments where a trade-off of guaranteed performance for capacity is acceptable.</simpara>
<simpara>Requests and limits enable administrators to allow and manage the overcommitment of resources on a node.
The scheduler uses requests for scheduling your container and providing a minimum service guarantee.
Limits constrain the amount of compute resource that may be consumed on your node.</simpara>
<section xml:id="nodes-cluster-overcommit-about_nodes-scheduler-overcommit">
<title>Understanding overcommitment</title>
<simpara>Requests and limits enable administrators to allow and manage the overcommitment of resources on a node. The scheduler uses requests for scheduling your container and providing a minimum service guarantee. Limits constrain the amount of compute resource that may be consumed on your node.</simpara>
<simpara>{product-title} administrators can control the level of overcommit and manage container density on nodes by configuring masters to override the ratio between request and limit set on developer containers. In conjunction with a per-project <literal>LimitRange</literal> object specifying limits and defaults, this adjusts the container limit and request to achieve the desired level of overcommit.</simpara>
<note>
<simpara>That these overrides have no effect if no limits have been set on containers. Create a <literal>LimitRange</literal> object with default limits, per individual project, or in the project template, to ensure that the overrides apply.</simpara>
</note>
<simpara>After these overrides, the container limits and requests must still be validated by any <literal>LimitRange</literal> object in the project. It is possible, for example, for developers to specify a limit close to the minimum limit, and have the request then be overridden below the minimum limit, causing the pod to be forbidden. This unfortunate user experience should be addressed with future work, but for now, configure this capability and <literal>LimitRange</literal> objects with caution.</simpara>
</section>
<section xml:id="nodes-cluster-overcommit-configure-nodes_nodes-scheduler-overcommit">
<title>Understanding nodes overcommitment</title>
<simpara>In an overcommitted environment, it is important to properly configure your node to provide best system behavior.</simpara>
<simpara>When the node starts, it ensures that the kernel tunable flags for memory
management are set properly. The kernel should never fail memory allocations
unless it runs out of physical memory.</simpara>
<simpara>To ensure this behavior, {product-title} configures the kernel to always overcommit
memory by setting the <literal>vm.overcommit_memory</literal> parameter to <literal>1</literal>, overriding the
default operating system setting.</simpara>
<simpara>{product-title} also configures the kernel not to panic when it runs out of memory
by setting the <literal>vm.panic_on_oom</literal> parameter to <literal>0</literal>. A setting of 0 instructs the
kernel to call oom_killer in an Out of Memory (OOM) condition, which kills
processes based on priority</simpara>
<simpara>You can view the current setting by running the following commands on your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sysctl -a |grep commit</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#...
vm.overcommit_memory = 0
#...</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sysctl -a |grep panic</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#...
vm.panic_on_oom = 0
#...</programlisting>
</para>
</formalpara>
<note>
<simpara>The above flags should already be set on nodes, and no further action is
required.</simpara>
</note>
<simpara>You can also perform the following configurations for each node:</simpara>
<itemizedlist>
<listitem>
<simpara>Disable or enforce CPU limits using CPU CFS quotas</simpara>
</listitem>
<listitem>
<simpara>Reserve resources for system processes</simpara>
</listitem>
<listitem>
<simpara>Reserve memory across quality of service tiers</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-scheduler-taints-tolerations">
<title>Controlling pod placement using node taints</title>

<simpara>Taints and tolerations allow the node to control which pods should (or should not) be scheduled on them.</simpara>
<section xml:id="nodes-scheduler-taints-tolerations-about_nodes-scheduler-taints-tolerations">
<title>Understanding taints and tolerations</title>
<simpara>A <emphasis>taint</emphasis> allows a node to refuse a pod to be scheduled unless that pod has a matching <emphasis>toleration</emphasis>.</simpara>
<simpara>You apply taints to a node through the <literal>Node</literal> specification (<literal>NodeSpec</literal>) and apply tolerations to a pod through the <literal>Pod</literal> specification (<literal>PodSpec</literal>). When you apply a taint a node, the scheduler cannot place a pod on that node unless the pod can tolerate the taint.</simpara>
<formalpara>
<title>Example taint in a node specification</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Node
metadata:
  name: my-node
#...
spec:
  taints:
  - effect: NoExecute
    key: key1
    value: value1
#...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example toleration in a <literal>Pod</literal> spec</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoExecute"
    tolerationSeconds: 3600
#...</programlisting>
</para>
</formalpara>
<simpara>Taints and tolerations consist of a key, value, and effect.</simpara>
<table xml:id="taint-components-table_nodes-scheduler-taints-tolerations" frame="all" rowsep="1" colsep="1">
<title>Taint and toleration components</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>key</literal> is any string, up to 253 characters. The key must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>value</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>value</literal> is any string, up to 63 characters. The value must begin with a letter or number, and may contain letters, numbers, hyphens, dots, and underscores.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>effect</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The effect is one of the following:</simpara>
<informaltable frame="none" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="60*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>NoSchedule</literal> <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>New pods that do not match the taint are not scheduled onto that node.</simpara>
</listitem>
<listitem>
<simpara>Existing pods on the node remain.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PreferNoSchedule</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>New pods that do not match the taint might be scheduled onto that node, but the scheduler tries not to.</simpara>
</listitem>
<listitem>
<simpara>Existing pods on the node remain.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NoExecute</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>New pods that do not match the taint cannot be scheduled onto that node.</simpara>
</listitem>
<listitem>
<simpara>Existing pods on the node that do not have a matching toleration  are removed.</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operator</literal></simpara></entry>
<entry align="left" valign="top"><informaltable frame="none" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="60*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Equal</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>key</literal>/<literal>value</literal>/<literal>effect</literal> parameters must match. This is the default.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Exists</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>key</literal>/<literal>effect</literal> parameters must match. You must leave a blank <literal>value</literal> parameter, which matches any.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>If you add a <literal>NoSchedule</literal> taint to a control plane node, the node must have the <literal>node-role.kubernetes.io/master=:NoSchedule</literal> taint, which is added by default.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Node
metadata:
  annotations:
    machine.openshift.io/machine: openshift-machine-api/ci-ln-62s7gtb-f76d1-v8jxv-master-0
    machineconfiguration.openshift.io/currentConfig: rendered-master-cdc1ab7da414629332cc4c3926e6e59c
  name: my-node
#...
spec:
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
#...</programlisting>
</listitem>
</orderedlist>
</para>
<simpara>A toleration matches a taint:</simpara>
<itemizedlist>
<listitem>
<simpara>If the <literal>operator</literal> parameter is set to <literal>Equal</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>the <literal>key</literal> parameters are the same;</simpara>
</listitem>
<listitem>
<simpara>the <literal>value</literal> parameters are the same;</simpara>
</listitem>
<listitem>
<simpara>the <literal>effect</literal> parameters are the same.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the <literal>operator</literal> parameter is set to <literal>Exists</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>the <literal>key</literal> parameters are the same;</simpara>
</listitem>
<listitem>
<simpara>the <literal>effect</literal> parameters are the same.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The following taints are built into {product-title}:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>node.kubernetes.io/not-ready</literal>: The node is not ready. This corresponds to the node condition <literal>Ready=False</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/unreachable</literal>: The node is unreachable from the node controller. This corresponds to the node condition <literal>Ready=Unknown</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/memory-pressure</literal>: The node has memory pressure issues. This corresponds to the node condition <literal>MemoryPressure=True</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/disk-pressure</literal>: The node has disk pressure issues. This corresponds to the node condition <literal>DiskPressure=True</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/network-unavailable</literal>: The node network is unavailable.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/unschedulable</literal>: The node is unschedulable.</simpara>
</listitem>
<listitem>
<simpara><literal>node.cloudprovider.kubernetes.io/uninitialized</literal>: When the node controller is started with an external cloud provider, this taint is set on a node to mark it as unusable. After a controller from the cloud-controller-manager initializes this node, the kubelet removes this taint.</simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/pid-pressure</literal>: The node has pid pressure. This corresponds to the node condition <literal>PIDPressure=True</literal>.</simpara>
<important>
<simpara>{product-title} does not set a default pid.available <literal>evictionHard</literal>.</simpara>
</important>
</listitem>
</itemizedlist>
<section xml:id="nodes-scheduler-taints-tolerations-about-seconds_nodes-scheduler-taints-tolerations">
<title>Understanding how to use toleration seconds to delay pod evictions</title>
<simpara>You can specify how long a pod can remain bound to a node before being evicted by specifying the <literal>tolerationSeconds</literal> parameter in the <literal>Pod</literal> specification or <literal>MachineSet</literal> object. If a taint with the <literal>NoExecute</literal> effect is added to a node, a pod that does tolerate the taint, which has the <literal>tolerationSeconds</literal> parameter, the pod is not evicted until that time period expires.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoExecute"
    tolerationSeconds: 3600
#...</programlisting>
</para>
</formalpara>
<simpara>Here, if this pod is running but does not have a matching toleration, the pod stays bound to the node for 3,600 seconds and then be evicted. If the taint is removed before that time, the pod is not evicted.</simpara>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-about-multiple_nodes-scheduler-taints-tolerations">
<title>Understanding how to use multiple taints</title>
<simpara>You can put multiple taints on the same node and multiple tolerations on the same pod. {product-title} processes multiple taints and tolerations as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Process the taints for which the pod has a matching toleration.</simpara>
</listitem>
<listitem>
<simpara>The remaining unmatched taints have the indicated effects on the pod:</simpara>
<itemizedlist>
<listitem>
<simpara>If there is at least one unmatched taint with effect <literal>NoSchedule</literal>, {product-title} cannot schedule a pod onto that node.</simpara>
</listitem>
<listitem>
<simpara>If there is no unmatched taint with effect <literal>NoSchedule</literal> but there is at least one unmatched taint with effect <literal>PreferNoSchedule</literal>, {product-title} tries to not schedule the pod onto the node.</simpara>
</listitem>
<listitem>
<simpara>If there is at least one unmatched taint with effect <literal>NoExecute</literal>, {product-title} evicts the pod from the node if it is already running on the node, or the pod is not scheduled onto the node if it is not yet running on the node.</simpara>
<itemizedlist>
<listitem>
<simpara>Pods that do not tolerate the taint are evicted immediately.</simpara>
</listitem>
<listitem>
<simpara>Pods that tolerate the taint without specifying <literal>tolerationSeconds</literal> in their <literal>Pod</literal> specification remain bound forever.</simpara>
</listitem>
<listitem>
<simpara>Pods that tolerate the taint with a specified <literal>tolerationSeconds</literal> remain bound for the specified amount of time.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Add the following taints to the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 key1=value1:NoSchedule</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 key1=value1:NoExecute</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 key2=value2:NoSchedule</programlisting>
</listitem>
<listitem>
<simpara>The pod has the following tolerations:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoSchedule"
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoExecute"
#...</programlisting>
</listitem>
</itemizedlist>
<simpara>In this case, the pod cannot be scheduled onto the node, because there is no toleration matching the third taint. The pod continues running if it is already running on the node when the taint is added, because the third taint is the only
one of the three that is not tolerated by the pod.</simpara>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-about-taintNodesByCondition_nodes-scheduler-taints-tolerations">
<title>Understanding pod scheduling and node conditions (taint node by condition)</title>
<simpara>The Taint Nodes By Condition feature, which is enabled by default, automatically taints nodes that report conditions such as memory pressure and disk pressure. If a node reports a condition, a taint is added until the condition clears. The taints have the <literal>NoSchedule</literal> effect, which means no pod can be scheduled on the node unless the pod has a matching toleration.</simpara>
<simpara>The scheduler checks for these taints on nodes before scheduling pods. If the taint is present, the pod is scheduled on a different node. Because the scheduler checks for taints and not the actual node conditions, you configure the scheduler to ignore some of these node conditions by adding appropriate pod tolerations.</simpara>
<simpara>To ensure backward compatibility, the daemon set controller automatically adds the following tolerations to all daemons:</simpara>
<itemizedlist>
<listitem>
<simpara>node.kubernetes.io/memory-pressure</simpara>
</listitem>
<listitem>
<simpara>node.kubernetes.io/disk-pressure</simpara>
</listitem>
<listitem>
<simpara>node.kubernetes.io/unschedulable (1.10 or later)</simpara>
</listitem>
<listitem>
<simpara>node.kubernetes.io/network-unavailable (host network only)</simpara>
</listitem>
</itemizedlist>
<simpara>You can also add arbitrary tolerations to daemon sets.</simpara>
<note>
<simpara>The control plane also adds the <literal>node.kubernetes.io/memory-pressure</literal> toleration on pods that have a QoS class. This is because Kubernetes manages pods in the <literal>Guaranteed</literal> or <literal>Burstable</literal> QoS classes. The new <literal>BestEffort</literal> pods do not get scheduled onto the affected node.</simpara>
</note>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-about-taintBasedEvictions_nodes-scheduler-taints-tolerations">
<title>Understanding evicting pods by condition (taint-based evictions)</title>
<simpara>The Taint-Based Evictions feature, which is enabled by default, evicts pods from a node that experiences specific conditions, such as <literal>not-ready</literal> and <literal>unreachable</literal>.
When a node experiences one of these conditions, {product-title} automatically adds taints to the node, and starts evicting and rescheduling the pods on different nodes.</simpara>
<simpara>Taint Based Evictions have a <literal>NoExecute</literal> effect, where any pod that does not tolerate the taint is evicted immediately and any pod that does tolerate the taint will never be evicted, unless the pod uses the <literal>tolerationSeconds</literal> parameter.</simpara>
<simpara>The <literal>tolerationSeconds</literal> parameter allows you to specify how long a pod stays bound to a node that has a node condition. If the condition still exists after the <literal>tolerationSeconds</literal> period, the taint remains on the node and the pods with a matching toleration are evicted. If the condition clears before the <literal>tolerationSeconds</literal> period, pods with matching tolerations are not removed.</simpara>
<simpara>If you use the <literal>tolerationSeconds</literal> parameter with no value, pods are never evicted because of the not ready and unreachable node conditions.</simpara>
<note>
<simpara>{product-title} evicts pods in a rate-limited way to prevent massive pod evictions in scenarios such as the master becoming partitioned from the nodes.</simpara>
<simpara>By default, if more than 55% of nodes in a given zone are unhealthy, the node lifecycle controller changes that zone&#8217;s state to <literal>PartialDisruption</literal> and the rate of pod evictions is reduced. For small clusters (by default, 50 nodes or less) in this state, nodes in this zone are not tainted and evictions are stopped.</simpara>
<simpara>For more information, see <link xl:href="https://kubernetes.io/docs/concepts/architecture/nodes/#rate-limits-on-eviction">Rate limits on eviction</link> in the Kubernetes documentation.</simpara>
</note>
<simpara>{product-title} automatically adds a toleration for <literal>node.kubernetes.io/not-ready</literal> and <literal>node.kubernetes.io/unreachable</literal> with <literal>tolerationSeconds=300</literal>, unless the <literal>Pod</literal> configuration specifies either toleration.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: node.kubernetes.io/not-ready
    operator: Exists
    effect: NoExecute
    tolerationSeconds: 300 <co xml:id="CO103-1"/>
  - key: node.kubernetes.io/unreachable
    operator: Exists
    effect: NoExecute
    tolerationSeconds: 300
#...</programlisting>
<calloutlist>
<callout arearefs="CO103-1">
<para>These tolerations ensure that the default pod behavior is to remain bound for five minutes after one of these node conditions problems is detected.</para>
</callout>
</calloutlist>
<simpara>You can configure these tolerations as needed. For example, if you have an application with a lot of local state, you might want to keep the pods bound to node for a longer time in the event of network partition, allowing for the partition to recover and avoiding pod eviction.</simpara>
<simpara>Pods spawned by a daemon set are created with <literal>NoExecute</literal> tolerations for the following taints with no <literal>tolerationSeconds</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>node.kubernetes.io/unreachable</literal></simpara>
</listitem>
<listitem>
<simpara><literal>node.kubernetes.io/not-ready</literal></simpara>
</listitem>
</itemizedlist>
<simpara>As a result, daemon set pods are never evicted because of these node conditions.</simpara>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-all_nodes-scheduler-taints-tolerations">
<title>Tolerating all taints</title>
<simpara>You can configure a pod to tolerate all taints by adding an <literal>operator: "Exists"</literal> toleration with no <literal>key</literal> and <literal>values</literal> parameters.
Pods with this toleration are not removed from a node that has taints.</simpara>
<formalpara>
<title><literal>Pod</literal> spec for tolerating all taints</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - operator: "Exists"
#...</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-adding_nodes-scheduler-taints-tolerations">
<title>Adding taints and tolerations</title>
<simpara>You add tolerations to pods and taints to nodes to allow the node to control which pods should or should not be scheduled on them. For existing pods and nodes, you should add the toleration to the pod first, then add the taint to the node to avoid pods being removed from the node before you can add the toleration.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a toleration to a pod by editing the <literal>Pod</literal> spec to include a <literal>tolerations</literal> stanza:</simpara>
<formalpara>
<title>Sample pod configuration file with an Equal operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1" <co xml:id="CO104-1"/>
    value: "value1"
    operator: "Equal"
    effect: "NoExecute"
    tolerationSeconds: 3600 <co xml:id="CO104-2"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO104-1">
<para>The toleration parameters, as described in the <emphasis role="strong">Taint and toleration components</emphasis> table.</para>
</callout>
<callout arearefs="CO104-2">
<para>The <literal>tolerationSeconds</literal> parameter specifies how long a pod can remain bound to a node before being evicted.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<formalpara>
<title>Sample pod configuration file with an Exists operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
   tolerations:
    - key: "key1"
      operator: "Exists" <co xml:id="CO105-1"/>
      effect: "NoExecute"
      tolerationSeconds: 3600
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO105-1">
<para>The <literal>Exists</literal> operator does not take a <literal>value</literal>.</para>
</callout>
</calloutlist>
<simpara>This example places a taint on <literal>node1</literal> that has key <literal>key1</literal>, value <literal>value1</literal>, and taint effect <literal>NoExecute</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add a taint to a node by using the following command with the parameters described in the <emphasis role="strong">Taint and toleration components</emphasis> table:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes &lt;node_name&gt; &lt;key&gt;=&lt;value&gt;:&lt;effect&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 key1=value1:NoExecute</programlisting>
<simpara>This command places a taint on <literal>node1</literal> that has key <literal>key1</literal>, value <literal>value1</literal>, and effect <literal>NoExecute</literal>.</simpara>
<note>
<simpara>If you add a <literal>NoSchedule</literal> taint to a control plane node, the node must have the <literal>node-role.kubernetes.io/master=:NoSchedule</literal> taint, which is added by default.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Node
metadata:
  annotations:
    machine.openshift.io/machine: openshift-machine-api/ci-ln-62s7gtb-f76d1-v8jxv-master-0
    machineconfiguration.openshift.io/currentConfig: rendered-master-cdc1ab7da414629332cc4c3926e6e59c
  name: my-node
#...
spec:
  taints:
  - effect: NoSchedule
    key: node-role.kubernetes.io/master
#...</programlisting>
</note>
<simpara>The tolerations on the pod match the taint on the node. A pod with either toleration can be scheduled onto <literal>node1</literal>.</simpara>
</listitem>
</orderedlist>
<section xml:id="nodes-scheduler-taints-tolerations-adding-machineset_nodes-scheduler-taints-tolerations">
<title>Adding taints and tolerations using a compute machine set</title>
<simpara>You can add taints to nodes using a compute machine set. All nodes associated with the <literal>MachineSet</literal> object are updated with the taint. Tolerations respond to taints added by a compute machine set in the same manner as taints added directly to the nodes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a toleration to a pod by editing the <literal>Pod</literal> spec to include a <literal>tolerations</literal> stanza:</simpara>
<formalpara>
<title>Sample pod configuration file with <literal>Equal</literal> operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1" <co xml:id="CO106-1"/>
    value: "value1"
    operator: "Equal"
    effect: "NoExecute"
    tolerationSeconds: 3600 <co xml:id="CO106-2"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO106-1">
<para>The toleration parameters, as described in the <emphasis role="strong">Taint and toleration components</emphasis> table.</para>
</callout>
<callout arearefs="CO106-2">
<para>The <literal>tolerationSeconds</literal> parameter specifies how long a pod is bound to a node before being evicted.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<formalpara>
<title>Sample pod configuration file with <literal>Exists</literal> operator</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key1"
    operator: "Exists"
    effect: "NoExecute"
    tolerationSeconds: 3600
#...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add the taint to the <literal>MachineSet</literal> object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>MachineSet</literal> YAML for the nodes you want to taint or you can create a new <literal>MachineSet</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machineset&gt;</programlisting>
</listitem>
<listitem>
<simpara>Add the taint to the <literal>spec.template.spec</literal> section:</simpara>
<formalpara>
<title>Example taint in a compute machine set specification</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: my-machineset
#...
spec:
#...
  template:
#...
    spec:
      taints:
      - effect: NoExecute
        key: key1
        value: value1
#...</programlisting>
</para>
</formalpara>
<simpara>This example places a taint that has the key <literal>key1</literal>, value <literal>value1</literal>, and taint effect <literal>NoExecute</literal> on the nodes.</simpara>
</listitem>
<listitem>
<simpara>Scale down the compute machine set to 0:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=0 machineset &lt;machineset&gt; -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to scale the compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machineset&gt;
  namespace: openshift-machine-api
spec:
  replicas: 0</programlisting>
</tip>
<simpara>Wait for the machines to be removed.</simpara>
</listitem>
<listitem>
<simpara>Scale up the compute machine set as needed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=2 machineset &lt;machineset&gt; -n openshift-machine-api</programlisting>
<simpara>Or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machineset&gt; -n openshift-machine-api</programlisting>
<simpara>Wait for the machines to start. The taint is added to the nodes associated with the <literal>MachineSet</literal> object.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-bindings_nodes-scheduler-taints-tolerations">
<title>Binding a user to a node using taints and tolerations</title>
<simpara>If you want to dedicate a set of nodes for exclusive use by a particular set of users, add a toleration to their pods. Then, add a corresponding taint to those nodes.  The pods with the tolerations are allowed to use the tainted nodes or any other nodes in the cluster.</simpara>
<simpara>If you want ensure the pods are scheduled to only those tainted nodes, also add a label to the same set of nodes and add a node affinity to the pods so that the pods can only be scheduled onto nodes with that label.</simpara>
<formalpara>
<title>Procedure</title>
<para>To configure a node so that users can use only that node:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a corresponding taint to those nodes:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes node1 dedicated=groupName:NoSchedule</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the taint:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: my-node
#...
spec:
  taints:
    - key: dedicated
      value: groupName
      effect: NoSchedule
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Add a toleration to the pods by writing a custom admission controller.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-projects_nodes-scheduler-taints-tolerations">
<title>Creating a project with a node selector and toleration</title>
<simpara>You can create a project that uses a node selector and toleration, which are set as annotations, to control the placement of pods onto specific nodes. Any subsequent resources created in the project are then scheduled on nodes that have a taint matching the toleration.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A label for node selection has been added to one or more nodes by using a compute machine set or editing the node directly.</simpara>
</listitem>
<listitem>
<simpara>A taint has been added to one or more nodes by using a compute machine set or editing the node directly.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Project</literal> resource definition, specifying a node selector and toleration in the <literal>metadata.annotations</literal> section:</simpara>
<formalpara>
<title>Example <literal>project.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Project
apiVersion: project.openshift.io/v1
metadata:
  name: &lt;project_name&gt; <co xml:id="CO107-1"/>
  annotations:
    openshift.io/node-selector: '&lt;label&gt;' <co xml:id="CO107-2"/>
    scheduler.alpha.kubernetes.io/defaultTolerations: &gt;-
      [{"operator": "Exists", "effect": "NoSchedule", "key":
      "&lt;key_name&gt;"} <co xml:id="CO107-3"/>
      ]</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO107-1">
<para>The project name.</para>
</callout>
<callout arearefs="CO107-2">
<para>The default node selector label.</para>
</callout>
<callout arearefs="CO107-3">
<para>The toleration parameters, as described in the <emphasis role="strong">Taint and toleration components</emphasis> table. This example uses the <literal>NoSchedule</literal> effect, which allows existing pods on the node to remain, and the <literal>Exists</literal> operator, which does not take a value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the <literal>oc apply</literal> command to create the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f project.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>Any subsequent resources created in the <literal>&lt;project_name&gt;</literal> namespace should now be scheduled on the specified nodes.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>Adding taints and tolerations <link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-adding_nodes-scheduler-taints-tolerations">manually to nodes</link> or <link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-adding-machineset_nodes-scheduler-taints-tolerations">with compute machine sets</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-selectors.xml#nodes-scheduler-node-selectors-project_nodes-scheduler-node-selectors">Creating project-wide node selectors</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-pod-placement_olm-adding-operators-to-a-cluster">Pod placement of Operator workloads</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-special_nodes-scheduler-taints-tolerations">
<title>Controlling nodes with special hardware using taints and tolerations</title>
<simpara>In a cluster where a small subset of nodes have specialized hardware, you can use taints and tolerations to keep pods that do not need the specialized hardware off of those nodes, leaving the nodes for pods that do need the specialized hardware. You can also require pods that need specialized hardware to use specific nodes.</simpara>
<simpara>You can achieve this by adding a toleration to pods that need the special hardware and tainting the nodes that have the specialized hardware.</simpara>
<formalpara>
<title>Procedure</title>
<para>To ensure nodes with specialized hardware are reserved for specific pods:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a toleration to pods that need the special hardware.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
    - key: "disktype"
      value: "ssd"
      operator: "Equal"
      effect: "NoSchedule"
      tolerationSeconds: 3600
#...</programlisting>
</listitem>
<listitem>
<simpara>Taint the nodes that have the specialized hardware using one of the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes &lt;node-name&gt; disktype=ssd:NoSchedule</programlisting>
<simpara>Or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes &lt;node-name&gt; disktype=ssd:PreferNoSchedule</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the taint:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: my_node
#...
spec:
  taints:
    - key: disktype
      value: ssd
      effect: PreferNoSchedule
#...</programlisting>
</tip>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-scheduler-taints-tolerations-removing_nodes-scheduler-taints-tolerations">
<title>Removing taints and tolerations</title>
<simpara>You can remove taints from nodes and tolerations from pods as needed. You should add the toleration to the pod first, then add the taint to the node to avoid pods being removed from the node before you can add the toleration.</simpara>
<formalpara>
<title>Procedure</title>
<para>To remove taints and tolerations:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To remove a taint from a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes &lt;node-name&gt; &lt;key&gt;-</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm taint nodes ip-10-0-132-248.ec2.internal key1-</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/ip-10-0-132-248.ec2.internal untainted</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To remove a toleration from a pod, edit the <literal>Pod</literal> spec to remove the toleration:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
#...
spec:
  tolerations:
  - key: "key2"
    operator: "Exists"
    effect: "NoExecute"
    tolerationSeconds: 3600
#...</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-scheduler-node-selectors">
<title>Placing pods on specific nodes using node selectors</title>

<simpara>A <emphasis>node selector</emphasis> specifies a map of key/value pairs that are defined using custom labels on nodes and selectors specified in pods.</simpara>
<simpara>For the pod to be eligible to run on a node, the pod must have the same key/value node selector as the label on the node.</simpara>
<section xml:id="nodes-scheduler-node-selectors-about_nodes-scheduler-node-selectors">
<title>About node selectors</title>
<simpara>You can use node selectors on pods and labels on nodes to control where the pod is scheduled. With node selectors, {product-title} schedules the pods on nodes that contain matching labels.</simpara>
<simpara>You can use a node selector to place specific pods on specific nodes, cluster-wide node selectors to place new pods on specific nodes anywhere in the cluster, and project node selectors to place new pods in a project on specific nodes.</simpara>
<simpara>For example, as a cluster administrator, you can create an infrastructure where application developers can deploy pods only onto the nodes closest to their geographical location by including a node selector in every pod they create. In this example, the cluster consists of five data centers spread across two regions. In the U.S., label the nodes as <literal>us-east</literal>, <literal>us-central</literal>, or <literal>us-west</literal>. In the Asia-Pacific region (APAC), label the nodes as <literal>apac-east</literal> or <literal>apac-west</literal>. The developers can add a node selector to the pods they create to ensure the pods get scheduled on those nodes.</simpara>
<simpara>A pod is not scheduled if the <literal>Pod</literal> object contains a node selector, but no node has a matching label.</simpara>
<important>
<simpara>If you are using node selectors and node affinity in the same pod configuration, the following rules control pod placement onto nodes:</simpara>
<itemizedlist>
<listitem>
<simpara>If you configure both <literal>nodeSelector</literal> and <literal>nodeAffinity</literal>, both conditions must be satisfied for the pod to be scheduled onto a candidate node.</simpara>
</listitem>
<listitem>
<simpara>If you specify multiple <literal>nodeSelectorTerms</literal> associated with <literal>nodeAffinity</literal> types, then the pod can be scheduled onto a node if one of the <literal>nodeSelectorTerms</literal> is satisfied.</simpara>
</listitem>
<listitem>
<simpara>If you specify multiple <literal>matchExpressions</literal> associated with <literal>nodeSelectorTerms</literal>, then the pod can be scheduled onto a node only if all <literal>matchExpressions</literal> are satisfied.</simpara>
</listitem>
</itemizedlist>
</important>
<variablelist>
<varlistentry>
<term>Node selectors on specific pods and nodes</term>
<listitem>
<simpara>You can control which node a specific pod is scheduled on by using node selectors and labels.</simpara>
<simpara>To use node selectors and labels, first label the node to avoid pods being descheduled, then add the node selector to the pod.</simpara>
<note>
<simpara>You cannot add a node selector directly to an existing scheduled pod. You must label the object that controls the pod, such as deployment config.</simpara>
</note>
<simpara>For example, the following <literal>Node</literal> object has the <literal>region: east</literal> label:</simpara>
<formalpara>
<title>Sample <literal>Node</literal> object with a label</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: ip-10-0-131-14.ec2.internal
  selfLink: /api/v1/nodes/ip-10-0-131-14.ec2.internal
  uid: 7bc2580a-8b8e-11e9-8e01-021ab4174c74
  resourceVersion: '478704'
  creationTimestamp: '2019-06-10T14:46:08Z'
  labels:
    kubernetes.io/os: linux
    topology.kubernetes.io/zone: us-east-1a
    node.openshift.io/os_version: '4.5'
    node-role.kubernetes.io/worker: ''
    topology.kubernetes.io/region: us-east-1
    node.openshift.io/os_id: rhcos
    node.kubernetes.io/instance-type: m4.large
    kubernetes.io/hostname: ip-10-0-131-14
    kubernetes.io/arch: amd64
    region: east <co xml:id="CO108-1"/>
    type: user-node
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO108-1">
<para>Labels to match the pod node selector.</para>
</callout>
</calloutlist>
<simpara>A pod has the <literal>type: user-node,region: east</literal> node selector:</simpara>
<formalpara>
<title>Sample <literal>Pod</literal> object with node selectors</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
#...
spec:
  nodeSelector: <co xml:id="CO109-1"/>
    region: east
    type: user-node
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO109-1">
<para>Node selectors to match the node label. The node must have a label for each node selector.</para>
</callout>
</calloutlist>
<simpara>When you create the pod using the example pod spec, it can be scheduled on the example node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Default cluster-wide node selectors</term>
<listitem>
<simpara>With default cluster-wide node selectors, when you create a pod in that cluster, {product-title} adds the default node selectors to the pod and schedules
the pod on nodes with matching labels.</simpara>
<simpara>For example, the following <literal>Scheduler</literal> object has the default cluster-wide <literal>region=east</literal> and <literal>type=user-node</literal> node selectors:</simpara>
<formalpara>
<title>Example Scheduler Operator Custom Resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  name: cluster
#...
spec:
  defaultNodeSelector: type=user-node,region=east
#...</programlisting>
</para>
</formalpara>
<simpara>A node in that cluster has the <literal>type=user-node,region=east</literal> labels:</simpara>
<formalpara>
<title>Example <literal>Node</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Node
metadata:
  name: ci-ln-qg1il3k-f76d1-hlmhl-worker-b-df2s4
#...
  labels:
    region: east
    type: user-node
#...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example <literal>Pod</literal> object with a node selector</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
#...
spec:
  nodeSelector:
    region: east
#...</programlisting>
</para>
</formalpara>
<simpara>When you create the pod using the example pod spec in the example cluster, the pod is created with the cluster-wide node selector and is scheduled on the labeled node:</simpara>
<formalpara>
<title>Example pod list with the pod on the labeled node</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     READY   STATUS    RESTARTS   AGE   IP           NODE                                       NOMINATED NODE   READINESS GATES
pod-s1   1/1     Running   0          20s   10.131.2.6   ci-ln-qg1il3k-f76d1-hlmhl-worker-b-df2s4   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>If the project where you create the pod has a project node selector, that selector takes preference over a cluster-wide node selector. Your pod is not created or scheduled if the pod does not have the project node selector.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
<variablelist xml:id="project-node-selectors_nodes-scheduler-node-selectors">
<varlistentry>
<term>Project node selectors</term>
<listitem>
<simpara>With project node selectors, when you create a pod in this project, {product-title} adds the node selectors to the pod and schedules the pods on a node with matching labels. If there is a cluster-wide default node selector, a project node selector takes preference.</simpara>
<simpara>For example, the following project has the <literal>region=east</literal> node selector:</simpara>
<formalpara>
<title>Example <literal>Namespace</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: east-region
  annotations:
    openshift.io/node-selector: "region=east"
#...</programlisting>
</para>
</formalpara>
<simpara>The following node has the <literal>type=user-node,region=east</literal> labels:</simpara>
<formalpara>
<title>Example <literal>Node</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Node
metadata:
  name: ci-ln-qg1il3k-f76d1-hlmhl-worker-b-df2s4
#...
  labels:
    region: east
    type: user-node
#...</programlisting>
</para>
</formalpara>
<simpara>When you create the pod using the example pod spec in this example project, the pod is created with the project node selectors and is scheduled on the labeled node:</simpara>
<formalpara>
<title>Example <literal>Pod</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  namespace: east-region
#...
spec:
  nodeSelector:
    region: east
    type: user-node
#...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example pod list with the pod on the labeled node</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     READY   STATUS    RESTARTS   AGE   IP           NODE                                       NOMINATED NODE   READINESS GATES
pod-s1   1/1     Running   0          20s   10.131.2.6   ci-ln-qg1il3k-f76d1-hlmhl-worker-b-df2s4   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
<simpara>A pod in the project is not created or scheduled if the pod contains different node selectors. For example, if you deploy the following pod into the example project, it is not be created:</simpara>
<formalpara>
<title>Example <literal>Pod</literal> object with an invalid node selector</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: west-region
#...
spec:
  nodeSelector:
    region: west
#...</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-scheduler-node-selectors-pod_nodes-scheduler-node-selectors">
<title>Using node selectors to control pod placement</title>
<simpara>You can use node selectors on pods and labels on nodes to control where the pod is scheduled. With node selectors, {product-title} schedules the pods on nodes that contain matching labels.</simpara>
<simpara>You add labels to a node, a compute machine set, or a machine config. Adding the label to the compute machine set ensures that if the node or machine goes down, new nodes have the label. Labels added to a node or machine config do not persist if the node or machine goes down.</simpara>
<simpara>To add node selectors to an existing pod, add a node selector to the controlling object for that pod, such as a <literal>ReplicaSet</literal> object, <literal>DaemonSet</literal> object, <literal>StatefulSet</literal> object, <literal>Deployment</literal> object, or <literal>DeploymentConfig</literal> object.
Any existing pods under that controlling object are recreated on a node with a matching label. If you are creating a new pod, you can add the node selector directly to the pod spec. If the pod does not have a controlling object, you must delete the pod, edit the pod spec, and recreate the pod.</simpara>
<note>
<simpara>You cannot add a node selector directly to an existing scheduled pod.</simpara>
</note>
<formalpara>
<title>Prerequisites</title>
<para>To add a node selector to existing pods, determine the controlling object for that pod.
For example, the <literal>router-default-66d5cf9464-m2g75</literal> pod is controlled by the <literal>router-default-66d5cf9464</literal>
replica set:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod router-default-66d5cf9464-7pwkc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
# ...
Name:               router-default-66d5cf9464-7pwkc
Namespace:          openshift-ingress
# ...
Controlled By:      ReplicaSet/router-default-66d5cf9464
# ...</programlisting>
</para>
</formalpara>
<simpara>The web console lists the controlling object under <literal>ownerReferences</literal> in the pod YAML:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: router-default-66d5cf9464-7pwkc
# ...
  ownerReferences:
    - apiVersion: apps/v1
      kind: ReplicaSet
      name: router-default-66d5cf9464
      uid: d81dd094-da26-11e9-a48a-128e7edf0312
      controller: true
      blockOwnerDeletion: true
# ...</programlisting>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add labels to a node by using a compute machine set or editing the node directly:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a <literal>MachineSet</literal> object to add labels to nodes managed by the compute machine set when a node is created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to add labels to a <literal>MachineSet</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet &lt;name&gt; --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"&lt;key&gt;"="&lt;value&gt;","&lt;key&gt;"="&lt;value&gt;"}}]'  -n openshift-machine-api</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet abc612-msrtw-worker-us-east-1c  --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"type":"user-node","region":"east"}}]'  -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: xf2bd-infra-us-east-2a
  namespace: openshift-machine-api
spec:
  template:
    spec:
      metadata:
        labels:
          region: "east"
          type: "user-node"
# ...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the <literal>MachineSet</literal> object by using the <literal>oc edit</literal> command:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit MachineSet abc612-msrtw-worker-us-east-1c -n openshift-machine-api</programlisting>
<formalpara>
<title>Example <literal>MachineSet</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet

# ...

spec:
# ...
  template:
    metadata:
# ...
    spec:
      metadata:
        labels:
          region: east
          type: user-node
# ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add labels directly to a node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Node</literal> object for the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes &lt;name&gt; &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example, to label a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes ip-10-0-142-25.ec2.internal type=user-node region=east</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a node:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: hello-node-6fbccf8d9
  labels:
    type: "user-node"
    region: "east"
# ...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node,region=east</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          STATUS   ROLES    AGE   VERSION
ip-10-0-142-25.ec2.internal   Ready    worker   17m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Add the matching node selector to a pod:</simpara>
<itemizedlist>
<listitem>
<simpara>To add a node selector to existing and future pods, add a node selector to the controlling object for the pods:</simpara>
<formalpara>
<title>Example <literal>ReplicaSet</literal> object with labels</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ReplicaSet
apiVersion: apps/v1
metadata:
  name: hello-node-6fbccf8d9
# ...
spec:
# ...
  template:
    metadata:
      creationTimestamp: null
      labels:
        ingresscontroller.operator.openshift.io/deployment-ingresscontroller: default
        pod-template-hash: 66d5cf9464
    spec:
      nodeSelector:
        kubernetes.io/os: linux
        node-role.kubernetes.io/worker: ''
        type: user-node <co xml:id="CO110-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO110-1">
<para>Add the node selector.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To add a node selector to a specific, new pod, add the selector to the <literal>Pod</literal> object directly:</simpara>
<formalpara>
<title>Example <literal>Pod</literal> object with a node selector</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: hello-node-6fbccf8d9
# ...
spec:
  nodeSelector:
    region: east
    type: user-node
# ...</programlisting>
</para>
</formalpara>
<note>
<simpara>You cannot add a node selector directly to an existing scheduled pod.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-node-selectors-cluster_nodes-scheduler-node-selectors">
<title>Creating default cluster-wide node selectors</title>
<simpara>You can use default cluster-wide node selectors on pods together with labels on nodes to constrain all pods created in a cluster to specific nodes.</simpara>
<simpara>With cluster-wide node selectors, when you create a pod in that cluster, {product-title} adds the default node selectors to the pod and schedules
the pod on nodes with matching labels.</simpara>
<simpara>You configure cluster-wide node selectors by editing the Scheduler Operator custom resource (CR). You add labels to a node, a compute machine set, or a machine config. Adding the label to the compute machine set ensures that if the node or machine goes down, new nodes have the label. Labels added to a node or machine config do not persist if the node or machine goes down.</simpara>
<note>
<simpara>You can add additional key/value pairs to a pod. But you cannot add a different value for a default key.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To add a default cluster-wide node selector:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the Scheduler Operator CR to add the default cluster-wide node selectors:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit scheduler cluster</programlisting>
<formalpara>
<title>Example Scheduler Operator CR with a node selector</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  name: cluster
...
spec:
  defaultNodeSelector: type=user-node,region=east <co xml:id="CO111-1"/>
  mastersSchedulable: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO111-1">
<para>Add a node selector with the appropriate <literal>&lt;key&gt;:&lt;value&gt;</literal> pairs.</para>
</callout>
</calloutlist>
<simpara>After making this change, wait for the pods in the <literal>openshift-kube-apiserver</literal> project to redeploy. This can take several minutes. The default cluster-wide node selector does not take effect until the pods redeploy.</simpara>
</listitem>
<listitem>
<simpara>Add labels to a node by using a compute machine set or editing the node directly:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a compute machine set to add labels to nodes managed by the compute machine set when a node is created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to add labels to a <literal>MachineSet</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet &lt;name&gt; --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"&lt;key&gt;"="&lt;value&gt;","&lt;key&gt;"="&lt;value&gt;"}}]'  -n openshift-machine-api <co xml:id="CO112-1"/></programlisting>
<calloutlist>
<callout arearefs="CO112-1">
<para>Add a <literal>&lt;key&gt;/&lt;value&gt;</literal> pair for each label.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"type":"user-node","region":"east"}}]'  -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machineset&gt;
  namespace: openshift-machine-api
spec:
  template:
    spec:
      metadata:
        labels:
          region: "east"
          type: "user-node"</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the <literal>MachineSet</literal> object by using the <literal>oc edit</literal> command:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit MachineSet abc612-msrtw-worker-us-east-1c -n openshift-machine-api</programlisting>
<formalpara>
<title>Example <literal>MachineSet</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
  ...
spec:
  ...
  template:
    metadata:
  ...
    spec:
      metadata:
        labels:
          region: east
          type: user-node
  ...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Redeploy the nodes associated with that compute machine set by scaling down to <literal>0</literal> and scaling up the nodes:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=0 MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c -n openshift-machine-api</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=1 MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>When the nodes are ready and available, verify that the label is added to the nodes by using the <literal>oc get</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS   ROLES    AGE   VERSION
ci-ln-l8nry52-f76d1-hl7m7-worker-c-vmqzp   Ready    worker   61s   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add labels directly to a node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Node</literal> object for the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes &lt;name&gt; &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example, to label a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes ci-ln-l8nry52-f76d1-hl7m7-worker-b-tgq49 type=user-node region=east</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a node:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    type: "user-node"
    region: "east"</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the node using the <literal>oc get</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l &lt;key&gt;=&lt;value&gt;,&lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node,region=east</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS   ROLES    AGE   VERSION
ci-ln-l8nry52-f76d1-hl7m7-worker-b-tgq49   Ready    worker   17m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-node-selectors-project_nodes-scheduler-node-selectors">
<title>Creating project-wide node selectors</title>
<simpara>You can use node selectors in a project together with labels on nodes to constrain all pods created in that project to the labeled nodes.</simpara>
<simpara>When you create a pod in this project, {product-title} adds the node selectors to the pods in the project and schedules the pods on a node with matching labels in the project. If there is a cluster-wide default node selector, a project node selector takes preference.</simpara>
<simpara>You add node selectors to a project by editing the <literal>Namespace</literal> object to add the <literal>openshift.io/node-selector</literal> parameter. You add labels to a node, a compute machine set, or a machine config. Adding the label to the compute machine set ensures that if the node or machine goes down, new nodes have the label. Labels added to a node or machine config do not persist if the node or machine goes down.</simpara>
<simpara>A pod is not scheduled if the <literal>Pod</literal> object contains a node selector, but no project has a matching node selector. When you create a pod from that spec, you receive an error similar to the following message:</simpara>
<formalpara>
<title>Example error message</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error from server (Forbidden): error when creating "pod.yaml": pods "pod-4" is forbidden: pod node label selector conflicts with its project node label selector</programlisting>
</para>
</formalpara>
<note>
<simpara>You can add additional key/value pairs to a pod. But you cannot add a different value for a project key.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To add a default project node selector:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a namespace or edit an existing namespace to add the <literal>openshift.io/node-selector</literal> parameter:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit namespace &lt;name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  annotations:
    openshift.io/node-selector: "type=user-node,region=east" <co xml:id="CO113-1"/>
    openshift.io/description: ""
    openshift.io/display-name: ""
    openshift.io/requester: kube:admin
    openshift.io/sa.scc.mcs: s0:c30,c5
    openshift.io/sa.scc.supplemental-groups: 1000880000/10000
    openshift.io/sa.scc.uid-range: 1000880000/10000
  creationTimestamp: "2021-05-10T12:35:04Z"
  labels:
    kubernetes.io/metadata.name: demo
  name: demo
  resourceVersion: "145537"
  uid: 3f8786e3-1fcb-42e3-a0e3-e2ac54d15001
spec:
  finalizers:
  - kubernetes</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO113-1">
<para>Add the <literal>openshift.io/node-selector</literal> with the appropriate <literal>&lt;key&gt;:&lt;value&gt;</literal> pairs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add labels to a node by using a compute machine set or editing the node directly:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a <literal>MachineSet</literal> object to add labels to nodes managed by the compute machine set when a node is created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the following command to add labels to a <literal>MachineSet</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet &lt;name&gt; --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"&lt;key&gt;"="&lt;value&gt;","&lt;key&gt;"="&lt;value&gt;"}}]'  -n openshift-machine-api</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c --type='json' -p='[{"op":"add","path":"/spec/template/spec/metadata/labels", "value":{"type":"user-node","region":"east"}}]'  -n openshift-machine-api</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a compute machine set:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  name: &lt;machineset&gt;
  namespace: openshift-machine-api
spec:
  template:
    spec:
      metadata:
        labels:
          region: "east"
          type: "user-node"</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the <literal>MachineSet</literal> object by using the <literal>oc edit</literal> command:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
...
spec:
...
  template:
    metadata:
...
    spec:
      metadata:
        labels:
          region: east
          type: user-node</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Redeploy the nodes associated with that compute machine set:</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=0 MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c -n openshift-machine-api</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=1 MachineSet ci-ln-l8nry52-f76d1-hl7m7-worker-c -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>When the nodes are ready and available, verify that the label is added to the nodes by using the <literal>oc get</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS   ROLES    AGE   VERSION
ci-ln-l8nry52-f76d1-hl7m7-worker-c-vmqzp   Ready    worker   61s   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add labels directly to a node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Node</literal> object to add labels:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label &lt;resource&gt; &lt;name&gt; &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example, to label a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes ci-ln-l8nry52-f76d1-hl7m7-worker-c-tgq49 type=user-node region=east</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add labels to a node:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: &lt;node_name&gt;
  labels:
    type: "user-node"
    region: "east"</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Verify that the labels are added to the <literal>Node</literal> object using the <literal>oc get</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l &lt;key&gt;=&lt;value&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l type=user-node,region=east</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS   ROLES    AGE   VERSION
ci-ln-l8nry52-f76d1-hl7m7-worker-b-tgq49   Ready    worker   17m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-projects_nodes-scheduler-taints-tolerations">Creating a project with a node selector and toleration</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints">
<title>Controlling pod placement by using pod topology spread constraints</title>

<simpara>You can use pod topology spread constraints to control the placement of your pods across nodes, zones, regions, or other user-defined topology domains.</simpara>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints-about_nodes-scheduler-pod-topology-spread-constraints">
<title>About pod topology spread constraints</title>
<simpara>By using a <emphasis>pod topology spread constraint</emphasis>, you provide fine-grained control over the distribution of pods across failure domains to help achieve high availability and more efficient resource utilization.</simpara>
<simpara>{product-title} administrators can label nodes to provide topology information, such as regions, zones, nodes, or other user-defined domains. After these labels are set on nodes, users can then define pod topology spread constraints to control the placement of pods across these topology domains.</simpara>
<simpara>You specify which pods to group together, which topology domains they are spread among, and the acceptable skew. Only pods within the same namespace are matched and grouped together when spreading due to a constraint.</simpara>
</section>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints-configuring_nodes-scheduler-pod-topology-spread-constraints">
<title>Configuring pod topology spread constraints</title>
<simpara>The following steps demonstrate how to configure pod topology spread constraints to distribute pods that match the specified labels based on their zone.</simpara>
<simpara>You can specify multiple pod topology spread constraints, but you must ensure that they do not conflict with each other. All pod topology spread constraints must be satisfied for a pod to be placed.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A user with the <literal>cluster-admin</literal> role has added the required labels to nodes.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Pod</literal> spec and specify a pod topology spread constraint:</simpara>
<formalpara>
<title>Example <literal>pod-spec.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    region: us-east
spec:
  topologySpreadConstraints:
  - maxSkew: 1 <co xml:id="CO114-1"/>
    topologyKey: topology.kubernetes.io/zone <co xml:id="CO114-2"/>
    whenUnsatisfiable: DoNotSchedule <co xml:id="CO114-3"/>
    labelSelector: <co xml:id="CO114-4"/>
      matchLabels:
        region: us-east <co xml:id="CO114-5"/>
    matchLabelKeys:
      - my-pod-label <co xml:id="CO114-6"/>
  containers:
  - image: "docker.io/ocpqe/hello-pod"
    name: hello-pod</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO114-1">
<para>The maximum difference in number of pods between any two topology domains. The default is <literal>1</literal>, and you cannot specify a value of <literal>0</literal>.</para>
</callout>
<callout arearefs="CO114-2">
<para>The key of a node label. Nodes with this key and identical value are considered to be in the same topology.</para>
</callout>
<callout arearefs="CO114-3">
<para>How to handle a pod if it does not satisfy the spread constraint. The default is <literal>DoNotSchedule</literal>, which tells the scheduler not to schedule the pod. Set to <literal>ScheduleAnyway</literal> to still schedule the pod, but the scheduler prioritizes honoring the skew to not make the cluster more imbalanced.</para>
</callout>
<callout arearefs="CO114-4">
<para>Pods that match this label selector are counted and recognized as a group when spreading to satisfy the constraint. Be sure to specify a label selector, otherwise no pods can be matched.</para>
</callout>
<callout arearefs="CO114-5">
<para>Be sure that this <literal>Pod</literal> spec also sets its labels to match this label selector if you want it to be counted properly in the future.</para>
</callout>
<callout arearefs="CO114-6">
<para>A list of pod label keys to select which pods to calculate spreading over.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod-spec.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints-examples_nodes-scheduler-pod-topology-spread-constraints">
<title>Example pod topology spread constraints</title>
<simpara>The following examples demonstrate pod topology spread constraint configurations.</simpara>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints-example-single_nodes-scheduler-pod-topology-spread-constraints">
<title>Single pod topology spread constraint example</title>
<simpara>This example <literal>Pod</literal> spec defines one pod topology spread constraint. It matches on pods labeled <literal>region: us-east</literal>, distributes among zones, specifies a skew of <literal>1</literal>, and does not schedule the pod if it does not meet these requirements.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: my-pod
  labels:
    region: us-east
spec:
  topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        region: us-east
  containers:
  - image: "docker.io/ocpqe/hello-pod"
    name: hello-pod</programlisting>
</section>
<section xml:id="nodes-scheduler-pod-topology-spread-constraints-example-multiple_nodes-scheduler-pod-topology-spread-constraints">
<title>Multiple pod topology spread constraints example</title>
<simpara>This example <literal>Pod</literal> spec defines two pod topology spread constraints. Both match on pods labeled <literal>region: us-east</literal>, specify a skew of <literal>1</literal>, and do not schedule the pod if it does not meet these requirements.</simpara>
<simpara>The first constraint distributes pods based on a user-defined label <literal>node</literal>, and the second constraint distributes pods based on a user-defined label <literal>rack</literal>. Both constraints must be met for the pod to be scheduled.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: my-pod-2
  labels:
    region: us-east
spec:
  topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: node
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        region: us-east
  - maxSkew: 1
    topologyKey: rack
    whenUnsatisfiable: DoNotSchedule
    labelSelector:
      matchLabels:
        region: us-east
  containers:
  - image: "docker.io/ocpqe/hello-pod"
    name: hello-pod</programlisting>
</section>
</section>
<section xml:id="_additional_resources_3" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-updating_nodes-nodes-working">Understanding how to update labels on nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_descheduler">
<title>Descheduler</title>
<section xml:id="nodes-descheduler-about">
<title>Descheduler overview</title>

<simpara>While the <link xl:href="../../../nodes/scheduling/nodes-scheduler-about.xml#nodes-scheduler-about">scheduler</link> is used to determine the most suitable node to host a new pod, the descheduler can be used to evict a running pod so that the pod can be rescheduled onto a more suitable node.</simpara>
<important>
<simpara>The Kube Descheduler Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="nodes-descheduler-about_nodes-descheduler-about">
<title>About the descheduler</title>
<simpara>You can use the descheduler to evict pods based on specific strategies so that the pods can be rescheduled onto more appropriate nodes.</simpara>
<simpara>You can benefit from descheduling running pods in situations such as the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Nodes are underutilized or overutilized.</simpara>
</listitem>
<listitem>
<simpara>Pod and node affinity requirements, such as taints or labels, have changed and the original scheduling decisions are no longer appropriate for certain nodes.</simpara>
</listitem>
<listitem>
<simpara>Node failure requires pods to be moved.</simpara>
</listitem>
<listitem>
<simpara>New nodes are added to clusters.</simpara>
</listitem>
<listitem>
<simpara>Pods have been restarted too many times.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The descheduler does not schedule replacement of evicted pods. The scheduler automatically performs this task for the evicted pods.</simpara>
</important>
<simpara>When the descheduler decides to evict pods from a node, it employs the following general mechanism:</simpara>
<itemizedlist>
<listitem>
<simpara>Pods in the <literal>openshift-*</literal> and <literal>kube-system</literal> namespaces are never evicted.</simpara>
</listitem>
<listitem>
<simpara>Critical pods with <literal>priorityClassName</literal> set to <literal>system-cluster-critical</literal> or <literal>system-node-critical</literal> are never evicted.</simpara>
</listitem>
<listitem>
<simpara>Static, mirrored, or stand-alone pods that are not part of a replication controller, replica set, deployment, or job are never evicted because these pods will not be recreated.</simpara>
</listitem>
<listitem>
<simpara>Pods associated with daemon sets are never evicted.</simpara>
</listitem>
<listitem>
<simpara>Pods with local storage are never evicted.</simpara>
</listitem>
<listitem>
<simpara>Best effort pods are evicted before burstable and guaranteed pods.</simpara>
</listitem>
<listitem>
<simpara>All types of pods with the <literal>descheduler.alpha.kubernetes.io/evict</literal> annotation are eligible for eviction. This annotation is used to override checks that prevent eviction, and the user can select which pod is evicted. Users should know how and if the pod will be recreated.</simpara>
</listitem>
<listitem>
<simpara>Pods subject to pod disruption budget (PDB) are not evicted if descheduling violates its pod disruption budget (PDB). The pods are evicted by using eviction subresource to handle PDB.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-descheduler-profiles_nodes-descheduler-about">
<title>Descheduler profiles</title>
<simpara>The following descheduler profiles are available:</simpara>
<variablelist>
<varlistentry>
<term><literal>AffinityAndTaints</literal></term>
<listitem>
<simpara>This profile evicts pods that violate inter-pod anti-affinity, node affinity, and node taints.</simpara>
<simpara>It enables the following strategies:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>RemovePodsViolatingInterPodAntiAffinity</literal>: removes pods that are violating inter-pod anti-affinity.</simpara>
</listitem>
<listitem>
<simpara><literal>RemovePodsViolatingNodeAffinity</literal>: removes pods that are violating node affinity.</simpara>
</listitem>
<listitem>
<simpara><literal>RemovePodsViolatingNodeTaints</literal>: removes pods that are violating <literal>NoSchedule</literal> taints on nodes.</simpara>
<simpara>Pods with a node affinity type of <literal>requiredDuringSchedulingIgnoredDuringExecution</literal> are removed.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>TopologyAndDuplicates</literal></term>
<listitem>
<simpara>This profile evicts pods in an effort to evenly spread similar pods, or pods of the same topology domain, among nodes.</simpara>
<simpara>It enables the following strategies:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>RemovePodsViolatingTopologySpreadConstraint</literal>: finds unbalanced topology domains and tries to evict pods from larger ones when <literal>DoNotSchedule</literal> constraints are violated.</simpara>
</listitem>
<listitem>
<simpara><literal>RemoveDuplicates</literal>: ensures that there is only one pod associated with a replica set, replication controller, deployment, or job running on same node. If there are more, those duplicate pods are evicted for better pod distribution in a cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>LifecycleAndUtilization</literal></term>
<listitem>
<simpara>This profile evicts long-running pods and balances resource usage between nodes.</simpara>
<simpara>It enables the following strategies:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>RemovePodsHavingTooManyRestarts</literal>: removes pods whose containers have been restarted too many times.</simpara>
<simpara>Pods where the sum of restarts over all containers (including Init Containers) is more than 100.</simpara>
</listitem>
<listitem>
<simpara><literal>LowNodeUtilization</literal>: finds nodes that are underutilized and evicts pods, if possible, from overutilized nodes in the hope that recreation of evicted pods will be scheduled on these underutilized nodes.</simpara>
<simpara>A node is considered underutilized if its usage is below 20% for all thresholds (CPU, memory, and number of pods).</simpara>
<simpara>A node is considered overutilized if its usage is above 50% for any of the thresholds (CPU, memory, and number of pods).</simpara>
</listitem>
<listitem>
<simpara><literal>PodLifeTime</literal>: evicts pods that are too old.</simpara>
<simpara>By default, pods that are older than 24 hours are removed. You can customize the pod lifetime value.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>SoftTopologyAndDuplicates</literal></term>
<listitem>
<simpara>This profile is the same as <literal>TopologyAndDuplicates</literal>, except that pods with soft topology constraints, such as <literal>whenUnsatisfiable: ScheduleAnyway</literal>, are also considered for eviction.</simpara>
<note>
<simpara>Do not enable both <literal>SoftTopologyAndDuplicates</literal> and <literal>TopologyAndDuplicates</literal>. Enabling both results in a conflict.</simpara>
</note>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>EvictPodsWithLocalStorage</literal></term>
<listitem>
<simpara>This profile allows pods with local storage to be eligible for eviction.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>EvictPodsWithPVC</literal></term>
<listitem>
<simpara>This profile allows pods with persistent volume claims to be eligible for eviction. If you are using <literal>Kubernetes NFS Subdir External Provisioner</literal>, you must add an excluded namespace for the namespace where the provisioner is installed.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="nodes-descheduler-release-notes">
<title>Kube Descheduler Operator release notes</title>

<simpara>The Kube Descheduler Operator allows you to evict pods so that they can be rescheduled on more appropriate nodes.</simpara>
<simpara>These release notes track the development of the Kube Descheduler Operator.</simpara>
<important>
<simpara>The Kube Descheduler Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<simpara>For more information, see <link xl:href="../../../nodes/scheduling/descheduler/index.xml#nodes-descheduler-about_nodes-descheduler-about">About the descheduler</link>.</simpara>
</section>
<section xml:id="nodes-descheduler-configuring">
<title>Evicting pods using the descheduler</title>

<simpara>You can run the descheduler in {product-title} by installing the Kube Descheduler Operator and setting the desired profiles and other customizations.</simpara>
<important>
<simpara>The Kube Descheduler Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="nodes-descheduler-installing_nodes-descheduler-configuring">
<title>Installing the descheduler</title>
<simpara>The descheduler is not available by default. To enable the descheduler, you must install the Kube Descheduler Operator from OperatorHub and enable one or more descheduler profiles.</simpara>
<simpara>By default, the descheduler runs in predictive mode, which means that it only simulates pod evictions. You must change the mode to automatic for the descheduler to perform the pod evictions.</simpara>
<important>
<simpara>If you have enabled hosted control planes in your cluster, set a custom priority threshold to lower the chance that pods in the hosted control plane namespaces are evicted. Set the priority threshold class name to <literal>hypershift-control-plane</literal>, because it has the lowest priority value (<literal>100000000</literal>) of the hosted control plane priority classes.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Create the required namespace for the Kube Descheduler Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis> and click <emphasis role="strong">Create Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>openshift-kube-descheduler-operator</literal> in the <emphasis role="strong">Name</emphasis> field, enter <literal>openshift.io/cluster-monitoring=true</literal> in the <emphasis role="strong">Labels</emphasis> field to enable descheduler metrics, and click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the Kube Descheduler Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">Kube Descheduler Operator</emphasis> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Kube Descheduler Operator</emphasis> and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, select <emphasis role="strong">A specific namespace on the cluster</emphasis>. Select <emphasis role="strong">openshift-kube-descheduler-operator</emphasis> from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Adjust the values for the <emphasis role="strong">Update Channel</emphasis> and <emphasis role="strong">Approval Strategy</emphasis> to the desired values.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a descheduler instance.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page, click the <emphasis role="strong">Kube Descheduler Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Kube Descheduler</emphasis> tab and click <emphasis role="strong">Create KubeDescheduler</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Edit the settings as necessary.</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>To evict pods instead of simulating the evictions, change the <emphasis role="strong">Mode</emphasis> field to <emphasis role="strong">Automatic</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-descheduler-configuring-profiles_nodes-descheduler-configuring">
<title>Configuring descheduler profiles</title>
<simpara>You can configure which profiles the descheduler uses to evict pods.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>KubeDescheduler</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit kubedeschedulers.operator.openshift.io cluster -n openshift-kube-descheduler-operator</programlisting>
</listitem>
<listitem>
<simpara>Specify one or more profiles in the <literal>spec.profiles</literal> section.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: KubeDescheduler
metadata:
  name: cluster
  namespace: openshift-kube-descheduler-operator
spec:
  deschedulingIntervalSeconds: 3600
  logLevel: Normal
  managementState: Managed
  operatorLogLevel: Normal
  mode: Predictive                                     <co xml:id="CO115-1"/>
  profileCustomizations:
    namespaces:                                        <co xml:id="CO115-2"/>
      excluded:
      - my-namespace
    podLifetime: 48h                                   <co xml:id="CO115-3"/>
    thresholdPriorityClassName: my-priority-class-name <co xml:id="CO115-4"/>
  profiles:                                            <co xml:id="CO115-5"/>
  - AffinityAndTaints
  - TopologyAndDuplicates                              <co xml:id="CO115-6"/>
  - LifecycleAndUtilization
  - EvictPodsWithLocalStorage
  - EvictPodsWithPVC</programlisting>
<calloutlist>
<callout arearefs="CO115-1">
<para>Optional: By default, the descheduler does not evict pods. To evict pods, set <literal>mode</literal> to <literal>Automatic</literal>.</para>
</callout>
<callout arearefs="CO115-2">
<para>Optional: Set a list of user-created namespaces to include or exclude from descheduler operations. Use <literal>excluded</literal> to set a list of namespaces to exclude or use <literal>included</literal> to set a list of namespaces to include. Note that protected namespaces (<literal>openshift-*</literal>, <literal>kube-system</literal>, <literal>hypershift</literal>) are excluded by default.</para>
</callout>
<callout arearefs="CO115-3">
<para>Optional: Enable a custom pod lifetime value for the <literal>LifecycleAndUtilization</literal> profile. Valid units are <literal>s</literal>, <literal>m</literal>, or <literal>h</literal>. The default pod lifetime is 24 hours.</para>
</callout>
<callout arearefs="CO115-4">
<para>Optional: Specify a priority threshold to consider pods for eviction only if their priority is lower than the specified level. Use the <literal>thresholdPriority</literal> field to set a numerical priority threshold (for example, <literal>10000</literal>) or use the <literal>thresholdPriorityClassName</literal> field to specify a certain priority class name (for example, <literal>my-priority-class-name</literal>). If you specify a priority class name, it must already exist or the descheduler will throw an error. Do not set both <literal>thresholdPriority</literal> and <literal>thresholdPriorityClassName</literal>.</para>
</callout>
<callout arearefs="CO115-5">
<para>Add one or more profiles to enable. Available profiles: <literal>AffinityAndTaints</literal>, <literal>TopologyAndDuplicates</literal>, <literal>LifecycleAndUtilization</literal>, <literal>SoftTopologyAndDuplicates</literal>, <literal>EvictPodsWithLocalStorage</literal>, and <literal>EvictPodsWithPVC</literal>.</para>
</callout>
<callout arearefs="CO115-6">
<para>Do not enable both <literal>TopologyAndDuplicates</literal> and <literal>SoftTopologyAndDuplicates</literal>. Enabling both results in a conflict.</para>
</callout>
</calloutlist>
<simpara>You can enable multiple profiles; the order that the profiles are specified in is not important.</simpara>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-descheduler-configuring-interval_nodes-descheduler-configuring">
<title>Configuring the descheduler interval</title>
<simpara>You can configure the amount of time between descheduler runs. The default is 3600 seconds (one hour).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>KubeDescheduler</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit kubedeschedulers.operator.openshift.io cluster -n openshift-kube-descheduler-operator</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>deschedulingIntervalSeconds</literal> field to the desired value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: KubeDescheduler
metadata:
  name: cluster
  namespace: openshift-kube-descheduler-operator
spec:
  deschedulingIntervalSeconds: 3600 <co xml:id="CO116-1"/>
...</programlisting>
<calloutlist>
<callout arearefs="CO116-1">
<para>Set the number of seconds between descheduler runs. A value of <literal>0</literal> in this field runs the descheduler once and exits.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-descheduler-uninstalling">
<title>Uninstalling the Kube Descheduler Operator</title>

<simpara>You can remove the Kube Descheduler Operator from {product-title} by uninstalling the Operator and removing its related resources.</simpara>
<important>
<simpara>The Kube Descheduler Operator is not currently available for {product-title} {product-version}. The Operator is planned to be released in the near future.</simpara>
</important>
<section xml:id="nodes-descheduler-uninstalling_nodes-descheduler-uninstalling">
<title>Uninstalling the descheduler</title>
<simpara>You can remove the descheduler from your cluster by removing the descheduler instance and uninstalling the Kube Descheduler Operator. This procedure also cleans up the <literal>KubeDescheduler</literal> CRD and <literal>openshift-kube-descheduler-operator</literal> namespace.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Delete the descheduler instance.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page, click <emphasis role="strong">Kube Descheduler Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Kube Descheduler</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">cluster</emphasis> entry and select <emphasis role="strong">Delete KubeDescheduler</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Uninstall the Kube Descheduler Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">Kube Descheduler Operator</emphasis> entry and select <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>openshift-kube-descheduler-operator</literal> namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>openshift-kube-descheduler-operator</literal> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">openshift-kube-descheduler-operator</emphasis> entry and select <emphasis role="strong">Delete Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, enter <literal>openshift-kube-descheduler-operator</literal> and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the <literal>KubeDescheduler</literal> CRD.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Custom Resource Definitions</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>KubeDescheduler</literal> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">KubeDescheduler</emphasis> entry and select <emphasis role="strong">Delete CustomResourceDefinition</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="_secondary_scheduler">
<title>Secondary scheduler</title>
<section xml:id="nodes-secondary-scheduler-about">
<title>Secondary scheduler overview</title>

<simpara>You can install the Secondary Scheduler Operator to run a custom secondary scheduler alongside the default scheduler to schedule pods.</simpara>
<section xml:id="nodes-secondary-scheduler-about_nodes-secondary-scheduler-about">
<title>About the Secondary Scheduler Operator</title>
<simpara>The Secondary Scheduler Operator for Red Hat OpenShift provides a way to deploy a custom secondary scheduler in {product-title}. The secondary scheduler runs alongside the default scheduler to schedule pods. Pod configurations can specify which scheduler to use.</simpara>
<simpara>The custom scheduler must have the <literal>/bin/kube-scheduler</literal> binary and be based on the <link xl:href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/">Kubernetes scheduling framework</link>.</simpara>
<important>
<simpara>You can use the Secondary Scheduler Operator to deploy a custom secondary scheduler in {product-title}, but Red Hat does not directly support the functionality of the custom secondary scheduler.</simpara>
</important>
<simpara>The Secondary Scheduler Operator creates the default roles and role bindings required by the secondary scheduler. You can specify which scheduling plugins to enable or disable by configuring the <literal>KubeSchedulerConfiguration</literal> resource for the secondary scheduler.</simpara>
</section>
</section>
<section xml:id="nodes-secondary-scheduler-release-notes">
<title>Secondary Scheduler Operator for Red Hat OpenShift release notes</title>

<simpara>The Secondary Scheduler Operator for Red Hat OpenShift allows you to deploy a custom secondary scheduler in your {product-title} cluster.</simpara>
<simpara>These release notes track the development of the Secondary Scheduler Operator for Red Hat OpenShift.</simpara>
<simpara>For more information, see <link xl:href="../../../nodes/scheduling/secondary_scheduler/index.xml#nodes-secondary-scheduler-about_nodes-secondary-scheduler-about">About the Secondary Scheduler Operator</link>.</simpara>
<section xml:id="secondary-scheduler-operator-release-notes-1.2.0">
<title>Release notes for Secondary Scheduler Operator for Red Hat OpenShift 1.2.0</title>
<simpara>Issued: 2023-11-01</simpara>
<simpara>The following advisory is available for the Secondary Scheduler Operator for Red Hat OpenShift 1.2.0:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://access.redhat.com/errata/RHSA-2023:6154">RHSA-2023:6154</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="secondary-scheduler-1.2.0-bug-fixes">
<title>Bug fixes</title>
<itemizedlist>
<listitem>
<simpara>This release of the Secondary Scheduler Operator addresses several Common Vulnerabilities and Exposures (CVEs).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="secondary-scheduler-operator-1.2.0-known-issues">
<title>Known issues</title>
<itemizedlist>
<listitem>
<simpara>Currently, you cannot deploy additional resources, such as config maps, CRDs, or RBAC policies through the Secondary Scheduler Operator. Any resources other than roles and role bindings that are required by your custom secondary scheduler must be applied externally. (<link xl:href="https://issues.redhat.com/browse/WRKLDS-645"><emphasis role="strong">WRKLDS-645</emphasis></link>)</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="secondary-scheduler-configuring">
<title>Scheduling pods using a secondary scheduler</title>
<simpara>You can run a custom secondary scheduler in {product-title} by installing the Secondary Scheduler Operator, deploying the secondary scheduler, and setting the secondary scheduler in the pod definition.</simpara>

<section xml:id="nodes-secondary-scheduler-install-console_secondary-scheduler-configuring">
<title>Installing the Secondary Scheduler Operator</title>
<simpara>You can use the web console to install the Secondary Scheduler Operator for Red Hat OpenShift.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Create the required namespace for the Secondary Scheduler Operator for Red Hat OpenShift.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis> and click <emphasis role="strong">Create Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>openshift-secondary-scheduler-operator</literal> in the <emphasis role="strong">Name</emphasis> field and click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the Secondary Scheduler Operator for Red Hat OpenShift.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <emphasis role="strong">Secondary Scheduler Operator for Red Hat OpenShift</emphasis> into the filter box.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Secondary Scheduler Operator for Red Hat OpenShift</emphasis> and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>The <emphasis role="strong">Update channel</emphasis> is set to <emphasis role="strong">stable</emphasis>, which installs the latest stable release of the Secondary Scheduler Operator for Red Hat OpenShift.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">A specific namespace on the cluster</emphasis> and select <emphasis role="strong">openshift-secondary-scheduler-operator</emphasis> from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Select an <emphasis role="strong">Update approval</emphasis> strategy.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Automatic</emphasis> strategy allows Operator Lifecycle Manager (OLM) to automatically update the Operator when a new version is available.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Manual</emphasis> strategy requires a user with appropriate credentials to approve the Operator update.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify that <emphasis role="strong">Secondary Scheduler Operator for Red Hat OpenShift</emphasis> is listed with a <emphasis role="strong">Status</emphasis> of <emphasis role="strong">Succeeded</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-secondary-scheduler-configuring-console_secondary-scheduler-configuring">
<title>Deploying a secondary scheduler</title>
<simpara>After you have installed the Secondary Scheduler Operator, you can deploy a secondary scheduler.</simpara>
<itemizedlist>
<title>Prerequisities</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>The Secondary Scheduler Operator for Red Hat OpenShift is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Create config map to hold the configuration for the secondary scheduler.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">ConfigMaps</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create ConfigMap</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the YAML editor, enter the config map definition that contains the necessary <literal>KubeSchedulerConfiguration</literal> configuration. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: "secondary-scheduler-config"                  <co xml:id="CO117-1"/>
  namespace: "openshift-secondary-scheduler-operator" <co xml:id="CO117-2"/>
data:
  "config.yaml": |
    apiVersion: kubescheduler.config.k8s.io/v1beta3
    kind: KubeSchedulerConfiguration                  <co xml:id="CO117-3"/>
    leaderElection:
      leaderElect: false
    profiles:
      - schedulerName: secondary-scheduler            <co xml:id="CO117-4"/>
        plugins:                                      <co xml:id="CO117-5"/>
          score:
            disabled:
              - name: NodeResourcesBalancedAllocation
              - name: NodeResourcesLeastAllocated</programlisting>
<calloutlist>
<callout arearefs="CO117-1">
<para>The name of the config map. This is used in the <emphasis role="strong">Scheduler Config</emphasis> field when creating the <literal>SecondaryScheduler</literal> CR.</para>
</callout>
<callout arearefs="CO117-2">
<para>The config map must be created in the <literal>openshift-secondary-scheduler-operator</literal> namespace.</para>
</callout>
<callout arearefs="CO117-3">
<para>The <literal>KubeSchedulerConfiguration</literal> resource for the secondary scheduler. For more information, see <link xl:href="https://kubernetes.io/docs/reference/config-api/kube-scheduler-config.v1beta3/#kubescheduler-config-k8s-io-v1beta3-KubeSchedulerConfiguration"><literal>KubeSchedulerConfiguration</literal></link> in the Kubernetes API documentation.</para>
</callout>
<callout arearefs="CO117-4">
<para>The name of the secondary scheduler. Pods that set their <literal>spec.schedulerName</literal> field to this value are scheduled with this secondary scheduler.</para>
</callout>
<callout arearefs="CO117-5">
<para>The plugins to enable or disable for the secondary scheduler. For a list default scheduling plugins, see <link xl:href="https://kubernetes.io/docs/reference/scheduling/config/#scheduling-plugins">Scheduling plugins</link> in the Kubernetes documentation.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>SecondaryScheduler</literal> CR:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Secondary Scheduler Operator for Red Hat OpenShift</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Secondary Scheduler</emphasis> tab and click <emphasis role="strong">Create SecondaryScheduler</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Name</emphasis> field defaults to <literal>cluster</literal>; do not change this name.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Scheduler Config</emphasis> field defaults to <literal>secondary-scheduler-config</literal>. Ensure that this value matches the name of the config map created earlier in this procedure.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Scheduler Image</emphasis> field, enter the image name for your custom scheduler.</simpara>
<important>
<simpara>Red Hat does not directly support the functionality of your custom secondary scheduler.</simpara>
</important>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-secondary-scheduler-pod-console_secondary-scheduler-configuring">
<title>Scheduling a pod using the secondary scheduler</title>
<simpara>To schedule a pod using the secondary scheduler, set the <literal>schedulerName</literal> field in the pod definition.</simpara>
<itemizedlist>
<title>Prerequisities</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>The Secondary Scheduler Operator for Red Hat OpenShift is installed.</simpara>
</listitem>
<listitem>
<simpara>A secondary scheduler is configured.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Pods</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Pod</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the YAML editor, enter the desired pod configuration and add the <literal>schedulerName</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  namespace: default
spec:
  containers:
    - name: nginx
      image: nginx:1.14.2
      ports:
        - containerPort: 80
  schedulerName: secondary-scheduler <co xml:id="CO118-1"/></programlisting>
<calloutlist>
<callout arearefs="CO118-1">
<para>The <literal>schedulerName</literal> field must match the name that is defined in the config map when you configured the secondary scheduler.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Log in to the OpenShift CLI.</simpara>
</listitem>
<listitem>
<simpara>Describe the pod using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod nginx -n default</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:         nginx
Namespace:    default
Priority:     0
Node:         ci-ln-t0w4r1k-72292-xkqs4-worker-b-xqkxp/10.0.128.3
...
Events:
  Type    Reason          Age   From                 Message
  ----    ------          ----  ----                 -------
  Normal  Scheduled       12s   secondary-scheduler  Successfully assigned default/nginx to ci-ln-t0w4r1k-72292-xkqs4-worker-b-xqkxp
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>In the events table, find the event with a message similar to <literal>Successfully assigned &lt;namespace&gt;/&lt;pod_name&gt; to &lt;node_name&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the "From" column, verify that the event was generated from the secondary scheduler and not the default scheduler.</simpara>
<note>
<simpara>You can also check the <literal>secondary-scheduler-*</literal> pod logs in the <literal>openshift-secondary-scheduler-namespace</literal> to verify that the pod was scheduled by the secondary scheduler.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="secondary-scheduler-uninstalling">
<title>Uninstalling the Secondary Scheduler Operator</title>

<simpara>You can remove the Secondary Scheduler Operator for Red Hat OpenShift from {product-title} by uninstalling the Operator and removing its related resources.</simpara>
<section xml:id="nodes-secondary-scheduler-uninstall-console_secondary-scheduler-uninstalling">
<title>Uninstalling the Secondary Scheduler Operator</title>
<simpara>You can uninstall the Secondary Scheduler Operator for Red Hat OpenShift by using the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>The Secondary Scheduler Operator for Red Hat OpenShift is installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Uninstall the Secondary Scheduler Operator for Red Hat OpenShift Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">Secondary Scheduler Operator</emphasis> entry and click <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, click <emphasis role="strong">Uninstall</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-secondary-scheduler-remove-resources-console_secondary-scheduler-uninstalling">
<title>Removing Secondary Scheduler Operator resources</title>
<simpara>Optionally, after uninstalling the Secondary Scheduler Operator for Red Hat OpenShift, you can remove its related resources from your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Remove CRDs that were installed by the Secondary Scheduler Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>SecondaryScheduler</literal> in the <emphasis role="strong">Name</emphasis> field to filter the CRDs.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">SecondaryScheduler</emphasis> CRD and select <emphasis role="strong">Delete Custom Resource Definition</emphasis>:</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove the <literal>openshift-secondary-scheduler-operator</literal> namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Namespaces</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <emphasis role="strong">openshift-secondary-scheduler-operator</emphasis> and select <emphasis role="strong">Delete Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the confirmation dialog, enter <literal>openshift-secondary-scheduler-operator</literal> in the field and click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_using_jobs_and_daemonsets">
<title>Using Jobs and DaemonSets</title>
<section xml:id="nodes-pods-daemonsets">
<title>Running background tasks on nodes automatically with daemon sets</title>

<simpara>As an administrator, you can create and use daemon sets to run replicas of a pod on specific or all nodes in an {product-title} cluster.</simpara>
<simpara>A daemon set ensures that all (or some) nodes run a copy of a pod. As nodes are added to the cluster, pods are added to the cluster.
As nodes are removed from the cluster, those pods are removed through garbage collection. Deleting a daemon set will clean up the pods it created.</simpara>
<simpara>You can use daemon sets to create shared storage, run a logging pod on every node in
your cluster, or deploy a monitoring agent on every node.</simpara>
<simpara>For security reasons, the cluster administrators and the project administrators can create daemon sets.</simpara>
<simpara>For more information on daemon sets, see the <link xl:href="http://kubernetes.io/docs/admin/daemons/">Kubernetes documentation</link>.</simpara>
<important>
<simpara>Daemon set scheduling is incompatible with project&#8217;s default node selector.
If you fail to disable it, the daemon set gets restricted by merging with the
default node selector. This results in frequent pod recreates on the nodes that
got unselected by the merged node selector, which in turn puts unwanted load on
the cluster.</simpara>
</important>
<section xml:id="_scheduled_by_default_scheduler">
<title>Scheduled by default scheduler</title>
<simpara>A daemon set ensures that all eligible nodes run a copy of a pod. Normally, the node that a pod runs on is selected by the Kubernetes scheduler. However, daemon set pods are created and scheduled by the daemon set controller. That introduces the following issues:</simpara>
<itemizedlist>
<listitem>
<simpara>Inconsistent pod behavior: Normal pods waiting to be scheduled are created and in Pending state, but daemon set pods are not created in <literal>Pending</literal> state. This is confusing to the user.</simpara>
</listitem>
<listitem>
<simpara>Pod preemption is handled by default scheduler. When preemption is enabled, the daemon set controller will make scheduling decisions without considering pod priority and preemption.</simpara>
</listitem>
</itemizedlist>
<simpara>The <emphasis role="strong">ScheduleDaemonSetPods</emphasis> feature, enabled by default in {product-title}, lets you schedule daemon sets using the default scheduler instead of the daemon set controller, by adding the <literal>NodeAffinity</literal> term to the daemon set pods, instead of the <literal>spec.nodeName</literal> term. The default scheduler is then used to bind the pod to the target host. If node affinity of the daemon set pod already exists, it is replaced. The daemon set controller only performs these operations when creating or modifying daemon set pods, and no changes are made to the <literal>spec.template</literal> of the daemon set.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: hello-node-6fbccf8d9-9tmzr
#...
spec:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchFields:
        - key: metadata.name
          operator: In
          values:
          - target-host-name
#...</programlisting>
<simpara>In addition, a <literal>node.kubernetes.io/unschedulable:NoSchedule</literal> toleration is added automatically to daemon set pods. The default scheduler ignores unschedulable Nodes when scheduling daemon set pods.</simpara>
</section>
<section xml:id="nodes-pods-daemonsets-creating_nodes-pods-daemonsets">
<title>Creating daemonsets</title>
<simpara>When creating daemon sets, the <literal>nodeSelector</literal> field is used to indicate the
nodes on which the daemon set should deploy replicas.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Before you start using daemon sets, disable the default project-wide node selector
in your namespace, by setting the namespace annotation <literal>openshift.io/node-selector</literal> to an empty string:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch namespace myproject -p \
    '{"metadata": {"annotations": {"openshift.io/node-selector": ""}}}'</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to disable the default project-wide node selector for a namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: &lt;namespace&gt;
  annotations:
    openshift.io/node-selector: ''
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>If you are creating a new project, overwrite the default node selector:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm new-project &lt;name&gt; --node-selector=""</programlisting>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To create a daemon set:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Define the daemon set yaml file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: hello-daemonset
spec:
  selector:
      matchLabels:
        name: hello-daemonset <co xml:id="CO119-1"/>
  template:
    metadata:
      labels:
        name: hello-daemonset <co xml:id="CO119-2"/>
    spec:
      nodeSelector: <co xml:id="CO119-3"/>
        role: worker
      containers:
      - image: openshift/hello-openshift
        imagePullPolicy: Always
        name: registry
        ports:
        - containerPort: 80
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
      serviceAccount: default
      terminationGracePeriodSeconds: 10
#...</programlisting>
<calloutlist>
<callout arearefs="CO119-1">
<para>The label selector that determines which pods belong to the daemon set.</para>
</callout>
<callout arearefs="CO119-2">
<para>The pod template&#8217;s label selector. Must match the label selector above.</para>
</callout>
<callout arearefs="CO119-3">
<para>The node selector that determines on which nodes pod replicas should be deployed.
A matching label must be present on the node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the daemon set object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f daemonset.yaml</programlisting>
</listitem>
<listitem>
<simpara>To verify that the pods were created, and that each node has a pod replica:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the daemonset pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">hello-daemonset-cx6md   1/1       Running   0          2m
hello-daemonset-e3md9   1/1       Running   0          2m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the pods to verify the pod has been placed onto the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod/hello-daemonset-cx6md|grep Node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Node:        openshift-node01.hostname.com/10.14.20.134</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod/hello-daemonset-e3md9|grep Node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Node:        openshift-node02.hostname.com/10.14.20.137</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<important>
<itemizedlist>
<listitem>
<simpara>If you update a daemon set pod template, the existing pod
replicas are not affected.</simpara>
</listitem>
<listitem>
<simpara>If you delete a daemon set and then create a new daemon set
with a different template but the same label selector, it recognizes any
existing pod replicas as having matching labels and thus does not update them or
create new replicas despite a mismatch in the pod template.</simpara>
</listitem>
<listitem>
<simpara>If you change node labels, the daemon set adds pods to nodes that match the new labels and deletes pods
from nodes that do not match the new labels.</simpara>
</listitem>
</itemizedlist>
<simpara>To update a daemon set, force new pod replicas to be created by deleting the old
replicas or nodes.</simpara>
</important>
</section>
</section>
<section xml:id="nodes-nodes-jobs">
<title>Running tasks in pods using jobs</title>

<simpara>A <emphasis>job</emphasis> executes a task in your {product-title} cluster.</simpara>
<simpara>A job tracks the overall progress of a task and updates its status with information
about active, succeeded, and failed pods. Deleting a job will clean up any pod
replicas it created. Jobs are part of the Kubernetes API, which can be managed
with <literal>oc</literal> commands like other object types.</simpara>
<formalpara>
<title>Sample Job specification</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  parallelism: 1    <co xml:id="CO120-1"/>
  completions: 1    <co xml:id="CO120-2"/>
  activeDeadlineSeconds: 1800 <co xml:id="CO120-3"/>
  backoffLimit: 6   <co xml:id="CO120-4"/>
  template:         <co xml:id="CO120-5"/>
    metadata:
      name: pi
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: OnFailure    <co xml:id="CO120-6"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO120-1">
<para>The pod replicas a job should run in parallel.</para>
</callout>
<callout arearefs="CO120-2">
<para>Successful pod completions are needed to mark a job completed.</para>
</callout>
<callout arearefs="CO120-3">
<para>The maximum duration the job can run.</para>
</callout>
<callout arearefs="CO120-4">
<para>The number of retries for a job.</para>
</callout>
<callout arearefs="CO120-5">
<para>The template for the pod the controller creates.</para>
</callout>
<callout arearefs="CO120-6">
<para>The restart policy of the pod.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Jobs</link> in the Kubernetes documentation</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-nodes-jobs-about_nodes-nodes-jobs">
<title>Understanding jobs and cron jobs</title>
<simpara>A job tracks the overall progress of a task and updates its status with information
about active, succeeded, and failed pods. Deleting a job cleans up any pods it created.
Jobs are part of the Kubernetes API, which can be managed
with <literal>oc</literal> commands like other object types.</simpara>
<simpara>There are two possible resource types that allow creating run-once objects in {product-title}:</simpara>
<variablelist>
<varlistentry>
<term>Job</term>
<listitem>
<simpara>A regular job is a run-once object that creates a task and ensures the job finishes.</simpara>
<simpara>There are three main types of task suitable to run as a job:</simpara>
<itemizedlist>
<listitem>
<simpara>Non-parallel jobs:</simpara>
<itemizedlist>
<listitem>
<simpara>A job that starts only one pod, unless the pod fails.</simpara>
</listitem>
<listitem>
<simpara>The job is complete as soon as its pod terminates successfully.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Parallel jobs with a fixed completion count:</simpara>
<itemizedlist>
<listitem>
<simpara>a job that starts multiple pods.</simpara>
</listitem>
<listitem>
<simpara>The job represents the overall task and is complete when there is one successful pod for each value in the range <literal>1</literal> to the <literal>completions</literal> value.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Parallel jobs with a work queue:</simpara>
<itemizedlist>
<listitem>
<simpara>A job with multiple parallel worker processes in a given pod.</simpara>
</listitem>
<listitem>
<simpara>{product-title} coordinates pods to determine what each should work on or use an external queue service.</simpara>
</listitem>
<listitem>
<simpara>Each pod is independently capable of determining whether or not all peer pods are complete and that the entire job is done.</simpara>
</listitem>
<listitem>
<simpara>When any pod from the job terminates with success, no new pods are created.</simpara>
</listitem>
<listitem>
<simpara>When at least one pod has terminated with success and all pods are terminated, the job is successfully completed.</simpara>
</listitem>
<listitem>
<simpara>When any pod has exited with success, no other pod should be doing any work for this task or writing any output. Pods should all be in the process of exiting.</simpara>
<simpara>For more information about how to make use of the different types of job, see <link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#job-patterns">Job Patterns</link> in the Kubernetes documentation.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Cron job</term>
<listitem>
<simpara>A job can be scheduled to run multiple times, using a cron job.</simpara>
<simpara>A <emphasis>cron job</emphasis> builds on a regular job by allowing you to specify
how the job should be run. Cron jobs are part of the
<link xl:href="http://kubernetes.io/docs/user-guide/cron-jobs">Kubernetes</link> API, which
can be managed with <literal>oc</literal> commands like other object types.</simpara>
<simpara>Cron jobs are useful for creating periodic and recurring tasks, like running backups or sending emails.
Cron jobs can also schedule individual tasks for a specific time, such as if you want to schedule a job for a low activity period. A cron job creates a <literal>Job</literal> object based on the timezone configured on the control plane node that runs the cronjob controller.</simpara>
<warning>
<simpara>A cron job creates a <literal>Job</literal> object approximately once per execution time of its
schedule, but there are circumstances in which it fails to create a job or
two jobs might be created. Therefore, jobs must be idempotent and you must
configure history limits.</simpara>
</warning>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="jobs-create_nodes-nodes-jobs">
<title>Understanding how to create jobs</title>
<simpara>Both resource types require a job configuration that consists of the following key parts:</simpara>
<itemizedlist>
<listitem>
<simpara>A pod template, which describes the pod that {product-title} creates.</simpara>
</listitem>
<listitem>
<simpara>The <literal>parallelism</literal> parameter, which specifies how many pods running in parallel at any point in time should execute a job.</simpara>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset, defaults to <literal>1</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The <literal>completions</literal> parameter, specifying how many successful pod completions are needed to finish a job.</simpara>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset, defaults to <literal>1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a fixed completion count, specify a value.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a work queue, leave unset. When unset defaults to the <literal>parallelism</literal> value.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="jobs-set-max_nodes-nodes-jobs">
<title>Understanding how to set a maximum duration for jobs</title>
<simpara>When defining a job, you can define its maximum duration by setting
the <literal>activeDeadlineSeconds</literal> field. It is specified in seconds and is not
set by default. When not set, there is no maximum duration enforced.</simpara>
<simpara>The maximum duration is counted from the time when a first pod gets scheduled in
the system, and defines how long a job can be active. It tracks overall time of
an execution. After reaching the specified timeout, the job is terminated by {product-title}.</simpara>
</section>
<section xml:id="jobs-set-backoff_nodes-nodes-jobs">
<title>Understanding how to set a job back off policy for pod failure</title>
<simpara>A job can be considered failed, after a set amount of retries due to a
logical error in configuration or other similar reasons. Failed pods associated with the job are recreated by the controller with
an exponential back off delay (<literal>10s</literal>, <literal>20s</literal>, <literal>40s</literal> …) capped at six minutes. The
limit is reset if no new failed pods appear between controller checks.</simpara>
<simpara>Use the <literal>spec.backoffLimit</literal> parameter to set the number of retries for a job.</simpara>
</section>
<section xml:id="jobs-artifacts_nodes-nodes-jobs">
<title>Understanding how to configure a cron job to remove artifacts</title>
<simpara>Cron jobs can leave behind artifact resources such as jobs or pods.  As a user it is important
to configure history limits so that old jobs and their pods are properly cleaned.  There are two fields within cron job&#8217;s spec responsible for that:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>.spec.successfulJobsHistoryLimit</literal>. The number of successful finished jobs to retain (defaults to 3).</simpara>
</listitem>
<listitem>
<simpara><literal>.spec.failedJobsHistoryLimit</literal>. The number of failed finished jobs to retain (defaults to 1).</simpara>
</listitem>
</itemizedlist>
<tip>
<itemizedlist>
<listitem>
<simpara>Delete cron jobs that you no longer need:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete cronjob/&lt;cron_job_name&gt;</programlisting>
<simpara>Doing this prevents them from generating unnecessary artifacts.</simpara>
</listitem>
<listitem>
<simpara>You can suspend further executions by setting the <literal>spec.suspend</literal> to true.  All subsequent executions are suspended until you reset to <literal>false</literal>.</simpara>
</listitem>
</itemizedlist>
</tip>
</section>
<section xml:id="jobs-limits_nodes-nodes-jobs">
<title>Known limitations</title>
<simpara>The job specification restart policy only applies to the <emphasis>pods</emphasis>, and not the <emphasis>job controller</emphasis>. However, the job controller is hard-coded to keep retrying jobs to completion.</simpara>
<simpara>As such, <literal>restartPolicy: Never</literal> or <literal>--restart=Never</literal> results in the same behavior as <literal>restartPolicy: OnFailure</literal> or <literal>--restart=OnFailure</literal>. That is, when a job fails it is restarted automatically until it succeeds (or is manually discarded). The policy only sets which subsystem performs the restart.</simpara>
<simpara>With the <literal>Never</literal> policy, the <emphasis>job controller</emphasis> performs the restart. With each attempt, the job controller increments the number of failures in the job status and create new pods. This means that with each failed attempt, the number of pods increases.</simpara>
<simpara>With the <literal>OnFailure</literal> policy, <emphasis>kubelet</emphasis> performs the restart. Each attempt does not increment the number of failures in the job status. In addition, kubelet will retry failed jobs starting pods on the same nodes.</simpara>
</section>
</section>
<section xml:id="nodes-nodes-jobs-creating_nodes-nodes-jobs">
<title>Creating jobs</title>
<simpara>You create a job in {product-title} by creating a job object.</simpara>
<formalpara>
<title>Procedure</title>
<para>To create a job:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  parallelism: 1    <co xml:id="CO121-1"/>
  completions: 1    <co xml:id="CO121-2"/>
  activeDeadlineSeconds: 1800 <co xml:id="CO121-3"/>
  backoffLimit: 6   <co xml:id="CO121-4"/>
  template:         <co xml:id="CO121-5"/>
    metadata:
      name: pi
    spec:
      containers:
      - name: pi
        image: perl
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: OnFailure    <co xml:id="CO121-6"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO121-1">
<para>Optional: Specify how many pod replicas a job should run in parallel; defaults to <literal>1</literal>.</para>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset, defaults to <literal>1</literal>.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO121-2">
<para>Optional: Specify how many successful pod completions are needed to mark a job completed.</para>
<itemizedlist>
<listitem>
<simpara>For non-parallel jobs, leave unset. When unset, defaults to <literal>1</literal>.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a fixed completion count, specify the number of completions.</simpara>
</listitem>
<listitem>
<simpara>For parallel jobs with a work queue, leave unset. When unset defaults to the <literal>parallelism</literal> value.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO121-3">
<para>Optional: Specify the maximum duration the job can run.</para>
</callout>
<callout arearefs="CO121-4">
<para>Optional: Specify the number of retries for a job. This field defaults to six.</para>
</callout>
<callout arearefs="CO121-5">
<para>Specify the template for the pod the controller creates.</para>
</callout>
<callout arearefs="CO121-6">
<para>Specify the restart policy of the pod:</para>
<itemizedlist>
<listitem>
<simpara><literal>Never</literal>. Do not restart the job.</simpara>
</listitem>
<listitem>
<simpara><literal>OnFailure</literal>. Restart the job only if it fails.</simpara>
</listitem>
<listitem>
<simpara><literal>Always</literal>. Always restart the job.</simpara>
<simpara>For details on how {product-title} uses restart policy with failed containers, see
the <link xl:href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states">Example States</link> in the Kubernetes documentation.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the job:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>You can also create and launch a job from a single command using <literal>oc create job</literal>. The following command creates and launches a job similar to the one specified in the previous example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create job pi --image=perl -- perl -Mbignum=bpi -wle 'print bpi(2000)'</programlisting>
</note>
</section>
<section xml:id="nodes-nodes-jobs-creating-cron_nodes-nodes-jobs">
<title>Creating cron jobs</title>
<simpara>You create a cron job in {product-title} by creating a job object.</simpara>
<formalpara>
<title>Procedure</title>
<para>To create a cron job:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: batch/v1
kind: CronJob
metadata:
  name: pi
spec:
  schedule: "*/1 * * * *"          <co xml:id="CO122-1"/>
  timeZone: Etc/UTC                <co xml:id="CO122-2"/>
  concurrencyPolicy: "Replace"     <co xml:id="CO122-3"/>
  startingDeadlineSeconds: 200     <co xml:id="CO122-4"/>
  suspend: true                    <co xml:id="CO122-5"/>
  successfulJobsHistoryLimit: 3    <co xml:id="CO122-6"/>
  failedJobsHistoryLimit: 1        <co xml:id="CO122-7"/>
  jobTemplate:                     <co xml:id="CO122-8"/>
    spec:
      template:
        metadata:
          labels:                  <co xml:id="CO122-9"/>
            parent: "cronjobpi"
        spec:
          containers:
          - name: pi
            image: perl
            command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
          restartPolicy: OnFailure <co xml:id="CO122-10"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO122-1">
<para>Schedule for the job specified in <link xl:href="https://en.wikipedia.org/wiki/Cron">cron format</link>. In this example, the job will run every minute.</para>
</callout>
<callout arearefs="CO122-2">
<para>An optional time zone for the schedule. See <link xl:href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">List of tz database time zones</link> for valid options. If not specified, the Kubernetes controller manager interprets the schedule relative to its local time zone.</para>
</callout>
<callout arearefs="CO122-3">
<para>An optional concurrency policy, specifying how to treat concurrent jobs within a cron job. Only one of the following concurrent policies may be specified. If not specified, this defaults to allowing concurrent executions.</para>
<itemizedlist>
<listitem>
<simpara><literal>Allow</literal> allows cron jobs to run concurrently.</simpara>
</listitem>
<listitem>
<simpara><literal>Forbid</literal> forbids concurrent runs, skipping the next run if the previous has not
finished yet.</simpara>
</listitem>
<listitem>
<simpara><literal>Replace</literal> cancels the currently running job and replaces
it with a new one.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO122-4">
<para>An optional deadline (in seconds) for starting the job if it misses its
scheduled time for any reason. Missed jobs executions will be counted as failed
ones. If not specified, there is no deadline.</para>
</callout>
<callout arearefs="CO122-5">
<para>An optional flag allowing the suspension of a cron job. If set to <literal>true</literal>,
all subsequent executions will be suspended.</para>
</callout>
<callout arearefs="CO122-6">
<para>The number of successful finished jobs to retain (defaults to 3).</para>
</callout>
<callout arearefs="CO122-7">
<para>The number of failed finished jobs to retain (defaults to 1).</para>
</callout>
<callout arearefs="CO122-8">
<para>Job template. This is similar to the job example.</para>
</callout>
<callout arearefs="CO122-9">
<para>Sets a label for jobs spawned by this cron job.</para>
</callout>
<callout arearefs="CO122-10">
<para>The restart policy of the pod. This does not apply to the job controller.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the cron job:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>You can also create and launch a cron job from a single command using <literal>oc create cronjob</literal>. The following command creates and launches a cron job similar to the one specified in the previous example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create cronjob pi --image=perl --schedule='*/1 * * * *' -- perl -Mbignum=bpi -wle 'print bpi(2000)'</programlisting>
<simpara>With <literal>oc create cronjob</literal>, the <literal>--schedule</literal> option accepts schedules in <link xl:href="https://en.wikipedia.org/wiki/Cron">cron format</link>.</simpara>
</note>
</section>
</section>
</chapter>
<chapter xml:id="_working_with_nodes">
<title>Working with nodes</title>
<section xml:id="nodes-nodes-viewing">
<title>Viewing and listing the nodes in your {product-title} cluster</title>

<simpara>You can list all the nodes in your cluster to obtain information such as status, age, memory usage, and details about the nodes.</simpara>
<simpara>When you perform node management operations, the CLI interacts with node objects that are representations of actual node hosts.
The master uses the information from node objects to validate nodes with health checks.</simpara>
<section xml:id="nodes-nodes-viewing-listing_nodes-nodes-viewing">
<title>About listing all the nodes in a cluster</title>
<simpara>You can get detailed information on the nodes in the cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>The following command lists all nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<simpara>The following example is a cluster with healthy nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   STATUS    ROLES     AGE       VERSION
master.example.com     Ready     master    7h        v1.28.5
node1.example.com      Ready     worker    7h        v1.28.5
node2.example.com      Ready     worker    7h        v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The following example is a cluster with one unhealthy node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   STATUS                      ROLES     AGE       VERSION
master.example.com     Ready                       master    7h        v1.28.5
node1.example.com      NotReady,SchedulingDisabled worker    7h        v1.28.5
node2.example.com      Ready                       worker    7h        v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The conditions that trigger a <literal>NotReady</literal> status are shown later in this section.</simpara>
</listitem>
<listitem>
<simpara>The <literal>-o wide</literal> option provides additional information on nodes.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                STATUS   ROLES    AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE                                                       KERNEL-VERSION                 CONTAINER-RUNTIME
master.example.com  Ready    master   171m   v1.28.5   10.0.129.108   &lt;none&gt;        Red Hat Enterprise Linux CoreOS 48.83.202103210901-0 (Ootpa)   4.18.0-240.15.1.el8_3.x86_64   cri-o://1.28.5-30.rhaos4.10.gitf2f339d.el8-dev
node1.example.com   Ready    worker   72m    v1.28.5   10.0.129.222   &lt;none&gt;        Red Hat Enterprise Linux CoreOS 48.83.202103210901-0 (Ootpa)   4.18.0-240.15.1.el8_3.x86_64   cri-o://1.28.5-30.rhaos4.10.gitf2f339d.el8-dev
node2.example.com   Ready    worker   164m   v1.28.5   10.0.142.150   &lt;none&gt;        Red Hat Enterprise Linux CoreOS 48.83.202103210901-0 (Ootpa)   4.18.0-240.15.1.el8_3.x86_64   cri-o://1.28.5-30.rhaos4.10.gitf2f339d.el8-dev</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The following command lists information about a single node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node &lt;node&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node node1.example.com</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   STATUS    ROLES     AGE       VERSION
node1.example.com      Ready     worker    7h        v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The following command provides more detailed information about a specific node, including the reason for
the current condition:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node &lt;node&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node node1.example.com</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:               node1.example.com <co xml:id="CO123-1"/>
Roles:              worker <co xml:id="CO123-2"/>
Labels:             kubernetes.io/os=linux
                    kubernetes.io/hostname=ip-10-0-131-14
                    kubernetes.io/arch=amd64 <co xml:id="CO123-3"/>
                    node-role.kubernetes.io/worker=
                    node.kubernetes.io/instance-type=m4.large
                    node.openshift.io/os_id=rhcos
                    node.openshift.io/os_version=4.5
                    region=east
                    topology.kubernetes.io/region=us-east-1
                    topology.kubernetes.io/zone=us-east-1a
Annotations:        cluster.k8s.io/machine: openshift-machine-api/ahardin-worker-us-east-2a-q5dzc  <co xml:id="CO123-4"/>
                    machineconfiguration.openshift.io/currentConfig: worker-309c228e8b3a92e2235edd544c62fea8
                    machineconfiguration.openshift.io/desiredConfig: worker-309c228e8b3a92e2235edd544c62fea8
                    machineconfiguration.openshift.io/state: Done
                    volumes.kubernetes.io/controller-managed-attach-detach: true
CreationTimestamp:  Wed, 13 Feb 2019 11:05:57 -0500
Taints:             &lt;none&gt;  <co xml:id="CO123-5"/>
Unschedulable:      false
Conditions:                 <co xml:id="CO123-6"/>
  Type             Status  LastHeartbeatTime                 LastTransitionTime                Reason                       Message
  ----             ------  -----------------                 ------------------                ------                       -------
  OutOfDisk        False   Wed, 13 Feb 2019 15:09:42 -0500   Wed, 13 Feb 2019 11:05:57 -0500   KubeletHasSufficientDisk     kubelet has sufficient disk space available
  MemoryPressure   False   Wed, 13 Feb 2019 15:09:42 -0500   Wed, 13 Feb 2019 11:05:57 -0500   KubeletHasSufficientMemory   kubelet has sufficient memory available
  DiskPressure     False   Wed, 13 Feb 2019 15:09:42 -0500   Wed, 13 Feb 2019 11:05:57 -0500   KubeletHasNoDiskPressure     kubelet has no disk pressure
  PIDPressure      False   Wed, 13 Feb 2019 15:09:42 -0500   Wed, 13 Feb 2019 11:05:57 -0500   KubeletHasSufficientPID      kubelet has sufficient PID available
  Ready            True    Wed, 13 Feb 2019 15:09:42 -0500   Wed, 13 Feb 2019 11:07:09 -0500   KubeletReady                 kubelet is posting ready status
Addresses:   <co xml:id="CO123-7"/>
  InternalIP:   10.0.140.16
  InternalDNS:  ip-10-0-140-16.us-east-2.compute.internal
  Hostname:     ip-10-0-140-16.us-east-2.compute.internal
Capacity:    <co xml:id="CO123-8"/>
 attachable-volumes-aws-ebs:  39
 cpu:                         2
 hugepages-1Gi:               0
 hugepages-2Mi:               0
 memory:                      8172516Ki
 pods:                        250
Allocatable:
 attachable-volumes-aws-ebs:  39
 cpu:                         1500m
 hugepages-1Gi:               0
 hugepages-2Mi:               0
 memory:                      7558116Ki
 pods:                        250
System Info:    <co xml:id="CO123-9"/>
 Machine ID:                              63787c9534c24fde9a0cde35c13f1f66
 System UUID:                             EC22BF97-A006-4A58-6AF8-0A38DEEA122A
 Boot ID:                                 f24ad37d-2594-46b4-8830-7f7555918325
 Kernel Version:                          3.10.0-957.5.1.el7.x86_64
 OS Image:                                Red Hat Enterprise Linux CoreOS 410.8.20190520.0 (Ootpa)
 Operating System:                        linux
 Architecture:                            amd64
 Container Runtime Version:               cri-o://1.28.5-0.6.dev.rhaos4.3.git9ad059b.el8-rc2
 Kubelet Version:                         v1.28.5
 Kube-Proxy Version:                      v1.28.5
PodCIDR:                                  10.128.4.0/24
ProviderID:                               aws:///us-east-2a/i-04e87b31dc6b3e171
Non-terminated Pods:                      (12 in total)  <co xml:id="CO123-10"/>
  Namespace                               Name                                   CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------                               ----                                   ------------  ----------  ---------------  -------------
  openshift-cluster-node-tuning-operator  tuned-hdl5q                            0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-dns                           dns-default-l69zr                      0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-image-registry                node-ca-9hmcg                          0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-ingress                       router-default-76455c45c-c5ptv         0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-machine-config-operator       machine-config-daemon-cvqw9            20m (1%)      0 (0%)      50Mi (0%)        0 (0%)
  openshift-marketplace                   community-operators-f67fh              0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-monitoring                    alertmanager-main-0                    50m (3%)      50m (3%)    210Mi (2%)       10Mi (0%)
  openshift-monitoring                    node-exporter-l7q8d                    10m (0%)      20m (1%)    20Mi (0%)        40Mi (0%)
  openshift-monitoring                    prometheus-adapter-75d769c874-hvb85    0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-multus                        multus-kw8w5                           0 (0%)        0 (0%)      0 (0%)           0 (0%)
  openshift-sdn                           ovs-t4dsn                              100m (6%)     0 (0%)      300Mi (4%)       0 (0%)
  openshift-sdn                           sdn-g79hg                              100m (6%)     0 (0%)      200Mi (2%)       0 (0%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  Resource                    Requests     Limits
  --------                    --------     ------
  cpu                         380m (25%)   270m (18%)
  memory                      880Mi (11%)  250Mi (3%)
  attachable-volumes-aws-ebs  0            0
Events:     <co xml:id="CO123-11"/>
  Type     Reason                   Age                From                      Message
  ----     ------                   ----               ----                      -------
  Normal   NodeHasSufficientPID     6d (x5 over 6d)    kubelet, m01.example.com  Node m01.example.com status is now: NodeHasSufficientPID
  Normal   NodeAllocatableEnforced  6d                 kubelet, m01.example.com  Updated Node Allocatable limit across pods
  Normal   NodeHasSufficientMemory  6d (x6 over 6d)    kubelet, m01.example.com  Node m01.example.com status is now: NodeHasSufficientMemory
  Normal   NodeHasNoDiskPressure    6d (x6 over 6d)    kubelet, m01.example.com  Node m01.example.com status is now: NodeHasNoDiskPressure
  Normal   NodeHasSufficientDisk    6d (x6 over 6d)    kubelet, m01.example.com  Node m01.example.com status is now: NodeHasSufficientDisk
  Normal   NodeHasSufficientPID     6d                 kubelet, m01.example.com  Node m01.example.com status is now: NodeHasSufficientPID
  Normal   Starting                 6d                 kubelet, m01.example.com  Starting kubelet.
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO123-1">
<para>The name of the node.</para>
</callout>
<callout arearefs="CO123-2">
<para>The role of the node, either <literal>master</literal> or <literal>worker</literal>.</para>
</callout>
<callout arearefs="CO123-3">
<para>The labels applied to the node.</para>
</callout>
<callout arearefs="CO123-4">
<para>The annotations applied to the node.</para>
</callout>
<callout arearefs="CO123-5">
<para>The taints applied to the node.</para>
</callout>
<callout arearefs="CO123-6">
<para>The node conditions and status. The <literal>conditions</literal> stanza lists the <literal>Ready</literal>, <literal>PIDPressure</literal>, <literal>PIDPressure</literal>, <literal>MemoryPressure</literal>, <literal>DiskPressure</literal> and <literal>OutOfDisk</literal> status. These condition are described later in this section.</para>
</callout>
<callout arearefs="CO123-7">
<para>The IP address and hostname of the node.</para>
</callout>
<callout arearefs="CO123-8">
<para>The pod resources and allocatable resources.</para>
</callout>
<callout arearefs="CO123-9">
<para>Information about the node host.</para>
</callout>
<callout arearefs="CO123-10">
<para>The pods on the node.</para>
</callout>
<callout arearefs="CO123-11">
<para>The events reported by the node.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<simpara>Among the information shown for nodes, the following node conditions appear in the output of the commands shown in this section:</simpara>
<table xml:id="machine-health-checks-resource-conditions" frame="all" rowsep="1" colsep="1">
<title>Node Conditions</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Condition</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Ready</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, the node is healthy and ready to accept pods. If <literal>false</literal>, the node is not healthy and is not accepting pods. If <literal>unknown</literal>, the node controller has not received a heartbeat from the node for the <literal>node-monitor-grace-period</literal> (the default is 40 seconds).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DiskPressure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, the disk capacity is low.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MemoryPressure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, the node memory is low.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PIDPressure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, there are too many processes on the node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OutOfDisk</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, the node has insufficient free space on the node for adding new pods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NetworkUnavailable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, the network for the node is not correctly configured.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NotReady</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, one of the underlying components, such as the container runtime or network, is experiencing issues or is not yet configured.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SchedulingDisabled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pods cannot be scheduled for placement on the node.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="nodes-nodes-viewing-listing-pods_nodes-nodes-viewing">
<title>Listing pods on a node in your cluster</title>
<simpara>You can list all the pods on a specific node.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To list all or selected pods on one or more nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node &lt;node1&gt; &lt;node2&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node ip-10-0-128-218.ec2.internal</programlisting>
</listitem>
<listitem>
<simpara>To list all or selected pods on selected nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe --selector=&lt;node_selector&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node  --selector=kubernetes.io/os</programlisting>
<simpara>Or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe -l=&lt;pod_selector&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe node -l node-role.kubernetes.io/worker</programlisting>
</listitem>
<listitem>
<simpara>To list all pods on a specific node, including terminated pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod --all-namespaces --field-selector=spec.nodeName=&lt;nodename&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-nodes-viewing-memory_nodes-nodes-viewing">
<title>Viewing memory and CPU usage statistics on your nodes</title>
<simpara>You can display usage statistics about nodes, which provide the runtime
environments for containers. These usage statistics include CPU, memory, and
storage consumption.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have <literal>cluster-reader</literal> permission to view the usage statistics.</simpara>
</listitem>
<listitem>
<simpara>Metrics must be installed to view the usage statistics.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To view the usage statistics:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                   CPU(cores)   CPU%      MEMORY(bytes)   MEMORY%
ip-10-0-12-143.ec2.compute.internal    1503m        100%      4533Mi          61%
ip-10-0-132-16.ec2.compute.internal    76m          5%        1391Mi          18%
ip-10-0-140-137.ec2.compute.internal   398m         26%       2473Mi          33%
ip-10-0-142-44.ec2.compute.internal    656m         43%       6119Mi          82%
ip-10-0-146-165.ec2.compute.internal   188m         12%       3367Mi          45%
ip-10-0-19-62.ec2.compute.internal     896m         59%       5754Mi          77%
ip-10-0-44-193.ec2.compute.internal    632m         42%       5349Mi          72%</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view the usage statistics for nodes with labels:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm top node --selector=''</programlisting>
<simpara>You must choose the selector (label query) to filter on. Supports <literal>=</literal>, <literal>==</literal>, and <literal>!=</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-nodes-working">
<title>Working with nodes</title>

<simpara>As an administrator, you can perform several tasks to make your clusters more efficient.</simpara>
<section xml:id="nodes-nodes-working-evacuating_nodes-nodes-working">
<title>Understanding how to evacuate pods on nodes</title>
<simpara>Evacuating pods allows you to migrate all or selected pods from a given node or
nodes.</simpara>
<simpara>You can only evacuate pods backed by a replication controller. The replication controller creates new pods on
other nodes and removes the existing pods from the specified node(s).</simpara>
<simpara>Bare pods, meaning those not backed by a replication controller, are unaffected by default.
You can evacuate a subset of pods by specifying a pod-selector. Pod selectors are
based on labels, so all the pods with the specified label will be evacuated.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Mark the nodes unschedulable before performing the pod evacuation.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Mark the node as unschedulable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;node1&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/&lt;node1&gt; cordoned</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the node status is <literal>Ready,SchedulingDisabled</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node &lt;node1&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        STATUS                     ROLES     AGE       VERSION
&lt;node1&gt;     Ready,SchedulingDisabled   worker    1d        v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Evacuate the pods using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Evacuate all or selected pods on one or more nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; [--pod-selector=&lt;pod_selector&gt;]</programlisting>
</listitem>
<listitem>
<simpara>Force the deletion of bare pods using the <literal>--force</literal> option. When set to
<literal>true</literal>, deletion continues even if there are pods not managed by a replication
controller, replica set, job, daemon set, or stateful set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; --force=true</programlisting>
</listitem>
<listitem>
<simpara>Set a period  of time in seconds for each pod to
terminate gracefully, use <literal>--grace-period</literal>. If negative, the default value specified in the pod will
be used:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; --grace-period=-1</programlisting>
</listitem>
<listitem>
<simpara>Ignore pods managed by daemon sets using the <literal>--ignore-daemonsets</literal> flag set to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; --ignore-daemonsets=true</programlisting>
</listitem>
<listitem>
<simpara>Set the length of time to wait before giving up using the <literal>--timeout</literal> flag. A
value of <literal>0</literal> sets an infinite length of time:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; --timeout=5s</programlisting>
</listitem>
<listitem>
<simpara>Delete pods even if there are pods using <literal>emptyDir</literal> volumes by setting the <literal>--delete-emptydir-data</literal> flag to <literal>true</literal>. Local data is deleted when the node
is drained:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt; --delete-emptydir-data=true</programlisting>
</listitem>
<listitem>
<simpara>List objects that will be migrated without actually performing the evacuation,
using the <literal>--dry-run</literal> option set to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; &lt;node2&gt;  --dry-run=true</programlisting>
<simpara>Instead of specifying specific node names (for example, <literal>&lt;node1&gt; &lt;node2&gt;</literal>), you
can use the <literal>--selector=&lt;node_selector&gt;</literal> option to evacuate pods on selected
nodes.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Mark the node as schedulable when done.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm uncordon &lt;node1&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-nodes-working-updating_nodes-nodes-working">
<title>Understanding how to update labels on nodes</title>
<simpara>You can update any label on a node.</simpara>
<simpara>Node labels are not persisted after a node is deleted even if the node is backed up by a Machine.</simpara>
<note>
<simpara>Any change to a <literal>MachineSet</literal> object is not applied to existing machines owned by the compute machine set.
For example, labels edited or added to an existing <literal>MachineSet</literal> object are not propagated to existing machines and nodes
associated with the compute machine set.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>The following command adds or updates labels on a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node&gt; &lt;key_1&gt;=&lt;value_1&gt; ... &lt;key_n&gt;=&lt;value_n&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label nodes webconsole-7f7f6 unhealthy=true</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to apply the label:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  name: webconsole-7f7f6
  labels:
    unhealthy: 'true'
#...</programlisting>
</tip>
</listitem>
<listitem>
<simpara>The following command updates all pods in the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label pods --all &lt;key_1&gt;=&lt;value_1&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label pods --all status=unhealthy</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-nodes-working-marking_nodes-nodes-working">
<title>Understanding how to mark nodes as unschedulable or schedulable</title>
<simpara>By default, healthy nodes with a <literal>Ready</literal> status are
marked as schedulable, which means that you can place new pods on the
node. Manually marking a node as unschedulable blocks any new pods from being
scheduled on the node. Existing pods on the node are not affected.</simpara>
<itemizedlist>
<listitem>
<simpara>The following command marks a node or nodes as unschedulable:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;node&gt;</programlisting>
</para>
</formalpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon node1.example.com</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/node1.example.com cordoned

NAME                 LABELS                                        STATUS
node1.example.com    kubernetes.io/hostname=node1.example.com      Ready,SchedulingDisabled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The following command marks a currently unschedulable node or nodes as schedulable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm uncordon &lt;node1&gt;</programlisting>
<simpara>Alternatively, instead of specifying specific node names (for example, <literal>&lt;node&gt;</literal>), you can use the <literal>--selector=&lt;node_selector&gt;</literal> option to mark selected
nodes as schedulable or unschedulable.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="sno-clusters-reboot-without-drain_nodes-nodes-working">
<title>Handling errors in single-node OpenShift clusters when the node reboots without draining application pods</title>
<simpara>In single-node OpenShift clusters and in {product-title} clusters in general, a situation can arise where a node reboot occurs without first draining the node. This can occur where an application pod requesting devices fails with the <literal>UnexpectedAdmissionError</literal> error. <literal>Deployment</literal>, <literal>ReplicaSet</literal>, or <literal>DaemonSet</literal> errors are reported because the application pods that require those devices start before the pod serving those devices. You cannot control the order of pod restarts.</simpara>
<simpara>While this behavior is to be expected, it can cause a pod to remain on the cluster even though it has failed to deploy successfully. The pod continues to report <literal>UnexpectedAdmissionError</literal>. This issue is mitigated by the fact that application pods are typically included in a <literal>Deployment</literal>, <literal>ReplicaSet</literal>, or <literal>DaemonSet</literal>. If a pod is in this error state, it is of little concern because another instance should be running. Belonging to a <literal>Deployment</literal>, <literal>ReplicaSet</literal>, or <literal>DaemonSet</literal> guarantees the successful creation and execution of subsequent pods and ensures the successful deployment of the application.</simpara>
<simpara>There is ongoing work upstream to ensure that such pods are gracefully terminated. Until that work is resolved, run the following command for a single-node OpenShift cluster to remove the failed pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pods --field-selector status.phase=Failed -n <emphasis>&lt;POD_NAMESPACE&gt;</emphasis></programlisting>
<note>
<simpara>The option to drain the node is unavailable for single-node OpenShift clusters.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-evacuating_nodes-nodes-working">Understanding how to evacuate pods on nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_deleting_nodes">
<title>Deleting nodes</title>
<section xml:id="nodes-nodes-working-deleting_nodes-nodes-working">
<title>Deleting nodes from a cluster</title>
<simpara>To delete a node from the {product-title} cluster, scale down the appropriate <literal>MachineSet</literal> object.</simpara>
<important>
<simpara>When a cluster is integrated with a cloud provider, you must delete the corresponding machine to delete a node. Do not try to use the <literal>oc delete node</literal> command for this task.</simpara>
</important>
<simpara>When you delete a node by using the CLI, the node object is deleted in Kubernetes, but the pods that exist on the node are not deleted. Any bare pods that are not backed by a replication controller become inaccessible to {product-title}. Pods backed by replication controllers are rescheduled to other available nodes. You must delete local manifest pods.</simpara>
<note>
<simpara>If you are running cluster on bare metal, you cannot delete a node by editing <literal>MachineSet</literal> objects. Compute machine sets are only available when a cluster is integrated with a cloud provider. Instead you must unschedule and drain the node before manually deleting it.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the compute machine sets that are in the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinesets -n openshift-machine-api</programlisting>
<simpara>The compute machine sets are listed in the form of <literal>&lt;cluster-id&gt;-worker-&lt;aws-region-az&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>Scale down the compute machine set by using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify the number of replicas to scale down to by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc scale --replicas=2 machineset &lt;machine-set-name&gt; -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>Edit the compute machine set custom resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine-set-name&gt; -n openshift-machine-api</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
metadata:
  # ...
  name: &lt;machine-set-name&gt;
  namespace: openshift-machine-api
  # ...
spec:
  replicas: 2 <co xml:id="CO124-1"/>
  # ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO124-1">
<para>Specify the number of replicas to scale down to.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../machine_management/manually-scaling-machineset.xml#machineset-manually-scaling-manually-scaling-machineset">Manually scaling a compute machine set</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-nodes-working-deleting-bare-metal_nodes-nodes-working">
<title>Deleting nodes from a bare metal cluster</title>
<simpara>When you delete a node using the CLI, the node object is deleted in Kubernetes,
but the pods that exist on the node are not deleted. Any bare pods not backed by
a replication controller become inaccessible to {product-title}. Pods backed by
replication controllers are rescheduled to other available nodes. You must
delete local manifest pods.</simpara>
<formalpara>
<title>Procedure</title>
<para>Delete a node from an {product-title} cluster running on bare metal by completing
the following steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mark the node as unschedulable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Drain all pods on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node_name&gt; --force=true</programlisting>
<simpara>This step might fail if the node is offline or unresponsive. Even if the node does not respond, it might still be running a workload that writes to shared storage. To avoid data corruption, power down the physical hardware before you proceed.</simpara>
</listitem>
<listitem>
<simpara>Delete the node from the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete node &lt;node_name&gt;</programlisting>
<simpara>Although the node object is now deleted from the cluster, it can still rejoin
the cluster after reboot or if the kubelet service is restarted. To permanently
delete the node and all its data, you must
<link xl:href="https://access.redhat.com/solutions/84663">decommission the node</link>.</simpara>
</listitem>
<listitem>
<simpara>If you powered down the physical hardware, turn it back on so that the node can rejoin the cluster.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="nodes-nodes-managing">
<title>Managing nodes</title>

<simpara>{product-title} uses a KubeletConfig custom resource (CR) to manage the
configuration of nodes. By creating an instance of a <literal>KubeletConfig</literal> object, a managed machine config is created to override setting on the node.</simpara>
<note>
<simpara><emphasis role="strong">Logging in to  remote machines for the purpose of changing their configuration is not supported.</emphasis></simpara>
</note>
<section xml:id="nodes-nodes-managing-about_nodes-nodes-managing">
<title>Modifying nodes</title>
<simpara>To make configuration changes to a cluster, or machine pool, you must create a custom resource definition (CRD), or <literal>kubeletConfig</literal> object. {product-title} uses the Machine Config Controller to watch for changes introduced through the CRD to apply the changes to the cluster.</simpara>
<note>
<simpara>Because the fields in a <literal>kubeletConfig</literal> object are passed directly to the kubelet from upstream Kubernetes, the validation of those fields is handled directly by the kubelet itself. Please refer to the relevant Kubernetes documentation for the valid values for these fields. Invalid values in the <literal>kubeletConfig</literal> object can render cluster nodes unusable.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Obtain the label associated with the static CRD, Machine Config Pool, for the type of node you want to configure.
Perform one of the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check current labels of the desired machine config pool.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc get machineconfigpool  --show-labels</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      CONFIG                                             UPDATED   UPDATING   DEGRADED   LABELS
master    rendered-master-e05b81f5ca4db1d249a1bf32f9ec24fd   True      False      False      operator.machineconfiguration.openshift.io/required-for-upgrade=
worker    rendered-worker-f50e78e1bc06d8e82327763145bfcf62   True      False      False</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add a custom label to the desired machine config pool.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label machineconfigpool worker custom-kubelet=enabled</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>kubeletconfig</literal> custom resource (CR) for your configuration change.</simpara>
<simpara>For example:</simpara>
<formalpara>
<title>Sample configuration for a <emphasis role="strong">custom-config</emphasis> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: custom-config <co xml:id="CO125-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
      custom-kubelet: enabled <co xml:id="CO125-2"/>
  kubeletConfig: <co xml:id="CO125-3"/>
    podsPerCore: 10
    maxPods: 250
    systemReserved:
      cpu: 2000m
      memory: 1Gi
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO125-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO125-2">
<para>Specify the label to apply the configuration change, this is the label you added to the machine config pool.</para>
</callout>
<callout arearefs="CO125-3">
<para>Specify the new value(s) you want to change.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the CR object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f master-kube-config.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>Most <link xl:href="https://kubernetes.io/docs/reference/config-api/kubelet-config.v1beta1/">Kubelet Configuration options</link> can be set by the user. The following options are not allowed to be overwritten:</simpara>
<itemizedlist>
<listitem>
<simpara>CgroupDriver</simpara>
</listitem>
<listitem>
<simpara>ClusterDNS</simpara>
</listitem>
<listitem>
<simpara>ClusterDomain</simpara>
</listitem>
<listitem>
<simpara>StaticPodPath</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If a single node contains more than 50 images, pod scheduling might be imbalanced across nodes. This is because the list of images on a node is shortened to 50 by default. You can disable the image limit by editing the <literal>KubeletConfig</literal> object and setting the value of <literal>nodeStatusMaxImages</literal> to <literal>-1</literal>.</simpara>
</note>
</section>
<section xml:id="nodes-nodes-working-master-schedulable_nodes-nodes-managing">
<title>Configuring control plane nodes as schedulable</title>
<simpara>You can configure control plane nodes to be
schedulable, meaning that new pods are allowed for placement on the master
nodes. By default, control plane nodes are not schedulable.</simpara>
<simpara>You can set the masters to be schedulable, but must retain the worker nodes.</simpara>
<note>
<simpara>You can deploy {product-title} with no worker nodes on a bare metal cluster.
In this case, the control plane nodes are marked schedulable by default.</simpara>
</note>
<simpara>You can allow or disallow control plane nodes to be schedulable by configuring the <literal>mastersSchedulable</literal> field.</simpara>
<important>
<simpara>When you configure control plane nodes from the default unschedulable to schedulable, additional subscriptions are required. This is because control plane nodes then become worker nodes.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>schedulers.config.openshift.io</literal> resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit schedulers.config.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Configure the <literal>mastersSchedulable</literal> field.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  creationTimestamp: "2019-09-10T03:04:05Z"
  generation: 1
  name: cluster
  resourceVersion: "433"
  selfLink: /apis/config.openshift.io/v1/schedulers/cluster
  uid: a636d30a-d377-11e9-88d4-0a60097bee62
spec:
  mastersSchedulable: false <co xml:id="CO126-1"/>
status: {}
#...</programlisting>
<calloutlist>
<callout arearefs="CO126-1">
<para>Set to <literal>true</literal> to allow control plane nodes to be schedulable, or <literal>false</literal> to
disallow control plane nodes to be schedulable.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-nodes-working-setting-booleans_nodes-nodes-managing">
<title>Setting SELinux booleans</title>
<simpara>{product-title} allows you to enable and disable an SELinux boolean on a Red Hat Enterprise Linux CoreOS (RHCOS) node. The following procedure explains how to modify SELinux booleans on nodes using the Machine Config Operator (MCO). This procedure uses <literal>container_manage_cgroup</literal> as the example boolean. You can modify this value to whichever boolean you need.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (oc).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new YAML file with a <literal>MachineConfig</literal> object, displayed in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 99-worker-setsebool
spec:
  config:
    ignition:
      version: 3.2.0
    systemd:
      units:
      - contents: |
          [Unit]
          Description=Set SELinux booleans
          Before=kubelet.service

          [Service]
          Type=oneshot
          ExecStart=/sbin/setsebool container_manage_cgroup=on
          RemainAfterExit=true

          [Install]
          WantedBy=multi-user.target graphical.target
        enabled: true
        name: setsebool.service
#...</programlisting>
</listitem>
<listitem>
<simpara>Create the new <literal>MachineConfig</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f 99-worker-setsebool.yaml</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>Applying any changes to the <literal>MachineConfig</literal> object causes all affected nodes to gracefully reboot after the change is applied.</simpara>
</note>
</section>
<section xml:id="nodes-nodes-kernel-arguments_nodes-nodes-managing">
<title>Adding kernel arguments to nodes</title>
<simpara>In some special cases, you might want to add kernel arguments to a set of nodes in your cluster. This should only be done with caution and clear understanding of the implications of the arguments you set.</simpara>
<warning>
<simpara>Improper use of kernel arguments can result in your systems becoming unbootable.</simpara>
</warning>
<simpara>Examples of kernel arguments you could set include:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">nosmt</emphasis>: Disables symmetric multithreading (SMT) in the kernel. Multithreading allows multiple logical threads for each CPU. You could consider <literal>nosmt</literal> in multi-tenant environments to reduce risks from potential cross-thread attacks. By disabling SMT, you essentially choose security over performance.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">systemd.unified_cgroup_hierarchy</emphasis>: Enables <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Linux control group version 2</link> (cgroup v2). cgroup v2 is the next version of the kernel <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch01">control group</link> and offers multiple improvements.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">enforcing=0</emphasis>: Configures Security Enhanced Linux (SELinux) to run in permissive mode. In permissive mode, the system acts as if SELinux is enforcing the loaded security policy, including labeling objects and emitting access denial entries in the logs, but it does not actually deny any operations. While not supported for production systems, permissive mode can be helpful for debugging.</simpara>
<warning>
<simpara>Disabling SELinux on RHCOS in production is not supported.
Once SELinux has been disabled on a node, it must be re-provisioned before re-inclusion in a production cluster.</simpara>
</warning>
</listitem>
</itemizedlist>
<simpara>See <link xl:href="https://www.kernel.org/doc/Documentation/admin-guide/kernel-parameters.txt">Kernel.org kernel parameters</link> for a list and descriptions of kernel arguments.</simpara>
<simpara>In the following procedure, you create a <literal>MachineConfig</literal> object that identifies:</simpara>
<itemizedlist>
<listitem>
<simpara>A set of machines to which you want to add the kernel argument. In this case, machines with a worker role.</simpara>
</listitem>
<listitem>
<simpara>Kernel arguments that are appended to the end of the existing kernel arguments.</simpara>
</listitem>
<listitem>
<simpara>A label that indicates where in the list of machine configs the change is applied.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have administrative privilege to a working {product-title} cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List existing <literal>MachineConfig</literal> objects for your {product-title} cluster to determine how to
label your machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MachineConfig</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               GENERATEDBYCONTROLLER                      IGNITIONVERSION   AGE
00-master                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
00-worker                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-master-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-master-ssh                                                                                 3.2.0             40m
99-worker-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-worker-ssh                                                                                 3.2.0             40m
rendered-master-23e785de7587df95a4b517e0647e5ab7   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
rendered-worker-5d596d9293ca3ea80c896a1191735bb1   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a <literal>MachineConfig</literal> object file that identifies the kernel argument (for example, <literal>05-worker-kernelarg-selinuxpermissive.yaml</literal>)</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker<co xml:id="CO127-1"/>
  name: 05-worker-kernelarg-selinuxpermissive<co xml:id="CO127-2"/>
spec:
  kernelArguments:
    - enforcing=0<co xml:id="CO127-3"/></programlisting>
<calloutlist>
<callout arearefs="CO127-1">
<para>Applies the new kernel argument only to worker nodes.</para>
</callout>
<callout arearefs="CO127-2">
<para>Named to identify where it fits among the machine configs (05) and what it does (adds
a kernel argument to configure SELinux permissive mode).</para>
</callout>
<callout arearefs="CO127-3">
<para>Identifies the exact kernel argument as <literal>enforcing=0</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the new machine config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f 05-worker-kernelarg-selinuxpermissive.yaml</programlisting>
</listitem>
<listitem>
<simpara>Check the machine configs to see that the new one was added:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get MachineConfig</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               GENERATEDBYCONTROLLER                      IGNITIONVERSION   AGE
00-master                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
00-worker                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
05-worker-kernelarg-selinuxpermissive                                                         3.2.0             105s
99-master-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-master-ssh                                                                                 3.2.0             40m
99-worker-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-worker-ssh                                                                                 3.2.0             40m
rendered-master-23e785de7587df95a4b517e0647e5ab7   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
rendered-worker-5d596d9293ca3ea80c896a1191735bb1   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS                     ROLES    AGE   VERSION
ip-10-0-136-161.ec2.internal   Ready                      worker   28m   v1.28.5
ip-10-0-136-243.ec2.internal   Ready                      master   34m   v1.28.5
ip-10-0-141-105.ec2.internal   Ready,SchedulingDisabled   worker   28m   v1.28.5
ip-10-0-142-249.ec2.internal   Ready                      master   34m   v1.28.5
ip-10-0-153-11.ec2.internal    Ready                      worker   28m   v1.28.5
ip-10-0-153-150.ec2.internal   Ready                      master   34m   v1.28.5</programlisting>
</para>
</formalpara>
<simpara>You can see that scheduling on each worker node is disabled as the change is being applied.</simpara>
</listitem>
<listitem>
<simpara>Check that the kernel argument worked by going to one of the worker nodes and listing
the kernel command line arguments (in <literal>/proc/cmdline</literal> on the host):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/ip-10-0-141-105.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/ip-10-0-141-105ec2internal-debug ...
To use host binaries, run `chroot /host`

sh-4.2# cat /host/proc/cmdline
BOOT_IMAGE=/ostree/rhcos-... console=tty0 console=ttyS0,115200n8
rootflags=defaults,prjquota rw root=UUID=fd0... ostree=/ostree/boot.0/rhcos/16...
coreos.oem.id=qemu coreos.oem.id=ec2 ignition.platform.id=ec2 enforcing=0

sh-4.2# exit</programlisting>
</para>
</formalpara>
<simpara>You should see the <literal>enforcing=0</literal> argument added to the other kernel arguments.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-nodes-swap-memory_nodes-nodes-managing">
<title>Enabling swap memory use on nodes</title>
<important>
<simpara>Enabling swap memory use on nodes is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>You can enable swap memory use for {product-title} workloads on a per-node basis.</simpara>
<warning>
<simpara>Enabling swap memory can negatively impact workload performance and out-of-resource handling. Do not enable swap memory on control plane nodes.</simpara>
</warning>
<simpara>To enable swap memory, create a <literal>kubeletconfig</literal> custom resource (CR) to set the <literal>swapbehavior</literal> parameter. You can set limited or unlimited swap memory:</simpara>
<itemizedlist>
<listitem>
<simpara>Limited: Use the <literal>LimitedSwap</literal> value to limit how much swap memory workloads can use. Any workloads on the node that are not managed by {product-title} can still use swap memory. The <literal>LimitedSwap</literal> behavior depends on whether the node is running with Linux control groups <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/index.html">version 1 (cgroups v1)</link> or <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">version 2 (cgroup v2)</link>:</simpara>
<itemizedlist>
<listitem>
<simpara>cgroup v1: {product-title} workloads can use any combination of memory and swap, up to the pod&#8217;s memory limit, if set.</simpara>
</listitem>
<listitem>
<simpara>cgroup v2: {product-title} workloads cannot use swap memory.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Unlimited: Use the <literal>UnlimitedSwap</literal> value to allow workloads to use as much swap memory as they request, up to the system limit.</simpara>
</listitem>
</itemizedlist>
<simpara>Because the kubelet will not start in the presence of swap memory without this configuration, you must enable swap memory in {product-title} before enabling swap memory on the nodes. If there is no swap memory present on a node, enabling swap memory in {product-title} has no effect.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a running {product-title} cluster that uses version 4.10 or later.</simpara>
</listitem>
<listitem>
<simpara>You are logged in to the cluster as a user with administrative privileges.</simpara>
</listitem>
<listitem>
<simpara>You have enabled the <literal>TechPreviewNoUpgrade</literal> feature set on the cluster (see <emphasis>Nodes &#8594; Working with clusters &#8594; Enabling features using feature gates</emphasis>).</simpara>
<note>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set cannot be undone and prevents minor version updates. These feature sets are not recommended on production clusters.</simpara>
</note>
</listitem>
<listitem>
<simpara>If cgroup v2 is enabled on a node, you must enable swap accounting on the node, by setting the <literal>swapaccount=1</literal> kernel argument.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply a custom label to the machine config pool where you want to allow swap memory.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label machineconfigpool worker kubelet-swap=enabled</programlisting>
</listitem>
<listitem>
<simpara>Create a custom resource (CR) to enable and configure swap settings.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: swap-config
spec:
  machineConfigPoolSelector:
    matchLabels:
      kubelet-swap: enabled
  kubeletConfig:
    failSwapOn: false <co xml:id="CO128-1"/>
    memorySwap:
      swapBehavior: LimitedSwap <co xml:id="CO128-2"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO128-1">
<para>Set to <literal>false</literal> to enable swap memory use on the associated nodes. Set to <literal>true</literal> to disable swap memory use.</para>
</callout>
<callout arearefs="CO128-2">
<para>Specify the swap memory behavior. If unspecified, the default is <literal>LimitedSwap</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enable swap memory on the machines.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-control-plane-osp-migrating_nodes-nodes-managing">
<title>Migrating control plane nodes from one RHOSP host to another manually</title>
<simpara>If control plane machine sets are not enabled on your cluster, you can run a script that moves a control plane node from one Red Hat OpenStack Platform (RHOSP) node to another.</simpara>
<note>
<simpara>Control plane machine sets are not enabled on clusters that run on user-provisioned infrastructure.</simpara>
<simpara>For information about control plane machine sets, see "Managing control plane machines with control plane machine sets".</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The environment variable <literal>OS_CLOUD</literal> refers to a <literal>clouds</literal> entry that has administrative credentials in a <literal>clouds.yaml</literal> file.</simpara>
</listitem>
<listitem>
<simpara>The environment variable <literal>KUBECONFIG</literal> refers to a configuration that contains administrative {product-title} credentials.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>From a command line, run the following script:</simpara>
</listitem>
</itemizedlist>
<programlisting language="bash" linenumbering="unnumbered">#!/usr/bin/env bash

set -Eeuo pipefail

if [ $# -lt 1 ]; then
	echo "Usage: '$0 node_name'"
	exit 64
fi

# Check for admin OpenStack credentials
openstack server list --all-projects &gt;/dev/null || { &gt;&amp;2 echo "The script needs OpenStack admin credentials. Exiting"; exit 77; }

# Check for admin OpenShift credentials
oc adm top node &gt;/dev/null || { &gt;&amp;2 echo "The script needs OpenShift admin credentials. Exiting"; exit 77; }

set -x

declare -r node_name="$1"
declare server_id
server_id="$(openstack server list --all-projects -f value -c ID -c Name | grep "$node_name" | cut -d' ' -f1)"
readonly server_id

# Drain the node
oc adm cordon "$node_name"
oc adm drain "$node_name" --delete-emptydir-data --ignore-daemonsets --force

# Power off the server
oc debug "node/${node_name}" -- chroot /host shutdown -h 1

# Verify the server is shut off
until openstack server show "$server_id" -f value -c status | grep -q 'SHUTOFF'; do sleep 5; done

# Migrate the node
openstack server migrate --wait "$server_id"

# Resize the VM
openstack server resize confirm "$server_id"

# Wait for the resize confirm to finish
until openstack server show "$server_id" -f value -c status | grep -q 'SHUTOFF'; do sleep 5; done

# Restart the VM
openstack server start "$server_id"

# Wait for the node to show up as Ready:
until oc get node "$node_name" | grep -q "^${node_name}[[:space:]]\+Ready"; do sleep 5; done

# Uncordon the node
oc adm uncordon "$node_name"

# Wait for cluster operators to stabilize
until oc get co -o go-template='statuses: {{ range .items }}{{ range .status.conditions }}{{ if eq .type "Degraded" }}{{ if ne .status "False" }}DEGRADED{{ end }}{{ else if eq .type "Progressing"}}{{ if ne .status "False" }}PROGRESSING{{ end }}{{ else if eq .type "Available"}}{{ if ne .status "True" }}NOTAVAILABLE{{ end }}{{ end }}{{ end }}{{ end }}' | grep -qv '\(DEGRADED\|PROGRESSING\|NOTAVAILABLE\)'; do sleep 5; done</programlisting>
<simpara>If the script completes, the control plane machine is migrated to a new RHOSP node.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about control plane machine sets, see <link xl:href="../../machine_management/control_plane_machine_management/cpmso-using.xml#cpmso-using">Managing control plane machines with control plane machine sets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-nodes-managing-max-pods">
<title>Managing the maximum number of pods per node</title>

<simpara>In {product-title}, you can configure the number of pods that can run on a node based on the number of
processor cores on the node, a hard limit or both. If you use both options,
the lower of the two limits the number of pods on a node.</simpara>
<simpara>Exceeding these values can result in:</simpara>
<itemizedlist>
<listitem>
<simpara>Increased CPU utilization by {product-title}.</simpara>
</listitem>
<listitem>
<simpara>Slow pod scheduling.</simpara>
</listitem>
<listitem>
<simpara>Potential out-of-memory scenarios, depending on the amount of memory in the node.</simpara>
</listitem>
<listitem>
<simpara>Exhausting the IP address pool.</simpara>
</listitem>
<listitem>
<simpara>Resource overcommitting, leading to poor user application performance.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>A pod that is holding a single container actually uses two
containers. The second container sets up networking prior to the
actual container starting. As a result, a node running 10 pods actually
has 20 containers running.</simpara>
</note>
<simpara>The <literal>podsPerCore</literal> parameter limits the number of pods the node can run based on the number of
processor cores on the node. For example, if <literal>podsPerCore</literal> is set to <literal>10</literal> on
a node with 4 processor cores, the maximum number of pods allowed on the node is 40.</simpara>
<simpara>The <literal>maxPods</literal> parameter limits the number of pods the node can run to a fixed value, regardless
of the properties of the node.</simpara>
<section xml:id="nodes-nodes-managing-max-pods-proc_nodes-nodes-managing-max-pods">
<title>Configuring the maximum number of pods per node</title>
<simpara>Two parameters control the maximum number of pods that can be scheduled to a node: <literal>podsPerCore</literal> and <literal>maxPods</literal>. If you use both options, the lower of the two limits the number of pods on a node.</simpara>
<simpara>For example, if <literal>podsPerCore</literal> is set to <literal>10</literal> on a node with 4 processor cores, the maximum number of pods allowed on the node will be 40.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> CRD for the type of node you want to configure by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  creationTimestamp: "2022-11-16T15:34:25Z"
  generation: 4
  labels:
    pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO129-1"/>
  name: worker
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO129-1">
<para>The label appears under Labels.</para>
</callout>
</calloutlist>
<tip>
<simpara>If the label is not present, add a key/value pair such as:</simpara>
<screen>$ oc label machineconfigpool worker custom-kubelet=small-pods</screen>
</tip>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change.</simpara>
<formalpara>
<title>Sample configuration for a <literal>max-pods</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: set-max-pods <co xml:id="CO130-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO130-2"/>
  kubeletConfig:
    podsPerCore: 10 <co xml:id="CO130-3"/>
    maxPods: 250 <co xml:id="CO130-4"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO130-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO130-2">
<para>Specify the label from the machine config pool.</para>
</callout>
<callout arearefs="CO130-3">
<para>Specify the number of pods the node can run based on the number of processor cores on the node.</para>
</callout>
<callout arearefs="CO130-4">
<para>Specify the number of pods the node can run to a fixed value, regardless of the properties of the node.</para>
</callout>
</calloutlist>
<note>
<simpara>Setting <literal>podsPerCore</literal> to <literal>0</literal> disables this limit.</simpara>
</note>
<simpara>In the above example, the default value for <literal>podsPerCore</literal> is <literal>10</literal> and the default value for <literal>maxPods</literal> is <literal>250</literal>. This means that unless the node has 25 cores or more, by default, <literal>podsPerCore</literal> will be the limiting factor.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>List the <literal>MachineConfigPool</literal> CRDs to see if the change is applied. The <literal>UPDATING</literal> column reports <literal>True</literal> if the change is picked up by the Machine Config Controller:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpools</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                        UPDATED   UPDATING   DEGRADED
master   master-9cc2c72f205e103bb534   False     False      False
worker   worker-8cecd1236b33ee3f8a5e   False     True       False</programlisting>
</para>
</formalpara>
<simpara>Once the change is complete, the <literal>UPDATED</literal> column reports <literal>True</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpools</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                        UPDATED   UPDATING   DEGRADED
master   master-9cc2c72f205e103bb534   False     True       False
worker   worker-8cecd1236b33ee3f8a5e   True      False      False</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-node-tuning-operator">
<title>Using the Node Tuning Operator</title>

<simpara>Learn about the Node Tuning Operator and how you can use it to manage node-level
tuning by orchestrating the tuned daemon.</simpara>
<bridgehead xml:id="about-node-tuning-operator_nodes-node-tuning-operator" renderas="sect4">Purpose</bridgehead>
<simpara>The Node Tuning Operator helps you manage node-level tuning by orchestrating the TuneD daemon and achieves low latency performance by using the Performance Profile controller. The majority of high-performance applications require some level of kernel tuning. The Node Tuning Operator provides a unified management interface to users of node-level sysctls and more flexibility to add custom tuning specified by user needs.</simpara>
<simpara>The Operator manages the containerized TuneD daemon for {product-title} as a Kubernetes daemon set. It ensures the custom tuning specification is passed to all containerized TuneD daemons running in the cluster in the format that the daemons understand. The daemons run on all nodes in the cluster, one per node.</simpara>
<simpara>Node-level settings applied by the containerized TuneD daemon are rolled back on an event that triggers a profile change or when the containerized TuneD daemon is terminated gracefully by receiving and handling a termination signal.</simpara>
<simpara>The Node Tuning Operator uses the Performance Profile controller to implement automatic tuning to achieve low latency performance for {product-title} applications.</simpara>
<simpara>The cluster administrator configures a performance profile to define node-level settings such as the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Updating the kernel to kernel-rt.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for housekeeping.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for running workloads.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<simpara>The Node Tuning Operator is part of a standard {product-title} installation in version 4.1 and later.</simpara>
<note>
<simpara>In earlier versions of {product-title}, the Performance Addon Operator was used to implement automatic tuning to achieve low latency performance for OpenShift applications. In {product-title} 4.11 and later, this functionality is part of the Node Tuning Operator.</simpara>
</note>
<section xml:id="accessing-an-example-node-tuning-operator-specification_nodes-node-tuning-operator">
<title>Accessing an example Node Tuning Operator specification</title>
<simpara>Use this process to access an example Node Tuning Operator specification.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to access an example Node Tuning Operator specification:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get tuned.tuned.openshift.io/default -o yaml -n openshift-cluster-node-tuning-operator</programlisting>
</listitem>
</itemizedlist>
<simpara>The default CR is meant for delivering standard node-level tuning for the {product-title} platform and it can only be modified to set the Operator Management state. Any other custom changes to the default CR will be overwritten by the Operator. For custom tuning, create your own Tuned CRs. Newly created CRs will be combined with the default CR and custom tuning applied to {product-title} nodes based on node or pod labels and profile priorities.</simpara>
<warning>
<simpara>While in certain situations the support for pod labels can be a convenient way of automatically delivering required tuning, this practice is discouraged and strongly advised against, especially in large-scale clusters. The default Tuned CR ships without pod label matching. If a custom profile is created with pod label matching, then the functionality will be enabled at that time. The pod label functionality will be deprecated in future versions of the Node Tuning Operator.</simpara>
</warning>
</section>
<section xml:id="custom-tuning-specification_nodes-node-tuning-operator">
<title>Custom tuning specification</title>
<simpara>The custom resource (CR) for the Operator has two major sections. The first section, <literal>profile:</literal>, is a list of TuneD profiles and their names. The second, <literal>recommend:</literal>, defines the profile selection logic.</simpara>
<simpara>Multiple custom tuning specifications can co-exist as multiple CRs in the Operator&#8217;s namespace. The existence of new CRs or the deletion of old CRs is detected by the Operator. All existing custom tuning specifications are merged and appropriate objects for the containerized TuneD daemons are updated.</simpara>
<simpara><emphasis role="strong">Management state</emphasis></simpara>
<simpara>The Operator Management state is set by adjusting the default Tuned CR. By default, the Operator is in the Managed state and the <literal>spec.managementState</literal> field is not present in the default Tuned CR. Valid values for the Operator Management state are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>Managed: the Operator will update its operands as configuration resources are updated</simpara>
</listitem>
<listitem>
<simpara>Unmanaged: the Operator will ignore changes to the configuration resources</simpara>
</listitem>
<listitem>
<simpara>Removed: the Operator will remove its operands and resources the Operator provisioned</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Profile data</emphasis></simpara>
<simpara>The <literal>profile:</literal> section lists TuneD profiles and their names.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">profile:
- name: tuned_profile_1
  data: |
    # TuneD profile specification
    [main]
    summary=Description of tuned_profile_1 profile

    [sysctl]
    net.ipv4.ip_forward=1
    # ... other sysctl's or other TuneD daemon plugins supported by the containerized TuneD

# ...

- name: tuned_profile_n
  data: |
    # TuneD profile specification
    [main]
    summary=Description of tuned_profile_n profile

    # tuned_profile_n profile settings</programlisting>
<simpara><emphasis role="strong">Recommended profiles</emphasis></simpara>
<simpara>The <literal>profile:</literal> selection logic is defined by the <literal>recommend:</literal> section of the CR. The <literal>recommend:</literal> section is a list of items to recommend the profiles based on a selection criteria.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">recommend:
&lt;recommend-item-1&gt;
# ...
&lt;recommend-item-n&gt;</programlisting>
<simpara>The individual items of the list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- machineConfigLabels: <co xml:id="CO131-1"/>
    &lt;mcLabels&gt; <co xml:id="CO131-2"/>
  match: <co xml:id="CO131-3"/>
    &lt;match&gt; <co xml:id="CO131-4"/>
  priority: &lt;priority&gt; <co xml:id="CO131-5"/>
  profile: &lt;tuned_profile_name&gt; <co xml:id="CO131-6"/>
  operand: <co xml:id="CO131-7"/>
    debug: &lt;bool&gt; <co xml:id="CO131-8"/>
    tunedConfig:
      reapply_sysctl: &lt;bool&gt; <co xml:id="CO131-9"/></programlisting>
<calloutlist>
<callout arearefs="CO131-1">
<para>Optional.</para>
</callout>
<callout arearefs="CO131-2">
<para>A dictionary of key/value <literal>MachineConfig</literal> labels. The keys must be unique.</para>
</callout>
<callout arearefs="CO131-3">
<para>If omitted, profile match is assumed unless a profile with a higher priority matches first or <literal>machineConfigLabels</literal> is set.</para>
</callout>
<callout arearefs="CO131-4">
<para>An optional list.</para>
</callout>
<callout arearefs="CO131-5">
<para>Profile ordering priority. Lower numbers mean higher priority (<literal>0</literal> is the highest priority).</para>
</callout>
<callout arearefs="CO131-6">
<para>A TuneD profile to apply on a match. For example <literal>tuned_profile_1</literal>.</para>
</callout>
<callout arearefs="CO131-7">
<para>Optional operand configuration.</para>
</callout>
<callout arearefs="CO131-8">
<para>Turn debugging on or off for the TuneD daemon. Options are <literal>true</literal> for on or <literal>false</literal> for off. The default is <literal>false</literal>.</para>
</callout>
<callout arearefs="CO131-9">
<para>Turn <literal>reapply_sysctl</literal> functionality on or off for the TuneD daemon. Options are <literal>true</literal> for on and <literal>false</literal> for off.</para>
</callout>
</calloutlist>
<simpara><literal>&lt;match&gt;</literal> is an optional list recursively defined as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- label: &lt;label_name&gt; <co xml:id="CO132-1"/>
  value: &lt;label_value&gt; <co xml:id="CO132-2"/>
  type: &lt;label_type&gt; <co xml:id="CO132-3"/>
    &lt;match&gt; <co xml:id="CO132-4"/></programlisting>
<calloutlist>
<callout arearefs="CO132-1">
<para>Node or pod label name.</para>
</callout>
<callout arearefs="CO132-2">
<para>Optional node or pod label value. If omitted, the presence of <literal>&lt;label_name&gt;</literal> is enough to match.</para>
</callout>
<callout arearefs="CO132-3">
<para>Optional object type (<literal>node</literal> or <literal>pod</literal>). If omitted, <literal>node</literal> is assumed.</para>
</callout>
<callout arearefs="CO132-4">
<para>An optional <literal>&lt;match&gt;</literal> list.</para>
</callout>
</calloutlist>
<simpara>If <literal>&lt;match&gt;</literal> is not omitted, all nested <literal>&lt;match&gt;</literal> sections must also evaluate to <literal>true</literal>. Otherwise, <literal>false</literal> is assumed and the profile with the respective <literal>&lt;match&gt;</literal> section will not be applied or recommended. Therefore, the nesting (child <literal>&lt;match&gt;</literal> sections) works as logical AND operator. Conversely, if any item of the <literal>&lt;match&gt;</literal> list matches, the entire <literal>&lt;match&gt;</literal> list evaluates to <literal>true</literal>. Therefore, the list acts as logical OR operator.</simpara>
<simpara>If <literal>machineConfigLabels</literal> is defined, machine config pool based matching is turned on for the given <literal>recommend:</literal> list item. <literal>&lt;mcLabels&gt;</literal> specifies the labels for a machine config. The machine config is created automatically to apply host settings, such as kernel boot parameters, for the profile <literal>&lt;tuned_profile_name&gt;</literal>. This involves finding all machine config pools with machine config selector matching <literal>&lt;mcLabels&gt;</literal> and setting the profile <literal>&lt;tuned_profile_name&gt;</literal> on all nodes that are assigned the found machine config pools. To target nodes that have both master and worker roles, you must use the master role.</simpara>
<simpara>The list items <literal>match</literal> and <literal>machineConfigLabels</literal> are connected by the logical OR operator. The <literal>match</literal> item is evaluated first in a short-circuit manner. Therefore, if it evaluates to <literal>true</literal>, the <literal>machineConfigLabels</literal> item is not considered.</simpara>
<important>
<simpara>When using machine config pool based matching, it is advised to group nodes with the same hardware configuration into the same machine config pool. Not following this practice might result in TuneD operands calculating conflicting kernel parameters for two or more nodes sharing the same machine config pool.</simpara>
</important>
<formalpara>
<title>Example: Node or pod label based matching</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">- match:
  - label: tuned.openshift.io/elasticsearch
    match:
    - label: node-role.kubernetes.io/master
    - label: node-role.kubernetes.io/infra
    type: pod
  priority: 10
  profile: openshift-control-plane-es
- match:
  - label: node-role.kubernetes.io/master
  - label: node-role.kubernetes.io/infra
  priority: 20
  profile: openshift-control-plane
- priority: 30
  profile: openshift-node</programlisting>
</para>
</formalpara>
<simpara>The CR above is translated for the containerized TuneD daemon into its <literal>recommend.conf</literal> file based on the profile priorities. The profile with the highest priority (<literal>10</literal>) is <literal>openshift-control-plane-es</literal> and, therefore, it is considered first. The containerized TuneD daemon running on a given node looks to see if there is a pod running on the same node with the <literal>tuned.openshift.io/elasticsearch</literal> label set. If not, the entire <literal>&lt;match&gt;</literal> section evaluates as <literal>false</literal>. If there is such a pod with the label, in order for the <literal>&lt;match&gt;</literal> section to evaluate to <literal>true</literal>, the node label also needs to be <literal>node-role.kubernetes.io/master</literal> or <literal>node-role.kubernetes.io/infra</literal>.</simpara>
<simpara>If the labels for the profile with priority <literal>10</literal> matched, <literal>openshift-control-plane-es</literal> profile is applied and no other profile is considered. If the node/pod label combination did not match, the second highest priority profile (<literal>openshift-control-plane</literal>) is considered. This profile is applied if the containerized TuneD pod runs on a node with labels <literal>node-role.kubernetes.io/master</literal> or <literal>node-role.kubernetes.io/infra</literal>.</simpara>
<simpara>Finally, the profile <literal>openshift-node</literal> has the lowest priority of <literal>30</literal>. It lacks the <literal>&lt;match&gt;</literal> section and, therefore, will always match. It acts as a profile catch-all to set <literal>openshift-node</literal> profile, if no other profile with higher priority matches on a given node.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/node-tuning-operator-workflow-revised.png"/>
</imageobject>
<textobject><phrase>Decision workflow</phrase></textobject>
</mediaobject>
</informalfigure>
<formalpara>
<title>Example: Machine config pool based matching</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: openshift-node-custom
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Custom OpenShift node profile with an additional kernel parameter
      include=openshift-node
      [bootloader]
      cmdline_openshift_node_custom=+skew_tick=1
    name: openshift-node-custom

  recommend:
  - machineConfigLabels:
      machineconfiguration.openshift.io/role: "worker-custom"
    priority: 20
    profile: openshift-node-custom</programlisting>
</para>
</formalpara>
<simpara>To minimize node reboots, label the target nodes with a label the machine config pool&#8217;s node selector will match, then create the Tuned CR above and finally create the custom machine config pool itself.</simpara>
<simpara><emphasis role="strong">Cloud provider-specific TuneD profiles</emphasis></simpara>
<simpara>With this functionality, all Cloud provider-specific nodes can conveniently be assigned a TuneD profile specifically tailored to a given Cloud provider on a {product-title} cluster. This can be accomplished without adding additional node labels or grouping nodes into
machine config pools.</simpara>
<simpara>This functionality takes advantage of <literal>spec.providerID</literal> node object values in the form of <literal>&lt;cloud-provider&gt;://&lt;cloud-provider-specific-id&gt;</literal> and writes the file <literal>/var/lib/tuned/provider</literal> with the value <literal>&lt;cloud-provider&gt;</literal> in NTO operand containers.  The content of this file is then used by TuneD to load <literal>provider-&lt;cloud-provider&gt;</literal> profile if such profile exists.</simpara>
<simpara>The <literal>openshift</literal> profile that both <literal>openshift-control-plane</literal> and <literal>openshift-node</literal> profiles inherit settings from is now updated to use this functionality through the use of conditional profile loading. Neither NTO nor TuneD currently include any Cloud provider-specific profiles. However, it is possible to create a custom profile <literal>provider-&lt;cloud-provider&gt;</literal> that will be applied to all Cloud provider-specific cluster nodes.</simpara>
<formalpara>
<title>Example GCE Cloud provider profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: provider-gce
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=GCE Cloud provider-specific profile
      # Your tuning for GCE Cloud provider goes here.
    name: provider-gce</programlisting>
</para>
</formalpara>
<note>
<simpara>Due to profile inheritance, any setting specified in the <literal>provider-&lt;cloud-provider&gt;</literal> profile will be overwritten by the <literal>openshift</literal> profile and its child profiles.</simpara>
</note>
</section>
<section xml:id="custom-tuning-default-profiles-set_nodes-node-tuning-operator">
<title>Default profiles set on a cluster</title>
<simpara>The following are the default profiles set on a cluster.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: tuned.openshift.io/v1
kind: Tuned
metadata:
  name: default
  namespace: openshift-cluster-node-tuning-operator
spec:
  profile:
  - data: |
      [main]
      summary=Optimize systems running OpenShift (provider specific parent profile)
      include=-provider-${f:exec:cat:/var/lib/tuned/provider},openshift
    name: openshift
  recommend:
  - profile: openshift-control-plane
    priority: 30
    match:
    - label: node-role.kubernetes.io/master
    - label: node-role.kubernetes.io/infra
  - profile: openshift-node
    priority: 40</programlisting>
<simpara>Starting with {product-title} 4.9, all OpenShift TuneD profiles are shipped with
the TuneD package. You can use the <literal>oc exec</literal> command to view the contents of these profiles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec $tuned_pod -n openshift-cluster-node-tuning-operator -- find /usr/lib/tuned/openshift{,-control-plane,-node} -name tuned.conf -exec grep -H ^ {} \;</programlisting>
</section>
<section xml:id="supported-tuned-daemon-plug-ins_nodes-node-tuning-operator">
<title>Supported TuneD daemon plugins</title>
<simpara>Excluding the <literal>[main]</literal> section, the following TuneD plugins are supported when
using custom profiles defined in the <literal>profile:</literal> section of the Tuned CR:</simpara>
<itemizedlist>
<listitem>
<simpara>audio</simpara>
</listitem>
<listitem>
<simpara>cpu</simpara>
</listitem>
<listitem>
<simpara>disk</simpara>
</listitem>
<listitem>
<simpara>eeepc_she</simpara>
</listitem>
<listitem>
<simpara>modules</simpara>
</listitem>
<listitem>
<simpara>mounts</simpara>
</listitem>
<listitem>
<simpara>net</simpara>
</listitem>
<listitem>
<simpara>scheduler</simpara>
</listitem>
<listitem>
<simpara>scsi_host</simpara>
</listitem>
<listitem>
<simpara>selinux</simpara>
</listitem>
<listitem>
<simpara>sysctl</simpara>
</listitem>
<listitem>
<simpara>sysfs</simpara>
</listitem>
<listitem>
<simpara>usb</simpara>
</listitem>
<listitem>
<simpara>video</simpara>
</listitem>
<listitem>
<simpara>vm</simpara>
</listitem>
<listitem>
<simpara>bootloader</simpara>
</listitem>
</itemizedlist>
<simpara>There is some dynamic tuning functionality provided by some of these plugins
that is not supported. The following TuneD plugins are currently not supported:</simpara>
<itemizedlist>
<listitem>
<simpara>script</simpara>
</listitem>
<listitem>
<simpara>systemd</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The TuneD bootloader plugin only supports Red Hat Enterprise Linux CoreOS (RHCOS) worker nodes.</simpara>
</note>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/customizing-tuned-profiles_monitoring-and-managing-system-status-and-performance#available-tuned-plug-ins_customizing-tuned-profiles">Available TuneD Plugins</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/getting-started-with-tuned_monitoring-and-managing-system-status-and-performance">Getting Started with TuneD</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-remediating-fencing-maintaining-rhwa">
<title>Remediating, fencing, and maintaining nodes</title>

<simpara>When node-level failures occur, such as the kernel hangs or network interface controllers (NICs) fail, the work required from the cluster does not decrease, and workloads from affected nodes need to be restarted somewhere. Failures affecting these workloads risk data loss, corruption, or both. It is important to isolate the node, known as <literal>fencing</literal>, before initiating recovery of the workload, known as <literal>remediation</literal>, and recovery of the node.</simpara>
<simpara>For more information on remediation, fencing, and maintaining nodes, see the <link xl:href="https://access.redhat.com/documentation/en-us/workload_availability_for_red_hat_openshift/23.2/html-single/remediation_fencing_and_maintenance/index#about-remediation-fencing-maintenance">Workload Availability for Red Hat OpenShift</link> documentation.</simpara>
</section>
<section xml:id="nodes-nodes-rebooting">
<title>Understanding node rebooting</title>

<simpara>To reboot a node without causing an outage for applications running on the
platform, it is important to first evacuate the pods. For pods that are
made highly available by the routing tier, nothing
else needs to be done. For other pods needing storage, typically databases, it
is critical to ensure that they can remain in operation with one pod
temporarily going offline. While implementing resiliency for stateful pods
is different for each application, in all cases it is important to configure
the scheduler to use node anti-affinity to
ensure that the pods are properly spread across available nodes.</simpara>
<simpara>Another challenge is how to handle nodes that are running critical
infrastructure such as the router or the registry. The same node evacuation
process applies, though it is important to understand certain edge cases.</simpara>
<section xml:id="nodes-nodes-rebooting-infrastructure_nodes-nodes-rebooting">
<title>About rebooting nodes running critical infrastructure</title>
<simpara>When rebooting nodes that host critical {product-title} infrastructure components, such as router pods, registry pods, and monitoring pods, ensure that there are at least three nodes available to run these components.</simpara>
<simpara>The following scenario demonstrates how service interruptions can occur with applications running on {product-title} when only two nodes are available:</simpara>
<itemizedlist>
<listitem>
<simpara>Node A is marked unschedulable and all pods are evacuated.</simpara>
</listitem>
<listitem>
<simpara>The registry pod running on that node is now redeployed on node B. Node B is now running both registry pods.</simpara>
</listitem>
<listitem>
<simpara>Node B is now marked unschedulable and is evacuated.</simpara>
</listitem>
<listitem>
<simpara>The service exposing the two pod endpoints on node B loses all endpoints, for a brief period of time, until they are redeployed to node A.</simpara>
</listitem>
</itemizedlist>
<simpara>When using three nodes for infrastructure components, this process does not result in a service disruption. However, due to pod scheduling, the last node that is evacuated and brought back into rotation does not have a registry pod. One of the other nodes has two registry pods. To schedule the third registry pod on the last node, use pod anti-affinity to prevent the scheduler from locating two registry pods on the same node.</simpara>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on pod anti-affinity, see <link xl:href="../../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity">Placing pods relative to other pods using affinity and anti-affinity rules</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-nodes-rebooting-affinity_nodes-nodes-rebooting">
<title>Rebooting a node using pod anti-affinity</title>
<simpara>Pod anti-affinity is slightly different than node anti-affinity. Node anti-affinity can be
violated if there are no other suitable locations to deploy a pod. Pod
anti-affinity can be set to either required or preferred.</simpara>
<simpara>With this in place, if only two infrastructure nodes are available and one is rebooted, the container image registry
pod is prevented from running on the other node. <literal><emphasis role="strong">oc get pods</emphasis></literal> reports the pod as unready until a suitable node is available.
Once a node is available and all pods are back in ready state, the next node can be restarted.</simpara>
<formalpara>
<title>Procedure</title>
<para>To reboot a node using pod anti-affinity:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the node specification to configure pod anti-affinity:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: with-pod-antiaffinity
spec:
  affinity:
    podAntiAffinity: <co xml:id="CO133-1"/>
      preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO133-2"/>
      - weight: 100 <co xml:id="CO133-3"/>
        podAffinityTerm:
          labelSelector:
            matchExpressions:
            - key: registry <co xml:id="CO133-4"/>
              operator: In <co xml:id="CO133-5"/>
              values:
              - default
          topologyKey: kubernetes.io/hostname
#...</programlisting>
<calloutlist>
<callout arearefs="CO133-1">
<para>Stanza to configure pod anti-affinity.</para>
</callout>
<callout arearefs="CO133-2">
<para>Defines a preferred rule.</para>
</callout>
<callout arearefs="CO133-3">
<para>Specifies a weight for a preferred rule. The node with the highest weight is preferred.</para>
</callout>
<callout arearefs="CO133-4">
<para>Description of the pod label that determines when the anti-affinity rule applies. Specify a key and value for the label.</para>
</callout>
<callout arearefs="CO133-5">
<para>The operator represents the relationship between the label on the existing pod and the set of values in the <literal>matchExpression</literal> parameters in the specification for the new pod. Can be <literal>In</literal>, <literal>NotIn</literal>, <literal>Exists</literal>, or <literal>DoesNotExist</literal>.</para>
</callout>
</calloutlist>
<simpara>This example assumes the container image registry pod has a label of
<literal>registry=default</literal>. Pod anti-affinity can use any Kubernetes match
expression.</simpara>
</listitem>
<listitem>
<simpara>Enable the <literal>MatchInterPodAffinity</literal> scheduler predicate in the scheduling policy file.</simpara>
</listitem>
<listitem>
<simpara>Perform a graceful restart of the node.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-nodes-rebooting-router_nodes-nodes-rebooting">
<title>Understanding how to reboot nodes running routers</title>
<simpara>In most cases, a pod running an {product-title} router exposes a host port.</simpara>
<simpara>The <literal>PodFitsPorts</literal> scheduler predicate ensures that no router pods using the
same port can run on the same node, and pod anti-affinity is achieved. If the
routers are relying on IP failover for high availability, there is nothing else that is needed.</simpara>
<simpara>For router pods relying on an external service such as AWS Elastic Load Balancing for high
availability, it is that service&#8217;s responsibility to react to router pod restarts.</simpara>
<simpara>In rare cases, a router pod may not have a host port configured. In those cases,
it is important to follow the recommended restart process for infrastructure nodes.</simpara>
</section>
<section xml:id="nodes-nodes-rebooting-gracefully_nodes-nodes-rebooting">
<title>Rebooting a node gracefully</title>
<simpara>Before rebooting a node, it is recommended to backup etcd data to avoid any data loss on the node.</simpara>
<note>
<simpara>For single-node OpenShift clusters that require users to perform the <literal>oc login</literal> command rather than having the certificates in <literal>kubeconfig</literal> file to manage the cluster, the <literal>oc adm</literal> commands might not be available after cordoning and draining the node. This is because the <literal>openshift-oauth-apiserver</literal> pod is not running due to the cordon. You can use SSH to access the nodes as indicated in the following procedure.</simpara>
<simpara>In a single-node OpenShift cluster, pods cannot be rescheduled when cordoning and draining. However, doing so gives the pods, especially your workload pods, time to properly stop and release associated resources.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To perform a graceful restart of a node:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mark the node as unschedulable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;node1&gt;</programlisting>
</listitem>
<listitem>
<simpara>Drain the node to remove all the running pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; --ignore-daemonsets --delete-emptydir-data --force</programlisting>
<simpara>You might receive errors that pods associated with custom pod disruption budgets (PDB) cannot be evicted.</simpara>
<formalpara>
<title>Example error</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">error when evicting pods/"rails-postgresql-example-1-72v2w" -n "rails" (will retry after 5s): Cannot evict pod as it would violate the pod's disruption budget.</programlisting>
</para>
</formalpara>
<simpara>In this case, run the drain command again, adding the <literal>disable-eviction</literal> flag, which bypasses the PDB checks:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;node1&gt; --ignore-daemonsets --delete-emptydir-data --force --disable-eviction</programlisting>
</listitem>
<listitem>
<simpara>Access the node in debug mode:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node1&gt;</programlisting>
</listitem>
<listitem>
<simpara>Change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Restart the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ systemctl reboot</programlisting>
<simpara>In a moment, the node enters the <literal>NotReady</literal> state.</simpara>
<note>
<simpara>With some single-node OpenShift clusters, the <literal>oc</literal> commands might not be available after you cordon and drain the node because the <literal>openshift-oauth-apiserver</literal> pod is not running. You can use SSH to connect to the node and perform the reboot.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo systemctl reboot</programlisting>
</note>
</listitem>
<listitem>
<simpara>After the reboot is complete, mark the node as schedulable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm uncordon &lt;node1&gt;</programlisting>
<note>
<simpara>With some single-node OpenShift clusters, the <literal>oc</literal> commands might not be available after you cordon and drain the node because the <literal>openshift-oauth-apiserver</literal> pod is not running. You can use SSH to connect to the node and uncordon it.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;target_node&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo oc adm uncordon &lt;node&gt; --kubeconfig /etc/kubernetes/static-pod-resources/kube-apiserver-certs/secrets/node-kubeconfigs/localhost.kubeconfig</programlisting>
</note>
</listitem>
<listitem>
<simpara>Verify that the node is ready:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node &lt;node1&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME    STATUS  ROLES    AGE     VERSION
&lt;node1&gt; Ready   worker   6d22h   v1.18.3+b0068a8</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<formalpara>
<title>Additional information</title>
<para>For information on etcd data backup, see <link xl:href="../../backup_and_restore/control_plane_backup_and_restore/backing-up-etcd.xml#backup-etcd">Backing up etcd data</link>.</para>
</formalpara>
</section>
</section>
<section xml:id="nodes-nodes-garbage-collection">
<title>Freeing node resources using garbage collection</title>

<simpara>As an administrator, you can use {product-title} to ensure that your nodes are running efficiently
by freeing up resources through garbage collection.</simpara>
<simpara>The {product-title} node performs two types of garbage collection:</simpara>
<itemizedlist>
<listitem>
<simpara>Container garbage collection: Removes terminated containers.</simpara>
</listitem>
<listitem>
<simpara>Image garbage collection: Removes images not referenced by any running pods.</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-nodes-garbage-collection-containers_nodes-nodes-configuring">
<title>Understanding how terminated containers are removed through garbage collection</title>
<simpara>Container garbage collection removes terminated containers by using eviction thresholds.</simpara>
<simpara>When eviction thresholds are set for garbage collection, the node tries to keep any container for any pod accessible from the API. If the pod has been deleted, the containers will be as well. Containers are preserved as long the pod is not deleted and the eviction threshold is not reached. If the node is under disk pressure, it will remove containers and their logs will no longer be accessible using <literal>oc logs</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">eviction-soft</emphasis> - A soft eviction threshold pairs an eviction threshold with a required administrator-specified grace period.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">eviction-hard</emphasis> - A hard eviction threshold has no grace period, and if observed, {product-title} takes immediate action.</simpara>
</listitem>
</itemizedlist>
<simpara>The following table lists the eviction thresholds:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Variables for configuring container garbage collection</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Node condition</entry>
<entry align="left" valign="top">Eviction signal</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>MemoryPressure</simpara></entry>
<entry align="left" valign="top"><simpara><literal>memory.available</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The available memory on the node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DiskPressure</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>nodefs.available</literal></simpara>
</listitem>
<listitem>
<simpara><literal>nodefs.inodesFree</literal></simpara>
</listitem>
<listitem>
<simpara><literal>imagefs.available</literal></simpara>
</listitem>
<listitem>
<simpara><literal>imagefs.inodesFree</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>The available disk space or inodes on the node root file system, <literal>nodefs</literal>, or image file system, <literal>imagefs</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>For <literal>evictionHard</literal> you must specify all of these parameters.  If you do not specify all parameters, only the specified parameters are applied and the garbage collection will not function properly.</simpara>
</note>
<simpara>If a node is oscillating above and below a soft eviction threshold, but not exceeding its associated grace period, the corresponding node would constantly oscillate between <literal>true</literal> and <literal>false</literal>. As a consequence, the scheduler could make poor scheduling decisions.</simpara>
<simpara>To protect against this oscillation, use the <literal>eviction-pressure-transition-period</literal> flag to control how long {product-title} must wait before transitioning out of a pressure condition. {product-title} will not set an eviction threshold as being met for the specified pressure condition for the period specified before toggling the condition back to false.</simpara>
</section>
<section xml:id="nodes-nodes-garbage-collection-images_nodes-nodes-configuring">
<title>Understanding how images are removed through garbage collection</title>
<simpara>Image garbage collection removes images that are not referenced by any running pods.</simpara>
<simpara>{product-title} determines which images to remove from a node based on the disk usage that is reported by <emphasis role="strong">cAdvisor</emphasis>.</simpara>
<simpara>The policy for image garbage collection is based on two conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>The percent of disk usage (expressed as an integer) which triggers image
garbage collection. The default is <emphasis role="strong">85</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>The percent of disk usage (expressed as an integer) to which image garbage
collection attempts to free. Default is <emphasis role="strong">80</emphasis>.</simpara>
</listitem>
</itemizedlist>
<simpara>For image garbage collection, you can modify any of the following variables using
a custom resource.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Variables for configuring image garbage collection</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>imageMinimumGCAge</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum age for an unused image before the image is removed by garbage collection. The default is <emphasis role="strong">2m</emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>imageGCHighThresholdPercent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The percent of disk usage, expressed as an integer, which triggers image
garbage collection. The default is <emphasis role="strong">85</emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>imageGCLowThresholdPercent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The percent of disk usage, expressed as an integer, to which image garbage
collection attempts to free. The default is <emphasis role="strong">80</emphasis>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Two lists of images are retrieved in each garbage collector run:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A list of images currently running in at least one pod.</simpara>
</listitem>
<listitem>
<simpara>A list of images available on a host.</simpara>
</listitem>
</orderedlist>
<simpara>As new containers are run, new images appear. All images are marked with a time
stamp. If the image is running (the first list above) or is newly detected (the
second list above), it is marked with the current time. The remaining images are
already marked from the previous spins. All images are then sorted by the time
stamp.</simpara>
<simpara>Once the collection starts, the oldest images get deleted first until the
stopping criterion is met.</simpara>
</section>
<section xml:id="nodes-nodes-garbage-collection-configuring_nodes-nodes-configuring">
<title>Configuring garbage collection for containers and images</title>
<simpara>As an administrator, you can configure how {product-title} performs garbage collection by creating a <literal>kubeletConfig</literal> object for each machine config pool.</simpara>
<note>
<simpara>{product-title} supports only one <literal>kubeletConfig</literal> object for each machine config pool.</simpara>
</note>
<simpara>You can configure any combination of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Soft eviction for containers</simpara>
</listitem>
<listitem>
<simpara>Hard eviction for containers</simpara>
</listitem>
<listitem>
<simpara>Eviction for images</simpara>
</listitem>
</itemizedlist>
<simpara>Container garbage collection removes terminated containers. Image garbage collection removes images that are not referenced by any running pods.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> CRD for the type of node you want to configure by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  creationTimestamp: "2022-11-16T15:34:25Z"
  generation: 4
  labels:
    pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO134-1"/>
  name: worker
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO134-1">
<para>The label appears under Labels.</para>
</callout>
</calloutlist>
<tip>
<simpara>If the label is not present, add a key/value pair such as:</simpara>
<screen>$ oc label machineconfigpool worker custom-kubelet=small-pods</screen>
</tip>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change.</simpara>
<important>
<simpara>If there is one file system, or if <literal>/var/lib/kubelet</literal> and <literal>/var/lib/containers/</literal> are in the same file system, the settings with the highest values trigger evictions, as those are met first. The file system triggers the eviction.</simpara>
</important>
<formalpara>
<title>Sample configuration for a container garbage collection CR:</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: worker-kubeconfig <co xml:id="CO135-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO135-2"/>
  kubeletConfig:
    evictionSoft: <co xml:id="CO135-3"/>
      memory.available: "500Mi" <co xml:id="CO135-4"/>
      nodefs.available: "10%"
      nodefs.inodesFree: "5%"
      imagefs.available: "15%"
      imagefs.inodesFree: "10%"
    evictionSoftGracePeriod:  <co xml:id="CO135-5"/>
      memory.available: "1m30s"
      nodefs.available: "1m30s"
      nodefs.inodesFree: "1m30s"
      imagefs.available: "1m30s"
      imagefs.inodesFree: "1m30s"
    evictionHard: <co xml:id="CO135-6"/>
      memory.available: "200Mi"
      nodefs.available: "5%"
      nodefs.inodesFree: "4%"
      imagefs.available: "10%"
      imagefs.inodesFree: "5%"
    evictionPressureTransitionPeriod: 0s <co xml:id="CO135-7"/>
    imageMinimumGCAge: 5m <co xml:id="CO135-8"/>
    imageGCHighThresholdPercent: 80 <co xml:id="CO135-9"/>
    imageGCLowThresholdPercent: 75 <co xml:id="CO135-10"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO135-1">
<para>Name for the object.</para>
</callout>
<callout arearefs="CO135-2">
<para>Specify the label from the machine config pool.</para>
</callout>
<callout arearefs="CO135-3">
<para>For container garbage collection: Type of eviction: <literal>evictionSoft</literal> or <literal>evictionHard</literal>.</para>
</callout>
<callout arearefs="CO135-4">
<para>For container garbage collection: Eviction thresholds based on a specific eviction trigger signal.</para>
</callout>
<callout arearefs="CO135-5">
<para>For container garbage collection: Grace periods for the soft eviction. This parameter does not apply to <literal>eviction-hard</literal>.</para>
</callout>
<callout arearefs="CO135-6">
<para>For container garbage collection: Eviction thresholds based on a specific eviction trigger signal.
For <literal>evictionHard</literal> you must specify all of these parameters.  If you do not specify all parameters, only the specified parameters are applied and the garbage collection will not function properly.</para>
</callout>
<callout arearefs="CO135-7">
<para>For container garbage collection: The duration to wait before transitioning out of an eviction pressure condition.</para>
</callout>
<callout arearefs="CO135-8">
<para>For image garbage collection: The minimum age for an unused image before the image is removed by garbage collection.</para>
</callout>
<callout arearefs="CO135-9">
<para>For image garbage collection: The percent of disk usage (expressed as an integer) that triggers image garbage collection.</para>
</callout>
<callout arearefs="CO135-10">
<para>For image garbage collection: The percent of disk usage (expressed as an integer) that image garbage collection attempts to free.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the following command to create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f gc-container.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kubeletconfig.machineconfiguration.openshift.io/gc-container created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that garbage collection is active by entering the following command. The Machine Config Pool you specified in the custom resource appears with <literal>UPDATING</literal> as 'true` until the change is fully implemented:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                   UPDATED   UPDATING
master   rendered-master-546383f80705bd5aeaba93   True      False
worker   rendered-worker-b4c51bb33ccaae6fc4a6a5   False     True</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-nodes-resources-configuring">
<title>Allocating resources for nodes in an {product-title} cluster</title>

<simpara>To provide more reliable scheduling and minimize node resource overcommitment, reserve a portion of the CPU and memory resources for use by the underlying node components, such as <literal>kubelet</literal> and <literal>kube-proxy</literal>, and the remaining system components, such as <literal>sshd</literal> and <literal>NetworkManager</literal>. By specifying the resources to reserve, you provide the scheduler with more information about the remaining CPU and memory resources that a node has available for use by pods. You can allow {product-title} to <link xl:href="../../nodes/nodes/nodes-nodes-resources-configuring.xml#nodes-nodes-resources-configuring-auto_nodes-nodes-resources-configuring">automatically determine the optimal <literal>system-reserved</literal> CPU and memory resources</link> for your nodes or you can <link xl:href="../../nodes/nodes/nodes-nodes-resources-configuring.xml#nodes-nodes-resources-configuring-setting_nodes-nodes-resources-configuring">manually determine and set the best resources</link> for your nodes.</simpara>
<important>
<simpara>To manually set resource values, you must use a kubelet config CR. You cannot use a machine config CR.</simpara>
</important>
<section xml:id="nodes-nodes-resources-configuring-about_nodes-nodes-resources-configuring">
<title>Understanding how to allocate resources for nodes</title>
<simpara>CPU and memory resources reserved for node components in {product-title} are based on two node settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Setting</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>kube-reserved</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This setting is not used with {product-title}. Add the CPU and memory resources that you planned to reserve to the <literal>system-reserved</literal> setting.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>system-reserved</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This setting identifies the resources to reserve for the node components and system components, such as CRI-O and Kubelet. The default settings depend on the {product-title} and Machine Config Operator versions. Confirm the default <literal>systemReserved</literal> parameter on the <literal>machine-config-operator</literal> repository.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If a flag is not set, the defaults are used. If none of the flags are set, the
allocated resource is set to the node&#8217;s capacity as it was before the
introduction of allocatable resources.</simpara>
<note>
<simpara>Any CPUs specifically reserved using the <literal>reservedSystemCPUs</literal> parameter are not available for allocation using <literal>kube-reserved</literal> or <literal>system-reserved</literal>.</simpara>
</note>
<section xml:id="computing-allocated-resources_nodes-nodes-resources-configuring">
<title>How {product-title} computes allocated resources</title>
<simpara>An allocated amount of a resource is computed based on the following formula:</simpara>
<screen>[Allocatable] = [Node Capacity] - [system-reserved] - [Hard-Eviction-Thresholds]</screen>
<note>
<simpara>The withholding of <literal>Hard-Eviction-Thresholds</literal> from <literal>Allocatable</literal> improves system reliability because the value for <literal>Allocatable</literal> is enforced for pods at the node level.</simpara>
</note>
<simpara>If <literal>Allocatable</literal> is negative, it is set to <literal>0</literal>.</simpara>
<simpara>Each node reports the system resources that are used by the container runtime and kubelet. To simplify configuring the <literal>system-reserved</literal> parameter, view the resource use for the node by using the node summary API. The node summary is available at <literal>/api/v1/nodes/&lt;node&gt;/proxy/stats/summary</literal>.</simpara>
</section>
<section xml:id="allocate-node-enforcement_nodes-nodes-resources-configuring">
<title>How nodes enforce resource constraints</title>
<simpara>The node is able to limit the total amount of resources that pods can consume based on the configured allocatable value. This feature significantly improves the reliability of the node by preventing pods from using CPU and memory resources that are needed by system services such as the container runtime and node agent. To improve node reliability, administrators should reserve resources based on a target for resource use.</simpara>
<simpara>The node enforces resource constraints by using a new cgroup hierarchy that enforces quality of service. All pods are launched in a dedicated cgroup hierarchy that is separate from system daemons.</simpara>
<simpara>Administrators should treat system daemons similar to pods that have a guaranteed quality of service. System daemons can burst within their bounding control groups and this behavior must be managed as part of cluster deployments. Reserve CPU and memory resources for system daemons by specifying the amount of CPU and memory resources in <literal>system-reserved</literal>.</simpara>
<simpara>Enforcing <literal>system-reserved</literal> limits can prevent critical system services from receiving CPU and memory resources. As a result, a critical system service can be ended by the out-of-memory killer. The recommendation is to enforce <literal>system-reserved</literal> only if you have profiled the nodes exhaustively to determine precise estimates and you are confident that critical system services can recover if any process in that group is ended by the out-of-memory killer.</simpara>
</section>
<section xml:id="allocate-eviction-thresholds_nodes-nodes-resources-configuring">
<title>Understanding Eviction Thresholds</title>
<simpara>If a node is under memory pressure, it can impact the entire node and all pods running on the node. For example, a system daemon that uses more than its reserved amount of memory can trigger an out-of-memory event. To avoid or reduce the probability of system out-of-memory events, the node provides out-of-resource handling.</simpara>
<simpara>You can reserve some memory using the <literal>--eviction-hard</literal> flag. The node attempts to evict
pods whenever memory availability on the node drops below the absolute value or percentage.
If system daemons do not exist on a node, pods are limited to the memory
<literal>capacity - eviction-hard</literal>. For this reason, resources set aside as a buffer for eviction
before reaching out of memory conditions are not available for pods.</simpara>
<simpara>The following is an example to illustrate the impact of node allocatable for memory:</simpara>
<itemizedlist>
<listitem>
<simpara>Node capacity is <literal>32Gi</literal></simpara>
</listitem>
<listitem>
<simpara>--system-reserved is <literal>3Gi</literal></simpara>
</listitem>
<listitem>
<simpara>--eviction-hard is set to <literal>100Mi</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>For this node, the effective node allocatable value is <literal>28.9Gi</literal>. If the node and system components use all their reservation, the memory available for pods is <literal>28.9Gi</literal>, and kubelet evicts pods when it exceeds this threshold.</simpara>
<simpara>If you enforce node allocatable, <literal>28.9Gi</literal>, with top-level cgroups, then pods can never exceed <literal>28.9Gi</literal>. Evictions are not performed unless system daemons consume more than <literal>3.1Gi</literal> of memory.</simpara>
<simpara>If system daemons do not use up all their reservation, with the above example,
pods would face memcg OOM kills from their bounding cgroup before node evictions kick in.
To better enforce QoS under this situation, the node applies the hard eviction thresholds to
the top-level cgroup for all pods to be <literal>Node Allocatable + Eviction Hard Thresholds</literal>.</simpara>
<simpara>If system daemons do not use up all their reservation, the node will evict pods whenever
they consume more than <literal>28.9Gi</literal> of memory. If eviction does not occur in time, a pod
will be OOM killed if pods consume <literal>29Gi</literal> of memory.</simpara>
</section>
<section xml:id="allocate-scheduler-policy_nodes-nodes-resources-configuring">
<title>How the scheduler determines resource availability</title>
<simpara>The scheduler uses the value of <literal>node.Status.Allocatable</literal> instead of
<literal>node.Status.Capacity</literal> to decide if a node will become a candidate for pod
scheduling.</simpara>
<simpara>By default, the node will report its machine capacity as fully schedulable by
the cluster.</simpara>
</section>
</section>
<section xml:id="nodes-nodes-resources-configuring-auto_nodes-nodes-resources-configuring">
<title>Automatically allocating resources for nodes</title>
<simpara>{product-title} can automatically determine the optimal <literal>system-reserved</literal> CPU and memory resources for nodes associated with a specific machine config pool and update the nodes with those values when the nodes start. By default, the <literal>system-reserved</literal> CPU is <literal>500m</literal> and <literal>system-reserved</literal> memory is <literal>1Gi</literal>.</simpara>
<simpara>To automatically determine and allocate the <literal>system-reserved</literal> resources on nodes, create a <literal>KubeletConfig</literal> custom resource (CR) to set the <literal>autoSizingReserved: true</literal> parameter. A script on each node calculates the optimal values for the respective reserved resources based on the installed CPU and memory capacity on each node. The script takes into account that increased capacity requires a corresponding increase in the reserved resources.</simpara>
<simpara>Automatically determining the optimal <literal>system-reserved</literal> settings ensures that your cluster is running efficiently and prevents node failure due to resource starvation of system components, such as CRI-O and kubelet, without your needing to manually calculate and update the values.</simpara>
<simpara>This feature is disabled by default.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> object for the type of node you want to configure by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  creationTimestamp: "2022-11-16T15:34:25Z"
  generation: 4
  labels:
    pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO136-1"/>
  name: worker
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO136-1">
<para>The label appears under <literal>Labels</literal>.</para>
</callout>
</calloutlist>
<tip>
<simpara>If an appropriate label is not present, add a key/value pair such as:</simpara>
<screen>$ oc label machineconfigpool worker custom-kubelet=small-pods</screen>
</tip>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change:</simpara>
<formalpara>
<title>Sample configuration for a resource allocation CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: dynamic-node <co xml:id="CO137-1"/>
spec:
  autoSizingReserved: true <co xml:id="CO137-2"/>
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO137-3"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO137-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO137-2">
<para>Add the <literal>autoSizingReserved</literal> parameter set to <literal>true</literal> to allow {product-title} to automatically determine and allocate the <literal>system-reserved</literal> resources on the nodes associated with the specified label. To disable automatic allocation on those nodes, set this parameter to <literal>false</literal>.</para>
</callout>
<callout arearefs="CO137-3">
<para>Specify the label from the machine config pool that you configured in the "Prerequisites" section. You can choose any desired labels for the machine config pool, such as <literal>custom-kubelet: small-pods</literal>, or the default label, <literal>pools.operator.machineconfiguration.openshift.io/worker: ""</literal>.</para>
</callout>
</calloutlist>
<simpara>The previous example enables automatic resource allocation on all worker nodes. {product-title} drains the nodes, applies the kubelet config, and restarts the nodes.</simpara>
</listitem>
<listitem>
<simpara>Create the CR by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Log in to a node you configured by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>/etc/node-sizing.env</literal> file:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">SYSTEM_RESERVED_MEMORY=3Gi
SYSTEM_RESERVED_CPU=0.08</programlisting>
</para>
</formalpara>
<simpara>The kubelet uses the <literal>system-reserved</literal> values in the <literal>/etc/node-sizing.env</literal> file. In the previous example, the worker nodes are allocated <literal>0.08</literal> CPU and 3 Gi of memory. It can take several minutes for the optimal values to appear.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-nodes-resources-configuring-setting_nodes-nodes-resources-configuring">
<title>Manually allocating resources for nodes</title>
<simpara>{product-title} supports the CPU and memory resource types for allocation. The <literal>ephemeral-resource</literal> resource type is also supported. For the <literal>cpu</literal> type, you specify the resource quantity in units of cores, such as <literal>200m</literal>, <literal>0.5</literal>, or <literal>1</literal>. For <literal>memory</literal> and <literal>ephemeral-storage</literal>, you specify the resource quantity in units of bytes, such as <literal>200Ki</literal>, <literal>50Mi</literal>, or <literal>5Gi</literal>. By default, the <literal>system-reserved</literal> CPU is <literal>500m</literal> and <literal>system-reserved</literal> memory is <literal>1Gi</literal>.</simpara>
<simpara>As an administrator, you can set these values by using a kubelet config custom resource (CR) through a set of <literal>&lt;resource_type&gt;=&lt;resource_quantity&gt;</literal> pairs
(e.g., <literal>cpu=200m,memory=512Mi</literal>).</simpara>
<important>
<simpara>You must use a kubelet config CR to manually set resource values. You cannot use a machine config CR.</simpara>
</important>
<simpara>For details on the recommended <literal>system-reserved</literal> values, refer to the <link xl:href="https://access.redhat.com/solutions/5843241">recommended system-reserved values</link>.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> CRD for the type of node you want to configure by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  creationTimestamp: "2022-11-16T15:34:25Z"
  generation: 4
  labels:
    pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO138-1"/>
  name: worker
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO138-1">
<para>The label appears under Labels.</para>
</callout>
</calloutlist>
<tip>
<simpara>If the label is not present, add a key/value pair such as:</simpara>
<screen>$ oc label machineconfigpool worker custom-kubelet=small-pods</screen>
</tip>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change.</simpara>
<formalpara>
<title>Sample configuration for a resource allocation CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: set-allocatable <co xml:id="CO139-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO139-2"/>
  kubeletConfig:
    systemReserved: <co xml:id="CO139-3"/>
      cpu: 1000m
      memory: 1Gi
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO139-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO139-2">
<para>Specify the label from the machine config pool.</para>
</callout>
<callout arearefs="CO139-3">
<para>Specify the resources to reserve for the node components and system components.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the following command to create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-nodes-resources-cpus">
<title>Allocating specific CPUs for nodes in a cluster</title>

<simpara>When using the <link xl:href="../../scalability_and_performance/using-cpu-manager.xml">static CPU Manager policy</link>, you can reserve specific CPUs for use by specific nodes in your cluster. For example, on a system with 24 CPUs, you could reserve CPUs numbered 0 - 3 for the control plane allowing the compute nodes to use CPUs 4 - 23.</simpara>
<section xml:id="nodes-nodes-resources-cpus-reserve_nodes-nodes-resources-cpus">
<title>Reserving CPUs for nodes</title>
<simpara>To explicitly define a list of CPUs that are reserved for specific nodes, create a <literal>KubeletConfig</literal> custom resource (CR) to define the <literal>reservedSystemCPUs</literal> parameter. This list supersedes the CPUs that might be reserved using the <literal>systemReserved</literal> and <literal>kubeReserved</literal> parameters.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Obtain the label associated with the machine config pool (MCP) for the type of node you want to configure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">Name:         worker
Namespace:
Labels:       machineconfiguration.openshift.io/mco-built-in=
              pools.operator.machineconfiguration.openshift.io/worker= <co xml:id="CO140-1"/>
Annotations:  &lt;none&gt;
API Version:  machineconfiguration.openshift.io/v1
Kind:         MachineConfigPool
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO140-1">
<para>Get the MCP label.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a YAML file for the <literal>KubeletConfig</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: set-reserved-cpus <co xml:id="CO141-1"/>
spec:
  kubeletConfig:
    reservedSystemCPUs: "0,1,2,3" <co xml:id="CO141-2"/>
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO141-3"/>
#...</programlisting>
<calloutlist>
<callout arearefs="CO141-1">
<para>Specify a name for the CR.</para>
</callout>
<callout arearefs="CO141-2">
<para>Specify the core IDs of the CPUs you want to reserve for the nodes associated with the MCP.</para>
</callout>
<callout arearefs="CO141-3">
<para>Specify the label from the MCP.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the CR object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on the <literal>systemReserved</literal> and <literal>kubeReserved</literal> parameters, see <link xl:href="../../nodes/nodes/nodes-nodes-resources-configuring.xml#nodes-nodes-resources-configuring-about_nodes-nodes-resources-configuring">Allocating resources for nodes in an {product-title} cluster</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-nodes-tls">
<title>Enabling TLS security profiles for the kubelet</title>

<simpara>You can use a TLS (Transport Layer Security) security profile to define which TLS ciphers are required by the kubelet when it is acting as an HTTP server. The kubelet uses its HTTP/GRPC server to communicate with the Kubernetes API server, which sends commands to pods, gathers logs, and run exec commands on pods through the kubelet.</simpara>
<simpara>A TLS security profile defines the TLS ciphers that the Kubernetes API server must use when connecting with the kubelet to protect communication between the kubelet and the Kubernetes API server.</simpara>
<note>
<simpara>By default, when the kubelet acts as a client with the Kubernetes API server, it automatically negotiates the TLS parameters with the API server.</simpara>
</note>
<section xml:id="tls-profiles-understanding_nodes-nodes-tls">
<title>Understanding TLS security profiles</title>
<simpara>You can use a TLS (Transport Layer Security) security profile to define which TLS ciphers are required by various {product-title} components. The {product-title} TLS security profiles are based on <link xl:href="https://wiki.mozilla.org/Security/Server_Side_TLS">Mozilla recommended configurations</link>.</simpara>
<simpara>You can specify one of the following TLS security profiles for each component:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>TLS security profiles</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Old</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is intended for use with legacy clients or libraries. The profile is based on the <link xl:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Old_backward_compatibility">Old backward compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Old</literal> profile requires a minimum TLS version of 1.0.</simpara>
<note>
<simpara>For the Ingress Controller, the minimum TLS version is converted from 1.0 to 1.1.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Intermediate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is the recommended configuration for the majority of clients. It is the  default TLS security profile for the Ingress Controller, kubelet, and control plane. The profile is based on the <link xl:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Intermediate_compatibility_.28recommended.29">Intermediate compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Intermediate</literal> profile requires a minimum TLS version of 1.2.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Modern</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile is intended for use with modern clients that have no need for backwards compatibility. This profile is based on the <link xl:href="https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility">Modern compatibility</link> recommended configuration.</simpara>
<simpara>The <literal>Modern</literal> profile requires a minimum TLS version of 1.3.</simpara>
<note>
<simpara>In {product-title} 4.6, 4.7, and 4.8, the <literal>Modern</literal> profile is unsupported. If selected, the <literal>Intermediate</literal> profile is enabled.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Custom</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This profile allows you to define the TLS version and ciphers to use.</simpara>
<warning>
<simpara>Use caution when using a <literal>Custom</literal> profile, because invalid configurations can cause problems.</simpara>
</warning></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>When using one of the predefined profile types, the effective profile configuration is subject to change between releases. For example, given a specification to use the Intermediate profile deployed on release X.Y.Z, an upgrade to release X.Y.Z+1 might cause a new profile configuration to be applied, resulting in a rollout.</simpara>
</note>
</section>
<section xml:id="tls-profiles-kubelet-configuring_nodes-nodes-tls">
<title>Configuring the TLS security profile for the kubelet</title>
<simpara>To configure a TLS security profile for the kubelet when it is acting as an HTTP server, create a <literal>KubeletConfig</literal> custom resource (CR) to specify a predefined or custom TLS security profile for specific nodes. If a TLS security profile is not configured, the default TLS security profile is <literal>Intermediate</literal>.</simpara>
<formalpara>
<title>Sample <literal>KubeletConfig</literal> CR that configures the <literal>Old</literal> TLS security profile on worker nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: KubeletConfig
 ...
spec:
  tlsSecurityProfile:
    old: {}
    type: Old
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: ""
#...</programlisting>
</para>
</formalpara>
<simpara>You can see the ciphers and the minimum TLS version of the configured TLS security profile in the <literal>kubelet.conf</literal> file on a configured node.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to {product-title} as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>KubeletConfig</literal> CR to configure the TLS security profile:</simpara>
<formalpara>
<title>Sample <literal>KubeletConfig</literal> CR for a <literal>Custom</literal> profile</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: set-kubelet-tls-security-profile
spec:
  tlsSecurityProfile:
    type: Custom <co xml:id="CO142-1"/>
    custom: <co xml:id="CO142-2"/>
      ciphers: <co xml:id="CO142-3"/>
      - ECDHE-ECDSA-CHACHA20-POLY1305
      - ECDHE-RSA-CHACHA20-POLY1305
      - ECDHE-RSA-AES128-GCM-SHA256
      - ECDHE-ECDSA-AES128-GCM-SHA256
      minTLSVersion: VersionTLS11
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO142-4"/>
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO142-1">
<para>Specify the TLS security profile type (<literal>Old</literal>, <literal>Intermediate</literal>, or <literal>Custom</literal>). The default is <literal>Intermediate</literal>.</para>
</callout>
<callout arearefs="CO142-2">
<para>Specify the appropriate field for the selected type:</para>
<itemizedlist>
<listitem>
<simpara><literal>old: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>intermediate: {}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>custom:</literal></simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO142-3">
<para>For the <literal>custom</literal> type, specify a list of TLS ciphers and minimum accepted TLS version.</para>
</callout>
<callout arearefs="CO142-4">
<para>Optional: Specify the machine config pool label for the nodes you want to apply the TLS security profile.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>KubeletConfig</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;</programlisting>
<simpara>Depending on the number of worker nodes in the cluster, wait for the configured nodes to be rebooted one by one.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the profile is set,  perform the following steps after the nodes are in the <literal>Ready</literal> state:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start a debug session for a configured node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>kubelet.conf</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# cat /etc/kubernetes/kubelet.conf</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  "kind": "KubeletConfiguration",
  "apiVersion": "kubelet.config.k8s.io/v1beta1",
#...
  "tlsCipherSuites": [
    "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
    "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
    "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256",
    "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256"
  ],
  "tlsMinVersion": "VersionTLS12",
#...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="machine-config-daemon-metrics">
<title>Machine Config Daemon metrics</title>
<simpara>The Machine Config Daemon is a part of the Machine Config Operator. It runs on every node in the cluster. The Machine Config Daemon manages configuration changes and updates on each of the nodes.</simpara>
<section xml:id="machine-config-daemon-metrics_machine-config-operator">
<title>Machine Config Daemon metrics</title>
<simpara>Beginning with {product-title} 4.3, the Machine Config Daemon provides a set of metrics. These metrics can be accessed using the Prometheus Cluster Monitoring stack.</simpara>
<simpara>The following table describes this set of metrics. Some entries contain commands for getting specific logs. Hpwever, the most comprehensive set of logs is available using the <literal>oc adm must-gather</literal> command.</simpara>
<note>
<simpara>Metrics marked with <literal>*</literal> in the <emphasis role="strong">Name</emphasis> and <emphasis role="strong">Description</emphasis> columns represent serious errors that might cause performance problems. Such problems might prevent updates and upgrades from proceeding.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title>MCO metrics</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="33.3335*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Format</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_host_os_and_version</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]string{"os", "version"}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shows the OS that MCD is running on, such as RHCOS or RHEL. In case of RHCOS, the version is provided.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_drain_err*</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Logs errors received during failed drain. *</simpara></entry>
<entry align="left" valign="top"><simpara>While drains might need multiple tries to succeed, terminal failed drains prevent updates from proceeding. The <literal>drain_time</literal> metric, which shows how much time the drain took, might help with troubleshooting.</simpara><simpara>For further investigation, see the logs by running:</simpara><simpara><literal>$ oc logs -f -n openshift-machine-config-operator machine-config-daemon-&lt;hash&gt; -c machine-config-daemon</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_pivot_err*</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]string{"err", "node", "pivot_target"}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs errors encountered during pivot. *</simpara></entry>
<entry align="left" valign="top"><simpara>Pivot errors might prevent OS upgrades from proceeding.</simpara><simpara>For further investigation, run this command to see the logs from the <literal>machine-config-daemon</literal> container:</simpara><simpara><literal>$ oc logs -f -n openshift-machine-config-operator machine-config-daemon-&lt;hash&gt; -c machine-config-daemon</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_state</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]string{"state", "reason"}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>State of Machine Config Daemon for the indicated node. Possible states are "Done", "Working", and "Degraded". In case of "Degraded", the reason is included.</simpara></entry>
<entry align="left" valign="top"><simpara>For further investigation, see the logs by running:</simpara><simpara><literal>$ oc logs -f -n openshift-machine-config-operator machine-config-daemon-&lt;hash&gt; -c machine-config-daemon</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_kubelet_state*</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>Logs kubelet health failures.  *</simpara></entry>
<entry align="left" valign="top"><simpara>This is expected to be empty, with failure count of 0. If failure count exceeds 2, the error indicating threshold is exceeded. This indicates a possible issue with the health of the kubelet.</simpara><simpara>For further investigation, run this command to access the node and see all its logs:</simpara><simpara><literal>$ oc debug node/&lt;node&gt;&#8201;&#8212;&#8201;chroot /host journalctl -u kubelet</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_reboot_err*</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]string{"message", "err", "node"}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs the failed reboots and the corresponding errors. *</simpara></entry>
<entry align="left" valign="top"><simpara>This is expected to be empty, which indicates a successful reboot.</simpara><simpara>For further investigation, see the logs by running:</simpara><simpara><literal>$ oc logs -f -n openshift-machine-config-operator machine-config-daemon-&lt;hash&gt; -c machine-config-daemon</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mcd_update_state</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]string{"config", "err"}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs success or failure of configuration updates and the corresponding errors.</simpara></entry>
<entry align="left" valign="top"><simpara>The expected value is <literal>rendered-master/rendered-worker-XXXX</literal>. If the update fails, an error is present.</simpara><simpara>For further investigation, see the logs by running:</simpara><simpara><literal>$ oc logs -f -n openshift-machine-config-operator machine-config-daemon-&lt;hash&gt; -c machine-config-daemon</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../monitoring/monitoring-overview.xml#monitoring-overview">Monitoring overview</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../support/gathering-cluster-data.xml#gathering-cluster-data">Gathering data about your cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-nodes-creating-infrastructure-nodes">
<title>Creating infrastructure nodes</title>

<important>
<simpara>You can use the advanced machine management and scaling capabilities only in clusters where the Machine API is operational. Clusters with user-provisioned infrastructure require additional validation and configuration to use the Machine API.</simpara>
<simpara>Clusters with the infrastructure platform type <literal>none</literal> cannot use the Machine API. This limitation applies even if the compute machines that are attached to the cluster are installed on a platform that supports the feature. This parameter cannot be changed after installation.</simpara>
<simpara>To view the platform type for your cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get infrastructure cluster -o jsonpath='{.status.platform}'</programlisting>
</important>
<simpara>You can use infrastructure machine sets to create machines that host only infrastructure components, such as the default router, the integrated container image registry, and the components for cluster metrics and monitoring. These infrastructure machines are not counted toward the total number of subscriptions that are required to run the environment.</simpara>
<simpara>In a production deployment, it is recommended that you deploy at least three machine sets to hold infrastructure components. Both OpenShift Logging and Red Hat OpenShift Service Mesh deploy Elasticsearch, which requires three instances to be installed on different nodes. Each of these nodes can be deployed to different availability zones for high availability. This configuration requires three different machine sets, one for each availability zone. In global Azure regions that do not have multiple availability zones, you can use availability sets to ensure high availability.</simpara>
<note>
<simpara>After adding the <literal>NoSchedule</literal> taint on the infrastructure node, existing DNS pods running on that node are marked as <literal>misscheduled</literal>. You must either delete or <link xl:href="https://access.redhat.com/solutions/6592171">add toleration on <literal>misscheduled</literal> DNS pods</link>.</simpara>
</note>
<section xml:id="infrastructure-components_creating-infrastructure-nodes">
<title>{product-title} infrastructure components</title>
<simpara>The following infrastructure workloads do not incur {product-title} worker subscriptions:</simpara>
<itemizedlist>
<listitem>
<simpara>Kubernetes and {product-title} control plane services that run on masters</simpara>
</listitem>
<listitem>
<simpara>The default router</simpara>
</listitem>
<listitem>
<simpara>The integrated container image registry</simpara>
</listitem>
<listitem>
<simpara>The HAProxy-based Ingress Controller</simpara>
</listitem>
<listitem>
<simpara>The cluster metrics collection, or monitoring service, including components for monitoring user-defined projects</simpara>
</listitem>
<listitem>
<simpara>Cluster aggregated logging</simpara>
</listitem>
<listitem>
<simpara>Service brokers</simpara>
</listitem>
<listitem>
<simpara>Red Hat Quay</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Data Foundation</simpara>
</listitem>
<listitem>
<simpara>Red Hat Advanced Cluster Manager</simpara>
</listitem>
<listitem>
<simpara>Red Hat Advanced Cluster Security for Kubernetes</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift GitOps</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Pipelines</simpara>
</listitem>
</itemizedlist>
<simpara>Any node that runs any other container, pod, or component is a worker node that your subscription must cover.</simpara>
<simpara>For information about infrastructure nodes and which components can run on infrastructure nodes, see the "Red Hat OpenShift control plane and infrastructure nodes" section in the <link xl:href="https://www.redhat.com/en/resources/openshift-subscription-sizing-guide">OpenShift sizing and subscription guide for enterprise Kubernetes</link> document.</simpara>
<simpara>To create an infrastructure node, you can <link xl:href="../../machine_management/creating-infrastructure-machinesets.xml#machineset-creating_creating-infrastructure-machinesets">use a machine set</link>, <link xl:href="../../nodes/nodes/nodes-nodes-creating-infrastructure-nodes.xml#creating-an-infra-node_creating-infrastructure-nodes">label the node</link>, or <link xl:href="../../machine_management/creating-infrastructure-machinesets.xml#creating-infra-machines_creating-infrastructure-machinesets">use a machine config pool</link>.</simpara>
<section xml:id="creating-an-infra-node_creating-infrastructure-nodes">
<title>Creating an infrastructure node</title>
<important>
<simpara>See Creating infrastructure machine sets for installer-provisioned infrastructure environments or for any cluster where the control plane nodes are managed by the machine API.</simpara>
</important>
<simpara>Requirements of the cluster dictate that infrastructure, also called <literal>infra</literal> nodes, be provisioned. The installer only provides provisions for control plane and worker nodes. Worker nodes can be designated as infrastructure nodes or application, also called <literal>app</literal>, nodes through labeling.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a label to the worker node that you want to act as application node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node-name&gt; node-role.kubernetes.io/app=""</programlisting>
</listitem>
<listitem>
<simpara>Add a label to the worker nodes that you want to act as infrastructure nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node-name&gt; node-role.kubernetes.io/infra=""</programlisting>
</listitem>
<listitem>
<simpara>Check to see if applicable nodes now have the <literal>infra</literal> role and <literal>app</literal> roles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
</listitem>
<listitem>
<simpara>Create a default cluster-wide node selector. The default node selector is applied to pods created in all namespaces. This creates an intersection with any existing node selectors on a pod, which additionally constrains the pod&#8217;s selector.</simpara>
<important>
<simpara>If the default node selector key conflicts with the key of a pod&#8217;s label, then the default node selector is not applied.</simpara>
<simpara>However, do not set a default node selector that might cause a pod to become unschedulable. For example, setting the default node selector to a specific node role, such as <literal>node-role.kubernetes.io/infra=""</literal>, when a pod&#8217;s label is set to a different node role, such as <literal>node-role.kubernetes.io/master=""</literal>, can cause the pod to become unschedulable. For this reason, use caution when setting the default node selector to specific node roles.</simpara>
<simpara>You can alternatively use a project node selector to avoid cluster-wide node selector key conflicts.</simpara>
</important>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>Scheduler</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit scheduler cluster</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>defaultNodeSelector</literal> field with the appropriate node selector:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Scheduler
metadata:
  name: cluster
spec:
  defaultNodeSelector: topology.kubernetes.io/region=us-east-1 <co xml:id="CO143-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO143-1">
<para>This example node selector deploys pods on nodes in the <literal>us-east-1</literal> region by default.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now move infrastructure resources to the newly labeled <literal>infra</literal> nodes.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../machine_management/creating-infrastructure-machinesets.xml#moving-resources-to-infrastructure-machinesets">Moving resources to infrastructure machine sets</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_working_with_containers">
<title>Working with containers</title>
<section xml:id="nodes-containers-using">
<title>Understanding Containers</title>

<simpara>The basic units of {product-title} applications are called <emphasis>containers</emphasis>.
<link xl:href="https://www.redhat.com/en/topics/containers#overview">Linux container technologies</link>
are lightweight mechanisms for isolating running processes so that they are
limited to interacting with only their designated resources.</simpara>
<simpara>Many application instances can be running in containers on a single host without
visibility into each others' processes, files, network, and so on. Typically,
each container provides a single service (often called a "micro-service"), such
as a web server or a database, though containers can be used for arbitrary
workloads.</simpara>
<simpara>The Linux kernel has been incorporating capabilities for container technologies
for years. {product-title} and
Kubernetes add the ability to orchestrate containers across
multi-host installations.</simpara>
<section xml:id="nodes-containers-memory">
<title>About containers and RHEL kernel memory</title>
<simpara>Due to Red Hat Enterprise Linux (RHEL) behavior, a container on a node with high CPU usage might seem to consume more memory than expected. The higher memory consumption could be caused by the <literal>kmem_cache</literal> in the RHEL kernel. The RHEL kernel creates a <literal>kmem_cache</literal> for each cgroup. For added performance, the <literal>kmem_cache</literal> contains a <literal>cpu_cache</literal>, and a node cache for any NUMA nodes. These caches all consume kernel memory.</simpara>
<simpara>The amount of memory stored in those caches is proportional to the number of CPUs that the system uses. As a result, a higher number of CPUs results in a greater amount of kernel memory being held in these caches. Higher amounts of kernel memory in these caches can cause {product-title} containers to exceed the configured memory limits, resulting in the container being killed.</simpara>
<simpara>To avoid losing containers due to kernel memory issues, ensure that the containers request sufficient memory. You can use the following formula to estimate the amount of memory consumed by the <literal>kmem_cache</literal>, where <literal>nproc</literal> is the number of processing units available that are reported by the <literal>nproc</literal> command. The lower limit of container requests should be this value plus the container memory requirements:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$(nproc) X 1/2 MiB</programlisting>
</section>
<section xml:id="nodes-containers-runtimes">
<title>About the container engine and container runtime</title>
<simpara>A <emphasis>container engine</emphasis> is a piece of software that processes user requests, including command line options and image pulls. The container engine uses a <emphasis>container runtime</emphasis>, also called a <emphasis>lower-level container runtime</emphasis>, to run and manage the components required to deploy and operate containers. You likely will not need to interact with the container engine or container runtime.</simpara>
<note>
<simpara>The {product-title} documentation uses the term <emphasis>container runtime</emphasis> to refer to the lower-level container runtime. Other documentation can refer to the container engine as the container runtime.</simpara>
</note>
<simpara>{product-title} uses CRI-O as the container engine and runC or crun as the container runtime. The default container runtime is runC. Both container runtimes adhere to the <link xl:href="https://www.opencontainers.org/">Open Container Initiative (OCI)</link> runtime specifications.</simpara>
<simpara>CRI-O is a Kubernetes-native container engine implementation that integrates closely with the operating system to deliver an efficient and optimized Kubernetes experience. The CRI-O container engine runs as a systemd service on each {product-title} cluster node.</simpara>
<simpara>runC, developed by Docker and maintained by the Open Container Project, is a lightweight, portable container runtime written in Go. crun, developed by Red Hat, is a fast and low-memory container runtime fully written in C. As of {product-title} {product-version}, you can select between the two.</simpara>
<simpara>crun has several improvements over runC, including:</simpara>
<itemizedlist>
<listitem>
<simpara>Smaller binary</simpara>
</listitem>
<listitem>
<simpara>Quicker processing</simpara>
</listitem>
<listitem>
<simpara>Lower memory footprint</simpara>
</listitem>
</itemizedlist>
<simpara>runC has some benefits over crun, including:</simpara>
<itemizedlist>
<listitem>
<simpara>Most popular OCI container runtime.</simpara>
</listitem>
<listitem>
<simpara>Longer tenure in production.</simpara>
</listitem>
<listitem>
<simpara>Default container runtime of CRI-O.</simpara>
</listitem>
</itemizedlist>
<simpara>You can move between the two container runtimes as needed.</simpara>
<simpara>For information on setting which container runtime to use, see <link xl:href="../../post_installation_configuration/machine-configuration-tasks.xml#create-a-containerruntimeconfig_post-install-machine-configuration-tasks">Creating a <literal>ContainerRuntimeConfig</literal> CR to edit CRI-O parameters</link>.</simpara>
</section>
</section>
<section xml:id="nodes-containers-init">
<title>Using Init Containers to perform tasks before a pod is deployed</title>

<simpara>{product-title} provides <emphasis>init containers</emphasis>, which are specialized containers
that run before application containers and can contain utilities or setup scripts not present in an app image.</simpara>
<section xml:id="nodes-containers-init-about_nodes-containers-init">
<title>Understanding Init Containers</title>
<simpara>You can use an Init Container resource to perform tasks before the rest of a pod is deployed.</simpara>
<simpara>A pod can have Init Containers in addition to application containers. Init
containers allow you to reorganize setup scripts and binding code.</simpara>
<simpara>An Init Container can:</simpara>
<itemizedlist>
<listitem>
<simpara>Contain and run utilities that are not desirable to include in the app Container image for security reasons.</simpara>
</listitem>
<listitem>
<simpara>Contain utilities or custom code for setup that is not present in an app image. For example, there is no requirement to make an image FROM another image just to use a tool like sed, awk, python, or dig during setup.</simpara>
</listitem>
<listitem>
<simpara>Use Linux namespaces so that they have different filesystem views from app containers, such as access to secrets that application containers are not able to access.</simpara>
</listitem>
</itemizedlist>
<simpara>Each Init Container must complete successfully before the next one is started. So, Init Containers provide an easy way to block or delay the startup of app containers until some set of preconditions are met.</simpara>
<simpara>For example, the following are some ways you can use Init Containers:</simpara>
<itemizedlist>
<listitem>
<simpara>Wait for a service to be created with a shell command like:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1</programlisting>
</listitem>
<listitem>
<simpara>Register this pod with a remote server from the downward API with a command like:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d ‘instance=$()&amp;ip=$()’</programlisting>
</listitem>
<listitem>
<simpara>Wait for some time before starting the app Container with a command like <literal>sleep 60</literal>.</simpara>
</listitem>
<listitem>
<simpara>Clone a git repository into a volume.</simpara>
</listitem>
<listitem>
<simpara>Place values into a configuration file and run a template tool to dynamically generate a configuration file for the main app Container. For example, place the POD_IP value in a configuration and generate the main app configuration file using Jinja.</simpara>
</listitem>
</itemizedlist>
<simpara>See the <link xl:href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">Kubernetes documentation</link> for more information.</simpara>
</section>
<section xml:id="nodes-containers-init-creating_nodes-containers-init">
<title>Creating Init Containers</title>
<simpara>The following example outlines a simple pod which has two Init Containers. The first waits for <literal>myservice</literal> and the second waits for <literal>mydb</literal>. After both containers complete, the pod begins.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the pod for the Init Container:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: registry.access.redhat.com/ubi9/ubi:latest
    command: ['sh', '-c', 'echo The app is running! &amp;&amp; sleep 3600']
  initContainers:
  - name: init-myservice
    image: registry.access.redhat.com/ubi9/ubi:latest
    command: ['sh', '-c', 'until getent hosts myservice; do echo waiting for myservice; sleep 2; done;']
  - name: init-mydb
    image: registry.access.redhat.com/ubi9/ubi:latest
    command: ['sh', '-c', 'until getent hosts mydb; do echo waiting for mydb; sleep 2; done;']
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f myapp.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the status of the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY     STATUS              RESTARTS   AGE
myapp-pod                     0/1       Init:0/2            0          5s</programlisting>
</para>
</formalpara>
<simpara>The pod status, <literal>Init:0/2</literal>, indicates it is waiting for the two services.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>myservice</literal> service.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Service
apiVersion: v1
metadata:
  name: myservice
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376</programlisting>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f myservice.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the status of the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY     STATUS              RESTARTS   AGE
myapp-pod                     0/1       Init:1/2            0          5s</programlisting>
</para>
</formalpara>
<simpara>The pod status, <literal>Init:1/2</literal>, indicates it is waiting for one service, in this case the <literal>mydb</literal> service.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>mydb</literal> service:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Service
apiVersion: v1
metadata:
  name: mydb
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9377</programlisting>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f mydb.yaml</programlisting>
</listitem>
<listitem>
<simpara>View the status of the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          READY     STATUS              RESTARTS   AGE
myapp-pod                     1/1       Running             0          2m</programlisting>
</para>
</formalpara>
<simpara>The pod status indicated that it is no longer waiting for the services and is running.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-containers-volumes">
<title>Using volumes to persist container data</title>

<simpara>Files in a container are ephemeral. As such, when a container crashes or stops, the data is lost.
You can use <emphasis>volumes</emphasis> to persist the data used by the containers in a pod. A volume is directory, accessible to the Containers in a pod, where data is stored for the life of the pod.</simpara>
<section xml:id="nodes-containers-volumes-about_nodes-containers-volumes">
<title>Understanding volumes</title>
<simpara>Volumes are mounted file systems available to pods and their
containers which may be backed by a number of host-local or network attached
storage endpoints. Containers are not persistent by default; on restart, their contents are
cleared.</simpara>
<simpara>To ensure that the file system on the volume contains no errors and, if errors
are present, to repair them when possible, {product-title} invokes the <literal>fsck</literal>
utility prior to the <literal>mount</literal> utility. This occurs when either adding a volume or
updating an existing volume.</simpara>
<simpara>The simplest volume type is <literal>emptyDir</literal>, which is a temporary directory on a
single machine. Administrators may also allow you to request a persistent volume that is automatically attached
to your pods.</simpara>
<note>
<simpara><literal>emptyDir</literal> volume storage may be restricted by a quota based on the pod&#8217;s
FSGroup, if the FSGroup parameter is enabled by your cluster administrator.</simpara>
</note>
</section>
<section xml:id="nodes-containers-volumes-cli_nodes-containers-volumes">
<title>Working with volumes using the {product-title} CLI</title>
<simpara>You can use the CLI command <literal>oc set volume</literal> to add and remove volumes and
volume mounts for any object that has a pod template like replication controllers or
deployment configs. You can also list volumes in pods or any
object that has a pod template.</simpara>
<simpara>The <literal>oc set volume</literal> command uses the following general syntax:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume &lt;object_selection&gt; &lt;operation&gt; &lt;mandatory_parameters&gt; &lt;options&gt;</programlisting>
<variablelist>
<varlistentry>
<term>Object selection</term>
<listitem>
<simpara>Specify one of the following for the <literal>object_selection</literal> parameter in the <literal>oc set volume</literal> command:</simpara>
</listitem>
</varlistentry>
</variablelist>
<table xml:id="vol-object-selection_nodes-containers-volumes" frame="all" rowsep="1" colsep="1">
<title>Object Selection</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Syntax</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>&lt;object_type&gt;</emphasis> <emphasis>&lt;name&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Selects <literal><emphasis>&lt;name&gt;</emphasis></literal> of type <literal><emphasis>&lt;object_type&gt;</emphasis></literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>deploymentConfig registry</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>&lt;object_type&gt;</emphasis>/<emphasis>&lt;name&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Selects <literal><emphasis>&lt;name&gt;</emphasis></literal> of type <literal><emphasis>&lt;object_type&gt;</emphasis></literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>deploymentConfig/registry</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>&lt;object_type&gt;</emphasis></literal>
<literal>--selector=<emphasis>&lt;object_label_selector&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Selects resources of type <literal><emphasis>&lt;object_type&gt;</emphasis></literal> that matched the given label
selector.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>deploymentConfig</literal>
<literal>--selector="name=registry"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>&lt;object_type&gt;</emphasis> --all</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Selects all resources of type <literal><emphasis>&lt;object_type&gt;</emphasis></literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>deploymentConfig --all</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-f</literal> or
<literal>--filename=<emphasis>&lt;file_name&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>File name, directory, or URL to file to use to edit the resource.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>-f registry-deployment-config.json</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<variablelist>
<varlistentry>
<term>Operation</term>
<listitem>
<simpara>Specify <literal>--add</literal> or <literal>--remove</literal> for the <literal>operation</literal> parameter in the <literal>oc set volume</literal> command.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Mandatory parameters</term>
<listitem>
<simpara>Any mandatory parameters are specific to the
selected operation and are discussed in later sections.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Options</term>
<listitem>
<simpara>Any options are specific to the
selected operation and are discussed in later sections.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-containers-volumes-listing_nodes-containers-volumes">
<title>Listing volumes and volume mounts in a pod</title>
<simpara>You can list volumes and volume mounts in pods or pod templates:</simpara>
<formalpara>
<title>Procedure</title>
<para>To list volumes:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume &lt;object_type&gt;/&lt;name&gt; [options]</programlisting>
<simpara>List volume supported options:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the volume.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-c, --containers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Select containers by name. It can also take wildcard <literal>'*'</literal> that matches any
character.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>'*'</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>To list all volumes for pod <emphasis role="strong">p1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume pod/p1</programlisting>
</listitem>
<listitem>
<simpara>To list volume <emphasis role="strong">v1</emphasis> defined on all deployment configs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume dc --all --name=v1</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-volumes-adding_nodes-containers-volumes">
<title>Adding volumes to a pod</title>
<simpara>You can add volumes and volume mounts to a pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>To add a volume, a volume mount, or both to pod templates:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume &lt;object_type&gt;/&lt;name&gt; --add [options]</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Supported Options for Adding Volumes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the volume.</simpara></entry>
<entry align="left" valign="top"><simpara>Automatically generated, if not specified.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-t, --type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the volume source. Supported values: <literal>emptyDir</literal>, <literal>hostPath</literal>, <literal>secret</literal>,
<literal>configmap</literal>, <literal>persistentVolumeClaim</literal> or <literal>projected</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>emptyDir</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-c, --containers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Select containers by name. It can also take wildcard <literal>'*'</literal> that matches any
character.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>'*'</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-m, --mount-path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mount path inside the selected containers. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host path. Mandatory parameter for <literal>--type=hostPath</literal>. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--secret-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the secret. Mandatory parameter for <literal>--type=secret</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--configmap-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the configmap. Mandatory parameter for <literal>--type=configmap</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--claim-name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the persistent volume claim. Mandatory parameter for
<literal>--type=persistentVolumeClaim</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--source</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Details of volume source as a JSON string. Recommended if the desired volume
source is not supported by <literal>--type</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-o, --output</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display the modified objects instead of updating them on the server. Supported
values: <literal>json</literal>, <literal>yaml</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--output-version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output the modified objects with the given version.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>api-version</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>To add a new volume source <emphasis role="strong">emptyDir</emphasis> to the <emphasis role="strong">registry</emphasis> <literal>DeploymentConfig</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume dc/registry --add</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the volume:</simpara>
<example>
<title>Sample deployment config with an added volume</title>
<programlisting language="yaml" linenumbering="unnumbered">kind: DeploymentConfig
apiVersion: apps.openshift.io/v1
metadata:
  name: registry
  namespace: registry
spec:
  replicas: 3
  selector:
    app: httpd
  template:
    metadata:
      labels:
        app: httpd
    spec:
      volumes: <co xml:id="CO144-1"/>
        - name: volume-pppsw
          emptyDir: {}
      containers:
        - name: httpd
          image: &gt;-
            image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest
          ports:
            - containerPort: 8080
              protocol: TCP</programlisting>
<calloutlist>
<callout arearefs="CO144-1">
<para>Add the volume source <emphasis role="strong">emptyDir</emphasis>.</para>
</callout>
</calloutlist>
</example>
</tip>
</listitem>
<listitem>
<simpara>To add volume <emphasis role="strong">v1</emphasis> with secret <emphasis role="strong">secret1</emphasis> for replication controller <emphasis role="strong">r1</emphasis> and mount
inside the containers at <emphasis role="strong"><emphasis>/data</emphasis></emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume rc/r1 --add --name=v1 --type=secret --secret-name='secret1' --mount-path=/data</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the volume:</simpara>
<example>
<title>Sample replication controller with added volume and secret</title>
<programlisting language="yaml" linenumbering="unnumbered">kind: ReplicationController
apiVersion: v1
metadata:
  name: example-1
  namespace: example
spec:
  replicas: 0
  selector:
    app: httpd
    deployment: example-1
    deploymentconfig: example
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: httpd
        deployment: example-1
        deploymentconfig: example
    spec:
      volumes: <co xml:id="CO145-1"/>
        - name: v1
          secret:
            secretName: secret1
            defaultMode: 420
      containers:
        - name: httpd
          image: &gt;-
            image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest
          volumeMounts: <co xml:id="CO145-2"/>
            - name: v1
              mountPath: /data</programlisting>
<calloutlist>
<callout arearefs="CO145-1">
<para>Add the volume and secret.</para>
</callout>
<callout arearefs="CO145-2">
<para>Add the container mount path.</para>
</callout>
</calloutlist>
</example>
</tip>
</listitem>
<listitem>
<simpara>To add existing persistent volume <emphasis role="strong">v1</emphasis> with claim name <emphasis role="strong">pvc1</emphasis> to deployment
configuration <emphasis role="strong"><emphasis>dc.json</emphasis></emphasis> on disk, mount the volume on container <emphasis role="strong">c1</emphasis> at
<emphasis role="strong"><emphasis>/data</emphasis></emphasis>, and update the <literal>DeploymentConfig</literal> object on the server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume -f dc.json --add --name=v1 --type=persistentVolumeClaim \
  --claim-name=pvc1 --mount-path=/data --containers=c1</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the volume:</simpara>
<example>
<title>Sample deployment config with persistent volume added</title>
<programlisting language="yaml" linenumbering="unnumbered">kind: DeploymentConfig
apiVersion: apps.openshift.io/v1
metadata:
  name: example
  namespace: example
spec:
  replicas: 3
  selector:
    app: httpd
  template:
    metadata:
      labels:
        app: httpd
    spec:
      volumes:
        - name: volume-pppsw
          emptyDir: {}
        - name: v1 <co xml:id="CO146-1"/>
          persistentVolumeClaim:
            claimName: pvc1
      containers:
        - name: httpd
          image: &gt;-
            image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest
          ports:
            - containerPort: 8080
              protocol: TCP
          volumeMounts: <co xml:id="CO146-2"/>
            - name: v1
              mountPath: /data</programlisting>
<calloutlist>
<callout arearefs="CO146-1">
<para>Add the persistent volume claim named `pvc1.</para>
</callout>
<callout arearefs="CO146-2">
<para>Add the container mount path.</para>
</callout>
</calloutlist>
</example>
</tip>
</listitem>
<listitem>
<simpara>To add a volume <emphasis role="strong">v1</emphasis> based on Git repository
<emphasis role="strong">https://github.com/namespace1/project1</emphasis> with revision <emphasis role="strong">5125c45f9f563</emphasis> for
all replication controllers:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume rc --all --add --name=v1 \
  --source='{"gitRepo": {
                "repository": "https://github.com/namespace1/project1",
                "revision": "5125c45f9f563"
            }}'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-volumes-updating_nodes-containers-volumes">
<title>Updating volumes and volume mounts in a pod</title>
<simpara>You can modify the volumes and volume mounts in a pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>Updating existing volumes using the <literal>--overwrite</literal> option:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume &lt;object_type&gt;/&lt;name&gt; --add --overwrite [options]</programlisting>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>To replace existing volume <emphasis role="strong">v1</emphasis> for replication controller <emphasis role="strong">r1</emphasis> with existing
persistent volume claim <emphasis role="strong">pvc1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume rc/r1 --add --overwrite --name=v1 --type=persistentVolumeClaim --claim-name=pvc1</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to replace the volume:</simpara>
<example>
<title>Sample replication controller with persistent volume claim named <literal>pvc1</literal></title>
<programlisting language="yaml" linenumbering="unnumbered">kind: ReplicationController
apiVersion: v1
metadata:
  name: example-1
  namespace: example
spec:
  replicas: 0
  selector:
    app: httpd
    deployment: example-1
    deploymentconfig: example
  template:
    metadata:
      labels:
        app: httpd
        deployment: example-1
        deploymentconfig: example
    spec:
      volumes:
        - name: v1 <co xml:id="CO147-1"/>
          persistentVolumeClaim:
            claimName: pvc1
      containers:
        - name: httpd
          image: &gt;-
            image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest
          ports:
            - containerPort: 8080
              protocol: TCP
          volumeMounts:
            - name: v1
              mountPath: /data</programlisting>
<calloutlist>
<callout arearefs="CO147-1">
<para>Set persistent volume claim to <literal>pvc1</literal>.</para>
</callout>
</calloutlist>
</example>
</tip>
</listitem>
<listitem>
<simpara>To change the <literal>DeploymentConfig</literal> object <emphasis role="strong">d1</emphasis> mount point to <emphasis role="strong"><emphasis>/opt</emphasis></emphasis> for volume <emphasis role="strong">v1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume dc/d1 --add --overwrite --name=v1 --mount-path=/opt</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to change the mount point:</simpara>
<example>
<title>Sample deployment config with mount point set to <literal>opt</literal>.</title>
<programlisting language="yaml" linenumbering="unnumbered">kind: DeploymentConfig
apiVersion: apps.openshift.io/v1
metadata:
  name: example
  namespace: example
spec:
  replicas: 3
  selector:
    app: httpd
  template:
    metadata:
      labels:
        app: httpd
    spec:
      volumes:
        - name: volume-pppsw
          emptyDir: {}
        - name: v2
          persistentVolumeClaim:
            claimName: pvc1
        - name: v1
          persistentVolumeClaim:
            claimName: pvc1
      containers:
        - name: httpd
          image: &gt;-
            image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest
          ports:
            - containerPort: 8080
              protocol: TCP
          volumeMounts: <co xml:id="CO148-1"/>
            - name: v1
              mountPath: /opt</programlisting>
<calloutlist>
<callout arearefs="CO148-1">
<para>Set the mount point to <literal>/opt</literal>.</para>
</callout>
</calloutlist>
</example>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-volumes-removing_nodes-containers-volumes">
<title>Removing volumes and volume mounts from a pod</title>
<simpara>You can remove a volume or volume mount from a pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>To remove a volume from pod templates:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume &lt;object_type&gt;/&lt;name&gt; --remove [options]</programlisting>
<table frame="all" rowsep="1" colsep="1">
<title>Supported options for removing volumes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Option</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the volume.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-c, --containers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Select containers by name. It can also take wildcard <literal>'*'</literal> that matches any character.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>'*'</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--confirm</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicate that you want to remove multiple volumes at once.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-o, --output</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display the modified objects instead of updating them on the server. Supported values: <literal>json</literal>, <literal>yaml</literal>.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--output-version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output the modified objects with the given version.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>api-version</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>To remove a volume <emphasis role="strong">v1</emphasis> from the <literal>DeploymentConfig</literal> object <emphasis role="strong">d1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume dc/d1 --remove --name=v1</programlisting>
</listitem>
<listitem>
<simpara>To unmount volume <emphasis role="strong">v1</emphasis> from container <emphasis role="strong">c1</emphasis> for the <literal>DeploymentConfig</literal> object <emphasis role="strong">d1</emphasis> and remove the volume <emphasis role="strong">v1</emphasis> if it is not referenced by any containers on <emphasis role="strong">d1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume dc/d1 --remove --name=v1 --containers=c1</programlisting>
</listitem>
<listitem>
<simpara>To remove all volumes for replication controller <emphasis role="strong">r1</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set volume rc/r1 --remove --confirm</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-volumes-subpath_nodes-containers-volumes">
<title>Configuring volumes for multiple uses in a pod</title>
<simpara>You can configure a volume to allows you to share one volume for
multiple uses in a single pod using the <literal>volumeMounts.subPath</literal> property to specify a <literal>subPath</literal> value inside a volume
instead of the volume&#8217;s root.</simpara>
<note>
<simpara>You cannot add a <literal>subPath</literal> parameter to an existing scheduled pod.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To view the list of files in the volume, run the <literal>oc rsh</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh &lt;pod&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2$ ls /path/to/volume/subpath/mount
example_file1 example_file2 example_file3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Specify the <literal>subPath</literal>:</simpara>
<formalpara>
<title>Example <literal>Pod</literal> spec with <literal>subPath</literal> parameter</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: my-site
spec:
    containers:
    - name: mysql
      image: mysql
      volumeMounts:
      - mountPath: /var/lib/mysql
        name: site-data
        subPath: mysql <co xml:id="CO149-1"/>
    - name: php
      image: php
      volumeMounts:
      - mountPath: /var/www/html
        name: site-data
        subPath: html <co xml:id="CO149-2"/>
    volumes:
    - name: site-data
      persistentVolumeClaim:
        claimName: my-site-data</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO149-1">
<para>Databases are stored in the <literal>mysql</literal> folder.</para>
</callout>
<callout arearefs="CO149-2">
<para>HTML content is stored in the <literal>html</literal> folder.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-containers-projected-volumes">
<title>Mapping volumes using projected volumes</title>

<simpara>A <emphasis>projected volume</emphasis> maps several existing volume sources into the same directory.</simpara>
<simpara>The following types of volume sources can be projected:</simpara>
<itemizedlist>
<listitem>
<simpara>Secrets</simpara>
</listitem>
<listitem>
<simpara>Config Maps</simpara>
</listitem>
<listitem>
<simpara>Downward API</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>All sources are required to be in the same namespace as the pod.</simpara>
</note>
<section xml:id="nodes-containers-projected-volumes-about_nodes-containers-projected-volumes">
<title>Understanding projected volumes</title>
<simpara>Projected volumes can map any combination of these volume sources into a single directory, allowing the user to:</simpara>
<itemizedlist>
<listitem>
<simpara>automatically populate a single volume with the keys from multiple secrets, config maps, and with downward API information,
so that I can synthesize a single directory with various sources of information;</simpara>
</listitem>
<listitem>
<simpara>populate a single volume with the keys from multiple secrets, config maps, and with downward API information,
explicitly specifying paths for each item, so that I can have full control over the contents of that volume.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>When the <literal>RunAsUser</literal> permission is set in the security context of a Linux-based pod, the projected files have the correct permissions set, including container user ownership. However, when the Windows equivalent <literal>RunAsUsername</literal> permission is set in a Windows pod, the kubelet is unable to correctly set ownership on the files in the projected volume.</simpara>
<simpara>Therefore, the <literal>RunAsUsername</literal> permission set in the security context of a Windows pod is not honored for Windows projected volumes running in {product-title}.</simpara>
</important>
<simpara>The following general scenarios show how you can use projected volumes.</simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">Config map, secrets, Downward API.</emphasis></term>
<listitem>
<simpara>Projected volumes allow you to deploy containers with configuration data that includes passwords.
An application using these resources could be deploying Red Hat OpenStack Platform (RHOSP) on Kubernetes. The configuration data might have to be assembled differently depending on if the services are going to be used for production or for testing. If a pod is labeled with production or testing, the downward API selector <literal>metadata.labels</literal> can be used to produce the correct RHOSP configs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Config map + secrets.</emphasis></term>
<listitem>
<simpara>Projected volumes allow you to deploy containers involving configuration data and passwords.
For example, you might execute a config map with some sensitive encrypted tasks that are decrypted using a vault password file.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">ConfigMap + Downward API.</emphasis></term>
<listitem>
<simpara>Projected volumes allow you to generate a config including the pod name (available via the <literal>metadata.name</literal> selector). This application can then pass the pod name along with requests to easily determine the source without using IP tracking.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Secrets + Downward API.</emphasis></term>
<listitem>
<simpara>Projected volumes allow you to use a secret as a public key to encrypt the namespace of the pod (available via the <literal>metadata.namespace</literal> selector).
This example allows the Operator to use the application to deliver the namespace information securely without using an encrypted transport.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="projected-volumes-examples_nodes-containers-projected-volumes">
<title>Example Pod specs</title>
<simpara>The following are examples of <literal>Pod</literal> specs for creating projected volumes.</simpara>
<formalpara>
<title>Pod with a secret, a Downward API, and a config map</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox
    volumeMounts: <co xml:id="CO150-1"/>
    - name: all-in-one
      mountPath: "/projected-volume"<co xml:id="CO150-2"/>
      readOnly: true <co xml:id="CO150-3"/>
  volumes: <co xml:id="CO150-4"/>
  - name: all-in-one <co xml:id="CO150-5"/>
    projected:
      defaultMode: 0400 <co xml:id="CO150-6"/>
      sources:
      - secret:
          name: mysecret <co xml:id="CO150-7"/>
          items:
            - key: username
              path: my-group/my-username <co xml:id="CO150-8"/>
      - downwardAPI: <co xml:id="CO150-9"/>
          items:
            - path: "labels"
              fieldRef:
                fieldPath: metadata.labels
            - path: "cpu_limit"
              resourceFieldRef:
                containerName: container-test
                resource: limits.cpu
      - configMap: <co xml:id="CO150-10"/>
          name: myconfigmap
          items:
            - key: config
              path: my-group/my-config
              mode: 0777 <co xml:id="CO150-11"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO150-1">
<para>Add a <literal>volumeMounts</literal> section for each container that needs the secret.</para>
</callout>
<callout arearefs="CO150-2">
<para>Specify a path to an unused directory where the secret will appear.</para>
</callout>
<callout arearefs="CO150-3">
<para>Set <literal>readOnly</literal> to <literal>true</literal>.</para>
</callout>
<callout arearefs="CO150-4">
<para>Add a <literal>volumes</literal> block to list each projected volume source.</para>
</callout>
<callout arearefs="CO150-5">
<para>Specify any name for the volume.</para>
</callout>
<callout arearefs="CO150-6">
<para>Set the execute permission on the files.</para>
</callout>
<callout arearefs="CO150-7">
<para>Add a secret. Enter the name of the secret object. Each secret you want to use must be listed.</para>
</callout>
<callout arearefs="CO150-8">
<para>Specify the path to the secrets file under the <literal>mountPath</literal>. Here, the secrets file is in <emphasis role="strong"><emphasis>/projected-volume/my-group/my-username</emphasis></emphasis>.</para>
</callout>
<callout arearefs="CO150-9">
<para>Add a Downward API source.</para>
</callout>
<callout arearefs="CO150-10">
<para>Add a ConfigMap source.</para>
</callout>
<callout arearefs="CO150-11">
<para>Set the mode for the specific projection</para>
</callout>
</calloutlist>
<note>
<simpara>If there are multiple containers in the pod, each container needs a <literal>volumeMounts</literal> section, but only one <literal>volumes</literal> section is needed.</simpara>
</note>
<formalpara>
<title>Pod with multiple secrets with a non-default permission mode set</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox
    volumeMounts:
    - name: all-in-one
      mountPath: "/projected-volume"
      readOnly: true
  volumes:
  - name: all-in-one
    projected:
      defaultMode: 0755
      sources:
      - secret:
          name: mysecret
          items:
            - key: username
              path: my-group/my-username
      - secret:
          name: mysecret2
          items:
            - key: password
              path: my-group/my-password
              mode: 511</programlisting>
</para>
</formalpara>
<note>
<simpara>The <literal>defaultMode</literal> can only be specified at the projected level and not for each
volume source. However, as illustrated above, you can explicitly set the <literal>mode</literal>
for each individual projection.</simpara>
</note>
</section>
<section xml:id="projected-volumes-pathing_nodes-containers-projected-volumes">
<title>Pathing Considerations</title>
<variablelist>
<varlistentry>
<term><emphasis role="strong">Collisions Between Keys when Configured Paths are Identical</emphasis></term>
<listitem>
<simpara>If you configure any keys with the same path, the pod spec will not be accepted as valid.
In the following example, the specified path for <literal>mysecret</literal> and <literal>myconfigmap</literal> are the same:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox
    volumeMounts:
    - name: all-in-one
      mountPath: "/projected-volume"
      readOnly: true
  volumes:
  - name: all-in-one
    projected:
      sources:
      - secret:
          name: mysecret
          items:
            - key: username
              path: my-group/data
      - configMap:
          name: myconfigmap
          items:
            - key: config
              path: my-group/data</programlisting>
</listitem>
</varlistentry>
</variablelist>
<simpara>Consider the following situations related to the volume file paths.</simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">Collisions Between Keys without Configured Paths</emphasis></term>
<listitem>
<simpara>The only run-time validation that can occur is when all the paths are known at pod creation, similar to the above scenario. Otherwise, when a conflict occurs the most recent specified resource will overwrite anything preceding it
(this is true for resources that are updated after pod creation as well).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Collisions when One Path is Explicit and the Other is Automatically Projected</emphasis></term>
<listitem>
<simpara>In the event that there is a collision due to a user specified path matching data that is automatically projected,
the latter resource will overwrite anything preceding it as before</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="nodes-containers-projected-volumes-creating_nodes-containers-projected-volumes">
<title>Configuring a Projected Volume for a Pod</title>
<simpara>When creating projected volumes, consider the volume file path situations described in <emphasis>Understanding projected volumes</emphasis>.</simpara>
<simpara>The following example shows how to use a projected volume to mount an existing secret volume source. The steps can be used to create a user name and password secrets from local files. You then create a pod that runs one container, using a projected volume to mount the secrets into the same shared directory.</simpara>
<simpara>The user name and password values can be any valid string that is <emphasis role="strong">base64</emphasis> encoded.</simpara>
<simpara>The following example shows <literal>admin</literal> in base64:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo -n "admin" | base64</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">YWRtaW4=</programlisting>
</para>
</formalpara>
<simpara>The following example shows the password <literal>1f2d1e2e67df</literal> in base64:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo -n "1f2d1e2e67df" | base64</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">MWYyZDFlMmU2N2Rm</programlisting>
</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>To use a projected volume to mount an existing secret volume source.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the secret:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following, replacing the password and user information as appropriate:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  pass: MWYyZDFlMmU2N2Rm
  user: YWRtaW4=</programlisting>
</listitem>
<listitem>
<simpara>Use the following command to create the secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;secrets-filename&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">secret "mysecret" created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can check that the secret was created using the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;secret-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret mysecret</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       TYPE      DATA      AGE
mysecret   Opaque    2         17h</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;secret-name&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret mysecret -o yaml</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  pass: MWYyZDFlMmU2N2Rm
  user: YWRtaW4=
kind: Secret
metadata:
  creationTimestamp: 2017-05-30T20:21:38Z
  name: mysecret
  namespace: default
  resourceVersion: "2107"
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: 959e0424-4575-11e7-9f97-fa163e4bd54c
type: Opaque</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a pod with a projected volume.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following, including a <literal>volumes</literal> section:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
metadata:
  name: test-projected-volume
spec:
  containers:
  - name: test-projected-volume
    image: busybox
    args:
    - sleep
    - "86400"
    volumeMounts:
    - name: all-in-one
      mountPath: "/projected-volume"
      readOnly: true
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
  volumes:
  - name: all-in-one
    projected:
      sources:
      - secret:
          name: mysecret <co xml:id="CO151-1"/></programlisting>
<calloutlist>
<callout arearefs="CO151-1">
<para>The name of the secret you created.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod from the configuration file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;your_yaml_file&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret-pod.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">pod "test-projected-volume" created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify that the pod container is running, and then watch for changes to
the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test-projected-volume</programlisting>
<simpara>The output should appear similar to the following:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>In another terminal, use the <literal>oc exec</literal> command to open a shell to the running container:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it &lt;pod&gt; &lt;command&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec -it test-projected-volume -- /bin/sh</programlisting>
</listitem>
<listitem>
<simpara>In your shell, verify that the <literal>projected-volumes</literal> directory contains your projected sources:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/ # ls</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">bin               home              root              tmp
dev               proc              run               usr
etc               projected-volume  sys               var</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-containers-downward-api">
<title>Allowing containers to consume API objects</title>

<simpara>The <emphasis>Downward API</emphasis> is a mechanism that allows containers to consume information
about API objects without coupling to {product-title}.
Such information includes the pod&#8217;s name, namespace, and resource values.
Containers can consume information from the downward API using environment
variables or a volume plugin.</simpara>
<section xml:id="nodes-containers-projected-volumes-about_nodes-containers-downward-api">
<title>Expose pod information to Containers using the Downward API</title>
<simpara>The Downward API contains such information as the pod&#8217;s name, project, and resource values. Containers can consume
information from the downward API using environment variables or a volume
plugin.</simpara>
<simpara>Fields within the pod are selected using the <literal>FieldRef</literal> API type. <literal>FieldRef</literal>
has two fields:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>fieldPath</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The path of the field to select, relative to the pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The API version to interpret the <literal>fieldPath</literal> selector within.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Currently, the valid selectors in the v1 API include:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Selector</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s name. This is supported in both environment variables and volumes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s namespace.This is supported in both environment variables and volumes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.labels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s labels. This is only supported in volumes and not in environment variables.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s annotations. This is only supported in volumes and not in environment variables.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>status.podIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s IP. This is only supported in environment variables and not volumes.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>apiVersion</literal> field, if not specified, defaults to the API version of the
enclosing pod template.</simpara>
</section>
<section xml:id="nodes-containers-downward-api-container-values_nodes-containers-downward-api">
<title>Understanding how to consume container values using the downward API</title>
<simpara>You containers can consume API values using environment variables or a volume plugin.
Depending on the method you choose, containers can consume:</simpara>
<itemizedlist>
<listitem>
<simpara>Pod name</simpara>
</listitem>
<listitem>
<simpara>Pod project/namespace</simpara>
</listitem>
<listitem>
<simpara>Pod annotations</simpara>
</listitem>
<listitem>
<simpara>Pod labels</simpara>
</listitem>
</itemizedlist>
<simpara>Annotations and labels are available using only a volume plugin.</simpara>
<section xml:id="nodes-containers-downward-api-container-values-envars_nodes-containers-downward-api">
<title>Consuming container values using environment variables</title>
<simpara>When using a container&#8217;s environment variables, use the <literal>EnvVar</literal> type&#8217;s <literal>valueFrom</literal> field (of type <literal>EnvVarSource</literal>)
to specify that the variable&#8217;s value should come from a <literal>FieldRef</literal>
source instead of the literal value specified by the <literal>value</literal> field.</simpara>
<simpara>Only constant attributes of the pod can be consumed this way, as environment
variables cannot be updated once a process is started in a way that allows the
process to be notified that the value of a variable has changed. The fields
supported using environment variables are:</simpara>
<itemizedlist>
<listitem>
<simpara>Pod name</simpara>
</listitem>
<listitem>
<simpara>Pod project/namespace</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new pod spec that contains the environment variables you want the container to consume:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: env-test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: MY_POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: MY_POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
  restartPolicy: Never
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs for the <literal>MY_POD_NAME</literal> and <literal>MY_POD_NAMESPACE</literal>
values:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-env-test-pod</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-downward-api-container-values-plugin_nodes-containers-downward-api">
<title>Consuming container values using a volume plugin</title>
<simpara>You containers can consume API values using a volume plugin.</simpara>
<simpara>Containers can consume:</simpara>
<itemizedlist>
<listitem>
<simpara>Pod name</simpara>
</listitem>
<listitem>
<simpara>Pod project/namespace</simpara>
</listitem>
<listitem>
<simpara>Pod annotations</simpara>
</listitem>
<listitem>
<simpara>Pod labels</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To use the volume plugin:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a new pod spec that contains the environment variables you want the container to consume:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>volume-pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  labels:
    zone: us-east-coast
    cluster: downward-api-test-cluster1
    rack: rack-123
  name: dapi-volume-test-pod
  annotations:
    annotation1: "345"
    annotation2: "456"
spec:
  containers:
    - name: volume-test-container
      image: gcr.io/google_containers/busybox
      command: ["sh", "-c", "cat /tmp/etc/pod_labels /tmp/etc/pod_annotations"]
      volumeMounts:
        - name: podinfo
          mountPath: /tmp/etc
          readOnly: false
  volumes:
  - name: podinfo
    downwardAPI:
      defaultMode: 420
      items:
      - fieldRef:
          fieldPath: metadata.name
        path: pod_name
      - fieldRef:
          fieldPath: metadata.namespace
        path: pod_namespace
      - fieldRef:
          fieldPath: metadata.labels
        path: pod_labels
      - fieldRef:
          fieldPath: metadata.annotations
        path: pod_annotations
  restartPolicy: Never
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>volume-pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f volume-pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs and verify the presence of the configured fields:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-volume-test-pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">cluster=downward-api-test-cluster1
rack=rack-123
zone=us-east-coast
annotation1=345
annotation2=456
kubernetes.io/config.source=api</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-containers-downward-api-container-resources-api_nodes-containers-downward-api">
<title>Understanding how to consume container resources using the Downward API</title>
<simpara>When creating pods, you can use the Downward API to inject information about
computing resource requests and limits so that image and application authors can
correctly create an image for specific environments.</simpara>
<simpara>You can do this using environment variable or a volume plugin.</simpara>
<section xml:id="nodes-containers-downward-api-container-resources-envars_nodes-containers-downward-api">
<title>Consuming container resources using environment variables</title>
<simpara>When creating pods, you can use the Downward API to inject information about
computing resource requests and limits using environment variables.</simpara>
<simpara>When creating the pod configuration, specify environment variables that
correspond to the contents of the <literal>resources</literal> field in the <literal><emphasis role="strong">spec.container</emphasis></literal>
field.</simpara>
<note>
<simpara>If the resource limits are not included in the container configuration, the
downward API defaults to the node&#8217;s CPU and memory allocatable values.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new pod spec that contains the resources you want to inject:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: test-container
      image: gcr.io/google_containers/busybox:1.24
      command: [ "/bin/sh", "-c", "env" ]
      resources:
        requests:
          memory: "32Mi"
          cpu: "125m"
        limits:
          memory: "64Mi"
          cpu: "250m"
      env:
        - name: MY_CPU_REQUEST
          valueFrom:
            resourceFieldRef:
              resource: requests.cpu
        - name: MY_CPU_LIMIT
          valueFrom:
            resourceFieldRef:
              resource: limits.cpu
        - name: MY_MEM_REQUEST
          valueFrom:
            resourceFieldRef:
              resource: requests.memory
        - name: MY_MEM_LIMIT
          valueFrom:
            resourceFieldRef:
              resource: limits.memory
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-containers-downward-api-container-resources-plugin_nodes-containers-downward-api">
<title>Consuming container resources using a volume plugin</title>
<simpara>When creating pods, you can use the Downward API to inject information about
computing resource requests and limits using a volume plugin.</simpara>
<simpara>When creating the pod configuration, use the <literal>spec.volumes.downwardAPI.items</literal>
field to describe the desired resources that correspond to the
<literal>spec.resources</literal> field.</simpara>
<note>
<simpara>If the resource limits are not included in the container configuration, the
Downward API defaults to the node&#8217;s CPU and memory allocatable values.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new pod spec that contains the resources you want to inject:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: client-container
      image: gcr.io/google_containers/busybox:1.24
      command: ["sh", "-c", "while true; do echo; if [[ -e /etc/cpu_limit ]]; then cat /etc/cpu_limit; fi; if [[ -e /etc/cpu_request ]]; then cat /etc/cpu_request; fi; if [[ -e /etc/mem_limit ]]; then cat /etc/mem_limit; fi; if [[ -e /etc/mem_request ]]; then cat /etc/mem_request; fi; sleep 5; done"]
      resources:
        requests:
          memory: "32Mi"
          cpu: "125m"
        limits:
          memory: "64Mi"
          cpu: "250m"
      volumeMounts:
        - name: podinfo
          mountPath: /etc
          readOnly: false
  volumes:
    - name: podinfo
      downwardAPI:
        items:
          - path: "cpu_limit"
            resourceFieldRef:
              containerName: client-container
              resource: limits.cpu
          - path: "cpu_request"
            resourceFieldRef:
              containerName: client-container
              resource: requests.cpu
          - path: "mem_limit"
            resourceFieldRef:
              containerName: client-container
              resource: limits.memory
          - path: "mem_request"
            resourceFieldRef:
              containerName: client-container
              resource: requests.memory
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal><emphasis role="strong"><emphasis>volume-pod.yaml</emphasis></emphasis></literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f volume-pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-containers-downward-api-container-secrets_nodes-containers-downward-api">
<title>Consuming secrets using the Downward API</title>
<simpara>When creating pods, you can use the downward API to inject secrets
so image and application authors can create an image
for specific environments.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a secret to inject:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>secret.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: mysecret
data:
  password: &lt;password&gt;
  username: &lt;username&gt;
type: kubernetes.io/basic-auth</programlisting>
</listitem>
<listitem>
<simpara>Create the secret object from the <literal>secret.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f secret.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a pod that references the <literal>username</literal> field from the above <literal>Secret</literal> object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: env-test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: MY_SECRET_USERNAME
          valueFrom:
            secretKeyRef:
              name: mysecret
              key: username
  restartPolicy: Never
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs for the <literal>MY_SECRET_USERNAME</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-env-test-pod</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-downward-api-container-configmaps_nodes-containers-downward-api">
<title>Consuming configuration maps using the Downward API</title>
<simpara>When creating pods, you can use the Downward API to inject configuration map values
so image and application authors can create an image for specific environments.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a config map with the values to inject:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal><emphasis role="strong"><emphasis>configmap.yaml</emphasis></emphasis></literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: myconfigmap
data:
  mykey: myvalue</programlisting>
</listitem>
<listitem>
<simpara>Create the config map from the <literal>configmap.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f configmap.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a pod that references the above config map:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: env-test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: MY_CONFIGMAP_VALUE
          valueFrom:
            configMapKeyRef:
              name: myconfigmap
              key: mykey
  restartPolicy: Always
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal>pod.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs for the <literal>MY_CONFIGMAP_VALUE</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-env-test-pod</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-downward-api-container-envars_nodes-containers-downward-api">
<title>Referencing environment variables</title>
<simpara>When creating pods, you can reference the value of a previously defined
environment variable by using the <literal>$()</literal> syntax. If the environment variable
reference can not be resolved, the value will be left as the provided
string.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod that references an existing environment variable:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: env-test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: MY_EXISTING_ENV
          value: my_value
        - name: MY_ENV_VAR_REF_ENV
          value: $(MY_EXISTING_ENV)
  restartPolicy: Never
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal><emphasis role="strong"><emphasis>pod.yaml</emphasis></emphasis></literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs for the <literal>MY_ENV_VAR_REF_ENV</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-env-test-pod</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-downward-api-container-escaping_nodes-containers-downward-api">
<title>Escaping environment variable references</title>
<simpara>When creating a pod, you can escape an environment variable reference by using
a double dollar sign. The value will then be set to a single dollar sign version
of the provided value.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a pod that references an existing environment variable:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>pod.yaml</literal> file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: dapi-env-test-pod
spec:
  containers:
    - name: env-test-container
      image: gcr.io/google_containers/busybox
      command: [ "/bin/sh", "-c", "env" ]
      env:
        - name: MY_NEW_ENV
          value: $$(SOME_OTHER_ENV)
  restartPolicy: Never
# ...</programlisting>
</listitem>
<listitem>
<simpara>Create the pod from the <literal><emphasis role="strong"><emphasis>pod.yaml</emphasis></emphasis></literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check the container&#8217;s logs for the <literal>MY_NEW_ENV</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -p dapi-env-test-pod</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-containers-copying-files">
<title>Copying files to or from an {product-title} container</title>

<simpara>You can use the CLI to copy local files to or from a remote directory in a container
using the <literal>rsync</literal> command.</simpara>
<section xml:id="nodes-containers-copying-files-about_nodes-containers-copying-files">
<title>Understanding how to copy files</title>
<simpara>The <literal>oc rsync</literal> command, or remote sync, is a useful tool for copying database archives to and from your pods for backup and restore purposes.
You can also use <literal>oc rsync</literal> to copy source code changes into a running pod for development debugging, when the running pod supports hot reload of source files.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsync &lt;source&gt; &lt;destination&gt; [-c &lt;container&gt;]</programlisting>
<section xml:id="_requirements">
<title>Requirements</title>
<variablelist>
<varlistentry>
<term>Specifying the Copy Source</term>
<listitem>
<simpara>The source argument of the <literal>oc rsync</literal> command must point to either a local
directory or a pod directory. Individual files are not supported.</simpara>
<simpara>When specifying a pod directory the directory name must be prefixed with the pod
name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">&lt;pod name&gt;:&lt;dir&gt;</programlisting>
<simpara>If the directory name ends in a path separator (<literal>/</literal>), only the contents of the directory are copied to the destination. Otherwise, the
directory and its contents are copied to the destination.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Specifying the Copy Destination</term>
<listitem>
<simpara>The destination argument of the <literal>oc rsync</literal> command must point to a directory. If
the directory does not exist, but <literal>rsync</literal> is used for copy, the directory is
created for you.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deleting Files at the Destination</term>
<listitem>
<simpara>The <literal>--delete</literal> flag may be used to delete any files in the remote directory that
are not in the local directory.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Continuous Syncing on File Change</term>
<listitem>
<simpara>Using the <literal>--watch</literal> option causes the command to monitor the source path for any
file system changes, and synchronizes changes when they occur. With this
argument, the command runs forever.</simpara>
<simpara>Synchronization occurs after short quiet periods to ensure a
rapidly changing file system does not result in continuous synchronization
calls.</simpara>
<simpara>When using the <literal>--watch</literal> option, the behavior is effectively the same as
manually invoking <literal>oc rsync</literal> repeatedly, including any arguments normally passed
to <literal>oc rsync</literal>. Therefore, you can control the behavior via the same flags used
with manual invocations of <literal>oc rsync</literal>, such as <literal>--delete</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="nodes-containers-copying-files-procedure_nodes-containers-copying-files">
<title>Copying files to and from containers</title>
<simpara>Support for copying local files to or from a container is built into the CLI.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>When working with <literal>oc rsync</literal>, note the following:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>rsync must be installed. The <literal>oc rsync</literal> command uses the local <literal>rsync</literal> tool, if present on the client
machine and the remote container.</simpara>
<simpara>If <literal>rsync</literal> is not found locally or in the remote container, a <emphasis role="strong">tar</emphasis> archive
is created locally and sent to the container where the <emphasis role="strong">tar</emphasis> utility is used to
extract the files. If <emphasis role="strong">tar</emphasis> is not available in the remote container, the
copy will fail.</simpara>
<simpara>The <emphasis role="strong">tar</emphasis> copy method does not provide the same functionality as <literal>oc rsync</literal>. For
example, <literal>oc rsync</literal> creates the destination directory if it does not exist and
only sends files that are different between the source and the destination.</simpara>
<note>
<simpara>In Windows, the <literal>cwRsync</literal> client should be installed and added to the PATH for
use with the <literal>oc rsync</literal> command.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To copy a local directory to a pod directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsync &lt;local-dir&gt; &lt;pod-name&gt;:/&lt;remote-dir&gt; -c &lt;container-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsync /home/user/source devpod1234:/src -c user-container</programlisting>
</listitem>
<listitem>
<simpara>To copy a pod directory to a local directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsync devpod1234:/src /home/user/source</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsync devpod1234:/src/status.txt /home/user/</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-copying-files-rsync_nodes-containers-copying-files">
<title>Using advanced Rsync features</title>
<simpara>The <literal>oc rsync</literal> command exposes fewer command line options than standard <literal>rsync</literal>.
In the case that you want to use a standard <literal>rsync</literal> command line option that is
not available in <literal>oc rsync</literal>, for example the <literal>--exclude-from=FILE</literal> option, it
might be possible to use standard <literal>rsync</literal> 's <literal>--rsh</literal> (<literal>-e</literal>) option or <literal>RSYNC_RSH</literal>
environment variable as a workaround, as follows:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rsync --rsh='oc rsh' --exclude-from=&lt;file_name&gt; &lt;local-dir&gt; &lt;pod-name&gt;:/&lt;remote-dir&gt;</programlisting>
<simpara>or:</simpara>
<simpara>Export the <literal>RSYNC_RSH</literal> variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export RSYNC_RSH='oc rsh'</programlisting>
<simpara>Then, run the rsync command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rsync --exclude-from=&lt;file_name&gt; &lt;local-dir&gt; &lt;pod-name&gt;:/&lt;remote-dir&gt;</programlisting>
<simpara>Both of the above examples configure standard <literal>rsync</literal> to use <literal>oc rsh</literal> as its
remote shell program to enable it to connect to the remote pod, and are an
alternative to running <literal>oc rsync</literal>.</simpara>
</section>
</section>
<section xml:id="nodes-containers-remote-commands">
<title>Executing remote commands in an {product-title} container</title>

<simpara>You can use the CLI to execute remote commands in an {product-title} container.</simpara>
<section xml:id="nodes-containers-remote-commands-about_nodes-containers-remote-commands">
<title>Executing remote commands in containers</title>
<simpara>Support for remote container command execution is built into the CLI.</simpara>
<formalpara>
<title>Procedure</title>
<para>To run a command in a container:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec &lt;pod&gt; [-c &lt;container&gt;] -- &lt;command&gt; [&lt;arg_1&gt; ... &lt;arg_n&gt;]</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec mypod date</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Thu Apr  9 02:21:53 UTC 2015</programlisting>
</para>
</formalpara>
<important>
<simpara><link xl:href="https://access.redhat.com/errata/RHSA-2015:1650">For security purposes</link>, the
<literal>oc exec</literal> command does not work when accessing privileged containers except when
the command is executed by a <literal>cluster-admin</literal> user.</simpara>
</important>
</section>
<section xml:id="nodes-containers-remote-commands-protocol_nodes-containers-remote-commands">
<title>Protocol for initiating a remote command from a client</title>
<simpara>Clients initiate the execution of a remote command in a container by issuing a
request to the Kubernetes API server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/proxy/nodes/&lt;node_name&gt;/exec/&lt;namespace&gt;/&lt;pod&gt;/&lt;container&gt;?command=&lt;command&gt;</programlisting>
<simpara>In the above URL:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;node_name&gt;</literal> is the FQDN of the node.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;namespace&gt;</literal> is the project of the target pod.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;pod&gt;</literal> is the name of the target pod.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;container&gt;</literal> is the name of the target container.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;command&gt;</literal> is the desired command to be executed.</simpara>
</listitem>
</itemizedlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/proxy/nodes/node123.openshift.com/exec/myns/mypod/mycontainer?command=date</programlisting>
<simpara>Additionally, the client can add parameters to the request to indicate if:</simpara>
<itemizedlist>
<listitem>
<simpara>the client should send input to the remote container&#8217;s command (stdin).</simpara>
</listitem>
<listitem>
<simpara>the client&#8217;s terminal is a TTY.</simpara>
</listitem>
<listitem>
<simpara>the remote container&#8217;s command should send output from stdout to the client.</simpara>
</listitem>
<listitem>
<simpara>the remote container&#8217;s command should send output from stderr to the client.</simpara>
</listitem>
</itemizedlist>
<simpara>After sending an <literal>exec</literal> request to the API server, the client upgrades the
connection to one that supports multiplexed streams; the current implementation
uses <emphasis role="strong">HTTP/2</emphasis>.</simpara>
<simpara>The client creates one stream each for stdin, stdout, and stderr. To distinguish
among the streams, the client sets the <literal>streamType</literal> header on the stream to one
of <literal>stdin</literal>, <literal>stdout</literal>, or <literal>stderr</literal>.</simpara>
<simpara>The client closes all streams, the upgraded connection, and the underlying
connection when it is finished with the remote command execution request.</simpara>
</section>
</section>
<section xml:id="nodes-containers-port-forwarding">
<title>Using port forwarding to access applications in a container</title>

<simpara>{product-title} supports port forwarding to pods.</simpara>
<section xml:id="nodes-containers-port-forwarding-about_nodes-containers-port-forwarding">
<title>Understanding port forwarding</title>
<simpara>You can use the CLI to forward one or more local ports to a pod. This allows you
to listen on a given or random port locally, and have data forwarded to and from
given ports in the pod.</simpara>
<simpara>Support for port forwarding is built into the CLI:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; [&lt;local_port&gt;:]&lt;remote_port&gt; [...[&lt;local_port_n&gt;:]&lt;remote_port_n&gt;]</programlisting>
<simpara>The CLI listens on each local port specified by the user, forwarding using the protocol described below.</simpara>
<simpara>Ports may be specified using the following formats:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara><literal>5000</literal></simpara>
</entry>
<entry>
<simpara>The client listens on port 5000 locally and forwards to 5000 in the
pod.</simpara>
</entry>
</row>
<row>
<entry>
<simpara><literal>6000:5000</literal></simpara>
</entry>
<entry>
<simpara>The client listens on port 6000 locally and forwards to 5000 in
the pod.</simpara>
</entry>
</row>
<row>
<entry>
<simpara><literal>:5000</literal> or <literal>0:5000</literal></simpara>
</entry>
<entry>
<simpara>The client selects a free local port and forwards to 5000
in the pod.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>{product-title} handles port-forward requests from clients. Upon receiving a request, {product-title} upgrades the response and waits for the client
to create port-forwarding streams. When {product-title} receives a new stream, it copies data between the stream and the pod&#8217;s port.</simpara>
<simpara>Architecturally, there are options for forwarding to a pod&#8217;s port. The supported {product-title} implementation invokes <literal>nsenter</literal> directly on the node host
to enter the pod&#8217;s network namespace, then invokes <literal>socat</literal> to copy data between the stream and the pod&#8217;s port. However, a custom implementation could
include running a <emphasis>helper</emphasis> pod that then runs <literal>nsenter</literal> and <literal>socat</literal>, so that those binaries are not required to be installed on the host.</simpara>
</section>
<section xml:id="nodes-containers-port-forwarding-using_nodes-containers-port-forwarding">
<title>Using port forwarding</title>
<simpara>You can use the CLI to port-forward one or more local ports to a pod.</simpara>
<formalpara>
<title>Procedure</title>
<para>Use the following command to listen on the specified port in a pod:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; [&lt;local_port&gt;:]&lt;remote_port&gt; [...[&lt;local_port_n&gt;:]&lt;remote_port_n&gt;]</programlisting>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Use the following command to listen on ports <literal>5000</literal> and <literal>6000</literal> locally and forward data to and from ports <literal>5000</literal> and <literal>6000</literal> in the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; 5000 6000</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Forwarding from 127.0.0.1:5000 -&gt; 5000
Forwarding from [::1]:5000 -&gt; 5000
Forwarding from 127.0.0.1:6000 -&gt; 6000
Forwarding from [::1]:6000 -&gt; 6000</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the following command to listen on port <literal>8888</literal> locally and forward to <literal>5000</literal> in the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; 8888:5000</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Forwarding from 127.0.0.1:8888 -&gt; 5000
Forwarding from [::1]:8888 -&gt; 5000</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the following command to listen on a free port locally and forward to <literal>5000</literal> in the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; :5000</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Forwarding from 127.0.0.1:42390 -&gt; 5000
Forwarding from [::1]:42390 -&gt; 5000</programlisting>
</para>
</formalpara>
<simpara>Or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc port-forward &lt;pod&gt; 0:5000</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-port-forwarding-protocol_nodes-containers-port-forwarding">
<title>Protocol for initiating port forwarding from a client</title>
<simpara>Clients initiate port forwarding to a pod by issuing a request to the
Kubernetes API server:</simpara>
<screen>/proxy/nodes/&lt;node_name&gt;/portForward/&lt;namespace&gt;/&lt;pod&gt;</screen>
<simpara>In the above URL:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;node_name&gt;</literal> is the FQDN of the node.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;namespace&gt;</literal> is the namespace of the target pod.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;pod&gt;</literal> is the name of the target pod.</simpara>
</listitem>
</itemizedlist>
<simpara>For example:</simpara>
<screen>/proxy/nodes/node123.openshift.com/portForward/myns/mypod</screen>
<simpara>After sending a port forward request to the API server, the client upgrades the
connection to one that supports multiplexed streams; the current implementation
uses <link xl:href="https://httpwg.org/specs/rfc7540.html"><emphasis role="strong">Hyptertext Transfer Protocol Version 2 (HTTP/2)</emphasis></link>.</simpara>
<simpara>The client creates a stream with the <literal>port</literal> header containing the target port in
the pod. All data written to the stream is delivered via the kubelet to the
target pod and port. Similarly, all data sent from the pod for that forwarded
connection is delivered back to the same stream in the client.</simpara>
<simpara>The client closes all streams, the upgraded connection, and the underlying
connection when it is finished with the port forwarding request.</simpara>
</section>
</section>
<section xml:id="nodes-containers-sysctls">
<title>Using sysctls in containers</title>

<simpara>Sysctl settings are exposed through Kubernetes, allowing users to modify certain kernel parameters at runtime. Only sysctls that are namespaced can be set independently on pods. If a sysctl is not namespaced, called <emphasis>node-level</emphasis>, you must use another method of setting the sysctl, such as by using the Node Tuning Operator.</simpara>
<simpara>Network sysctls are a special category of sysctl. Network sysctls include:</simpara>
<itemizedlist>
<listitem>
<simpara>System-wide sysctls, for example <literal>net.ipv4.ip_local_port_range</literal>, that are valid for all networking. You can set these independently for each pod on a node.</simpara>
</listitem>
<listitem>
<simpara>Interface-specific sysctls, for example <literal>net.ipv4.conf.IFNAME.accept_local</literal>, that only apply to a specific additional network interface for a given pod. You can set these independently for each additional network configuration. You set these by using a configuration in the <literal>tuning-cni</literal> after the network interfaces are created.</simpara>
</listitem>
</itemizedlist>
<simpara>Moreover, only those sysctls considered <emphasis>safe</emphasis> are whitelisted by default; you
can manually enable other <emphasis>unsafe</emphasis> sysctls on the node to be available to the
user.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../scalability_and_performance/using-node-tuning-operator.xml#using-node-tuning-operator">Node Tuning Operator</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-containers-sysctls-about_nodes-containers-using">
<title>About sysctls</title>
<simpara>In Linux, the sysctl interface allows an administrator to modify kernel parameters at runtime. Parameters are available from the <literal><emphasis>/proc/sys/</emphasis></literal> virtual process file system. The parameters cover various subsystems, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>kernel (common prefix: <literal><emphasis>kernel.</emphasis></literal>)</simpara>
</listitem>
<listitem>
<simpara>networking (common prefix: <literal><emphasis>net.</emphasis></literal>)</simpara>
</listitem>
<listitem>
<simpara>virtual memory (common prefix: <literal><emphasis>vm.</emphasis></literal>)</simpara>
</listitem>
<listitem>
<simpara>MDADM (common prefix: <literal><emphasis>dev.</emphasis></literal>)</simpara>
</listitem>
</itemizedlist>
<simpara>More subsystems are described in <link xl:href="https://www.kernel.org/doc/Documentation/sysctl/README">Kernel documentation</link>.
To get a list of all parameters, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo sysctl -a</programlisting>
</section>
<section xml:id="namespaced-and-node-level-sysctls">
<title>Namespaced and node-level sysctls</title>
<simpara>A number of sysctls are <emphasis>namespaced</emphasis> in the Linux kernels. This means that you can set them independently for each pod on a node. Being namespaced is a requirement for sysctls to be accessible in a pod context within Kubernetes.</simpara>
<simpara>The following sysctls are known to be namespaced:</simpara>
<itemizedlist>
<listitem>
<simpara><literal><emphasis>kernel.shm*</emphasis></literal></simpara>
</listitem>
<listitem>
<simpara><literal><emphasis>kernel.msg*</emphasis></literal></simpara>
</listitem>
<listitem>
<simpara><literal><emphasis>kernel.sem</emphasis></literal></simpara>
</listitem>
<listitem>
<simpara><literal><emphasis>fs.mqueue.*</emphasis></literal></simpara>
</listitem>
</itemizedlist>
<simpara>Additionally, most of the sysctls in the <literal>net.*</literal> group are known to be namespaced. Their namespace adoption differs based on the kernel version and distributor.</simpara>
<simpara>Sysctls that are not namespaced are called <emphasis>node-level</emphasis> and must be set
manually by the cluster administrator, either by means of the underlying Linux
distribution of the nodes, such as by modifying the <literal><emphasis>/etc/sysctls.conf</emphasis></literal> file,
or by using a daemon set with privileged containers. You can use the Node Tuning Operator to set <emphasis>node-level</emphasis> sysctls.</simpara>
<note>
<simpara>Consider marking nodes with special sysctls as tainted. Only schedule pods onto
them that need those sysctl settings. Use the taints and toleration feature to mark the nodes.</simpara>
</note>
</section>
<section xml:id="safe_and_unsafe_sysctls_nodes-containers-using">
<title>Safe and unsafe sysctls</title>
<simpara>Sysctls are grouped into <emphasis>safe</emphasis> and <emphasis>unsafe</emphasis> sysctls.</simpara>
<simpara>For system-wide sysctls to be considered safe, they must be namespaced. A namespaced sysctl ensures there is isolation between namespaces and therefore pods. If you set a sysctl for one pod it must not add any of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Influence any other pod on the node</simpara>
</listitem>
<listitem>
<simpara>Harm the node health</simpara>
</listitem>
<listitem>
<simpara>Gain CPU or memory resources outside of the resource limits of a pod</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Being namespaced alone is not sufficient for the sysctl to be considered safe.</simpara>
</note>
<simpara>Any sysctl that is not added to the allowed list on {product-title} is considered unsafe for {product-title}.</simpara>
<simpara>Unsafe sysctls are not allowed by default. For system-wide sysctls the cluster administrator must manually enable them on a per-node basis. Pods with disabled unsafe sysctls are scheduled but do not launch.</simpara>
<note>
<simpara>You cannot manually enable interface-specific unsafe sysctls.</simpara>
</note>
<simpara>{product-title} adds the following system-wide and interface-specific safe sysctls to an allowed safe list:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>System-wide safe sysctls</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">sysctl</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>kernel.shm_rmid_forced</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When set to <literal>1</literal>, all shared memory objects in current IPC namespace are automatically forced to use IPC_RMID. For more information, see <link xl:href="https://docs.kernel.org/admin-guide/sysctl/kernel.html?highlight=shm_rmid_forced#shm-rmid-forced">shm_rmid_forced</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.ip_local_port_range</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines the local port range that is used by TCP and UDP to choose the local port. The first number is the first port number, and the second number is the last local port number. If possible, it is better if these numbers have different parity (one even and one odd value). They must be greater than or equal to <literal>ip_unprivileged_port_start</literal>. The default values are <literal>32768</literal> and <literal>60999</literal> respectively. For more information, see <link xl:href="https://docs.kernel.org/networking/ip-sysctl.html?highlight=ip_local_port_range#ip-variables">ip_local_port_range</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.tcp_syncookies</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When <literal>net.ipv4.tcp_syncookies</literal> is set, the kernel handles TCP SYN packets normally until the
half-open connection queue is full, at which time, the SYN cookie functionality kicks in. This functionality allows the system to keep accepting valid connections, even if under a denial-of-service attack. For more information, see <link xl:href="https://docs.kernel.org/networking/ip-sysctl.html?highlight=tcp_syncookies#tcp-variables">tcp_syncookies</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.ping_group_range</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This restricts <literal>ICMP_PROTO</literal> datagram sockets to users in the group range. The default is <literal>1 0</literal>, meaning that nobody, not even root, can create ping sockets. For more information, see <link xl:href="https://docs.kernel.org/networking/ip-sysctl.html?highlight=ping_group_range#ip-variables">ping_group_range</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.ip_unprivileged_port_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This defines the first unprivileged port in the network namespace. To disable all privileged ports, set this to <literal>0</literal>. Privileged ports must not overlap with the <literal>ip_local_port_range</literal>. For more information, see <link xl:href="https://docs.kernel.org/networking/ip-sysctl.html?highlight=ip_unprivileged_port_start#ip-variables#ip-variables">ip_unprivileged_port_start</link>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Interface-specific safe sysctls</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">sysctl</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.accept_redirects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept IPv4 ICMP redirect messages.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.accept_source_route</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept IPv4 packets with strict source route (SRR) option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.arp_accept</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define behavior for gratuitous ARP frames with an IPv4 address that is not already present in the ARP table:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>0</literal> - Do not create new entries in the ARP table.</simpara>
</listitem>
<listitem>
<simpara><literal>1</literal> - Create new entries in the ARP table.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.arp_notify</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define mode for notification of IPv4 address and device changes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.disable_policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable IPSEC policy (SPD) for this IPv4 interface.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.secure_redirects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept ICMP redirect messages only to gateways listed in the interface’s current gateway list.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv4.conf.IFNAME.send_redirects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Send redirects is enabled only if the node acts as a router. That is, a host should not send an ICMP redirect message. It is used by routers to notify the host about a better routing path that is available for a particular destination.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.conf.IFNAME.accept_ra</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept IPv6 Router advertisements; autoconfigure using them. It also determines whether or not to transmit router solicitations. Router solicitations are transmitted only if the functional setting is to accept router advertisements.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.conf.IFNAME.accept_redirects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept IPv6 ICMP redirect messages.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.conf.IFNAME.accept_source_route</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Accept IPv6 packets with SRR option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.conf.IFNAME.arp_accept</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define behavior for gratuitous ARP frames with an IPv6 address that is not already present in the ARP table:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>0</literal> - Do not create new entries in the ARP table.</simpara>
</listitem>
<listitem>
<simpara><literal>1</literal> - Create new entries in the ARP table.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.conf.IFNAME.arp_notify</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define mode for notification of IPv6 address and device changes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.neigh.IFNAME.base_reachable_time_ms</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This parameter controls the hardware address to IP mapping lifetime in the neighbour table for IPv6.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>net.ipv6.neigh.IFNAME.retrans_time_ms</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the retransmit timer for neighbor discovery messages.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>When setting these values using the <literal>tuning</literal> CNI plugin, use the value <literal>IFNAME</literal> literally. The interface name is represented by the <literal>IFNAME</literal> token, and is replaced with the actual name of the interface at runtime.</simpara>
</note>
</section>
<section xml:id="updating-interface-specific-safe-sysctls-list_nodes-containers-using">
<title>Updating the interface-specific safe sysctls list</title>
<simpara>{product-title} includes a predefined list of safe interface-specific <literal>sysctls</literal>. You can modify this list by updating the <literal>cni-sysctl-allowlist</literal> in the <literal>openshift-multus</literal> namespace.</simpara>
<important>
<simpara>The support for updating the interface-specific safe sysctls list is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Follow this procedure to modify the predefined list of safe <literal>sysctls</literal>. This procedure describes how to extend the default allow list.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the existing predefined list by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cm -n openshift-multus cni-sysctl-allowlist -oyaml</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
data:
  allowlist.conf: |-
    ^net.ipv4.conf.IFNAME.accept_redirects$
    ^net.ipv4.conf.IFNAME.accept_source_route$
    ^net.ipv4.conf.IFNAME.arp_accept$
    ^net.ipv4.conf.IFNAME.arp_notify$
    ^net.ipv4.conf.IFNAME.disable_policy$
    ^net.ipv4.conf.IFNAME.secure_redirects$
    ^net.ipv4.conf.IFNAME.send_redirects$
    ^net.ipv6.conf.IFNAME.accept_ra$
    ^net.ipv6.conf.IFNAME.accept_redirects$
    ^net.ipv6.conf.IFNAME.accept_source_route$
    ^net.ipv6.conf.IFNAME.arp_accept$
    ^net.ipv6.conf.IFNAME.arp_notify$
    ^net.ipv6.neigh.IFNAME.base_reachable_time_ms$
    ^net.ipv6.neigh.IFNAME.retrans_time_ms$
kind: ConfigMap
metadata:
  annotations:
    kubernetes.io/description: |
      Sysctl allowlist for nodes.
    release.openshift.io/version: {product-version}.0-0.nightly-2022-11-16-003434
  creationTimestamp: "2022-11-17T14:09:27Z"
  name: cni-sysctl-allowlist
  namespace: openshift-multus
  resourceVersion: "2422"
  uid: 96d138a3-160e-4943-90ff-6108fa7c50c3</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit the list by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit cm -n openshift-multus cni-sysctl-allowlist -oyaml</programlisting>
<simpara>For example, to allow you to be able to implement stricter reverse path forwarding you need to add <literal>^net.ipv4.conf.IFNAME.rp_filter$</literal> and <literal>^net.ipv6.conf.IFNAME.rp_filter$</literal> to the list as shown here:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># Please edit the object below. Lines beginning with a '#' will be ignored,
# and an empty file will abort the edit. If an error occurs while saving this file will be
# reopened with the relevant failures.
#
apiVersion: v1
data:
  allowlist.conf: |-
    ^net.ipv4.conf.IFNAME.accept_redirects$
    ^net.ipv4.conf.IFNAME.accept_source_route$
    ^net.ipv4.conf.IFNAME.arp_accept$
    ^net.ipv4.conf.IFNAME.arp_notify$
    ^net.ipv4.conf.IFNAME.disable_policy$
    ^net.ipv4.conf.IFNAME.secure_redirects$
    ^net.ipv4.conf.IFNAME.send_redirects$
    ^net.ipv4.conf.IFNAME.rp_filter$
    ^net.ipv6.conf.IFNAME.accept_ra$
    ^net.ipv6.conf.IFNAME.accept_redirects$
    ^net.ipv6.conf.IFNAME.accept_source_route$
    ^net.ipv6.conf.IFNAME.arp_accept$
    ^net.ipv6.conf.IFNAME.arp_notify$
    ^net.ipv6.neigh.IFNAME.base_reachable_time_ms$
    ^net.ipv6.neigh.IFNAME.retrans_time_ms$
    ^net.ipv6.conf.IFNAME.rp_filter$</programlisting>
</listitem>
<listitem>
<simpara>Save the changes to the file and exit.</simpara>
<note>
<simpara>The removal of <literal>sysctls</literal> is also supported. Edit the file, remove the <literal>sysctl</literal> or <literal>sysctls</literal> then save the changes and exit.</simpara>
</note>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>Follow this procedure to enforce stricter reverse path forwarding for IPv4.
For more information on reverse path forwarding see <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/security_guide/sect-security_guide-server_security-reverse_path_forwarding">Reverse Path Forwarding
</link>.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a network attachment definition, such as <literal>reverse-path-fwd-example.yaml</literal>, with the following content:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: tuningnad
  namespace: default
spec:
  config: '{
    "cniVersion": "0.4.0",
    "name": "tuningnad",
    "plugins": [{
      "type": "bridge"
      },
      {
      "type": "tuning",
      "sysctl": {
         "net.ipv4.conf.IFNAME.rp_filter": "1"
        }
    }
  ]
}'</programlisting>
</listitem>
<listitem>
<simpara>Apply the yaml by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f reverse-path-fwd-example.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">networkattachmentdefinition.k8.cni.cncf.io/tuningnad created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a pod such as <literal>examplepod.yaml</literal> using the following YAML:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: example
  labels:
    app: httpd
  namespace: default
  annotations:
    k8s.v1.cni.cncf.io/networks: tuningnad  <co xml:id="CO152-1"/>
spec:
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
  containers:
    - name: httpd
      image: 'image-registry.openshift-image-registry.svc:5000/openshift/httpd:latest'
      ports:
        - containerPort: 8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL</programlisting>
<calloutlist>
<callout arearefs="CO152-1">
<para>Specify the name of the configured <literal>NetworkAttachmentDefinition</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the yaml by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f examplepod.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the pod is created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY   STATUS    RESTARTS   AGE
example   1/1     Running   0          47s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Log in to the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh example</programlisting>
</listitem>
<listitem>
<simpara>Verify the value of the configured sysctl flag. For example, find the value <literal>net.ipv4.conf.net1.rp_filter</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# sysctl net.ipv4.conf.net1.rp_filter</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">net.ipv4.conf.net1.rp_filter = 1</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://docs.kernel.org/networking/ip-sysctl.html">Linux networking documentation</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-starting-pod-safe-sysctls_nodes-containers-using">
<title>Starting a pod with safe sysctls</title>
<simpara>You can set sysctls on pods using the pod&#8217;s <literal>securityContext</literal>. The <literal>securityContext</literal> applies to all containers in the same pod.</simpara>
<simpara>Safe sysctls are allowed by default.</simpara>
<simpara>This example uses the pod <literal>securityContext</literal> to set the following safe sysctls:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kernel.shm_rmid_forced</literal></simpara>
</listitem>
<listitem>
<simpara><literal>net.ipv4.ip_local_port_range</literal></simpara>
</listitem>
<listitem>
<simpara><literal>net.ipv4.tcp_syncookies</literal></simpara>
</listitem>
<listitem>
<simpara><literal>net.ipv4.ping_group_range</literal></simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>To avoid destabilizing your operating system, modify sysctl parameters only after you understand their effects.</simpara>
</warning>
<simpara>Use this procedure to start a pod with the configured sysctl settings.</simpara>
<note>
<simpara>In most cases you modify an existing pod definition and add the <literal>securityContext</literal> spec.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file <literal>sysctl_pod.yaml</literal> that defines an example pod and add the <literal>securityContext</literal> spec, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: sysctl-example
  namespace: default
spec:
  containers:
  - name: podexample
    image: centos
    command: ["bin/bash", "-c", "sleep INF"]
    securityContext:
      runAsUser: 2000 <co xml:id="CO153-1"/>
      runAsGroup: 3000 <co xml:id="CO153-2"/>
      allowPrivilegeEscalation: false <co xml:id="CO153-3"/>
      capabilities: <co xml:id="CO153-4"/>
        drop: ["ALL"]
  securityContext:
    runAsNonRoot: true <co xml:id="CO153-5"/>
    seccompProfile: <co xml:id="CO153-6"/>
      type: RuntimeDefault
    sysctls:
    - name: kernel.shm_rmid_forced
      value: "1"
    - name: net.ipv4.ip_local_port_range
      value: "32770       60666"
    - name: net.ipv4.tcp_syncookies
      value: "0"
    - name: net.ipv4.ping_group_range
      value: "0           200000000"</programlisting>
<calloutlist>
<callout arearefs="CO153-1">
<para><literal>runAsUser</literal> controls which user ID the container is run with.</para>
</callout>
<callout arearefs="CO153-2">
<para><literal>runAsGroup</literal> controls which primary group ID the containers is run with.</para>
</callout>
<callout arearefs="CO153-3">
<para><literal>allowPrivilegeEscalation</literal> determines if a pod can request to allow privilege escalation. If unspecified, it defaults to true. This boolean directly controls whether the <literal>no_new_privs</literal> flag gets set on the container process.</para>
</callout>
<callout arearefs="CO153-4">
<para><literal>capabilities</literal> permit privileged actions without giving full root access. This policy ensures all capabilities are dropped from the pod.</para>
</callout>
<callout arearefs="CO153-5">
<para><literal>runAsNonRoot: true</literal> requires that the container will run with a user with any UID other than 0.</para>
</callout>
<callout arearefs="CO153-6">
<para><literal>RuntimeDefault</literal> enables the default seccomp profile for a pod or container workload.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sysctl_pod.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the pod is created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              READY   STATUS            RESTARTS   AGE
sysctl-example    1/1     Running           0          14s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Log in to the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh sysctl-example</programlisting>
</listitem>
<listitem>
<simpara>Verify the values of the configured sysctl flags. For example, find the value <literal>kernel.shm_rmid_forced</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# sysctl kernel.shm_rmid_forced</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">kernel.shm_rmid_forced = 1</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-containers-starting-pod-with-unsafe-sysctls_nodes-containers-using">
<title>Starting a pod with unsafe sysctls</title>
<simpara>A pod with unsafe sysctls fails to launch on any node unless the cluster administrator explicitly enables unsafe sysctls for that node. As with node-level sysctls, use the taints and toleration feature or labels on nodes to schedule those pods onto the right nodes.</simpara>
<simpara>The following example uses the pod <literal>securityContext</literal> to set a safe sysctl <literal>kernel.shm_rmid_forced</literal> and two unsafe sysctls, <literal>net.core.somaxconn</literal> and <literal>kernel.msgmax</literal>. There is no distinction between <emphasis>safe</emphasis> and <emphasis>unsafe</emphasis> sysctls in the specification.</simpara>
<warning>
<simpara>To avoid destabilizing your operating system, modify sysctl parameters only after you understand their effects.</simpara>
</warning>
<simpara>The following example illustrates what happens when you add safe and unsafe sysctls to a pod specification:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file <literal>sysctl-example-unsafe.yaml</literal> that defines an example pod and add the <literal>securityContext</literal> specification, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: sysctl-example-unsafe
spec:
  containers:
  - name: podexample
    image: centos
    command: ["bin/bash", "-c", "sleep INF"]
    securityContext:
      runAsUser: 2000
      runAsGroup: 3000
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
    sysctls:
    - name: kernel.shm_rmid_forced
      value: "0"
    - name: net.core.somaxconn
      value: "1024"
    - name: kernel.msgmax
      value: "65536"</programlisting>
</listitem>
<listitem>
<simpara>Create the pod using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sysctl-example-unsafe.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the pod is scheduled but does not deploy because unsafe sysctls are not allowed for the node using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                       READY             STATUS            RESTARTS   AGE
sysctl-example-unsafe      0/1               SysctlForbidden   0          14s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-containers-sysctls-unsafe_nodes-containers-using">
<title>Enabling unsafe sysctls</title>
<simpara>A cluster administrator can allow certain unsafe sysctls for very special
situations such as high performance or real-time application tuning.</simpara>
<simpara>If you want to use unsafe sysctls, a cluster administrator must enable them
individually for a specific type of node. The sysctls must be namespaced.</simpara>
<simpara>You can further control which sysctls are set in pods by specifying lists of sysctls or sysctl patterns in the <literal>allowedUnsafeSysctls</literal> field of the Security Context Constraints.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>allowedUnsafeSysctls</literal> option controls specific needs such as high performance or real-time application tuning.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>Due to their nature of being unsafe, the use of unsafe sysctls is
at-your-own-risk and can lead to severe problems, such as improper behavior of
containers, resource shortage, or breaking a node.</simpara>
</warning>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List existing MachineConfig objects for your {product-title} cluster to decide how to label your machine config by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                             UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master   rendered-master-bfb92f0cd1684e54d8e234ab7423cc96   True      False      False      3              3                   3                     0                      42m
worker   rendered-worker-21b6cb9a0f8919c88caf39db80ac1fce   True      False      False      3              3                   3                     0                      42m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Add a label to the machine config pool where the containers with the unsafe sysctls will run by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label machineconfigpool worker custom-kubelet=sysctl</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file <literal>set-sysctl-worker.yaml</literal> that defines a <literal>KubeletConfig</literal> custom resource (CR):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: custom-kubelet
spec:
  machineConfigPoolSelector:
    matchLabels:
      custom-kubelet: sysctl <co xml:id="CO154-1"/>
  kubeletConfig:
    allowedUnsafeSysctls: <co xml:id="CO154-2"/>
      - "kernel.msg*"
      - "net.core.somaxconn"</programlisting>
<calloutlist>
<callout arearefs="CO154-1">
<para>Specify the label from the machine config pool.</para>
</callout>
<callout arearefs="CO154-2">
<para>List the unsafe sysctls you want to allow.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f set-sysctl-worker.yaml</programlisting>
</listitem>
<listitem>
<simpara>Wait for the Machine Config Operator to generate the new rendered configuration and apply it to the machines by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool worker -w</programlisting>
<simpara>After some minutes the <literal>UPDATING</literal> status changes from True to False:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                             UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
worker   rendered-worker-f1704a00fc6f30d3a7de9a15fd68a800   False     True       False      3              2                   2                     0                      71m
worker   rendered-worker-f1704a00fc6f30d3a7de9a15fd68a800   False     True       False      3              2                   3                     0                      72m
worker   rendered-worker-0188658afe1f3a183ec8c4f14186f4d5   True      False      False      3              3                   3                     0                      72m</programlisting>
</listitem>
<listitem>
<simpara>Create a YAML file <literal>sysctl-example-safe-unsafe.yaml</literal> that defines an example pod and add the <literal>securityContext</literal> spec, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: sysctl-example-safe-unsafe
spec:
  containers:
  - name: podexample
    image: centos
    command: ["bin/bash", "-c", "sleep INF"]
    securityContext:
      runAsUser: 2000
      runAsGroup: 3000
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
  securityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault
    sysctls:
    - name: kernel.shm_rmid_forced
      value: "0"
    - name: net.core.somaxconn
      value: "1024"
    - name: kernel.msgmax
      value: "65536"</programlisting>
</listitem>
<listitem>
<simpara>Create the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sysctl-example-safe-unsafe.yaml</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Warning: would violate PodSecurity "restricted:latest": forbidden sysctls (net.core.somaxconn, kernel.msgmax)
pod/sysctl-example-safe-unsafe created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the pod is created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                         READY   STATUS    RESTARTS   AGE
sysctl-example-safe-unsafe   1/1     Running   0          19s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Log in to the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh sysctl-example-safe-unsafe</programlisting>
</listitem>
<listitem>
<simpara>Verify the values of the configured sysctl flags. For example, find the value <literal>net.core.somaxconn</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# sysctl net.core.somaxconn</programlisting>
<formalpara>
<title>Expected output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">net.core.somaxconn = 1024</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>The unsafe sysctl is now allowed and the value is set as defined in the <literal>securityContext</literal> spec of the updated pod specification.</simpara>
</section>
<section xml:id="additional-resources_nodes-containers-sysctls" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../networking/configure-syscontrols-interface-tuning-cni.xml#nw-configuring-tuning-cni_configure-syscontrols-interface-tuning-cni">Configuring system controls by using the tuning CNI</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_working_with_clusters">
<title>Working with clusters</title>
<section xml:id="nodes-containers-events">
<title>Viewing system event information in an {product-title} cluster</title>

<simpara>Events in {product-title} are modeled based on events that happen to API objects
in an {product-title} cluster.</simpara>
<section xml:id="nodes-containers-events-about_nodes-containers-events">
<title>Understanding events</title>
<simpara>Events allow {product-title} to record
information about real-world events in a resource-agnostic manner. They also
allow developers and administrators to consume information about system
components in a unified way.</simpara>
</section>
<section xml:id="nodes-containers-events-viewing-cli_nodes-containers-events">
<title>Viewing events using the CLI</title>
<simpara>You can get a list of events in a given project using the CLI.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To view events in a project use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events [-n &lt;project&gt;] <co xml:id="CO155-1"/></programlisting>
<calloutlist>
<callout arearefs="CO155-1">
<para>The name of the project.</para>
</callout>
</calloutlist>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events -n openshift-config</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">LAST SEEN   TYPE      REASON                   OBJECT                      MESSAGE
97m         Normal    Scheduled                pod/dapi-env-test-pod       Successfully assigned openshift-config/dapi-env-test-pod to ip-10-0-171-202.ec2.internal
97m         Normal    Pulling                  pod/dapi-env-test-pod       pulling image "gcr.io/google_containers/busybox"
97m         Normal    Pulled                   pod/dapi-env-test-pod       Successfully pulled image "gcr.io/google_containers/busybox"
97m         Normal    Created                  pod/dapi-env-test-pod       Created container
9m5s        Warning   FailedCreatePodSandBox   pod/dapi-volume-test-pod    Failed create pod sandbox: rpc error: code = Unknown desc = failed to create pod network sandbox k8s_dapi-volume-test-pod_openshift-config_6bc60c1f-452e-11e9-9140-0eec59c23068_0(748c7a40db3d08c07fb4f9eba774bd5effe5f0d5090a242432a73eee66ba9e22): Multus: Err adding pod to network "openshift-sdn": cannot set "openshift-sdn" ifname to "eth0": no netns: failed to Statfs "/proc/33366/ns/net": no such file or directory
8m31s       Normal    Scheduled                pod/dapi-volume-test-pod    Successfully assigned openshift-config/dapi-volume-test-pod to ip-10-0-171-202.ec2.internal</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view events in your project from the {product-title} console.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Launch the {product-title} console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Events</emphasis> and select your project.</simpara>
</listitem>
<listitem>
<simpara>Move to resource that you want to see events. For example: <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis> &#8594; &lt;project-name&gt; &#8594; &lt;resource-name&gt;.</simpara>
<simpara>Many objects, such as pods and deployments, have their own
<emphasis role="strong">Events</emphasis> tab as well, which shows events related to that object.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-containers-events-list_nodes-containers-events">
<title>List of events</title>
<simpara>This section describes the events of {product-title}.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Configuration events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedValidation</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed pod configuration validation.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Container events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>BackOff</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Back-off restarting failed the container.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Created</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Container created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Failed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pull/Create/Start failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Killing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Killing the container.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Started</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Container started.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Preempting</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Preempting other pods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ExceededGracePeriod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Container runtime did not stop the pod within specified grace period.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Health events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Unhealthy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Container is unhealthy.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Image events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>BackOff</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Back off Ctr Start, image pull.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ErrImageNeverPull</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The image&#8217;s <emphasis role="strong">NeverPull Policy</emphasis> is violated.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Failed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to pull the image.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InspectFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to inspect the image.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Successfully pulled the image or the container image is already present on the machine.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulling</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pulling the image.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Image Manager events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FreeDiskSpaceFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Free disk space failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InvalidDiskCapacity</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Invalid disk capacity.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Node events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedMount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume mount failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HostNetworkNotSupported</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host network not supported.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HostPortConflict</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host/port conflict.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KubeletSetupFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubelet setup failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NilShaper</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Undefined shaper.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeNotReady</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node is not ready.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeNotSchedulable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node is not schedulable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeReady</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node is ready.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeSchedulable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node is schedulable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeSelectorMismatching</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node selector mismatch.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OutOfDisk</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Out of disk.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Rebooted</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Node rebooted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Starting</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starting kubelet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedAttachVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to attach volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedDetachVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to detach volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeResizeFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to expand/reduce volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeResizeSuccessful</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Successfully expanded/reduced volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FileSystemResizeFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to expand/reduce file system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FileSystemResizeSuccessful</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Successfully expanded/reduced file system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedUnMount</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to unmount volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedMapVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to map a volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedUnmapDevice</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed unmaped device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AlreadyMountedVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume is already mounted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulDetachVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume is successfully detached.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulMountVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume is successfully mounted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulUnMountVolume</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume is successfully unmounted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ContainerGCFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Container garbage collection failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ImageGCFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Image garbage collection failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedNodeAllocatableEnforcement</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to enforce System Reserved Cgroup limit.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NodeAllocatableEnforced</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Enforced System Reserved Cgroup limit.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UnsupportedMountOption</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unsupported mount option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SandboxChanged</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pod sandbox changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedCreatePodSandBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to create pod sandbox.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedPodSandBoxStatus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed pod sandbox status.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Pod worker events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedSync</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pod sync failed.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>System Events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SystemOOM</literal></simpara></entry>
<entry align="left" valign="top"><simpara>There is an OOM (out of memory) situation on the cluster.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Pod events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedKillPod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to stop a pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedCreatePodContainer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to create a pod container.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Failed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to make pod data directories.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NetworkNotReady</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Network is not ready.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedCreate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error creating: <literal>&lt;error-msg&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulCreate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Created pod: <literal>&lt;pod-name&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedDelete</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error deleting: <literal>&lt;error-msg&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulDelete</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Deleted pod: <literal>&lt;pod-id&gt;</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Horizontal Pod AutoScaler events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SelectorRequired</simpara></entry>
<entry align="left" valign="top"><simpara>Selector is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InvalidSelector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Could not convert selector into a corresponding internal selector object.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedGetObjectMetric</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HPA was unable to compute the replica count.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InvalidMetricSourceType</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Unknown metric source type.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ValidMetricFound</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HPA was able to successfully calculate a replica count.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedConvertHPA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to convert the given HPA.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedGetScale</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HPA controller was unable to get the target&#8217;s current scale.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SucceededGetScale</literal></simpara></entry>
<entry align="left" valign="top"><simpara>HPA controller was able to get the target&#8217;s current scale.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedComputeMetricsReplicas</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to compute desired number of replicas based on listed metrics.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedRescale</literal></simpara></entry>
<entry align="left" valign="top"><simpara>New size: <literal>&lt;size&gt;</literal>; reason: <literal>&lt;msg&gt;</literal>; error: <literal>&lt;error-msg&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SuccessfulRescale</literal></simpara></entry>
<entry align="left" valign="top"><simpara>New size: <literal>&lt;size&gt;</literal>; reason: <literal>&lt;msg&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedUpdateStatus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to update status.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Network events (openshift-sdn)</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Starting</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starting OpenShift SDN.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NetworkFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pod&#8217;s network interface has been lost and the pod will be stopped.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Network events (kube-proxy)</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>NeedPods</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The service-port <literal>&lt;serviceName&gt;:&lt;port&gt;</literal> needs pods.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Volume events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedBinding</literal></simpara></entry>
<entry align="left" valign="top"><simpara>There are no persistent volumes available and no storage class is set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeMismatch</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Volume size or class is different from what is requested in claim.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeFailedRecycle</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error creating recycler pod.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeRecycled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Occurs when volume is recycled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RecyclerPod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Occurs when pod is recycled.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeDelete</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Occurs when volume is deleted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeFailedDelete</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error when deleting the volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ExternalProvisioning</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Occurs when volume for the claim is provisioned either manually or via external software.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ProvisioningFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to provision volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ProvisioningCleanupFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error cleaning provisioned volume.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ProvisioningSucceeded</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Occurs when the volume is provisioned successfully.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>WaitForFirstConsumer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Delay binding until pod scheduling.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Lifecycle hooks</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedPostStartHook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Handler failed for pod start.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedPreStopHook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Handler failed for pre-stop.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UnfinishedPreStopHook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pre-stop hook unfinished.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Deployments</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>DeploymentCancellationFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to cancel deployment.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeploymentCancelled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Canceled deployment.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeploymentCreated</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Created new replication controller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>IngressIPRangeFull</literal></simpara></entry>
<entry align="left" valign="top"><simpara>No available Ingress IP to allocate to service.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Scheduler events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>FailedScheduling</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to schedule pod: <literal>&lt;pod-namespace&gt;/&lt;pod-name&gt;</literal>. This event is raised for
multiple reasons, for example: <literal>AssumePodVolumes</literal> failed, Binding rejected etc.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Preempted</literal></simpara></entry>
<entry align="left" valign="top"><simpara>By <literal>&lt;preemptor-namespace&gt;/&lt;preemptor-name&gt;</literal> on node <literal>&lt;node-name&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Scheduled</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Successfully assigned <literal>&lt;pod-name&gt;</literal> to <literal>&lt;node-name&gt;</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Daemon set events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SelectingAll</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This daemon set is selecting all pods. A non-empty selector is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedPlacement</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Failed to place pod on <literal>&lt;node-name&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FailedDaemonPod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Found failed daemon pod <literal>&lt;pod-name&gt;</literal> on node <literal>&lt;node-name&gt;</literal>, will try to kill it.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>LoadBalancer service events</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>CreatingLoadBalancerFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error creating load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeletingLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Deleting load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>EnsuringLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Ensuring load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>EnsuredLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Ensured load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UnAvailableLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>There are no available nodes for <literal>LoadBalancer</literal> service.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LoadBalancerSourceRanges</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists the new <literal>LoadBalancerSourceRanges</literal>. For example, <literal>&lt;old-source-range&gt; &#8594; &lt;new-source-range&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LoadbalancerIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists the new IP address. For example, <literal>&lt;old-ip&gt; &#8594; &lt;new-ip&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ExternalIP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists external IP address. For example, <literal>Added: &lt;external-ip&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UID</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists the new UID. For example, <literal>&lt;old-service-uid&gt; &#8594; &lt;new-service-uid&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ExternalTrafficPolicy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists the new <literal>ExternalTrafficPolicy</literal>. For example, <literal>&lt;old-policy&gt; &#8594; &lt;new-policy&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HealthCheckNodePort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Lists the new <literal>HealthCheckNodePort</literal>. For example, <literal>&lt;old-node-port&gt; &#8594; new-node-port&gt;</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>UpdatedLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Updated load balancer with new hosts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LoadBalancerUpdateFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error updating load balancer with new hosts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeletingLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Deleting load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeletingLoadBalancerFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Error deleting load balancer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeletedLoadBalancer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Deleted load balancer.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="nodes-cluster-resource-levels">
<title>Estimating the number of pods your {product-title} nodes can hold</title>

<simpara>As a cluster administrator, you can use the OpenShift Cluster Capacity Tool to view the number of pods that can be scheduled to increase the current resources before they become exhausted, and to ensure any future pods can be scheduled. This capacity comes from an individual node host in a cluster, and includes CPU, memory, disk space, and others.</simpara>
<section xml:id="nodes-cluster-resource-levels-about_nodes-cluster-resource-levels">
<title>Understanding the OpenShift Cluster Capacity Tool</title>
<simpara>The OpenShift Cluster Capacity Tool simulates a sequence of scheduling decisions to
determine how many instances of an input pod can be scheduled on the cluster
before it is exhausted of resources to provide a more accurate estimation.</simpara>
<note>
<simpara>The remaining allocatable capacity is a rough estimation, because it does not
count all of the resources being distributed among nodes. It analyzes only the
remaining resources and estimates the available capacity that is still
consumable in terms of a number of instances of a pod with given requirements
that can be scheduled in a cluster.</simpara>
<simpara>Also, pods might only have scheduling support on particular sets of nodes based
on its selection and affinity criteria. As a result, the estimation of which
remaining pods a cluster can schedule can be difficult.</simpara>
</note>
<simpara>You can run the OpenShift Cluster Capacity Tool as a stand-alone utility from
the command line, or as a job in a pod inside an {product-title} cluster.
Running the tool as job inside of a pod enables you to run it multiple times without intervention.</simpara>
</section>
<section xml:id="nodes-cluster-resource-levels-command_nodes-cluster-resource-levels">
<title>Running the OpenShift Cluster Capacity Tool on the command line</title>
<simpara>You can run the OpenShift Cluster Capacity Tool from the command line
to estimate the number of pods that can be scheduled onto your cluster.</simpara>
<simpara>You create a sample pod spec file, which the tool uses for estimating resource usage. The pod spec specifies its resource
requirements as <literal>limits</literal> or <literal>requests</literal>. The cluster capacity tool takes the
pod&#8217;s resource requirements into account for its estimation analysis.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>Run the <link xl:href="https://catalog.redhat.com/software/containers/openshift4/ose-cluster-capacity/5cca0324d70cc57c44ae8eb6?container-tabs=overview">OpenShift Cluster Capacity Tool</link>, which is available as a container image from the Red Hat Ecosystem Catalog.</simpara>
</listitem>
<listitem>
<simpara>Create a sample pod spec file:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: small-pod
  labels:
    app: guestbook
    tier: frontend
spec:
  containers:
  - name: php-redis
    image: gcr.io/google-samples/gb-frontend:v4
    imagePullPolicy: Always
    resources:
      limits:
        cpu: 150m
        memory: 100Mi
      requests:
        cpu: 150m
        memory: 100Mi</programlisting>
</listitem>
<listitem>
<simpara>Create the cluster role:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod-spec.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Procedure</title>
<para>To use the cluster capacity tool on the command line:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the terminal, log in to the Red Hat Registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login registry.redhat.io</programlisting>
</listitem>
<listitem>
<simpara>Pull the cluster capacity tool image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman pull registry.redhat.io/openshift4/ose-cluster-capacity</programlisting>
</listitem>
<listitem>
<simpara>Run the cluster capacity tool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -v $HOME/.kube:/kube:Z -v $(pwd):/cc:Z  ose-cluster-capacity \
/bin/cluster-capacity --kubeconfig /kube/config --&lt;pod_spec&gt;.yaml /cc/&lt;pod_spec&gt;.yaml \
--verbose</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;pod_spec&gt;.yaml</term>
<listitem>
<simpara>Specifies the pod spec to use.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>verbose</term>
<listitem>
<simpara>Outputs a detailed description of how many pods can be scheduled on each node in the cluster.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">small-pod pod requirements:
	- CPU: 150m
	- Memory: 100Mi

The cluster can schedule 88 instance(s) of the pod small-pod.

Termination reason: Unschedulable: 0/5 nodes are available: 2 Insufficient cpu,
3 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't
tolerate.

Pod distribution among nodes:
small-pod
	- 192.168.124.214: 45 instance(s)
	- 192.168.124.120: 43 instance(s)</programlisting>
</para>
</formalpara>
<simpara>In the above example, the number of estimated pods that can be scheduled onto
the cluster is 88.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-resource-levels-job_nodes-cluster-resource-levels">
<title>Running the OpenShift Cluster Capacity Tool as a job inside a pod</title>
<simpara>Running the OpenShift Cluster Capacity Tool as a job inside of a pod allows you to run the tool multiple times without needing user intervention. You run the OpenShift Cluster Capacity Tool as a job by using a <literal>ConfigMap</literal> object.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>Download and install <link xl:href="https://github.com/openshift/cluster-capacity">OpenShift Cluster Capacity Tool</link>.</para>
</formalpara>
<formalpara>
<title>Procedure</title>
<para>To run the cluster capacity tool:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the cluster role:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: cluster-capacity-role
rules:
- apiGroups: [""]
  resources: ["pods", "nodes", "persistentvolumeclaims", "persistentvolumes", "services", "replicationcontrollers"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["apps"]
  resources: ["replicasets", "statefulsets"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["policy"]
  resources: ["poddisruptionbudgets"]
  verbs: ["get", "watch", "list"]
- apiGroups: ["storage.k8s.io"]
  resources: ["storageclasses"]
  verbs: ["get", "watch", "list"]</programlisting>
</listitem>
<listitem>
<simpara>Create the cluster role by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create sa cluster-capacity-sa</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create sa cluster-capacity-sa -n default</programlisting>
</listitem>
<listitem>
<simpara>Add the role to the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-cluster-role-to-user cluster-capacity-role \
    system:serviceaccount:&lt;namespace&gt;:cluster-capacity-sa</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;namespace&gt;</term>
<listitem>
<simpara>Specifies the namespace where the pod is located.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Define and create the pod spec:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: small-pod
  labels:
    app: guestbook
    tier: frontend
spec:
  containers:
  - name: php-redis
    image: gcr.io/google-samples/gb-frontend:v4
    imagePullPolicy: Always
    resources:
      limits:
        cpu: 150m
        memory: 100Mi
      requests:
        cpu: 150m
        memory: 100Mi</programlisting>
</listitem>
<listitem>
<simpara>Create the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Created a config map object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap cluster-capacity-configmap \
    --from-file=pod.yaml=pod.yaml</programlisting>
<simpara>The cluster capacity analysis is mounted in a volume using a config map object named <literal>cluster-capacity-configmap</literal> to mount the input pod spec file <literal>pod.yaml</literal> into a volume <literal>test-volume</literal> at the path <literal>/test-pod</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create the job using the below example of a job specification file:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: batch/v1
kind: Job
metadata:
  name: cluster-capacity-job
spec:
  parallelism: 1
  completions: 1
  template:
    metadata:
      name: cluster-capacity-pod
    spec:
        containers:
        - name: cluster-capacity
          image: openshift/origin-cluster-capacity
          imagePullPolicy: "Always"
          volumeMounts:
          - mountPath: /test-pod
            name: test-volume
          env:
          - name: CC_INCLUSTER <co xml:id="CO156-1"/>
            value: "true"
          command:
          - "/bin/sh"
          - "-ec"
          - |
            /bin/cluster-capacity --podspec=/test-pod/pod.yaml --verbose
        restartPolicy: "Never"
        serviceAccountName: cluster-capacity-sa
        volumes:
        - name: test-volume
          configMap:
            name: cluster-capacity-configmap</programlisting>
<calloutlist>
<callout arearefs="CO156-1">
<para>A required environment variable letting the cluster capacity tool know that it is running inside a cluster as a pod.
<?asciidoc-br?>
The <literal>pod.yaml</literal> key of the <literal>ConfigMap</literal> object is the same as the <literal>Pod</literal> spec file name, though it is not required. By doing this, the input pod spec file can be accessed inside the pod as <literal>/test-pod/pod.yaml</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the cluster capacity image as a job in a pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cluster-capacity-job.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the job logs to find the number of pods that can be scheduled in the
cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs jobs/cluster-capacity-job</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">small-pod pod requirements:
        - CPU: 150m
        - Memory: 100Mi

The cluster can schedule 52 instance(s) of the pod small-pod.

Termination reason: Unschedulable: No nodes are available that match all of the
following predicates:: Insufficient cpu (2).

Pod distribution among nodes:
small-pod
        - 192.168.124.214: 26 instance(s)
        - 192.168.124.120: 26 instance(s)</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cluster-limit-ranges">
<title>Restrict resource consumption with limit ranges</title>

<simpara>By default, containers run with unbounded compute resources on an {product-title}
cluster. With limit ranges, you can restrict resource consumption for specific
objects in a project:</simpara>
<itemizedlist>
<listitem>
<simpara>pods and containers: You can set minimum and maximum requirements for CPU and
memory for pods and their containers.</simpara>
</listitem>
<listitem>
<simpara>Image streams: You can set limits on the number of images and tags in an
<literal>ImageStream</literal> object.</simpara>
</listitem>
<listitem>
<simpara>Images: You can limit the size of images that can be pushed to an internal
registry.</simpara>
</listitem>
<listitem>
<simpara>Persistent volume claims (PVC): You can restrict the size of the PVCs that can
be requested.</simpara>
</listitem>
</itemizedlist>
<simpara>If a pod does not meet the constraints imposed by the limit
range, the pod cannot be created in the namespace.</simpara>
<section xml:id="nodes-cluster-limit-ranges-about_nodes-cluster-limit-ranges">
<title>About limit ranges</title>
<simpara>A limit range, defined by a <literal>LimitRange</literal> object, restricts resource
consumption in a project. In the project you can set specific resource
limits for a pod, container, image, image stream, or
persistent volume claim (PVC).</simpara>
<simpara>All requests to create and modify resources are evaluated against each
<literal>LimitRange</literal> object in the project. If the resource violates any of the
enumerated constraints, the resource is rejected.</simpara>
<simpara>The following shows a limit range object for all components: pod, container,
image, image stream, or PVC. You can configure limits for any or all of these
components in the same object. You create a different limit range object for
each project where you want to control resources.</simpara>
<formalpara>
<title>Sample limit range object for a container</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits"
spec:
  limits:
    - type: "Container"
      max:
        cpu: "2"
        memory: "1Gi"
      min:
        cpu: "100m"
        memory: "4Mi"
      default:
        cpu: "300m"
        memory: "200Mi"
      defaultRequest:
        cpu: "200m"
        memory: "100Mi"
      maxLimitRequestRatio:
        cpu: "10"</programlisting>
</para>
</formalpara>
<section xml:id="nodes-cluster-limit-ranges-limits_nodes-cluster-limit-ranges">
<title>About component limits</title>
<simpara>The following examples show limit range parameters for each component. The
examples are broken out for clarity. You can create a single <literal>LimitRange</literal> object
for any or all components as necessary.</simpara>
<section xml:id="nodes-cluster-limit-container-limits">
<title>Container limits</title>
<simpara>A limit range allows you to specify the minimum and maximum CPU and memory that each container
in a pod can request for a specific project. If a container is created in the project,
the container CPU and memory requests in the <literal>Pod</literal> spec must comply with the values set in the
<literal>LimitRange</literal> object. If not, the pod does not get created.</simpara>
<itemizedlist>
<listitem>
<simpara>The container CPU or memory request and limit must be greater than or equal to the
<literal>min</literal> resource constraint for containers that are specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The container CPU or memory request and limit must be less than or equal to the
<literal>max</literal> resource constraint for containers that are specified in the <literal>LimitRange</literal> object.</simpara>
<simpara>If the <literal>LimitRange</literal> object defines a <literal>max</literal> CPU, you do not need to define a CPU
<literal>request</literal> value in the <literal>Pod</literal> spec. But you must specify a CPU <literal>limit</literal> value that
satisfies the maximum CPU constraint specified in the limit range.</simpara>
</listitem>
<listitem>
<simpara>The ratio of the container limits to requests must be
less than or equal to the <literal>maxLimitRequestRatio</literal> value for containers that
is specified in the <literal>LimitRange</literal> object.</simpara>
<simpara>If the <literal>LimitRange</literal> object defines a <literal>maxLimitRequestRatio</literal> constraint, any new
containers must have both a <literal>request</literal> and a <literal>limit</literal> value. {product-title}
calculates the limit-to-request ratio by dividing the <literal>limit</literal> by the
<literal>request</literal>. This value should be a non-negative integer greater than 1.</simpara>
<simpara>For example, if a container has <literal>cpu: 500</literal> in the <literal>limit</literal> value, and
<literal>cpu: 100</literal> in the <literal>request</literal> value, the limit-to-request ratio for <literal>cpu</literal> is
<literal>5</literal>. This ratio must be less than or equal to the <literal>maxLimitRequestRatio</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>If the <literal>Pod</literal> spec does not specify a container resource memory or limit,
the <literal>default</literal> or <literal>defaultRequest</literal> CPU and memory values for containers
specified in the limit range object are assigned to the container.</simpara>
<formalpara>
<title>Container <literal>LimitRange</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO157-1"/>
spec:
  limits:
    - type: "Container"
      max:
        cpu: "2" <co xml:id="CO157-2"/>
        memory: "1Gi" <co xml:id="CO157-3"/>
      min:
        cpu: "100m" <co xml:id="CO157-4"/>
        memory: "4Mi" <co xml:id="CO157-5"/>
      default:
        cpu: "300m" <co xml:id="CO157-6"/>
        memory: "200Mi" <co xml:id="CO157-7"/>
      defaultRequest:
        cpu: "200m" <co xml:id="CO157-8"/>
        memory: "100Mi" <co xml:id="CO157-9"/>
      maxLimitRequestRatio:
        cpu: "10" <co xml:id="CO157-10"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO157-1">
<para>The name of the LimitRange object.</para>
</callout>
<callout arearefs="CO157-2">
<para>The maximum amount of CPU that a single container in a pod can request.</para>
</callout>
<callout arearefs="CO157-3">
<para>The maximum amount of memory that a single container in a pod can request.</para>
</callout>
<callout arearefs="CO157-4">
<para>The minimum amount of CPU that a single container in a pod can request.</para>
</callout>
<callout arearefs="CO157-5">
<para>The minimum amount of memory that a single container in a pod can request.</para>
</callout>
<callout arearefs="CO157-6">
<para>The default amount of CPU that a container can use if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO157-7">
<para>The default amount of memory that a container can use if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO157-8">
<para>The default amount of CPU that a container can request if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO157-9">
<para>The default amount of memory that a container can request if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO157-10">
<para>The maximum limit-to-request ratio for a container.</para>
</callout>
</calloutlist>
</section>
<section xml:id="nodes-cluster-limit-pod-limits">
<title>Pod limits</title>
<simpara>A limit range allows you to specify the minimum and maximum CPU and memory limits for all containers
across a pod in a given project. To create a container in the project, the container CPU and memory
requests in the <literal>Pod</literal> spec must comply with the values set in the <literal>LimitRange</literal> object. If not,
the pod does not get created.</simpara>
<simpara>If the <literal>Pod</literal> spec does not specify a container resource memory or limit,
the <literal>default</literal> or <literal>defaultRequest</literal> CPU and memory values for containers
specified in the limit range object are assigned to the container.</simpara>
<simpara>Across all containers in a pod, the following must hold true:</simpara>
<itemizedlist>
<listitem>
<simpara>The container CPU or memory request and limit must be greater than or equal to the
<literal>min</literal> resource constraints for pods that are specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The container CPU or memory request and limit must be less than or equal to the
<literal>max</literal> resource constraints for pods that are specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The ratio of the container limits to requests must be less than or equal to
the <literal>maxLimitRequestRatio</literal> constraint specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Pod <literal>LimitRange</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO158-1"/>
spec:
  limits:
    - type: "Pod"
      max:
        cpu: "2" <co xml:id="CO158-2"/>
        memory: "1Gi" <co xml:id="CO158-3"/>
      min:
        cpu: "200m" <co xml:id="CO158-4"/>
        memory: "6Mi" <co xml:id="CO158-5"/>
      maxLimitRequestRatio:
        cpu: "10" <co xml:id="CO158-6"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO158-1">
<para>The name of the limit range object.</para>
</callout>
<callout arearefs="CO158-2">
<para>The maximum amount of CPU that a pod can request across all containers.</para>
</callout>
<callout arearefs="CO158-3">
<para>The maximum amount of memory that a pod can request across all containers.</para>
</callout>
<callout arearefs="CO158-4">
<para>The minimum amount of CPU that a pod can request across all containers.</para>
</callout>
<callout arearefs="CO158-5">
<para>The minimum amount of memory that a pod can request across all containers.</para>
</callout>
<callout arearefs="CO158-6">
<para>The maximum limit-to-request ratio for a container.</para>
</callout>
</calloutlist>
</section>
<section xml:id="nodes-cluster-limit-image-limits">
<title>Image limits</title>
<simpara>A <literal>LimitRange</literal> object allows you to specify the maximum size of an image
that can be pushed to an OpenShift image registry.</simpara>
<simpara>When pushing images to an OpenShift image registry, the following must hold true:</simpara>
<itemizedlist>
<listitem>
<simpara>The size of the image must be less than or equal to the <literal>max</literal> size for
images that is specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Image <literal>LimitRange</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO159-1"/>
spec:
  limits:
    - type: openshift.io/Image
      max:
        storage: 1Gi <co xml:id="CO159-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO159-1">
<para>The name of the <literal>LimitRange</literal> object.</para>
</callout>
<callout arearefs="CO159-2">
<para>The maximum size of an image that can be pushed to an OpenShift image registry.</para>
</callout>
</calloutlist>
<note>
<simpara>To prevent blobs that exceed the limit from being uploaded to the registry, the
registry must be configured to enforce quotas.</simpara>
</note>
<warning>
<simpara>The image size is not always available in the manifest of an uploaded image.
This is especially the case for images built with Docker 1.10 or higher and
pushed to a v2 registry. If such an image is pulled with an older Docker daemon,
the image manifest is converted by the registry to schema v1 lacking all
the size information. No storage limit set on images prevent it from being
uploaded.</simpara>
<simpara><link xl:href="https://github.com/openshift/origin/issues/7706">The issue</link> is being
addressed.</simpara>
</warning>
</section>
<section xml:id="nodes-cluster-limit-stream-limits">
<title>Image stream limits</title>
<simpara>A <literal>LimitRange</literal> object allows you to specify limits for image streams.</simpara>
<simpara>For each image stream, the following must hold true:</simpara>
<itemizedlist>
<listitem>
<simpara>The number of image tags in an <literal>ImageStream</literal> specification must be less
than or equal to the <literal>openshift.io/image-tags</literal> constraint in the <literal>LimitRange</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The number of unique references to images in an <literal>ImageStream</literal> specification
must be less than or equal to the <literal>openshift.io/images</literal> constraint in the limit
range object.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Imagestream <literal>LimitRange</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO160-1"/>
spec:
  limits:
    - type: openshift.io/ImageStream
      max:
        openshift.io/image-tags: 20 <co xml:id="CO160-2"/>
        openshift.io/images: 30 <co xml:id="CO160-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO160-1">
<para>The name of the <literal>LimitRange</literal> object.</para>
</callout>
<callout arearefs="CO160-2">
<para>The maximum number of unique image tags in the <literal>imagestream.spec.tags</literal>
parameter in imagestream spec.</para>
</callout>
<callout arearefs="CO160-3">
<para>The maximum number of unique image references in the <literal>imagestream.status.tags</literal>
parameter in the <literal>imagestream</literal> spec.</para>
</callout>
</calloutlist>
<simpara>The <literal>openshift.io/image-tags</literal> resource represents unique image
references. Possible references are an <literal><emphasis role="strong">ImageStreamTag</emphasis></literal>, an
<literal><emphasis role="strong">ImageStreamImage</emphasis></literal> and a <literal><emphasis role="strong">DockerImage</emphasis></literal>. Tags can be created using
the <literal>oc tag</literal> and <literal>oc import-image</literal> commands. No distinction
is made between internal and external references. However, each unique reference
tagged in an <literal>ImageStream</literal> specification is counted just once. It does not
restrict pushes to an internal container image registry in any way, but is useful for tag
restriction.</simpara>
<simpara>The <literal>openshift.io/images</literal> resource represents unique image names recorded in
image stream status. It allows for restriction of a number of images that can be
pushed to the OpenShift image registry. Internal and external references are not
distinguished.</simpara>
</section>
<section xml:id="nodes-cluster-limit-pvc-limits">
<title>Persistent volume claim limits</title>
<simpara>A <literal>LimitRange</literal> object allows you to restrict the storage requested in a persistent volume claim (PVC).</simpara>
<simpara>Across all persistent volume claims in a project, the following must hold true:</simpara>
<itemizedlist>
<listitem>
<simpara>The resource request in a persistent volume claim (PVC) must be greater than or equal
the <literal>min</literal> constraint for PVCs that is specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The resource request in a persistent volume claim (PVC) must be less than or equal
the <literal>max</literal> constraint for PVCs that is specified in the <literal>LimitRange</literal> object.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>PVC <literal>LimitRange</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO161-1"/>
spec:
  limits:
    - type: "PersistentVolumeClaim"
      min:
        storage: "2Gi" <co xml:id="CO161-2"/>
      max:
        storage: "50Gi" <co xml:id="CO161-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO161-1">
<para>The name of the <literal>LimitRange</literal> object.</para>
</callout>
<callout arearefs="CO161-2">
<para>The minimum amount of storage that can be requested in a persistent volume claim.</para>
</callout>
<callout arearefs="CO161-3">
<para>The maximum amount of storage that can be requested in a persistent volume claim.</para>
</callout>
</calloutlist>
</section>
</section>
</section>
<section xml:id="nodes-cluster-limit-creating_nodes-cluster-limit-ranges">
<title>Creating a Limit Range</title>
<simpara>To apply a limit range to a project:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a <literal>LimitRange</literal> object with your required specifications:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "LimitRange"
metadata:
  name: "resource-limits" <co xml:id="CO162-1"/>
spec:
  limits:
    - type: "Pod" <co xml:id="CO162-2"/>
      max:
        cpu: "2"
        memory: "1Gi"
      min:
        cpu: "200m"
        memory: "6Mi"
    - type: "Container" <co xml:id="CO162-3"/>
      max:
        cpu: "2"
        memory: "1Gi"
      min:
        cpu: "100m"
        memory: "4Mi"
      default: <co xml:id="CO162-4"/>
        cpu: "300m"
        memory: "200Mi"
      defaultRequest: <co xml:id="CO162-5"/>
        cpu: "200m"
        memory: "100Mi"
      maxLimitRequestRatio: <co xml:id="CO162-6"/>
        cpu: "10"
    - type: openshift.io/Image <co xml:id="CO162-7"/>
      max:
        storage: 1Gi
    - type: openshift.io/ImageStream <co xml:id="CO162-8"/>
      max:
        openshift.io/image-tags: 20
        openshift.io/images: 30
    - type: "PersistentVolumeClaim" <co xml:id="CO162-9"/>
      min:
        storage: "2Gi"
      max:
        storage: "50Gi"</programlisting>
<calloutlist>
<callout arearefs="CO162-1">
<para>Specify a name for the <literal>LimitRange</literal> object.</para>
</callout>
<callout arearefs="CO162-2">
<para>To set limits for a pod, specify the minimum and maximum CPU and memory requests as needed.</para>
</callout>
<callout arearefs="CO162-3">
<para>To set limits for a container, specify the minimum and maximum CPU and memory requests as needed.</para>
</callout>
<callout arearefs="CO162-4">
<para>Optional. For a container, specify the default amount of CPU or memory that a container can use, if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO162-5">
<para>Optional. For a container, specify the default amount of CPU or memory that a container can request, if not specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO162-6">
<para>Optional. For a container, specify the maximum limit-to-request ratio that can be specified in the <literal>Pod</literal> spec.</para>
</callout>
<callout arearefs="CO162-7">
<para>To set limits for an Image object, set the maximum size of an image that can be pushed to an OpenShift image registry.</para>
</callout>
<callout arearefs="CO162-8">
<para>To set limits for an image stream, set the maximum number of image tags and references that can be in the <literal>ImageStream</literal> object file, as needed.</para>
</callout>
<callout arearefs="CO162-9">
<para>To set limits for a persistent volume claim, set the minimum and maximum amount of storage that can be requested.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;limit_range_file&gt; -n &lt;project&gt; <co xml:id="CO163-1"/></programlisting>
<calloutlist>
<callout arearefs="CO163-1">
<para>Specify the name of the YAML file you created and the project where you want the limits to apply.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-limit-viewing_nodes-cluster-limit-ranges">
<title>Viewing a limit</title>
<simpara>You can view any limits defined in a project by navigating in the web
console to the project&#8217;s <emphasis role="strong">Quota</emphasis> page.</simpara>
<simpara>You can also use the CLI to view limit range details:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Get the list of <literal>LimitRange</literal> object defined in the project. For example, for a
project called <emphasis role="strong">demoproject</emphasis>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get limits -n demoproject</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">NAME              CREATED AT
resource-limits   2020-07-15T17:14:23Z</programlisting>
</listitem>
<listitem>
<simpara>Describe the <literal>LimitRange</literal> object you are interested in, for example the
<literal>resource-limits</literal> limit range:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe limits resource-limits -n demoproject</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">Name:                           resource-limits
Namespace:                      demoproject
Type                            Resource                Min     Max     Default Request Default Limit   Max Limit/Request Ratio
----                            --------                ---     ---     --------------- -------------   -----------------------
Pod                             cpu                     200m    2       -               -               -
Pod                             memory                  6Mi     1Gi     -               -               -
Container                       cpu                     100m    2       200m            300m            10
Container                       memory                  4Mi     1Gi     100Mi           200Mi           -
openshift.io/Image              storage                 -       1Gi     -               -               -
openshift.io/ImageStream        openshift.io/image      -       12      -               -               -
openshift.io/ImageStream        openshift.io/image-tags -       10      -               -               -
PersistentVolumeClaim           storage                 -       50Gi    -               -               -</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-limit-ranges-deleting_nodes-cluster-limit-ranges">
<title>Deleting a Limit Range</title>
<simpara>To remove any active <literal>LimitRange</literal> object to no longer enforce the limits in a project:</simpara>
<itemizedlist>
<listitem>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete limits &lt;limit_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cluster-resource-configure">
<title>Configuring cluster memory to meet container memory and risk requirements</title>

<simpara>As a cluster administrator, you can help your clusters operate efficiently through
managing application memory by:</simpara>
<itemizedlist>
<listitem>
<simpara>Determining the memory and risk requirements of a containerized application
component and configuring the container memory parameters to suit those
requirements.</simpara>
</listitem>
<listitem>
<simpara>Configuring containerized application runtimes (for example, OpenJDK) to adhere
optimally to the configured container memory parameters.</simpara>
</listitem>
<listitem>
<simpara>Diagnosing and resolving memory-related error conditions associated with
running in a container.</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-cluster-resource-configure-about_nodes-cluster-resource-configure">
<title>Understanding managing application memory</title>
<simpara>It is recommended to fully read the overview of how {product-title} manages
Compute Resources before proceeding.</simpara>
<simpara>For each kind of resource (memory, CPU, storage), {product-title} allows
optional <emphasis role="strong">request</emphasis> and <emphasis role="strong">limit</emphasis> values to be placed on each container in a
pod.</simpara>
<simpara>Note the following about memory requests and memory limits:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Memory request</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>The memory request value, if specified, influences the {product-title}
scheduler. The scheduler considers the memory request when scheduling a
container to a node, then fences off the requested memory on the chosen node
for the use of the container.</simpara>
</listitem>
<listitem>
<simpara>If a node&#8217;s memory is exhausted, {product-title} prioritizes evicting its
containers whose memory usage most exceeds their memory request. In serious
cases of memory exhaustion, the node OOM killer may select and kill a
process in a container based on a similar metric.</simpara>
</listitem>
<listitem>
<simpara>The cluster administrator can assign quota or assign default values for the memory request value.</simpara>
</listitem>
<listitem>
<simpara>The cluster administrator can override the memory request values that a developer specifies, to manage cluster overcommit.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Memory limit</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>The memory limit value, if specified, provides a hard limit on the memory
that can be allocated across all the processes in a container.</simpara>
</listitem>
<listitem>
<simpara>If the memory allocated by all of the processes in a container exceeds the
memory limit, the node Out of Memory (OOM) killer will immediately select and kill a
process in the container.</simpara>
</listitem>
<listitem>
<simpara>If both memory request and limit are specified, the memory limit value must
be greater than or equal to the memory request.</simpara>
</listitem>
<listitem>
<simpara>The cluster administrator can assign quota or assign default values for the memory limit value.</simpara>
</listitem>
<listitem>
<simpara>The minimum memory limit is 12 MB. If a container fails to start due to a <literal>Cannot allocate memory</literal> pod event, the memory limit is too low.
Either increase or remove the memory limit. Removing the limit allows pods to consume unbounded node resources.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<section xml:id="nodes-cluster-resource-configure-about-memory_nodes-cluster-resource-configure">
<title>Managing application memory strategy</title>
<simpara>The steps for sizing application memory on {product-title} are as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Determine expected container memory usage</emphasis></simpara>
<simpara>Determine expected mean and peak container memory usage, empirically if
necessary (for example, by separate load testing). Remember to consider all the
processes that may potentially run in parallel in the container: for example,
does the main application spawn any ancillary scripts?</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Determine risk appetite</emphasis></simpara>
<simpara>Determine risk appetite for eviction. If the risk appetite is low, the
container should request memory according to the expected peak usage plus a
percentage safety margin. If the risk appetite is higher, it may be more
appropriate to request memory according to the expected mean usage.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Set container memory request</emphasis></simpara>
<simpara>Set container memory request based on the above. The more accurately the
request represents the application memory usage, the better. If the request is
too high, cluster and quota usage will be inefficient. If the request is too
low, the chances of application eviction increase.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Set container memory limit, if required</emphasis></simpara>
<simpara>Set container memory limit, if required. Setting a limit has the effect of
immediately killing a container process if the combined memory usage of all
processes in the container exceeds the limit, and is therefore a mixed blessing.
On the one hand, it may make unanticipated excess memory usage obvious early
("fail fast"); on the other hand it also terminates processes abruptly.</simpara>
<simpara>Note that some {product-title} clusters may require a limit value to be set;
some may override the request based on the limit; and some application images
rely on a limit value being set as this is easier to detect than a request
value.</simpara>
<simpara>If the memory limit is set, it should not be set to less than the expected peak
container memory usage plus a percentage safety margin.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Ensure application is tuned</emphasis></simpara>
<simpara>Ensure application is tuned with respect to configured request and limit values,
if appropriate. This step is particularly relevant to applications which pool
memory, such as the JVM. The rest of this page discusses this.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-overcommit.xml#nodes-cluster-overcommit-reserving-memory_nodes-cluster-overcommit">Understanding compute resources and containers</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cluster-resource-configure-jdk_nodes-cluster-resource-configure">
<title>Understanding OpenJDK settings for {product-title}</title>
<simpara>The default OpenJDK settings do not work well with containerized
environments. As a result, some additional Java memory
settings must always be provided whenever running the OpenJDK in a container.</simpara>
<simpara>The JVM memory layout is complex, version dependent, and describing it in detail
is beyond the scope of this documentation. However, as a starting point for
running OpenJDK in a container, at least the following three memory-related
tasks are key:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Overriding the JVM maximum heap size.</simpara>
</listitem>
<listitem>
<simpara>Encouraging the JVM to release unused memory to the operating system, if
appropriate.</simpara>
</listitem>
<listitem>
<simpara>Ensuring all JVM processes within a container are appropriately configured.</simpara>
</listitem>
</orderedlist>
<simpara>Optimally tuning JVM workloads for running in a container is beyond the scope of
this documentation, and may involve setting multiple additional JVM options.</simpara>
<section xml:id="nodes-cluster-resource-configure-jdk-heap_nodes-cluster-resource-configure">
<title>Understanding how to override the JVM maximum heap size</title>
<simpara>For many Java workloads, the JVM heap is the largest single consumer of memory.
Currently, the OpenJDK defaults to allowing up to 1/4 (1/<literal>-XX:MaxRAMFraction</literal>)
of the compute node&#8217;s memory to be used for the heap, regardless of whether the
OpenJDK is running in a container or not. It is therefore <emphasis role="strong">essential</emphasis> to
override this behavior, especially if a container memory limit is also set.</simpara>
<simpara>There are at least two ways the above can be achieved:</simpara>
<itemizedlist>
<listitem>
<simpara>If the container memory limit is set and the experimental options are
supported by the JVM, set <literal>-XX:+UnlockExperimentalVMOptions
-XX:+UseCGroupMemoryLimitForHeap</literal>.</simpara>
<note>
<simpara>The <literal>UseCGroupMemoryLimitForHeap</literal> option has been removed in JDK 11. Use <literal>-XX:+UseContainerSupport</literal> instead.</simpara>
</note>
<simpara>This sets <literal>-XX:MaxRAM</literal> to the container memory limit, and the maximum heap size
(<literal>-XX:MaxHeapSize</literal> / <literal>-Xmx</literal>) to 1/<literal>-XX:MaxRAMFraction</literal> (1/4 by default).</simpara>
</listitem>
<listitem>
<simpara>Directly override one of <literal>-XX:MaxRAM</literal>, <literal>-XX:MaxHeapSize</literal> or <literal>-Xmx</literal>.</simpara>
<simpara>This option involves hard-coding a value, but has the advantage of allowing a
safety margin to be calculated.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cluster-resource-configure-jdk-unused_nodes-cluster-resource-configure">
<title>Understanding how to encourage the JVM to release unused memory to the operating system</title>
<simpara>By default, the OpenJDK does not aggressively return unused memory to the
operating system. This may be appropriate for many containerized Java
workloads, but notable exceptions include workloads where additional active
processes co-exist with a JVM within a container, whether those additional
processes are native, additional JVMs, or a combination of the two.</simpara>
<simpara>Java-based agents can use the following JVM arguments to encourage the JVM
to release unused memory to the operating system:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">-XX:+UseParallelGC
-XX:MinHeapFreeRatio=5 -XX:MaxHeapFreeRatio=10 -XX:GCTimeRatio=4
-XX:AdaptiveSizePolicyWeight=90.</programlisting>
<simpara>These arguments are intended to return heap
memory to the operating system whenever allocated memory exceeds 110% of in-use
memory (<literal>-XX:MaxHeapFreeRatio</literal>), spending up to 20% of CPU time in the garbage
collector (<literal>-XX:GCTimeRatio</literal>). At no time will the application heap allocation
be less than the initial heap allocation (overridden by <literal>-XX:InitialHeapSize</literal> /
<literal>-Xms</literal>). Detailed additional information is available
<link xl:href="https://developers.redhat.com/blog/2014/07/15/dude-wheres-my-paas-memory-tuning-javas-footprint-in-openshift-part-1/">Tuning Java&#8217;s footprint in OpenShift (Part 1)</link>,
<link xl:href="https://developers.redhat.com/blog/2014/07/22/dude-wheres-my-paas-memory-tuning-javas-footprint-in-openshift-part-2/">Tuning Java&#8217;s footprint in OpenShift (Part 2)</link>,
and at
<link xl:href="https://developers.redhat.com/blog/2017/04/04/openjdk-and-containers/">OpenJDK
and Containers</link>.</simpara>
</section>
<section xml:id="nodes-cluster-resource-configure-jdk-proc_nodes-cluster-resource-configure">
<title>Understanding how to ensure all JVM processes within a container are appropriately configured</title>
<simpara>In the case that multiple JVMs run in the same container, it is essential to
ensure that they are all configured appropriately. For many workloads it will
be necessary to grant each JVM a percentage memory budget, leaving a perhaps
substantial additional safety margin.</simpara>
<simpara>Many Java tools use different environment variables (<literal>JAVA_OPTS</literal>, <literal>GRADLE_OPTS</literal>, and so on) to configure their JVMs and it can be challenging to ensure
that the right settings are being passed to the right JVM.</simpara>
<simpara>The <literal>JAVA_TOOL_OPTIONS</literal> environment variable is always respected by the OpenJDK,
and values specified in <literal>JAVA_TOOL_OPTIONS</literal> will be overridden by other options
specified on the JVM command line. By default, to ensure that these options are
used by default for all JVM workloads run in the Java-based agent image, the {product-title} Jenkins
Maven agent image sets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">JAVA_TOOL_OPTIONS="-XX:+UnlockExperimentalVMOptions
-XX:+UseCGroupMemoryLimitForHeap -Dsun.zip.disableMemoryMapping=true"</programlisting>
<note>
<simpara>The <literal>UseCGroupMemoryLimitForHeap</literal> option has been removed in JDK 11. Use <literal>-XX:+UseContainerSupport</literal> instead.</simpara>
</note>
<simpara>This does not guarantee that additional options are not required, but is
intended to be a helpful starting point.</simpara>
</section>
</section>
<section xml:id="nodes-cluster-resource-configure-request-limit_nodes-cluster-resource-configure">
<title>Finding the memory request and limit from within a pod</title>
<simpara>An application wishing to dynamically discover its memory request and limit from
within a pod should use the Downward API.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure the pod to add the <literal>MEMORY_REQUEST</literal> and <literal>MEMORY_LIMIT</literal> stanzas:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a YAML file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: test
spec:
  containers:
  - name: test
    image: fedora:latest
    command:
    - sleep
    - "3600"
    env:
    - name: MEMORY_REQUEST <co xml:id="CO164-1"/>
      valueFrom:
        resourceFieldRef:
          containerName: test
          resource: requests.memory
    - name: MEMORY_LIMIT <co xml:id="CO164-2"/>
      valueFrom:
        resourceFieldRef:
          containerName: test
          resource: limits.memory
    resources:
      requests:
        memory: 384Mi
      limits:
        memory: 512Mi</programlisting>
<calloutlist>
<callout arearefs="CO164-1">
<para>Add this stanza to discover the application memory request value.</para>
</callout>
<callout arearefs="CO164-2">
<para>Add this stanza to discover the application memory limit value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Access the pod using a remote shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh test</programlisting>
</listitem>
<listitem>
<simpara>Check that the requested values were applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ env | grep MEMORY | sort</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">MEMORY_LIMIT=536870912
MEMORY_REQUEST=402653184</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<note>
<simpara>The memory limit value can also be read from inside the container by the
<literal>/sys/fs/cgroup/memory/memory.limit_in_bytes</literal> file.</simpara>
</note>
</section>
<section xml:id="nodes-cluster-resource-configure-oom_nodes-cluster-resource-configure">
<title>Understanding OOM kill policy</title>
<simpara>{product-title} can kill a process in a container if the total memory usage of
all the processes in the container exceeds the memory limit, or in serious cases
of node memory exhaustion.</simpara>
<simpara>When a process is Out of Memory (OOM) killed, this might result in the container
exiting immediately. If the container PID 1 process receives the <emphasis role="strong">SIGKILL</emphasis>, the
container will exit immediately. Otherwise, the container behavior is
dependent on the behavior of the other processes.</simpara>
<simpara>For example, a container process exited with code 137, indicating it received a SIGKILL signal.</simpara>
<simpara>If the container does not exit immediately, an OOM kill is detectable as
follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Access the pod using a remote shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc rsh test</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to see the current OOM kill count in <literal>/sys/fs/cgroup/memory/memory.oom_control</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ grep '^oom_kill ' /sys/fs/cgroup/memory/memory.oom_control</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">oom_kill 0</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to provoke an OOM kill:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sed -e '' &lt;/dev/zero</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Killed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to view the exit status of the <literal>sed</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $?</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">137</programlisting>
</para>
</formalpara>
<simpara>The <literal>137</literal> code indicates the container process exited with code 137, indicating it received a SIGKILL signal.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to see that the OOM kill counter in <literal>/sys/fs/cgroup/memory/memory.oom_control</literal> incremented:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ grep '^oom_kill ' /sys/fs/cgroup/memory/memory.oom_control</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">oom_kill 1</programlisting>
</para>
</formalpara>
<simpara>If one or more processes in a pod are OOM killed, when the pod subsequently
exits, whether immediately or not, it will have phase <emphasis role="strong">Failed</emphasis> and reason
<emphasis role="strong">OOMKilled</emphasis>. An OOM-killed pod might be restarted depending on the value of
<literal>restartPolicy</literal>. If not restarted, controllers such as the
replication controller will notice the pod&#8217;s failed status and create a new pod
to replace the old one.</simpara>
<simpara>Use the follwing command to get the pod status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY     STATUS      RESTARTS   AGE
test      0/1       OOMKilled   0          1m</programlisting>
</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>If the pod has not restarted, run the following command to view the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
status:
  containerStatuses:
  - name: test
    ready: false
    restartCount: 0
    state:
      terminated:
        exitCode: 137
        reason: OOMKilled
  phase: Failed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If restarted, run the following command to view the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
status:
  containerStatuses:
  - name: test
    ready: true
    restartCount: 1
    lastState:
      terminated:
        exitCode: 137
        reason: OOMKilled
    state:
      running:
  phase: Running</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-resource-configure-evicted_nodes-cluster-resource-configure">
<title>Understanding pod eviction</title>
<simpara>{product-title} may evict a pod from its node when the node&#8217;s memory is
exhausted. Depending on the extent of memory exhaustion, the eviction may or
may not be graceful. Graceful eviction implies the main process (PID 1) of each
container receiving a SIGTERM signal, then some time later a SIGKILL signal if
the process has not exited already. Non-graceful eviction implies the main
process of each container immediately receiving a SIGKILL signal.</simpara>
<simpara>An evicted pod has phase <emphasis role="strong">Failed</emphasis> and reason <emphasis role="strong">Evicted</emphasis>. It will not be
restarted, regardless of the value of <literal>restartPolicy</literal>. However, controllers
such as the replication controller will notice the pod&#8217;s failed status and create
a new pod to replace the old one.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      READY     STATUS    RESTARTS   AGE
test      0/1       Evicted   0          1m</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod test -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
status:
  message: 'Pod The node was low on resource: [MemoryPressure].'
  phase: Failed
  reason: Evicted</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="nodes-cluster-overcommit">
<title>Configuring your cluster to place pods on overcommitted nodes</title>

<simpara>In an <emphasis>overcommitted</emphasis> state, the sum of the container compute resource requests
and limits exceeds the resources available on the system. For example, you might
want to use overcommitment in development environments where a trade-off of
guaranteed performance for capacity is acceptable.</simpara>
<simpara>Containers can specify compute resource requests and limits. Requests are used
for scheduling your container and provide a minimum service guarantee. Limits
constrain the amount of compute resource that can be consumed on your node.</simpara>
<simpara>The scheduler attempts to optimize the compute resource use across all nodes
in your cluster. It places pods onto specific nodes, taking the pods' compute
resource requests and nodes' available capacity into consideration.</simpara>
<simpara>{product-title} administrators can control the level of overcommit and manage
container density on nodes. You can configure cluster-level overcommit using
the <link linkend="nodes-cluster-resource-override_nodes-cluster-overcommit">ClusterResourceOverride Operator</link>
to override the ratio between requests and limits set on developer containers.
In conjunction with <link linkend="nodes-cluster-node-overcommit_nodes-cluster-overcommit">node overcommit</link> and
<link xl:href="../../applications/deployments/managing-deployment-processes.xml#deployments-setting-resources_deployment-operations">project memory and CPU limits and defaults</link>, you can adjust the resource limit and request to achieve the desired level of overcommit.</simpara>
<note>
<simpara>In {product-title}, you must enable cluster-level overcommit. Node overcommitment is enabled by default.
See <link linkend="nodes-cluster-overcommit-node-disable_nodes-cluster-overcommit">Disabling overcommitment for a node</link>.</simpara>
</note>
<section xml:id="nodes-cluster-overcommit-resource-requests_nodes-cluster-overcommit">
<title>Resource requests and overcommitment</title>
<simpara>For each compute resource, a container may specify a resource request and limit.
Scheduling decisions are made based on the request to ensure that a node has
enough capacity available to meet the requested value. If a container specifies
limits, but omits requests, the requests are defaulted to the limits. A
container is not able to exceed the specified limit on the node.</simpara>
<simpara>The enforcement of limits is dependent upon the compute resource type. If a
container makes no request or limit, the container is scheduled to a node with
no resource guarantees. In practice, the container is able to consume as much of
the specified resource as is available with the lowest local priority. In low
resource situations, containers that specify no resource requests are given the
lowest quality of service.</simpara>
<simpara>Scheduling is based on resources requested, while quota and hard limits refer
to resource limits, which can be set higher than requested resources. The
difference between request and limit determines the level of overcommit;
for instance, if a container is given a memory request of 1Gi and a memory limit
of 2Gi, it is scheduled based on the 1Gi request being available on the node,
but could use up to 2Gi; so it is 200% overcommitted.</simpara>
</section>
<section xml:id="nodes-cluster-resource-override_nodes-cluster-overcommit">
<title>Cluster-level overcommit using the Cluster Resource Override Operator</title>
<simpara>The Cluster Resource Override Operator is an admission webhook that allows you to control the level of overcommit and manage
container density across all the nodes in your cluster. The Operator controls how nodes in specific projects can exceed defined memory and CPU limits.</simpara>
<simpara>You must install the Cluster Resource Override Operator using the {product-title} console or CLI as shown in the following sections.
During the installation, you create a <literal>ClusterResourceOverride</literal> custom resource (CR), where you set the level of overcommit, as shown in the
following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
    name: cluster <co xml:id="CO165-1"/>
spec:
  podResourceOverride:
    spec:
      memoryRequestToLimitPercent: 50 <co xml:id="CO165-2"/>
      cpuRequestToLimitPercent: 25 <co xml:id="CO165-3"/>
      limitCPUToMemoryPercent: 200 <co xml:id="CO165-4"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO165-1">
<para>The name must be <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO165-2">
<para>Optional. If a container memory limit has been specified or defaulted, the memory request is overridden to this percentage of the limit, between 1-100. The default is 50.</para>
</callout>
<callout arearefs="CO165-3">
<para>Optional. If a container CPU limit has been specified or defaulted, the CPU request is overridden to this percentage of the limit, between 1-100. The default is 25.</para>
</callout>
<callout arearefs="CO165-4">
<para>Optional. If a container memory limit has been specified or defaulted, the CPU limit is overridden to a percentage of the memory limit, if specified. Scaling 1Gi of RAM at 100 percent is equal to 1 CPU core. This is processed prior to overriding the CPU request (if configured). The default is 200.</para>
</callout>
</calloutlist>
<note>
<simpara>The Cluster Resource Override Operator overrides have no effect if limits have not
been set on containers. Create a <literal>LimitRange</literal> object with default limits per individual project
or configure limits in <literal>Pod</literal> specs for the overrides to apply.</simpara>
</note>
<simpara>When configured, overrides can be enabled per-project by applying the following
label to the Namespace object for each project:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:

# ...

  labels:
    clusterresourceoverrides.admission.autoscaling.openshift.io/enabled: "true"

# ...</programlisting>
<simpara>The Operator watches for the <literal>ClusterResourceOverride</literal> CR and ensures that the <literal>ClusterResourceOverride</literal> admission webhook is installed into the same namespace as the operator.</simpara>
<section xml:id="nodes-cluster-resource-override-deploy-console_nodes-cluster-overcommit">
<title>Installing the Cluster Resource Override Operator using the web console</title>
<simpara>You can use the {product-title} web console to install the Cluster Resource Override Operator to help control overcommit in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Cluster Resource Override Operator has no effect if limits have not
been set on containers. You must specify default limits for a project using a <literal>LimitRange</literal> object or configure limits in <literal>Pod</literal> specs for the overrides to apply.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the Cluster Resource Override Operator using the {product-title} web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the {product-title} web console, navigate to <emphasis role="strong">Home</emphasis> &#8594; <emphasis role="strong">Projects</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Create Project</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Specify <literal>clusterresourceoverride-operator</literal> as the name of the project.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose  <emphasis role="strong">ClusterResourceOverride Operator</emphasis> from the list of available Operators and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, make sure <emphasis role="strong">A specific Namespace on the cluster</emphasis> is selected for <emphasis role="strong">Installation Mode</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Make sure <emphasis role="strong">clusterresourceoverride-operator</emphasis> is selected for <emphasis role="strong">Installed Namespace</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select an <emphasis role="strong">Update Channel</emphasis> and <emphasis role="strong">Approval Strategy</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, click <emphasis role="strong">ClusterResourceOverride</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the <emphasis role="strong">ClusterResourceOverride Operator</emphasis> details page, click <emphasis role="strong">Create ClusterResourceOverride</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Create ClusterResourceOverride</emphasis> page, click <emphasis role="strong">YAML view</emphasis> and edit the YAML template to set the overcommit values as needed:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
  name: cluster <co xml:id="CO166-1"/>
spec:
  podResourceOverride:
    spec:
      memoryRequestToLimitPercent: 50 <co xml:id="CO166-2"/>
      cpuRequestToLimitPercent: 25 <co xml:id="CO166-3"/>
      limitCPUToMemoryPercent: 200 <co xml:id="CO166-4"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO166-1">
<para>The name must be <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO166-2">
<para>Optional. Specify the percentage to override the container memory limit, if used, between 1-100. The default is 50.</para>
</callout>
<callout arearefs="CO166-3">
<para>Optional. Specify the percentage to override the container CPU limit, if used, between 1-100. The default is 25.</para>
</callout>
<callout arearefs="CO166-4">
<para>Optional. Specify the percentage to override the container memory limit, if used. Scaling 1Gi of RAM at 100 percent is equal to 1 CPU core. This is processed prior to overriding the CPU request, if configured. The default is 200.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check the current state of the admission webhook by checking the status of the cluster custom resource:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the <emphasis role="strong">ClusterResourceOverride Operator</emphasis> page, click <emphasis role="strong">cluster</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">ClusterResourceOverride Details</emphasis> page, click <emphasis role="strong">YAML</emphasis>. The <literal>mutatingWebhookConfigurationRef</literal> section appears when the webhook is called.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"operator.autoscaling.openshift.io/v1","kind":"ClusterResourceOverride","metadata":{"annotations":{},"name":"cluster"},"spec":{"podResourceOverride":{"spec":{"cpuRequestToLimitPercent":25,"limitCPUToMemoryPercent":200,"memoryRequestToLimitPercent":50}}}}
  creationTimestamp: "2019-12-18T22:35:02Z"
  generation: 1
  name: cluster
  resourceVersion: "127622"
  selfLink: /apis/operator.autoscaling.openshift.io/v1/clusterresourceoverrides/cluster
  uid: 978fc959-1717-4bd1-97d0-ae00ee111e8d
spec:
  podResourceOverride:
    spec:
      cpuRequestToLimitPercent: 25
      limitCPUToMemoryPercent: 200
      memoryRequestToLimitPercent: 50
status:

# ...

    mutatingWebhookConfigurationRef: <co xml:id="CO167-1"/>
      apiVersion: admissionregistration.k8s.io/v1
      kind: MutatingWebhookConfiguration
      name: clusterresourceoverrides.admission.autoscaling.openshift.io
      resourceVersion: "127621"
      uid: 98b3b8ae-d5ce-462b-8ab5-a729ea8f38f3

# ...</programlisting>
<calloutlist>
<callout arearefs="CO167-1">
<para>Reference to the <literal>ClusterResourceOverride</literal> admission webhook.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-resource-override-deploy-cli_nodes-cluster-overcommit">
<title>Installing the Cluster Resource Override Operator using the CLI</title>
<simpara>You can use the {product-title} CLI to install the Cluster Resource Override Operator to help control overcommit in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Cluster Resource Override Operator has no effect if limits have not been set on containers. You must specify default limits for a project using a <literal>LimitRange</literal> object or configure limits in <literal>Pod</literal> specs for the overrides to apply.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the Cluster Resource Override Operator using the CLI:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a namespace for the Cluster Resource Override Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>Namespace</literal> object YAML file (for example, <literal>cro-namespace.yaml</literal>) for the Cluster Resource Override Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: clusterresourceoverride-operator</programlisting>
</listitem>
<listitem>
<simpara>Create the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cro-namespace.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an Operator group:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file (for example, cro-og.yaml) for the Cluster Resource Override Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: clusterresourceoverride-operator
  namespace: clusterresourceoverride-operator
spec:
  targetNamespaces:
    - clusterresourceoverride-operator</programlisting>
</listitem>
<listitem>
<simpara>Create the Operator Group:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cro-og.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a subscription:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file (for example, cro-sub.yaml) for the Cluster Resource Override Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: clusterresourceoverride
  namespace: clusterresourceoverride-operator
spec:
  channel: "{product-version}"
  name: clusterresourceoverride
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Create the subscription:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cro-sub.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>ClusterResourceOverride</literal> custom resource (CR) object in the <literal>clusterresourceoverride-operator</literal> namespace:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Change to the <literal>clusterresourceoverride-operator</literal> namespace.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project clusterresourceoverride-operator</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>ClusterResourceOverride</literal> object YAML file (for example, cro-cr.yaml) for the Cluster Resource Override Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
    name: cluster <co xml:id="CO168-1"/>
spec:
  podResourceOverride:
    spec:
      memoryRequestToLimitPercent: 50 <co xml:id="CO168-2"/>
      cpuRequestToLimitPercent: 25 <co xml:id="CO168-3"/>
      limitCPUToMemoryPercent: 200 <co xml:id="CO168-4"/></programlisting>
<calloutlist>
<callout arearefs="CO168-1">
<para>The name must be <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO168-2">
<para>Optional. Specify the percentage to override the container memory limit, if used, between 1-100. The default is 50.</para>
</callout>
<callout arearefs="CO168-3">
<para>Optional. Specify the percentage to override the container CPU limit, if used, between 1-100. The default is 25.</para>
</callout>
<callout arearefs="CO168-4">
<para>Optional. Specify the percentage to override the container memory limit, if used. Scaling 1Gi of RAM at 100 percent is equal to 1 CPU core. This is processed prior to overriding the CPU request, if configured. The default is 200.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterResourceOverride</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cro-cr.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify the current state of the admission webhook by checking the status of the cluster custom resource.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterresourceoverride cluster -n clusterresourceoverride-operator -o yaml</programlisting>
<simpara>The <literal>mutatingWebhookConfigurationRef</literal> section appears when the webhook is called.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"operator.autoscaling.openshift.io/v1","kind":"ClusterResourceOverride","metadata":{"annotations":{},"name":"cluster"},"spec":{"podResourceOverride":{"spec":{"cpuRequestToLimitPercent":25,"limitCPUToMemoryPercent":200,"memoryRequestToLimitPercent":50}}}}
  creationTimestamp: "2019-12-18T22:35:02Z"
  generation: 1
  name: cluster
  resourceVersion: "127622"
  selfLink: /apis/operator.autoscaling.openshift.io/v1/clusterresourceoverrides/cluster
  uid: 978fc959-1717-4bd1-97d0-ae00ee111e8d
spec:
  podResourceOverride:
    spec:
      cpuRequestToLimitPercent: 25
      limitCPUToMemoryPercent: 200
      memoryRequestToLimitPercent: 50
status:

# ...

    mutatingWebhookConfigurationRef: <co xml:id="CO169-1"/>
      apiVersion: admissionregistration.k8s.io/v1
      kind: MutatingWebhookConfiguration
      name: clusterresourceoverrides.admission.autoscaling.openshift.io
      resourceVersion: "127621"
      uid: 98b3b8ae-d5ce-462b-8ab5-a729ea8f38f3

# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO169-1">
<para>Reference to the <literal>ClusterResourceOverride</literal> admission webhook.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-resource-configure_nodes-cluster-overcommit">
<title>Configuring cluster-level overcommit</title>
<simpara>The Cluster Resource Override Operator requires a <literal>ClusterResourceOverride</literal> custom resource (CR)
and a label for each project where you want the Operator to control overcommit.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Cluster Resource Override Operator has no effect if limits have not
been set on containers. You must specify default limits for a project using a <literal>LimitRange</literal> object or configure limits in <literal>Pod</literal> specs for the overrides to apply.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To modify cluster-level overcommit:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the <literal>ClusterResourceOverride</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.autoscaling.openshift.io/v1
kind: ClusterResourceOverride
metadata:
    name: cluster
spec:
  podResourceOverride:
    spec:
      memoryRequestToLimitPercent: 50 <co xml:id="CO170-1"/>
      cpuRequestToLimitPercent: 25 <co xml:id="CO170-2"/>
      limitCPUToMemoryPercent: 200 <co xml:id="CO170-3"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO170-1">
<para>Optional. Specify the percentage to override the container memory limit, if used, between 1-100. The default is 50.</para>
</callout>
<callout arearefs="CO170-2">
<para>Optional. Specify the percentage to override the container CPU limit, if used, between 1-100. The default is 25.</para>
</callout>
<callout arearefs="CO170-3">
<para>Optional. Specify the percentage to override the container memory limit, if used. Scaling 1Gi of RAM at 100 percent is equal to 1 CPU core. This is processed prior to overriding the CPU request, if configured. The default is 200.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Ensure the following label has been added to the Namespace object for each project where you want the Cluster Resource Override Operator to control overcommit:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:

# ...

  labels:
    clusterresourceoverrides.admission.autoscaling.openshift.io/enabled: "true" <co xml:id="CO171-1"/>

# ...</programlisting>
<calloutlist>
<callout arearefs="CO171-1">
<para>Add this label to each project.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cluster-node-overcommit_nodes-cluster-overcommit">
<title>Node-level overcommit</title>
<simpara>You can use various ways to control overcommit on specific nodes, such as quality of service (QOS)
guarantees, CPU limits, or reserve resources. You can also disable overcommit for specific nodes
and specific projects.</simpara>
<section xml:id="nodes-cluster-overcommit-reserving-memory_nodes-cluster-overcommit">
<title>Understanding compute resources and containers</title>
<simpara>The node-enforced behavior for compute resources is specific to the resource
type.</simpara>
<section xml:id="understanding-container-CPU-requests_nodes-cluster-overcommit">
<title>Understanding container CPU requests</title>
<simpara>A container is guaranteed the amount of CPU it requests and is additionally able
to consume excess CPU available on the node, up to any limit specified by the
container. If multiple containers are attempting to use excess CPU, CPU time is
distributed based on the amount of CPU requested by each container.</simpara>
<simpara>For example, if one container requested 500m of CPU time and another container
requested 250m of CPU time, then any extra CPU time available on the node is
distributed among the containers in a 2:1 ratio. If a container specified a
limit, it will be throttled not to use more CPU than the specified limit.
CPU requests are enforced using the CFS shares support in the Linux kernel. By
default, CPU limits are enforced using the CFS quota support in the Linux kernel
over a 100ms measuring interval, though this can be disabled.</simpara>
</section>
<section xml:id="understanding-memory-requests-container_nodes-cluster-overcommit">
<title>Understanding container memory requests</title>
<simpara>A container is guaranteed the amount of memory it requests. A container can use
more memory than requested, but once it exceeds its requested amount, it could
be terminated in a low memory situation on the node.
If a container uses less memory than requested, it will not be terminated unless
system tasks or daemons need more memory than was accounted for in the node&#8217;s
resource reservation. If a container specifies a limit on memory, it is
immediately terminated if it exceeds the limit amount.</simpara>
</section>
</section>
<section xml:id="nodes-cluster-overcommit-qos-about_nodes-cluster-overcommit">
<title>Understanding overcomitment and quality of service classes</title>
<simpara>A node is <emphasis>overcommitted</emphasis> when it has a pod scheduled that makes no request, or
when the sum of limits across all pods on that node exceeds available machine
capacity.</simpara>
<simpara>In an overcommitted environment, it is possible that the pods on the node will
attempt to use more compute resource than is available at any given point in
time. When this occurs, the node must give priority to one pod over another. The
facility used to make this decision is referred to as a Quality of Service (QoS)
Class.</simpara>
<simpara>A pod is designated as one of three QoS classes with decreasing order of priority:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Quality of Service Classes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="14.2857*"/>
<colspec colname="col_2" colwidth="14.2857*"/>
<colspec colname="col_3" colwidth="71.4286*"/>
<thead>
<row>
<entry align="left" valign="top">Priority</entry>
<entry align="left" valign="top">Class Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1 (highest)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Guaranteed</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>If limits and optionally requests are set (not equal to 0) for all resources
and they are equal, then the pod is classified as <emphasis role="strong">Guaranteed</emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Burstable</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>If requests and optionally limits are set (not equal to 0) for all resources,
and they are not equal, then the pod is classified as <emphasis role="strong">Burstable</emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3 (lowest)</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">BestEffort</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>If requests and limits are not set for any of the resources, then the pod
is classified as <emphasis role="strong">BestEffort</emphasis>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Memory is an incompressible resource, so in low memory situations, containers
that have the lowest priority are terminated first:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Guaranteed</emphasis> containers are considered top priority, and are guaranteed to
only be terminated if they exceed their limits, or if the system is under memory
pressure and there are no lower priority containers that can be evicted.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Burstable</emphasis> containers under system memory pressure are more likely to be
terminated once they exceed their requests and no other <emphasis role="strong">BestEffort</emphasis> containers
exist.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">BestEffort</emphasis> containers are treated with the lowest priority. Processes in
these containers are first to be terminated if the system runs out of memory.</simpara>
</listitem>
</itemizedlist>
<section xml:id="qos-about-reserve_nodes-cluster-overcommit">
<title>Understanding how to reserve memory across quality of service tiers</title>
<simpara>You can use the <literal>qos-reserved</literal> parameter to specify a percentage of memory to be reserved
by a pod in a particular QoS level. This feature attempts to reserve requested resources to exclude pods
from lower OoS classes from using resources requested by pods in higher QoS classes.</simpara>
<simpara>{product-title} uses the <literal>qos-reserved</literal> parameter as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>A value of <literal>qos-reserved=memory=100%</literal> will prevent the <literal>Burstable</literal> and <literal>BestEffort</literal> QoS classes from consuming memory
that was requested by a higher QoS class. This increases the risk of inducing OOM
on <literal>BestEffort</literal> and <literal>Burstable</literal> workloads in favor of increasing memory resource guarantees
for <literal>Guaranteed</literal> and <literal>Burstable</literal> workloads.</simpara>
</listitem>
<listitem>
<simpara>A value of <literal>qos-reserved=memory=50%</literal> will allow the <literal>Burstable</literal> and <literal>BestEffort</literal> QoS classes
to consume half of the memory requested by a higher QoS class.</simpara>
</listitem>
<listitem>
<simpara>A value of <literal>qos-reserved=memory=0%</literal>
will allow a <literal>Burstable</literal> and <literal>BestEffort</literal> QoS classes to consume up to the full node
allocatable amount if available, but increases the risk that a <literal>Guaranteed</literal> workload
will not have access to requested memory. This condition effectively disables this feature.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-qos-about-swap_nodes-cluster-overcommit">
<title>Understanding swap memory and QOS</title>
<simpara>You can disable swap by default on your nodes to preserve quality of
service (QOS) guarantees. Otherwise, physical resources on a node can oversubscribe,
affecting the resource guarantees the Kubernetes scheduler makes during pod
placement.</simpara>
<simpara>For example, if two guaranteed pods have reached their memory limit, each
container could start using swap memory. Eventually, if there is not enough swap
space, processes in the pods can be terminated due to the system being
oversubscribed.</simpara>
<simpara>Failing to disable swap results in nodes not recognizing that they are
experiencing <emphasis role="strong">MemoryPressure</emphasis>, resulting in pods not receiving the memory they
made in their scheduling request. As a result, additional pods are placed on the
node to further increase memory pressure, ultimately increasing your risk of
experiencing a system out of memory (OOM) event.</simpara>
<important>
<simpara>If swap is enabled, any out-of-resource handling eviction thresholds for available memory will not work as
expected. Take advantage of out-of-resource handling to allow pods to be evicted
from a node when it is under memory pressure, and rescheduled on an alternative
node that has no such pressure.</simpara>
</important>
</section>
<section xml:id="nodes-cluster-overcommit-configure-nodes_nodes-cluster-overcommit">
<title>Understanding nodes overcommitment</title>
<simpara>In an overcommitted environment, it is important to properly configure your node to provide best system behavior.</simpara>
<simpara>When the node starts, it ensures that the kernel tunable flags for memory
management are set properly. The kernel should never fail memory allocations
unless it runs out of physical memory.</simpara>
<simpara>To ensure this behavior, {product-title} configures the kernel to always overcommit
memory by setting the <literal>vm.overcommit_memory</literal> parameter to <literal>1</literal>, overriding the
default operating system setting.</simpara>
<simpara>{product-title} also configures the kernel not to panic when it runs out of memory
by setting the <literal>vm.panic_on_oom</literal> parameter to <literal>0</literal>. A setting of 0 instructs the
kernel to call oom_killer in an Out of Memory (OOM) condition, which kills
processes based on priority</simpara>
<simpara>You can view the current setting by running the following commands on your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sysctl -a |grep commit</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#...
vm.overcommit_memory = 0
#...</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sysctl -a |grep panic</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">#...
vm.panic_on_oom = 0
#...</programlisting>
</para>
</formalpara>
<note>
<simpara>The above flags should already be set on nodes, and no further action is
required.</simpara>
</note>
<simpara>You can also perform the following configurations for each node:</simpara>
<itemizedlist>
<listitem>
<simpara>Disable or enforce CPU limits using CPU CFS quotas</simpara>
</listitem>
<listitem>
<simpara>Reserve resources for system processes</simpara>
</listitem>
<listitem>
<simpara>Reserve memory across quality of service tiers</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cluster-overcommit-node-enforcing_nodes-cluster-overcommit">
<title>Disabling or enforcing CPU limits using CPU CFS quotas</title>
<simpara>Nodes by default enforce specified CPU limits using the Completely Fair Scheduler (CFS) quota support in the Linux kernel.</simpara>
<simpara>If you disable CPU limit enforcement, it is important to understand the impact on your node:</simpara>
<itemizedlist>
<listitem>
<simpara>If a container has a CPU request, the request continues to be enforced by CFS shares in the Linux kernel.</simpara>
</listitem>
<listitem>
<simpara>If a container does not have a CPU request, but does have a CPU limit, the CPU request defaults to the specified CPU limit, and is enforced by CFS shares in the Linux kernel.</simpara>
</listitem>
<listitem>
<simpara>If a container has both a CPU request and limit, the CPU request is enforced by CFS shares in the Linux kernel, and the CPU limit has no impact on the node.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the label associated with the static <literal>MachineConfigPool</literal> CRD for the type of node you want to configure by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool &lt;name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineconfigpool worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  creationTimestamp: "2022-11-16T15:34:25Z"
  generation: 4
  labels:
    pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO172-1"/>
  name: worker</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO172-1">
<para>The label appears under Labels.</para>
</callout>
</calloutlist>
<tip>
<simpara>If the label is not present, add a key/value pair such as:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label machineconfigpool worker custom-kubelet=small-pods</programlisting>
</tip>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a custom resource (CR) for your configuration change.</simpara>
<formalpara>
<title>Sample configuration for a disabling CPU limits</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: disable-cpu-units <co xml:id="CO173-1"/>
spec:
  machineConfigPoolSelector:
    matchLabels:
      pools.operator.machineconfiguration.openshift.io/worker: "" <co xml:id="CO173-2"/>
  kubeletConfig:
    cpuCfsQuota: false <co xml:id="CO173-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO173-1">
<para>Assign a name to CR.</para>
</callout>
<callout arearefs="CO173-2">
<para>Specify the label from the machine config pool.</para>
</callout>
<callout arearefs="CO173-3">
<para>Set the <literal>cpuCfsQuota</literal> parameter to <literal>false</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the following command to create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-overcommit-node-resources_nodes-cluster-overcommit">
<title>Reserving resources for system processes</title>
<simpara>To provide more reliable scheduling and minimize node resource overcommitment,
each node can reserve a portion of its resources for use by system daemons
that are required to run on your node for your cluster to function.
In particular, it is recommended that you reserve resources for incompressible resources such as memory.</simpara>
<formalpara>
<title>Procedure</title>
<para>To explicitly reserve resources for non-pod processes, allocate node resources by specifying resources
available for scheduling.
For more details, see Allocating Resources for Nodes.</para>
</formalpara>
</section>
<section xml:id="nodes-cluster-overcommit-node-disable_nodes-cluster-overcommit">
<title>Disabling overcommitment for a node</title>
<simpara>When enabled, overcommitment can be disabled on each node.</simpara>
<formalpara>
<title>Procedure</title>
<para>To disable overcommitment in a node run the following command on that node:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sysctl -w vm.overcommit_memory=0</programlisting>
</section>
</section>
<section xml:id="nodes-cluster-project-overcommit_nodes-cluster-overcommit">
<title>Project-level limits</title>
<simpara>To help control overcommit, you can set per-project resource limit ranges,
specifying memory and CPU limits and defaults for a project that overcommit
cannot exceed.</simpara>
<simpara>For information on project-level resource limits, see Additional resources.</simpara>
<simpara>Alternatively, you can disable overcommitment for specific projects.</simpara>
<section xml:id="nodes-cluster-overcommit-project-disable_nodes-cluster-overcommit">
<title>Disabling overcommitment for a project</title>
<simpara>When enabled, overcommitment can be disabled per-project. For example, you can allow infrastructure components to be configured independently of overcommitment.</simpara>
<formalpara>
<title>Procedure</title>
<para>To disable overcommitment in a project:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create or edit the namespace object file.</simpara>
</listitem>
<listitem>
<simpara>Add the following annotation:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  annotations:
    quota.openshift.io/cluster-resource-override-enabled: "false" <co xml:id="CO174-1"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO174-1">
<para>Setting this annotation to <literal>false</literal> disables overcommit for this namespace.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cluster-overcommit-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../applications/deployments/managing-deployment-processes.xml#deployments-triggers_deployment-operations">Setting deployment resources</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-resources-configuring.xml#nodes-nodes-resources-configuring-setting_nodes-nodes-resources-configuring">Allocating resources for nodes</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cluster-cgroups-2">
<title>Configuring the Linux cgroup version on your nodes</title>

<simpara>As of {product-title} 4.14, {product-title} uses <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Linux control group version 2</link> (cgroup v2) in your cluster. If you are using cgroup v1 on {product-title} 4.13 or earlier, migrating to {product-title} 4.14 or later will not automatically update your cgroup configuration to version 2. A fresh installation of {product-title} 4.14 or later will use cgroup v2 by default. However, you can enable <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/index.html">Linux control group version 1</link> (cgroup v1) upon installation.</simpara>
<simpara>cgroup v2 is the current version of the Linux cgroup API. cgroup v2 offers several improvements over cgroup v1, including a unified hierarchy, safer sub-tree delegation, new features such as <link xl:href="https://www.kernel.org/doc/html/latest/accounting/psi.html">Pressure Stall Information</link>, and enhanced resource management and isolation. However, cgroup v2 has different CPU, memory, and I/O management characteristics than cgroup v1. Therefore, some workloads might experience slight differences in memory or CPU usage on clusters that run cgroup v2.</simpara>
<simpara>You can change between cgroup v1 and cgroup v2, as needed. Enabling cgroup v1 in {product-title} disables all cgroup v2 controllers and hierarchies in your cluster.</simpara>
<note>
<itemizedlist>
<listitem>
<simpara>If you run third-party monitoring and security agents that depend on the cgroup file system, update the agents to a version that supports cgroup v2.</simpara>
</listitem>
<listitem>
<simpara>If you have configured cgroup v2 and run cAdvisor as a stand-alone daemon set for monitoring pods and containers, update cAdvisor to v0.43.0 or later.</simpara>
</listitem>
<listitem>
<simpara>If you deploy Java applications, use versions that fully support cgroup v2, such as the following packages:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenJDK / HotSpot: jdk8u372, 11.0.16, 15 and later</simpara>
</listitem>
<listitem>
<simpara>NodeJs 20.3.0 or later</simpara>
</listitem>
<listitem>
<simpara>IBM Semeru Runtimes: jdk8u345-b01, 11.0.16.0, 17.0.4.0, 18.0.2.0 and later</simpara>
</listitem>
<listitem>
<simpara>IBM SDK Java Technology Edition Version (IBM Java): 8.0.7.15 and later</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</note>
<section xml:id="nodes-clusters-cgroups-2_nodes-cluster-cgroups-2">
<title>Configuring Linux cgroup</title>
<simpara>You can enable <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/index.html">Linux control group version 1</link> (cgroup v1) or <link xl:href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">Linux control group version 2</link> (cgroup v2)  by editing the <literal>node.config</literal> object. The default is cgroup v2.</simpara>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a running {product-title} cluster that uses version 4.12 or later.</simpara>
</listitem>
<listitem>
<simpara>You are logged in to the cluster as a user with administrative privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Enable cgroup v1 on nodes:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>node.config</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit nodes.config/cluster</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>spec.cgroupMode</literal> parameter:</simpara>
<formalpara>
<title>Example <literal>node.config</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v2
kind: Node
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2022-07-08T16:02:51Z"
  generation: 1
  name: cluster
  ownerReferences:
  - apiVersion: config.openshift.io/v2
    kind: ClusterVersion
    name: version
    uid: 36282574-bf9f-409e-a6cd-3032939293eb
  resourceVersion: "1865"
  uid: 0c0f7a4c-4307-4187-b591-6155695ac85b
spec:
  cgroupMode: "v1" <co xml:id="CO175-1"/>
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO175-1">
<para>Specify <literal>v1</literal> to enable cgroup v1 or <literal>v2</literal> for cgroup v2.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the machine configs to see that the new machine configs were added:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                               GENERATEDBYCONTROLLER                      IGNITIONVERSION   AGE
00-master                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
00-worker                                          52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-master-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-container-runtime                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
01-worker-kubelet                                  52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
97-master-generated-kubelet                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-worker-generated-kubelet                        52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-master-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-master-ssh                                                                                 3.2.0             40m
99-worker-generated-registries                     52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
99-worker-ssh                                                                                 3.2.0             40m
rendered-master-23d4317815a5f854bd3553d689cfe2e9   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             10s <co xml:id="CO176-1"/>
rendered-master-23e785de7587df95a4b517e0647e5ab7   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
rendered-worker-5d596d9293ca3ea80c896a1191735bb1   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             33m
rendered-worker-dcc7f1b92892d34db74d6832bcc9ccd4   52dd3ba6a9a527fc3ab42afac8d12b693534c8c9   3.2.0             10s</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO176-1">
<para>New machine configs are created, as expected.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check that the new <literal>kernelArguments</literal> were added to the new machine configs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe mc &lt;name&gt;</programlisting>
<formalpara>
<title>Example output for cgroup v2</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v2
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 05-worker-kernelarg-selinuxpermissive
spec:
  kernelArguments:
    systemd_unified_cgroup_hierarchy=1 <co xml:id="CO177-1"/>
    cgroup_no_v1="all" <co xml:id="CO177-2"/>
    psi=1 <co xml:id="CO177-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO177-1">
<para>Enables cgroup v2 in systemd.</para>
</callout>
<callout arearefs="CO177-2">
<para>Disables cgroup v1.</para>
</callout>
<callout arearefs="CO177-3">
<para>Enables the Linux Pressure Stall Information (PSI) feature.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output for cgroup v1</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v2
kind: MachineConfig
metadata:
  labels:
    machineconfiguration.openshift.io/role: worker
  name: 05-worker-kernelarg-selinuxpermissive
spec:
  kernelArguments:
    systemd.unified_cgroup_hierarchy=0 <co xml:id="CO178-1"/>
    systemd.legacy_systemd_cgroup_controller=1 <co xml:id="CO178-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO178-1">
<para>Disables cgroup v2.</para>
</callout>
<callout arearefs="CO178-2">
<para>Enables cgroup v1 in systemd.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the nodes to see that scheduling on the nodes is disabled. This indicates that the change is being applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       STATUS                     ROLES    AGE   VERSION
ci-ln-fm1qnwt-72292-99kt6-master-0         Ready,SchedulingDisabled   master   58m   v1.28.5
ci-ln-fm1qnwt-72292-99kt6-master-1         Ready                      master   58m   v1.28.5
ci-ln-fm1qnwt-72292-99kt6-master-2         Ready                      master   58m   v1.28.5
ci-ln-fm1qnwt-72292-99kt6-worker-a-h5gt4   Ready,SchedulingDisabled   worker   48m   v1.28.5
ci-ln-fm1qnwt-72292-99kt6-worker-b-7vtmd   Ready                      worker   48m   v1.28.5
ci-ln-fm1qnwt-72292-99kt6-worker-c-rhzkv   Ready                      worker   48m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After a node returns to the <literal>Ready</literal> state, start a debug session for that node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Check that the <literal>sys/fs/cgroup/cgroup2fs</literal> or <literal>sys/fs/cgroup/tmpfs</literal> file is present on your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ stat -c %T -f /sys/fs/cgroup</programlisting>
<formalpara>
<title>Example output for cgroup v2</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">cgroup2fs</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output for cgroup v1</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">tmpfs</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/index.xml#ocp-installation-overview">OpenShift Container Platform installation overview</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nodes-cluster-enabling">
<title>Enabling features using feature gates</title>

<simpara>As an administrator, you can use feature gates to enable features that are not part of the default set of features.</simpara>
<section xml:id="nodes-cluster-enabling-features-about_nodes-cluster-enabling">
<title>Understanding feature gates</title>
<simpara>You can use the <literal>FeatureGate</literal> custom resource (CR) to enable specific feature sets in your cluster. A feature set is a collection of {product-title} features that are not enabled by default.</simpara>
<simpara>You can activate the following feature set by using the <literal>FeatureGate</literal> CR:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>TechPreviewNoUpgrade</literal>. This feature set is a subset of the current Technology Preview features. This feature set allows you to enable these Technology Preview features on test clusters, where you can fully test them, while leaving the features disabled on production clusters.</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set on your cluster cannot be undone and prevents minor version updates. You should not enable this feature set on production clusters.</simpara>
</warning>
<simpara>The following Technology Preview features are enabled by this feature set:</simpara>
<itemizedlist>
<listitem>
<simpara>External cloud providers. Enables support for external cloud providers for clusters on vSphere, AWS, Azure, and GCP. Support for OpenStack is GA. This is an internal feature that most users do not need to interact with. (<literal>ExternalCloudProvider</literal>)</simpara>
</listitem>
<listitem>
<simpara>Shared Resources CSI Driver in OpenShift Builds. Enables the Container Storage Interface (CSI). (<literal>CSIDriverSharedResource</literal>)</simpara>
</listitem>
<listitem>
<simpara>Swap memory on nodes. Enables swap memory use for {product-title} workloads on a per-node basis. (<literal>NodeSwap</literal>)</simpara>
</listitem>
<listitem>
<simpara>OpenStack Machine API Provider. This gate has no effect and is planned to be removed from this feature set in a future release. (<literal>MachineAPIProviderOpenStack</literal>)</simpara>
</listitem>
<listitem>
<simpara>Insights Operator. Enables the Insights Operator, which gathers {product-title} configuration data and sends it to Red Hat. (<literal>InsightsConfigAPI</literal>)</simpara>
</listitem>
<listitem>
<simpara>Retroactive Default Storage Class. Enables {product-title} to retroactively assign the default storage class to PVCs if there was no default storage class when the PVC was created.(<literal>RetroactiveDefaultStorageClass</literal>)</simpara>
</listitem>
<listitem>
<simpara>Dynamic Resource Allocation API. Enables a new API for requesting and sharing resources between pods and containers. This is an internal feature that most users do not need to interact with. (<literal>DynamicResourceAllocation</literal>)</simpara>
</listitem>
<listitem>
<simpara>Pod security admission enforcement. Enables the restricted enforcement mode for pod security admission. Instead of only logging a warning, pods are rejected if they violate pod security standards. (<literal>OpenShiftPodSecurityAdmission</literal>)</simpara>
</listitem>
<listitem>
<simpara>StatefulSet pod availability upgrading limits. Enables users to define the maximum number of statefulset pods unavailable during updates which reduces application downtime. (<literal>MaxUnavailableStatefulSet</literal>)</simpara>
</listitem>
<listitem>
<simpara>Admin Network Policy and Baseline Admin Network Policy. Enables <literal>AdminNetworkPolicy</literal> and <literal>BaselineAdminNetworkPolicy</literal> resources, which are part of the Network Policy V2 API, in clusters running the OVN-Kubernetes CNI plugin. Cluster administrators can apply cluster-scoped policies and safeguards for an entire cluster before namespaces are created. Network administrators can secure clusters by enforcing network traffic controls that cannot be overridden by users. Network administrators can enforce optional baseline network traffic controls that can be overridden by users in the cluster, if necessary. Currently, these APIs support only expressing policies for intra-cluster traffic. (<literal>AdminNetworkPolicy</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>MatchConditions</literal> is a list of conditions that must be met for a request to be sent to this webhook. Match conditions filter requests that have already been matched by the rules, namespaceSelector, and objectSelector. An empty list of <literal>matchConditions</literal> matches all requests. (<literal>admissionWebhookMatchConditions</literal>)</simpara>
</listitem>
<listitem>
<simpara>Gateway API. To enable the {product-title} Gateway API, set the value of the <literal>enabled</literal> field to <literal>true</literal> in the <literal>techPreview.gatewayAPI</literal> specification of the <literal>ServiceMeshControlPlane</literal> resource.(<literal>gateGatewayAPI</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>gcpLabelsTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vSphereStaticIPs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>routeExternalCertificate</literal></simpara>
</listitem>
<listitem>
<simpara><literal>automatedEtcdBackup</literal></simpara>
</listitem>
<listitem>
<simpara><literal>gcpClusterHostedDNS</literal></simpara>
</listitem>
<listitem>
<simpara><literal>vSphereControlPlaneMachineset</literal></simpara>
</listitem>
<listitem>
<simpara><literal>dnsNameResolver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>machineConfigNodes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>metricsServer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>installAlternateInfrastructureAWS</literal></simpara>
</listitem>
<listitem>
<simpara><literal>sdnLiveMigration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mixedCPUsAllocation</literal></simpara>
</listitem>
<listitem>
<simpara><literal>managedBootImages</literal></simpara>
</listitem>
<listitem>
<simpara><literal>onClusterBuild</literal></simpara>
</listitem>
<listitem>
<simpara><literal>signatureStores</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>For more information about the features activated by the <literal>TechPreviewNoUpgrade</literal> feature gate, see the following topics:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../cicd/builds/running-entitled-builds.xml#builds-running-entitled-builds-with-sharedsecret-objects_running-entitled-builds">Shared Resources CSI Driver and Build CSI Volumes in OpenShift Builds</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../storage/container_storage_interface/ephemeral-storage-csi-inline.xml#ephemeral-storage-csi-inline">CSI inline ephemeral volumes</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-managing.xml#nodes-nodes-swap-memory_nodes-nodes-managing">Swap memory on nodes</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../machine_management/capi-machine-management.xml#capi-machine-management">Managing machines with the Cluster API</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../support/remote_health_monitoring/using-insights-operator.xml#using-insights-operator">Using Insights Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../storage/container_storage_interface/persistent-storage-csi-sc-manage.xml#persistent-storage-csi-sc-manage">Managing the default storage class</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Pod security admission enforcement</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-cluster-enabling-features-install_nodes-cluster-enabling">
<title>Enabling feature sets at installation</title>
<simpara>You can enable feature sets for all nodes in the cluster by editing the <literal>install-config.yaml</literal> file before you deploy the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have an <literal>install-config.yaml</literal> file.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>featureSet</literal> parameter to specify the name of the feature set you want to enable, such as <literal>TechPreviewNoUpgrade</literal>:</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set on your cluster cannot be undone and prevents minor version updates. You should not enable this feature set on production clusters.</simpara>
</warning>
<formalpara>
<title>Sample <literal>install-config.yaml</literal> file with an enabled feature set</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">compute:
- hyperthreading: Enabled
  name: worker
  platform:
    aws:
      rootVolume:
        iops: 2000
        size: 500
        type: io1
      metadataService:
        authentication: Optional
      type: c5.4xlarge
      zones:
      - us-west-2c
  replicas: 3
featureSet: TechPreviewNoUpgrade</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Save the file and reference it when using the installation program to deploy the cluster.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You can verify that the feature gates are enabled by looking at the <literal>kubelet.conf</literal> file on a node after the nodes return to the ready state.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the <emphasis role="strong">Administrator</emphasis> perspective in the web console, navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Nodes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a node.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Node details</emphasis> page, click <emphasis role="strong">Terminal</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the terminal window, change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>kubelet.conf</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# cat /etc/kubernetes/kubelet.conf</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># ...
featureGates:
  InsightsOperatorPullingSCA: true,
  LegacyNodeRoleBehavior: false
# ...</programlisting>
</para>
</formalpara>
<simpara>The features that are listed as <literal>true</literal> are enabled on your cluster.</simpara>
<note>
<simpara>The features listed vary depending upon the {product-title} version.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-enabling-features-console_nodes-cluster-enabling">
<title>Enabling feature sets using the web console</title>
<simpara>You can use the {product-title} web console to enable feature sets for all of the nodes in a cluster by editing the <literal>FeatureGate</literal> custom resource (CR).</simpara>
<formalpara>
<title>Procedure</title>
<para>To enable feature sets:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the {product-title} web console, switch to the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Custom Resource Definitions</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Custom Resource Definitions</emphasis> page, click <emphasis role="strong">FeatureGate</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Custom Resource Definition Details</emphasis> page, click the <emphasis role="strong">Instances</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">cluster</emphasis> feature gate, then click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Edit the <emphasis role="strong">cluster</emphasis> instance to add specific feature sets:</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set on your cluster cannot be undone and prevents minor version updates. You should not enable this feature set on production clusters.</simpara>
</warning>
<formalpara>
<title>Sample Feature Gate custom resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: FeatureGate
metadata:
  name: cluster <co xml:id="CO179-1"/>
# ...
spec:
  featureSet: TechPreviewNoUpgrade <co xml:id="CO179-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO179-1">
<para>The name of the <literal>FeatureGate</literal> CR must be <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO179-2">
<para>Add the feature set that you want to enable:</para>
<itemizedlist>
<listitem>
<simpara><literal>TechPreviewNoUpgrade</literal> enables specific Technology Preview features.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<simpara>After you save the changes, new machine configs are created, the machine config pools are updated, and scheduling on each node is disabled while the change is being applied.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You can verify that the feature gates are enabled by looking at the <literal>kubelet.conf</literal> file on a node after the nodes return to the ready state.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the <emphasis role="strong">Administrator</emphasis> perspective in the web console, navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Nodes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a node.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Node details</emphasis> page, click <emphasis role="strong">Terminal</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the terminal window, change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>kubelet.conf</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# cat /etc/kubernetes/kubelet.conf</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># ...
featureGates:
  InsightsOperatorPullingSCA: true,
  LegacyNodeRoleBehavior: false
# ...</programlisting>
</para>
</formalpara>
<simpara>The features that are listed as <literal>true</literal> are enabled on your cluster.</simpara>
<note>
<simpara>The features listed vary depending upon the {product-title} version.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="nodes-cluster-enabling-features-cli_nodes-cluster-enabling">
<title>Enabling feature sets using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to enable feature sets for all of the nodes in a cluster by editing the <literal>FeatureGate</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To enable feature sets:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Edit the <literal>FeatureGate</literal> CR named <literal>cluster</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit featuregate cluster</programlisting>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set on your cluster cannot be undone and prevents minor version updates. You should not enable this feature set on production clusters.</simpara>
</warning>
<formalpara>
<title>Sample FeatureGate custom resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: FeatureGate
metadata:
  name: cluster <co xml:id="CO180-1"/>
# ...
spec:
  featureSet: TechPreviewNoUpgrade <co xml:id="CO180-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO180-1">
<para>The name of the <literal>FeatureGate</literal> CR must be <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO180-2">
<para>Add the feature set that you want to enable:</para>
<itemizedlist>
<listitem>
<simpara><literal>TechPreviewNoUpgrade</literal> enables specific Technology Preview features.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
<simpara>After you save the changes, new machine configs are created, the machine config pools are updated, and scheduling on each node is disabled while the change is being applied.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You can verify that the feature gates are enabled by looking at the <literal>kubelet.conf</literal> file on a node after the nodes return to the ready state.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>From the <emphasis role="strong">Administrator</emphasis> perspective in the web console, navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Nodes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a node.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Node details</emphasis> page, click <emphasis role="strong">Terminal</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the terminal window, change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>View the <literal>kubelet.conf</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# cat /etc/kubernetes/kubelet.conf</programlisting>
<formalpara>
<title>Sample output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># ...
featureGates:
  InsightsOperatorPullingSCA: true,
  LegacyNodeRoleBehavior: false
# ...</programlisting>
</para>
</formalpara>
<simpara>The features that are listed as <literal>true</literal> are enabled on your cluster.</simpara>
<note>
<simpara>The features listed vary depending upon the {product-title} version.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="nodes-cluster-worker-latency-profiles">
<title>Improving cluster stability in high latency environments using worker latency profiles</title>

<simpara>If the cluster administrator has performed latency tests for platform verification, they can discover the need to adjust the operation of the cluster to ensure stability in cases of high latency. The cluster administrator need change only one parameter, recorded in a file, which controls four parameters affecting how supervisory processes read status and interpret the health of the cluster. Changing only the one parameter provides cluster tuning in an easy, supportable manner.</simpara>
<simpara>The <literal>Kubelet</literal> process provides the starting point for monitoring cluster health. The <literal>Kubelet</literal> sets status values for all nodes in the {product-title} cluster. The Kubernetes Controller Manager (<literal>kube controller</literal>) reads the status values every 10 seconds, by default.
If the <literal>kube controller</literal> cannot read a node status value, it loses contact with that node after a configured period. The default behavior is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The node controller on the control plane updates the node health to <literal>Unhealthy</literal> and marks the node <literal>Ready</literal> condition`Unknown`.</simpara>
</listitem>
<listitem>
<simpara>In response, the scheduler stops scheduling pods to that node.</simpara>
</listitem>
<listitem>
<simpara>The Node Lifecycle Controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to the node and schedules any pods on the node for eviction after five minutes, by default.</simpara>
</listitem>
</orderedlist>
<simpara>This behavior can cause problems if your network is prone to latency issues, especially if you have nodes at the network edge. In some cases, the Kubernetes Controller Manager might not receive an update from a healthy node due to network latency. The <literal>Kubelet</literal> evicts pods from the node even though the node is healthy.</simpara>
<simpara>To avoid this problem, you can use <emphasis>worker latency profiles</emphasis> to adjust the frequency that the <literal>Kubelet</literal> and the Kubernetes Controller Manager wait for status updates before taking action. These adjustments help to ensure that your cluster runs properly if network latency between the control plane and the worker nodes is not optimal.</simpara>
<simpara>These worker latency profiles contain three sets of parameters that are pre-defined with carefully tuned values to control the reaction of the cluster to increased latency. No need to experimentally find the best values manually.</simpara>
<simpara>You can configure worker latency profiles when installing a cluster or at any time you notice increased latency in your cluster network.</simpara>
<simpara>You can configure worker latency profiles when installing a cluster or at any time you notice increased latency in your cluster network.</simpara>
<section xml:id="nodes-cluster-worker-latency-profiles-about_nodes-cluster-worker-latency-profiles">
<title>Understanding worker latency profiles</title>
<simpara>Worker latency profiles are four different categories of carefully-tuned parameters. The four parameters which implement these values are <literal>node-status-update-frequency</literal>, <literal>node-monitor-grace-period</literal>, <literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal>. These parameters can use values which allow you control the reaction of the cluster to latency issues without needing to determine the best values using manual methods.</simpara>
<important>
<simpara>Setting these parameters manually is not supported. Incorrect parameter settings adversely affect cluster stability.</simpara>
</important>
<simpara>All worker latency profiles configure the following parameters:</simpara>
<variablelist>
<varlistentry>
<term>node-status-update-frequency</term>
<listitem>
<simpara>Specifies how often the kubelet posts node status to the API server.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>node-monitor-grace-period</term>
<listitem>
<simpara>Specifies the amount of time in seconds that the Kubernetes Controller Manager waits for an update from a kubelet before marking the node unhealthy and adding the <literal>node.kubernetes.io/not-ready</literal> or <literal>node.kubernetes.io/unreachable</literal> taint to the node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>default-not-ready-toleration-seconds</term>
<listitem>
<simpara>Specifies the amount of time in seconds after marking a node unhealthy that the Kube API Server Operator waits before evicting pods from that node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>default-unreachable-toleration-seconds</term>
<listitem>
<simpara>Specifies the amount of time in seconds after marking a node unreachable that the Kube API Server Operator waits before evicting pods from that node.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following Operators monitor the changes to the worker latency profiles and respond accordingly:</simpara>
<itemizedlist>
<listitem>
<simpara>The Machine Config Operator (MCO) updates the <literal>node-status-update-frequency</literal> parameter on the worker nodes.</simpara>
</listitem>
<listitem>
<simpara>The Kubernetes Controller Manager updates the <literal>node-monitor-grace-period</literal> parameter on the control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>The Kubernetes API Server Operator updates the <literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal> parameters on the control plane nodes.</simpara>
</listitem>
</itemizedlist>
<simpara>Although the default configuration works in most cases, {product-title} offers two other worker latency profiles for situations where the network is experiencing higher latency than usual. The three worker latency profiles are described in the following sections:</simpara>
<variablelist>
<varlistentry>
<term>Default worker latency profile</term>
<listitem>
<simpara>With the <literal>Default</literal> profile, each <literal>Kubelet</literal> updates it&#8217;s status every 10 seconds (<literal>node-status-update-frequency</literal>). The <literal>Kube Controller Manager</literal> checks the statuses of <literal>Kubelet</literal> every 5 seconds (<literal>node-monitor-grace-period</literal>).</simpara>
<simpara>The Kubernetes Controller Manager waits 40 seconds for a status update from <literal>Kubelet</literal> before considering the <literal>Kubelet</literal> unhealthy. If no status is made available to the Kubernetes Controller Manager, it then marks the node with the <literal>node.kubernetes.io/not-ready</literal> or <literal>node.kubernetes.io/unreachable</literal> taint and evicts the pods on that node.</simpara>
<simpara>If a pod on that node has the <literal>NoExecute</literal> taint, the pod is run according to <literal>tolerationSeconds</literal>. If the pod has no taint, it will be evicted in 300 seconds (<literal>default-not-ready-toleration-seconds</literal> and <literal>default-unreachable-toleration-seconds</literal> settings of the <literal>Kube API Server</literal>).</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>10s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>40s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>300s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>300s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Medium worker latency profile</term>
<listitem>
<simpara>Use the <literal>MediumUpdateAverageReaction</literal> profile if the network latency is slightly higher than usual.</simpara>
<simpara>The <literal>MediumUpdateAverageReaction</literal> profile reduces the frequency of kubelet updates to 20 seconds and changes the period that the Kubernetes Controller Manager waits for those updates to 2 minutes. The pod eviction period for a pod on that node is reduced to 60 seconds. If the pod has the <literal>tolerationSeconds</literal> parameter, the eviction waits for the period specified by that parameter.</simpara>
<simpara>The Kubernetes Controller Manager waits for 2 minutes to consider a node unhealthy. In another minute, the eviction process starts.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>MediumUpdateAverageReaction</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>20s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>2m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
<varlistentry>
<term>Low worker latency profile</term>
<listitem>
<simpara>Use the <literal>LowUpdateSlowReaction</literal> profile if the network latency is extremely high.</simpara>
<simpara>The <literal>LowUpdateSlowReaction</literal> profile reduces the frequency of kubelet updates to 1 minute and changes the period that the Kubernetes Controller Manager waits for those updates to 5 minutes. The pod eviction period for a pod on that node is reduced to 60 seconds. If the pod has the <literal>tolerationSeconds</literal> parameter, the eviction waits for the period specified by that parameter.</simpara>
<simpara>The Kubernetes Controller Manager waits for 5 minutes to consider a node unhealthy. In another minute, the eviction process starts.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><simpara>LowUpdateSlowReaction</simpara></entry>
<entry align="left" valign="top"><simpara>kubelet</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-status-update-frequency</literal></simpara></entry>
<entry align="left" valign="top"><simpara>1m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubelet Controller Manager</simpara></entry>
<entry align="left" valign="top"><simpara><literal>node-monitor-grace-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>5m</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-not-ready-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API Server Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>default-unreachable-toleration-seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>60s</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-cluster-worker-latency-profiles-using_nodes-cluster-worker-latency-profiles">
<title>Using and changing worker latency profiles</title>
<simpara>To change a worker latency profile to deal with network latency, edit the <literal>node.config</literal> object to add the name of the profile. You can change the profile at any time as latency increases or decreases.</simpara>
<simpara>You must move one worker latency profile at a time. For example, you cannot move directly from the <literal>Default</literal> profile to the <literal>LowUpdateSlowReaction</literal> worker latency profile. You must move from the <literal>Default</literal> worker latency profile to the <literal>MediumUpdateAverageReaction</literal> profile first, then to <literal>LowUpdateSlowReaction</literal>. Similarly, when returning to the <literal>Default</literal> profile, you must move from the low profile to the medium profile first, then to <literal>Default</literal>.</simpara>
<note>
<simpara>You can also configure worker latency profiles upon installing an {product-title} cluster.</simpara>
</note>
<formalpara>
<title>Procedure</title>
<para>To move from the default worker latency profile:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Move to the medium worker latency profile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>node.config</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit nodes.config/cluster</programlisting>
</listitem>
<listitem>
<simpara>Add <literal>spec.workerLatencyProfile: MediumUpdateAverageReaction</literal>:</simpara>
<formalpara>
<title>Example <literal>node.config</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Node
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2022-07-08T16:02:51Z"
  generation: 1
  name: cluster
  ownerReferences:
  - apiVersion: config.openshift.io/v1
    kind: ClusterVersion
    name: version
    uid: 36282574-bf9f-409e-a6cd-3032939293eb
  resourceVersion: "1865"
  uid: 0c0f7a4c-4307-4187-b591-6155695ac85b
spec:
  workerLatencyProfile: MediumUpdateAverageReaction <co xml:id="CO181-1"/>

# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO181-1">
<para>Specifies the medium worker latency policy.</para>
</callout>
</calloutlist>
<simpara>Scheduling on each worker node is disabled as the change is being applied.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Optional: Move to the low worker latency profile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>node.config</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit nodes.config/cluster</programlisting>
</listitem>
<listitem>
<simpara>Change the <literal>spec.workerLatencyProfile</literal> value to <literal>LowUpdateSlowReaction</literal>:</simpara>
<formalpara>
<title>Example <literal>node.config</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Node
metadata:
  annotations:
    include.release.openshift.io/ibm-cloud-managed: "true"
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  creationTimestamp: "2022-07-08T16:02:51Z"
  generation: 1
  name: cluster
  ownerReferences:
  - apiVersion: config.openshift.io/v1
    kind: ClusterVersion
    name: version
    uid: 36282574-bf9f-409e-a6cd-3032939293eb
  resourceVersion: "1865"
  uid: 0c0f7a4c-4307-4187-b591-6155695ac85b
spec:
  workerLatencyProfile: LowUpdateSlowReaction <co xml:id="CO182-1"/>

# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO182-1">
<para>Specifies use of the low worker latency policy.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>Scheduling on each worker node is disabled as the change is being applied.</simpara>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>When all nodes return to the <literal>Ready</literal> condition, you can use the following command to look in the Kubernetes Controller Manager to ensure it was applied:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get KubeControllerManager -o yaml | grep -i workerlatency -A 5 -B 5</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># ...
    - lastTransitionTime: "2022-07-11T19:47:10Z"
      reason: ProfileUpdated
      status: "False"
      type: WorkerLatencyProfileProgressing
    - lastTransitionTime: "2022-07-11T19:47:10Z" <co xml:id="CO183-1"/>
      message: all static pod revision(s) have updated latency profile
      reason: ProfileUpdated
      status: "True"
      type: WorkerLatencyProfileComplete
    - lastTransitionTime: "2022-07-11T19:20:11Z"
      reason: AsExpected
      status: "False"
      type: WorkerLatencyProfileDegraded
    - lastTransitionTime: "2022-07-11T19:20:36Z"
      status: "False"
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO183-1">
<para>Specifies that the profile is applied and active.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<simpara>To change the medium profile to default or change the default to medium, edit the <literal>node.config</literal> object and set the <literal>spec.workerLatencyProfile</literal> parameter to the appropriate value.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_remote_worker_nodes_on_the_network_edge">
<title>Remote worker nodes on the network edge</title>
<section xml:id="nodes-edge-remote-workers">
<title>Using remote worker nodes at the network edge</title>

<simpara>You can configure {product-title} clusters with nodes located at your network edge. In this topic, they are called <emphasis>remote worker nodes</emphasis>. A typical cluster with remote worker nodes combines on-premise master and worker nodes with worker nodes in other locations that connect to the cluster. This topic is intended to provide guidance on best practices for using remote worker nodes and does not contain specific configuration details.</simpara>
<simpara>There are multiple use cases across different industries, such as telecommunications, retail, manufacturing, and government, for using a deployment pattern with remote worker nodes. For example, you can separate and isolate your projects and workloads by combining the remote worker nodes into <link xl:href="../../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers-strategies-zones_nodes-edge-remote-workers">Kubernetes zones</link>.</simpara>
<simpara>However, having remote worker nodes can introduce higher latency, intermittent loss of network connectivity, and other issues. Among the challenges in a cluster with remote worker node are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Network separation</emphasis>: The {product-title} control plane and the remote worker nodes must be able communicate with each other. Because of the distance between the control plane and the remote worker nodes, network issues could prevent this communication. See <link xl:href="../../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers-network_nodes-edge-remote-workers">Network separation with remote worker nodes</link> for information on how {product-title} responds to network separation and for methods to diminish the impact to your cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Power outage</emphasis>: Because the control plane and remote worker nodes are in separate locations, a power outage at the remote location or at any point between the two can negatively impact your cluster. See <link xl:href="../../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers-power_nodes-edge-remote-workers">Power loss on remote worker nodes</link> for information on how {product-title} responds to a node losing power and for methods to diminish the impact to your cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Latency spikes or temporary reduction in throughput</emphasis>: As with any network, any changes in network conditions between your cluster and the remote worker nodes can negatively impact your cluster. {product-title} offers multiple <emphasis>worker latency profiles</emphasis> that let you control the reaction of the cluster to latency issues.</simpara>
</listitem>
</itemizedlist>
<simpara>Note the following limitations when planning a cluster with remote worker nodes:</simpara>
<itemizedlist>
<listitem>
<simpara>{product-title} does not support remote worker nodes that use a different cloud provider than the on-premise cluster uses.</simpara>
</listitem>
<listitem>
<simpara>Moving workloads from one Kubernetes zone to a different Kubernetes zone can be problematic due to system and environment issues, such as a specific type of memory not being available in a different zone.</simpara>
</listitem>
<listitem>
<simpara>Proxies and firewalls can present additional limitations that are beyond the scope of this document. See the relevant {product-title} documentation for how to address such limitations, such as <link xl:href="../../installing/install_config/configuring-firewall.xml#configuring-firewall">Configuring your firewall</link>.</simpara>
</listitem>
<listitem>
<simpara>You are responsible for configuring and maintaining L2/L3-level network connectivity between the control plane and the network-edge nodes.</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-rwn_con_adding-remote-worker-nodes_nodes-edge-remote-workers">
<title>Adding remote worker nodes</title>
<simpara>Adding remote worker nodes to a cluster involves some additional considerations.</simpara>
<itemizedlist>
<listitem>
<simpara>You must ensure that a route or a default gateway is in place to route traffic between the control plane and every remote worker node.</simpara>
</listitem>
<listitem>
<simpara>You must place the Ingress VIP on the control plane.</simpara>
</listitem>
<listitem>
<simpara>Adding remote worker nodes with user-provisioned infrastructure is identical to adding other worker nodes.</simpara>
</listitem>
<listitem>
<simpara>To add remote worker nodes to an installer-provisioned cluster at install time, specify the subnet for each worker node in the <literal>install-config.yaml</literal> file before installation. There are no additional settings required for the DHCP server. You must use virtual media, because the remote worker nodes will not have access to the local provisioning network.</simpara>
</listitem>
<listitem>
<simpara>To add remote worker nodes to an installer-provisioned cluster deployed with a provisioning network, ensure that <literal>virtualMediaViaExternalNetwork</literal> flag is set to <literal>true</literal> in the <literal>install-config.yaml</literal> file so that it will add the nodes using virtual media. Remote worker nodes will not have access to the local provisioning network. They must be deployed with virtual media rather than PXE. Additionally, specify each subnet for each group of remote worker nodes and the control plane nodes in the DHCP server.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal_ipi/ipi-install-installation-workflow.xml#ipi-install-establishing-communication-between-subnets_ipi-install-installation-workflow">Establishing communications between subnets</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal_ipi/ipi-install-installation-workflow.xml#ipi-install-configuring-host-network-interfaces-for-subnets_ipi-install-installation-workflow">Configuring host network interfaces for subnets</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal_ipi/ipi-install-installation-workflow.xml#configure-network-components-to-run-on-the-control-plane_ipi-install-installation-workflow">Configuring network components to run on the control plane</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-edge-remote-workers-network_nodes-edge-remote-workers">
<title>Network separation with remote worker nodes</title>
<simpara>All nodes send heartbeats to the Kubernetes Controller Manager Operator (kube controller) in the {product-title} cluster every 10 seconds. If the cluster does not receive heartbeats from a node, {product-title} responds using several default mechanisms.</simpara>
<simpara>{product-title} is designed to be resilient to network partitions and other disruptions. You can mitigate some of the more common disruptions, such as interruptions from software upgrades, network splits, and routing issues. Mitigation strategies include ensuring that pods on remote worker nodes request the correct amount of CPU and memory resources, configuring an appropriate replication policy, using redundancy across zones, and using Pod Disruption Budgets on workloads.</simpara>
<simpara>If the kube controller loses contact with a node after a configured period, the node controller on the control plane updates the node health to <literal>Unhealthy</literal> and marks the node <literal>Ready</literal> condition as <literal>Unknown</literal>. In response, the scheduler stops scheduling pods to that node. The on-premise node controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to the node and schedules pods on the node for eviction after five minutes, by default.</simpara>
<simpara>If a workload controller, such as a <literal>Deployment</literal> object or <literal>StatefulSet</literal> object, is directing traffic to pods on the unhealthy node and other nodes can reach the cluster, {product-title} routes the traffic away from the pods on the node. Nodes that cannot reach the cluster do not get updated with the new traffic routing. As a result, the workloads on those nodes might continue to attempt to reach the unhealthy node.</simpara>
<simpara>You can mitigate the effects of connection loss by:</simpara>
<itemizedlist>
<listitem>
<simpara>using daemon sets to create pods that tolerate the taints</simpara>
</listitem>
<listitem>
<simpara>using static pods that automatically restart if a node goes down</simpara>
</listitem>
<listitem>
<simpara>using Kubernetes zones to control pod eviction</simpara>
</listitem>
<listitem>
<simpara>configuring pod tolerations to delay or avoid pod eviction</simpara>
</listitem>
<listitem>
<simpara>configuring the kubelet to control the timing of when it marks nodes as unhealthy.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information on using these objects in a cluster with remote worker nodes, see <link xl:href="../../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers-strategies_nodes-edge-remote-workers">About remote worker node strategies</link>.</simpara>
</section>
<section xml:id="nodes-edge-remote-workers-power_nodes-edge-remote-workers">
<title>Power loss on remote worker nodes</title>
<simpara>If a remote worker node loses power or restarts ungracefully, {product-title} responds using several default mechanisms.</simpara>
<simpara>If the Kubernetes Controller Manager Operator (kube controller) loses contact with a node after a configured period, the control plane updates the node health to <literal>Unhealthy</literal> and marks the node <literal>Ready</literal> condition as <literal>Unknown</literal>. In response, the scheduler stops scheduling pods to that node.  The on-premise node controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to the node and schedules pods on the node for eviction after five minutes, by default.</simpara>
<simpara>On the node, the pods must be restarted when the node recovers power and reconnects with the control plane.</simpara>
<note>
<simpara>If you want the pods to restart immediately upon restart, use static pods.</simpara>
</note>
<simpara>After the node restarts, the kubelet also restarts and attempts to restart the pods that were scheduled on the node. If the connection to the control plane takes longer than the default five minutes, the control plane cannot update the node health and remove the <literal>node.kubernetes.io/unreachable</literal> taint. On the node, the kubelet terminates any running pods. When these conditions are cleared, the scheduler can start scheduling pods to that node.</simpara>
<simpara>You can mitigate the effects of power loss by:</simpara>
<itemizedlist>
<listitem>
<simpara>using daemon sets to create pods that tolerate the taints</simpara>
</listitem>
<listitem>
<simpara>using static pods that automatically restart with a node</simpara>
</listitem>
<listitem>
<simpara>configuring pods tolerations to delay or avoid pod eviction</simpara>
</listitem>
<listitem>
<simpara>configuring the kubelet to control the timing of when the node controller marks nodes as unhealthy.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information on using these objects in a cluster with remote worker nodes, see <link xl:href="../../nodes/edge/nodes-edge-remote-workers.xml#nodes-edge-remote-workers-strategies_nodes-edge-remote-workers">About remote worker node strategies</link>.</simpara>
</section>
<section xml:id="nodes-edge-remote-workers-latency">
<title>Latency spikes or temporary reduction in throughput to remote workers</title>
<simpara>If the cluster administrator has performed latency tests for platform verification, they can discover the need to adjust the operation of the cluster to ensure stability in cases of high latency. The cluster administrator need change only one parameter, recorded in a file, which controls four parameters affecting how supervisory processes read status and interpret the health of the cluster. Changing only the one parameter provides cluster tuning in an easy, supportable manner.</simpara>
<simpara>The <literal>Kubelet</literal> process provides the starting point for monitoring cluster health. The <literal>Kubelet</literal> sets status values for all nodes in the {product-title} cluster. The Kubernetes Controller Manager (<literal>kube controller</literal>) reads the status values every 10 seconds, by default.
If the <literal>kube controller</literal> cannot read a node status value, it loses contact with that node after a configured period. The default behavior is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The node controller on the control plane updates the node health to <literal>Unhealthy</literal> and marks the node <literal>Ready</literal> condition`Unknown`.</simpara>
</listitem>
<listitem>
<simpara>In response, the scheduler stops scheduling pods to that node.</simpara>
</listitem>
<listitem>
<simpara>The Node Lifecycle Controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to the node and schedules any pods on the node for eviction after five minutes, by default.</simpara>
</listitem>
</orderedlist>
<simpara>This behavior can cause problems if your network is prone to latency issues, especially if you have nodes at the network edge. In some cases, the Kubernetes Controller Manager might not receive an update from a healthy node due to network latency. The <literal>Kubelet</literal> evicts pods from the node even though the node is healthy.</simpara>
<simpara>To avoid this problem, you can use <emphasis>worker latency profiles</emphasis> to adjust the frequency that the <literal>Kubelet</literal> and the Kubernetes Controller Manager wait for status updates before taking action. These adjustments help to ensure that your cluster runs properly if network latency between the control plane and the worker nodes is not optimal.</simpara>
<simpara>These worker latency profiles contain three sets of parameters that are pre-defined with carefully tuned values to control the reaction of the cluster to increased latency. No need to experimentally find the best values manually.</simpara>
<simpara>You can configure worker latency profiles when installing a cluster or at any time you notice increased latency in your cluster network.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-worker-latency-profiles.xml#nodes-cluster-worker-latency-profiles">Improving cluster stability in high latency environments using worker latency profiles </link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="nodes-edge-remote-workers-strategies_nodes-edge-remote-workers">
<title>Remote worker node strategies</title>
<simpara>If you use remote worker nodes, consider which objects to use to run your applications.</simpara>
<simpara>It is recommended to use daemon sets or static pods based on the behavior you want in the event of network issues or power loss. In addition, you can use Kubernetes zones and tolerations to control or avoid pod evictions if the control plane cannot reach remote worker nodes.</simpara>
<variablelist xml:id="nodes-edge-remote-workers-strategies-daemonsets_nodes-edge-remote-workers">
<varlistentry>
<term>Daemon sets</term>
<listitem>
<simpara>Daemon sets are the best approach to managing pods on remote worker nodes for the following reasons:</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<listitem>
<simpara>Daemon sets do not typically need rescheduling behavior. If a node disconnects from the cluster, pods on the node can continue to run. {product-title} does not change the state of daemon set pods, and leaves the pods in the state they last reported. For example, if a daemon set pod is in the <literal>Running</literal> state, when a node stops communicating, the pod keeps running and is assumed to be running by {product-title}.</simpara>
</listitem>
<listitem>
<simpara>Daemon set pods, by default, are created with <literal>NoExecute</literal> tolerations for the <literal>node.kubernetes.io/unreachable</literal> and <literal>node.kubernetes.io/not-ready</literal> taints with no <literal>tolerationSeconds</literal> value. These default values ensure that daemon set pods are never evicted if the control plane cannot reach a node. For example:</simpara>
<formalpara>
<title>Tolerations added to daemon set pods by default</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  tolerations:
    - key: node.kubernetes.io/not-ready
      operator: Exists
      effect: NoExecute
    - key: node.kubernetes.io/unreachable
      operator: Exists
      effect: NoExecute
    - key: node.kubernetes.io/disk-pressure
      operator: Exists
      effect: NoSchedule
    - key: node.kubernetes.io/memory-pressure
      operator: Exists
      effect: NoSchedule
    - key: node.kubernetes.io/pid-pressure
      operator: Exists
      effect: NoSchedule
    - key: node.kubernetes.io/unschedulable
      operator: Exists
      effect: NoSchedule</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Daemon sets can use labels to ensure that a workload runs on a matching worker node.</simpara>
</listitem>
<listitem>
<simpara>You can use an {product-title} service endpoint to load balance daemon set pods.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Daemon sets do not schedule pods after a reboot of the node if {product-title} cannot reach the node.</simpara>
</note>
<variablelist xml:id="nodes-edge-remote-workers-strategies-static_nodes-edge-remote-workers">
<varlistentry>
<term>Static pods</term>
<listitem>
<simpara>If you want pods restart if a node reboots, after a power loss for example, consider <link xl:href="https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/">static pods</link>. The kubelet on a node automatically restarts static pods as node restarts.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>Static pods cannot use secrets and config maps.</simpara>
</note>
<variablelist xml:id="nodes-edge-remote-workers-strategies-zones_nodes-edge-remote-workers">
<varlistentry>
<term>Kubernetes zones</term>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/setup/best-practices/multiple-zones/">Kubernetes zones</link> can slow down the rate or, in some cases, completely stop pod evictions.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>When the control plane cannot reach a node, the node controller, by default, applies <literal>node.kubernetes.io/unreachable</literal> taints and evicts pods at a rate of 0.1 nodes per second. However, in a cluster that uses Kubernetes zones, pod eviction behavior is altered.</simpara>
<simpara>If a zone is fully disrupted, where all nodes in the zone have a <literal>Ready</literal> condition that is <literal>False</literal> or <literal>Unknown</literal>, the control plane does not apply the <literal>node.kubernetes.io/unreachable</literal> taint to the nodes in that zone.</simpara>
<simpara>For partially disrupted zones, where more than 55% of the nodes have a <literal>False</literal> or <literal>Unknown</literal> condition, the pod eviction rate is reduced to 0.01 nodes per second. Nodes in smaller clusters, with fewer than 50 nodes, are not tainted. Your cluster must have more than three zones for these behavior to take effect.</simpara>
<simpara>You assign a node to a specific zone by applying the <literal>topology.kubernetes.io/region</literal> label in the node specification.</simpara>
<formalpara>
<title>Sample node labels for Kubernetes zones</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Node
apiVersion: v1
metadata:
  labels:
    topology.kubernetes.io/region=east</programlisting>
</para>
</formalpara>
<variablelist xml:id="nodes-edge-remote-workers-strategies-kubeconfig_nodes-edge-remote-workers">
<varlistentry>
<term><literal>KubeletConfig</literal> objects</term>
<listitem>
</listitem>
</varlistentry>
</variablelist>
<simpara>You can adjust the amount of time that the kubelet checks the state of each node.</simpara>
<simpara>To set the interval that affects the timing of when the on-premise node controller marks nodes with the <literal>Unhealthy</literal> or <literal>Unreachable</literal> condition, create a <literal>KubeletConfig</literal> object that contains the <literal>node-status-update-frequency</literal> and <literal>node-status-report-frequency</literal> parameters.</simpara>
<simpara>The kubelet on each node determines the node status as defined by the <literal>node-status-update-frequency</literal> setting and reports that status to the cluster based on the <literal>node-status-report-frequency</literal> setting. By default, the kubelet determines the pod status every 10 seconds and reports the status every minute. However, if the node state changes, the kubelet reports the change to the cluster immediately. {product-title} uses the <literal>node-status-report-frequency</literal> setting only when the Node Lease feature gate is enabled, which is the default state in {product-title} clusters. If the Node Lease feature gate is disabled, the node reports its status based on the <literal>node-status-update-frequency</literal> setting.</simpara>
<formalpara>
<title>Example kubelet config</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: KubeletConfig
metadata:
  name: disable-cpu-units
spec:
  machineConfigPoolSelector:
    matchLabels:
      machineconfiguration.openshift.io/role: worker <co xml:id="CO184-1"/>
  kubeletConfig:
    node-status-update-frequency: <co xml:id="CO184-2"/>
      - "10s"
    node-status-report-frequency: <co xml:id="CO184-3"/>
      - "1m"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO184-1">
<para>Specify the type of node type to which this <literal>KubeletConfig</literal> object applies using the label from the <literal>MachineConfig</literal> object.</para>
</callout>
<callout arearefs="CO184-2">
<para>Specify the frequency that the kubelet checks the status of a node associated with this <literal>MachineConfig</literal> object. The default value is <literal>10s</literal>. If you change this default, the <literal>node-status-report-frequency</literal> value is changed to the same value.</para>
</callout>
<callout arearefs="CO184-3">
<para>Specify the frequency that the kubelet reports the status of a node associated with this <literal>MachineConfig</literal> object. The default value is <literal>1m</literal>.</para>
</callout>
</calloutlist>
<simpara>The <literal>node-status-update-frequency</literal> parameter works with the <literal>node-monitor-grace-period</literal> parameter.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>node-monitor-grace-period</literal> parameter specifies how long {product-title} waits after a node associated with a <literal>MachineConfig</literal> object is marked <literal>Unhealthy</literal> if the controller manager does not receive the node heartbeat. Workloads on the node continue to run after this time. If the remote worker node rejoins the cluster after <literal>node-monitor-grace-period</literal> expires, pods continue to run. New pods can be scheduled to that node. The <literal>node-monitor-grace-period</literal> interval is <literal>40s</literal>. The <literal>node-status-update-frequency</literal> value must be lower than the <literal>node-monitor-grace-period</literal> value.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Modifying the <literal>node-monitor-grace-period</literal> parameter is not supported.</simpara>
</note>
<variablelist xml:id="nodes-edge-remote-workers-strategies-tolerations_nodes-edge-remote-workers">
<varlistentry>
<term>Tolerations</term>
<listitem>
<simpara>You can use pod tolerations to mitigate the effects if the on-premise node controller adds a <literal>node.kubernetes.io/unreachable</literal> taint with a <literal>NoExecute</literal> effect to a node it cannot reach.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>A taint with the <literal>NoExecute</literal> effect affects pods that are running on the node in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Pods that do not tolerate the taint are queued for eviction.</simpara>
</listitem>
<listitem>
<simpara>Pods that tolerate the taint without specifying a <literal>tolerationSeconds</literal> value in their toleration specification remain bound forever.</simpara>
</listitem>
<listitem>
<simpara>Pods that tolerate the taint with a specified <literal>tolerationSeconds</literal> value remain bound for the specified amount of time. After the time elapses, the pods are queued for eviction.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Unless tolerations are explicitly set, Kubernetes automatically adds a toleration for <literal>node.kubernetes.io/not-ready</literal> and <literal>node.kubernetes.io/unreachable</literal> with <literal>tolerationSeconds=300</literal>, meaning that pods remain bound for 5 minutes if either of these taints is detected.</simpara>
</note>
<simpara>You can delay or avoid pod eviction by configuring pods tolerations with the <literal>NoExecute</literal> effect for the <literal>node.kubernetes.io/unreachable</literal> and <literal>node.kubernetes.io/not-ready</literal> taints.</simpara>
<formalpara>
<title>Example toleration in a pod spec</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
tolerations:
- key: "node.kubernetes.io/unreachable"
  operator: "Exists"
  effect: "NoExecute" <co xml:id="CO185-1"/>
- key: "node.kubernetes.io/not-ready"
  operator: "Exists"
  effect: "NoExecute" <co xml:id="CO185-2"/>
  tolerationSeconds: 600 <co xml:id="CO185-3"/>
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO185-1">
<para>The <literal>NoExecute</literal> effect without <literal>tolerationSeconds</literal> lets pods remain forever if the control plane cannot reach the node.</para>
</callout>
<callout arearefs="CO185-2">
<para>The <literal>NoExecute</literal> effect with <literal>tolerationSeconds</literal>: 600 lets pods remain for 10 minutes if the control plane marks the node as <literal>Unhealthy</literal>.</para>
</callout>
<callout arearefs="CO185-3">
<para>You can specify your own <literal>tolerationSeconds</literal> value.</para>
</callout>
</calloutlist>
<variablelist xml:id="nodes-edge-remote-workers-strategies-objects_nodes-edge-remote-workers">
<varlistentry>
<term>Other types of {product-title} objects</term>
<listitem>
<simpara>You can use replica sets, deployments, and replication controllers. The scheduler can reschedule these pods onto other nodes after the node is disconnected for five minutes. Rescheduling onto other nodes can be beneficial for some workloads, such as REST APIs, where an administrator can guarantee a specific number of pods are running and accessible.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>When working with remote worker nodes, rescheduling pods on different nodes might not be acceptable if remote worker nodes are intended to be reserved for specific functions.</simpara>
</note>
<simpara xml:id="nodes-edge-remote-workers-strategies-statefulset_nodes-edge-remote-workers"><link xl:href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">stateful sets</link> do not get restarted when there is an outage. The pods remain in the <literal>terminating</literal> state until the control plane can acknowledge that the pods are terminated.</simpara>
<simpara>To avoid scheduling a to a node that does not have access to the same type of persistent storage, {product-title} cannot migrate pods that require persistent volumes to other zones in the case of network separation.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information on Daemonesets, see <link xl:href="../../nodes/jobs/nodes-pods-daemonsets.xml#nodes-pods-daemonsets">DaemonSets</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on  taints and tolerations, see <link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-about_nodes-scheduler-taints-tolerations">Controlling pod placement using node taints</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on configuring <literal>KubeletConfig</literal> objects, see <link xl:href="../../post_installation_configuration/node-tasks.xml#create-a-kubeletconfig-crd-to-edit-kubelet-parameters_post-install-node-tasks">Creating a KubeletConfig CRD</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on replica sets, see <link xl:href="../../applications/deployments/what-deployments-are.xml#deployments-repliasets_what-deployments-are">ReplicaSets</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on deployments, see <link xl:href="../../applications/deployments/what-deployments-are.xml#deployments-kube-deployments_what-deployments-are">Deployments</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on replication controllers, see <link xl:href="../../applications/deployments/what-deployments-are.xml#deployments-replicationcontrollers_what-deployments-are">Replication controllers</link>.</simpara>
</listitem>
<listitem>
<simpara>For more information on the controller manager, see <link xl:href="../../operators/operator-reference.xml#kube-controller-manager-operator_cluster-operators-ref">Kubernetes Controller Manager Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_worker_nodes_for_single_node_openshift_clusters">
<title>Worker nodes for single-node OpenShift clusters</title>
<section xml:id="nodes-sno-worker-nodes">
<title>Adding worker nodes to single-node OpenShift clusters</title>

<simpara>Single-node OpenShift clusters reduce the host prerequisites for deployment to a single host. This is useful for deployments in constrained environments or at the network edge. However, sometimes you need to add additional capacity to your cluster, for example, in telecommunications and network edge scenarios. In these scenarios, you can add worker nodes to the single-node cluster.</simpara>
<note>
<simpara>Unlike multi-node clusters, by default all ingress traffic is routed to the single control-plane node, even after adding additional worker nodes.</simpara>
</note>
<simpara>There are several ways that you can add worker nodes to a single-node cluster. You can add worker nodes to a cluster manually, using <link xl:href="https://console.redhat.com/openshift/assisted-installer/clusters">Red Hat OpenShift Cluster Manager</link>, or by using the Assisted Installer REST API directly.</simpara>
<important>
<simpara>Adding worker nodes does not expand the cluster control plane, and it does not provide high availability to your cluster. For single-node OpenShift clusters, high availability is handled by failing over to another site. It is not recommended to add a large number of worker nodes to a single-node cluster.</simpara>
</important>
<note>
<simpara>To add worker nodes, you must have access to the OpenShift Cluster Manager. This method is not supported when using the Agent-based installer to install a cluster in a disconnected environment.</simpara>
</note>
<section xml:id="ai-sno-requirements-for-installing-worker-nodes_add-workers">
<title>Requirements for installing single-node OpenShift worker nodes</title>
<simpara>To install a single-node OpenShift worker node, you must address the following requirements:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Administration host:</emphasis> You must have a computer to prepare the ISO and to monitor the installation.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Production-grade server:</emphasis> Installing single-node OpenShift worker nodes requires a server with sufficient resources to run {product-title} services and a production workload.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Minimum resource requirements</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">vCPU</entry>
<entry align="left" valign="top">Memory</entry>
<entry align="left" valign="top">Storage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Minimum</simpara></entry>
<entry align="left" valign="top"><simpara>2 vCPU cores</simpara></entry>
<entry align="left" valign="top"><simpara>8GB of RAM</simpara></entry>
<entry align="left" valign="top"><simpara>100GB</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>One vCPU is equivalent to one physical core when simultaneous multithreading (SMT), or hyperthreading, is not enabled. When enabled, use the following formula to calculate the corresponding ratio:</simpara>
<simpara>(threads per core × cores) × sockets = vCPUs</simpara>
</note>
<simpara>The server must have a Baseboard Management Controller (BMC) when booting with virtual media.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Networking:</emphasis> The worker node server must have access to the internet or access to a local registry if it is not connected to a routable network. The worker node server must have a DHCP reservation or a static IP address and be able to access the single-node OpenShift cluster Kubernetes API, ingress route, and cluster node domain names. You must configure the DNS to resolve the IP address to each of the following fully qualified domain names (FQDN) for the single-node OpenShift cluster:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Required DNS records</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Usage</entry>
<entry align="left" valign="top">FQDN</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Kubernetes API</simpara></entry>
<entry align="left" valign="top"><simpara><literal>api.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Add a DNS A/AAAA or CNAME record. This record must be resolvable by clients external to the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Internal API</simpara></entry>
<entry align="left" valign="top"><simpara><literal>api-int.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Add a DNS A/AAAA or CNAME record when creating the ISO manually. This record must be resolvable by nodes within the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ingress route</simpara></entry>
<entry align="left" valign="top"><simpara><literal>*.apps.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Add a wildcard DNS A/AAAA or CNAME record that targets the node. This record must be resolvable by clients external to the cluster.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Without persistent IP addresses, communications between the <literal>apiserver</literal> and <literal>etcd</literal> might fail.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal/installing-restricted-networks-bare-metal.xml#installation-minimum-resource-requirements_installing-restricted-networks-bare-metal">Minimum resource requirements for cluster installation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../scalability_and_performance/recommended-performance-scale-practices/recommended-control-plane-practices.xml#recommended-scale-practices_cluster-scaling">Recommended practices for scaling the cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal/installing-bare-metal-network-customizations.xml#installation-dns-user-infra_installing-bare-metal-network-customizations">User-provisioned DNS requirements</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_sno/install-sno-installing-sno.xml#installing-with-usb-media_install-sno-installing-sno-with-the-assisted-installer">Creating a bootable ISO image on a USB drive</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_sno/install-sno-installing-sno.xml#install-booting-from-an-iso-over-http-redfish_install-sno-installing-sno-with-the-assisted-installer">Booting from an ISO image served over HTTP using the Redfish API</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-deleting_nodes-nodes-working">Deleting nodes from a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="sno-adding-worker-nodes-to-sno-clusters_add-workers">
<title>Adding worker nodes using the Assisted Installer and OpenShift Cluster Manager</title>
<simpara>You can add worker nodes to single-node OpenShift clusters that were created on <link xl:href="https://console.redhat.com">Red Hat OpenShift Cluster Manager</link> using the <link xl:href="https://console.redhat.com/openshift/assisted-installer/clusters/~new">Assisted Installer</link>.</simpara>
<important>
<simpara>Adding worker nodes to single-node OpenShift clusters is only supported for clusters running {product-title} version 4.11 and up.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have access to a single-node OpenShift cluster installed using <link xl:href="https://console.redhat.com/openshift/assisted-installer/clusters/~new">Assisted Installer</link>.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Ensure that all the required DNS records exist for the cluster that you are adding the worker node to.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <link xl:href="https://console.redhat.com/openshift">OpenShift Cluster Manager</link> and click the single-node cluster that you want to add a worker node to.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Add hosts</emphasis>, and download the discovery ISO for the new worker node, adding SSH public key and configuring cluster-wide proxy settings as required.</simpara>
</listitem>
<listitem>
<simpara>Boot the target host using the discovery ISO, and wait for the host to be discovered in the console. After the host is discovered, start the installation.</simpara>
</listitem>
<listitem>
<simpara>As the installation proceeds, the installation generates pending certificate signing requests (CSRs) for the worker node. When prompted, approve the pending CSRs to complete the installation.</simpara>
<simpara>When the worker node is sucessfully installed, it is listed as a worker node in the cluster web console.</simpara>
</listitem>
</orderedlist>
<important>
<simpara>New worker nodes will be encrypted using the same method as the original cluster.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal/installing-bare-metal-network-customizations.xml#installation-dns-user-infra_installing-bare-metal-network-customizations">User-provisioned DNS requirements</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-sno-worker-nodes.xml#installation-approve-csrs_add-workers">Approving the certificate signing requests for your machines</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_adding_worker_nodes_using_the_assisted_installer_api">
<title>Adding worker nodes using the Assisted Installer API</title>
<simpara>You can add worker nodes to single-node OpenShift clusters using the Assisted Installer REST API. Before you add worker nodes, you must log in to <link xl:href="https://console.redhat.com/openshift/token/show">OpenShift Cluster Manager</link> and authenticate against the API.</simpara>
<section xml:id="ai-authenticating-against-ai-rest-api_add-workers">
<title>Authenticating against the Assisted Installer REST API</title>
<simpara>Before you can use the Assisted Installer REST API, you must authenticate against the API using a JSON web token (JWT) that you generate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Log in to <link xl:href="https://console.redhat.com/openshift/assisted-installer/clusters">OpenShift Cluster Manager</link> as a user with cluster creation privileges.</simpara>
</listitem>
<listitem>
<simpara>Install <literal>jq</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <link xl:href="https://console.redhat.com/openshift/token/show">OpenShift Cluster Manager</link> and copy your API token.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>$OFFLINE_TOKEN</literal> variable using the copied API token by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export OFFLINE_TOKEN=&lt;copied_api_token&gt;</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>$JWT_TOKEN</literal> variable using the previously set <literal>$OFFLINE_TOKEN</literal> variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export JWT_TOKEN=$(
  curl \
  --silent \
  --header "Accept: application/json" \
  --header "Content-Type: application/x-www-form-urlencoded" \
  --data-urlencode "grant_type=refresh_token" \
  --data-urlencode "client_id=cloud-services" \
  --data-urlencode "refresh_token=${OFFLINE_TOKEN}" \
  "https://sso.redhat.com/auth/realms/redhat-external/protocol/openid-connect/token" \
  | jq --raw-output ".access_token"
)</programlisting>
<note>
<simpara>The JWT token is valid for 15 minutes only.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Optional: Check that you can access the API by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s https://api.openshift.com/api/assisted-install/v2/component-versions -H "Authorization: Bearer ${JWT_TOKEN}" | jq</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">{
    "release_tag": "v2.5.1",
    "versions":
    {
        "assisted-installer": "registry.redhat.io/rhai-tech-preview/assisted-installer-rhel8:v1.0.0-175",
        "assisted-installer-controller": "registry.redhat.io/rhai-tech-preview/assisted-installer-reporter-rhel8:v1.0.0-223",
        "assisted-installer-service": "quay.io/app-sre/assisted-service:ac87f93",
        "discovery-agent": "registry.redhat.io/rhai-tech-preview/assisted-installer-agent-rhel8:v1.0.0-156"
    }
}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ai-adding-worker-nodes-to-cluster_add-workers">
<title>Adding worker nodes using the Assisted Installer REST API</title>
<simpara>You can add worker nodes to clusters using the Assisted Installer REST API.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift Cluster Manager CLI (<literal>ocm</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to <link xl:href="https://console.redhat.com/openshift/assisted-installer/clusters">OpenShift Cluster Manager</link> as a user with cluster creation privileges.</simpara>
</listitem>
<listitem>
<simpara>Install <literal>jq</literal>.</simpara>
</listitem>
<listitem>
<simpara>Ensure that all the required DNS records exist for the cluster that you are adding the worker node to.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Authenticate against the Assisted Installer REST API and generate a JSON web token (JWT) for your session. The generated JWT token is valid for 15 minutes only.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>$API_URL</literal> variable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export API_URL=&lt;api_url&gt; <co xml:id="CO186-1"/></programlisting>
<calloutlist>
<callout arearefs="CO186-1">
<para>Replace <literal>&lt;api_url&gt;</literal> with the Assisted Installer API URL, for example, <literal><link xl:href="https://api.openshift.com">https://api.openshift.com</link></literal></para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Import the single-node OpenShift cluster by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the <literal>$OPENSHIFT_CLUSTER_ID</literal> variable. Log in to the cluster and run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export OPENSHIFT_CLUSTER_ID=$(oc get clusterversion -o jsonpath='{.items[].spec.clusterID}')</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>$CLUSTER_REQUEST</literal> variable that is used to import the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export CLUSTER_REQUEST=$(jq --null-input --arg openshift_cluster_id "$OPENSHIFT_CLUSTER_ID" '{
  "api_vip_dnsname": "&lt;api_vip&gt;", <co xml:id="CO187-1"/>
  "openshift_cluster_id": $openshift_cluster_id,
  "name": "&lt;openshift_cluster_name&gt;" <co xml:id="CO187-2"/>
}')</programlisting>
<calloutlist>
<callout arearefs="CO187-1">
<para>Replace <literal>&lt;api_vip&gt;</literal> with the hostname for the cluster&#8217;s API server. This can be the DNS domain for the API server or the IP address of the single node which the worker node can reach. For example, <literal>api.compute-1.example.com</literal>.</para>
</callout>
<callout arearefs="CO187-2">
<para>Replace <literal>&lt;openshift_cluster_name&gt;</literal> with the plain text name for the cluster. The cluster name should match the cluster name that was set during the Day 1 cluster installation.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Import the cluster and set the <literal>$CLUSTER_ID</literal> variable. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ CLUSTER_ID=$(curl "$API_URL/api/assisted-install/v2/clusters/import" -H "Authorization: Bearer ${JWT_TOKEN}" -H 'accept: application/json' -H 'Content-Type: application/json' \
  -d "$CLUSTER_REQUEST" | tee /dev/stderr | jq -r '.id')</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Generate the <literal>InfraEnv</literal> resource for the cluster and set the <literal>$INFRA_ENV_ID</literal> variable by running the following commands:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Download the pull secret file from Red Hat OpenShift Cluster Manager at <link xl:href="console.redhat.com/openshift/install/pull-secret">console.redhat.com</link>.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>$INFRA_ENV_REQUEST</literal> variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">export INFRA_ENV_REQUEST=$(jq --null-input \
    --slurpfile pull_secret &lt;path_to_pull_secret_file&gt; \<co xml:id="CO188-1"/>
    --arg ssh_pub_key "$(cat &lt;path_to_ssh_pub_key&gt;)" \<co xml:id="CO188-2"/>
    --arg cluster_id "$CLUSTER_ID" '{
  "name": "&lt;infraenv_name&gt;", <co xml:id="CO188-3"/>
  "pull_secret": $pull_secret[0] | tojson,
  "cluster_id": $cluster_id,
  "ssh_authorized_key": $ssh_pub_key,
  "image_type": "&lt;iso_image_type&gt;" <co xml:id="CO188-4"/>
}')</programlisting>
<calloutlist>
<callout arearefs="CO188-1">
<para>Replace <literal>&lt;path_to_pull_secret_file&gt;</literal> with the path to the local file containing the downloaded pull secret from Red Hat OpenShift Cluster Manager at <link xl:href="console.redhat.com/openshift/install/pull-secret">console.redhat.com</link>.</para>
</callout>
<callout arearefs="CO188-2">
<para>Replace <literal>&lt;path_to_ssh_pub_key&gt;</literal> with the path to the public SSH key required to access the host. If you do not set this value, you cannot access the host while in discovery mode.</para>
</callout>
<callout arearefs="CO188-3">
<para>Replace <literal>&lt;infraenv_name&gt;</literal> with the plain text name for the <literal>InfraEnv</literal> resource.</para>
</callout>
<callout arearefs="CO188-4">
<para>Replace <literal>&lt;iso_image_type&gt;</literal> with the ISO image type, either <literal>full-iso</literal> or <literal>minimal-iso</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Post the <literal>$INFRA_ENV_REQUEST</literal> to the <link xl:href="https://api.openshift.com/?urls.primaryName=assisted-service%20service#/installer/RegisterInfraEnv">/v2/infra-envs</link> API and set the <literal>$INFRA_ENV_ID</literal> variable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ INFRA_ENV_ID=$(curl "$API_URL/api/assisted-install/v2/infra-envs" -H "Authorization: Bearer ${JWT_TOKEN}" -H 'accept: application/json' -H 'Content-Type: application/json' -d "$INFRA_ENV_REQUEST" | tee /dev/stderr | jq -r '.id')</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Get the URL of the discovery ISO for the cluster worker node by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s "$API_URL/api/assisted-install/v2/infra-envs/$INFRA_ENV_ID" -H "Authorization: Bearer ${JWT_TOKEN}" | jq -r '.download_url'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">https://api.openshift.com/api/assisted-images/images/41b91e72-c33e-42ee-b80f-b5c5bbf6431a?arch=x86_64&amp;image_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTYwMjYzNzEsInN1YiI6IjQxYjkxZTcyLWMzM2UtNDJlZS1iODBmLWI1YzViYmY2NDMxYSJ9.1EX_VGaMNejMhrAvVRBS7PDPIQtbOOc8LtG8OukE1a4&amp;type=minimal-iso&amp;version=$VERSION</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Download the ISO:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -L -s '&lt;iso_url&gt;' --output rhcos-live-minimal.iso <co xml:id="CO189-1"/></programlisting>
<calloutlist>
<callout arearefs="CO189-1">
<para>Replace <literal>&lt;iso_url&gt;</literal> with the URL for the ISO from the previous step.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Boot the new worker host from the downloaded <literal>rhcos-live-minimal.iso</literal>.</simpara>
</listitem>
<listitem>
<simpara>Get the list of hosts in the cluster that are <emphasis>not</emphasis> installed. Keep running the following command until the new host shows up:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s "$API_URL/api/assisted-install/v2/clusters/$CLUSTER_ID" -H "Authorization: Bearer ${JWT_TOKEN}" | jq -r '.hosts[] | select(.status != "installed").id'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2294ba03-c264-4f11-ac08-2f1bb2f8c296</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set the <literal>$HOST_ID</literal> variable for the new worker node, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ HOST_ID=&lt;host_id&gt; <co xml:id="CO190-1"/></programlisting>
<calloutlist>
<callout arearefs="CO190-1">
<para>Replace <literal>&lt;host_id&gt;</literal> with the host ID from the previous step.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check that the host is ready to install by running the following command:</simpara>
<note>
<simpara>Ensure that you copy the entire command including the complete <literal>jq</literal> expression.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s $API_URL/api/assisted-install/v2/clusters/$CLUSTER_ID -H "Authorization: Bearer ${JWT_TOKEN}" | jq '
def host_name($host):
    if (.suggested_hostname // "") == "" then
        if (.inventory // "") == "" then
            "Unknown hostname, please wait"
        else
            .inventory | fromjson | .hostname
        end
    else
        .suggested_hostname
    end;

def is_notable($validation):
    ["failure", "pending", "error"] | any(. == $validation.status);

def notable_validations($validations_info):
    [
        $validations_info // "{}"
        | fromjson
        | to_entries[].value[]
        | select(is_notable(.))
    ];

{
    "Hosts validations": {
        "Hosts": [
            .hosts[]
            | select(.status != "installed")
            | {
                "id": .id,
                "name": host_name(.),
                "status": .status,
                "notable_validations": notable_validations(.validations_info)
            }
        ]
    },
    "Cluster validations info": {
        "notable_validations": notable_validations(.validations_info)
    }
}
' -r</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "Hosts validations": {
    "Hosts": [
      {
        "id": "97ec378c-3568-460c-bc22-df54534ff08f",
        "name": "localhost.localdomain",
        "status": "insufficient",
        "notable_validations": [
          {
            "id": "ntp-synced",
            "status": "failure",
            "message": "Host couldn't synchronize with any NTP server"
          },
          {
            "id": "api-domain-name-resolved-correctly",
            "status": "error",
            "message": "Parse error for domain name resolutions result"
          },
          {
            "id": "api-int-domain-name-resolved-correctly",
            "status": "error",
            "message": "Parse error for domain name resolutions result"
          },
          {
            "id": "apps-domain-name-resolved-correctly",
            "status": "error",
            "message": "Parse error for domain name resolutions result"
          }
        ]
      }
    ]
  },
  "Cluster validations info": {
    "notable_validations": []
  }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>When the previous command shows that the host is ready, start the installation using the <link xl:href="https://api.openshift.com/?urls.primaryName=assisted-service%20service#/installer/v2InstallHost">/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/install</link> API by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -X POST -s "$API_URL/api/assisted-install/v2/infra-envs/$INFRA_ENV_ID/hosts/$HOST_ID/actions/install"  -H "Authorization: Bearer ${JWT_TOKEN}"</programlisting>
</listitem>
<listitem>
<simpara>As the installation proceeds, the installation generates pending certificate signing requests (CSRs) for the worker node.</simpara>
<important>
<simpara>You must approve the CSRs to complete the installation.</simpara>
</important>
<simpara>Keep running the following API call to monitor the cluster installation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s "$API_URL/api/assisted-install/v2/clusters/$CLUSTER_ID" -H "Authorization: Bearer ${JWT_TOKEN}" | jq '{
    "Cluster day-2 hosts":
        [
            .hosts[]
            | select(.status != "installed")
            | {id, requested_hostname, status, status_info, progress, status_updated_at, updated_at, infra_env_id, cluster_id, created_at}
        ]
}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{
  "Cluster day-2 hosts": [
    {
      "id": "a1c52dde-3432-4f59-b2ae-0a530c851480",
      "requested_hostname": "control-plane-1",
      "status": "added-to-existing-cluster",
      "status_info": "Host has rebooted and no further updates will be posted. Please check console for progress and to possibly approve pending CSRs",
      "progress": {
        "current_stage": "Done",
        "installation_percentage": 100,
        "stage_started_at": "2022-07-08T10:56:20.476Z",
        "stage_updated_at": "2022-07-08T10:56:20.476Z"
      },
      "status_updated_at": "2022-07-08T10:56:20.476Z",
      "updated_at": "2022-07-08T10:57:15.306369Z",
      "infra_env_id": "b74ec0c3-d5b5-4717-a866-5b6854791bd3",
      "cluster_id": "8f721322-419d-4eed-aa5b-61b50ea586ae",
      "created_at": "2022-07-06T22:54:57.161614Z"
    }
  ]
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Run the following command to see all the events for the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -s "$API_URL/api/assisted-install/v2/events?cluster_id=$CLUSTER_ID" -H "Authorization: Bearer ${JWT_TOKEN}" | jq -c '.[] | {severity, message, event_time, host_id}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"severity":"info","message":"Host compute-0: updated status from insufficient to known (Host is ready to be installed)","event_time":"2022-07-08T11:21:46.346Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}
{"severity":"info","message":"Host compute-0: updated status from known to installing (Installation is in progress)","event_time":"2022-07-08T11:28:28.647Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}
{"severity":"info","message":"Host compute-0: updated status from installing to installing-in-progress (Starting installation)","event_time":"2022-07-08T11:28:52.068Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}
{"severity":"info","message":"Uploaded logs for host compute-0 cluster 8f721322-419d-4eed-aa5b-61b50ea586ae","event_time":"2022-07-08T11:29:47.802Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}
{"severity":"info","message":"Host compute-0: updated status from installing-in-progress to added-to-existing-cluster (Host has rebooted and no further updates will be posted. Please check console for progress and to possibly approve pending CSRs)","event_time":"2022-07-08T11:29:48.259Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}
{"severity":"info","message":"Host: compute-0, reached installation stage Rebooting","event_time":"2022-07-08T11:29:48.261Z","host_id":"9d7b3b44-1125-4ad0-9b14-76550087b445"}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Log in to the cluster and approve the pending CSRs to complete the installation.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the new worker node was successfully added to the cluster with a status of <literal>Ready</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS   ROLES           AGE   VERSION
control-plane-1.example.com    Ready    master,worker   56m   v1.28.5
compute-1.example.com          Ready    worker          11m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal/installing-bare-metal-network-customizations.xml#installation-dns-user-infra_installing-bare-metal-network-customizations">User-provisioned DNS requirements</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-sno-worker-nodes.xml#installation-approve-csrs_add-workers">Approving the certificate signing requests for your machines</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="sno-adding-worker-nodes-to-single-node-clusters-manually_add-workers">
<title>Adding worker nodes to single-node OpenShift clusters manually</title>
<simpara>You can add a worker node to a single-node OpenShift cluster manually by booting the worker node from Red Hat Enterprise Linux CoreOS (RHCOS) ISO and by using the cluster <literal>worker.ign</literal> file to join the new worker node to the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install a single-node OpenShift cluster on bare metal.</simpara>
</listitem>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Ensure that all the required DNS records exist for the cluster that you are adding the worker node to.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the {product-title} version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ OCP_VERSION=&lt;ocp_version&gt; <co xml:id="CO191-1"/></programlisting>
<calloutlist>
<callout arearefs="CO191-1">
<para>Replace <literal>&lt;ocp_version&gt;</literal> with the current version, for example, <literal>latest-{product-version}</literal></para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Set the host architecture:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ARCH=&lt;architecture&gt; <co xml:id="CO192-1"/></programlisting>
<calloutlist>
<callout arearefs="CO192-1">
<para>Replace <literal>&lt;architecture&gt;</literal> with the target host architecture, for example, <literal>aarch64</literal> or <literal>x86_64</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Get the <literal>worker.ign</literal> data from the running single-node cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc extract -n openshift-machine-api secret/worker-user-data-managed --keys=userData --to=- &gt; worker.ign</programlisting>
</listitem>
<listitem>
<simpara>Host the <literal>worker.ign</literal> file on a web server accessible from your network.</simpara>
</listitem>
<listitem>
<simpara>Download the {product-title} installer and make it available for use by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -k https://mirror.openshift.com/pub/openshift-v4/clients/ocp/$OCP_VERSION/openshift-install-linux.tar.gz &gt; openshift-install-linux.tar.gz</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ tar zxvf openshift-install-linux.tar.gz</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod +x openshift-install</programlisting>
</listitem>
<listitem>
<simpara>Retrieve the RHCOS ISO URL:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ISO_URL=$(./openshift-install coreos print-stream-json | grep location | grep $ARCH | grep iso | cut -d\" -f4)</programlisting>
</listitem>
<listitem>
<simpara>Download the RHCOS ISO:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -L $ISO_URL -o rhcos-live.iso</programlisting>
</listitem>
<listitem>
<simpara>Use the RHCOS ISO and the hosted <literal>worker.ign</literal> file to install the worker node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Boot the target host with the RHCOS ISO and your preferred method of installation.</simpara>
</listitem>
<listitem>
<simpara>When the target host has booted from the RHCOS ISO, open a console on the target host.</simpara>
</listitem>
<listitem>
<simpara>If your local network does not have DHCP enabled, you need to create an ignition file with the new hostname and configure the worker node static IP address before running the RHCOS installation. Perform the following steps:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Configure the worker host network connection with a static IP. Run the following command on the target host console:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ nmcli con mod &lt;network_interface&gt; ipv4.method manual /
ipv4.addresses &lt;static_ip&gt; ipv4.gateway &lt;network_gateway&gt; ipv4.dns &lt;dns_server&gt; /
802-3-ethernet.mtu 9000</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;static_ip&gt;</term>
<listitem>
<simpara>Is the host static IP address and CIDR, for example, <literal>10.1.101.50/24</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;network_gateway&gt;</term>
<listitem>
<simpara>Is the network gateway, for example, <literal>10.1.101.1</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Activate the modified network interface:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ nmcli con up &lt;network_interface&gt;</programlisting>
</listitem>
<listitem>
<simpara>Create a new ignition file <literal>new-worker.ign</literal> that includes a reference to the original <literal>worker.ign</literal> and an additional instruction that the <literal>coreos-installer</literal> program uses to populate the <literal>/etc/hostname</literal> file on the new worker host. For example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "ignition":{
    "version":"3.2.0",
    "config":{
      "merge":[
        {
          "source":"&lt;hosted_worker_ign_file&gt;" <co xml:id="CO193-1"/>
        }
      ]
    }
  },
  "storage":{
    "files":[
      {
        "path":"/etc/hostname",
        "contents":{
          "source":"data:,&lt;new_fqdn&gt;" <co xml:id="CO193-2"/>
        },
        "mode":420,
        "overwrite":true,
        "path":"/etc/hostname"
      }
    ]
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO193-1">
<para><literal>&lt;hosted_worker_ign_file&gt;</literal> is the locally accessible URL for the original <literal>worker.ign</literal> file. For example, <literal><link xl:href="http://webserver.example.com/worker.ign">http://webserver.example.com/worker.ign</link></literal></para>
</callout>
<callout arearefs="CO193-2">
<para><literal>&lt;new_fqdn&gt;</literal> is the new FQDN that you set for the worker node. For example, <literal>new-worker.example.com</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Host the <literal>new-worker.ign</literal> file on a web server accessible from your network.</simpara>
</listitem>
<listitem>
<simpara>Run the following <literal>coreos-installer</literal> command, passing in the <literal>ignition-url</literal> and hard disk details:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo coreos-installer install --copy-network /
--ignition-url=&lt;new_worker_ign_file&gt; &lt;hard_disk&gt; --insecure-ignition</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;new_worker_ign_file&gt;</term>
<listitem>
<simpara>is the locally accessible URL for the hosted <literal>new-worker.ign</literal> file, for example, <literal><link xl:href="http://webserver.example.com/new-worker.ign">http://webserver.example.com/new-worker.ign</link></literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;hard_disk&gt;</term>
<listitem>
<simpara>Is the hard disk where you install RHCOS, for example, <literal>/dev/sda</literal></simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>For networks that have DHCP enabled, you do not need to set a static IP. Run the following <literal>coreos-installer</literal> command from the target host console to install the system:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ coreos-installer install --ignition-url=&lt;hosted_worker_ign_file&gt; &lt;hard_disk&gt;</programlisting>
</listitem>
<listitem>
<simpara>To manually enable DHCP, apply the following <literal>NMStateConfig</literal> CR to the single-node OpenShift cluster:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: agent-install.openshift.io/v1
kind: NMStateConfig
metadata:
  name: nmstateconfig-dhcp
  namespace: example-sno
  labels:
    nmstate_config_cluster_name: &lt;nmstate_config_cluster_label&gt;
spec:
  config:
    interfaces:
      - name: eth0
        type: ethernet
        state: up
        ipv4:
          enabled: true
          dhcp: true
        ipv6:
          enabled: false
  interfaces:
    - name: "eth0"
      macAddress: "AA:BB:CC:DD:EE:11"</programlisting>
<important>
<simpara>The <literal>NMStateConfig</literal> CR is required for successful deployments of worker nodes with static IP addresses and for adding a worker node with a dynamic IP address if the single-node OpenShift was deployed with a static IP address. The cluster network DHCP does not automatically set these network settings for the new worker node.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>As the installation proceeds, the installation generates pending certificate signing requests (CSRs) for the worker node. When prompted, approve the pending CSRs to complete the installation.</simpara>
</listitem>
<listitem>
<simpara>When the install is complete, reboot the host. The host joins the cluster as a new worker node.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the new worker node was successfully added to the cluster with a status of <literal>Ready</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS   ROLES           AGE   VERSION
control-plane-1.example.com    Ready    master,worker   56m   v1.28.5
compute-1.example.com          Ready    worker          11m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_bare_metal/installing-bare-metal-network-customizations.xml#installation-dns-user-infra_installing-bare-metal-network-customizations">User-provisioned DNS requirements</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-sno-worker-nodes.xml#installation-approve-csrs_add-workers">Approving the certificate signing requests for your machines</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-approve-csrs_add-workers">
<title>Approving the certificate signing requests for your machines</title>
<simpara>When you add machines to a cluster, two pending certificate signing requests (CSRs) are generated for each machine that you added. You must confirm that these CSRs are approved or, if necessary, approve them yourself. The client requests must be approved first, followed by the server requests.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You added machines to your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Confirm that the cluster recognizes the machines:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  63m  v1.28.5
master-1  Ready     master  63m  v1.28.5
master-2  Ready     master  64m  v1.28.5</programlisting>
</para>
</formalpara>
<simpara>The output lists all of the machines that you created.</simpara>
<note>
<simpara>The preceding output might not include the compute nodes, also known as worker nodes, until some CSRs are approved.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the pending CSRs and ensure that you see the client requests with the <literal>Pending</literal> or <literal>Approved</literal> status for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-8b2br   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
csr-8vnps   15m     system:serviceaccount:openshift-machine-config-operator:node-bootstrapper   Pending
...</programlisting>
</para>
</formalpara>
<simpara>In this example, two machines are joining the cluster. You might see more approved CSRs in the list.</simpara>
</listitem>
<listitem>
<simpara>If the CSRs were not approved, after all of the pending CSRs for the machines you added are in <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<note>
<simpara>Because the CSRs rotate automatically, approve your CSRs within an hour of adding the machines to the cluster. If you do not approve them within an hour, the certificates will rotate, and more than two certificates will be present for each node. You must approve all of these certificates. After the client CSR is approved, the Kubelet creates a secondary CSR for the serving certificate, which requires manual approval. Then, subsequent serving certificate renewal requests are automatically approved by the <literal>machine-approver</literal> if the Kubelet requests a new certificate with identical parameters.</simpara>
</note>
<note>
<simpara>For clusters running on platforms that are not machine API enabled, such as bare metal and other user-provisioned infrastructure, you must implement a method of automatically approving the kubelet serving certificate requests (CSRs). If a request is not approved, then the <literal>oc exec</literal>, <literal>oc rsh</literal>, and <literal>oc logs</literal> commands cannot succeed, because a serving certificate is required when the API server connects to the kubelet. Any operation that contacts the Kubelet endpoint requires this certificate approval to be in place. The method must watch for new CSRs, confirm that the CSR was submitted by the <literal>node-bootstrapper</literal> service account in the <literal>system:node</literal> or <literal>system:admin</literal> groups, and confirm the identity of the node.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO194-1"/></programlisting>
<calloutlist>
<callout arearefs="CO194-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs --no-run-if-empty oc adm certificate approve</programlisting>
<note>
<simpara>Some Operators might not become available until some CSRs are approved.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Now that your client requests are approved, you must review the server requests for each machine that you added to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        AGE     REQUESTOR                                                                   CONDITION
csr-bfd72   5m26s   system:node:ip-10-0-50-126.us-east-2.compute.internal                       Pending
csr-c57lv   5m26s   system:node:ip-10-0-95-157.us-east-2.compute.internal                       Pending
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the remaining CSRs are not approved, and are in the <literal>Pending</literal> status, approve the CSRs for your cluster machines:</simpara>
<itemizedlist>
<listitem>
<simpara>To approve them individually, run the following command for each valid CSR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm certificate approve &lt;csr_name&gt; <co xml:id="CO195-1"/></programlisting>
<calloutlist>
<callout arearefs="CO195-1">
<para><literal>&lt;csr_name&gt;</literal> is the name of a CSR from the list of current CSRs.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To approve all pending CSRs, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csr -o go-template='{{range .items}}{{if not .status}}{{.metadata.name}}{{"\n"}}{{end}}{{end}}' | xargs oc adm certificate approve</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>After all client and server CSRs have been approved, the machines have the <literal>Ready</literal> status. Verify this by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    ROLES   AGE  VERSION
master-0  Ready     master  73m  v1.28.5
master-1  Ready     master  73m  v1.28.5
master-2  Ready     master  74m  v1.28.5
worker-0  Ready     worker  11m  v1.28.5
worker-1  Ready     worker  11m  v1.28.5</programlisting>
</para>
</formalpara>
<note>
<simpara>It can take a few minutes after approval of the server CSRs for the machines to transition to the <literal>Ready</literal> status.</simpara>
</note>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional information</title>
<listitem>
<simpara>For more information on CSRs, see <link xl:href="https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/">Certificate Signing Requests</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="nodes-dashboard-using">
<title>Node metrics dashboard</title>

<simpara>The node metrics dashboard is a visual analytics dashboard that helps you identify potential pod scaling issues.</simpara>
<section xml:id="nodes-dashboard-using-about_nodes-dashboard-using">
<title>About the node metrics dashboard</title>
<simpara>The node metrics dashboard enables administrative and support team members to monitor metrics related to pod scaling, including scaling limits used to diagnose and troubleshoot scaling issues. Particularly, you can use the visual analytics displayed through the dashboard to monitor workload distributions across nodes. Insights gained from these analytics help you determine the health of your CRI-O and Kubelet system components as well as identify potential sources of excessive or imbalanced resource consumption and system instability.</simpara>
<simpara>The dashboard displays visual analytics widgets organized into the following categories:</simpara>
<variablelist>
<varlistentry>
<term>Critical</term>
<listitem>
<simpara>Includes visualizations that can help you identify node issues that could result in system instability and inefficiency</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Outliers</term>
<listitem>
<simpara>Includes histograms that visualize processes with runtime durations that fall outside of the 95th percentile</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Average durations</term>
<listitem>
<simpara>Helps you track change in the time that system components take to process operations</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Number of operations</term>
<listitem>
<simpara>Displays visualizations that help you identify changes in the number of operations being run, which in turn helps you determine the load balance and efficiency of your system</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="nodes-dashboard-using-accessing_nodes-dashboard-using">
<title>Accessing the node metrics dashboard</title>
<simpara>You can access the node metrics dashboard from the <emphasis role="strong">Administrator</emphasis> perspective.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Expand the <emphasis role="strong">Observe</emphasis> menu option and select <emphasis role="strong">Dashboards</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">Dashboard</emphasis> filter, select <emphasis role="strong">Node cluster</emphasis>.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>If no data appears in the visualizations under the <emphasis role="strong">Critical</emphasis> category, no critical anomalies were detected. The dashboard is working as intended.</simpara>
</note>
</section>
<section xml:id="nodes-dashboard-using-identify_nodes-dashboard-using">
<title>Identify metrics for indicating optimal node resource usage</title>
<simpara>The node metrics dashboard is organized into four categories: <emphasis role="strong">Critical</emphasis>, <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of Operations</emphasis>. The metrics in the <emphasis role="strong">Critical</emphasis> category help you indicate optimal node resource usage. These metrics include:</simpara>
<itemizedlist>
<listitem>
<simpara>Top 3 containers with the most OOM kills in the last day</simpara>
</listitem>
<listitem>
<simpara>Failure rate for image pulls in the last hour</simpara>
</listitem>
<listitem>
<simpara>Nodes with system reserved memory utilization &gt; 80%</simpara>
</listitem>
<listitem>
<simpara>Nodes with Kubelet system reserved memory utilization &gt; 50%</simpara>
</listitem>
<listitem>
<simpara>Nodes with CRI-O system reserved memory utilization &gt; 50%</simpara>
</listitem>
<listitem>
<simpara>Nodes with system reserved CPU utilization &gt; 80%</simpara>
</listitem>
<listitem>
<simpara>Nodes with Kubelet system reserved CPU utilization &gt; 50%</simpara>
</listitem>
<listitem>
<simpara>Nodes with CRI-O system reserved CPU utilization &gt; 50%</simpara>
</listitem>
</itemizedlist>
<section xml:id="nodes-dashboard-using-identify-critical-top3_nodes-dashboard-using">
<title>Top 3 containers with the most OOM kills in the last day</title>
<simpara>The <emphasis role="strong">Top 3 containers with the most OOM kills in the last day</emphasis> query fetches details regarding the top three containers that have experienced the most Out-Of-Memory (OOM) kills in the previous day.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>topk(3, sum(increase(container_runtime_crio_containers_oom_count_total[1d])) by (name))</screen>
</para>
</formalpara>
<simpara>OOM kills force the system to terminate some processes due to low memory. Frequent OOM kills can hinder the functionality of the node and even the entire Kubernetes ecosystem. Containers experiencing frequent OOM kills might be consuming more memory than they should, which causes system instability.</simpara>
<simpara>Use this metric to identify containers that are experiencing frequent OOM kills and investigate why these containers are consuming an excessive amount of memory. Adjust the resource allocation if necessary and consider resizing the containers based on their memory usage. You can also review the metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights into the health and stability of your nodes.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-pulls_nodes-dashboard-using">
<title>Failure rate for image pulls in the last hour</title>
<simpara>The <emphasis role="strong">Failure rate for image pulls in the last hour</emphasis> query divides the total number of failed image pulls by the sum of successful and failed image pulls to provide a ratio of failures.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>rate(container_runtime_crio_image_pulls_failure_total[1h]) / (rate(container_runtime_crio_image_pulls_success_total[1h]) + rate(container_runtime_crio_image_pulls_failure_total[1h]))</screen>
</para>
</formalpara>
<simpara>Understanding the failure rate of image pulls is crucial for maintaining the health of the node. A high failure rate might indicate networking issues, storage problems, misconfigurations, or other issues that could disrupt pod density and the deployment of new containers.</simpara>
<simpara>If the outcome of this query is high, investigate possible causes such as network connections, the availability of remote repositories, node storage, and the accuracy of image references. You can also review the metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-memory_nodes-dashboard-using">
<title>Nodes with system reserved memory utilization &gt; 80%</title>
<simpara>The <emphasis role="strong">Nodes with system reserved memory utilization &gt; 80%</emphasis> query calculates the percentage of system reserved memory that is utilized for each node. The calculation divides the total resident set size (RSS) by the total memory capacity of the node subtracted from the allocatable memory. RSS is the portion of the system&#8217;s memory occupied by a process that is held in main memory (RAM). Nodes are flagged if their resulting value equals or exceeds an 80% threshold.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (container_memory_rss{id="/system.slice"}) / sum by (node) (kube_node_status_capacity{resource="memory"} - kube_node_status_allocatable{resource="memory"}) * 100 &gt;= 80</screen>
</para>
</formalpara>
<simpara>System reserved memory is crucial for a Kubernetes node as it is utilized to run system daemons and Kubernetes system daemons. System reserved memory utilization that exceeds 80% indicates that the system and Kubernetes daemons are consuming too much memory and can suggest node instability that could affect the performance of running pods. Excessive memory consumption can cause Out-of-Memory (OOM) killers that can terminate critical system processes to free up memory.</simpara>
<simpara>If a node is flagged by this metric, identify which system or Kubernetes processes are consuming excessive memory and take appropriate actions to mitigate the situation. These actions may include scaling back non-critical processes, optimizing program configurations to reduce memory usage, or upgrading node systems to hardware with greater memory capacity. You can also review the metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights into node performance.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-memory-kubelet_nodes-dashboard-using">
<title>Nodes with Kubelet system reserved memory utilization &gt; 50%</title>
<simpara>The <emphasis role="strong">Nodes with Kubelet system reserved memory utilization &gt; 50%</emphasis> query indicates nodes where the Kubelet&#8217;s system reserved memory utilization exceeds 50%. The query examines the memory that the Kubelet process itself is consuming on a node.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (container_memory_rss{id="/system.slice/kubelet.service"}) / sum by (node) (kube_node_status_capacity{resource="memory"} - kube_node_status_allocatable{resource="memory"}) * 100 &gt;= 50</screen>
</para>
</formalpara>
<simpara>This query helps you identify any possible memory pressure situations in your nodes that could affect the stability and efficiency of node operations. Kubelet memory utilization that consistently exceeds 50% of the system reserved memory, indicate that the system reserved settings are not configured properly and that there is a high risk of the node becoming unstable.</simpara>
<simpara>If this metric is highlighted, review your configuration policy and consider adjusting the system reserved settings or the resource limits settings for the Kubelet. Additionally, if your Kubelet memory utilization consistently exceeds half of your total reserved system memory, examine metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights for more precise diagnostics.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-memory-crio_nodes-dashboard-using">
<title>Nodes with CRI-O system reserved memory utilization &gt; 50%</title>
<simpara>The <emphasis role="strong">Nodes with CRI-O system reserved memory utilization &gt; 50%</emphasis> query calculates all nodes where the percentage of used memory reserved for the CRI-O system is greater than or equal to 50%. In this case, memory usage is defined by the resident set size (RSS), which is the portion of the CRI-O system&#8217;s memory held in RAM.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (container_memory_rss{id="/system.slice/crio.service"}) / sum by (node) (kube_node_status_capacity{resource="memory"} - kube_node_status_allocatable{resource="memory"}) * 100 &gt;= 50</screen>
</para>
</formalpara>
<simpara>This query helps you monitor the status of memory reserved for the CRI-O system on each node. High utilization could indicate a lack of available resources and potential performance issues. If the memory reserved for the CRI-O system exceeds the advised limit of 50%, it indicates that half of the system reserved memory is being used by CRI-O on a node.</simpara>
<simpara>Check memory allocation and usage and assess whether memory resources need to be shifted or increased to prevent possible node instability. You can also examine the metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-cpu">
<title>Nodes with System Reserved CPU Utilization &gt; 80%</title>
<simpara>The <emphasis role="strong">Nodes with system reserved CPU utilization &gt; 80%</emphasis> query identifies nodes where the system-reserved CPU utilization is more than 80%. The query focuses on the system-reserved capacity to calculate the rate of CPU usage in the last 5 minutes and compares that to the CPU resources available on the nodes. If the ratio exceeds 80%, the node&#8217;s result is displayed in the metric.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (rate(container_cpu_usage_seconds_total{id="/system.slice"}[5m]) * 100) / sum by (node) (kube_node_status_capacity{resource="cpu"} - kube_node_status_allocatable{resource="cpu"}) &gt;= 80</screen>
</para>
</formalpara>
<simpara>This query indicates a critical level of system-reserved CPU usage, which can lead to resource exhaustion. High system-reserved CPU usage can result in the inability of the system processes (including the Kubelet and CRI-O) to adequately manage resources on the node. This query can indicate excessive system processes or misconfigured CPU allocation.</simpara>
<simpara>Potential corrective measures include rebalancing workloads to other nodes or increasing the CPU resources allocated to the nodes. Investigate the cause of the high system CPU utilization and review the corresponding metrics in the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories for additional insights into the node&#8217;s behavior.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-cpu-kubelet_nodes-dashboard-using">
<title>Nodes with Kubelet system reserved CPU utilization &gt; 50%</title>
<simpara>The <emphasis role="strong">Nodes with Kubelet system reserved CPU utilization &gt; 50%</emphasis> query calculates the percentage of the CPU that the Kubelet system is currently using from system reserved.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (rate(container_cpu_usage_seconds_total{id="/system.slice/kubelet.service"}[5m]) * 100) / sum by (node) (kube_node_status_capacity{resource="cpu"} - kube_node_status_allocatable{resource="cpu"}) &gt;= 50</screen>
</para>
</formalpara>
<simpara>The Kubelet uses the system reserved CPU for its own operations and for running critical system services. For the node&#8217;s health, it is important to ensure that system reserve CPU usage does not exceed the 50% threshold. Exceeding this limit could indicate heavy utilization or load on the Kubelet, which affects node stability and potentially the performance of the entire Kubernetes cluster.</simpara>
<simpara>If any node is displayed in this metric, the Kubelet and the system overall are under heavy load. You can reduce overload on a particular node by balancing the load across other nodes in the cluster. Check other query metrics under the <emphasis role="strong">Outliers</emphasis>, <emphasis role="strong">Average durations</emphasis>, and <emphasis role="strong">Number of operations</emphasis> categories to gain further insights and take necessary corrective action.</simpara>
</section>
<section xml:id="nodes-dashboard-using-identify-critical-cpu-crio">
<title>Nodes with CRI-O system reserved CPU utilization &gt; 50%</title>
<simpara>The <emphasis role="strong">Nodes with CRI-O system reserved CPU utilization &gt; 50%</emphasis> query identifies nodes where the CRI-O system reserved CPU utilization has exceeded 50% in the last 5 minutes. The query monitors CPU resource consumption by CRI-O, your container runtime, on a per-node basis.</simpara>
<formalpara>
<title>Example default query</title>
<para>
<screen>sum by (node) (rate(container_cpu_usage_seconds_total{id="/system.slice/crio.service"}[5m]) * 100) / sum by (node) (kube_node_status_capacity{resource="cpu"} - kube_node_status_allocatable{resource="cpu"}) &gt;= 50</screen>
</para>
</formalpara>
<simpara>This query allows for quick identification of abnormal start times that could negatively impact pod performance. If this query returns a high value, your pod start times are slower than usual, which suggests potential issues with the kubelet, pod configuration, or resources.</simpara>
<simpara>Investigate further by checking your pod configurations and allocated resources. Make sure that they align with your system capabilities. If you still see high start times, explore metrics panels from other categories on the dashboard to determine the state of your system components.</simpara>
</section>
</section>
<section xml:id="nodes-dashboard-using-queries_nodes-dashboard-using">
<title>Customizing dashboard queries</title>
<simpara>You can customize the default queries used to build the node metrics dashboard.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Choose a metric and click <emphasis role="strong">Inspect</emphasis> to navigate into the data. This page displays the metric in detail, including an expanded visualization of the results of the query, the Prometheus query used to analyze the data, and the data subset used in the query.</simpara>
</listitem>
<listitem>
<simpara>Make any required changes to the query parameters.</simpara>
</listitem>
<listitem>
<simpara>Optional: Click <emphasis role="strong">Add query</emphasis> to run additional queries against the data.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Run query</emphasis> to rerun the query using your specified parameters.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
</book>