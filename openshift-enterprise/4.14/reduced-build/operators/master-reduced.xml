<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Operators</title>
<date>2024-02-13</date>
</info>
<chapter xml:id="operators-overview">
<title>Operators overview</title>

<simpara>Operators are among the most important components of {product-title}. Operators are the preferred method of packaging, deploying, and managing services on the control plane. They can also provide advantages to applications that users run.</simpara>
<simpara>Operators integrate with Kubernetes APIs and CLI tools such as <literal>kubectl</literal> and <literal>oc</literal> commands. They provide the means of monitoring applications, performing health checks, managing over-the-air (OTA) updates, and ensuring that applications remain in your specified state.</simpara>
<simpara>While both follow similar Operator concepts and goals, Operators in {product-title} are managed by two different systems, depending on their purpose:</simpara>
<itemizedlist>
<listitem>
<simpara>Cluster Operators, which are managed by the Cluster Version Operator (CVO), are installed by default to perform cluster functions.</simpara>
</listitem>
<listitem>
<simpara>Optional add-on Operators, which are managed by Operator Lifecycle Manager (OLM), can be made accessible for users to run in their applications.</simpara>
</listitem>
</itemizedlist>
<simpara>With Operators, you can create applications to monitor the running services in the cluster. Operators are designed specifically for your applications. Operators implement and automate the common Day 1 operations such as installation and configuration as well as Day 2 operations such as autoscaling up and down and creating backups. All these activities are in a piece of software running inside your cluster.</simpara>
<section xml:id="operators-overview-developer-tasks">
<title>For developers</title>
<simpara>As a developer, you can perform the following Operator tasks:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Install Operator SDK CLI</link>.</simpara>
</listitem>
<listitem>
<simpara>Create <link xl:href="../operators/operator_sdk/golang/osdk-golang-quickstart.xml#osdk-golang-quickstart">Go-based Operators</link>, <link xl:href="../operators/operator_sdk/ansible/osdk-ansible-quickstart.xml#osdk-ansible-quickstart">Ansible-based Operators</link>, <link xl:href="../operators/operator_sdk/java/osdk-java-quickstart.xml#osdk-java-quickstart">Java-based Operators</link>, and <link xl:href="../operators/operator_sdk/helm/osdk-helm-quickstart.xml#osdk-helm-quickstart">Helm-based Operators</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/operator_sdk/osdk-about.xml#osdk-about">Use Operator SDK to build, test, and deploy an Operator</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/user/olm-installing-operators-in-namespace.xml#olm-installing-operators-in-namespace">Install and subscribe an Operator to your namespace</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/user/olm-creating-apps-from-installed-operators.xml#olm-creating-apps-from-installed-operators">Create an application from an installed Operator through the web console</link>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../machine_management/deleting-machine.xml#machine-lifecycle-hook-deletion-uses_deleting-machine">Machine deletion lifecycle hook examples for Operator developers</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="operators-overview-administrator-tasks">
<title>For administrators</title>
<simpara>As a cluster administrator, you can perform the following Operator tasks:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs">Manage custom catalogs</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-creating-policy.xml#olm-creating-policy">Allow non-cluster administrators to install Operators</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/user/olm-installing-operators-in-namespace.xml#olm-installing-operators-in-namespace">Install an Operator from OperatorHub</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-status.xml#olm-status">View Operator status</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-managing-operatorconditions.xml#olm-managing-operatorconditions">Manage Operator conditions</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Upgrade installed Operators</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-deleting-operators-from-cluster.xml#olm-deleting-operators-from-a-cluster">Delete installed Operators</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">Configure proxy support</link>.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Use Operator Lifecycle Manager on restricted networks</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>To know all about the cluster Operators that Red Hat provides, see <link xl:href="../operators/operator-reference.xml#cluster-operators-ref">Cluster Operators reference</link>.</simpara>
</section>
<section xml:id="operators-overview-next-steps">
<title>Next steps</title>
<simpara>To understand more about Operators, see <link xl:href="../operators/understanding/olm-what-operators-are.xml#olm-what-operators-are">What are Operators?</link></simpara>
</section>
</chapter>
<chapter xml:id="_understanding_operators">
<title>Understanding Operators</title>
<section xml:id="olm-what-operators-are">
<title>What are Operators?</title>

<simpara>Conceptually, <emphasis>Operators</emphasis> take human operational knowledge and encode it into software that is more easily shared with consumers.</simpara>
<simpara>Operators are pieces of software that ease the operational complexity of running another piece of software. They act like an extension of the software vendor&#8217;s engineering team, monitoring a Kubernetes environment (such as {product-title}) and using its current state to make decisions in real time. Advanced Operators are designed to handle upgrades seamlessly, react to failures automatically, and not take shortcuts, like skipping a software backup process to save time.</simpara>
<simpara>More technically, Operators are a method of packaging, deploying, and managing a Kubernetes application.</simpara>
<simpara>A Kubernetes application is an app that is both deployed on Kubernetes and managed using the Kubernetes APIs and <literal>kubectl</literal> or <literal>oc</literal> tooling. To be able to make the most of Kubernetes, you require a set of cohesive APIs to extend in order to service and manage your apps that run on Kubernetes. Think of Operators as the runtime that manages this type of app on Kubernetes.</simpara>
<section xml:id="olm-why-use-operators_olm-what-operators-are">
<title>Why use Operators?</title>
<simpara>Operators provide:</simpara>
<itemizedlist>
<listitem>
<simpara>Repeatability of installation and upgrade.</simpara>
</listitem>
<listitem>
<simpara>Constant health checks of every system component.</simpara>
</listitem>
<listitem>
<simpara>Over-the-air (OTA) updates for OpenShift components and ISV content.</simpara>
</listitem>
<listitem>
<simpara>A place to encapsulate knowledge from field engineers and spread it to all users, not just one or two.</simpara>
</listitem>
</itemizedlist>
<variablelist>
<varlistentry>
<term>Why deploy on Kubernetes?</term>
<listitem>
<simpara>Kubernetes (and by extension, {product-title}) contains all of the primitives needed to build complex distributed systems – secret handling, load balancing, service discovery, autoscaling – that work across on-premises and cloud providers.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Why manage your app with Kubernetes APIs and <literal>kubectl</literal> tooling?</term>
<listitem>
<simpara>These APIs are feature rich, have clients for all platforms and plug into the cluster&#8217;s access control/auditing. An Operator uses the Kubernetes extension mechanism, custom resource definitions (CRDs), so your custom object, <link xl:href="https://marketplace.redhat.com/en-us/products/mongodb-enterprise-advanced-from-ibm">for example <literal>MongoDB</literal></link>, looks and acts just like the built-in, native Kubernetes objects.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>How do Operators compare with service brokers?</term>
<listitem>
<simpara>A service broker is a step towards programmatic discovery and deployment of an app. However, because it is not a long running process, it cannot execute Day 2 operations like upgrade, failover, or scaling. Customizations and parameterization of tunables are provided at install time, versus an Operator that is constantly watching the current state of your cluster. Off-cluster services are a good match for a service broker, although Operators exist for these as well.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="olm-operator-framework_olm-what-operators-are">
<title>Operator Framework</title>
<simpara>The Operator Framework is a family of tools and capabilities to deliver on the customer experience described above. It is not just about writing code; testing, delivering, and updating Operators is just as important. The Operator Framework components consist of open source tools to tackle these problems:</simpara>
<variablelist>
<varlistentry>
<term>Operator SDK</term>
<listitem>
<simpara>The Operator SDK assists Operator authors in bootstrapping, building, testing, and packaging their own Operator based on their expertise without requiring knowledge of Kubernetes API complexities.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager</term>
<listitem>
<simpara>Operator Lifecycle Manager (OLM) controls the installation, upgrade, and role-based access control (RBAC) of Operators in a cluster. It is deployed by default in {product-title} {product-version}.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Registry</term>
<listitem>
<simpara>The Operator Registry stores cluster service versions (CSVs) and custom resource definitions (CRDs) for creation in a cluster and stores Operator metadata about packages and channels. It runs in a Kubernetes or OpenShift cluster to provide this Operator catalog data to OLM.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OperatorHub</term>
<listitem>
<simpara>OperatorHub is a web console for cluster administrators to discover and select Operators to install on their cluster. It is deployed by default in {product-title}.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>These tools are designed to be composable, so you can use any that are useful to you.</simpara>
</section>
<section xml:id="olm-maturity-model_olm-what-operators-are">
<title>Operator maturity model</title>
<simpara>The level of sophistication of the management logic encapsulated within an Operator can vary. This logic is also in general highly dependent on the type of the service represented by the Operator.</simpara>
<simpara>One can however generalize the scale of the maturity of the encapsulated operations of an Operator for certain set of capabilities that most Operators can include. To this end, the following Operator maturity model defines five phases of maturity for generic Day 2 operations of an Operator:</simpara>
<figure>
<title>Operator maturity model</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/operator-maturity-model.png"/>
</imageobject>
<textobject><phrase>operator maturity model</phrase></textobject>
</mediaobject>
</figure>
<simpara>The above model also shows how these capabilities can best be developed through
the Helm, Go, and Ansible capabilities of the Operator SDK.</simpara>
</section>
</section>
<section xml:id="olm-packaging-format">
<title>Operator Framework packaging format</title>

<simpara>This guide outlines the packaging format for Operators supported by Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-bundle-format_olm-packaging-format">
<title>Bundle format</title>
<simpara>The <emphasis>bundle format</emphasis> for Operators is a packaging format introduced by the Operator Framework. To improve scalability and to better enable upstream users hosting their own catalogs, the bundle format specification simplifies the distribution of Operator metadata.</simpara>
<simpara>An Operator bundle represents a single version of an Operator. On-disk <emphasis>bundle manifests</emphasis> are containerized and shipped as a <emphasis>bundle image</emphasis>, which is a non-runnable container image that stores the Kubernetes manifests and Operator metadata. Storage and distribution of the bundle image is then managed using existing container tools like <literal>podman</literal> and <literal>docker</literal> and container registries such as Quay.</simpara>
<simpara>Operator metadata can include:</simpara>
<itemizedlist>
<listitem>
<simpara>Information that identifies the Operator, for example its name and version.</simpara>
</listitem>
<listitem>
<simpara>Additional information that drives the UI, for example its icon and some example custom resources (CRs).</simpara>
</listitem>
<listitem>
<simpara>Required and provided APIs.</simpara>
</listitem>
<listitem>
<simpara>Related images.</simpara>
</listitem>
</itemizedlist>
<simpara>When loading manifests into the Operator Registry database, the following requirements are validated:</simpara>
<itemizedlist>
<listitem>
<simpara>The bundle must have at least one channel defined in the annotations.</simpara>
</listitem>
<listitem>
<simpara>Every bundle has exactly one cluster service version (CSV).</simpara>
</listitem>
<listitem>
<simpara>If a CSV owns a custom resource definition (CRD), that CRD must exist in the bundle.</simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-bundle-format-manifests_olm-packaging-format">
<title>Manifests</title>
<simpara>Bundle manifests refer to a set of Kubernetes manifests that define the deployment and RBAC model of the Operator.</simpara>
<simpara>A bundle includes one CSV per directory and typically the CRDs that define the owned APIs of the CSV in its <literal>/manifests</literal> directory.</simpara>
<formalpara>
<title>Example bundle format layout</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">etcd
├── manifests
│   ├── etcdcluster.crd.yaml
│   └── etcdoperator.clusterserviceversion.yaml
│   └── secret.yaml
│   └── configmap.yaml
└── metadata
    └── annotations.yaml
    └── dependencies.yaml</programlisting>
</para>
</formalpara>
<bridgehead xml:id="olm-bundle-format-manifests-optional_olm-packaging-format" renderas="sect5">Additionally supported objects</bridgehead>
<simpara>The following object types can also be optionally included in the <literal>/manifests</literal> directory of a bundle:</simpara>
<itemizedlist role="small">
<title>Supported optional object types</title>
<listitem>
<simpara><literal>ClusterRole</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClusterRoleBinding</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ConfigMap</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ConsoleCLIDownload</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ConsoleLink</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ConsoleQuickStart</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ConsoleYamlSample</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PodDisruptionBudget</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PriorityClass</literal></simpara>
</listitem>
<listitem>
<simpara><literal>PrometheusRule</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Role</literal></simpara>
</listitem>
<listitem>
<simpara><literal>RoleBinding</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Secret</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Service</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceAccount</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceMonitor</literal></simpara>
</listitem>
<listitem>
<simpara><literal>VerticalPodAutoscaler</literal></simpara>
</listitem>
</itemizedlist>
<simpara>When these optional objects are included in a bundle, Operator Lifecycle Manager (OLM) can create them from the bundle and manage their lifecycle along with the CSV:</simpara>
<itemizedlist>
<title>Lifecycle for optional objects</title>
<listitem>
<simpara>When the CSV is deleted, OLM deletes the optional object.</simpara>
</listitem>
<listitem>
<simpara>When the CSV is upgraded:</simpara>
<itemizedlist>
<listitem>
<simpara>If the name of the optional object is the same, OLM updates it in place.</simpara>
</listitem>
<listitem>
<simpara>If the name of the optional object has changed between versions, OLM deletes and recreates it.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-bundle-format-annotations_olm-packaging-format">
<title>Annotations</title>
<simpara>A bundle also includes an <literal>annotations.yaml</literal> file in its <literal>/metadata</literal> directory. This file defines higher level aggregate data that helps describe the format and package information about how the bundle should be added into an index of bundles:</simpara>
<formalpara>
<title>Example <literal>annotations.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">annotations:
  operators.operatorframework.io.bundle.mediatype.v1: "registry+v1" <co xml:id="CO1-1"/>
  operators.operatorframework.io.bundle.manifests.v1: "manifests/" <co xml:id="CO1-2"/>
  operators.operatorframework.io.bundle.metadata.v1: "metadata/" <co xml:id="CO1-3"/>
  operators.operatorframework.io.bundle.package.v1: "test-operator" <co xml:id="CO1-4"/>
  operators.operatorframework.io.bundle.channels.v1: "beta,stable" <co xml:id="CO1-5"/>
  operators.operatorframework.io.bundle.channel.default.v1: "stable" <co xml:id="CO1-6"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>The media type or format of the Operator bundle. The <literal>registry+v1</literal> format means it contains a CSV and its associated Kubernetes objects.</para>
</callout>
<callout arearefs="CO1-2">
<para>The path in the image to the directory that contains the Operator manifests. This label is reserved for future use and currently defaults to <literal>manifests/</literal>. The value <literal>manifests.v1</literal> implies that the bundle contains Operator manifests.</para>
</callout>
<callout arearefs="CO1-3">
<para>The path in the image to the directory that contains metadata files about the bundle. This label is reserved for future use and currently defaults to <literal>metadata/</literal>. The value <literal>metadata.v1</literal> implies that this bundle has Operator metadata.</para>
</callout>
<callout arearefs="CO1-4">
<para>The package name of the bundle.</para>
</callout>
<callout arearefs="CO1-5">
<para>The list of channels the bundle is subscribing to when added into an Operator Registry.</para>
</callout>
<callout arearefs="CO1-6">
<para>The default channel an Operator should be subscribed to when installed from a registry.</para>
</callout>
</calloutlist>
<note>
<simpara>In case of a mismatch, the <literal>annotations.yaml</literal> file is authoritative because the on-cluster Operator Registry that relies on these annotations only has access to this file.</simpara>
</note>
</section>
<section xml:id="olm-dependencies_olm-packaging-format">
<title>Dependencies</title>
<simpara>The dependencies of an Operator are listed in a <literal>dependencies.yaml</literal> file in the <literal>metadata/</literal> folder of a bundle. This file is optional and currently only used to specify explicit Operator-version dependencies.</simpara>
<simpara>The dependency list contains a <literal>type</literal> field for each item to specify what kind of dependency this is. The following types of Operator dependencies are supported:</simpara>
<variablelist>
<varlistentry>
<term><literal>olm.package</literal></term>
<listitem>
<simpara>This type indicates a dependency for a specific Operator version. The dependency information must include the package name and the version of the package in semver format. For example, you can specify an exact version such as <literal>0.5.2</literal> or a range of versions such as <literal>&gt;0.5.1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>olm.gvk</literal></term>
<listitem>
<simpara>With this type, the author can specify a dependency with group/version/kind (GVK) information, similar to existing CRD and API-based usage in a CSV. This is a path to enable Operator authors to consolidate all dependencies, API or explicit versions, to be in the same place.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>olm.constraint</literal></term>
<listitem>
<simpara>This type declares generic constraints on arbitrary Operator properties.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In the following example, dependencies are specified for a Prometheus Operator and etcd CRDs:</simpara>
<formalpara>
<title>Example <literal>dependencies.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">dependencies:
  - type: olm.package
    value:
      packageName: prometheus
      version: "&gt;0.27.0"
  - type: olm.gvk
    value:
      group: etcd.database.coreos.com
      kind: EtcdCluster
      version: v1beta2</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-dependency-resolution.xml#olm-understanding-dependency-resolution">Operator Lifecycle Manager dependency resolution</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-about-opm_olm-packaging-format">
<title>About the opm CLI</title>
<simpara>The <literal>opm</literal> CLI tool is provided by the Operator Framework for use with the Operator bundle format. This tool allows you to create and maintain catalogs of Operators from a list of Operator bundles that are similar to software repositories. The result is a container image which can be stored in a container registry and then installed on a cluster.</simpara>
<simpara>A catalog contains a database of pointers to Operator manifest content that can be queried through an included API that is served when the container image is run. On {product-title}, Operator Lifecycle Manager (OLM) can reference the image in a catalog source, defined by a <literal>CatalogSource</literal> object, which polls the image at regular intervals to enable frequent updates to installed Operators on the cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../cli_reference/opm/cli-opm-install.xml#cli-opm-install">CLI tools</link> for steps on installing the <literal>opm</literal> CLI.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-file-based-catalogs_olm-packaging-format">
<title>File-based catalogs</title>
<simpara><emphasis>File-based catalogs</emphasis> are the latest iteration of the catalog format in Operator Lifecycle Manager (OLM). It is a plain text-based (JSON or YAML) and declarative config evolution of the earlier SQLite database format, and it is fully backwards compatible. The goal of this format is to enable Operator catalog editing, composability, and extensibility.</simpara>
<variablelist>
<varlistentry>
<term>Editing</term>
<listitem>
<simpara>With file-based catalogs, users interacting with the contents of a catalog are able to make direct changes to the format and verify that their changes are valid. Because this format is plain text JSON or YAML, catalog maintainers can easily manipulate catalog metadata by hand or with widely known and supported JSON or YAML tooling, such as the <literal>jq</literal> CLI.</simpara>
<simpara>This editability enables the following features and user-defined extensions:</simpara>
<itemizedlist>
<listitem>
<simpara>Promoting an existing bundle to a new channel</simpara>
</listitem>
<listitem>
<simpara>Changing the default channel of a package</simpara>
</listitem>
<listitem>
<simpara>Custom algorithms for adding, updating, and removing upgrade edges</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Composability</term>
<listitem>
<simpara>File-based catalogs are stored in an arbitrary directory hierarchy, which enables catalog composition. For example, consider two separate file-based catalog directories: <literal>catalogA</literal> and <literal>catalogB</literal>. A catalog maintainer can create a new combined catalog by making a new directory <literal>catalogC</literal> and copying <literal>catalogA</literal> and <literal>catalogB</literal> into it.</simpara>
<simpara>This composability enables decentralized catalogs. The format permits Operator authors to maintain Operator-specific catalogs, and it permits maintainers to trivially build a catalog composed of individual Operator catalogs. File-based catalogs can be composed by combining multiple other catalogs, by extracting subsets of one catalog, or a combination of both of these.</simpara>
<note>
<simpara>Duplicate packages and duplicate bundles within a package are not permitted. The <literal>opm validate</literal> command returns an error if any duplicates are found.</simpara>
</note>
<simpara>Because Operator authors are most familiar with their Operator, its dependencies, and its upgrade compatibility, they are able to maintain their own Operator-specific catalog and have direct control over its contents. With file-based catalogs, Operator authors own the task of building and maintaining their packages in a catalog. Composite catalog maintainers, however, only own the task of curating the packages in their catalog and publishing the catalog to users.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Extensibility</term>
<listitem>
<simpara>The file-based catalog specification is a low-level representation of a catalog. While it can be maintained directly in its low-level form, catalog maintainers can build interesting extensions on top that can be used by their own custom tooling to make any number of mutations.</simpara>
<simpara>For example, a tool could translate a high-level API, such as <literal>(mode=semver)</literal>, down to the low-level, file-based catalog format for upgrade edges. Or a catalog maintainer might need to customize all of the bundle metadata by adding a new property to bundles that meet a certain criteria.</simpara>
<simpara>While this extensibility allows for additional official tooling to be developed on top of the low-level APIs for future {product-title} releases, the major benefit is that catalog maintainers have this capability as well.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>As of {product-title} 4.11, the default Red Hat-provided Operator catalog releases in the file-based catalog format. The default Red Hat-provided Operator catalogs for {product-title} 4.6 through 4.10 released in the deprecated SQLite database format.</simpara>
<simpara>The <literal>opm</literal> subcommands, flags, and functionality related to the SQLite database format are also deprecated and will be removed in a future release. The features are still supported and must be used for catalogs that use the deprecated SQLite database format.</simpara>
<simpara>Many of the <literal>opm</literal> subcommands and flags for working with the SQLite database format, such as <literal>opm index prune</literal>, do not work with the file-based catalog format.
For more information about working with file-based catalogs, see <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs-fb">Managing custom catalogs</link> and <link xl:href="../../installing/disconnected_install/installing-mirroring-disconnected.xml#installing-mirroring-disconnected">Mirroring images for a disconnected installation using the oc-mirror plugin</link>.</simpara>
</important>
<section xml:id="olm-fb-catalogs-structure_olm-packaging-format">
<title>Directory structure</title>
<simpara>File-based catalogs can be stored and loaded from directory-based file systems. The <literal>opm</literal> CLI loads the catalog by walking the root directory and recursing into subdirectories. The CLI attempts to load every file it finds and fails if any errors occur.</simpara>
<simpara>Non-catalog files can be ignored using <literal>.indexignore</literal> files, which have the same rules for patterns and precedence as <literal>.gitignore</literal> files.</simpara>
<formalpara>
<title>Example <literal>.indexignore</literal> file</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># Ignore everything except non-object .json and .yaml files
**/*
!*.json
!*.yaml
**/objects/*.json
**/objects/*.yaml</programlisting>
</para>
</formalpara>
<simpara>Catalog maintainers have the flexibility to choose their desired layout, but it is recommended to store each package&#8217;s file-based catalog blobs in separate subdirectories. Each individual file can be either JSON or YAML; it is not necessary for every file in a catalog to use the same format.</simpara>
<formalpara>
<title>Basic recommended structure</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">catalog
├── packageA
│   └── index.yaml
├── packageB
│   ├── .indexignore
│   ├── index.yaml
│   └── objects
│       └── packageB.v0.1.0.clusterserviceversion.yaml
└── packageC
    └── index.json</programlisting>
</para>
</formalpara>
<simpara>This recommended structure has the property that each subdirectory in the directory hierarchy is a self-contained catalog, which makes catalog composition, discovery, and navigation trivial file system operations. The catalog could also be included in a parent catalog by copying it into the parent catalog&#8217;s root directory.</simpara>
</section>
<section xml:id="olm-fb-catalogs-schemas_olm-packaging-format">
<title>Schemas</title>
<simpara>File-based catalogs use a format, based on the <link xl:href="https://cuelang.org/docs/references/spec/">CUE language specification</link>, that can be extended with arbitrary schemas. The following  <literal>_Meta</literal> CUE schema defines the format that all file-based catalog blobs must adhere to:</simpara>
<formalpara>
<title><literal>_Meta</literal> schema</title>
<para>
<programlisting language="go" linenumbering="unnumbered">_Meta: {
  // schema is required and must be a non-empty string
  schema: string &amp; !=""

  // package is optional, but if it's defined, it must be a non-empty string
  package?: string &amp; !=""

  // properties is optional, but if it's defined, it must be a list of 0 or more properties
  properties?: [... #Property]
}

#Property: {
  // type is required
  type: string &amp; !=""

  // value is required, and it must not be null
  value: !=null
}</programlisting>
</para>
</formalpara>
<note>
<simpara>No CUE schemas listed in this specification should be considered exhaustive. The <literal>opm validate</literal> command has additional validations that are difficult or impossible to express concisely in CUE.</simpara>
</note>
<simpara>An Operator Lifecycle Manager (OLM) catalog currently uses three schemas (<literal>olm.package</literal>, <literal>olm.channel</literal>, and <literal>olm.bundle</literal>), which correspond to OLM&#8217;s existing package and bundle concepts.</simpara>
<simpara>Each Operator package in a catalog requires exactly one <literal>olm.package</literal> blob, at least one <literal>olm.channel</literal> blob, and one or more <literal>olm.bundle</literal> blobs.</simpara>
<note>
<simpara>All <literal>olm.*</literal> schemas are reserved for OLM-defined schemas. Custom schemas must use a unique prefix, such as a domain that you own.</simpara>
</note>
<section xml:id="olm-fb-catalogs-package-schema_olm-packaging-format">
<title>olm.package schema</title>
<simpara>The <literal>olm.package</literal> schema defines package-level metadata for an Operator. This includes its name, description, default channel, and icon.</simpara>
<example>
<title><literal>olm.package</literal> schema</title>
<programlisting language="go" linenumbering="unnumbered">#Package: {
  schema: "olm.package"

  // Package name
  name: string &amp; !=""

  // A description of the package
  description?: string

  // The package's default channel
  defaultChannel: string &amp; !=""

  // An optional icon
  icon?: {
    base64data: string
    mediatype:  string
  }
}</programlisting>
</example>
</section>
<section xml:id="olm-fb-catalogs-channel-schema_olm-packaging-format">
<title>olm.channel schema</title>
<simpara>The <literal>olm.channel</literal> schema defines a channel within a package, the bundle entries that are members of the channel, and the upgrade edges for those bundles.</simpara>
<simpara>A bundle can included as an entry in multiple <literal>olm.channel</literal> blobs, but it can have only one entry per channel.</simpara>
<simpara>It is valid for an entry&#8217;s replaces value to reference another bundle name that cannot be found in this catalog or another catalog. However, all other channel invariants must hold true, such as a channel not having multiple heads.</simpara>
<example>
<title><literal>olm.channel</literal> schema</title>
<programlisting language="go" linenumbering="unnumbered">#Channel: {
  schema: "olm.channel"
  package: string &amp; !=""
  name: string &amp; !=""
  entries: [...#ChannelEntry]
}

#ChannelEntry: {
  // name is required. It is the name of an `olm.bundle` that
  // is present in the channel.
  name: string &amp; !=""

  // replaces is optional. It is the name of bundle that is replaced
  // by this entry. It does not have to be present in the entry list.
  replaces?: string &amp; !=""

  // skips is optional. It is a list of bundle names that are skipped by
  // this entry. The skipped bundles do not have to be present in the
  // entry list.
  skips?: [...string &amp; !=""]

  // skipRange is optional. It is the semver range of bundle versions
  // that are skipped by this entry.
  skipRange?: string &amp; !=""
}</programlisting>
</example>
<warning>
<simpara>When using the <literal>skipRange</literal> field, the skipped Operator versions are pruned from the update graph and are therefore no longer installable by users with the <literal>spec.startingCSV</literal> property of <literal>Subscription</literal> objects.</simpara>
<simpara>If you want to have direct (one version increment) updates to an Operator version from multiple previous versions, and also keep those previous versions available to users for installation, always use the <literal>skipRange</literal> field along with the <literal>replaces</literal> field. Ensure that the <literal>replaces</literal> field points to the immediate previous version of the Operator version in question.</simpara>
</warning>
</section>
<section xml:id="olm-fb-catalogs-olm-bundle_olm-packaging-format">
<title>olm.bundle schema</title>
<example>
<title><literal>olm.bundle</literal> schema</title>
<programlisting language="go" linenumbering="unnumbered">#Bundle: {
  schema: "olm.bundle"
  package: string &amp; !=""
  name: string &amp; !=""
  image: string &amp; !=""
  properties: [...#Property]
  relatedImages?: [...#RelatedImage]
}

#Property: {
  // type is required
  type: string &amp; !=""

  // value is required, and it must not be null
  value: !=null
}

#RelatedImage: {
  // image is the image reference
  image: string &amp; !=""

  // name is an optional descriptive name for an image that
  // helps identify its purpose in the context of the bundle
  name?: string &amp; !=""
}</programlisting>
</example>
</section>
</section>
<section xml:id="olm-fb-catalogs-prop_olm-packaging-format">
<title>Properties</title>
<simpara>Properties are arbitrary pieces of metadata that can be attached to file-based catalog schemas. The <literal>type</literal> field is a string that effectively specifies the semantic and syntactic meaning of the <literal>value</literal> field. The value can be any arbitrary JSON or YAML.</simpara>
<simpara>OLM defines a handful of property types, again using the reserved <literal>olm.*</literal> prefix.</simpara>
<section xml:id="olm-fb-catalogs-package-prop_olm-packaging-format">
<title>olm.package property</title>
<simpara>The <literal>olm.package</literal> property defines the package name and version. This is a required property on bundles, and there must be exactly one of these properties. The <literal>packageName</literal> field must match the bundle&#8217;s first-class <literal>package</literal> field, and the <literal>version</literal> field must be a valid semantic version.</simpara>
<example>
<title><literal>olm.package</literal> property</title>
<programlisting language="go" linenumbering="unnumbered">#PropertyPackage: {
  type: "olm.package"
  value: {
    packageName: string &amp; !=""
    version: string &amp; !=""
  }
}</programlisting>
</example>
</section>
<section xml:id="olm-fb-catalogs-gvk-prop_olm-packaging-format">
<title>olm.gvk property</title>
<simpara>The <literal>olm.gvk</literal> property defines the group/version/kind (GVK) of a Kubernetes API that is provided by this bundle. This property is used by OLM to resolve a bundle with this property as a dependency for other bundles that list the same GVK as a required API. The GVK must adhere to Kubernetes GVK validations.</simpara>
<example>
<title><literal>olm.gvk</literal> property</title>
<programlisting language="go" linenumbering="unnumbered">#PropertyGVK: {
  type: "olm.gvk"
  value: {
    group: string &amp; !=""
    version: string &amp; !=""
    kind: string &amp; !=""
  }
}</programlisting>
</example>
</section>
<section xml:id="olm-fb-catalogs-package-reqd-prop_olm-packaging-format">
<title>olm.package.required</title>
<simpara>The <literal>olm.package.required</literal> property defines the package name and version range of another package that this bundle requires. For every required package property a bundle lists, OLM ensures there is an Operator installed on the cluster for the listed package and in the required version range. The <literal>versionRange</literal> field must be a valid semantic version (semver) range.</simpara>
<example>
<title><literal>olm.package.required</literal> property</title>
<programlisting language="go" linenumbering="unnumbered">#PropertyPackageRequired: {
  type: "olm.package.required"
  value: {
    packageName: string &amp; !=""
    versionRange: string &amp; !=""
  }
}</programlisting>
</example>
</section>
<section xml:id="olm-fb-catalogs-gvk-reqd-prop_olm-packaging-format">
<title>olm.gvk.required</title>
<simpara>The <literal>olm.gvk.required</literal> property defines the group/version/kind (GVK) of a Kubernetes API that this bundle requires. For every required GVK property a bundle lists, OLM ensures there is an Operator installed on the cluster that provides it. The GVK must adhere to Kubernetes GVK validations.</simpara>
<example>
<title><literal>olm.gvk.required</literal> property</title>
<programlisting language="terminal" linenumbering="unnumbered">#PropertyGVKRequired: {
  type: "olm.gvk.required"
  value: {
    group: string &amp; !=""
    version: string &amp; !=""
    kind: string &amp; !=""
  }
}</programlisting>
</example>
</section>
</section>
<section xml:id="olm-fb-catalogs-example_olm-packaging-format">
<title>Example catalog</title>
<simpara>With file-based catalogs, catalog maintainers can focus on Operator curation and compatibility. Because Operator authors have already produced Operator-specific catalogs for their Operators, catalog maintainers can build their catalog by rendering each Operator catalog into a subdirectory of the catalog&#8217;s root directory.</simpara>
<simpara>There are many possible ways to build a file-based catalog; the following steps outline a simple approach:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Maintain a single configuration file for the catalog, containing image references for each Operator in the catalog:</simpara>
<formalpara>
<title>Example catalog configuration file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">name: community-operators
repo: quay.io/community-operators/catalog
tag: latest
references:
- name: etcd-operator
  image: quay.io/etcd-operator/index@sha256:5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03
- name: prometheus-operator
  image: quay.io/prometheus-operator/index@sha256:e258d248fda94c63753607f7c4494ee0fcbe92f1a76bfdac795c9d84101eb317</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run a script that parses the configuration file and creates a new catalog from its references:</simpara>
<formalpara>
<title>Example script</title>
<para>
<programlisting language="sh" linenumbering="unnumbered">name=$(yq eval '.name' catalog.yaml)
mkdir "$name"
yq eval '.name + "/" + .references[].name' catalog.yaml | xargs mkdir
for l in $(yq e '.name as $catalog | .references[] | .image + "|" + $catalog + "/" + .name + "/index.yaml"' catalog.yaml); do
  image=$(echo $l | cut -d'|' -f1)
  file=$(echo $l | cut -d'|' -f2)
  opm render "$image" &gt; "$file"
done
opm alpha generate dockerfile "$name"
indexImage=$(yq eval '.repo + ":" + .tag' catalog.yaml)
docker build -t "$indexImage" -f "$name.Dockerfile" .
docker push "$indexImage"</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-fb-catalogs-guidelines_olm-packaging-format">
<title>Guidelines</title>
<simpara>Consider the following guidelines when maintaining file-based catalogs.</simpara>
<section xml:id="olm-fb-catalogs-immutable_olm-packaging-format">
<title>Immutable bundles</title>
<simpara>The general advice with Operator Lifecycle Manager (OLM) is that bundle images and their metadata should be treated as immutable.</simpara>
<simpara>If a broken bundle has been pushed to a catalog, you must assume that at least one of your users has upgraded to that bundle. Based on that assumption, you must release another bundle with an upgrade edge from the broken bundle to ensure users with the broken bundle installed receive an upgrade. OLM will not reinstall an installed bundle if the contents of that bundle are updated in the catalog.</simpara>
<simpara>However, there are some cases where a change in the catalog metadata is preferred:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel promotion: If you already released a bundle and later decide that you would like to add it to another channel, you can add an entry for your bundle in another <literal>olm.channel</literal> blob.</simpara>
</listitem>
<listitem>
<simpara>New upgrade edges: If you release a new <literal>1.2.z</literal> bundle version, for example <literal>1.2.4</literal>, but <literal>1.3.0</literal> is already released, you can update the catalog metadata for <literal>1.3.0</literal> to skip <literal>1.2.4</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-fb-catalogs-source-control_olm-packaging-format">
<title>Source control</title>
<simpara>Catalog metadata should be stored in source control and treated as the source of truth. Updates to catalog images should include the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Update the source-controlled catalog directory with a new commit.</simpara>
</listitem>
<listitem>
<simpara>Build and push the catalog image. Use a consistent tagging taxonomy, such as <literal>:latest</literal> or <literal>:&lt;target_cluster_version&gt;</literal>, so that users can receive updates to a catalog as they become available.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-fb-catalogs-cli">
<title>CLI usage</title>
<simpara>For instructions about creating file-based catalogs by using the <literal>opm</literal> CLI, see <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-creating-fb-catalog-image_olm-managing-custom-catalogs">Managing custom catalogs</link>.</simpara>
<simpara>For reference documentation about the <literal>opm</literal> CLI commands related to managing file-based catalogs, see <link xl:href="../../cli_reference/opm/cli-opm-ref.xml#cli-opm-ref">CLI tools</link>.</simpara>
</section>
<section xml:id="olm-fb-catalogs-automation_olm-packaging-format">
<title>Automation</title>
<simpara>Operator authors and catalog maintainers are encouraged to automate their catalog maintenance with CI/CD workflows. Catalog maintainers can further improve on this by building GitOps automation to accomplish the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Check that pull request (PR) authors are permitted to make the requested changes, for example by updating their package&#8217;s image reference.</simpara>
</listitem>
<listitem>
<simpara>Check that the catalog updates pass the <literal>opm validate</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Check that the updated bundle or catalog image references exist, the catalog images run successfully in a cluster, and Operators from that package can be successfully installed.</simpara>
</listitem>
<listitem>
<simpara>Automatically merge PRs that pass the previous checks.</simpara>
</listitem>
<listitem>
<simpara>Automatically rebuild and republish the catalog image.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-rukpak-about_olm-packaging-format">
<title>RukPak (Technology Preview)</title>
<important>
<simpara>RukPak is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>{product-title} 4.12 introduces the <emphasis>platform Operator</emphasis> type as a Technology Preview feature. The platform Operator mechanism relies on the RukPak component, also introduced in {product-title} 4.12, and its resources to manage content.</simpara>
<simpara>{product-title} 4.14 introduces Operator Lifecycle Manager (OLM) 1.0 as a Technology Preview feature, which also relies on the RukPak component.</simpara>
<simpara>RukPak is a pluggable solution for packaging and distributing cloud-native content. It supports advanced strategies for installation, updates, and policy.</simpara>
<simpara>RukPak provides a content ecosystem for installing a variety of artifacts on a Kubernetes cluster. Artifact examples include Git repositories, Helm charts, and OLM bundles. RukPak can then manage, scale, and upgrade these artifacts in a safe way to enable powerful cluster extensions.</simpara>
<simpara>At its core, RukPak is a small set of APIs and controllers. The APIs are packaged as custom resource definitions (CRDs) that express what content to install on a cluster and how to create a running deployment of the content. The controllers watch for the APIs.</simpara>
<variablelist>
<title>Common terminology</title>
<varlistentry>
<term>Bundle</term>
<listitem>
<simpara>A collection of Kubernetes manifests that define content to be deployed to a cluster</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle image</term>
<listitem>
<simpara>A container image that contains a bundle within its filesystem</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle Git repository</term>
<listitem>
<simpara>A Git repository that contains a bundle within a directory</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Provisioner</term>
<listitem>
<simpara>Controllers that install and manage content on a Kubernetes cluster</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle deployment</term>
<listitem>
<simpara>Generates deployed instances of a bundle</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-po.xml#olm-managing-po">Managing platform Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-po.xml#olm-po-techpreview_olm-managing-po">Technology Preview restrictions for platform Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/index.xml#olmv1-about">About Operator Lifecycle Manager 1.0 (Technology Preview)</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-rukpak-bundle_olm-packaging-format">
<title>Bundle</title>
<simpara>A RukPak <literal>Bundle</literal> object represents content to make available to other consumers in the cluster. Much like the contents of a container image must be pulled and unpacked in order for pod to start using them, <literal>Bundle</literal> objects are used to reference content that might need to be pulled and unpacked. In this sense, a bundle is a generalization of the image concept and can be used to represent any type of content.</simpara>
<simpara>Bundles cannot do anything on their own; they require a provisioner to unpack and make their content available in the cluster. They can be unpacked to any arbitrary storage medium, such as a <literal>tar.gz</literal> file in a directory mounted into the provisioner pods. Each <literal>Bundle</literal> object has an associated <literal>spec.provisionerClassName</literal> field that indicates the <literal>Provisioner</literal> object that watches and unpacks that particular bundle type.</simpara>
<formalpara>
<title>Example <literal>Bundle</literal> object configured to work with the plain provisioner</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core.rukpak.io/v1alpha1
kind: Bundle
metadata:
  name: my-bundle
spec:
  source:
    type: image
    image:
      ref: my-bundle@sha256:xyz123
  provisionerClassName: core-rukpak-io-plain</programlisting>
</para>
</formalpara>
<note>
<simpara>Bundles are considered immutable after they are created.</simpara>
</note>
<section xml:id="olm-rukpak-bundle-immutability_olm-packaging-format">
<title>Bundle immutability</title>
<simpara>After a <literal>Bundle</literal> object is accepted by the API server, the bundle is considered an immutable artifact by the rest of the RukPak system. This behavior enforces the notion that a bundle represents some unique, static piece of content to source onto the cluster. A user can have confidence that a particular bundle is pointing to a specific set of manifests and cannot be updated without creating a new bundle. This property is true for both standalone bundles and dynamic bundles created by an embedded <literal>BundleTemplate</literal> object.</simpara>
<simpara>Bundle immutability is enforced by the core RukPak webhook. This webhook watches <literal>Bundle</literal> object events and, for any update to a bundle, checks whether the <literal>spec</literal> field of the existing bundle is semantically equal to that in the proposed updated bundle. If they are not equal, the update is rejected by the webhook. Other <literal>Bundle</literal> object fields, such as <literal>metadata</literal> or <literal>status</literal>, are updated during the bundle&#8217;s lifecycle; it is only the <literal>spec</literal> field that is considered immutable.</simpara>
<simpara>Applying a <literal>Bundle</literal> object and then attempting to update its spec should fail. For example, the following example creates a bundle:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f -&lt;&lt;EOF
apiVersion: core.rukpak.io/v1alpha1
kind: Bundle
metadata:
  name: combo-tag-ref
spec:
  source:
    type: git
    git:
      ref:
        tag: v0.0.2
      repository: https://github.com/operator-framework/combo
  provisionerClassName: core-rukpak-io-plain
EOF</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">bundle.core.rukpak.io/combo-tag-ref created</programlisting>
</para>
</formalpara>
<simpara>Then, patching the bundle to point to a newer tag returns an error:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch bundle combo-tag-ref --type='merge' -p '{"spec":{"source":{"git":{"ref":{"tag":"v0.0.3"}}}}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error from server (bundle.spec is immutable): admission webhook "vbundles.core.rukpak.io" denied the request: bundle.spec is immutable</programlisting>
</para>
</formalpara>
<simpara>The core RukPak admission webhook rejected the patch because the spec of the bundle is immutable. The recommended method to change the content of a bundle is by creating a new <literal>Bundle</literal> object instead of updating it in-place.</simpara>
<bridgehead xml:id="olm-rukpak-bundle-immutability-considerations_olm-packaging-format" renderas="sect6">Further immutability considerations</bridgehead>
<simpara>While the <literal>spec</literal> field of the <literal>Bundle</literal> object is immutable, it is still possible for a <literal>BundleDeployment</literal> object to pivot to a newer version of bundle content without changing the underlying <literal>spec</literal> field. This unintentional pivoting could occur in the following scenario:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A user sets an image tag, a Git branch, or a Git tag in the <literal>spec.source</literal> field of the <literal>Bundle</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The image tag moves to a new digest, a user pushes changes to a Git branch, or a user deletes and re-pushes a Git tag on a different commit.</simpara>
</listitem>
<listitem>
<simpara>A user does something to cause the bundle unpack pod to be re-created, such as deleting the unpack pod.</simpara>
</listitem>
</orderedlist>
<simpara>If this scenario occurs, the new content from step 2 is unpacked as a result of step 3. The bundle deployment detects the changes and pivots to the newer version of the content.</simpara>
<simpara>This is similar to pod behavior, where one of the pod&#8217;s container images uses a tag, the tag is moved to a different digest, and then at some point in the future the existing pod is rescheduled on a different node. At that point, the node pulls the new image at the new digest and runs something different without the user explicitly asking for it.</simpara>
<simpara>To be confident that the underlying <literal>Bundle</literal> spec content does not change, use a digest-based image or a Git commit reference when creating the bundle.</simpara>
</section>
<section xml:id="olm-rukpak-plain-bundle_olm-packaging-format">
<title>Plain bundle spec</title>
<simpara>A plain bundle in RukPak is a collection of static, arbitrary, Kubernetes YAML manifests in a given directory.</simpara>
<simpara>The currently implemented plain bundle format is the <literal>plain+v0</literal> format. The name of the bundle format, <literal>plain+v0</literal>, combines the type of bundle (<literal>plain</literal>) with the current schema version (<literal>v0</literal>).</simpara>
<note>
<simpara>The <literal>plain+v0</literal> bundle format is at schema version <literal>v0</literal>, which means it is an experimental format that is subject to change.</simpara>
</note>
<simpara>For example, the following shows the file tree in a <literal>plain+v0</literal> bundle. It must have a <literal>manifests/</literal> directory containing the Kubernetes resources required to deploy an application.</simpara>
<formalpara>
<title>Example <literal>plain+v0</literal> bundle file tree</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ tree manifests

manifests
├── namespace.yaml
├── service_account.yaml
├── cluster_role.yaml
├── cluster_role_binding.yaml
└── deployment.yaml</programlisting>
</para>
</formalpara>
<simpara>The static manifests must be located in the <literal>manifests/</literal> directory with at least one resource in it for the bundle to be a valid <literal>plain+v0</literal> bundle that the provisioner can unpack. The <literal>manifests/</literal> directory must also be flat; all manifests must be at the top-level with no subdirectories.</simpara>
<important>
<simpara>Do not include any content in the <literal>manifests/</literal> directory of a plain bundle that are not static manifests. Otherwise, a failure will occur when creating content on-cluster from that bundle. Any file that would not successfully apply with the <literal>oc apply</literal> command will result in an error. Multi-object YAML or JSON files are valid, as well.</simpara>
</important>
</section>
<section xml:id="olm-rukpak-registry-bundle_olm-packaging-format">
<title>Registry bundle spec</title>
<simpara>A registry bundle, or <literal>registry+v1</literal> bundle, contains a set of static Kubernetes YAML manifests organized in the legacy Operator Lifecycle Manager (OLM) bundle format.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">Legacy OLM bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-rukpak-bd_olm-packaging-format">
<title>BundleDeployment</title>
<warning>
<simpara>A <literal>BundleDeployment</literal> object changes the state of a Kubernetes cluster by installing and removing objects. It is important to verify and trust the content that is being installed and limit access, by using RBAC, to the <literal>BundleDeployment</literal> API to only those who require those permissions.</simpara>
</warning>
<simpara>The RukPak <literal>BundleDeployment</literal> API points to a <literal>Bundle</literal> object and indicates that it should be active. This includes pivoting from older versions of an active bundle. A <literal>BundleDeployment</literal> object might also include an embedded spec for a desired bundle.</simpara>
<simpara>Much like pods generate instances of container images, a bundle deployment generates a deployed version of a bundle. A bundle deployment can be seen as a generalization of the pod concept.</simpara>
<simpara>The specifics of how a bundle deployment makes changes to a cluster based on a referenced bundle is defined by the provisioner that is configured to watch that bundle deployment.</simpara>
<formalpara>
<title>Example <literal>BundleDeployment</literal> object configured to work with the plain provisioner</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core.rukpak.io/v1alpha1
kind: BundleDeployment
metadata:
  name: my-bundle-deployment
spec:
  provisionerClassName: core-rukpak-io-plain
  template:
    metadata:
      labels:
        app: my-bundle
    spec:
      source:
        type: image
        image:
          ref: my-bundle@sha256:xyz123
      provisionerClassName: core-rukpak-io-plain</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olm-rukpak-provisioner_olm-packaging-format">
<title>About provisioners</title>
<simpara>RukPak consists of a series of controllers, known as <emphasis>provisioners</emphasis>, that install and manage content on a Kubernetes cluster. RukPak also provides two primary APIs: <literal>Bundle</literal> and <literal>BundleDeployment</literal>. These components work together to bring content onto the cluster and install it, generating resources within the cluster.</simpara>
<simpara>Two provisioners are currently implemented and bundled with RukPak: the <emphasis>plain provisioner</emphasis> that sources and unpacks <literal>plain+v0</literal> bundles, and the <emphasis>registry provisioner</emphasis> that sources and unpacks Operator Lifecycle Manager (OLM) <literal>registry+v1</literal> bundles.</simpara>
<simpara>Each provisioner is assigned a unique ID and is responsible for reconciling <literal>Bundle</literal> and <literal>BundleDeployment</literal> objects with a <literal>spec.provisionerClassName</literal> field that matches that particular ID. For example, the plain provisioner is able to unpack a given <literal>plain+v0</literal> bundle onto a cluster and then instantiate it, making the content of the bundle available in the cluster.</simpara>
<simpara>A provisioner places a watch on both <literal>Bundle</literal> and <literal>BundleDeployment</literal> resources that refer to the provisioner explicitly. For a given bundle, the provisioner unpacks the contents of the <literal>Bundle</literal> resource onto the cluster. Then, given a <literal>BundleDeployment</literal> resource referring to that bundle, the provisioner installs the bundle contents and is responsible for managing the lifecycle of those resources.</simpara>
</section>
</section>
</section>
<section xml:id="olm-common-terms">
<title>Operator Framework glossary of common terms</title>

<simpara>This topic provides a glossary of common terms related to the Operator Framework, including Operator Lifecycle Manager (OLM) and the Operator SDK.</simpara>
<section xml:id="olm-common-terms-glossary_olm-common-terms">
<title>Common Operator Framework terms</title>
<section xml:id="olm-common-terms-bundle_olm-common-terms">
<title>Bundle</title>
<simpara>In the bundle format, a <emphasis>bundle</emphasis> is a collection of an Operator CSV, manifests, and metadata. Together, they form a unique version of an Operator that can be installed onto the cluster.</simpara>
</section>
<section xml:id="olm-common-terms-bundle-image_olm-common-terms">
<title>Bundle image</title>
<simpara>In the bundle format, a <emphasis>bundle image</emphasis> is a container image that is built from Operator manifests and that contains one bundle. Bundle images are stored and distributed by Open Container Initiative (OCI) spec container registries, such as Quay.io or DockerHub.</simpara>
</section>
<section xml:id="olm-common-terms-catalogsource_olm-common-terms">
<title>Catalog source</title>
<simpara>A <emphasis>catalog source</emphasis> represents a store of metadata that OLM can query to discover and install Operators and their dependencies.</simpara>
</section>
<section xml:id="olm-common-terms-channel_olm-common-terms">
<title>Channel</title>
<simpara>A <emphasis>channel</emphasis> defines a stream of updates for an Operator and is used to roll out updates for subscribers. The head points to the latest version of that channel. For example, a <literal>stable</literal> channel would have all stable versions of an Operator arranged from the earliest to the latest.</simpara>
<simpara>An Operator can have several channels, and a subscription binding to a certain channel would only look for updates in that channel.</simpara>
</section>
<section xml:id="olm-common-terms-channel-head_olm-common-terms">
<title>Channel head</title>
<simpara>A <emphasis>channel head</emphasis> refers to the latest known update in a particular channel.</simpara>
</section>
<section xml:id="olm-common-terms-csv_olm-common-terms">
<title>Cluster service version</title>
<simpara>A <emphasis>cluster service version (CSV)</emphasis> is a YAML manifest created from Operator
metadata that assists OLM in running the Operator in a cluster. It is the
metadata that accompanies an Operator container image, used to populate user
interfaces with information such as its logo, description, and version.</simpara>
<simpara>It is also a source of technical information that is required to run the Operator, like the RBAC rules it requires and which custom resources (CRs) it manages or depends on.</simpara>
</section>
<section xml:id="olm-common-terms-dependency_olm-common-terms">
<title>Dependency</title>
<simpara>An Operator may have a <emphasis>dependency</emphasis> on another Operator being present in the cluster. For example, the Vault Operator has a dependency on the etcd Operator for its data persistence layer.</simpara>
<simpara>OLM resolves dependencies by ensuring that all specified versions of Operators and CRDs are installed on the cluster during the installation phase. This dependency is resolved by finding and installing an Operator in a catalog that satisfies the required CRD API, and is not related to packages or bundles.</simpara>
</section>
<section xml:id="olm-common-terms-index-image_olm-common-terms">
<title>Index image</title>
<simpara>In the bundle format, an <emphasis>index image</emphasis> refers to an image of a database (a database snapshot) that contains information about Operator bundles including CSVs and CRDs of all versions. This index can host a history of Operators on a cluster and be maintained by adding or removing Operators using the <literal>opm</literal> CLI tool.</simpara>
</section>
<section xml:id="olm-common-terms-installplan_olm-common-terms">
<title>Install plan</title>
<simpara>An <emphasis>install plan</emphasis> is a calculated list of resources to be created to automatically install or upgrade a CSV.</simpara>
</section>
<section xml:id="olm-common-terms-multitenancy_olm-common-terms">
<title>Multitenancy</title>
<simpara>A <emphasis>tenant</emphasis> in {product-title} is a user or group of users that share common access and privileges for a set of deployed workloads, typically represented by a namespace or project. You can use tenants to provide a level of isolation between different groups or teams.</simpara>
<simpara>When a cluster is shared by multiple users or groups, it is considered a <emphasis>multitenant</emphasis> cluster.</simpara>
</section>
<section xml:id="olm-common-terms-operatorgroup_olm-common-terms">
<title>Operator group</title>
<simpara>An <emphasis>Operator group</emphasis> configures all Operators deployed in the same namespace as the <literal>OperatorGroup</literal> object to watch for their CR in a list of namespaces or cluster-wide.</simpara>
</section>
<section xml:id="olm-common-terms-package_olm-common-terms">
<title>Package</title>
<simpara>In the bundle format, a <emphasis>package</emphasis> is a directory that encloses all released history of an Operator with each version. A released version of an Operator is described in a CSV manifest alongside the CRDs.</simpara>
</section>
<section xml:id="olm-common-terms-registry_olm-common-terms">
<title>Registry</title>
<simpara>A <emphasis>registry</emphasis> is a database that stores bundle images of Operators, each with all of its latest and historical versions in all channels.</simpara>
</section>
<section xml:id="olm-common-terms-subscription_olm-common-terms">
<title>Subscription</title>
<simpara>A <emphasis>subscription</emphasis> keeps CSVs up to date by tracking a channel in a package.</simpara>
</section>
<section xml:id="olm-common-terms-update-graph_olm-common-terms">
<title>Update graph</title>
<simpara>An <emphasis>update graph</emphasis> links versions of CSVs together, similar to the update graph of any other packaged software. Operators can be installed sequentially, or certain versions can be skipped. The update graph is expected to grow only at the head with newer versions being added.</simpara>
</section>
</section>
</section>
<section xml:id="_operator_lifecycle_manager_olm">
<title>Operator Lifecycle Manager (OLM)</title>
<section xml:id="olm-understanding-olm">
<title>Operator Lifecycle Manager concepts and resources</title>

<simpara>This guide provides an overview of the concepts that drive Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-overview_olm-understanding-olm">
<title>What is Operator Lifecycle Manager?</title>
<simpara><emphasis>Operator Lifecycle Manager</emphasis> (OLM) helps users install, update, and manage the lifecycle of Kubernetes native applications (Operators) and their associated services running across their {product-title} clusters. It is part of the <link xl:href="https://operatorframework.io/">Operator Framework</link>, an open source toolkit designed to manage Operators in an effective, automated, and scalable way.</simpara>
<figure>
<title>Operator Lifecycle Manager workflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-workflow.png"/>
</imageobject>
<textobject><phrase>olm workflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>OLM runs by default in {product-title} {product-version}, which aids
cluster administrators
in installing, upgrading, and granting access to Operators running on their cluster. The {product-title} web console provides management screens for
cluster administrators
to install Operators, as well as grant specific projects access to use the catalog of Operators available on the cluster.</simpara>
<simpara>For developers, a self-service experience allows provisioning and configuring instances of databases, monitoring, and big data services without having to be subject matter experts, because the Operator has that knowledge baked into it.</simpara>
</section>
<section xml:id="olm-resources_olm-understanding-olm">
<title>OLM resources</title>
<simpara>The following custom resource definitions (CRDs) are defined and managed by Operator Lifecycle Manager (OLM):</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CRDs managed by OLM and Catalog Operators</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="66.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Resource</entry>
<entry align="left" valign="top">Short name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterServiceVersion</literal> (CSV)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>csv</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Application metadata. For example: name, version, icon, required resources.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CatalogSource</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>catsrc</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A repository of CSVs, CRDs, and packages that define an application.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Subscription</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>sub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Keeps CSVs up to date by tracking a channel in a package.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlan</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>ip</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Calculated list of resources to be created to automatically install or upgrade a CSV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OperatorGroup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>og</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Configures all Operators deployed in the same namespace as the <literal>OperatorGroup</literal> object to watch for their custom resource (CR) in a list of namespaces or cluster-wide.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OperatorConditions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>Creates a communication channel between OLM and an Operator it manages. Operators can write to the <literal>Status.Conditions</literal> array to communicate complex states to OLM.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="olm-csv_olm-understanding-olm">
<title>Cluster service version</title>
<simpara>A <emphasis>cluster service version</emphasis> (CSV) represents a specific version of a running Operator on an {product-title} cluster. It is a YAML manifest created from Operator metadata that assists Operator Lifecycle Manager (OLM) in running the Operator in the cluster.</simpara>
<simpara>OLM requires this metadata about an Operator to ensure that it can be kept running safely on a cluster, and to provide information about how updates should be applied as new versions of the Operator are published. This is similar to packaging software for a traditional operating system; think of the packaging step for OLM as the stage at which you make your <literal>rpm</literal>, <literal>deb</literal>, or <literal>apk</literal> bundle.</simpara>
<simpara>A CSV includes the metadata that accompanies an Operator container image, used to populate user interfaces with information such as its name, version, description, labels, repository link, and logo.</simpara>
<simpara>A CSV is also a source of technical information required to run the Operator, such as which custom resources (CRs) it manages or depends on, RBAC rules, cluster requirements, and install strategies. This information tells OLM how to create required resources and set up the Operator as a deployment.</simpara>
</section>
<section xml:id="olm-catalogsource_olm-understanding-olm">
<title>Catalog source</title>
<simpara>A <emphasis>catalog source</emphasis> represents a store of metadata, typically by referencing an <emphasis>index image</emphasis> stored in a container registry. Operator Lifecycle Manager (OLM) queries catalog sources to discover and install Operators and their dependencies. OperatorHub in the {product-title} web console also displays the Operators provided by catalog sources.</simpara>
<tip>
<simpara>Cluster administrators can view the full list of Operators provided by an enabled catalog source on a cluster by using the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page in the web console.</simpara>
</tip>
<simpara>The <literal>spec</literal> of a <literal>CatalogSource</literal> object indicates how to construct a pod or how to communicate with a service that serves the Operator Registry gRPC API.</simpara>
<example>
<title>Example <literal>CatalogSource</literal> object</title>
<programlisting language="yaml" linenumbering="unnumbered">﻿apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  generation: 1
  name: example-catalog <co xml:id="CO2-1"/>
  namespace: openshift-marketplace <co xml:id="CO2-2"/>
  annotations:
    olm.catalogImageTemplate: <co xml:id="CO2-3"/>
      "quay.io/example-org/example-catalog:v{kube_major_version}.{kube_minor_version}.{kube_patch_version}"
spec:
  displayName: Example Catalog <co xml:id="CO2-4"/>
  image: quay.io/example-org/example-catalog:v1 <co xml:id="CO2-5"/>
  priority: -400 <co xml:id="CO2-6"/>
  publisher: Example Org
  sourceType: grpc <co xml:id="CO2-7"/>
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO2-8"/>
    nodeSelector: <co xml:id="CO2-9"/>
      custom_label: &lt;label&gt;
    priorityClassName: system-cluster-critical <co xml:id="CO2-10"/>
    tolerations: <co xml:id="CO2-11"/>
      - key: "key1"
        operator: "Equal"
        value: "value1"
        effect: "NoSchedule"
  updateStrategy:
    registryPoll: <co xml:id="CO2-12"/>
      interval: 30m0s
status:
  connectionState:
    address: example-catalog.openshift-marketplace.svc:50051
    lastConnect: 2021-08-26T18:14:31Z
    lastObservedState: READY <co xml:id="CO2-13"/>
  latestImageRegistryPoll: 2021-08-26T18:46:25Z <co xml:id="CO2-14"/>
  registryService: <co xml:id="CO2-15"/>
    createdAt: 2021-08-26T16:16:37Z
    port: 50051
    protocol: grpc
    serviceName: example-catalog
    serviceNamespace: openshift-marketplace</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Name for the <literal>CatalogSource</literal> object. This value is also used as part of the name for the related pod that is created in the requested namespace.</para>
</callout>
<callout arearefs="CO2-2">
<para>Namespace to create the catalog in. To make the catalog available cluster-wide in all namespaces, set this value to <literal>openshift-marketplace</literal>. The default Red Hat-provided catalog sources also use the <literal>openshift-marketplace</literal> namespace. Otherwise, set the value to a specific namespace to make the Operator only available in that namespace.</para>
</callout>
<callout arearefs="CO2-3">
<para>Optional: To avoid cluster upgrades potentially leaving Operator installations in an unsupported state or without a continued update path, you can enable automatically changing your Operator catalog&#8217;s index image version as part of cluster upgrades.</para>
<simpara>Set the <literal>olm.catalogImageTemplate</literal> annotation to your index image name and use one or more of the Kubernetes cluster version variables as shown when constructing the template for the image tag. The annotation overwrites the <literal>spec.image</literal> field at run time. See the "Image template for custom catalog sources" section for more details.</simpara>
</callout>
<callout arearefs="CO2-4">
<para>Display name for the catalog in the web console and CLI.</para>
</callout>
<callout arearefs="CO2-5">
<para>Index image for the catalog. Optionally, can be omitted when using the <literal>olm.catalogImageTemplate</literal> annotation, which sets the pull spec at run time.</para>
</callout>
<callout arearefs="CO2-6">
<para>Weight for the catalog source. OLM uses the weight for prioritization during dependency resolution. A higher weight indicates the catalog is preferred over lower-weighted catalogs.</para>
</callout>
<callout arearefs="CO2-7">
<para>Source types include the following:</para>
<itemizedlist>
<listitem>
<simpara><literal>grpc</literal> with an <literal>image</literal> reference: OLM pulls the image and runs the pod, which is expected to serve a compliant API.</simpara>
</listitem>
<listitem>
<simpara><literal>grpc</literal> with an <literal>address</literal> field: OLM attempts to contact the gRPC API at the given address. This should not be used in most cases.</simpara>
</listitem>
<listitem>
<simpara><literal>configmap</literal>: OLM parses config map data and runs a pod that can serve the gRPC API over it.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO2-8">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
<callout arearefs="CO2-9">
<para>Optional: For <literal>grpc</literal> type catalog sources, overrides the default node selector for the pod serving the content in <literal>spec.image</literal>, if defined.</para>
</callout>
<callout arearefs="CO2-10">
<para>Optional: For <literal>grpc</literal> type catalog sources, overrides the default priority class name for the pod serving the content in <literal>spec.image</literal>, if defined. Kubernetes provides <literal>system-cluster-critical</literal> and <literal>system-node-critical</literal> priority classes by default. Setting the field to empty (<literal>""</literal>) assigns the pod the default priority. Other priority classes can be defined manually.</para>
</callout>
<callout arearefs="CO2-11">
<para>Optional: For <literal>grpc</literal> type catalog sources, overrides the default tolerations for the pod serving the content in <literal>spec.image</literal>, if defined.</para>
</callout>
<callout arearefs="CO2-12">
<para>Automatically check for new versions at a given interval to stay up-to-date.</para>
</callout>
<callout arearefs="CO2-13">
<para>Last observed state of the catalog connection. For example:</para>
<itemizedlist>
<listitem>
<simpara><literal>READY</literal>: A connection is successfully established.</simpara>
</listitem>
<listitem>
<simpara><literal>CONNECTING</literal>: A connection is attempting to establish.</simpara>
</listitem>
<listitem>
<simpara><literal>TRANSIENT_FAILURE</literal>: A temporary problem has occurred while attempting to establish a connection, such as a timeout. The state will eventually switch back to <literal>CONNECTING</literal> and try again.</simpara>
</listitem>
</itemizedlist>
<simpara>See <link xl:href="https://grpc.github.io/grpc/core/md_doc_connectivity-semantics-and-api.html">States of Connectivity</link> in the gRPC documentation for more details.</simpara>
</callout>
<callout arearefs="CO2-14">
<para>Latest time the container registry storing the catalog image was polled to ensure the image is up-to-date.</para>
</callout>
<callout arearefs="CO2-15">
<para>Status information for the catalog&#8217;s Operator Registry service.</para>
</callout>
</calloutlist>
</example>
<simpara>Referencing the <literal>name</literal> of a <literal>CatalogSource</literal> object in a subscription instructs OLM where to search to find a requested Operator:</simpara>
<example>
<title>Example <literal>Subscription</literal> object referencing a catalog source</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: example-operator
  namespace: example-namespace
spec:
  channel: stable
  name: example-operator
  source: example-catalog
  sourceNamespace: openshift-marketplace</programlisting>
</example>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-understanding-operatorhub.xml#olm-understanding-operatorhub">Understanding OperatorHub</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs">Red Hat-provided Operator catalogs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-managing-custom-catalogs.xml#olm-creating-catalog-from-index_olm-managing-custom-catalogs">Adding a catalog source to a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-understanding-dependency-resolution.xml#olm-dependency-catalog-priority_olm-understanding-dependency-resolution">Catalog priority</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-status.xml#olm-cs-status-cli_olm-status">Viewing Operator catalog source status by using the CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-cs-podsched.xml#olm-cs-podsched">Catalog source pod scheduling</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-catalogsource-image-template_olm-understanding-olm">
<title>Image template for custom catalog sources</title>
<simpara>Operator compatibility with the underlying cluster can be expressed by a catalog source in various ways. One way, which is used for the default Red Hat-provided catalog sources, is to identify image tags for index images that are specifically created for a particular platform release, for example {product-title} {product-version}.</simpara>
<simpara>During a cluster upgrade, the index image tag for the default Red Hat-provided catalog sources are updated automatically by the Cluster Version Operator (CVO) so that Operator Lifecycle Manager (OLM) pulls the updated version of the catalog. For example during an upgrade from {product-title} 4.14 to 4.15, the <literal>spec.image</literal> field in the <literal>CatalogSource</literal> object for the <literal>redhat-operators</literal> catalog is updated from:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">registry.redhat.io/redhat/redhat-operator-index:v4.13</programlisting>
<simpara>to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">registry.redhat.io/redhat/redhat-operator-index:v4.15</programlisting>
<simpara>However, the CVO does not automatically update image tags for custom catalogs. To ensure users are left with a compatible and supported Operator installation after a cluster upgrade, custom catalogs should also be kept updated to reference an updated index image.</simpara>
<simpara>Starting in {product-title} 4.9, cluster administrators can add the <literal>olm.catalogImageTemplate</literal> annotation in the <literal>CatalogSource</literal> object for custom catalogs to an image reference that includes a template. The following Kubernetes version variables are supported for use in the template:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>kube_major_version</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube_minor_version</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube_patch_version</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>You must specify the Kubernetes cluster version and not an {product-title} cluster version, as the latter is not currently available for templating.</simpara>
</note>
<simpara>Provided that you have created and pushed an index image with a tag specifying the updated Kubernetes version, setting this annotation enables the index image versions in custom catalogs to be automatically changed after a cluster upgrade. The annotation value is used to set or update the image reference in the <literal>spec.image</literal> field of the <literal>CatalogSource</literal> object. This helps avoid cluster upgrades leaving Operator installations in unsupported states or without a continued update path.</simpara>
<important>
<simpara>You must ensure that the index image with the updated tag, in whichever registry it is stored in, is accessible by the cluster at the time of the cluster upgrade.</simpara>
</important>
<example>
<title>Example catalog source with an image template</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  generation: 1
  name: example-catalog
  namespace: openshift-marketplace
  annotations:
    olm.catalogImageTemplate:
      "quay.io/example-org/example-catalog:v{kube_major_version}.{kube_minor_version}"
spec:
  displayName: Example Catalog
  image: quay.io/example-org/example-catalog:v1.28
  priority: -400
  publisher: Example Org</programlisting>
</example>
<note>
<simpara>If the <literal>spec.image</literal> field and the <literal>olm.catalogImageTemplate</literal> annotation are both set, the <literal>spec.image</literal> field is overwritten by the resolved value from the annotation. If the annotation does not resolve to a usable pull spec, the catalog source falls back to the set <literal>spec.image</literal> value.</simpara>
<simpara>If the <literal>spec.image</literal> field is not set and the annotation does not resolve to a usable pull spec, OLM stops reconciliation of the catalog source and sets it into a human-readable error condition.</simpara>
</note>
<simpara>For an {product-title} {product-version} cluster, which uses Kubernetes 1.28, the <literal>olm.catalogImageTemplate</literal> annotation in the preceding example resolves to the following image reference:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">quay.io/example-org/example-catalog:v1.28</programlisting>
<simpara>For future releases of {product-title}, you can create updated index images for your custom catalogs that target the later Kubernetes version that is used by the later {product-title} version. With the <literal>olm.catalogImageTemplate</literal> annotation set before the upgrade, upgrading the cluster to the later {product-title} version would then automatically update the catalog&#8217;s index image as well.</simpara>
</section>
<section xml:id="olm-cs-health_olm-understanding-olm">
<title>Catalog health requirements</title>
<simpara>Operator catalogs on a cluster are interchangeable from the perspective of installation resolution; a <literal>Subscription</literal> object might reference a specific catalog, but dependencies are resolved using all catalogs on the cluster.</simpara>
<simpara>For example, if Catalog A is unhealthy, a subscription referencing Catalog A could resolve a dependency in Catalog B, which the cluster administrator might not have been expecting, because B normally had a lower catalog priority than A.</simpara>
<simpara>As a result, OLM requires that all catalogs with a given global namespace (for example, the default <literal>openshift-marketplace</literal> namespace or a custom global namespace) are healthy. When a catalog is unhealthy, all Operator installation or update operations within its shared global namespace will fail with a <literal>CatalogSourcesUnhealthy</literal> condition. If these operations were permitted in an unhealthy state, OLM might make resolution and installation decisions that were unexpected to the cluster administrator.</simpara>
<simpara>As a cluster administrator, if you observe an unhealthy catalog and want to consider the catalog as invalid and resume Operator installations, see the "Removing custom catalogs" or "Disabling the default OperatorHub catalog sources" sections for information about removing the unhealthy catalog.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-managing-custom-catalogs.xml#olm-removing-catalogs_olm-managing-custom-catalogs">Removing custom catalogs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-managing-custom-catalogs.xml#olm-restricted-networks-operatorhub_olm-managing-custom-catalogs">Disabling the default OperatorHub catalog sources</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-subscription_olm-understanding-olm">
<title>Subscription</title>
<simpara>A <emphasis>subscription</emphasis>, defined by a <literal>Subscription</literal> object, represents an intention to install an Operator. It is the custom resource that relates an Operator to a catalog source.</simpara>
<simpara>Subscriptions describe which channel of an Operator package to subscribe to, and whether to perform updates automatically or manually. If set to automatic, the subscription ensures Operator Lifecycle Manager (OLM) manages and upgrades the Operator to ensure that the latest version is always running in the cluster.</simpara>
<formalpara>
<title>Example <literal>Subscription</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: example-operator
  namespace: example-namespace
spec:
  channel: stable
  name: example-operator
  source: example-catalog
  sourceNamespace: openshift-marketplace</programlisting>
</para>
</formalpara>
<simpara>This <literal>Subscription</literal> object defines the name and namespace of the Operator, as well as the catalog from which the Operator data can be found. The channel, such as <literal>alpha</literal>, <literal>beta</literal>, or <literal>stable</literal>, helps determine which Operator stream should be installed from the catalog source.</simpara>
<simpara>The names of channels in a subscription can differ between Operators, but the naming scheme should follow a common convention within a given Operator. For example, channel names might follow a minor release update stream for the application provided by the Operator (<literal>1.2</literal>, <literal>1.3</literal>) or a release frequency (<literal>stable</literal>, <literal>fast</literal>).</simpara>
<simpara>In addition to being easily visible from the {product-title} web console, it is possible to identify when there is a newer version of an Operator available by inspecting the status of the related subscription. The value associated with the <literal>currentCSV</literal> field is the newest version that is known to OLM, and <literal>installedCSV</literal> is the version that is installed on the cluster.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Multitenancy and Operator colocation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-status.xml#olm-status-viewing-cli_olm-status">Viewing Operator subscription status by using the CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installplan_olm-understanding-olm">
<title>Install plan</title>
<simpara>An <emphasis>install plan</emphasis>, defined by an <literal>InstallPlan</literal> object, describes a set of resources that Operator Lifecycle Manager (OLM) creates to install or upgrade to a specific version of an Operator. The version is defined by a cluster service version (CSV).</simpara>
<simpara>To install an Operator, a cluster administrator, or a user who has been granted Operator installation permissions, must first create a <literal>Subscription</literal> object. A subscription represents the intent to subscribe to a stream of available versions of an Operator from a catalog source. The subscription then creates an <literal>InstallPlan</literal> object to facilitate the installation of the resources for the Operator.</simpara>
<simpara>The install plan must then be approved according to one of the following approval strategies:</simpara>
<itemizedlist>
<listitem>
<simpara>If the subscription&#8217;s <literal>spec.installPlanApproval</literal> field is set to <literal>Automatic</literal>, the install plan is approved automatically.</simpara>
</listitem>
<listitem>
<simpara>If the subscription&#8217;s <literal>spec.installPlanApproval</literal> field is set to <literal>Manual</literal>, the install plan must be manually approved by a cluster administrator or user with proper permissions.</simpara>
</listitem>
</itemizedlist>
<simpara>After the install plan is approved, OLM creates the specified resources and installs the Operator in the namespace that is specified by the subscription.</simpara>
<example>
<title>Example <literal>InstallPlan</literal> object</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: InstallPlan
metadata:
  name: install-abcde
  namespace: operators
spec:
  approval: Automatic
  approved: true
  clusterServiceVersionNames:
    - my-operator.v1.0.1
  generation: 1
status:
  ...
  catalogSources: []
  conditions:
    - lastTransitionTime: '2021-01-01T20:17:27Z'
      lastUpdateTime: '2021-01-01T20:17:27Z'
      status: 'True'
      type: Installed
  phase: Complete
  plan:
    - resolving: my-operator.v1.0.1
      resource:
        group: operators.coreos.com
        kind: ClusterServiceVersion
        manifest: &gt;-
        ...
        name: my-operator.v1.0.1
        sourceName: redhat-operators
        sourceNamespace: openshift-marketplace
        version: v1alpha1
      status: Created
    - resolving: my-operator.v1.0.1
      resource:
        group: apiextensions.k8s.io
        kind: CustomResourceDefinition
        manifest: &gt;-
        ...
        name: webservers.web.servers.org
        sourceName: redhat-operators
        sourceNamespace: openshift-marketplace
        version: v1beta1
      status: Created
    - resolving: my-operator.v1.0.1
      resource:
        group: ''
        kind: ServiceAccount
        manifest: &gt;-
        ...
        name: my-operator
        sourceName: redhat-operators
        sourceNamespace: openshift-marketplace
        version: v1
      status: Created
    - resolving: my-operator.v1.0.1
      resource:
        group: rbac.authorization.k8s.io
        kind: Role
        manifest: &gt;-
        ...
        name: my-operator.v1.0.1-my-operator-6d7cbc6f57
        sourceName: redhat-operators
        sourceNamespace: openshift-marketplace
        version: v1
      status: Created
    - resolving: my-operator.v1.0.1
      resource:
        group: rbac.authorization.k8s.io
        kind: RoleBinding
        manifest: &gt;-
        ...
        name: my-operator.v1.0.1-my-operator-6d7cbc6f57
        sourceName: redhat-operators
        sourceNamespace: openshift-marketplace
        version: v1
      status: Created
      ...</programlisting>
</example>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Multitenancy and Operator colocation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-creating-policy.xml#olm-creating-policy">Allowing non-cluster administrators to install Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-operatorgroups-about_olm-understanding-olm">
<title>Operator groups</title>
<simpara>An <emphasis>Operator group</emphasis>, defined by the <literal>OperatorGroup</literal> resource, provides multitenant configuration to OLM-installed Operators. An Operator group selects target namespaces in which to generate required RBAC access for its member Operators.</simpara>
<simpara>The set of target namespaces is provided by a comma-delimited string stored in the <literal>olm.targetNamespaces</literal> annotation of a cluster service version (CSV). This annotation is applied to the CSV instances of member Operators and is projected into their deployments.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-understanding-operatorgroups">Operator groups</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-about-operatorconditions_olm-understanding-olm">
<title>Operator conditions</title>
<simpara>As part of its role in managing the lifecycle of an Operator, Operator Lifecycle Manager (OLM) infers the state of an Operator from the state of Kubernetes resources that define the Operator. While this approach provides some level of assurance that an Operator is in a given state, there are many instances where an Operator might need to communicate information to OLM that could not be inferred otherwise. This information can then be used by OLM to better manage the lifecycle of the Operator.</simpara>
<simpara>OLM provides a custom resource definition (CRD) called <literal>OperatorCondition</literal> that allows Operators to communicate conditions to OLM. There are a set of supported conditions that influence management of the Operator by OLM when present in the <literal>Spec.Conditions</literal> array of an <literal>OperatorCondition</literal> resource.</simpara>
<note>
<simpara>By default, the <literal>Spec.Conditions</literal> array is not present in an <literal>OperatorCondition</literal> object until it is either added by a user or as a result of custom Operator logic.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-operatorconditions.xml#olm-operatorconditions">Operator conditions</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="olm-arch">
<title>Operator Lifecycle Manager architecture</title>

<simpara>This guide outlines the component architecture of Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-architecture_olm-arch">
<title>Component responsibilities</title>
<simpara>Operator Lifecycle Manager (OLM) is composed of two Operators: the OLM Operator and the Catalog Operator.</simpara>
<simpara>Each of these Operators is responsible for managing the custom resource definitions (CRDs) that are the basis for the OLM framework:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CRDs managed by OLM and Catalog Operators</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="8.3333*"/>
<colspec colname="col_3" colwidth="8.3333*"/>
<colspec colname="col_4" colwidth="66.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Resource</entry>
<entry align="left" valign="top">Short name</entry>
<entry align="left" valign="top">Owner</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterServiceVersion</literal> (CSV)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>csv</literal></simpara></entry>
<entry align="left" valign="top"><simpara>OLM</simpara></entry>
<entry align="left" valign="top"><simpara>Application metadata: name, version, icon, required resources, installation, and so on.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlan</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>ip</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>Calculated list of resources to be created to automatically install or upgrade a CSV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CatalogSource</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>catsrc</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>A repository of CSVs, CRDs, and packages that define an application.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Subscription</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>sub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>Keeps CSVs up to date by tracking a channel in a package.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OperatorGroup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>og</literal></simpara></entry>
<entry align="left" valign="top"><simpara>OLM</simpara></entry>
<entry align="left" valign="top"><simpara>Configures all Operators deployed in the same namespace as the <literal>OperatorGroup</literal> object to watch for their custom resource (CR) in a list of namespaces or cluster-wide.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Each of these Operators is also responsible for creating the following resources:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Resources created by OLM and Catalog Operators</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Resource</entry>
<entry align="left" valign="top">Owner</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Deployments</literal></simpara></entry>
<entry align="left" valign="middle" morerows="3"><simpara>OLM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ServiceAccounts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>(Cluster)Roles</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>(Cluster)RoleBindings</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CustomResourceDefinitions</literal> (CRDs)</simpara></entry>
<entry align="left" valign="middle" morerows="1"><simpara>Catalog</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterServiceVersions</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="olm-arch-olm-operator_olm-arch">
<title>OLM Operator</title>
<simpara>The OLM Operator is responsible for deploying applications defined by CSV resources after the required resources specified in the CSV are present in the cluster.</simpara>
<simpara>The OLM Operator is not concerned with the creation of the required resources; you can choose to manually create these resources using the CLI or using the Catalog Operator. This separation of concern allows users incremental buy-in in terms of how much of the OLM framework they choose to leverage for their application.</simpara>
<simpara>The OLM Operator uses the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Watch for cluster service versions (CSVs) in a namespace and check that requirements are met.</simpara>
</listitem>
<listitem>
<simpara>If requirements are met, run the install strategy for the CSV.</simpara>
<note>
<simpara>A CSV must be an active member of an Operator group for the install strategy to run.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-arch-catalog-operator_olm-arch">
<title>Catalog Operator</title>
<simpara>The Catalog Operator is responsible for resolving and installing cluster service versions (CSVs) and the required resources they specify. It is also responsible for watching catalog sources for updates to packages in channels and upgrading them, automatically if desired, to the latest available versions.</simpara>
<simpara>To track a package in a channel, you can create a <literal>Subscription</literal> object configuring the desired package, channel, and the <literal>CatalogSource</literal> object you want to use for pulling updates. When updates are found, an appropriate <literal>InstallPlan</literal> object is written into the namespace on behalf of the user.</simpara>
<simpara>The Catalog Operator uses the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Connect to each catalog source in the cluster.</simpara>
</listitem>
<listitem>
<simpara>Watch for unresolved install plans created by a user, and if found:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the CSV matching the name requested and add the CSV as a resolved resource.</simpara>
</listitem>
<listitem>
<simpara>For each managed or required CRD, add the CRD as a resolved resource.</simpara>
</listitem>
<listitem>
<simpara>For each required CRD, find the CSV that manages it.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Watch for resolved install plans and create all of the discovered resources for it, if approved by a user or automatically.</simpara>
</listitem>
<listitem>
<simpara>Watch for catalog sources and subscriptions and create install plans based on them.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-arch-catalog-registry_olm-arch">
<title>Catalog Registry</title>
<simpara>The Catalog Registry stores CSVs and CRDs for creation in a cluster and stores metadata about packages and channels.</simpara>
<simpara>A <emphasis>package manifest</emphasis> is an entry in the Catalog Registry that associates a package identity with sets of CSVs. Within a package, channels point to a particular CSV. Because CSVs explicitly reference the CSV that they replace, a package manifest provides the Catalog Operator with all of the information that is required to update a CSV to the latest version in a channel, stepping through each intermediate version.</simpara>
</section>
</section>
<section xml:id="olm-workflow">
<title>Operator Lifecycle Manager workflow</title>

<simpara>This guide outlines the workflow of Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-upgrades_olm-workflow">
<title>Operator installation and upgrade workflow in OLM</title>
<simpara>In the Operator Lifecycle Manager (OLM) ecosystem, the following resources are used to resolve Operator installations and upgrades:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ClusterServiceVersion</literal> (CSV)</simpara>
</listitem>
<listitem>
<simpara><literal>CatalogSource</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Subscription</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Operator metadata, defined in CSVs, can be stored in a collection called a catalog source. OLM uses catalog sources, which use the <link xl:href="https://github.com/operator-framework/operator-registry">Operator Registry API</link>, to query for available Operators as well as upgrades for installed Operators.</simpara>
<figure>
<title>Catalog source overview</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-catalogsource.png"/>
</imageobject>
<textobject><phrase>olm catalogsource</phrase></textobject>
</mediaobject>
</figure>
<simpara>Within a catalog source, Operators are organized into <emphasis>packages</emphasis> and streams of updates called <emphasis>channels</emphasis>, which should be a familiar update pattern from {product-title} or other software on a continuous release cycle like web browsers.</simpara>
<figure>
<title>Packages and channels in a Catalog source</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-channels.png"/>
</imageobject>
<textobject><phrase>olm channels</phrase></textobject>
</mediaobject>
</figure>
<simpara>A user indicates a particular package and channel in a particular catalog source in a <emphasis>subscription</emphasis>, for example an <literal>etcd</literal> package and its <literal>alpha</literal> channel. If a subscription is made to a package that has not yet been installed in the namespace, the latest Operator for that package is installed.</simpara>
<note>
<simpara>OLM deliberately avoids version comparisons, so the "latest" or "newest" Operator available from a given <emphasis>catalog</emphasis> &#8594; <emphasis>channel</emphasis> &#8594; <emphasis>package</emphasis> path does not necessarily need to be the highest version number. It should be thought of more as the <emphasis>head</emphasis> reference of a channel, similar to a Git repository.</simpara>
</note>
<simpara>Each CSV has a <literal>replaces</literal> parameter that indicates which Operator it replaces. This builds a graph of CSVs that can be queried by OLM, and updates can be shared between channels. Channels can be thought of as entry points into the graph of updates:</simpara>
<figure>
<title>OLM graph of available channel updates</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-replaces.png"/>
</imageobject>
<textobject><phrase>olm replaces</phrase></textobject>
</mediaobject>
</figure>
<formalpara>
<title>Example channels in a package</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">packageName: example
channels:
- name: alpha
  currentCSV: example.v0.1.2
- name: beta
  currentCSV: example.v0.1.3
defaultChannel: alpha</programlisting>
</para>
</formalpara>
<simpara>For OLM to successfully query for updates, given a catalog source, package, channel, and CSV, a catalog must be able to return, unambiguously and deterministically, a single CSV that <literal>replaces</literal> the input CSV.</simpara>
<section xml:id="olm-upgrades-example-upgrade-path_olm-workflow">
<title>Example upgrade path</title>
<simpara>For an example upgrade scenario, consider an installed Operator corresponding to CSV version <literal>0.1.1</literal>. OLM queries the catalog source and detects an upgrade in the subscribed channel with new CSV version <literal>0.1.3</literal> that replaces an older but not-installed CSV version <literal>0.1.2</literal>, which in turn replaces the older and installed CSV version <literal>0.1.1</literal>.</simpara>
<simpara>OLM walks back from the channel head to previous versions via the <literal>replaces</literal> field specified in the CSVs to determine the upgrade path <literal>0.1.3</literal> &#8594; <literal>0.1.2</literal> &#8594; <literal>0.1.1</literal>; the direction of the arrow indicates that the former replaces the latter. OLM upgrades the Operator one version at the time until it reaches the channel head.</simpara>
<simpara>For this given scenario, OLM installs Operator version <literal>0.1.2</literal> to replace the existing Operator version <literal>0.1.1</literal>. Then, it installs Operator version <literal>0.1.3</literal> to replace the previously installed Operator version <literal>0.1.2</literal>. At this point, the installed operator version <literal>0.1.3</literal> matches the channel head and the upgrade is completed.</simpara>
</section>
<section xml:id="olm-upgrades-skipping_olm-workflow">
<title>Skipping upgrades</title>
<simpara>The basic path for upgrades in OLM is:</simpara>
<itemizedlist>
<listitem>
<simpara>A catalog source is updated with one or more updates to an Operator.</simpara>
</listitem>
<listitem>
<simpara>OLM traverses every version of the Operator until reaching the latest version the catalog source contains.</simpara>
</listitem>
</itemizedlist>
<simpara>However, sometimes this is not a safe operation to perform. There will be cases where a published version of an Operator should never be installed on a cluster if it has not already, for example because a version introduces a serious vulnerability.</simpara>
<simpara>In those cases, OLM must consider two cluster states and provide an update graph that supports both:</simpara>
<itemizedlist>
<listitem>
<simpara>The "bad" intermediate Operator has been seen by the cluster and installed.</simpara>
</listitem>
<listitem>
<simpara>The "bad" intermediate Operator has not yet been installed onto the cluster.</simpara>
</listitem>
</itemizedlist>
<simpara>By shipping a new catalog and adding a <emphasis>skipped</emphasis> release, OLM is ensured that it can always get a single unique update regardless of the cluster state and whether it has seen the bad update yet.</simpara>
<formalpara>
<title>Example CSV with skipped release</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  name: etcdoperator.v0.9.2
  namespace: placeholder
  annotations:
spec:
    displayName: etcd
    description: Etcd Operator
    replaces: etcdoperator.v0.9.0
    skips:
    - etcdoperator.v0.9.1</programlisting>
</para>
</formalpara>
<simpara>Consider the following example of <emphasis role="strong">Old CatalogSource</emphasis> and <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
<figure>
<title>Skipping updates</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-skipping-updates.png"/>
</imageobject>
<textobject><phrase>olm skipping updates</phrase></textobject>
</mediaobject>
</figure>
<simpara>This graph maintains that:</simpara>
<itemizedlist>
<listitem>
<simpara>Any Operator found in <emphasis role="strong">Old CatalogSource</emphasis> has a single replacement in <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Any Operator found in <emphasis role="strong">New CatalogSource</emphasis> has a single replacement in <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If the bad update has not yet been installed, it will never be.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-upgrades-replacing-multiple_olm-workflow">
<title>Replacing multiple Operators</title>
<simpara>Creating <emphasis role="strong">New CatalogSource</emphasis> as described requires publishing CSVs that <literal>replace</literal> one Operator, but can <literal>skip</literal> several. This can be accomplished using the <literal>skipRange</literal> annotation:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">olm.skipRange: &lt;semver_range&gt;</programlisting>
<simpara>where <literal>&lt;semver_range&gt;</literal> has the version range format supported by the <link xl:href="https://github.com/blang/semver#ranges">semver library</link>.</simpara>
<simpara>When searching catalogs for updates, if the head of a channel has a <literal>skipRange</literal> annotation and the currently installed Operator has a version field that falls in the range, OLM updates to the latest entry in the channel.</simpara>
<simpara>The order of precedence is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Channel head in the source specified by <literal>sourceName</literal> on the subscription, if the other criteria for skipping are met.</simpara>
</listitem>
<listitem>
<simpara>The next Operator that replaces the current one, in the source specified by <literal>sourceName</literal>.</simpara>
</listitem>
<listitem>
<simpara>Channel head in another source that is visible to the subscription, if the other criteria for skipping are met.</simpara>
</listitem>
<listitem>
<simpara>The next Operator that replaces the current one in any source visible to the
subscription.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Example CSV with <literal>skipRange</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
    name: elasticsearch-operator.v4.1.2
    namespace: &lt;namespace&gt;
    annotations:
        olm.skipRange: '&gt;=4.1.0 &lt;4.1.2'</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olm-upgrades-z-stream_olm-workflow">
<title>Z-stream support</title>
<simpara>A <emphasis>z-stream</emphasis>, or patch release, must replace all previous z-stream releases for the same minor version. OLM does not consider major, minor, or patch versions, it just needs to build the correct graph in a catalog.</simpara>
<simpara>In other words, OLM must be able to take a graph as in <emphasis role="strong">Old CatalogSource</emphasis> and, similar to before, generate a graph as in <emphasis role="strong">New CatalogSource</emphasis>:</simpara>
<figure>
<title>Replacing several Operators</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-z-stream.png"/>
</imageobject>
<textobject><phrase>olm z stream</phrase></textobject>
</mediaobject>
</figure>
<simpara>This graph maintains that:</simpara>
<itemizedlist>
<listitem>
<simpara>Any Operator found in <emphasis role="strong">Old CatalogSource</emphasis> has a single replacement in <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Any Operator found in <emphasis role="strong">New CatalogSource</emphasis> has a single replacement in <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Any z-stream release in <emphasis role="strong">Old CatalogSource</emphasis> will update to the latest z-stream release in <emphasis role="strong">New CatalogSource</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Unavailable releases can be considered "virtual" graph nodes; their content does not need to exist, the registry just needs to respond as if the graph looks like this.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="olm-understanding-dependency-resolution">
<title>Operator Lifecycle Manager dependency resolution</title>

<simpara>This guide outlines dependency resolution and custom resource definition (CRD) upgrade lifecycles with Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-dependency-resolution-about_olm-understanding-dependency-resolution">
<title>About dependency resolution</title>
<simpara>Operator Lifecycle Manager (OLM) manages the dependency resolution and upgrade lifecycle of running Operators. In many ways, the problems OLM faces are similar to other system or language package managers, such as <literal>yum</literal> and <literal>rpm</literal>.</simpara>
<simpara>However, there is one constraint that similar systems do not generally have that OLM does: because Operators are always running, OLM attempts to ensure that you are never left with a set of Operators that do not work with each other.</simpara>
<simpara>As a result, OLM must never create the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>Install a set of Operators that require APIs that cannot be provided</simpara>
</listitem>
<listitem>
<simpara>Update an Operator in a way that breaks another that depends upon it</simpara>
</listitem>
</itemizedlist>
<simpara>This is made possible with two types of data:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Properties</simpara>
</entry>
<entry>
<simpara>Typed metadata about the Operator that constitutes the public interface for it in the dependency resolver. Examples include the group/version/kind (GVK) of the APIs provided by the Operator and the semantic version (semver) of the Operator.</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Constraints or dependencies</simpara>
</entry>
<entry>
<simpara>An Operator&#8217;s requirements that should be satisfied by other Operators that might or might not have already been installed on the target cluster. These act as queries or filters over all available Operators and constrain the selection during dependency resolution and installation. Examples include requiring a specific API to be available on the cluster or expecting a particular Operator with a particular version to be installed.</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>OLM converts these properties and constraints into a system of Boolean formulas and passes them to a SAT solver, a program that establishes Boolean satisfiability, which does the work of determining what Operators should be installed.</simpara>
</section>
<section xml:id="olm-properties_olm-understanding-dependency-resolution">
<title>Operator properties</title>
<simpara>All Operators in a catalog have the following properties:</simpara>
<variablelist>
<varlistentry>
<term><literal>olm.package</literal></term>
<listitem>
<simpara>Includes the name of the package and the version of the Operator</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>olm.gvk</literal></term>
<listitem>
<simpara>A single property for each provided API from the cluster service version (CSV)</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Additional properties can also be directly declared by an Operator author by including a <literal>properties.yaml</literal> file in the <literal>metadata/</literal> directory of the Operator bundle.</simpara>
<formalpara>
<title>Example arbitrary property</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">properties:
- type: olm.kubeversion
  value:
    version: "1.16.0"</programlisting>
</para>
</formalpara>
<section xml:id="olm-arbitrary-properties_olm-understanding-dependency-resolution">
<title>Arbitrary properties</title>
<simpara>Operator authors can declare arbitrary properties in a <literal>properties.yaml</literal> file in the <literal>metadata/</literal> directory of the Operator bundle. These properties are translated into a map data structure that is used as an input to the Operator Lifecycle Manager (OLM) resolver at runtime.</simpara>
<simpara>These properties are opaque to the resolver as it does not understand the properties, but it can evaluate the generic constraints against those properties to determine if the constraints can be satisfied given the properties list.</simpara>
<formalpara>
<title>Example arbitrary properties</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">properties:
  - property:
      type: color
      value: red
  - property:
      type: shape
      value: square
  - property:
      type: olm.gvk
      value:
        group: olm.coreos.io
        version: v1alpha1
        kind: myresource</programlisting>
</para>
</formalpara>
<simpara>This structure can be used to construct a Common Expression Language (CEL) expression for generic constraints.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-understanding-dependency-resolution.xml#olm-cel_olm-understanding-dependency-resolution">Common Expression Language (CEL) constraints</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-dependencies_olm-understanding-dependency-resolution">
<title>Operator dependencies</title>
<simpara>The dependencies of an Operator are listed in a <literal>dependencies.yaml</literal> file in the <literal>metadata/</literal> folder of a bundle. This file is optional and currently only used to specify explicit Operator-version dependencies.</simpara>
<simpara>The dependency list contains a <literal>type</literal> field for each item to specify what kind of dependency this is. The following types of Operator dependencies are supported:</simpara>
<variablelist>
<varlistentry>
<term><literal>olm.package</literal></term>
<listitem>
<simpara>This type indicates a dependency for a specific Operator version. The dependency information must include the package name and the version of the package in semver format. For example, you can specify an exact version such as <literal>0.5.2</literal> or a range of versions such as <literal>&gt;0.5.1</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>olm.gvk</literal></term>
<listitem>
<simpara>With this type, the author can specify a dependency with group/version/kind (GVK) information, similar to existing CRD and API-based usage in a CSV. This is a path to enable Operator authors to consolidate all dependencies, API or explicit versions, to be in the same place.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>olm.constraint</literal></term>
<listitem>
<simpara>This type declares generic constraints on arbitrary Operator properties.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>In the following example, dependencies are specified for a Prometheus Operator and etcd CRDs:</simpara>
<formalpara>
<title>Example <literal>dependencies.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">dependencies:
  - type: olm.package
    value:
      packageName: prometheus
      version: "&gt;0.27.0"
  - type: olm.gvk
    value:
      group: etcd.database.coreos.com
      kind: EtcdCluster
      version: v1beta2</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olm-generic-constraints_olm-understanding-dependency-resolution">
<title>Generic constraints</title>
<simpara>An <literal>olm.constraint</literal> property declares a dependency constraint of a particular type, differentiating non-constraint and constraint properties. Its <literal>value</literal> field is an object containing a <literal>failureMessage</literal> field holding a string-representation of the constraint message. This message is surfaced as an informative comment to users if the constraint is not satisfiable at runtime.</simpara>
<simpara>The following keys denote the available constraint types:</simpara>
<variablelist>
<varlistentry>
<term><literal>gvk</literal></term>
<listitem>
<simpara>Type whose value and interpretation is identical to the <literal>olm.gvk</literal> type</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>package</literal></term>
<listitem>
<simpara>Type whose value and interpretation is identical to the <literal>olm.package</literal> type</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>cel</literal></term>
<listitem>
<simpara>A Common Expression Language (CEL) expression evaluated at runtime by the Operator Lifecycle Manager (OLM) resolver over arbitrary bundle properties and cluster information</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>all</literal>, <literal>any</literal>, <literal>not</literal></term>
<listitem>
<simpara>Conjunction, disjunction, and negation constraints, respectively, containing one or more concrete constraints, such as <literal>gvk</literal> or a nested compound constraint</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="olm-cel_olm-understanding-dependency-resolution">
<title>Common Expression Language (CEL) constraints</title>
<simpara>The <literal>cel</literal> constraint type supports <link xl:href="https://github.com/google/cel-go">Common Expression Language (CEL)</link> as the expression language. The <literal>cel</literal> struct has a <literal>rule</literal> field which contains the CEL expression string that is evaluated against Operator properties at runtime to determine if the Operator satisfies the constraint.</simpara>
<formalpara>
<title>Example <literal>cel</literal> constraint</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">type: olm.constraint
value:
  failureMessage: 'require to have "certified"'
  cel:
    rule: 'properties.exists(p, p.type == "certified")'</programlisting>
</para>
</formalpara>
<simpara>The CEL syntax supports a wide range of logical operators, such as <literal>AND</literal> and <literal>OR</literal>. As a result, a single CEL expression can have multiple rules for multiple conditions that are linked together by these logical operators. These rules are evaluated against a dataset of multiple different properties from a bundle or any given source, and the output is solved into a single bundle or Operator that satisfies all of those rules within a single constraint.</simpara>
<formalpara>
<title>Example <literal>cel</literal> constraint with multiple rules</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">type: olm.constraint
value:
  failureMessage: 'require to have "certified" and "stable" properties'
  cel:
    rule: 'properties.exists(p, p.type == "certified") &amp;&amp; properties.exists(p, p.type == "stable")'</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olm-compound-constraints_olm-understanding-dependency-resolution">
<title>Compound constraints (all, any, not)</title>
<simpara>Compound constraint types are evaluated following their logical definitions.</simpara>
<simpara>The following is an example of a conjunctive constraint (<literal>all</literal>) of two packages and one GVK. That is, they must all be satisfied by installed bundles:</simpara>
<formalpara>
<title>Example <literal>all</literal> constraint</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">schema: olm.bundle
name: red.v1.0.0
properties:
- type: olm.constraint
  value:
    failureMessage: All are required for Red because...
    all:
      constraints:
      - failureMessage: Package blue is needed for...
        package:
          name: blue
          versionRange: '&gt;=1.0.0'
      - failureMessage: GVK Green/v1 is needed for...
        gvk:
          group: greens.example.com
          version: v1
          kind: Green</programlisting>
</para>
</formalpara>
<simpara>The following is an example of a disjunctive constraint (<literal>any</literal>) of three versions of the same GVK. That is, at least one must be satisfied by installed bundles:</simpara>
<formalpara>
<title>Example <literal>any</literal> constraint</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">schema: olm.bundle
name: red.v1.0.0
properties:
- type: olm.constraint
  value:
    failureMessage: Any are required for Red because...
    any:
      constraints:
      - gvk:
          group: blues.example.com
          version: v1beta1
          kind: Blue
      - gvk:
          group: blues.example.com
          version: v1beta2
          kind: Blue
      - gvk:
          group: blues.example.com
          version: v1
          kind: Blue</programlisting>
</para>
</formalpara>
<simpara>The following is an example of a negation constraint (<literal>not</literal>) of one version of a GVK. That is, this GVK cannot be provided by any bundle in the result set:</simpara>
<formalpara>
<title>Example <literal>not</literal> constraint</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">schema: olm.bundle
name: red.v1.0.0
properties:
- type: olm.constraint
  value:
  all:
    constraints:
    - failureMessage: Package blue is needed for...
      package:
        name: blue
        versionRange: '&gt;=1.0.0'
    - failureMessage: Cannot be required for Red because...
      not:
        constraints:
        - gvk:
            group: greens.example.com
            version: v1alpha1
            kind: greens</programlisting>
</para>
</formalpara>
<simpara>The negation semantics might appear unclear in the <literal>not</literal> constraint context. To clarify, the negation is really instructing the resolver to remove any possible solution that includes a particular GVK, package at a version, or satisfies some child compound constraint from the result set.</simpara>
<simpara>As a corollary, the <literal>not</literal> compound constraint should only be used within <literal>all</literal> or <literal>any</literal> constraints, because negating without first selecting a possible set of dependencies does not make sense.</simpara>
</section>
<section xml:id="olm-nested-compound_olm-understanding-dependency-resolution">
<title>Nested compound constraints</title>
<simpara>A nested compound constraint, one that contains at least one child compound constraint along with zero or more simple constraints, is evaluated from the bottom up following the procedures for each previously described constraint type.</simpara>
<simpara>The following is an example of a disjunction of conjunctions, where one, the other, or both can satisfy the constraint:</simpara>
<formalpara>
<title>Example nested compound constraint</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">schema: olm.bundle
name: red.v1.0.0
properties:
- type: olm.constraint
  value:
    failureMessage: Required for Red because...
    any:
      constraints:
      - all:
          constraints:
          - package:
              name: blue
              versionRange: '&gt;=1.0.0'
          - gvk:
              group: blues.example.com
              version: v1
              kind: Blue
      - all:
          constraints:
          - package:
              name: blue
              versionRange: '&lt;1.0.0'
          - gvk:
              group: blues.example.com
              version: v1beta1
              kind: Blue</programlisting>
</para>
</formalpara>
<note>
<simpara>The maximum raw size of an <literal>olm.constraint</literal> type is 64KB to limit resource exhaustion attacks.</simpara>
</note>
</section>
</section>
<section xml:id="olm-dependency-resolution-preferences_olm-understanding-dependency-resolution">
<title>Dependency preferences</title>
<simpara>There can be many options that equally satisfy a dependency of an Operator. The dependency resolver in Operator Lifecycle Manager (OLM) determines which option best fits the requirements of the requested Operator. As an Operator author or user, it can be important to understand how these choices are made so that dependency resolution is clear.</simpara>
<section xml:id="olm-dependency-catalog-priority_olm-understanding-dependency-resolution">
<title>Catalog priority</title>
<simpara>On {product-title} cluster, OLM reads catalog sources to know which Operators are available for installation.</simpara>
<formalpara>
<title>Example <literal>CatalogSource</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "operators.coreos.com/v1alpha1"
kind: "CatalogSource"
metadata:
  name: "my-operators"
  namespace: "operators"
spec:
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO3-1"/>
  image: example.com/my/operator-index:v1
  displayName: "My Operators"
  priority: 100</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
</calloutlist>
<simpara>A <literal>CatalogSource</literal> object has a <literal>priority</literal> field, which is used by the resolver to know how to prefer options for a dependency.</simpara>
<simpara>There are two rules that govern catalog preference:</simpara>
<itemizedlist>
<listitem>
<simpara>Options in higher-priority catalogs are preferred to options in lower-priority catalogs.</simpara>
</listitem>
<listitem>
<simpara>Options in the same catalog as the dependent are preferred to any other catalogs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-dependency-catalog-ordering_olm-understanding-dependency-resolution">
<title>Channel ordering</title>
<simpara>An Operator package in a catalog is a collection of update channels that a user can subscribe to in an {product-title} cluster. Channels can be used to provide a particular stream of updates for a minor release (<literal>1.2</literal>, <literal>1.3</literal>) or a release frequency (<literal>stable</literal>, <literal>fast</literal>).</simpara>
<simpara>It is likely that a dependency might be satisfied by Operators in the same package, but different channels. For example, version <literal>1.2</literal> of an Operator might exist in both the <literal>stable</literal> and <literal>fast</literal> channels.</simpara>
<simpara>Each package has a default channel, which is always preferred to non-default channels. If no option in the default channel can satisfy a dependency, options are considered from the remaining channels in lexicographic order of the channel name.</simpara>
</section>
<section xml:id="olm-dependency-order-winthin-channel_olm-understanding-dependency-resolution">
<title>Order within a channel</title>
<simpara>There are almost always multiple options to satisfy a dependency within a single channel. For example, Operators in one package and channel provide the same set of APIs.</simpara>
<simpara>When a user creates a subscription, they indicate which channel to receive updates from. This immediately reduces the search to just that one channel. But within the channel, it is likely that many Operators satisfy a dependency.</simpara>
<simpara>Within a channel, newer Operators that are higher up in the update graph are preferred. If the head of a channel satisfies a dependency, it will be tried first.</simpara>
</section>
<section xml:id="olm-dependency-preferences-other_olm-understanding-dependency-resolution">
<title>Other constraints</title>
<simpara>In addition to the constraints supplied by package dependencies, OLM includes additional constraints to represent the desired user state and enforce resolution invariants.</simpara>
<section xml:id="olm-dependency-sub-constraint_olm-understanding-dependency-resolution">
<title>Subscription constraint</title>
<simpara>A subscription constraint filters the set of Operators that can satisfy a subscription. Subscriptions are user-supplied constraints for the dependency resolver. They declare the intent to either install a new Operator if it is not already on the cluster, or to keep an existing Operator updated.</simpara>
</section>
<section xml:id="olm-dependency-package-constraint_olm-understanding-dependency-resolution">
<title>Package constraint</title>
<simpara>Within a namespace, no two Operators may come from the same package.</simpara>
</section>
</section>
<section xml:id="additional-resources_dependency-resolution-preferences" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-understanding-olm.xml#olm-cs-health_olm-understanding-olm">Catalog health requirements</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-dependency-resolution-crd-upgrades_olm-understanding-dependency-resolution">
<title>CRD upgrades</title>
<simpara>OLM upgrades a custom resource definition (CRD) immediately if it is owned by a singular cluster service version (CSV). If a CRD is owned by multiple CSVs, then the CRD is upgraded when it has satisfied all of the following backward compatible conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>All existing serving versions in the current CRD are present in the new CRD.</simpara>
</listitem>
<listitem>
<simpara>All existing instances, or custom resources, that are associated with the serving versions of the CRD are valid when validated against the validation schema of the new CRD.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-generating-csvs.xml#olm-dependency-resolution-adding-new-crd-version_osdk-generating-csvs">Adding a new CRD version</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-generating-csvs.xml#olm-dependency-resolution-removing-crd-version_osdk-generating-csvs">Deprecating or removing a CRD version</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-dependency-best-practices_olm-understanding-dependency-resolution">
<title>Dependency best practices</title>
<simpara>When specifying dependencies, there are best practices you should consider.</simpara>
<variablelist>
<varlistentry>
<term>Depend on APIs or a specific version range of Operators</term>
<listitem>
<simpara>Operators can add or remove APIs at any time; always specify an <literal>olm.gvk</literal> dependency on any APIs your Operators requires. The exception to this is if you are specifying <literal>olm.package</literal> constraints instead.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Set a minimum version</term>
<listitem>
<simpara>The Kubernetes documentation on API changes describes what changes are allowed for Kubernetes-style Operators. These versioning conventions allow an Operator to update an API without bumping the API version, as long as the API is backwards-compatible.</simpara>
<simpara>For Operator dependencies, this means that knowing the API version of a dependency might not be enough to ensure the dependent Operator works as intended.</simpara>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>TestOperator v1.0.0 provides v1alpha1 API version of the <literal>MyObject</literal> resource.</simpara>
</listitem>
<listitem>
<simpara>TestOperator v1.0.1 adds a new field <literal>spec.newfield</literal> to <literal>MyObject</literal>, but still at v1alpha1.</simpara>
</listitem>
</itemizedlist>
<simpara>Your Operator might require the ability to write <literal>spec.newfield</literal> into the <literal>MyObject</literal> resource. An <literal>olm.gvk</literal> constraint alone is not enough for OLM to determine that you need TestOperator v1.0.1 and not TestOperator v1.0.0.</simpara>
<simpara>Whenever possible, if a specific Operator that provides an API is known ahead of time, specify an additional <literal>olm.package</literal> constraint to set a minimum.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Omit a maximum version or allow a very wide range</term>
<listitem>
<simpara>Because Operators provide cluster-scoped resources such as API services and CRDs, an Operator that specifies a small window for a dependency might unnecessarily constrain updates for other consumers of that dependency.</simpara>
<simpara>Whenever possible, do not set a maximum version. Alternatively, set a very wide semantic range to prevent conflicts with other Operators. For example, <literal>&gt;1.0.0 &lt;2.0.0</literal>.</simpara>
<simpara>Unlike with conventional package managers, Operator authors explicitly encode that updates are safe through channels in OLM. If an update is available for an existing subscription, it is assumed that the Operator author is indicating that it can update from the previous version. Setting a maximum version for a dependency overrides the update stream of the author by unnecessarily truncating it at a particular upper bound.</simpara>
<note>
<simpara>Cluster administrators cannot override dependencies set by an Operator author.</simpara>
</note>
<simpara>However, maximum versions can and should be set if there are known incompatibilities that must be avoided. Specific versions can be omitted with the version range syntax, for example <literal>&gt; 1.0.0 !1.2.1</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>Kubernetes documentation: <link xl:href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api_changes.md#readme">Changing the API</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-dependency-caveats_olm-understanding-dependency-resolution">
<title>Dependency caveats</title>
<simpara>When specifying dependencies, there are caveats you should consider.</simpara>
<variablelist>
<varlistentry>
<term>No compound constraints (AND)</term>
<listitem>
<simpara>There is currently no method for specifying an AND relationship between constraints. In other words, there is no way to specify that one Operator depends on another Operator that both provides a given API and has version <literal>&gt;1.1.0</literal>.</simpara>
<simpara>This means that when specifying a dependency such as:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">dependencies:
- type: olm.package
  value:
    packageName: etcd
    version: "&gt;3.1.0"
- type: olm.gvk
  value:
    group: etcd.database.coreos.com
    kind: EtcdCluster
    version: v1beta2</programlisting>
<simpara>It would be possible for OLM to satisfy this with two Operators: one that provides EtcdCluster and one that has version <literal>&gt;3.1.0</literal>. Whether that happens, or whether an Operator is selected that satisfies both constraints, depends on the ordering that potential options are visited. Dependency preferences and ordering options are well-defined and can be reasoned about, but to exercise caution, Operators should stick to one mechanism or the other.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cross-namespace compatibility</term>
<listitem>
<simpara>OLM performs dependency resolution at the namespace scope. It is possible to get into an update deadlock if updating an Operator in one namespace would be an issue for an Operator in another namespace, and vice-versa.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="olm-dependency-resolution-examples_olm-understanding-dependency-resolution">
<title>Example dependency resolution scenarios</title>
<simpara>In the following examples, a <emphasis>provider</emphasis> is an Operator which "owns" a CRD or API service.</simpara>
<bridgehead xml:id="_example_deprecating_dependent_apis" renderas="sect6">Example: Deprecating dependent APIs</bridgehead>
<simpara>A and B are APIs (CRDs):</simpara>
<itemizedlist>
<listitem>
<simpara>The provider of A depends on B.</simpara>
</listitem>
<listitem>
<simpara>The provider of B has a subscription.</simpara>
</listitem>
<listitem>
<simpara>The provider of B updates to provide C but deprecates B.</simpara>
</listitem>
</itemizedlist>
<simpara>This results in:</simpara>
<itemizedlist>
<listitem>
<simpara>B no longer has a provider.</simpara>
</listitem>
<listitem>
<simpara>A no longer works.</simpara>
</listitem>
</itemizedlist>
<simpara>This is a case OLM prevents with its upgrade strategy.</simpara>
<bridgehead xml:id="_example_version_deadlock" renderas="sect6">Example: Version deadlock</bridgehead>
<simpara>A and B are APIs:</simpara>
<itemizedlist>
<listitem>
<simpara>The provider of A requires B.</simpara>
</listitem>
<listitem>
<simpara>The provider of B requires A.</simpara>
</listitem>
<listitem>
<simpara>The provider of A updates to (provide A2, require B2) and deprecate A.</simpara>
</listitem>
<listitem>
<simpara>The provider of B updates to (provide B2, require A2) and deprecate B.</simpara>
</listitem>
</itemizedlist>
<simpara>If OLM attempts to update A without simultaneously updating B, or vice-versa, it is unable to progress to new versions of the Operators, even though a new compatible set can be found.</simpara>
<simpara>This is another case OLM prevents with its upgrade strategy.</simpara>
</section>
</section>
<section xml:id="olm-understanding-operatorgroups">
<title>Operator groups</title>

<simpara>This guide outlines the use of Operator groups with Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<section xml:id="olm-operatorgroups-about_olm-understanding-operatorgroups">
<title>About Operator groups</title>
<simpara>An <emphasis>Operator group</emphasis>, defined by the <literal>OperatorGroup</literal> resource, provides multitenant configuration to OLM-installed Operators. An Operator group selects target namespaces in which to generate required RBAC access for its member Operators.</simpara>
<simpara>The set of target namespaces is provided by a comma-delimited string stored in the <literal>olm.targetNamespaces</literal> annotation of a cluster service version (CSV). This annotation is applied to the CSV instances of member Operators and is projected into their deployments.</simpara>
</section>
<section xml:id="olm-operatorgroups-membership_olm-understanding-operatorgroups">
<title>Operator group membership</title>
<simpara>An Operator is considered a <emphasis>member</emphasis> of an Operator group if the following conditions are true:</simpara>
<itemizedlist>
<listitem>
<simpara>The CSV of the Operator exists in the same namespace as the Operator group.</simpara>
</listitem>
<listitem>
<simpara>The install modes in the CSV of the Operator support the set of namespaces targeted by the Operator group.</simpara>
</listitem>
</itemizedlist>
<simpara>An install mode in a CSV consists of an <literal>InstallModeType</literal> field and a boolean <literal>Supported</literal> field. The spec of a CSV can contain a set of install modes of four distinct <literal>InstallModeTypes</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Install modes and supported Operator groups</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">InstallModeType</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>OwnNamespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator can be a member of an Operator group that selects its own namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SingleNamespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator can be a member of an Operator group that selects one namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MultiNamespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator can be a member of an Operator group that selects more than one namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>AllNamespaces</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator can be a member of an Operator group that selects all namespaces (target namespace set is the empty string <literal>""</literal>).</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>If the spec of a CSV omits an entry of <literal>InstallModeType</literal>, then that type is considered unsupported unless support can be inferred by an existing entry that implicitly supports it.</simpara>
</note>
</section>
<section xml:id="olm-operatorgroups-target-namespace_olm-understanding-operatorgroups">
<title>Target namespace selection</title>
<simpara>You can explicitly name the target namespace for an Operator group using the <literal>spec.targetNamespaces</literal> parameter:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: my-group
  namespace: my-namespace
spec:
  targetNamespaces:
  - my-namespace</programlisting>
<simpara>You can alternatively specify a namespace using a label selector with the <literal>spec.selector</literal> parameter:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: my-group
  namespace: my-namespace
spec:
  selector:
    cool.io/prod: "true"</programlisting>
<important>
<simpara>Listing multiple namespaces via <literal>spec.targetNamespaces</literal> or use of a label selector via <literal>spec.selector</literal> is not recommended, as the support for more than one target namespace in an Operator group will likely be removed in a future release.</simpara>
</important>
<simpara>If both <literal>spec.targetNamespaces</literal> and <literal>spec.selector</literal> are defined, <literal>spec.selector</literal> is ignored. Alternatively, you can omit both <literal>spec.selector</literal> and <literal>spec.targetNamespaces</literal> to specify a <emphasis>global</emphasis> Operator group, which selects all namespaces:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: my-group
  namespace: my-namespace</programlisting>
<simpara>The resolved set of selected namespaces is shown in the <literal>status.namespaces</literal> parameter of an Opeator group. The <literal>status.namespace</literal> of a global Operator group contains the empty string (<literal>""</literal>), which signals to a consuming Operator that it should watch all namespaces.</simpara>
</section>
<section xml:id="olm-operatorgroups-csv-annotations_olm-understanding-operatorgroups">
<title>Operator group CSV annotations</title>
<simpara>Member CSVs of an Operator group have the following annotations:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>olm.operatorGroup=&lt;group_name&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the name of the Operator group.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>olm.operatorNamespace=&lt;group_namespace&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the namespace of the Operator group.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>olm.targetNamespaces=&lt;target_namespaces&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains a comma-delimited string that lists the target namespace selection of the Operator group.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>All annotations except <literal>olm.targetNamespaces</literal> are included with copied CSVs. Omitting the <literal>olm.targetNamespaces</literal> annotation on copied CSVs prevents the duplication of target namespaces between tenants.</simpara>
</note>
</section>
<section xml:id="olm-operatorgroups-provided-apis-annotation_olm-understanding-operatorgroups">
<title>Provided APIs annotation</title>
<simpara>A <emphasis>group/version/kind (GVK)</emphasis> is a unique identifier for a Kubernetes API. Information about what GVKs are provided by an Operator group are shown in an <literal>olm.providedAPIs</literal> annotation. The value of the annotation is a string consisting of <literal>&lt;kind&gt;.&lt;version&gt;.&lt;group&gt;</literal> delimited with commas. The GVKs of CRDs and API services provided by all active member CSVs of an Operator group are included.</simpara>
<simpara>Review the following example of an <literal>OperatorGroup</literal> object with a single active member CSV that provides the <literal>PackageManifest</literal> resource:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  annotations:
    olm.providedAPIs: PackageManifest.v1alpha1.packages.apps.redhat.com
  name: olm-operators
  namespace: local
  ...
spec:
  selector: {}
  serviceAccount:
    metadata:
      creationTimestamp: null
  targetNamespaces:
  - local
status:
  lastUpdated: 2019-02-19T16:18:28Z
  namespaces:
  - local</programlisting>
</section>
<section xml:id="olm-operatorgroups-rbac_olm-understanding-operatorgroups">
<title>Role-based access control</title>
<simpara>When an Operator group is created, three cluster roles are generated. Each contains a single aggregation rule with a cluster role selector set to match a label, as shown below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Cluster role</entry>
<entry align="left" valign="top">Label to match</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;operatorgroup_name&gt;-admin</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm.opgroup.permissions/aggregate-to-admin: &lt;operatorgroup_name&gt;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;operatorgroup_name&gt;-edit</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm.opgroup.permissions/aggregate-to-edit: &lt;operatorgroup_name&gt;</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;operatorgroup_name&gt;-view</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm.opgroup.permissions/aggregate-to-view: &lt;operatorgroup_name&gt;</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The following RBAC resources are generated when a CSV becomes an active member of an Operator group, as long as the CSV is watching all namespaces with the <literal>AllNamespaces</literal> install mode and is not in a failed state with reason <literal>InterOperatorGroupOwnerConflict</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Cluster roles for each API resource from a CRD</simpara>
</listitem>
<listitem>
<simpara>Cluster roles for each API resource from an API service</simpara>
</listitem>
<listitem>
<simpara>Additional roles and role bindings</simpara>
</listitem>
</itemizedlist>
<table xml:id="olm-resources-per-api-resource-crd_olm-understanding-operatorgroups" frame="all" rowsep="1" colsep="1">
<title>Cluster roles generated for each API resource from a CRD</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Cluster role</entry>
<entry align="left" valign="top">Settings</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-admin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>*</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-admin: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-admin: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-edit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>create</literal></simpara>
</listitem>
<listitem>
<simpara><literal>update</literal></simpara>
</listitem>
<listitem>
<simpara><literal>patch</literal></simpara>
</listitem>
<listitem>
<simpara><literal>delete</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-edit: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-edit: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-view</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>get</literal></simpara>
</listitem>
<listitem>
<simpara><literal>list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>watch</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-view: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-view: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-view-crdview</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>apiextensions.k8s.io</literal> <literal>customresourcedefinitions</literal> <literal>&lt;crd-name&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>get</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-view: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-view: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</table>
<table xml:id="olm-resources-per-api-resource-api_olm-understanding-operatorgroups" frame="all" rowsep="1" colsep="1">
<title>Cluster roles generated for each API resource from an API service</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Cluster role</entry>
<entry align="left" valign="top">Settings</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-admin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>*</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-admin: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-admin: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-edit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>create</literal></simpara>
</listitem>
<listitem>
<simpara><literal>update</literal></simpara>
</listitem>
<listitem>
<simpara><literal>patch</literal></simpara>
</listitem>
<listitem>
<simpara><literal>delete</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-edit: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-edit: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;kind&gt;.&lt;group&gt;-&lt;version&gt;-view</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbs on <literal>&lt;kind&gt;</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>get</literal></simpara>
</listitem>
<listitem>
<simpara><literal>list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>watch</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Aggregation labels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>rbac.authorization.k8s.io/aggregate-to-view: true</literal></simpara>
</listitem>
<listitem>
<simpara><literal>olm.opgroup.permissions/aggregate-to-view: &lt;operatorgroup_name&gt;</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist xml:id="olm-resources-additional-roles-rolebindings_olm-understanding-operatorgroups">
<title>Additional roles and role bindings</title>
<listitem>
<simpara>If the CSV defines exactly one target namespace that contains <literal>*</literal>, then a cluster role and corresponding cluster role binding are generated for each permission defined in the <literal>permissions</literal> field of the CSV. All resources generated are given the <literal>olm.owner: &lt;csv_name&gt;</literal> and <literal>olm.owner.namespace: &lt;csv_namespace&gt;</literal> labels.</simpara>
</listitem>
<listitem>
<simpara>If the CSV does <emphasis>not</emphasis> define exactly one target namespace that contains <literal>*</literal>, then all roles and role bindings in the Operator namespace with the <literal>olm.owner: &lt;csv_name&gt;</literal> and <literal>olm.owner.namespace: &lt;csv_namespace&gt;</literal> labels are copied into the target namespace.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-operatorgroups-copied-csvs_olm-understanding-operatorgroups">
<title>Copied CSVs</title>
<simpara>OLM creates copies of all active member CSVs of an Operator group in each of the target namespaces of that Operator group. The purpose of a copied CSV is to tell users of a target namespace that a specific Operator is configured to watch resources created there.</simpara>
<simpara>Copied CSVs have a status reason <literal>Copied</literal> and are updated to match the status of their source CSV. The <literal>olm.targetNamespaces</literal> annotation is stripped from copied CSVs before they are created on the cluster. Omitting the target namespace selection avoids the duplication of target namespaces between tenants.</simpara>
<simpara>Copied CSVs are deleted when their source CSV no longer exists or the Operator group that their source CSV belongs to no longer targets the namespace of the copied CSV.</simpara>
<note>
<simpara>By default, the <literal>disableCopiedCSVs</literal> field is disabled. After enabling a <literal>disableCopiedCSVs</literal> field, the OLM deletes existing copied CSVs on a cluster. When a <literal>disableCopiedCSVs</literal> field is disabled, the OLM adds copied CSVs again.</simpara>
<itemizedlist>
<listitem>
<simpara>Disable the <literal>disableCopiedCSVs</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ cat &lt;&lt; EOF | oc apply -f -
apiVersion: operators.coreos.com/v1
kind: OLMConfig
metadata:
  name: cluster
spec:
  features:
    disableCopiedCSVs: false
EOF</programlisting>
</listitem>
<listitem>
<simpara>Enable the <literal>disableCopiedCSVs</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ cat &lt;&lt; EOF | oc apply -f -
apiVersion: operators.coreos.com/v1
kind: OLMConfig
metadata:
  name: cluster
spec:
  features:
    disableCopiedCSVs: true
EOF</programlisting>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="olm-operatorgroups-static_olm-understanding-operatorgroups">
<title>Static Operator groups</title>
<simpara>An Operator group is <emphasis>static</emphasis> if its <literal>spec.staticProvidedAPIs</literal> field is set to <literal>true</literal>. As a result, OLM does not modify the <literal>olm.providedAPIs</literal> annotation of an Operator group, which means that it can be set in advance. This is useful when a user wants to use an Operator group to prevent resource contention in a set of namespaces but does not have active member CSVs that provide the APIs for those resources.</simpara>
<simpara>Below is an example of an Operator group that protects <literal>Prometheus</literal> resources in all namespaces with the <literal>something.cool.io/cluster-monitoring: "true"</literal> annotation:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: cluster-monitoring
  namespace: cluster-monitoring
  annotations:
    olm.providedAPIs: Alertmanager.v1.monitoring.coreos.com,Prometheus.v1.monitoring.coreos.com,PrometheusRule.v1.monitoring.coreos.com,ServiceMonitor.v1.monitoring.coreos.com
spec:
  staticProvidedAPIs: true
  selector:
    matchLabels:
      something.cool.io/cluster-monitoring: "true"</programlisting>
</section>
<section xml:id="olm-operatorgroups-intersection_olm-understanding-operatorgroups">
<title>Operator group intersection</title>
<simpara>Two Operator groups are said to have <emphasis>intersecting provided APIs</emphasis> if the intersection of their target namespace sets is not an empty set and the intersection of their provided API sets, defined by <literal>olm.providedAPIs</literal> annotations, is not an empty set.</simpara>
<simpara>A potential issue is that Operator groups with intersecting provided APIs can compete for the same resources in the set of intersecting namespaces.</simpara>
<note>
<simpara>When checking intersection rules, an Operator group namespace is always included as part of its selected target namespaces.</simpara>
</note>
<bridgehead xml:id="olm-operatorgroups-intersection-rules_olm-understanding-operatorgroups" renderas="sect6">Rules for intersection</bridgehead>
<simpara>Each time an active member CSV synchronizes, OLM queries the cluster for the set of intersecting provided APIs between the Operator group of the CSV and all others. OLM then checks if that set is an empty set:</simpara>
<itemizedlist>
<listitem>
<simpara>If <literal>true</literal> and the CSV&#8217;s provided APIs are a subset of the Operator group&#8217;s:</simpara>
<itemizedlist>
<listitem>
<simpara>Continue transitioning.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If <literal>true</literal> and the CSV&#8217;s provided APIs are <emphasis>not</emphasis> a subset of the Operator group&#8217;s:</simpara>
<itemizedlist>
<listitem>
<simpara>If the Operator group is static:</simpara>
<itemizedlist>
<listitem>
<simpara>Clean up any deployments that belong to the CSV.</simpara>
</listitem>
<listitem>
<simpara>Transition the CSV to a failed state with status reason
<literal>CannotModifyStaticOperatorGroupProvidedAPIs</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the Operator group is <emphasis>not</emphasis> static:</simpara>
<itemizedlist>
<listitem>
<simpara>Replace the Operator group&#8217;s <literal>olm.providedAPIs</literal> annotation with the union of itself and the CSV&#8217;s provided APIs.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If <literal>false</literal> and the CSV&#8217;s provided APIs are <emphasis>not</emphasis> a subset of the Operator group&#8217;s:</simpara>
<itemizedlist>
<listitem>
<simpara>Clean up any deployments that belong to the CSV.</simpara>
</listitem>
<listitem>
<simpara>Transition the CSV to a failed state with status reason <literal>InterOperatorGroupOwnerConflict</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If <literal>false</literal> and the CSV&#8217;s provided APIs are a subset of the Operator group&#8217;s:</simpara>
<itemizedlist>
<listitem>
<simpara>If the Operator group is static:</simpara>
<itemizedlist>
<listitem>
<simpara>Clean up any deployments that belong to the CSV.</simpara>
</listitem>
<listitem>
<simpara>Transition the CSV to a failed state with status reason <literal>CannotModifyStaticOperatorGroupProvidedAPIs</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the Operator group is <emphasis>not</emphasis> static:</simpara>
<itemizedlist>
<listitem>
<simpara>Replace the Operator group&#8217;s <literal>olm.providedAPIs</literal> annotation with the difference between itself and the CSV&#8217;s provided APIs.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>Failure states caused by Operator groups are non-terminal.</simpara>
</note>
<simpara>The following actions are performed each time an Operator group synchronizes:</simpara>
<itemizedlist>
<listitem>
<simpara>The set of provided APIs from active member CSVs is calculated from the cluster. Note that copied CSVs are ignored.</simpara>
</listitem>
<listitem>
<simpara>The cluster set is compared to <literal>olm.providedAPIs</literal>, and if <literal>olm.providedAPIs</literal> contains any extra APIs, then those APIs are pruned.</simpara>
</listitem>
<listitem>
<simpara>All CSVs that provide the same APIs across all namespaces are requeued. This notifies conflicting CSVs in intersecting groups that their conflict has possibly been resolved, either through resizing or through deletion of the conflicting CSV.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-operatorgroups-limitations">
<title>Limitations for multitenant Operator management</title>
<simpara>{product-title} provides limited support for simultaneously installing different versions of an Operator on the same cluster. Operator Lifecycle Manager (OLM) installs Operators multiple times in different namespaces. One constraint of this is that the Operator&#8217;s API versions must be the same.</simpara>
<simpara>Operators are control plane extensions due to their usage of <literal>CustomResourceDefinition</literal> objects (CRDs), which are global resources in Kubernetes. Different major versions of an Operator often have incompatible CRDs. This makes them incompatible to install simultaneously in different namespaces on a cluster.</simpara>
<simpara>All tenants, or namespaces, share the same control plane of a cluster. Therefore, tenants in a multitenant cluster also share global CRDs, which limits the scenarios in which different instances of the same Operator can be used in parallel on the same cluster.</simpara>
<simpara>The supported scenarios include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Operators of different versions that ship the exact same CRD definition (in case of versioned CRDs, the exact same set of versions)</simpara>
</listitem>
<listitem>
<simpara>Operators of different versions that do not ship a CRD, and instead have their CRD available in a separate bundle on the OperatorHub</simpara>
</listitem>
</itemizedlist>
<simpara>All other scenarios are not supported, because the integrity of the cluster data cannot be guaranteed if there are multiple competing or overlapping CRDs from different Operator versions to be reconciled on the same cluster.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Operator Lifecycle Manager (OLM) &#8594; Multitenancy and Operator colocation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-multitenancy.xml#olm-multitenancy">Operators in multitenant clusters</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-creating-policy.xml#olm-creating-policy">Allowing non-cluster administrators to install Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-operatorgroups-troubleshooting_olm-understanding-operatorgroups">
<title>Troubleshooting Operator groups</title>
<bridgehead xml:id="olm-operatorgroups-troubleshooting-membership_olm-understanding-operatorgroups" renderas="sect6">Membership</bridgehead>
<itemizedlist>
<listitem>
<simpara>An install plan&#8217;s namespace must contain only one Operator group. When attempting to generate a cluster service version (CSV) in a namespace, an install plan considers an Operator group invalid in the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>No Operator groups exist in the install plan&#8217;s namespace.</simpara>
</listitem>
<listitem>
<simpara>Multiple Operator groups exist in the install plan&#8217;s namespace.</simpara>
</listitem>
<listitem>
<simpara>An incorrect or non-existent service account name is specified in the Operator group.</simpara>
</listitem>
</itemizedlist>
<simpara>If an install plan encounters an invalid Operator group, the CSV is not generated and the <literal>InstallPlan</literal> resource continues to install with a relevant message. For example, the following message is provided if more than one Operator group exists in the same namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">attenuated service account query failed - more than one operator group(s) are managing this namespace count=2</programlisting>
<simpara>where <literal>count=</literal> specifies the number of Operator groups in the namespace.</simpara>
</listitem>
<listitem>
<simpara>If the install modes of a CSV do not support the target namespace selection of the Operator group in its namespace, the CSV transitions to a failure state with the reason <literal>UnsupportedOperatorGroup</literal>. CSVs in a failed state for this reason transition to pending after either the target namespace selection of the Operator group changes to a supported configuration, or the install modes of the CSV are modified to support the target namespace selection.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-colocation">
<title>Multitenancy and Operator colocation</title>

<simpara>This guide outlines multitenancy and Operator colocation in Operator Lifecycle Manager (OLM).</simpara>
<section xml:id="olm-colocation-namespaces_olm-colocation">
<title>Colocation of Operators in a namespace</title>
<simpara>Operator Lifecycle Manager (OLM) handles OLM-managed Operators that are installed in the same namespace, meaning their <literal>Subscription</literal> resources are colocated in the same namespace, as related Operators. Even if they are not actually related, OLM considers their states, such as their version and update policy, when any one of them is updated.</simpara>
<simpara>This default behavior manifests in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>InstallPlan</literal> resources of pending updates include <literal>ClusterServiceVersion</literal> (CSV) resources of all other Operators that are in the same namespace.</simpara>
</listitem>
<listitem>
<simpara>All Operators in the same namespace share the same update policy. For example, if one Operator is set to manual updates, all other Operators' update policies are also set to manual.</simpara>
</listitem>
</itemizedlist>
<simpara>These scenarios can lead to the following issues:</simpara>
<itemizedlist>
<listitem>
<simpara>It becomes hard to reason about install plans for Operator updates, because there are many more resources defined in them than just the updated Operator.</simpara>
</listitem>
<listitem>
<simpara>It becomes impossible to have some Operators in a namespace update automatically while other are updated manually, which is a common desire for cluster administrators.</simpara>
</listitem>
</itemizedlist>
<simpara>These issues usually surface because, when installing Operators with the {product-title} web console, the default behavior installs Operators that support the <emphasis role="strong">All namespaces</emphasis> install mode into the default <literal>openshift-operators</literal> global namespace.</simpara>
<simpara>As a cluster administrator,
you can bypass this default behavior manually by using the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a namespace for the installation of the Operator.</simpara>
</listitem>
<listitem>
<simpara>Create a custom <emphasis>global Operator group</emphasis>, which is an Operator group that watches all namespaces. By associating this Operator group with the namespace you just created, it makes the installation namespace a global namespace, which makes Operators installed there available in all namespaces.</simpara>
</listitem>
<listitem>
<simpara>Install the desired Operator in the installation namespace.</simpara>
</listitem>
</orderedlist>
<simpara>If the Operator has dependencies, the dependencies are automatically installed in the pre-created namespace. As a result, it is then valid for the dependency Operators to have the same update policy and shared install plans. For a detailed procedure, see "Installing global Operators in custom namespaces".</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-global-namespaces_olm-adding-operators-to-a-cluster">Installing global Operators in custom namespaces</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-multitenancy.xml#olm-multitenancy">Operators in multitenant clusters</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-operatorconditions">
<title>Operator conditions</title>

<simpara>This guide outlines how Operator Lifecycle Manager (OLM) uses Operator conditions.</simpara>
<section xml:id="olm-about-operatorconditions_olm-operatorconditions">
<title>About Operator conditions</title>
<simpara>As part of its role in managing the lifecycle of an Operator, Operator Lifecycle Manager (OLM) infers the state of an Operator from the state of Kubernetes resources that define the Operator. While this approach provides some level of assurance that an Operator is in a given state, there are many instances where an Operator might need to communicate information to OLM that could not be inferred otherwise. This information can then be used by OLM to better manage the lifecycle of the Operator.</simpara>
<simpara>OLM provides a custom resource definition (CRD) called <literal>OperatorCondition</literal> that allows Operators to communicate conditions to OLM. There are a set of supported conditions that influence management of the Operator by OLM when present in the <literal>Spec.Conditions</literal> array of an <literal>OperatorCondition</literal> resource.</simpara>
<note>
<simpara>By default, the <literal>Spec.Conditions</literal> array is not present in an <literal>OperatorCondition</literal> object until it is either added by a user or as a result of custom Operator logic.</simpara>
</note>
</section>
<section xml:id="olm-supported-operatorconditions_olm-operatorconditions">
<title>Supported conditions</title>
<simpara>Operator Lifecycle Manager (OLM) supports the following Operator conditions.</simpara>
<section xml:id="olm-upgradeable-operatorcondition_olm-operatorconditions">
<title>Upgradeable condition</title>
<simpara>The <literal>Upgradeable</literal> Operator condition prevents an existing cluster service version (CSV) from being replaced by a newer version of the CSV. This condition is useful when:</simpara>
<itemizedlist>
<listitem>
<simpara>An Operator is about to start a critical process and should not be upgraded until the process is completed.</simpara>
</listitem>
<listitem>
<simpara>An Operator is performing a migration of custom resources (CRs) that must be completed before the Operator is ready to be upgraded.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Setting the <literal>Upgradeable</literal> Operator condition to the <literal>False</literal> value does not avoid pod disruption. If you must ensure your pods are not disrupted, see "Using pod disruption budgets to specify the number of pods that must be up" and "Graceful termination" in the "Additional resources" section.</simpara>
</important>
<formalpara>
<title>Example <literal>Upgradeable</literal> Operator condition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorCondition
metadata:
  name: my-operator
  namespace: operators
spec:
  conditions:
  - type: Upgradeable <co xml:id="CO4-1"/>
    status: "False" <co xml:id="CO4-2"/>
    reason: "migration"
    message: "The Operator is performing a migration."
    lastTransitionTime: "2020-08-24T23:15:55Z"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>Name of the condition.</para>
</callout>
<callout arearefs="CO4-2">
<para>A <literal>False</literal> value indicates the Operator is not ready to be upgraded. OLM prevents a CSV that replaces the existing CSV of the Operator from leaving the <literal>Pending</literal> phase. A <literal>False</literal> value does not block cluster upgrades.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="olm-operatorconditions-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-managing-operatorconditions.xml#olm-operatorconditions">Managing Operator conditions</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-operatorconditions_osdk-generating-csvs">Enabling Operator conditions</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../nodes/pods/nodes-pods-configuring.xml#nodes-pods-configuring-pod-distruption-about_nodes-pods-configuring">Using pod disruption budgets to specify the number of pods that must be up</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../applications/deployments/route-based-deployment-strategies.xml#deployments-graceful-termination_route-based-deployment-strategies">Graceful termination</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-understanding-metrics">
<title>Operator Lifecycle Manager metrics</title>

<section xml:id="olm-metrics_olm-understanding-metrics">
<title>Exposed metrics</title>
<simpara>Operator Lifecycle Manager (OLM) exposes certain OLM-specific resources for use by the Prometheus-based {product-title} cluster monitoring stack.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Metrics exposed by OLM</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>catalog_source_count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of catalog sources.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>catalogsource_ready</literal></simpara></entry>
<entry align="left" valign="top"><simpara>State of a catalog source. The value <literal>1</literal> indicates that the catalog source is in a <literal>READY</literal> state. The value of <literal>0</literal> indicates that the catalog source is not in a <literal>READY</literal> state.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>csv_abnormal</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When reconciling a cluster service version (CSV), present whenever a CSV version is in any state other than <literal>Succeeded</literal>, for example when it is not installed. Includes the <literal>name</literal>, <literal>namespace</literal>, <literal>phase</literal>, <literal>reason</literal>, and <literal>version</literal> labels. A Prometheus alert is created when this metric is present.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>csv_count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of CSVs successfully registered.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>csv_succeeded</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When reconciling a CSV, represents whether a CSV version is in a <literal>Succeeded</literal> state (value <literal>1</literal>) or not (value <literal>0</literal>). Includes the <literal>name</literal>, <literal>namespace</literal>, and <literal>version</literal> labels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>csv_upgrade_count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Monotonic count of CSV upgrades.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>install_plan_count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of install plans.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>installplan_warnings_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Monotonic count of warnings generated by resources, such as deprecated resources, included in an install plan.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>olm_resolution_duration_seconds</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The duration of a dependency resolution attempt.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>subscription_count</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of subscriptions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>subscription_sync_total</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Monotonic count of subscription syncs. Includes the <literal>channel</literal>, <literal>installed</literal> CSV, and subscription <literal>name</literal> labels.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="olm-webhooks">
<title>Webhook management in Operator Lifecycle Manager</title>

<simpara>Webhooks allow Operator authors to intercept, modify, and accept or reject resources before they are saved to the object store and handled by the Operator controller. Operator Lifecycle Manager (OLM) can manage the lifecycle of these webhooks when they are shipped alongside your Operator.</simpara>
<simpara>See <link xl:href="../../../operators/operator_sdk/osdk-generating-csvs.xml#olm-defining-csv-webhook_osdk-generating-csvs">Defining cluster service versions (CSVs)</link> for details on how an Operator developer can define webhooks for their Operator, as well as considerations when running on OLM.</simpara>
<section xml:id="olm-webhooks-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../architecture/admission-plug-ins.xml#admission-webhook-types_admission-plug-ins">Types of webhook admission plugins</link></simpara>
</listitem>
<listitem>
<simpara>Kubernetes documentation:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">Validating admission webhooks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">Mutating admission webhooks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#webhook-conversion">Conversion webhooks</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="olm-understanding-operatorhub">
<title>Understanding OperatorHub</title>

<section xml:id="olm-operatorhub-overview_olm-understanding-operatorhub">
<title>About OperatorHub</title>
<simpara><emphasis>OperatorHub</emphasis> is the web console interface in {product-title} that cluster administrators use to discover and install Operators. With one click, an Operator can be pulled from its off-cluster source, installed and subscribed on the cluster, and made ready for engineering teams to self-service manage the product across deployment environments using Operator Lifecycle Manager (OLM).</simpara>
<simpara>Cluster administrators can choose from catalogs grouped into the following categories:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Category</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Red Hat Operators</simpara></entry>
<entry align="left" valign="top"><simpara>Red Hat products packaged and shipped by Red Hat. Supported by Red Hat.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Certified Operators</simpara></entry>
<entry align="left" valign="top"><simpara>Products from leading independent software vendors (ISVs). Red Hat partners with ISVs to package and ship. Supported by the ISV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Red Hat Marketplace</simpara></entry>
<entry align="left" valign="top"><simpara>Certified software that can be purchased from <link xl:href="https://marketplace.redhat.com/">Red Hat Marketplace</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Community Operators</simpara></entry>
<entry align="left" valign="top"><simpara>Optionally-visible software maintained by relevant representatives in the <link xl:href="https://github.com/redhat-openshift-ecosystem/community-operators-prod/tree/main/operators">redhat-openshift-ecosystem/community-operators-prod/operators</link> GitHub repository. No official support.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Custom Operators</simpara></entry>
<entry align="left" valign="top"><simpara>Operators you add to the cluster yourself. If you have not added any custom Operators, the <emphasis role="strong">Custom</emphasis> category does not appear in the web console on your OperatorHub.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Operators on OperatorHub are packaged to run on OLM. This includes a YAML file called a cluster service version (CSV) containing all of the CRDs, RBAC rules, deployments, and container images required to install and securely run the Operator. It also contains user-visible information like a description of its features and supported Kubernetes versions.</simpara>
<simpara>The Operator SDK can be used to assist developers packaging their Operators for use on OLM and OperatorHub. If you have a commercial application that you want to make accessible to your customers, get it included using the certification workflow provided on the Red Hat Partner Connect portal at <link xl:href="https://connect.redhat.com">connect.redhat.com</link>.</simpara>
</section>
<section xml:id="olm-operatorhub-arch_olm-understanding-operatorhub">
<title>OperatorHub architecture</title>
<simpara>The OperatorHub UI component is driven by the Marketplace Operator by default on {product-title} in the <literal>openshift-marketplace</literal> namespace.</simpara>
<section xml:id="olm-operatorhub-arch-operatorhub_crd_olm-understanding-operatorhub">
<title>OperatorHub custom resource</title>
<simpara>The Marketplace Operator manages an <literal>OperatorHub</literal> custom resource (CR) named <literal>cluster</literal> that manages the default <literal>CatalogSource</literal> objects provided with OperatorHub.
You can modify this resource to enable or disable the default catalogs, which is useful when configuring {product-title} in restricted network environments.</simpara>
<formalpara>
<title>Example <literal>OperatorHub</literal> custom resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OperatorHub
metadata:
  name: cluster
spec:
  disableAllDefaultSources: true <co xml:id="CO5-1"/>
  sources: [ <co xml:id="CO5-2"/>
    {
      name: "community-operators",
      disabled: false
    }
  ]</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para><literal>disableAllDefaultSources</literal> is an override that controls availability of all default catalogs that are configured by default during an {product-title} installation.</para>
</callout>
<callout arearefs="CO5-2">
<para>Disable default catalogs individually by changing the <literal>disabled</literal> parameter value per source.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="olm-understanding-operatorhub-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource_olm-understanding-olm">Catalog source</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-about.xml#osdk-about">About the Operator SDK</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-generating-csvs">Defining cluster service versions (CSVs)</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-workflow.xml#olm-upgrades_olm-workflow">Operator installation and upgrade workflow in OLM</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://connect.redhat.com">Red Hat Partner Connect</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://marketplace.redhat.com">Red Hat Marketplace</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-rh-catalogs">
<title>Red Hat-provided Operator catalogs</title>

<simpara>Red Hat provides several Operator catalogs that are included with {product-title} by default.</simpara>
<important>
<simpara>As of {product-title} 4.11, the default Red Hat-provided Operator catalog releases in the file-based catalog format. The default Red Hat-provided Operator catalogs for {product-title} 4.6 through 4.10 released in the deprecated SQLite database format.</simpara>
<simpara>The <literal>opm</literal> subcommands, flags, and functionality related to the SQLite database format are also deprecated and will be removed in a future release. The features are still supported and must be used for catalogs that use the deprecated SQLite database format.</simpara>
<simpara>Many of the <literal>opm</literal> subcommands and flags for working with the SQLite database format, such as <literal>opm index prune</literal>, do not work with the file-based catalog format.
For more information about working with file-based catalogs, see <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs">Managing custom catalogs</link>,
<link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">Operator Framework packaging format</link>, and <link xl:href="../../installing/disconnected_install/installing-mirroring-disconnected.xml#installing-mirroring-disconnected">Mirroring images for a disconnected installation using the oc-mirror plugin</link>.</simpara>
</important>
<section xml:id="olm-about-catalogs_olm-rh-catalogs">
<title>About Operator catalogs</title>
<simpara>An Operator catalog is a repository of metadata that Operator Lifecycle Manager (OLM) can query to discover and install Operators and their dependencies on a cluster. OLM always installs Operators from the latest version of a catalog.</simpara>
<simpara>An index image, based on the Operator bundle format, is a containerized snapshot of a catalog. It is an immutable artifact that contains the database of pointers to a set of Operator manifest content. A catalog can reference an index image to source its content for OLM on the cluster.</simpara>
<simpara>As catalogs are updated, the latest versions of Operators change, and older versions may be removed or altered. In addition, when OLM runs on an {product-title} cluster in a restricted network environment, it is unable to access the catalogs directly from the internet to pull the latest content.</simpara>
<simpara>As a cluster administrator, you can create your own custom index image, either based on a Red Hat-provided catalog or from scratch, which can be used to source the catalog content on the cluster. Creating and updating your own index image provides a method for customizing the set of Operators available on the cluster, while also avoiding the aforementioned restricted network environment issues.</simpara>
<important>
<simpara>Kubernetes periodically deprecates certain APIs that are removed in subsequent releases. As a result, Operators are unable to use removed APIs starting with the version of {product-title} that uses the Kubernetes version that removed the API.</simpara>
<simpara>If your cluster is using custom catalogs, see <link xl:href="../../operators/operator_sdk/osdk-working-bundle-images.xml#osdk-control-compat_osdk-working-bundle-images">Controlling Operator compatibility with {product-title} versions</link> for more details about how Operator authors can update their projects to help avoid workload issues and prevent incompatible upgrades.</simpara>
</important>
<note>
<simpara>Support for the legacy <emphasis>package manifest format</emphasis> for Operators, including custom catalogs that were using the legacy format, is removed in {product-title} 4.8 and later.</simpara>
<simpara>When creating custom catalog images, previous versions of {product-title} 4 required using the <literal>oc adm catalog build</literal> command, which was deprecated for several releases and is now removed. With the availability of Red Hat-provided index images starting in {product-title} 4.6, catalog builders must use the <literal>opm index</literal> command to manage index images.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs">Managing custom catalogs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">Packaging format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-rh-catalogs_olm-rh-catalogs">
<title>About Red Hat-provided Operator catalogs</title>
<simpara>The Red Hat-provided catalog sources are installed by default in the <literal>openshift-marketplace</literal> namespace, which makes the catalogs available cluster-wide in all namespaces.</simpara>
<simpara>The following Operator catalogs are distributed by Red Hat:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="55*"/>
<colspec colname="col_3" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Catalog</entry>
<entry align="left" valign="top">Index image</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>redhat-operators</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>registry.redhat.io/redhat/redhat-operator-index:v{product-version}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Red Hat products packaged and shipped by Red Hat. Supported by Red Hat.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>certified-operators</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>registry.redhat.io/redhat/certified-operator-index:v{product-version}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Products from leading independent software vendors (ISVs). Red Hat partners with ISVs to package and ship. Supported by the ISV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>redhat-marketplace</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>registry.redhat.io/redhat/redhat-marketplace-index:v{product-version}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Certified software that can be purchased from <link xl:href="https://marketplace.redhat.com/">Red Hat Marketplace</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>community-operators</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>registry.redhat.io/redhat/community-operator-index:v{product-version}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Software maintained by relevant representatives in the <link xl:href="https://github.com/redhat-openshift-ecosystem/community-operators-prod/tree/main/operators">redhat-openshift-ecosystem/community-operators-prod/operators</link> GitHub repository. No official support.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>During a cluster upgrade, the index image tag for the default Red Hat-provided catalog sources are updated automatically by the Cluster Version Operator (CVO) so that Operator Lifecycle Manager (OLM) pulls the updated version of the catalog. For example during an upgrade from {product-title} 4.8 to 4.9, the <literal>spec.image</literal> field in the <literal>CatalogSource</literal> object for the <literal>redhat-operators</literal> catalog is updated from:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">registry.redhat.io/redhat/redhat-operator-index:v4.8</programlisting>
<simpara>to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">registry.redhat.io/redhat/redhat-operator-index:v4.9</programlisting>
</section>
</section>
<section xml:id="olm-multitenancy">
<title>Operators in multitenant clusters</title>

<simpara>The default behavior for Operator Lifecycle Manager (OLM) aims to provide simplicity during Operator installation. However, this behavior can lack flexibility, especially in multitenant clusters. In order for multiple tenants on a {product-title} cluster to use an Operator, the default behavior of OLM requires that administrators install the Operator in <emphasis role="strong">All namespaces</emphasis> mode, which can be considered to violate the principle of least privilege.</simpara>
<simpara>Consider the following scenarios to determine which Operator installation workflow works best for your environment and requirements.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-common-terms.xml#olm-common-terms-multitenancy_olm-common-terms">Common terms: Multitenant</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-operatorgroups-limitations">Limitations for multitenant Operator management</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-default-install-modes-behavior_olm-multitenancy">
<title>Default Operator install modes and behavior</title>
<simpara>When installing Operators with the web console as an administrator, you typically have two choices for the install mode, depending on the Operator&#8217;s capabilities:</simpara>
<variablelist>
<varlistentry>
<term>Single namespace</term>
<listitem>
<simpara>Installs the Operator in the chosen single namespace, and makes all permissions that the Operator requests available in that namespace.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>All namespaces</term>
<listitem>
<simpara>Installs the Operator in the default <literal>openshift-operators</literal> namespace to watch and be made available to all namespaces in the cluster. Makes all permissions that the Operator requests available in all namespaces. In some cases, an Operator author can define metadata to give the user a second option for that Operator&#8217;s suggested namespace.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This choice also means that users in the affected namespaces get access to the Operators APIs, which can leverage the custom resources (CRs) they own, depending on their role in the namespace:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>namespace-admin</literal> and <literal>namespace-edit</literal> roles can read/write to the Operator APIs, meaning they can use them.</simpara>
</listitem>
<listitem>
<simpara>The <literal>namespace-view</literal> role can read CR objects of that Operator.</simpara>
</listitem>
</itemizedlist>
<simpara>For <emphasis role="strong">Single namespace</emphasis> mode, because the Operator itself installs in the chosen namespace, its pod and service account are also located there. For <emphasis role="strong">All namespaces</emphasis> mode, the Operator&#8217;s privileges are all automatically elevated to cluster roles, meaning the Operator has those permissions in all namespaces.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-adding-operators-to-a-cluster">Adding Operators to a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-operatorgroups-membership_olm-understanding-operatorgroups">Install modes types</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-suggested-namespace_osdk-generating-csvs">Setting a suggested namespace</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-multitenancy-solution_olm-multitenancy">
<title>Recommended solution for multitenant clusters</title>
<simpara>While a <emphasis role="strong">Multinamespace</emphasis> install mode does exist, it is supported by very few Operators. As a middle ground solution between the standard <emphasis role="strong">All namespaces</emphasis> and <emphasis role="strong">Single namespace</emphasis> install modes, you can install multiple instances of the same Operator, one for each tenant, by using the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a namespace for the tenant Operator that is separate from the tenant&#8217;s namespace.</simpara>
</listitem>
<listitem>
<simpara>Create an Operator group for the tenant Operator scoped only to the tenant&#8217;s namespace.</simpara>
</listitem>
<listitem>
<simpara>Install the Operator in the tenant Operator namespace.</simpara>
</listitem>
</orderedlist>
<simpara>As a result, the Operator resides in the tenant Operator namespace and watches the tenant namespace, but neither the Operator&#8217;s pod nor its service account are visible or usable by the tenant.</simpara>
<simpara>This solution provides better tenant separation, least privilege principle at the cost of resource usage, and additional orchestration to ensure the constraints are met. For a detailed procedure, see "Preparing for multiple instances of an Operator for multitenant clusters".</simpara>
<formalpara>
<title>Limitations and considerations</title>
<para>This solution only works when the following constraints are met:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>All instances of the same Operator must be the same version.</simpara>
</listitem>
<listitem>
<simpara>The Operator cannot have dependencies on other Operators.</simpara>
</listitem>
<listitem>
<simpara>The Operator cannot ship a CRD conversion webhook.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>You cannot use different versions of the same Operator on the same cluster. Eventually, the installation of another instance of the Operator would be blocked when it meets the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>The instance is not the newest version of the Operator.</simpara>
</listitem>
<listitem>
<simpara>The instance ships an older revision of the CRDs that lack information or versions that newer revisions have that are already in use on the cluster.</simpara>
</listitem>
</itemizedlist>
</important>
<warning>
<simpara>As an administrator, use caution when allowing non-cluster administrators to install Operators self-sufficiently, as explained in "Allowing non-cluster administrators to install Operators". These tenants should only have access to a curated catalog of Operators that are known to not have dependencies. These tenants must also be forced to use the same version line of an Operator, to ensure the CRDs do not change. This requires the use of namespace-scoped catalogs and likely disabling the global default catalogs.</simpara>
</warning>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-preparing-operators-multitenant_olm-adding-operators-to-a-cluster">Preparing for multiple instances of an Operator for multitenant clusters</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-creating-policy.xml#olm-creating-policy">Allowing non-cluster administrators to install Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-restricted-networks-operatorhub_olm-managing-custom-catalogs">Disabling the default OperatorHub catalog sources</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-colocation_olm-multitenancy">
<title>Operator colocation and Operator groups</title>
<simpara>Operator Lifecycle Manager (OLM) handles OLM-managed Operators that are installed in the same namespace, meaning their <literal>Subscription</literal> resources are colocated in the same namespace, as related Operators. Even if they are not actually related, OLM considers their states, such as their version and update policy, when any one of them is updated.</simpara>
<simpara>For more information on Operator colocation and using Operator groups effectively, see <link xl:href="../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Operator Lifecycle Manager (OLM) &#8594; Multitenancy and Operator colocation</link>.</simpara>
</section>
</section>
<section xml:id="_crds">
<title>CRDs</title>
<section xml:id="crd-extending-api-with-crds">
<title>Extending the Kubernetes API with custom resource definitions</title>

<simpara>Operators use the Kubernetes extension mechanism, custom resource definitions (CRDs), so that custom objects managed by the Operator look and act just like the built-in, native Kubernetes objects. This guide describes how cluster administrators can extend their {product-title} cluster by creating and managing CRDs.</simpara>
<section xml:id="crd-custom-resource-definitions_crd-extending-api-with-crds">
<title>Custom resource definitions</title>
<simpara>In the Kubernetes API, a <emphasis>resource</emphasis> is an endpoint that stores a collection of API objects of a certain kind. For example, the built-in <literal>Pods</literal> resource contains a collection of <literal>Pod</literal> objects.</simpara>
<simpara>A <emphasis>custom resource definition</emphasis> (CRD) object defines a new, unique object type, called a <emphasis>kind</emphasis>, in the cluster and lets the Kubernetes API server handle its entire lifecycle.</simpara>
<simpara><emphasis>Custom resource</emphasis> (CR) objects are created from CRDs that have been added to the cluster by a cluster administrator, allowing all cluster users to add the new resource type into projects.</simpara>
<simpara>When a cluster administrator adds a new CRD to the cluster, the Kubernetes API server reacts by creating a new RESTful resource path that can be accessed by the entire cluster or a single project (namespace) and begins serving the specified CR.</simpara>
<simpara>Cluster administrators that want to grant access to the CRD to other users can use cluster role aggregation to grant access to users with the <literal>admin</literal>, <literal>edit</literal>, or <literal>view</literal> default cluster roles. Cluster role aggregation allows the insertion of custom policy rules into these cluster roles. This behavior integrates the new resource into the RBAC policy of the cluster as if it was a built-in resource.</simpara>
<simpara>Operators in particular make use of CRDs by packaging them with any required RBAC policy and other software-specific logic.
Cluster administrators can also add CRDs manually to the cluster outside of the lifecycle of an Operator, making them available to all users.</simpara>
<note>
<simpara>While only cluster administrators can create CRDs, developers can create the CR from an existing CRD if they have read and write permission to it.</simpara>
</note>
</section>
<section xml:id="crd-creating-custom-resources-definition_crd-extending-api-with-crds">
<title>Creating a custom resource definition</title>
<simpara>To create custom resource (CR) objects, cluster administrators must first create a custom resource definition (CRD).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster with <literal>cluster-admin</literal> user privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To create a CRD:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a YAML file that contains the following field types:</simpara>
<formalpara>
<title>Example YAML file for a CRD</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apiextensions.k8s.io/v1 <co xml:id="CO6-1"/>
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com <co xml:id="CO6-2"/>
spec:
  group: stable.example.com <co xml:id="CO6-3"/>
  versions:
    name: v1 <co xml:id="CO6-4"/>
  scope: Namespaced <co xml:id="CO6-5"/>
  names:
    plural: crontabs <co xml:id="CO6-6"/>
    singular: crontab <co xml:id="CO6-7"/>
    kind: CronTab <co xml:id="CO6-8"/>
    shortNames:
    - ct <co xml:id="CO6-9"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO6-1">
<para>Use the <literal>apiextensions.k8s.io/v1</literal> API.</para>
</callout>
<callout arearefs="CO6-2">
<para>Specify a name for the definition. This must be in the <literal>&lt;plural-name&gt;.&lt;group&gt;</literal> format using the values from the <literal>group</literal> and <literal>plural</literal> fields.</para>
</callout>
<callout arearefs="CO6-3">
<para>Specify a group name for the API. An API group is a collection of objects that are logically related. For example, all batch objects like <literal>Job</literal> or <literal>ScheduledJob</literal> could be in the batch API group (such as <literal>batch.api.example.com</literal>). A good practice is to use a fully-qualified-domain name (FQDN) of your organization.</para>
</callout>
<callout arearefs="CO6-4">
<para>Specify a version name to be used in the URL. Each API group can exist in multiple versions, for example <literal>v1alpha</literal>, <literal>v1beta</literal>, <literal>v1</literal>.</para>
</callout>
<callout arearefs="CO6-5">
<para>Specify whether the custom objects are available to a project (<literal>Namespaced</literal>) or all projects in the cluster (<literal>Cluster</literal>).</para>
</callout>
<callout arearefs="CO6-6">
<para>Specify the plural name to use in the URL. The <literal>plural</literal> field is the same as a resource in an API URL.</para>
</callout>
<callout arearefs="CO6-7">
<para>Specify a singular name to use as an alias on the CLI and for display.</para>
</callout>
<callout arearefs="CO6-8">
<para>Specify the kind of objects that can be created. The type can be in CamelCase.</para>
</callout>
<callout arearefs="CO6-9">
<para>Specify a shorter string to match your resource on the CLI.</para>
</callout>
</calloutlist>
<note>
<simpara>By default, a CRD is cluster-scoped and available to all projects.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the CRD object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
<simpara>A new RESTful API endpoint is created at:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/apis/&lt;spec:group&gt;/&lt;spec:version&gt;/&lt;scope&gt;/*/&lt;names-plural&gt;/...</programlisting>
<simpara>For example, using the example file, the following endpoint is created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/apis/stable.example.com/v1/namespaces/*/crontabs/...</programlisting>
<simpara>You can now use this endpoint URL to create and manage CRs. The object kind is based on the <literal>spec.kind</literal> field of the CRD object you created.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="crd-creating-aggregated-cluster-role_crd-extending-api-with-crds">
<title>Creating cluster roles for custom resource definitions</title>
<simpara>Cluster administrators can grant permissions to existing cluster-scoped custom resource definitions (CRDs). If you use the <literal>admin</literal>, <literal>edit</literal>, and <literal>view</literal> default cluster roles, you can take advantage of cluster role aggregation for their rules.</simpara>
<important>
<simpara>You must explicitly assign permissions to each of these roles. The roles with more permissions do not inherit rules from roles with fewer permissions. If you assign a rule to a role, you must also assign that verb to roles that have more permissions. For example, if you grant the <literal>get crontabs</literal> permission to the view role, you must also grant it to the <literal>edit</literal> and <literal>admin</literal> roles. The <literal>admin</literal> or <literal>edit</literal> role is usually assigned to the user that created a project through the project template.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a CRD.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a cluster role definition file for the CRD. The cluster role definition is a YAML file that contains the rules that apply to each cluster role. An {product-title} controller adds the rules that you specify to the default cluster roles.</simpara>
<formalpara>
<title>Example YAML file for a cluster role definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1 <co xml:id="CO7-1"/>
metadata:
  name: aggregate-cron-tabs-admin-edit <co xml:id="CO7-2"/>
  labels:
    rbac.authorization.k8s.io/aggregate-to-admin: "true" <co xml:id="CO7-3"/>
    rbac.authorization.k8s.io/aggregate-to-edit: "true" <co xml:id="CO7-4"/>
rules:
- apiGroups: ["stable.example.com"] <co xml:id="CO7-5"/>
  resources: ["crontabs"] <co xml:id="CO7-6"/>
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete", "deletecollection"] <co xml:id="CO7-7"/>
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: aggregate-cron-tabs-view <co xml:id="CO7-8"/>
  labels:
    # Add these permissions to the "view" default role.
    rbac.authorization.k8s.io/aggregate-to-view: "true" <co xml:id="CO7-9"/>
    rbac.authorization.k8s.io/aggregate-to-cluster-reader: "true" <co xml:id="CO7-10"/>
rules:
- apiGroups: ["stable.example.com"] <co xml:id="CO7-11"/>
  resources: ["crontabs"] <co xml:id="CO7-12"/>
  verbs: ["get", "list", "watch"] <co xml:id="CO7-13"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para>Use the <literal>rbac.authorization.k8s.io/v1</literal> API.</para>
</callout>
<callout arearefs="CO7-2 CO7-8">
<para>Specify a name for the definition.</para>
</callout>
<callout arearefs="CO7-3">
<para>Specify this label to grant permissions to the admin default role.</para>
</callout>
<callout arearefs="CO7-4">
<para>Specify this label to grant permissions to the edit default role.</para>
</callout>
<callout arearefs="CO7-5 CO7-11">
<para>Specify the group name of the CRD.</para>
</callout>
<callout arearefs="CO7-6 CO7-12">
<para>Specify the plural name of the CRD that these rules apply to.</para>
</callout>
<callout arearefs="CO7-7 CO7-13">
<para>Specify the verbs that represent the permissions that are granted to the role. For example, apply read and write permissions to the <literal>admin</literal> and <literal>edit</literal> roles and only read permission to the <literal>view</literal> role.</para>
</callout>
<callout arearefs="CO7-9">
<para>Specify this label to grant permissions to the <literal>view</literal> default role.</para>
</callout>
<callout arearefs="CO7-10">
<para>Specify this label to grant permissions to the <literal>cluster-reader</literal> default role.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the cluster role:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="crd-creating-custom-resources-from-file_crd-extending-api-with-crds">
<title>Creating custom resources from a file</title>
<simpara>After a custom resource definition (CRD) has been added to the cluster, custom resources (CRs) can be created with the CLI from a file using the CR specification.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>CRD added to the cluster by a cluster administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file for the CR. In the following example definition, the <literal>cronSpec</literal> and <literal>image</literal> custom fields are set in a CR of <literal>Kind: CronTab</literal>. The <literal>Kind</literal> comes from the <literal>spec.kind</literal> field of the CRD object:</simpara>
<formalpara>
<title>Example YAML file for a CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "stable.example.com/v1" <co xml:id="CO8-1"/>
kind: CronTab <co xml:id="CO8-2"/>
metadata:
  name: my-new-cron-object <co xml:id="CO8-3"/>
  finalizers: <co xml:id="CO8-4"/>
  - finalizer.stable.example.com
spec: <co xml:id="CO8-5"/>
  cronSpec: "* * * * /5"
  image: my-awesome-cron-image</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<para>Specify the group name and API version (name/version) from the CRD.</para>
</callout>
<callout arearefs="CO8-2">
<para>Specify the type in the CRD.</para>
</callout>
<callout arearefs="CO8-3">
<para>Specify a name for the object.</para>
</callout>
<callout arearefs="CO8-4">
<para>Specify the <link xl:href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#finalizers">finalizers</link> for the object, if any. Finalizers allow controllers to implement conditions that must be completed before the object can be deleted.</para>
</callout>
<callout arearefs="CO8-5">
<para>Specify conditions specific to the type of object.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After you create the file, create the object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="crd-inspecting-custom-resources_crd-extending-api-with-crds">
<title>Inspecting custom resources</title>
<simpara>You can inspect custom resource (CR) objects that exist in your cluster using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A CR object exists in a namespace to which you have access.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To get information on a specific kind of a CR, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontab</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 KIND
my-new-cron-object   CronTab.v1.stable.example.com</programlisting>
</para>
</formalpara>
<simpara>Resource names are not case-sensitive, and you can use either the singular or plural forms defined in the CRD, as well as any short name. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontabs</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontab</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ct</programlisting>
</listitem>
<listitem>
<simpara>You can also view the raw YAML data for a CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ct -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
items:
- apiVersion: stable.example.com/v1
  kind: CronTab
  metadata:
    clusterName: ""
    creationTimestamp: 2017-05-31T12:56:35Z
    deletionGracePeriodSeconds: null
    deletionTimestamp: null
    name: my-new-cron-object
    namespace: default
    resourceVersion: "285"
    selfLink: /apis/stable.example.com/v1/namespaces/default/crontabs/my-new-cron-object
    uid: 9423255b-4600-11e7-af6a-28d2447dc82b
  spec:
    cronSpec: '* * * * /5' <co xml:id="CO9-1"/>
    image: my-awesome-cron-image <co xml:id="CO9-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1 CO9-2">
<para>Custom data from the YAML that you used to create the object displays.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="crd-managing-resources-from-crds">
<title>Managing resources from custom resource definitions</title>

<simpara>This guide describes how developers can manage custom resources (CRs) that come from custom resource definitions (CRDs).</simpara>
<section xml:id="crd-custom-resource-definitions_crd-managing-resources-from-crds">
<title>Custom resource definitions</title>
<simpara>In the Kubernetes API, a <emphasis>resource</emphasis> is an endpoint that stores a collection of API objects of a certain kind. For example, the built-in <literal>Pods</literal> resource contains a collection of <literal>Pod</literal> objects.</simpara>
<simpara>A <emphasis>custom resource definition</emphasis> (CRD) object defines a new, unique object type, called a <emphasis>kind</emphasis>, in the cluster and lets the Kubernetes API server handle its entire lifecycle.</simpara>
<simpara><emphasis>Custom resource</emphasis> (CR) objects are created from CRDs that have been added to the cluster by a cluster administrator, allowing all cluster users to add the new resource type into projects.</simpara>
<simpara>Operators in particular make use of CRDs by packaging them with any required RBAC policy and other software-specific logic.
Cluster administrators can also add CRDs manually to the cluster outside of the lifecycle of an Operator, making them available to all users.</simpara>
<note>
<simpara>While only cluster administrators can create CRDs, developers can create the CR from an existing CRD if they have read and write permission to it.</simpara>
</note>
</section>
<section xml:id="crd-creating-custom-resources-from-file_crd-managing-resources-from-crds">
<title>Creating custom resources from a file</title>
<simpara>After a custom resource definition (CRD) has been added to the cluster, custom resources (CRs) can be created with the CLI from a file using the CR specification.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>CRD added to the cluster by a cluster administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file for the CR. In the following example definition, the <literal>cronSpec</literal> and <literal>image</literal> custom fields are set in a CR of <literal>Kind: CronTab</literal>. The <literal>Kind</literal> comes from the <literal>spec.kind</literal> field of the CRD object:</simpara>
<formalpara>
<title>Example YAML file for a CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "stable.example.com/v1" <co xml:id="CO10-1"/>
kind: CronTab <co xml:id="CO10-2"/>
metadata:
  name: my-new-cron-object <co xml:id="CO10-3"/>
  finalizers: <co xml:id="CO10-4"/>
  - finalizer.stable.example.com
spec: <co xml:id="CO10-5"/>
  cronSpec: "* * * * /5"
  image: my-awesome-cron-image</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>Specify the group name and API version (name/version) from the CRD.</para>
</callout>
<callout arearefs="CO10-2">
<para>Specify the type in the CRD.</para>
</callout>
<callout arearefs="CO10-3">
<para>Specify a name for the object.</para>
</callout>
<callout arearefs="CO10-4">
<para>Specify the <link xl:href="https://kubernetes.io/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#finalizers">finalizers</link> for the object, if any. Finalizers allow controllers to implement conditions that must be completed before the object can be deleted.</para>
</callout>
<callout arearefs="CO10-5">
<para>Specify conditions specific to the type of object.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After you create the file, create the object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="crd-inspecting-custom-resources_crd-managing-resources-from-crds">
<title>Inspecting custom resources</title>
<simpara>You can inspect custom resource (CR) objects that exist in your cluster using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A CR object exists in a namespace to which you have access.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To get information on a specific kind of a CR, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontab</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 KIND
my-new-cron-object   CronTab.v1.stable.example.com</programlisting>
</para>
</formalpara>
<simpara>Resource names are not case-sensitive, and you can use either the singular or plural forms defined in the CRD, as well as any short name. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontabs</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crontab</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ct</programlisting>
</listitem>
<listitem>
<simpara>You can also view the raw YAML data for a CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get &lt;kind&gt; -o yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ct -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: v1
items:
- apiVersion: stable.example.com/v1
  kind: CronTab
  metadata:
    clusterName: ""
    creationTimestamp: 2017-05-31T12:56:35Z
    deletionGracePeriodSeconds: null
    deletionTimestamp: null
    name: my-new-cron-object
    namespace: default
    resourceVersion: "285"
    selfLink: /apis/stable.example.com/v1/namespaces/default/crontabs/my-new-cron-object
    uid: 9423255b-4600-11e7-af6a-28d2447dc82b
  spec:
    cronSpec: '* * * * /5' <co xml:id="CO11-1"/>
    image: my-awesome-cron-image <co xml:id="CO11-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO11-1 CO11-2">
<para>Custom data from the YAML that you used to create the object displays.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_user_tasks">
<title>User tasks</title>
<section xml:id="olm-creating-apps-from-installed-operators">
<title>Creating applications from installed Operators</title>

<simpara>This guide walks developers through an example of creating applications from an installed Operator using the {product-title} web console.</simpara>
<section xml:id="olm-creating-etcd-cluster-from-operator_olm-creating-apps-from-installed-operators">
<title>Creating an etcd cluster using an Operator</title>
<simpara>This procedure walks through creating a new etcd cluster using the etcd Operator, managed by Operator Lifecycle Manager (OLM).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} {product-version} cluster.</simpara>
</listitem>
<listitem>
<simpara>The etcd Operator already installed cluster-wide by an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new project in the {product-title} web console for this procedure. This example uses a project called <literal>my-etcd</literal>.</simpara>
</listitem>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page. The Operators that have been installed to the cluster by the
cluster administrator
and are available for use are shown here as a list of cluster service versions (CSVs). CSVs are used to launch and manage the software provided by the Operator.</simpara>
<tip>
<simpara>You can get this list from the CLI using:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv</programlisting>
</tip>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, click the etcd Operator to view more details and available actions.</simpara>
<simpara>As shown under <emphasis role="strong">Provided APIs</emphasis>, this Operator makes available three new resource types, including one for an <emphasis role="strong">etcd Cluster</emphasis> (the <literal>EtcdCluster</literal> resource). These objects work similar to the built-in native Kubernetes ones, such as <literal>Deployment</literal> or <literal>ReplicaSet</literal>, but contain logic specific to managing etcd.</simpara>
</listitem>
<listitem>
<simpara>Create a new etcd cluster:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis role="strong">etcd Cluster</emphasis> API box, click <emphasis role="strong">Create instance</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>The next page allows you to make any modifications to the minimal starting template of an <literal>EtcdCluster</literal> object, such as the size of the cluster. For now, click <emphasis role="strong">Create</emphasis> to finalize. This triggers the Operator to start up the pods, services, and other components of the new etcd cluster.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">example</emphasis> etcd cluster, then click the <emphasis role="strong">Resources</emphasis> tab to see that your project now contains a number of resources created and configured automatically by the Operator.</simpara>
<simpara>Verify that a Kubernetes service has been created that allows you to access the database from other pods in your project.</simpara>
</listitem>
<listitem>
<simpara>All users with the <literal>edit</literal> role in a given project can create, manage, and delete application instances (an etcd cluster, in this example) managed by Operators that have already been created in the project, in a self-service manner, just like a cloud service. If you want to enable additional users with this ability, project administrators can add the role using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user edit &lt;user&gt; -n &lt;target_project&gt;</programlisting>
</listitem>
</orderedlist>
<simpara>You now have an etcd cluster that will react to failures and rebalance data as pods become unhealthy or are migrated between nodes in the cluster. Most importantly,
cluster administrators
or developers with proper access can now easily use the database with their applications.</simpara>
</section>
</section>
<section xml:id="olm-installing-operators-in-namespace">
<title>Installing Operators in your namespace</title>

<simpara>If a cluster administrator has delegated Operator installation permissions to your account, you can install and subscribe an Operator to your namespace in a self-service manner.</simpara>
<section xml:id="olm-installing-operators-in-namespace-prereqs">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>A cluster administrator must add certain permissions to your {product-title} user account to allow self-service Operator installation to a namespace. See <link xl:href="../../operators/admin/olm-creating-policy.xml#olm-creating-policy">Allowing non-cluster administrators to install Operators</link> for details.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-operators-from-operatorhub_olm-installing-operators-in-namespace">
<title>About Operator installation with OperatorHub</title>
<simpara>OperatorHub is a user interface for discovering Operators; it works in conjunction with Operator Lifecycle Manager (OLM), which installs and manages Operators on a cluster.</simpara>
<simpara>As a user with the proper permissions, you can install an Operator from OperatorHub by using the {product-title} web console or CLI.</simpara>
<simpara>During installation, you must determine the following initial settings for the Operator:</simpara>
<variablelist>
<varlistentry>
<term>Installation Mode</term>
<listitem>
<simpara>Choose a specific namespace in which to install the Operator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Update Channel</term>
<listitem>
<simpara>If an Operator is available through multiple channels, you can choose which channel you want to subscribe to. For example, to deploy from the <emphasis role="strong">stable</emphasis> channel, if available, select it from the list.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Approval Strategy</term>
<listitem>
<simpara>You can choose automatic or manual updates.</simpara>
<simpara>If you choose automatic updates for an installed Operator, when a new version of that Operator is available in the selected channel, Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention.</simpara>
<simpara>If you select manual updates, when a newer version of an Operator is available, OLM creates an update request. As a
cluster administrator,
you must then manually approve that update request to have the Operator updated to the new version.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-understanding-operatorhub.xml#olm-understanding-operatorhub">Understanding OperatorHub</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-from-operatorhub-using-web-console_olm-installing-operators-in-namespace">
<title>Installing from OperatorHub using the web console</title>
<simpara>You can install and subscribe to an Operator from OperatorHub by using the {product-title} web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate in the web console to the <emphasis role="strong">Operators → OperatorHub</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Scroll or type a keyword into the <emphasis role="strong">Filter by keyword</emphasis> box to find the Operator you want. For example, type <literal>advanced</literal> to find the Advanced Cluster Management for Kubernetes Operator.</simpara>
<simpara>You can also filter options by <emphasis role="strong">Infrastructure Features</emphasis>. For example, select <emphasis role="strong">Disconnected</emphasis> if you want to see Operators that work in disconnected environments, also known as restricted network environments.</simpara>
</listitem>
<listitem>
<simpara>Select the Operator to display additional information.</simpara>
<note>
<simpara>Choosing a Community Operator warns that Red Hat does not certify Community Operators; you must acknowledge the warning before continuing.</simpara>
</note>
</listitem>
<listitem>
<simpara>Read the information about the Operator and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Choose a specific, single namespace in which to install the Operator. The Operator will only watch and be made available for use in this single namespace.</simpara>
</listitem>
<listitem>
<simpara>If the cluster is in AWS STS mode, enter the Amazon Resource Name (ARN) of the AWS IAM role of your service account in the <emphasis role="strong">role ARN</emphasis> field.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/oadp-install-operator-role-arn.png"/>
</imageobject>
<textobject><phrase>Entering the ARN</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To create the role&#8217;s ARN, follow the procedure described in <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_openshift_service_on_aws/4/html/tutorials/cloud-experts-deploy-api-data-protection#prepare-aws-account_cloud-experts-deploy-api-data-protection">Preparing AWS account</link>.</simpara>
</listitem>
<listitem>
<simpara>If more than one update channel is available, select an <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Automatic</emphasis> or <emphasis role="strong">Manual</emphasis> approval strategy, as described earlier.</simpara>
<important>
<simpara>If the web console shows that the cluster is in "STS mode", you must set <emphasis role="strong">Update approval</emphasis> to <emphasis role="strong">Manual</emphasis>.</simpara>
<simpara>Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis> to make the Operator available to the selected namespaces on this {product-title} cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you selected a <emphasis role="strong">Manual</emphasis> approval strategy, the upgrade status of the subscription remains <emphasis role="strong">Upgrading</emphasis> until you review and approve the install plan.</simpara>
<simpara>After approving on the <emphasis role="strong">Install Plan</emphasis> page, the subscription upgrade status moves to <emphasis role="strong">Up to date</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If you selected an <emphasis role="strong">Automatic</emphasis> approval strategy, the upgrade status should resolve to <emphasis role="strong">Up to date</emphasis> without intervention.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After the upgrade status of the subscription is <emphasis role="strong">Up to date</emphasis>, select <emphasis role="strong">Operators → Installed Operators</emphasis> to verify that the cluster service version (CSV) of the installed Operator eventually shows up. The <emphasis role="strong">Status</emphasis> should ultimately resolve to <emphasis role="strong">InstallSucceeded</emphasis> in the relevant namespace.</simpara>
<note>
<simpara>For the <emphasis role="strong">All namespaces&#8230;&#8203;</emphasis> installation mode, the status resolves to <emphasis role="strong">InstallSucceeded</emphasis> in the <literal>openshift-operators</literal> namespace, but the status is <emphasis role="strong">Copied</emphasis> if you check in other namespaces.</simpara>
</note>
<simpara>If it does not:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the logs in any pods in the <literal>openshift-operators</literal> project (or other relevant namespace if <emphasis role="strong">A specific namespace&#8230;&#8203;</emphasis> installation mode was selected) on the <emphasis role="strong">Workloads → Pods</emphasis> page that are reporting issues to troubleshoot further.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-installing-operator-from-operatorhub-using-cli_olm-installing-operators-in-namespace">
<title>Installing from OperatorHub using the CLI</title>
<simpara>Instead of using the {product-title} web console, you can install an Operator from OperatorHub by using the CLI. Use the <literal>oc</literal> command to create or update a <literal>Subscription</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the list of Operators available to the cluster from OperatorHub:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                               CATALOG               AGE
3scale-operator                    Red Hat Operators     91m
advanced-cluster-management        Red Hat Operators     91m
amq7-cert-manager                  Red Hat Operators     91m
...
couchbase-enterprise-certified     Certified Operators   91m
crunchy-postgres-operator          Certified Operators   91m
mongodb-enterprise                 Certified Operators   91m
...
etcd                               Community Operators   91m
jaeger                             Community Operators   91m
kubefed                            Community Operators   91m
...</programlisting>
</para>
</formalpara>
<simpara>Note the catalog for your desired Operator.</simpara>
</listitem>
<listitem>
<simpara>Inspect your desired Operator to verify its supported install modes and available channels:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests &lt;operator_name&gt; -n openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>An Operator group, defined by an <literal>OperatorGroup</literal> object, selects target namespaces in which to generate required RBAC access for all Operators in the same namespace as the Operator group.</simpara>
<simpara>The namespace to which you subscribe the Operator must have an Operator group that matches the install mode of the Operator, either the <literal>AllNamespaces</literal> or <literal>SingleNamespace</literal> mode. If the Operator you intend to install uses the <literal>AllNamespaces</literal>, then the <literal>openshift-operators</literal> namespace already has an appropriate Operator group in place.</simpara>
<simpara>However, if the Operator uses the <literal>SingleNamespace</literal> mode and you do not already have an appropriate Operator group in place, you must create one.</simpara>
<note>
<simpara>The web console version of this procedure handles the creation of the <literal>OperatorGroup</literal> and <literal>Subscription</literal> objects automatically behind the scenes for you when choosing <literal>SingleNamespace</literal> mode.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file, for example <literal>operatorgroup.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>OperatorGroup</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: &lt;operatorgroup_name&gt;
  namespace: &lt;namespace&gt;
spec:
  targetNamespaces:
  - &lt;namespace&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file to subscribe a namespace to an Operator, for example <literal>sub.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>Subscription</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: &lt;subscription_name&gt;
  namespace: openshift-operators <co xml:id="CO12-1"/>
spec:
  channel: &lt;channel_name&gt; <co xml:id="CO12-2"/>
  name: &lt;operator_name&gt; <co xml:id="CO12-3"/>
  source: redhat-operators <co xml:id="CO12-4"/>
  sourceNamespace: openshift-marketplace <co xml:id="CO12-5"/>
  config:
    env: <co xml:id="CO12-6"/>
    - name: ARGS
      value: "-v=10"
    envFrom: <co xml:id="CO12-7"/>
    - secretRef:
        name: license-secret
    volumes: <co xml:id="CO12-8"/>
    - name: &lt;volume_name&gt;
      configMap:
        name: &lt;configmap_name&gt;
    volumeMounts: <co xml:id="CO12-9"/>
    - mountPath: &lt;directory_name&gt;
      name: &lt;volume_name&gt;
    tolerations: <co xml:id="CO12-10"/>
    - operator: "Exists"
    resources: <co xml:id="CO12-11"/>
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    nodeSelector: <co xml:id="CO12-12"/>
      foo: bar</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>For default <literal>AllNamespaces</literal> install mode usage, specify the <literal>openshift-operators</literal> namespace. Alternatively, you can specify a custom global namespace, if you have created one. Otherwise, specify the relevant single namespace for <literal>SingleNamespace</literal> install mode usage.</para>
</callout>
<callout arearefs="CO12-2">
<para>Name of the channel to subscribe to.</para>
</callout>
<callout arearefs="CO12-3">
<para>Name of the Operator to subscribe to.</para>
</callout>
<callout arearefs="CO12-4">
<para>Name of the catalog source that provides the Operator.</para>
</callout>
<callout arearefs="CO12-5">
<para>Namespace of the catalog source. Use <literal>openshift-marketplace</literal> for the default OperatorHub catalog sources.</para>
</callout>
<callout arearefs="CO12-6">
<para>The <literal>env</literal> parameter defines a list of Environment Variables that must exist in all containers in the pod created by OLM.</para>
</callout>
<callout arearefs="CO12-7">
<para>The <literal>envFrom</literal> parameter defines a list of sources to populate Environment Variables in the container.</para>
</callout>
<callout arearefs="CO12-8">
<para>The <literal>volumes</literal> parameter defines a list of Volumes that must exist on the pod created by OLM.</para>
</callout>
<callout arearefs="CO12-9">
<para>The <literal>volumeMounts</literal> parameter defines a list of volume mounts that must exist in all containers in the pod created by OLM. If a <literal>volumeMount</literal> references a <literal>volume</literal> that does not exist, OLM fails to deploy the Operator.</para>
</callout>
<callout arearefs="CO12-10">
<para>The <literal>tolerations</literal> parameter defines a list of Tolerations for the pod created by OLM.</para>
</callout>
<callout arearefs="CO12-11">
<para>The <literal>resources</literal> parameter defines resource constraints for all the containers in the pod created by OLM.</para>
</callout>
<callout arearefs="CO12-12">
<para>The <literal>nodeSelector</literal> parameter defines a <literal>NodeSelector</literal> for the pod created by OLM.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If the cluster is in STS mode, include the following fields in the <literal>Subscription</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Subscription
# ...
spec:
  installPlanApproval: Manual <co xml:id="CO13-1"/>
  config:
    env:
    - name: ROLEARN
      value: "&lt;role_arn&gt;" <co xml:id="CO13-2"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.</para>
</callout>
<callout arearefs="CO13-2">
<para>Include the role ARN details.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sub.yaml</programlisting>
<simpara>At this point, OLM is now aware of the selected Operator. A cluster service version (CSV) for the Operator should appear in the target namespace, and APIs provided by the Operator should be available for creation.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-operatorgroups-about_olm-understanding-olm">Operator groups</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-subscription_olm-understanding-olm">Channel names</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-specific-version-cli_olm-installing-operators-in-namespace">
<title>Installing a specific version of an Operator</title>
<simpara>You can install a specific version of an Operator by setting the cluster service version (CSV) in a <literal>Subscription</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Look up the available versions and channels of the Operator you want to install by running the following command:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests &lt;operator_name&gt; -n &lt;catalog_namespace&gt;</programlisting>
</para>
</formalpara>
<simpara>For example, the following command prints the available channels and versions of the Red Hat Quay Operator from OperatorHub:</simpara>
<formalpara>
<title>Example command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests quay-operator -n openshift-marketplace</programlisting>
</para>
</formalpara>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">Name:         quay-operator
Namespace:    operator-marketplace
Labels:       catalog=redhat-operators
              catalog-namespace=openshift-marketplace
              hypershift.openshift.io/managed=true
              operatorframework.io/arch.amd64=supported
              operatorframework.io/os.linux=supported
              provider=Red Hat
              provider-url=
Annotations:  &lt;none&gt;
API Version:  packages.operators.coreos.com/v1
Kind:         PackageManifest
...
    Current CSV:  quay-operator.v3.7.11
...
    Entries:
      Name:       quay-operator.v3.7.11
      Version:    3.7.11
      Name:       quay-operator.v3.7.10
      Version:    3.7.10
      Name:       quay-operator.v3.7.9
      Version:    3.7.9
      Name:       quay-operator.v3.7.8
      Version:    3.7.8
      Name:       quay-operator.v3.7.7
      Version:    3.7.7
      Name:       quay-operator.v3.7.6
      Version:    3.7.6
      Name:       quay-operator.v3.7.5
      Version:    3.7.5
      Name:       quay-operator.v3.7.4
      Version:    3.7.4
      Name:       quay-operator.v3.7.3
      Version:    3.7.3
      Name:       quay-operator.v3.7.2
      Version:    3.7.2
      Name:       quay-operator.v3.7.1
      Version:    3.7.1
      Name:       quay-operator.v3.7.0
      Version:    3.7.0
    Name:         stable-3.7
...
   Current CSV:  quay-operator.v3.8.5
...
   Entries:
      Name:         quay-operator.v3.8.5
      Version:      3.8.5
      Name:         quay-operator.v3.8.4
      Version:      3.8.4
      Name:         quay-operator.v3.8.3
      Version:      3.8.3
      Name:         quay-operator.v3.8.2
      Version:      3.8.2
      Name:         quay-operator.v3.8.1
      Version:      3.8.1
      Name:         quay-operator.v3.8.0
      Version:      3.8.0
    Name:           stable-3.8
  Default Channel:  stable-3.8
  Package Name:     quay-operator</programlisting>
</example>
<tip>
<simpara>You can print an Operator&#8217;s version and channel information in the YAML format by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests &lt;operator_name&gt; -n &lt;catalog_namespace&gt; -o yaml</programlisting>
</tip>
<itemizedlist>
<listitem>
<simpara>If more than one catalog is installed in a namespace, run the following command to look up the available versions and channels of an Operator from a specific catalog:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifest \
   --selector=catalog=&lt;catalogsource_name&gt; \
   --field-selector metadata.name=&lt;operator_name&gt; \
   -n &lt;catalog_namespace&gt; -o yaml</programlisting>
<important>
<simpara>If you do not specify the Operator&#8217;s catalog, running the <literal>oc get packagemanifest</literal> and <literal>oc describe packagemanifest</literal> commands might return a package from an unexpected catalog if the following conditions are met:</simpara>
<itemizedlist>
<listitem>
<simpara>Multiple catalogs are installed in the same namespace.</simpara>
</listitem>
<listitem>
<simpara>The catalogs contain the same Operators or Operators with the same name.</simpara>
</listitem>
</itemizedlist>
</important>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>An Operator group, defined by an <literal>OperatorGroup</literal> object, selects target namespaces in which to generate required role-based access control (RBAC) access for all Operators in the same namespace as the Operator group.</simpara>
<simpara>The namespace to which you subscribe the Operator must have an Operator group that matches the install mode of the Operator, either the <literal>AllNamespaces</literal> or <literal>SingleNamespace</literal> mode. If the Operator you intend to install uses the <literal>AllNamespaces</literal> mode, then the <literal>openshift-operators</literal> namespace already has an appropriate Operator group in place.</simpara>
<simpara>However, if the Operator uses the <literal>SingleNamespace</literal> mode and you do not already have an appropriate Operator group in place, you must create one:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file, for example <literal>operatorgroup.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>OperatorGroup</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: &lt;operatorgroup_name&gt;
  namespace: &lt;namespace&gt;
spec:
  targetNamespaces:
  - &lt;namespace&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file that subscribes a namespace to an Operator with a specific version by setting the <literal>startingCSV</literal> field. Set the <literal>installPlanApproval</literal> field to <literal>Manual</literal> to prevent the Operator from automatically upgrading if a later version exists in the catalog.</simpara>
<simpara>For example, the following <literal>sub.yaml</literal> file can be used to install the Red Hat Quay Operator specifically to version 3.7.10:</simpara>
<formalpara>
<title>Subscription with a specific starting Operator version</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: quay-operator
  namespace: quay
spec:
  channel: quay-operator.v3.7.10
  installPlanApproval: Manual <co xml:id="CO14-1"/>
  name: quay-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  startingCSV: quay-operator.v3.7.10 <co xml:id="CO14-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO14-1">
<para>Set the approval strategy to <literal>Manual</literal> in case your specified version is superseded by a later version in the catalog. This plan prevents an automatic upgrade to a later version and requires manual approval before the starting CSV can complete the installation.</para>
</callout>
<callout arearefs="CO14-2">
<para>Set a specific version of an Operator CSV.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sub.yaml</programlisting>
</listitem>
<listitem>
<simpara>Manually approve the pending install plan to complete the Operator installation.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-approving-pending-upgrade_olm-upgrading-operators">Manually approving a pending Operator update</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_administrator_tasks">
<title>Administrator tasks</title>
<section xml:id="olm-adding-operators-to-a-cluster">
<title>Adding Operators to a cluster</title>

<simpara>Using Operator Lifecycle Manager (OLM),
cluster administrators
can install OLM-based Operators to an {product-title} cluster.</simpara>
<note>
<simpara>For information on how OLM handles updates for installed Operators colocated in the same namespace, as well as an alternative method for installing Operators with custom global Operator groups, see <link xl:href="../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Multitenancy and Operator colocation</link>.</simpara>
</note>
<section xml:id="olm-installing-operators-from-operatorhub_olm-adding-operators-to-a-cluster">
<title>About Operator installation with OperatorHub</title>
<simpara>OperatorHub is a user interface for discovering Operators; it works in conjunction with Operator Lifecycle Manager (OLM), which installs and manages Operators on a cluster.</simpara>
<simpara>As a user with the proper permissions, you can install an Operator from OperatorHub by using the {product-title} web console or CLI.</simpara>
<simpara>During installation, you must determine the following initial settings for the Operator:</simpara>
<variablelist>
<varlistentry>
<term>Installation Mode</term>
<listitem>
<simpara>Choose a specific namespace in which to install the Operator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Update Channel</term>
<listitem>
<simpara>If an Operator is available through multiple channels, you can choose which channel you want to subscribe to. For example, to deploy from the <emphasis role="strong">stable</emphasis> channel, if available, select it from the list.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Approval Strategy</term>
<listitem>
<simpara>You can choose automatic or manual updates.</simpara>
<simpara>If you choose automatic updates for an installed Operator, when a new version of that Operator is available in the selected channel, Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without human intervention.</simpara>
<simpara>If you select manual updates, when a newer version of an Operator is available, OLM creates an update request. As a
cluster administrator,
you must then manually approve that update request to have the Operator updated to the new version.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-understanding-operatorhub.xml#olm-understanding-operatorhub">Understanding OperatorHub</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-from-operatorhub-using-web-console_olm-adding-operators-to-a-cluster">
<title>Installing from OperatorHub using the web console</title>
<simpara>You can install and subscribe to an Operator from OperatorHub by using the {product-title} web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with
<literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate in the web console to the <emphasis role="strong">Operators → OperatorHub</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Scroll or type a keyword into the <emphasis role="strong">Filter by keyword</emphasis> box to find the Operator you want. For example, type <literal>advanced</literal> to find the Advanced Cluster Management for Kubernetes Operator.</simpara>
<simpara>You can also filter options by <emphasis role="strong">Infrastructure Features</emphasis>. For example, select <emphasis role="strong">Disconnected</emphasis> if you want to see Operators that work in disconnected environments, also known as restricted network environments.</simpara>
</listitem>
<listitem>
<simpara>Select the Operator to display additional information.</simpara>
<note>
<simpara>Choosing a Community Operator warns that Red Hat does not certify Community Operators; you must acknowledge the warning before continuing.</simpara>
</note>
</listitem>
<listitem>
<simpara>Read the information about the Operator and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">All namespaces on the cluster (default)</emphasis> installs the Operator in the default <literal>openshift-operators</literal> namespace to watch and be made available to all namespaces in the cluster. This option is not always available.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">A specific namespace on the cluster</emphasis> allows you to choose a specific, single namespace in which to install the Operator. The Operator will only watch and be made available for use in this single namespace.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose a specific, single namespace in which to install the Operator. The Operator will only watch and be made available for use in this single namespace.</simpara>
</listitem>
<listitem>
<simpara>If the cluster is in AWS STS mode, enter the Amazon Resource Name (ARN) of the AWS IAM role of your service account in the <emphasis role="strong">role ARN</emphasis> field.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/oadp-install-operator-role-arn.png"/>
</imageobject>
<textobject><phrase>Entering the ARN</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To create the role&#8217;s ARN, follow the procedure described in <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_openshift_service_on_aws/4/html/tutorials/cloud-experts-deploy-api-data-protection#prepare-aws-account_cloud-experts-deploy-api-data-protection">Preparing AWS account</link>.</simpara>
</listitem>
<listitem>
<simpara>If more than one update channel is available, select an <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Automatic</emphasis> or <emphasis role="strong">Manual</emphasis> approval strategy, as described earlier.</simpara>
<important>
<simpara>If the web console shows that the cluster is in "STS mode", you must set <emphasis role="strong">Update approval</emphasis> to <emphasis role="strong">Manual</emphasis>.</simpara>
<simpara>Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis> to make the Operator available to the selected namespaces on this {product-title} cluster.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If you selected a <emphasis role="strong">Manual</emphasis> approval strategy, the upgrade status of the subscription remains <emphasis role="strong">Upgrading</emphasis> until you review and approve the install plan.</simpara>
<simpara>After approving on the <emphasis role="strong">Install Plan</emphasis> page, the subscription upgrade status moves to <emphasis role="strong">Up to date</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If you selected an <emphasis role="strong">Automatic</emphasis> approval strategy, the upgrade status should resolve to <emphasis role="strong">Up to date</emphasis> without intervention.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After the upgrade status of the subscription is <emphasis role="strong">Up to date</emphasis>, select <emphasis role="strong">Operators → Installed Operators</emphasis> to verify that the cluster service version (CSV) of the installed Operator eventually shows up. The <emphasis role="strong">Status</emphasis> should ultimately resolve to <emphasis role="strong">InstallSucceeded</emphasis> in the relevant namespace.</simpara>
<note>
<simpara>For the <emphasis role="strong">All namespaces&#8230;&#8203;</emphasis> installation mode, the status resolves to <emphasis role="strong">InstallSucceeded</emphasis> in the <literal>openshift-operators</literal> namespace, but the status is <emphasis role="strong">Copied</emphasis> if you check in other namespaces.</simpara>
</note>
<simpara>If it does not:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the logs in any pods in the <literal>openshift-operators</literal> project (or other relevant namespace if <emphasis role="strong">A specific namespace&#8230;&#8203;</emphasis> installation mode was selected) on the <emphasis role="strong">Workloads → Pods</emphasis> page that are reporting issues to troubleshoot further.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-installing-operator-from-operatorhub-using-cli_olm-adding-operators-to-a-cluster">
<title>Installing from OperatorHub using the CLI</title>
<simpara>Instead of using the {product-title} web console, you can install an Operator from OperatorHub by using the CLI. Use the <literal>oc</literal> command to create or update a <literal>Subscription</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the list of Operators available to the cluster from OperatorHub:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                               CATALOG               AGE
3scale-operator                    Red Hat Operators     91m
advanced-cluster-management        Red Hat Operators     91m
amq7-cert-manager                  Red Hat Operators     91m
...
couchbase-enterprise-certified     Certified Operators   91m
crunchy-postgres-operator          Certified Operators   91m
mongodb-enterprise                 Certified Operators   91m
...
etcd                               Community Operators   91m
jaeger                             Community Operators   91m
kubefed                            Community Operators   91m
...</programlisting>
</para>
</formalpara>
<simpara>Note the catalog for your desired Operator.</simpara>
</listitem>
<listitem>
<simpara>Inspect your desired Operator to verify its supported install modes and available channels:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests &lt;operator_name&gt; -n openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>An Operator group, defined by an <literal>OperatorGroup</literal> object, selects target namespaces in which to generate required RBAC access for all Operators in the same namespace as the Operator group.</simpara>
<simpara>The namespace to which you subscribe the Operator must have an Operator group that matches the install mode of the Operator, either the <literal>AllNamespaces</literal> or <literal>SingleNamespace</literal> mode. If the Operator you intend to install uses the <literal>AllNamespaces</literal>, then the <literal>openshift-operators</literal> namespace already has an appropriate Operator group in place.</simpara>
<simpara>However, if the Operator uses the <literal>SingleNamespace</literal> mode and you do not already have an appropriate Operator group in place, you must create one.</simpara>
<note>
<simpara>The web console version of this procedure handles the creation of the <literal>OperatorGroup</literal> and <literal>Subscription</literal> objects automatically behind the scenes for you when choosing <literal>SingleNamespace</literal> mode.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file, for example <literal>operatorgroup.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>OperatorGroup</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: &lt;operatorgroup_name&gt;
  namespace: &lt;namespace&gt;
spec:
  targetNamespaces:
  - &lt;namespace&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file to subscribe a namespace to an Operator, for example <literal>sub.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>Subscription</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: &lt;subscription_name&gt;
  namespace: openshift-operators <co xml:id="CO15-1"/>
spec:
  channel: &lt;channel_name&gt; <co xml:id="CO15-2"/>
  name: &lt;operator_name&gt; <co xml:id="CO15-3"/>
  source: redhat-operators <co xml:id="CO15-4"/>
  sourceNamespace: openshift-marketplace <co xml:id="CO15-5"/>
  config:
    env: <co xml:id="CO15-6"/>
    - name: ARGS
      value: "-v=10"
    envFrom: <co xml:id="CO15-7"/>
    - secretRef:
        name: license-secret
    volumes: <co xml:id="CO15-8"/>
    - name: &lt;volume_name&gt;
      configMap:
        name: &lt;configmap_name&gt;
    volumeMounts: <co xml:id="CO15-9"/>
    - mountPath: &lt;directory_name&gt;
      name: &lt;volume_name&gt;
    tolerations: <co xml:id="CO15-10"/>
    - operator: "Exists"
    resources: <co xml:id="CO15-11"/>
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
    nodeSelector: <co xml:id="CO15-12"/>
      foo: bar</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>For default <literal>AllNamespaces</literal> install mode usage, specify the <literal>openshift-operators</literal> namespace. Alternatively, you can specify a custom global namespace, if you have created one. Otherwise, specify the relevant single namespace for <literal>SingleNamespace</literal> install mode usage.</para>
</callout>
<callout arearefs="CO15-2">
<para>Name of the channel to subscribe to.</para>
</callout>
<callout arearefs="CO15-3">
<para>Name of the Operator to subscribe to.</para>
</callout>
<callout arearefs="CO15-4">
<para>Name of the catalog source that provides the Operator.</para>
</callout>
<callout arearefs="CO15-5">
<para>Namespace of the catalog source. Use <literal>openshift-marketplace</literal> for the default OperatorHub catalog sources.</para>
</callout>
<callout arearefs="CO15-6">
<para>The <literal>env</literal> parameter defines a list of Environment Variables that must exist in all containers in the pod created by OLM.</para>
</callout>
<callout arearefs="CO15-7">
<para>The <literal>envFrom</literal> parameter defines a list of sources to populate Environment Variables in the container.</para>
</callout>
<callout arearefs="CO15-8">
<para>The <literal>volumes</literal> parameter defines a list of Volumes that must exist on the pod created by OLM.</para>
</callout>
<callout arearefs="CO15-9">
<para>The <literal>volumeMounts</literal> parameter defines a list of volume mounts that must exist in all containers in the pod created by OLM. If a <literal>volumeMount</literal> references a <literal>volume</literal> that does not exist, OLM fails to deploy the Operator.</para>
</callout>
<callout arearefs="CO15-10">
<para>The <literal>tolerations</literal> parameter defines a list of Tolerations for the pod created by OLM.</para>
</callout>
<callout arearefs="CO15-11">
<para>The <literal>resources</literal> parameter defines resource constraints for all the containers in the pod created by OLM.</para>
</callout>
<callout arearefs="CO15-12">
<para>The <literal>nodeSelector</literal> parameter defines a <literal>NodeSelector</literal> for the pod created by OLM.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If the cluster is in STS mode, include the following fields in the <literal>Subscription</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Subscription
# ...
spec:
  installPlanApproval: Manual <co xml:id="CO16-1"/>
  config:
    env:
    - name: ROLEARN
      value: "&lt;role_arn&gt;" <co xml:id="CO16-2"/></programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.</para>
</callout>
<callout arearefs="CO16-2">
<para>Include the role ARN details.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sub.yaml</programlisting>
<simpara>At this point, OLM is now aware of the selected Operator. A cluster service version (CSV) for the Operator should appear in the target namespace, and APIs provided by the Operator should be available for creation.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-operatorgroups-about_olm-understanding-operatorgroups">About Operator groups</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-specific-version-cli_olm-adding-operators-to-a-cluster">
<title>Installing a specific version of an Operator</title>
<simpara>You can install a specific version of an Operator by setting the cluster service version (CSV) in a <literal>Subscription</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with Operator installation permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Look up the available versions and channels of the Operator you want to install by running the following command:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests &lt;operator_name&gt; -n &lt;catalog_namespace&gt;</programlisting>
</para>
</formalpara>
<simpara>For example, the following command prints the available channels and versions of the Red Hat Quay Operator from OperatorHub:</simpara>
<formalpara>
<title>Example command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe packagemanifests quay-operator -n openshift-marketplace</programlisting>
</para>
</formalpara>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">Name:         quay-operator
Namespace:    operator-marketplace
Labels:       catalog=redhat-operators
              catalog-namespace=openshift-marketplace
              hypershift.openshift.io/managed=true
              operatorframework.io/arch.amd64=supported
              operatorframework.io/os.linux=supported
              provider=Red Hat
              provider-url=
Annotations:  &lt;none&gt;
API Version:  packages.operators.coreos.com/v1
Kind:         PackageManifest
...
    Current CSV:  quay-operator.v3.7.11
...
    Entries:
      Name:       quay-operator.v3.7.11
      Version:    3.7.11
      Name:       quay-operator.v3.7.10
      Version:    3.7.10
      Name:       quay-operator.v3.7.9
      Version:    3.7.9
      Name:       quay-operator.v3.7.8
      Version:    3.7.8
      Name:       quay-operator.v3.7.7
      Version:    3.7.7
      Name:       quay-operator.v3.7.6
      Version:    3.7.6
      Name:       quay-operator.v3.7.5
      Version:    3.7.5
      Name:       quay-operator.v3.7.4
      Version:    3.7.4
      Name:       quay-operator.v3.7.3
      Version:    3.7.3
      Name:       quay-operator.v3.7.2
      Version:    3.7.2
      Name:       quay-operator.v3.7.1
      Version:    3.7.1
      Name:       quay-operator.v3.7.0
      Version:    3.7.0
    Name:         stable-3.7
...
   Current CSV:  quay-operator.v3.8.5
...
   Entries:
      Name:         quay-operator.v3.8.5
      Version:      3.8.5
      Name:         quay-operator.v3.8.4
      Version:      3.8.4
      Name:         quay-operator.v3.8.3
      Version:      3.8.3
      Name:         quay-operator.v3.8.2
      Version:      3.8.2
      Name:         quay-operator.v3.8.1
      Version:      3.8.1
      Name:         quay-operator.v3.8.0
      Version:      3.8.0
    Name:           stable-3.8
  Default Channel:  stable-3.8
  Package Name:     quay-operator</programlisting>
</example>
<tip>
<simpara>You can print an Operator&#8217;s version and channel information in the YAML format by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests &lt;operator_name&gt; -n &lt;catalog_namespace&gt; -o yaml</programlisting>
</tip>
<itemizedlist>
<listitem>
<simpara>If more than one catalog is installed in a namespace, run the following command to look up the available versions and channels of an Operator from a specific catalog:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifest \
   --selector=catalog=&lt;catalogsource_name&gt; \
   --field-selector metadata.name=&lt;operator_name&gt; \
   -n &lt;catalog_namespace&gt; -o yaml</programlisting>
<important>
<simpara>If you do not specify the Operator&#8217;s catalog, running the <literal>oc get packagemanifest</literal> and <literal>oc describe packagemanifest</literal> commands might return a package from an unexpected catalog if the following conditions are met:</simpara>
<itemizedlist>
<listitem>
<simpara>Multiple catalogs are installed in the same namespace.</simpara>
</listitem>
<listitem>
<simpara>The catalogs contain the same Operators or Operators with the same name.</simpara>
</listitem>
</itemizedlist>
</important>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>An Operator group, defined by an <literal>OperatorGroup</literal> object, selects target namespaces in which to generate required role-based access control (RBAC) access for all Operators in the same namespace as the Operator group.</simpara>
<simpara>The namespace to which you subscribe the Operator must have an Operator group that matches the install mode of the Operator, either the <literal>AllNamespaces</literal> or <literal>SingleNamespace</literal> mode. If the Operator you intend to install uses the <literal>AllNamespaces</literal> mode, then the <literal>openshift-operators</literal> namespace already has an appropriate Operator group in place.</simpara>
<simpara>However, if the Operator uses the <literal>SingleNamespace</literal> mode and you do not already have an appropriate Operator group in place, you must create one:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file, for example <literal>operatorgroup.yaml</literal>:</simpara>
<formalpara>
<title>Example <literal>OperatorGroup</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: &lt;operatorgroup_name&gt;
  namespace: &lt;namespace&gt;
spec:
  targetNamespaces:
  - &lt;namespace&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file that subscribes a namespace to an Operator with a specific version by setting the <literal>startingCSV</literal> field. Set the <literal>installPlanApproval</literal> field to <literal>Manual</literal> to prevent the Operator from automatically upgrading if a later version exists in the catalog.</simpara>
<simpara>For example, the following <literal>sub.yaml</literal> file can be used to install the Red Hat Quay Operator specifically to version 3.7.10:</simpara>
<formalpara>
<title>Subscription with a specific starting Operator version</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: quay-operator
  namespace: quay
spec:
  channel: quay-operator.v3.7.10
  installPlanApproval: Manual <co xml:id="CO17-1"/>
  name: quay-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace
  startingCSV: quay-operator.v3.7.10 <co xml:id="CO17-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>Set the approval strategy to <literal>Manual</literal> in case your specified version is superseded by a later version in the catalog. This plan prevents an automatic upgrade to a later version and requires manual approval before the starting CSV can complete the installation.</para>
</callout>
<callout arearefs="CO17-2">
<para>Set a specific version of an Operator CSV.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f sub.yaml</programlisting>
</listitem>
<listitem>
<simpara>Manually approve the pending install plan to complete the Operator installation.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-approving-pending-upgrade_olm-upgrading-operators">Manually approving a pending Operator update</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-global-namespaces_olm-adding-operators-to-a-cluster">Installing global Operators in custom namespaces</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-specific-version-web-console_olm-adding-operators-to-a-cluster">
<title>Installing a specific version of an Operator in the web console</title>
<simpara>You can install a specific version of an Operator by using the OperatorHub in the web console. You are able to browse the various versions of an operator across any channels it might have, view the metadata for that channel and version, and select the exact version you want to install.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have administrator privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the web console, click <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select an Operator you want to install.</simpara>
</listitem>
<listitem>
<simpara>From the selected Operator, you can select a <emphasis role="strong">Channel</emphasis> and <emphasis role="strong">Version</emphasis> from the lists.</simpara>
<note>
<simpara>The version selection defaults to the latest version for the channel selected. If the latest version for the channel is selected, the Automatic approval strategy is enabled by default. Otherwise Manual approval is required when not installing the latest version for the selected channel.</simpara>
<simpara>Manual approval applies to all operators installed in a namespace.</simpara>
<simpara>Installing an Operator with manual approval causes all Operators installed within the namespace to function with the Manual approval strategy and all Operators are updated together. Install Operators into separate namespaces for updating independently.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis></simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>When the operator is installed, the metadata indicates which channel and version are installed.</simpara>
<note>
<simpara>The channel and version dropdown menus are still available for viewing other version metadata in this catalog context.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-preparing-operators-multitenant_olm-adding-operators-to-a-cluster">
<title>Preparing for multiple instances of an Operator for multitenant clusters</title>
<simpara>As a cluster administrator,
you can add multiple instances of an Operator for use in multitenant clusters. This is an alternative solution to either using the standard <emphasis role="strong">All namespaces</emphasis> install mode, which can be considered to violate the principle of least privilege, or the <emphasis role="strong">Multinamespace</emphasis> mode, which is not widely adopted. For more information, see "Operators in multitenant clusters".</simpara>
<simpara>In the following procedure, the <emphasis>tenant</emphasis> is a user or group of users that share common access and privileges for a set of deployed workloads. The <emphasis>tenant Operator</emphasis> is the instance of an Operator that is intended for use by only that tenant.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All instances of the Operator you want to install must be the same version across a given cluster.</simpara>
<important>
<simpara>For more information on this and other limitations, see "Operators in multitenant clusters".</simpara>
</important>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Before installing the Operator, create a namespace for the tenant Operator that is separate from the tenant&#8217;s namespace. For example, if the tenant&#8217;s namespace is <literal>team1</literal>, you might create a <literal>team1-operator</literal> namespace:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define a <literal>Namespace</literal> resource and save the YAML file, for example, <literal>team1-operator.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: team1-operator</programlisting>
</listitem>
<listitem>
<simpara>Create the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f team1-operator.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an Operator group for the tenant Operator scoped to the tenant&#8217;s namespace, with only that one namespace entry in the <literal>spec.targetNamespaces</literal> list:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> resource and save the YAML file, for example, <literal>team1-operatorgroup.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: team1-operatorgroup
  namespace: team1-operator
spec:
  targetNamespaces:
  - team1 <co xml:id="CO18-1"/></programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Define only the tenant&#8217;s namespace in the <literal>spec.targetNamespaces</literal> list.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the Operator group by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f team1-operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Install the Operator in the tenant Operator namespace. This task is more easily performed by using the OperatorHub in the web console instead of the CLI; for a detailed procedure, see <link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-from-operatorhub-using-web-console_olm-adding-operators-to-a-cluster">Installing from OperatorHub using the web console</link>.</simpara>
<note>
<simpara>After completing the Operator installation, the Operator resides in the tenant Operator namespace and watches the tenant namespace, but neither the Operator&#8217;s pod nor its service account are visible or usable by the tenant.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-multitenancy.xml#olm-multitenancy">Operators in multitenant clusters</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-global-namespaces_olm-adding-operators-to-a-cluster">
<title>Installing global Operators in custom namespaces</title>
<simpara>When installing Operators with the {product-title} web console, the default behavior installs Operators that support the <emphasis role="strong">All namespaces</emphasis> install mode into the default <literal>openshift-operators</literal> global namespace. This can cause issues related to shared install plans and update policies between all Operators in the namespace. For more details on these limitations, see "Multitenancy and Operator colocation".</simpara>
<simpara>As a cluster administrator,
you can bypass this default behavior manually by creating a custom global namespace and using that namespace to install your individual or scoped set of Operators and their dependencies.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Before installing the Operator, create a namespace for the installation of your desired Operator. This installation namespace will become the custom global namespace:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define a <literal>Namespace</literal> resource and save the YAML file, for example, <literal>global-operators.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: global-operators</programlisting>
</listitem>
<listitem>
<simpara>Create the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f global-operators.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a custom <emphasis>global Operator group</emphasis>, which is an Operator group that watches all namespaces:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> resource and save the YAML file, for example, <literal>global-operatorgroup.yaml</literal>. Omit both the <literal>spec.selector</literal> and <literal>spec.targetNamespaces</literal> fields to make it a <emphasis>global Operator group</emphasis>, which selects all namespaces:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: global-operatorgroup
  namespace: global-operators</programlisting>
<note>
<simpara>The <literal>status.namespaces</literal> of a created global Operator group contains the empty string (<literal>""</literal>), which signals to a consuming Operator that it should watch all namespaces.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the Operator group by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f global-operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Install the desired Operator in your custom global namespace. Because the web console does not populate the <emphasis role="strong">Installed Namespace</emphasis> menu during Operator installation with custom global namespaces, this task can only be performed with the OpenShift CLI (<literal>oc</literal>). For a detailed procedure, see <link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-operator-from-operatorhub-using-cli_olm-adding-operators-to-a-cluster">Installing from OperatorHub using the CLI</link>.</simpara>
<note>
<simpara>When you initiate the Operator installation, if the Operator has dependencies, the dependencies are also automatically installed in the custom global namespace. As a result, it is then valid for the dependency Operators to have the same update policy and shared install plans.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Multitenancy and Operator colocation</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-pod-placement_olm-adding-operators-to-a-cluster">
<title>Pod placement of Operator workloads</title>
<simpara>By default, Operator Lifecycle Manager (OLM) places pods on arbitrary worker nodes when installing an Operator or deploying Operand workloads. As an administrator, you can use projects with a combination of node selectors, taints, and tolerations to control the placement of Operators and Operands to specific nodes.</simpara>
<simpara>Controlling pod placement of Operator and Operand workloads has the following prerequisites:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Determine a node or set of nodes to target for the pods per your requirements. If available, note an existing label, such as <literal>node-role.kubernetes.io/app</literal>, that identifies the node or nodes. Otherwise, add a label, such as <literal>myoperator</literal>, by using a compute machine set or editing the node directly. You will use this label in a later step as the node selector on your project.</simpara>
</listitem>
<listitem>
<simpara>If you want to ensure that only pods with a certain label are allowed to run on the nodes, while steering unrelated workloads to other nodes, add a taint to the node or nodes by using a compute machine set or editing the node directly. Use an effect that ensures that new pods that do not match the taint cannot be scheduled on the nodes. For example, a <literal>myoperator:NoSchedule</literal> taint ensures that new pods that do not match the taint are not scheduled onto that node, but existing pods on the node are allowed to remain.</simpara>
</listitem>
<listitem>
<simpara>Create a project that is configured with a default node selector and, if you added a taint, a matching toleration.</simpara>
</listitem>
</orderedlist>
<simpara>At this point, the project you created can be used to steer pods towards the specified nodes in the following scenarios:</simpara>
<variablelist>
<varlistentry>
<term>For Operator pods</term>
<listitem>
<simpara>Administrators can create a <literal>Subscription</literal> object in the project as described in the following section. As a result, the Operator pods are placed on the specified nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>For Operand pods</term>
<listitem>
<simpara>Using an installed Operator, users can create an application in the project, which places the custom resource (CR) owned by the Operator in the project. As a result, the Operand pods are placed on the specified nodes, unless the Operator is deploying cluster-wide objects or resources in other namespaces, in which case this customized pod placement does not apply.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>Adding taints and tolerations <link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-adding_nodes-scheduler-taints-tolerations">manually to nodes</link> or <link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-adding-machineset_nodes-scheduler-taints-tolerations">with compute machine sets</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-selectors.xml#nodes-scheduler-node-selectors-project_nodes-scheduler-node-selectors">Creating project-wide node selectors</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-projects_nodes-scheduler-taints-tolerations">Creating a project with a node selector and toleration</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-overriding-operator-pod-affinity_olm-adding-operators-to-a-cluster">
<title>Controlling where an Operator is installed</title>
<simpara>By default, when you install an Operator, {product-title} installs the Operator pod to one of your worker nodes randomly. However, there might be situations where you want that pod scheduled on a specific node or set of nodes.</simpara>
<simpara>The following examples describe situations where you might want to schedule an Operator pod to a specific node or set of nodes:</simpara>
<itemizedlist>
<listitem>
<simpara>If an Operator requires a particular platform, such as <literal>amd64</literal> or <literal>arm64</literal></simpara>
</listitem>
<listitem>
<simpara>If an Operator requires a particular operating system, such as Linux or Windows</simpara>
</listitem>
<listitem>
<simpara>If you want Operators that work together scheduled on the same host or on hosts located on the same rack</simpara>
</listitem>
<listitem>
<simpara>If you want Operators dispersed throughout the infrastructure to avoid downtime due to network or hardware issues</simpara>
</listitem>
</itemizedlist>
<simpara>You can control where an Operator pod is installed by adding node affinity, pod affinity, or pod anti-affinity constraints to the Operator&#8217;s <literal>Subscription</literal> object. Node affinity is a set of rules used by the scheduler to determine where a pod can be placed. Pod affinity enables you to ensure that related pods are scheduled to the same node. Pod anti-affinity allows you to prevent a pod from being scheduled on a node.</simpara>
<simpara>The following examples show how to use node affinity or pod anti-affinity to install an instance of the Custom Metrics Autoscaler Operator to a specific node in the cluster:</simpara>
<formalpara>
<title>Node affinity example that places the Operator pod on a specific node</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      nodeAffinity: <co xml:id="CO19-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values:
              - ip-10-0-163-94.us-west-2.compute.internal
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO19-1">
<para>A node affinity that requires the Operator&#8217;s pod to be scheduled on a node named <literal>ip-10-0-163-94.us-west-2.compute.internal</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Node affinity example that places the Operator pod on a node with a specific platform</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      nodeAffinity: <co xml:id="CO20-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/arch
              operator: In
              values:
              - arm64
            - key: kubernetes.io/os
              operator: In
              values:
              - linux
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>A node affinity that requires the Operator&#8217;s pod to be scheduled on a node with the <literal>kubernetes.io/arch=arm64</literal> and <literal>kubernetes.io/os=linux</literal> labels.</para>
</callout>
</calloutlist>
<formalpara>
<title>Pod affinity example that places the Operator pod on one or more specific nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      podAffinity: <co xml:id="CO21-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: app
              operator: In
              values:
              - test
          topologyKey: kubernetes.io/hostname
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>A pod affinity that places the Operator&#8217;s pod on a node that has pods with the <literal>app=test</literal> label.</para>
</callout>
</calloutlist>
<formalpara>
<title>Pod anti-affinity example that prevents the Operator pod from one or more specific nodes</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity:
      podAntiAffinity: <co xml:id="CO22-1"/>
        requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
            - key: cpu
              operator: In
              values:
              - high
          topologyKey: kubernetes.io/hostname
#...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para>A pod anti-affinity that prevents the Operator&#8217;s pod from being scheduled on a node that has pods with the <literal>cpu=high</literal> label.</para>
</callout>
</calloutlist>
<formalpara>
<title>Procedure</title>
<para>To control the placement of an Operator pod, complete the following steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Operator as usual.</simpara>
</listitem>
<listitem>
<simpara>If needed, ensure that your nodes are labeled to properly respond to the affinity.</simpara>
</listitem>
<listitem>
<simpara>Edit the Operator <literal>Subscription</literal> object to add an affinity:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: openshift-custom-metrics-autoscaler-operator
  namespace: openshift-keda
spec:
  name: my-package
  source: my-operators
  sourceNamespace: operator-registries
  config:
    affinity: <co xml:id="CO23-1"/>
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
          - matchExpressions:
            - key: kubernetes.io/hostname
              operator: In
              values:
              - ip-10-0-185-229.ec2.internal
#...</programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Add a <literal>nodeAffinity</literal>, <literal>podAffinity</literal>, or <literal>podAntiAffinity</literal>. See the Additional resources section that follows for information about creating the affinity.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To ensure that the pod is deployed on the specific node, run the following command:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ oc get pods -o wide</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                  READY   STATUS    RESTARTS   AGE   IP            NODE                           NOMINATED NODE   READINESS GATES
custom-metrics-autoscaler-operator-5dcc45d656-bhshg   1/1     Running   0          50s   10.131.0.20   ip-10-0-185-229.ec2.internal   &lt;none&gt;           &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-pod-affinity.xml#nodes-scheduler-pod-affinity-about_nodes-scheduler-pod-affinity">Understanding pod affinity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity-about_nodes-scheduler-node-affinity">Understanding node affinity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-updating_nodes-nodes-working">Understanding how to update labels on nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-upgrading-operators">
<title>Updating installed Operators</title>

<simpara>As
a cluster administrator,
you can update Operators that have been previously installed using Operator Lifecycle Manager (OLM) on your {product-title} cluster.</simpara>
<note>
<simpara>For information on how OLM handles updates for installed Operators colocated in the same namespace, as well as an alternative method for installing Operators with custom global Operator groups, see <link xl:href="../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Multitenancy and Operator colocation</link>.</simpara>
</note>
<section xml:id="olm-preparing-upgrade_olm-upgrading-operators">
<title>Preparing for an Operator update</title>
<simpara>The subscription of an installed Operator specifies an update channel that tracks and receives updates for the Operator. You can change the update channel to start tracking and receiving updates from a newer channel.</simpara>
<simpara>The names of update channels in a subscription can differ between Operators, but the naming scheme typically follows a common convention within a given Operator. For example, channel names might follow a minor release update stream for the application provided by the Operator (<literal>1.2</literal>, <literal>1.3</literal>) or a release frequency (<literal>stable</literal>, <literal>fast</literal>).</simpara>
<note>
<simpara>You cannot change installed Operators to a channel that is older than the current channel.</simpara>
</note>
<simpara>Red Hat Customer Portal Labs include the following application that helps administrators prepare to update their Operators:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://access.redhat.com/labs/ocpouic/">Red Hat OpenShift Container Platform Operator Update Information Checker</link></simpara>
</listitem>
</itemizedlist>
<simpara>You can use the application to search for Operator Lifecycle Manager-based Operators and verify the available Operator version per update channel across different versions of {product-title}. Cluster Version Operator-based Operators are not included.</simpara>
</section>
<section xml:id="olm-changing-update-channel_olm-upgrading-operators">
<title>Changing the update channel for an Operator</title>
<simpara>You can change the update channel for an Operator by using the {product-title} web console.</simpara>
<tip>
<simpara>If the approval strategy in the subscription is set to <emphasis role="strong">Automatic</emphasis>, the update process initiates as soon as a new Operator version is available in the selected channel. If the approval strategy is set to <emphasis role="strong">Manual</emphasis>, you must manually approve pending updates.</simpara>
</tip>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the Operator you want to change the update channel for.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the update channel under <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the newer update channel that you want to change to, then click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>For subscriptions with an <emphasis role="strong">Automatic</emphasis> approval strategy, the update begins automatically. Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
<simpara>For subscriptions with a <emphasis role="strong">Manual</emphasis> approval strategy, you can manually approve the update from the <emphasis role="strong">Subscription</emphasis> tab.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-approving-pending-upgrade_olm-upgrading-operators">
<title>Manually approving a pending Operator update</title>
<simpara>If an installed Operator has the approval strategy in its subscription set to <emphasis role="strong">Manual</emphasis>, when new updates are released in its current update channel, the update must be manually approved before installation can begin.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator previously installed using Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the {product-title} web console, navigate to <emphasis role="strong">Operators &#8594; Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Operators that have a pending update display a status with <emphasis role="strong">Upgrade available</emphasis>. Click the name of the Operator you want to update.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Subscription</emphasis> tab. Any updates requiring approval are displayed next to <emphasis role="strong">Upgrade status</emphasis>. For example, it might display <emphasis role="strong">1 requires approval</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">1 requires approval</emphasis>, then click <emphasis role="strong">Preview Install Plan</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Review the resources that are listed as available for update. When satisfied, click <emphasis role="strong">Approve</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Navigate back to the <emphasis role="strong">Operators &#8594; Installed Operators</emphasis> page to monitor the progress of the update. When complete, the status changes to <emphasis role="strong">Succeeded</emphasis> and <emphasis role="strong">Up to date</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_olm-upgrading-operators" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-deleting-operators-from-a-cluster">
<title>Deleting Operators from a cluster</title>

<simpara>The following describes how to delete, or uninstall, Operators that were previously installed using Operator Lifecycle Manager (OLM) on your {product-title} cluster.</simpara>
<important>
<simpara>You must successfully and completely uninstall an Operator prior to attempting to reinstall the same Operator. Failure to fully uninstall the Operator properly can leave resources, such as a project or namespace, stuck in a "Terminating" state and cause "error resolving resource" messages to be observed when trying to reinstall the Operator.</simpara>
<simpara>For more information, see <link xl:href="../../operators/admin/olm-troubleshooting-operator-issues.xml#olm-reinstall_olm-troubleshooting-operator-issues">Reinstalling Operators after failed uninstallation</link>.</simpara>
</important>
<section xml:id="olm-deleting-operators-from-a-cluster-using-web-console_olm-deleting-operators-from-a-cluster">
<title>Deleting Operators from a cluster using the web console</title>
<simpara>Cluster administrators can delete installed Operators from a selected namespace by using the web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an {product-title} cluster web console using an account with
<literal>cluster-admin</literal> permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Scroll or enter a keyword into the <emphasis role="strong">Filter by name</emphasis> field to find the Operator that you want to remove. Then, click on it.</simpara>
</listitem>
<listitem>
<simpara>On the right side of the <emphasis role="strong">Operator Details</emphasis> page, select <emphasis role="strong">Uninstall Operator</emphasis> from the <emphasis role="strong">Actions</emphasis> list.</simpara>
<simpara>An <emphasis role="strong">Uninstall Operator?</emphasis> dialog box is displayed.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Uninstall</emphasis> to remove the Operator, Operator deployments, and pods. Following this action, the Operator stops running and no longer receives updates.</simpara>
<note>
<simpara>This action does not remove resources managed by the Operator, including custom resource definitions (CRDs) and custom resources (CRs). Dashboards and navigation items enabled by the web console and off-cluster resources that continue to run might need manual clean up. To remove these after uninstalling the Operator, you might need to manually delete the Operator CRDs.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-deleting-operator-from-a-cluster-using-cli_olm-deleting-operators-from-a-cluster">
<title>Deleting Operators from a cluster using the CLI</title>
<simpara>Cluster administrators can delete installed Operators from a selected namespace by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an {product-title} cluster using an account with
<literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift CLI (<literal>oc</literal>) is installed on your workstation.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Ensure the latest version of the subscribed operator (for example, <literal>serverless-operator</literal>) is identified in the <literal>currentCSV</literal> field.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subscription.operators.coreos.com serverless-operator -n openshift-serverless -o yaml | grep currentCSV</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  currentCSV: serverless-operator.v1.28.0</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the subscription (for example, <literal>serverless-operator</literal>):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete subscription.operators.coreos.com serverless-operator -n openshift-serverless</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">subscription.operators.coreos.com "serverless-operator" deleted</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the CSV for the Operator in the target namespace using the <literal>currentCSV</literal> value from the previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterserviceversion serverless-operator.v1.28.0 -n openshift-serverless</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">clusterserviceversion.operators.coreos.com "serverless-operator.v1.28.0" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-refresh-subs_olm-deleting-operators-from-a-cluster">
<title>Refreshing failing subscriptions</title>
<simpara>In Operator Lifecycle Manager (OLM), if you subscribe to an Operator that references images that are not accessible on your network, you can find jobs in the <literal>openshift-marketplace</literal> namespace that are failing with the following errors:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ImagePullBackOff for
Back-off pulling image "example.com/openshift4/ose-elasticsearch-operator-bundle@sha256:6d2587129c846ec28d384540322b40b05833e7e00b25cca584e004af9a1d292e"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">rpc error: code = Unknown desc = error pinging docker registry example.com: Get "https://example.com/v2/": dial tcp: lookup example.com on 10.0.0.1:53: no such host</programlisting>
</para>
</formalpara>
<simpara>As a result, the subscription is stuck in this failing state and the Operator is unable to install or upgrade.</simpara>
<simpara>You can refresh a failing subscription by deleting the subscription, cluster service version (CSV), and other related objects. After recreating the subscription, OLM then reinstalls the correct version of the Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a failing subscription that is unable to pull an inaccessible bundle image.</simpara>
</listitem>
<listitem>
<simpara>You have confirmed that the correct bundle image is accessible.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the names of the <literal>Subscription</literal> and <literal>ClusterServiceVersion</literal> objects from the namespace where the Operator is installed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sub,csv -n &lt;namespace&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       PACKAGE                  SOURCE             CHANNEL
subscription.operators.coreos.com/elasticsearch-operator   elasticsearch-operator   redhat-operators   5.0

NAME                                                                         DISPLAY                            VERSION    REPLACES   PHASE
clusterserviceversion.operators.coreos.com/elasticsearch-operator.5.0.0-65   OpenShift Elasticsearch Operator   5.0.0-65              Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the subscription:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete subscription &lt;subscription_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Delete the cluster service version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete csv &lt;csv_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Get the names of any failing jobs and related config maps in the <literal>openshift-marketplace</literal> namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get job,configmap -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                                        COMPLETIONS   DURATION   AGE
job.batch/1de9443b6324e629ddf31fed0a853a121275806170e34c926d69e53a7fcbccb   1/1           26s        9m30s

NAME                                                                        DATA   AGE
configmap/1de9443b6324e629ddf31fed0a853a121275806170e34c926d69e53a7fcbccb   3      9m30s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the job:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete job &lt;job_name&gt; -n openshift-marketplace</programlisting>
<simpara>This ensures pods that try to pull the inaccessible image are not recreated.</simpara>
</listitem>
<listitem>
<simpara>Delete the config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete configmap &lt;configmap_name&gt; -n openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Reinstall the Operator using OperatorHub in the web console.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the Operator has been reinstalled successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sub,csv,installplan -n &lt;namespace&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-config">
<title>Configuring Operator Lifecycle Manager features</title>

<simpara>The Operator Lifecycle Manager (OLM) controller is configured by an <literal>OLMConfig</literal> custom resource (CR) named <literal>cluster</literal>. Cluster administrators can modify this resource to enable or disable certain features.</simpara>
<simpara>This document outlines the features currently supported by OLM that are configured by the <literal>OLMConfig</literal> resource.</simpara>
<section xml:id="olm-disabling-copied-csvs_olm-config">
<title>Disabling copied CSVs</title>
<simpara>When an Operator is installed by Operator Lifecycle Manager (OLM), a simplified copy of its cluster service version (CSV) is created by default in every namespace that the Operator is configured to watch. These CSVs are known as <emphasis>copied CSVs</emphasis> and communicate to users which controllers are actively reconciling resource events in a given namespace.</simpara>
<simpara>When an Operator is configured to use the <literal>AllNamespaces</literal> install mode, versus targeting a single or specified set of namespaces, a copied CSV for the Operator is created in every namespace on the cluster. On especially large clusters, with namespaces and installed Operators potentially in the hundreds or thousands, copied CSVs consume an untenable amount of resources, such as OLM&#8217;s memory usage, cluster etcd limits, and networking.</simpara>
<simpara>To support these larger clusters, cluster administrators can disable copied CSVs for Operators globally installed with the <literal>AllNamespaces</literal> mode.</simpara>
<note>
<simpara>If you disable copied CSVs, an Operator installed in <literal>AllNamespaces</literal> mode has their CSV copied only to the <literal>openshift</literal> namespace, instead of every namespace on the cluster. In disabled copied CSVs mode, the behavior differs between the web console and CLI:</simpara>
<itemizedlist>
<listitem>
<simpara>In the web console, the default behavior is modified to show copied CSVs from the <literal>openshift</literal> namespace in every namespace, even though the CSVs are not actually copied to every namespace. This allows regular users to still be able to view the details of these Operators in their namespaces and create related custom resources (CRs).</simpara>
</listitem>
<listitem>
<simpara>In the OpenShift CLI (<literal>oc</literal>), regular users can view Operators installed directly in their namespaces by using the <literal>oc get csvs</literal> command, but the copied CSVs from the <literal>openshift</literal> namespace are not visible in their namespaces. Operators affected by this limitation are still available and continue to reconcile events in the user&#8217;s namespace.</simpara>
<simpara>To view a full list of installed global Operators, similar to the web console behavior, all authenticated users can run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csvs -n openshift</programlisting>
</listitem>
</itemizedlist>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>OLMConfig</literal> object named <literal>cluster</literal> and set the <literal>spec.features.disableCopiedCSVs</literal> field to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: operators.coreos.com/v1
kind: OLMConfig
metadata:
  name: cluster
spec:
  features:
    disableCopiedCSVs: true <co xml:id="CO24-1"/>
EOF</programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>Disabled copied CSVs for <literal>AllNamespaces</literal> install mode Operators</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>When copied CSVs are disabled, OLM captures this information in an event in the Operator&#8217;s namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">LAST SEEN   TYPE      REASON               OBJECT                                MESSAGE
85s         Warning   DisabledCopiedCSVs   clusterserviceversion/my-csv.v1.0.0   CSV copying disabled for operators/my-csv.v1.0.0</programlisting>
</para>
</formalpara>
<simpara>When the <literal>spec.features.disableCopiedCSVs</literal> field is missing or set to <literal>false</literal>, OLM recreates the copied CSVs for all Operators installed with the <literal>AllNamespaces</literal> mode and deletes the previously mentioned events.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-operatorgroups-membership_olm-understanding-operatorgroups">Install modes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-configuring-proxy-support">
<title>Configuring proxy support in Operator Lifecycle Manager</title>

<simpara>If a global proxy is configured on the {product-title} cluster, Operator Lifecycle Manager (OLM) automatically configures Operators that it manages with the cluster-wide proxy. However, you can also configure installed Operators to override the global proxy or inject a custom CA certificate.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">Configuring the cluster-wide proxy</link></simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../networking/configuring-a-custom-pki.xml#configuring-a-custom-pki">Configuring a custom PKI</link> (custom CA certificate)</simpara>
</listitem>
<listitem>
<simpara>Developing Operators that support proxy settings for <link xl:href="../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-run-proxy_osdk-golang-tutorial">Go</link>, <link xl:href="../../operators/operator_sdk/ansible/osdk-ansible-tutorial.xml#osdk-run-proxy_osdk-ansible-tutorial">Ansible</link>, and <link xl:href="../../operators/operator_sdk/helm/osdk-helm-tutorial.xml#osdk-run-proxy_osdk-helm-tutorial">Helm</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-overriding-proxy-settings_olm-configuring-proxy-support">
<title>Overriding proxy settings of an Operator</title>
<simpara>If a cluster-wide egress proxy is configured, Operators running with Operator Lifecycle Manager (OLM) inherit the cluster-wide proxy settings on their deployments.
Cluster administrators
can also override these proxy settings by configuring the subscription of an Operator.</simpara>
<important>
<simpara>Operators must handle setting environment variables for proxy settings in the pods for any managed Operands.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with
<literal>cluster-admin</literal> permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate in the web console to the <emphasis role="strong">Operators → OperatorHub</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Select the Operator and click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, modify the <literal>Subscription</literal> object to include one or more of the following environment variables in the <literal>spec</literal> section:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HTTP_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>HTTPS_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NO_PROXY</literal></simpara>
</listitem>
</itemizedlist>
<simpara>For example:</simpara>
<formalpara>
<title><literal>Subscription</literal> object with proxy setting overrides</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: etcd-config-test
  namespace: openshift-operators
spec:
  config:
    env:
    - name: HTTP_PROXY
      value: test_http
    - name: HTTPS_PROXY
      value: test_https
    - name: NO_PROXY
      value: test
  channel: clusterwide-alpha
  installPlanApproval: Automatic
  name: etcd
  source: community-operators
  sourceNamespace: openshift-marketplace
  startingCSV: etcdoperator.v0.9.4-clusterwide</programlisting>
</para>
</formalpara>
<note>
<simpara>These environment variables can also be unset using an empty value to remove any previously set cluster-wide or custom proxy settings.</simpara>
</note>
<simpara>OLM handles these environment variables as a unit; if at least one of them is set, all three are considered overridden and the cluster-wide defaults are not used for the deployments of the subscribed Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis> to make the Operator available to the selected namespaces.</simpara>
</listitem>
<listitem>
<simpara>After the CSV for the Operator appears in the relevant namespace, you can verify that custom proxy environment variables are set in the deployment. For example, using the CLI:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n openshift-operators \
    etcd-operator -o yaml \
    | grep -i "PROXY" -A 2</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">        - name: HTTP_PROXY
          value: test_http
        - name: HTTPS_PROXY
          value: test_https
        - name: NO_PROXY
          value: test
        image: quay.io/coreos/etcd-operator@sha256:66a37fd61a06a43969854ee6d3e21088a98b93838e284a6086b13917f96b0d9c
...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-inject-custom-ca_olm-configuring-proxy-support">
<title>Injecting a custom CA certificate</title>
<simpara>When a cluster administrator
adds a custom CA certificate to a cluster using a config map, the Cluster Network Operator merges the user-provided certificates and system CA certificates into a single bundle. You can inject this merged bundle into your Operator running on Operator Lifecycle Manager (OLM), which is useful if you have a man-in-the-middle HTTPS proxy.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an {product-title} cluster using an account with
<literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>Custom CA certificate added to the cluster using a config map.</simpara>
</listitem>
<listitem>
<simpara>Desired Operator installed and running on OLM.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an empty config map in the namespace where the subscription for your Operator exists and include the following label:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: trusted-ca <co xml:id="CO25-1"/>
  labels:
    config.openshift.io/inject-trusted-cabundle: "true" <co xml:id="CO25-2"/></programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>Name of the config map.</para>
</callout>
<callout arearefs="CO25-2">
<para>Requests the Cluster Network Operator to inject the merged bundle.</para>
</callout>
</calloutlist>
<simpara>After creating this config map, it is immediately populated with the certificate contents of the merged bundle.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>Subscription</literal> object to include a <literal>spec.config</literal> section that mounts the <literal>trusted-ca</literal> config map as a volume to each container within a pod that requires a custom CA:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: my-operator
spec:
  package: etcd
  channel: alpha
  config: <co xml:id="CO26-1"/>
    selector:
      matchLabels:
        &lt;labels_for_pods&gt; <co xml:id="CO26-2"/>
    volumes: <co xml:id="CO26-3"/>
    - name: trusted-ca
      configMap:
        name: trusted-ca
        items:
          - key: ca-bundle.crt <co xml:id="CO26-4"/>
            path: tls-ca-bundle.pem <co xml:id="CO26-5"/>
    volumeMounts: <co xml:id="CO26-6"/>
    - name: trusted-ca
      mountPath: /etc/pki/ca-trust/extracted/pem
      readOnly: true</programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para>Add a <literal>config</literal> section if it does not exist.</para>
</callout>
<callout arearefs="CO26-2">
<para>Specify labels to match pods that are owned by the Operator.</para>
</callout>
<callout arearefs="CO26-3">
<para>Create a <literal>trusted-ca</literal> volume.</para>
</callout>
<callout arearefs="CO26-4">
<para><literal>ca-bundle.crt</literal> is required as the config map key.</para>
</callout>
<callout arearefs="CO26-5">
<para><literal>tls-ca-bundle.pem</literal> is required as the config map path.</para>
</callout>
<callout arearefs="CO26-6">
<para>Create a <literal>trusted-ca</literal> volume mount.</para>
</callout>
</calloutlist>
<note>
<simpara>Deployments of an Operator can fail to validate the authority and display a <literal>x509 certificate signed by unknown authority</literal> error. This error can occur even after injecting a custom CA when using the subscription of an Operator. In this case, you can set the <literal>mountPath</literal> as <literal>/etc/ssl/certs</literal> for trusted-ca by using the subscription of an Operator.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-status">
<title>Viewing Operator status</title>

<simpara>Understanding the state of the system in Operator Lifecycle Manager (OLM) is important for making decisions about and debugging problems with installed Operators. OLM provides insight into subscriptions and related catalog sources regarding their state and actions performed. This helps users better understand the healthiness of their Operators.</simpara>
<section xml:id="olm-status-conditions_olm-status">
<title>Operator subscription condition types</title>
<simpara>Subscriptions can report the following condition types:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Subscription condition types</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Condition</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>CatalogSourcesUnhealthy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Some or all of the catalog sources to be used in resolution are unhealthy.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanMissing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription is missing.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanPending</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription is pending installation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription has failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ResolutionFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The dependency resolution for a subscription has failed.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Default {product-title} cluster Operators are managed by the Cluster Version Operator (CVO) and they do not have a <literal>Subscription</literal> object. Application Operators are managed by Operator Lifecycle Manager (OLM) and they have a <literal>Subscription</literal> object.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-deleting-operators-from-cluster.xml#olm-refresh-subs_olm-deleting-operators-from-a-cluster">Refreshing failing subscriptions</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-status-viewing-cli_olm-status">
<title>Viewing Operator subscription status by using the CLI</title>
<simpara>You can view Operator subscription status by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List Operator subscriptions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subs -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to inspect a <literal>Subscription</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe sub &lt;subscription_name&gt; -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>In the command output, find the <literal>Conditions</literal> section for the status of Operator subscription condition types. In the following example, the <literal>CatalogSourcesUnhealthy</literal> condition type has a status of <literal>false</literal> because all available catalog sources are healthy:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         cluster-logging
Namespace:    openshift-logging
Labels:       operators.coreos.com/cluster-logging.openshift-logging=
Annotations:  &lt;none&gt;
API Version:  operators.coreos.com/v1alpha1
Kind:         Subscription
# ...
Conditions:
   Last Transition Time:  2019-07-29T13:42:57Z
   Message:               all available catalogsources are healthy
   Reason:                AllCatalogSourcesHealthy
   Status:                False
   Type:                  CatalogSourcesUnhealthy
# ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<note>
<simpara>Default {product-title} cluster Operators are managed by the Cluster Version Operator (CVO) and they do not have a <literal>Subscription</literal> object. Application Operators are managed by Operator Lifecycle Manager (OLM) and they have a <literal>Subscription</literal> object.</simpara>
</note>
</section>
<section xml:id="olm-cs-status-cli_olm-status">
<title>Viewing Operator catalog source status by using the CLI</title>
<simpara>You can view the status of an Operator catalog source by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the catalog sources in a namespace. For example, you can check the <literal>openshift-marketplace</literal> namespace, which is used for cluster-wide catalog sources:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsources -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                  DISPLAY               TYPE   PUBLISHER   AGE
certified-operators   Certified Operators   grpc   Red Hat     55m
community-operators   Community Operators   grpc   Red Hat     55m
example-catalog       Example Catalog       grpc   Example Org 2m25s
redhat-marketplace    Red Hat Marketplace   grpc   Red Hat     55m
redhat-operators      Red Hat Operators     grpc   Red Hat     55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to get more details and status about a catalog source:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe catalogsource example-catalog -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         example-catalog
Namespace:    openshift-marketplace
Labels:       &lt;none&gt;
Annotations:  operatorframework.io/managed-by: marketplace-operator
              target.workload.openshift.io/management: {"effect": "PreferredDuringScheduling"}
API Version:  operators.coreos.com/v1alpha1
Kind:         CatalogSource
# ...
Status:
  Connection State:
    Address:              example-catalog.openshift-marketplace.svc:50051
    Last Connect:         2021-09-09T17:07:35Z
    Last Observed State:  TRANSIENT_FAILURE
  Registry Service:
    Created At:         2021-09-09T17:05:45Z
    Port:               50051
    Protocol:           grpc
    Service Name:       example-catalog
    Service Namespace:  openshift-marketplace
# ...</programlisting>
</para>
</formalpara>
<simpara>In the preceding example output, the last observed state is <literal>TRANSIENT_FAILURE</literal>. This state indicates that there is a problem establishing a connection for the catalog source.</simpara>
</listitem>
<listitem>
<simpara>List the pods in the namespace where your catalog source was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS             RESTARTS   AGE
certified-operators-cv9nn               1/1     Running            0          36m
community-operators-6v8lp               1/1     Running            0          36m
marketplace-operator-86bfc75f9b-jkgbc   1/1     Running            0          42m
example-catalog-bwt8z                   0/1     ImagePullBackOff   0          3m55s
redhat-marketplace-57p8c                1/1     Running            0          36m
redhat-operators-smxx8                  1/1     Running            0          36m</programlisting>
</para>
</formalpara>
<simpara>When a catalog source is created in a namespace, a pod for the catalog source is created in that namespace. In the preceding example output, the status for the <literal>example-catalog-bwt8z</literal> pod is <literal>ImagePullBackOff</literal>. This status indicates that there is an issue pulling the catalog source&#8217;s index image.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to inspect a pod for more detailed information:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod example-catalog-bwt8z -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         example-catalog-bwt8z
Namespace:    openshift-marketplace
Priority:     0
Node:         ci-ln-jyryyg2-f76d1-ggdbq-worker-b-vsxjd/10.0.128.2
...
Events:
  Type     Reason          Age                From               Message
  ----     ------          ----               ----               -------
  Normal   Scheduled       48s                default-scheduler  Successfully assigned openshift-marketplace/example-catalog-bwt8z to ci-ln-jyryyf2-f76d1-fgdbq-worker-b-vsxjd
  Normal   AddedInterface  47s                multus             Add eth0 [10.131.0.40/23] from openshift-sdn
  Normal   BackOff         20s (x2 over 46s)  kubelet            Back-off pulling image "quay.io/example-org/example-catalog:v1"
  Warning  Failed          20s (x2 over 46s)  kubelet            Error: ImagePullBackOff
  Normal   Pulling         8s (x3 over 47s)   kubelet            Pulling image "quay.io/example-org/example-catalog:v1"
  Warning  Failed          8s (x3 over 47s)   kubelet            Failed to pull image "quay.io/example-org/example-catalog:v1": rpc error: code = Unknown desc = reading manifest v1 in quay.io/example-org/example-catalog: unauthorized: access to the requested resource is not authorized
  Warning  Failed          8s (x3 over 47s)   kubelet            Error: ErrImagePull</programlisting>
</para>
</formalpara>
<simpara>In the preceding example output, the error messages indicate that the catalog source&#8217;s index image is failing to pull successfully because of an authorization issue. For example, the index image might be stored in a registry that requires login credentials.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource_olm-understanding-olm">Operator Lifecycle Manager concepts and resources &#8594; Catalog source</link></simpara>
</listitem>
<listitem>
<simpara>gRPC documentation: <link xl:href="https://grpc.github.io/grpc/core/md_doc_connectivity-semantics-and-api.html">States of Connectivity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-accessing-images-private-registries_olm-managing-custom-catalogs">Accessing images for Operators from private registries</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-managing-operatorconditions">
<title>Managing Operator conditions</title>

<simpara>As a cluster administrator, you can manage Operator conditions by using Operator Lifecycle Manager (OLM).</simpara>
<section xml:id="olm-supported-operatorconditions_olm-managing-operatorconditions">
<title>Overriding Operator conditions</title>
<simpara>As a cluster administrator,
you might want to ignore a supported Operator condition reported by an Operator. When present, Operator conditions in the <literal>Spec.Overrides</literal> array override the conditions in the <literal>Spec.Conditions</literal> array, allowing
cluster administrators
to deal with situations where an Operator is incorrectly reporting a state to Operator Lifecycle Manager (OLM).</simpara>
<note>
<simpara>By default, the <literal>Spec.Overrides</literal> array is not present in an <literal>OperatorCondition</literal> object until it is added by
a cluster administrator
. The <literal>Spec.Conditions</literal> array is also not present until it is either added by a user or as a result of custom Operator logic.</simpara>
</note>
<simpara>For example, consider a known version of an Operator that always communicates that it is not upgradeable. In this instance, you might want to upgrade the Operator despite the Operator communicating that it is not upgradeable. This could be accomplished by overriding the Operator condition by adding the condition <literal>type</literal> and <literal>status</literal> to the <literal>Spec.Overrides</literal> array in the <literal>OperatorCondition</literal> object.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>An Operator with an <literal>OperatorCondition</literal> object, installed using OLM.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>OperatorCondition</literal> object for the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit operatorcondition &lt;name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Add a <literal>Spec.Overrides</literal> array to the object:</simpara>
<formalpara>
<title>Example Operator condition override</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorCondition
metadata:
  name: my-operator
  namespace: operators
spec:
  overrides:
  - type: Upgradeable <co xml:id="CO27-1"/>
    status: "True"
    reason: "upgradeIsSafe"
    message: "This is a known issue with the Operator where it always reports that it cannot be upgraded."
  conditions:
  - type: Upgradeable
    status: "False"
    reason: "migration"
    message: "The operator is performing a migration."
    lastTransitionTime: "2020-08-24T23:15:55Z"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO27-1">
<para>Allows the cluster administrator to change the upgrade readiness to <literal>True</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-updating-use-operatorconditions_olm-managing-operatorconditions">
<title>Updating your Operator to use Operator conditions</title>
<simpara>Operator Lifecycle Manager (OLM) automatically creates an <literal>OperatorCondition</literal> resource for each <literal>ClusterServiceVersion</literal> resource that it reconciles. All service accounts in the CSV are granted the RBAC to interact with the <literal>OperatorCondition</literal> owned by the Operator.</simpara>
<simpara>An Operator author can develop their Operator to use the <literal>operator-lib</literal> library such that, after the Operator has been deployed by OLM, it can set its own conditions. For more resources about setting Operator conditions as an Operator author, see the <link xl:href="https://docs.openshift.com/container-platform/4.12/operators/operator_sdk/osdk-generating-csvs.html#osdk-operatorconditions_osdk-generating-csvs">Enabling Operator conditions</link> page.</simpara>
<section xml:id="olm-updating-use-operatorconditions-defaults_olm-managing-operatorconditions">
<title>Setting defaults</title>
<simpara>In an effort to remain backwards compatible, OLM treats the absence of an <literal>OperatorCondition</literal> resource as opting out of the condition. Therefore, an Operator that opts in to using Operator conditions should set default conditions before the ready probe for the pod is set to <literal>true</literal>. This provides the Operator with a grace period to update the condition to the correct state.</simpara>
</section>
</section>
<section xml:id="olm-managing-operatorconditions-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-operatorconditions.xml#olm-operatorconditions">Operator conditions</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-creating-policy">
<title>Allowing non-cluster administrators to install Operators</title>

<simpara>Cluster administrators can use <emphasis>Operator groups</emphasis> to allow regular users to install Operators.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-understanding-operatorgroups">Operator groups</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-policy-understanding_olm-creating-policy">
<title>Understanding Operator installation policy</title>
<simpara>Operators can require wide privileges to run, and the required privileges can change between versions. Operator Lifecycle Manager (OLM) runs with <literal>cluster-admin</literal> privileges. By default, Operator authors can specify any set of permissions in the cluster service version (CSV), and OLM consequently grants it to the Operator.</simpara>
<simpara>To ensure that an Operator cannot achieve cluster-scoped privileges and that users cannot escalate privileges using OLM, Cluster administrators can manually audit Operators before they are added to the cluster. Cluster administrators are also provided tools for determining and constraining which actions are allowed during an Operator installation or upgrade using service accounts.</simpara>
<simpara>Cluster administrators can associate an Operator group with a service account that has a set of privileges granted to it. The service account sets policy on Operators to ensure they only run within predetermined boundaries by using role-based access control (RBAC) rules. As a result, the Operator is unable to do anything that is not explicitly permitted by those rules.</simpara>
<simpara>By employing Operator groups, users with enough privileges can install Operators with a limited scope. As a result, more of the Operator Framework tools can safely be made available to more users, providing a richer experience for building applications with Operators.</simpara>
<note>
<simpara>Role-based access control (RBAC) for <literal>Subscription</literal> objects is automatically granted to every user with the <literal>edit</literal> or <literal>admin</literal> role in a namespace. However, RBAC does not exist on <literal>OperatorGroup</literal> objects; this absence is what prevents regular users from installing Operators. Preinstalling Operator groups is effectively what gives installation privileges.</simpara>
</note>
<simpara>Keep the following points in mind when associating an Operator group with a service account:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>APIService</literal> and <literal>CustomResourceDefinition</literal> resources are always created by OLM using the <literal>cluster-admin</literal> role. A service account associated with an Operator group should never be granted privileges to write these resources.</simpara>
</listitem>
<listitem>
<simpara>Any Operator tied to this Operator group is now confined to the permissions granted to the specified service account. If the Operator asks for permissions that are outside the scope of the service account, the install fails with appropriate errors so the cluster administrator can troubleshoot and resolve the issue.</simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-policy-scenarios_olm-creating-policy">
<title>Installation scenarios</title>
<simpara>When determining whether an Operator can be installed or upgraded on a cluster, Operator Lifecycle Manager (OLM) considers the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>A cluster administrator creates a new Operator group and specifies a service account. All Operator(s) associated with this Operator group are installed and run against the privileges granted to the service account.</simpara>
</listitem>
<listitem>
<simpara>A cluster administrator creates a new Operator group and does not specify any service account. {product-title} maintains backward compatibility, so the default behavior remains and Operator installs and upgrades are permitted.</simpara>
</listitem>
<listitem>
<simpara>For existing Operator groups that do not specify a service account, the default behavior remains and Operator installs and upgrades are permitted.</simpara>
</listitem>
<listitem>
<simpara>A cluster administrator updates an existing Operator group and specifies a service account. OLM allows the existing Operator to continue to run with their current privileges. When such an existing Operator is going through an upgrade, it is reinstalled and run against the privileges granted to the service account like any new Operator.</simpara>
</listitem>
<listitem>
<simpara>A service account specified by an Operator group changes by adding or removing permissions, or the existing service account is swapped with a new one. When existing Operators go through an upgrade, it is reinstalled and run against the privileges granted to the updated service account like any new Operator.</simpara>
</listitem>
<listitem>
<simpara>A cluster administrator removes the service account from an Operator group. The default behavior remains and Operator installs and upgrades are permitted.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-policy-workflow_olm-creating-policy">
<title>Installation workflow</title>
<simpara>When an Operator group is tied to a service account and an Operator is installed or upgraded, Operator Lifecycle Manager (OLM) uses the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The given <literal>Subscription</literal> object is picked up by OLM.</simpara>
</listitem>
<listitem>
<simpara>OLM fetches the Operator group tied to this subscription.</simpara>
</listitem>
<listitem>
<simpara>OLM determines that the Operator group has a service account specified.</simpara>
</listitem>
<listitem>
<simpara>OLM creates a client scoped to the service account and uses the scoped client to install the Operator. This ensures that any permission requested by the Operator is always confined to that of the service account in the Operator group.</simpara>
</listitem>
<listitem>
<simpara>OLM creates a new service account with the set of permissions specified in the CSV and assigns it to the Operator. The Operator runs as the assigned service account.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-policy-scoping-operator-install_olm-creating-policy">
<title>Scoping Operator installations</title>
<simpara>To provide scoping rules to Operator installations and upgrades on Operator Lifecycle Manager (OLM), associate a service account with an Operator group.</simpara>
<simpara>Using this example, a cluster administrator can confine a set of Operators to a designated namespace.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a new namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc create -f -
apiVersion: v1
kind: Namespace
metadata:
  name: scoped
EOF</programlisting>
</listitem>
<listitem>
<simpara>Allocate permissions that you want the Operator(s) to be confined to. This involves creating a new service account, relevant role(s), and role binding(s).</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc create -f -
apiVersion: v1
kind: ServiceAccount
metadata:
  name: scoped
  namespace: scoped
EOF</programlisting>
<simpara>The following example grants the service account permissions to do anything in the designated namespace for simplicity. In a production environment, you should create a more fine-grained set of permissions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc create -f -
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: scoped
  namespace: scoped
rules:
- apiGroups: ["*"]
  resources: ["*"]
  verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: scoped-bindings
  namespace: scoped
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: scoped
subjects:
- kind: ServiceAccount
  name: scoped
  namespace: scoped
EOF</programlisting>
</listitem>
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object in the designated namespace. This Operator group targets the designated namespace to ensure that its tenancy is confined to it.</simpara>
<simpara>In addition, Operator groups allow a user to specify a service account. Specify the service account created in the previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc create -f -
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: scoped
  namespace: scoped
spec:
  serviceAccountName: scoped
  targetNamespaces:
  - scoped
EOF</programlisting>
<simpara>Any Operator installed in the designated namespace is tied to this Operator group and therefore to the service account specified.</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object in the designated namespace to install an Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat &lt;&lt;EOF | oc create -f -
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: etcd
  namespace: scoped
spec:
  channel: singlenamespace-alpha
  name: etcd
  source: &lt;catalog_source_name&gt; <co xml:id="CO28-1"/>
  sourceNamespace: &lt;catalog_source_namespace&gt; <co xml:id="CO28-2"/>
EOF</programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>Specify a catalog source that already exists in the designated namespace or one that is in the global catalog namespace.</para>
</callout>
<callout arearefs="CO28-2">
<para>Specify a namespace where the catalog source was created.</para>
</callout>
</calloutlist>
<simpara>Any Operator tied to this Operator group is confined to the permissions granted to the specified service account. If the Operator requests permissions that are outside the scope of the service account, the installation fails with relevant errors.</simpara>
</listitem>
</orderedlist>
<section xml:id="olm-policy-fine-grained-permissions_olm-creating-policy">
<title>Fine-grained permissions</title>
<simpara>Operator Lifecycle Manager (OLM) uses the service account specified in an Operator group to create or update the following resources related to the Operator being installed:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ClusterServiceVersion</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Subscription</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Secret</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ServiceAccount</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Service</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ClusterRole</literal> and <literal>ClusterRoleBinding</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Role</literal> and <literal>RoleBinding</literal></simpara>
</listitem>
</itemizedlist>
<simpara>To confine Operators to a designated namespace, cluster administrators can start by granting the following permissions to the service account:</simpara>
<note>
<simpara>The following role is a generic example and additional rules might be required based on the specific Operator.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">kind: Role
rules:
- apiGroups: ["operators.coreos.com"]
  resources: ["subscriptions", "clusterserviceversions"]
  verbs: ["get", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["services", "serviceaccounts"]
  verbs: ["get", "create", "update", "patch"]
- apiGroups: ["rbac.authorization.k8s.io"]
  resources: ["roles", "rolebindings"]
  verbs: ["get", "create", "update", "patch"]
- apiGroups: ["apps"] <co xml:id="CO29-1"/>
  resources: ["deployments"]
  verbs: ["list", "watch", "get", "create", "update", "patch", "delete"]
- apiGroups: [""] <co xml:id="CO29-2"/>
  resources: ["pods"]
  verbs: ["list", "watch", "get", "create", "update", "patch", "delete"]</programlisting>
<calloutlist>
<callout arearefs="CO29-1 CO29-2">
<para>Add permissions to create other resources, such as deployments and pods shown here.</para>
</callout>
</calloutlist>
<simpara>In addition, if any Operator specifies a pull secret, the following permissions must also be added:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterRole <co xml:id="CO30-1"/>
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]
---
kind: Role
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "update", "patch"]</programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>Required to get the secret from the OLM namespace.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="olm-policy-catalog-access_olm-creating-policy">
<title>Operator catalog access control</title>
<simpara>When an Operator catalog is created in the global catalog namespace <literal>openshift-marketplace</literal>, the catalog&#8217;s Operators are made available cluster-wide to all namespaces. A catalog created in other namespaces only makes its Operators available in that same namespace of the catalog.</simpara>
<simpara>On clusters where non-cluster administrator users have been delegated Operator installation privileges, cluster administrators might want to further control or restrict the set of Operators those users are allowed to install. This can be achieved with the following actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Disable all of the default global catalogs.</simpara>
</listitem>
<listitem>
<simpara>Enable custom, curated catalogs in the same namespace where the relevant Operator groups have been preinstalled.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-restricted-networks-operatorhub_olm-managing-custom-catalogs">Disabling the default OperatorHub catalog sources</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-creating-catalog-from-index_olm-managing-custom-catalogs">Adding a catalog source to a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-policy-troubleshooting_olm-creating-policy">
<title>Troubleshooting permission failures</title>
<simpara>If an Operator installation fails due to lack of permissions, identify the errors using the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Review the <literal>Subscription</literal> object. Its status has an object reference <literal>installPlanRef</literal> that points to the <literal>InstallPlan</literal> object that attempted to create the necessary <literal>[Cluster]Role[Binding]</literal> object(s) for the Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: Subscription
metadata:
  name: etcd
  namespace: scoped
status:
  installPlanRef:
    apiVersion: operators.coreos.com/v1
    kind: InstallPlan
    name: install-4plp8
    namespace: scoped
    resourceVersion: "117359"
    uid: 2c1df80e-afea-11e9-bce3-5254009c9c23</programlisting>
</listitem>
<listitem>
<simpara>Check the status of the <literal>InstallPlan</literal> object for any errors:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: InstallPlan
status:
  conditions:
  - lastTransitionTime: "2019-07-26T21:13:10Z"
    lastUpdateTime: "2019-07-26T21:13:10Z"
    message: 'error creating clusterrole etcdoperator.v0.9.4-clusterwide-dsfx4: clusterroles.rbac.authorization.k8s.io
      is forbidden: User "system:serviceaccount:scoped:scoped" cannot create resource
      "clusterroles" in API group "rbac.authorization.k8s.io" at the cluster scope'
    reason: InstallComponentFailed
    status: "False"
    type: Installed
  phase: Failed</programlisting>
<simpara>The error message tells you:</simpara>
<itemizedlist>
<listitem>
<simpara>The type of resource it failed to create, including the API group of the resource. In this case, it was <literal>clusterroles</literal> in the <literal>rbac.authorization.k8s.io</literal> group.</simpara>
</listitem>
<listitem>
<simpara>The name of the resource.</simpara>
</listitem>
<listitem>
<simpara>The type of error: <literal>is forbidden</literal> tells you that the user does not have enough permission to do the operation.</simpara>
</listitem>
<listitem>
<simpara>The name of the user who attempted to create or update the resource. In this case, it refers to the service account specified in the Operator group.</simpara>
</listitem>
<listitem>
<simpara>The scope of the operation: <literal>cluster scope</literal> or not.</simpara>
<simpara>The user can add the missing permission to the service account and then iterate.</simpara>
<note>
<simpara>Operator Lifecycle Manager (OLM) does not currently provide the complete list of errors on the first try.</simpara>
</note>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-managing-custom-catalogs">
<title>Managing custom catalogs</title>

<simpara>Cluster administrators
and Operator catalog maintainers can create and manage custom catalogs packaged using the <link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">bundle format</link> on Operator Lifecycle Manager (OLM) in {product-title}.</simpara>
<important>
<simpara>Kubernetes periodically deprecates certain APIs that are removed in subsequent releases. As a result, Operators are unable to use removed APIs starting with the version of {product-title} that uses the Kubernetes version that removed the API.</simpara>
<simpara>If your cluster is using custom catalogs, see <link xl:href="../../operators/operator_sdk/osdk-working-bundle-images.xml#osdk-control-compat_osdk-working-bundle-images">Controlling Operator compatibility with {product-title} versions</link> for more details about how Operator authors can update their projects to help avoid workload issues and prevent incompatible upgrades.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs">Red Hat-provided Operator catalogs</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-managing-custom-catalogs-bundle-format-prereqs">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You have installed the <link xl:href="../../cli_reference/opm/cli-opm-install.xml#cli-opm-install"><literal>opm</literal> CLI</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-managing-custom-catalogs-fb">
<title>File-based catalogs</title>
<simpara><emphasis>File-based catalogs</emphasis> are the latest iteration of the catalog format in Operator Lifecycle Manager (OLM). It is a plain text-based (JSON or YAML) and declarative config evolution of the earlier SQLite database format, and it is fully backwards compatible.</simpara>
<important>
<simpara>As of {product-title} 4.11, the default Red Hat-provided Operator catalog releases in the file-based catalog format. The default Red Hat-provided Operator catalogs for {product-title} 4.6 through 4.10 released in the deprecated SQLite database format.</simpara>
<simpara>The <literal>opm</literal> subcommands, flags, and functionality related to the SQLite database format are also deprecated and will be removed in a future release. The features are still supported and must be used for catalogs that use the deprecated SQLite database format.</simpara>
<simpara>Many of the <literal>opm</literal> subcommands and flags for working with the SQLite database format, such as <literal>opm index prune</literal>, do not work with the file-based catalog format.
For more information about working with file-based catalogs, see <link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">Operator Framework packaging format</link> and <link xl:href="../../installing/disconnected_install/installing-mirroring-disconnected.xml#installing-mirroring-disconnected">Mirroring images for a disconnected installation using the oc-mirror plugin</link>.</simpara>
</important>
<section xml:id="olm-creating-fb-catalog-image_olm-managing-custom-catalogs">
<title>Creating a file-based catalog image</title>
<simpara>You can use the <literal>opm</literal> CLI to create a catalog image that uses the plain text <emphasis>file-based catalog</emphasis> format (JSON or YAML), which replaces the deprecated SQLite database format.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the <literal>opm</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>You have <literal>podman</literal> version 1.9.3+.</simpara>
</listitem>
<listitem>
<simpara>A bundle image is built and pushed to a registry that supports <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2/">Docker v2-2</link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Initialize the catalog:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a directory for the catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir &lt;catalog_dir&gt;</programlisting>
</listitem>
<listitem>
<simpara>Generate a Dockerfile that can build a catalog image by running the <literal>opm generate dockerfile</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm generate dockerfile &lt;catalog_dir&gt; \
    -i registry.redhat.io/openshift4/ose-operator-registry:v{product-version} <co xml:id="CO31-1"/></programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>Specify the official Red Hat base image by using the <literal>-i</literal> flag, otherwise the Dockerfile uses the default upstream image.</para>
</callout>
</calloutlist>
<simpara>The Dockerfile must be in the same parent directory as the catalog directory that you created in the previous step:</simpara>
<formalpara>
<title>Example directory structure</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">. <co xml:id="CO32-1"/>
├── &lt;catalog_dir&gt; <co xml:id="CO32-2"/>
└── &lt;catalog_dir&gt;.Dockerfile <co xml:id="CO32-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO32-1">
<para>Parent directory</para>
</callout>
<callout arearefs="CO32-2">
<para>Catalog directory</para>
</callout>
<callout arearefs="CO32-3">
<para>Dockerfile generated by the <literal>opm generate dockerfile</literal> command</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Populate the catalog with the package definition for your Operator by running the <literal>opm init</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm init &lt;operator_name&gt; \ <co xml:id="CO33-1"/>
    --default-channel=preview \ <co xml:id="CO33-2"/>
    --description=./README.md \ <co xml:id="CO33-3"/>
    --icon=./operator-icon.svg \ <co xml:id="CO33-4"/>
    --output yaml \ <co xml:id="CO33-5"/>
    &gt; &lt;catalog_dir&gt;/index.yaml <co xml:id="CO33-6"/></programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para>Operator, or package, name</para>
</callout>
<callout arearefs="CO33-2">
<para>Channel that subscriptions default to if unspecified</para>
</callout>
<callout arearefs="CO33-3">
<para>Path to the Operator&#8217;s <literal>README.md</literal> or other documentation</para>
</callout>
<callout arearefs="CO33-4">
<para>Path to the Operator&#8217;s icon</para>
</callout>
<callout arearefs="CO33-5">
<para>Output format: JSON or YAML</para>
</callout>
<callout arearefs="CO33-6">
<para>Path for creating the catalog configuration file</para>
</callout>
</calloutlist>
<simpara>This command generates an <literal>olm.package</literal> declarative config blob in the specified catalog configuration file.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Add a bundle to the catalog by running the <literal>opm render</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm render &lt;registry&gt;/&lt;namespace&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; \ <co xml:id="CO34-1"/>
    --output=yaml \
    &gt;&gt; &lt;catalog_dir&gt;/index.yaml <co xml:id="CO34-2"/></programlisting>
<calloutlist>
<callout arearefs="CO34-1">
<para>Pull spec for the bundle image</para>
</callout>
<callout arearefs="CO34-2">
<para>Path to the catalog configuration file</para>
</callout>
</calloutlist>
<note>
<simpara>Channels must contain at least one bundle.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add a channel entry for the bundle. For example, modify the following example to your specifications, and add it to your <literal>&lt;catalog_dir&gt;/index.yaml</literal> file:</simpara>
<formalpara>
<title>Example channel entry</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">---
schema: olm.channel
package: &lt;operator_name&gt;
name: preview
entries:
  - name: &lt;operator_name&gt;.v0.1.0 <co xml:id="CO35-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO35-1">
<para>Ensure that you include the period (<literal>.</literal>) after <literal>&lt;operator_name&gt;</literal> but before the <literal>v</literal> in the version. Otherwise, the entry fails to pass the <literal>opm validate</literal> command.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Validate the file-based catalog:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the <literal>opm validate</literal> command against the catalog directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm validate &lt;catalog_dir&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check that the error code is <literal>0</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $?</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">0</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Build the catalog image by running the <literal>podman build</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build . \
    -f &lt;catalog_dir&gt;.Dockerfile \
    -t &lt;registry&gt;/&lt;namespace&gt;/&lt;catalog_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the catalog image to a registry:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If required, authenticate with your target registry by running the <literal>podman login</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login &lt;registry&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the catalog image by running the <literal>podman push</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push &lt;registry&gt;/&lt;namespace&gt;/&lt;catalog_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../cli_reference/opm/cli-opm-ref.xml#cli-opm-ref"><literal>opm</literal> CLI reference</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-filtering-fbc_olm-managing-custom-catalogs">
<title>Updating or filtering a file-based catalog image</title>
<simpara>You can use the <literal>opm</literal> CLI to update or filter (also known as prune) a catalog image that uses the file-based catalog format. By extracting and modifying the contents of an existing catalog image, you can update, add, or remove one or more Operator package entries from the catalog. You can then rebuild the image as an updated version of the catalog.</simpara>
<note>
<simpara>Alternatively, if you already have a catalog image on a mirror registry, you can use the oc-mirror CLI plugin to automatically prune any removed images from an updated source version of that catalog image while mirroring it to the target registry.</simpara>
<simpara>For more information about the oc-mirror plugin and this use case, see the "Keeping your mirror registry content updated" section, and specifically the "Pruning images" subsection, of "Mirroring images for a disconnected installation using the oc-mirror plugin".</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have the following on your workstation:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>opm</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara><literal>podman</literal> version 1.9.3+.</simpara>
</listitem>
<listitem>
<simpara>A file-based catalog image.</simpara>
</listitem>
<listitem>
<simpara>A catalog directory structure recently initialized on your workstation related to this catalog.</simpara>
<simpara>If you do not have an initialized catalog directory, create the directory and generate the Dockerfile. For more information, see the "Initialize the catalog" step from the "Creating a file-based catalog image" procedure.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Extract the contents of the catalog image in YAML format to an <literal>index.yaml</literal> file in your catalog directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm render &lt;registry&gt;/&lt;namespace&gt;/&lt;catalog_image_name&gt;:&lt;tag&gt; \
    -o yaml &gt; &lt;catalog_dir&gt;/index.yaml</programlisting>
<note>
<simpara>Alternatively, you can use the <literal>-o json</literal> flag to output in JSON format.</simpara>
</note>
</listitem>
<listitem>
<simpara>Modify the contents of the resulting <literal>index.yaml</literal> file to your specifications by updating, adding, or removing one or more Operator package entries.</simpara>
<important>
<simpara>After a bundle has been published in a catalog, assume that one of your users has installed it. Ensure that all previously published bundles in a catalog have an update path to the current or newer channel head to avoid stranding users that have that version installed.</simpara>
</important>
<simpara>For example, if you wanted to remove an Operator package, the following example lists a set of <literal>olm.package</literal>, <literal>olm.channel</literal>, and <literal>olm.bundle</literal> blobs which must be deleted to remove the package from the catalog:</simpara>
<example>
<title>Example removed entries</title>
<programlisting language="yaml" linenumbering="unnumbered">---
defaultChannel: release-2.7
icon:
  base64data: &lt;base64_string&gt;
  mediatype: image/svg+xml
name: example-operator
schema: olm.package
---
entries:
- name: example-operator.v2.7.0
  skipRange: '&gt;=2.6.0 &lt;2.7.0'
- name: example-operator.v2.7.1
  replaces: example-operator.v2.7.0
  skipRange: '&gt;=2.6.0 &lt;2.7.1'
- name: example-operator.v2.7.2
  replaces: example-operator.v2.7.1
  skipRange: '&gt;=2.6.0 &lt;2.7.2'
- name: example-operator.v2.7.3
  replaces: example-operator.v2.7.2
  skipRange: '&gt;=2.6.0 &lt;2.7.3'
- name: example-operator.v2.7.4
  replaces: example-operator.v2.7.3
  skipRange: '&gt;=2.6.0 &lt;2.7.4'
name: release-2.7
package: example-operator
schema: olm.channel
---
image: example.com/example-inc/example-operator-bundle@sha256:&lt;digest&gt;
name: example-operator.v2.7.0
package: example-operator
properties:
- type: olm.gvk
  value:
    group: example-group.example.io
    kind: MyObject
    version: v1alpha1
- type: olm.gvk
  value:
    group: example-group.example.io
    kind: MyOtherObject
    version: v1beta1
- type: olm.package
  value:
    packageName: example-operator
    version: 2.7.0
- type: olm.bundle.object
  value:
    data: &lt;base64_string&gt;
- type: olm.bundle.object
  value:
    data: &lt;base64_string&gt;
relatedImages:
- image: example.com/example-inc/example-related-image@sha256:&lt;digest&gt;
  name: example-related-image
schema: olm.bundle
---</programlisting>
</example>
</listitem>
<listitem>
<simpara>Save your changes to the <literal>index.yaml</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Validate the catalog:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm validate &lt;catalog_dir&gt;</programlisting>
</listitem>
<listitem>
<simpara>Rebuild the catalog:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build . \
    -f &lt;catalog_dir&gt;.Dockerfile \
    -t &lt;registry&gt;/&lt;namespace&gt;/&lt;catalog_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the updated catalog image to a registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push &lt;registry&gt;/&lt;namespace&gt;/&lt;catalog_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>In the web console, navigate to the OperatorHub configuration resource in the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> page.</simpara>
</listitem>
<listitem>
<simpara>Add the catalog source or update the existing catalog source to use the pull spec for your updated catalog image.</simpara>
<simpara>For more information, see "Adding a catalog source to a cluster" in the "Additional resources" of this section.</simpara>
</listitem>
<listitem>
<simpara>After the catalog source is in a <emphasis role="strong">READY</emphasis> state, navigate to the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page and check that the changes you made are reflected in the list of Operators.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/disconnected_install/installing-mirroring-disconnected.xml#updating-mirror-registry-content">Mirroring images for a disconnected installation using the oc-mirror plugin &#8594; Keeping your mirror registry content updated</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-restricted-networks.xml#olm-creating-catalog-from-index_olm-restricted-networks">Adding a catalog source to a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-managing-custom-catalogs-sqlite">
<title>SQLite-based catalogs</title>
<important>
<simpara>The SQLite database format for Operator catalogs is a deprecated feature. Deprecated functionality is still included in {product-title} and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<simpara>For the most recent list of major functionality that has been deprecated or removed within {product-title}, refer to the <emphasis>Deprecated and removed features</emphasis> section of the {product-title} release notes.</simpara>
</important>
<section xml:id="olm-creating-index-image_olm-managing-custom-catalogs">
<title>Creating a SQLite-based index image</title>
<simpara>You can create an index image based on the SQLite database format by using the <literal>opm</literal> CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the <literal>opm</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>You have <literal>podman</literal> version 1.9.3+.</simpara>
</listitem>
<listitem>
<simpara>A bundle image is built and pushed to a registry that supports <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2/">Docker v2-2</link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Start a new index:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm index add \
    --bundles &lt;registry&gt;/&lt;namespace&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; \<co xml:id="CO36-1"/>
    --tag &lt;registry&gt;/&lt;namespace&gt;/&lt;index_image_name&gt;:&lt;tag&gt; \<co xml:id="CO36-2"/>
    [--binary-image &lt;registry_base_image&gt;] <co xml:id="CO36-3"/></programlisting>
<calloutlist>
<callout arearefs="CO36-1">
<para>Comma-separated list of bundle images to add to the index.</para>
</callout>
<callout arearefs="CO36-2">
<para>The image tag that you want the index image to have.</para>
</callout>
<callout arearefs="CO36-3">
<para>Optional: An alternative registry base image to use for serving the catalog.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Push the index image to a registry.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If required, authenticate with your target registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login &lt;registry&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the index image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push &lt;registry&gt;/&lt;namespace&gt;/&lt;index_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-updating-index-image_olm-managing-custom-catalogs">
<title>Updating a SQLite-based index image</title>
<simpara>After configuring OperatorHub to use a catalog source that references a custom index image,
cluster administrators
can keep the available Operators on their cluster up-to-date by adding bundle images to the index image.</simpara>
<simpara>You can update an existing index image using the <literal>opm index add</literal> command.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the <literal>opm</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>You have <literal>podman</literal> version 1.9.3+.</simpara>
</listitem>
<listitem>
<simpara>An index image is built and pushed to a registry.</simpara>
</listitem>
<listitem>
<simpara>You have an existing catalog source referencing the index image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the existing index by adding bundle images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm index add \
    --bundles &lt;registry&gt;/&lt;namespace&gt;/&lt;new_bundle_image&gt;@sha256:&lt;digest&gt; \<co xml:id="CO37-1"/>
    --from-index &lt;registry&gt;/&lt;namespace&gt;/&lt;existing_index_image&gt;:&lt;existing_tag&gt; \<co xml:id="CO37-2"/>
    --tag &lt;registry&gt;/&lt;namespace&gt;/&lt;existing_index_image&gt;:&lt;updated_tag&gt; \<co xml:id="CO37-3"/>
    --pull-tool podman <co xml:id="CO37-4"/></programlisting>
<calloutlist>
<callout arearefs="CO37-1">
<para>The <literal>--bundles</literal> flag specifies a comma-separated list of additional bundle images to add to the index.</para>
</callout>
<callout arearefs="CO37-2">
<para>The <literal>--from-index</literal> flag specifies the previously pushed index.</para>
</callout>
<callout arearefs="CO37-3">
<para>The <literal>--tag</literal> flag specifies the image tag to apply to the updated index image.</para>
</callout>
<callout arearefs="CO37-4">
<para>The <literal>--pull-tool</literal> flag specifies the tool used to pull container images.</para>
</callout>
</calloutlist>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;registry&gt;</literal></term>
<listitem>
<simpara>Specifies the hostname of the registry, such as <literal>quay.io</literal> or <literal>mirror.example.com</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;namespace&gt;</literal></term>
<listitem>
<simpara>Specifies the namespace of the registry, such as <literal>ocs-dev</literal> or <literal>abc</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;new_bundle_image&gt;</literal></term>
<listitem>
<simpara>Specifies the new bundle image to add to the registry, such as <literal>ocs-operator</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;digest&gt;</literal></term>
<listitem>
<simpara>Specifies the SHA image ID, or digest, of the bundle image, such as <literal>c7f11097a628f092d8bad148406aa0e0951094a03445fd4bc0775431ef683a41</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;existing_index_image&gt;</literal></term>
<listitem>
<simpara>Specifies the previously pushed image, such as <literal>abc-redhat-operator-index</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;existing_tag&gt;</literal></term>
<listitem>
<simpara>Specifies a previously pushed image tag, such as <literal>{product-version}</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;updated_tag&gt;</literal></term>
<listitem>
<simpara>Specifies the image tag to apply to the updated index image, such as <literal>{product-version}.1</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>Example command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ opm index add \
    --bundles quay.io/ocs-dev/ocs-operator@sha256:c7f11097a628f092d8bad148406aa0e0951094a03445fd4bc0775431ef683a41 \
    --from-index mirror.example.com/abc/abc-redhat-operator-index:{product-version} \
    --tag mirror.example.com/abc/abc-redhat-operator-index:{product-version}.1 \
    --pull-tool podman</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Push the updated index image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push &lt;registry&gt;/&lt;namespace&gt;/&lt;existing_index_image&gt;:&lt;updated_tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>After Operator Lifecycle Manager (OLM) automatically polls the index image referenced in the catalog source at its regular interval, verify that the new packages are successfully added:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifests -n openshift-marketplace</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-pruning-index-image_olm-managing-custom-catalogs">
<title>Filtering a SQLite-based index image</title>
<simpara>An index image, based on the Operator bundle format, is a containerized snapshot of an Operator catalog. You can filter, or <emphasis>prune</emphasis>, an index of all but a specified list of packages, which creates a copy of the source index containing only the Operators that you want.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have <literal>podman</literal> version 1.9.3+.</simpara>
</listitem>
<listitem>
<simpara>You have <link xl:href="https://github.com/fullstorydev/grpcurl"><literal>grpcurl</literal></link> (third-party command-line tool).</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>opm</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>You have access to a registry that supports
<link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2/">Docker v2-2</link>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Authenticate with your target registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login &lt;target_registry&gt;</programlisting>
</listitem>
<listitem>
<simpara>Determine the list of packages you want to include in your pruned index.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Run the source index image that you want to prune in a container. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run -p50051:50051 \
    -it registry.redhat.io/redhat/redhat-operator-index:v{product-version}</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Trying to pull registry.redhat.io/redhat/redhat-operator-index:v{product-version}...
Getting image source signatures
Copying blob ae8a0c23f5b1 done
...
INFO[0000] serving registry                              database=/database/index.db port=50051</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>In a separate terminal session, use the <literal>grpcurl</literal> command to get a list of the packages provided by the index:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ grpcurl -plaintext localhost:50051 api.Registry/ListPackages &gt; packages.out</programlisting>
</listitem>
<listitem>
<simpara>Inspect the <literal>packages.out</literal> file and identify which package names from this list you want to keep in your pruned index. For example:</simpara>
<formalpara>
<title>Example snippets of packages list</title>
<para>
<programlisting language="text" linenumbering="unnumbered">...
{
  "name": "advanced-cluster-management"
}
...
{
  "name": "jaeger-product"
}
...
{
{
  "name": "quay-operator"
}
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>In the terminal session where you executed the <literal>podman run</literal> command, press <keycap>Ctrl</keycap> and <keycap>C</keycap> to stop the container process.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to prune the source index of all but the specified packages:</simpara>
<programlisting language="text" linenumbering="unnumbered">$ opm index prune \
    -f registry.redhat.io/redhat/redhat-operator-index:v{product-version} \<co xml:id="CO38-1"/>
    -p advanced-cluster-management,jaeger-product,quay-operator \<co xml:id="CO38-2"/>
    [-i registry.redhat.io/openshift4/ose-operator-registry:v4.9] \<co xml:id="CO38-3"/>
    -t &lt;target_registry&gt;:&lt;port&gt;/&lt;namespace&gt;/redhat-operator-index:v{product-version} <co xml:id="CO38-4"/></programlisting>
<calloutlist>
<callout arearefs="CO38-1">
<para>Index to prune.</para>
</callout>
<callout arearefs="CO38-2">
<para>Comma-separated list of packages to keep.</para>
</callout>
<callout arearefs="CO38-3">
<para>Required only for IBM Power&#174; and IBM Z&#174; images: Operator Registry base image with the tag that matches the target {product-title} cluster major and minor version.</para>
</callout>
<callout arearefs="CO38-4">
<para>Custom tag for new index image being built.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the following command to push the new index image to your target registry:</simpara>
<programlisting language="text" linenumbering="unnumbered">$ podman push &lt;target_registry&gt;:&lt;port&gt;/&lt;namespace&gt;/redhat-operator-index:v{product-version}</programlisting>
<simpara>where <literal>&lt;namespace&gt;</literal> is any existing namespace on the registry.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-catalog-sources-and-psa_olm-managing-custom-catalogs">
<title>Catalog sources and pod security admission</title>
<simpara><emphasis>Pod security admission</emphasis> was introduced in {product-title} 4.11 to ensure pod security standards. Catalog sources built using the SQLite-based catalog format and a version of the <literal>opm</literal> CLI tool released before {product-title} 4.11 cannot run under restricted pod security enforcement.</simpara>
<simpara>In {product-title} {product-version}, namespaces do not have restricted pod security enforcement by default and the default catalog source security mode is set to <literal>legacy</literal>.</simpara>
<simpara>Default restricted enforcement for all namespaces is planned for inclusion in a future {product-title} release. When restricted enforcement occurs, the security context of the pod specification for catalog source pods must match the restricted pod security standard. If your catalog source image requires a different pod security standard, the pod security admissions label for the namespace must be explicitly set.</simpara>
<note>
<simpara>If you do not want to run your SQLite-based catalog source pods as restricted, you do not need to update your catalog source in {product-title} {product-version}.</simpara>
<simpara>However, it is recommended that you take action now to ensure your catalog sources run under restricted pod security enforcement. If you do not take action to ensure your catalog sources run under restricted pod security enforcement, your catalog sources might not run in future {product-title} releases.</simpara>
</note>
<simpara>As a catalog author, you can enable compatibility with restricted pod security enforcement by completing either of the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Migrate your catalog to the file-based catalog format.</simpara>
</listitem>
<listitem>
<simpara>Update your catalog image with a version of the <literal>opm</literal> CLI tool released with {product-title} 4.11 or later.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The SQLite database catalog format is deprecated, but still supported by Red Hat. In a future release, the SQLite database format will not be supported, and catalogs will need to migrate to the file-based catalog format. As of {product-title} 4.11, the default Red Hat-provided Operator catalog is released in the file-based catalog format. File-based catalogs are compatible with restricted pod security enforcement.</simpara>
</note>
<simpara>If you do not want to update your SQLite database catalog image or migrate your catalog to the file-based catalog format, you can configure your catalog to run with elevated permissions.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-migrating-sqlite-catalog-to-fbc_olm-managing-custom-catalogs">
<title>Migrating SQLite database catalogs to the file-based catalog format</title>
<simpara>You can update your deprecated SQLite database format catalogs to the file-based catalog format.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a SQLite database catalog source.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have the latest version of the <literal>opm</literal> CLI tool released with {product-title} {product-version} on your workstation.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Migrate your SQLite database catalog to a file-based catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm migrate &lt;registry_image&gt; &lt;fbc_directory&gt;</programlisting>
</listitem>
<listitem>
<simpara>Generate a Dockerfile for your file-based catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm generate dockerfile &lt;fbc_directory&gt; \
  --binary-image \
  registry.redhat.io/openshift4/ose-operator-registry:v{product-version}</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>The generated Dockerfile can be built, tagged, and pushed to your registry.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-creating-catalog-from-index_olm-managing-custom-catalogs">Adding a catalog source to a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-updating-sqlite-catalog-to-a-new-opm-version_olm-managing-custom-catalogs">
<title>Rebuilding SQLite database catalog images</title>
<simpara>You can rebuild your SQLite database catalog image with the latest version of the <literal>opm</literal> CLI tool that is released with your version of {product-title}.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a SQLite database catalog source.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have the latest version of the <literal>opm</literal> CLI tool released with {product-title} {product-version} on your workstation.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to rebuild your catalog with a more recent version of the <literal>opm</literal> CLI tool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm index add --binary-image \
  registry.redhat.io/openshift4/ose-operator-registry:v{product-version} \
  --from-index &lt;your_registry_image&gt; \
  --bundles "" -t \&lt;your_registry_image&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-sqlite-catalog-elevated-privileges_olm-managing-custom-catalogs">
<title>Configuring catalogs to run with elevated permissions</title>
<simpara>If you do not want to update your SQLite database catalog image or migrate your catalog to the file-based catalog format, you can perform the following actions to ensure your catalog source runs when the default pod security enforcement changes to restricted:</simpara>
<itemizedlist>
<listitem>
<simpara>Manually set the catalog security mode to legacy in your catalog source definition. This action ensures your catalog runs with legacy permissions even if the default catalog security mode changes to restricted.</simpara>
</listitem>
<listitem>
<simpara>Label the catalog source namespace for baseline or privileged pod security enforcement.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The SQLite database catalog format is deprecated, but still supported by Red Hat. In a future release, the SQLite database format will not be supported, and catalogs will need to migrate to the file-based catalog format. File-based catalogs are compatible with restricted pod security enforcement.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a SQLite database catalog source.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have a target namespace that supports running pods with the elevated pod security admission standard of <literal>baseline</literal> or <literal>privileged</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CatalogSource</literal> definition by setting the <literal>spec.grpcPodConfig.securityContextConfig</literal> label to <literal>legacy</literal>, as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>CatalogSource</literal> definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: my-catsrc
  namespace: my-ns
spec:
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: legacy
  image: my-image:latest</programlisting>
</para>
</formalpara>
<tip>
<simpara>In {product-title} {product-version}, the <literal>spec.grpcPodConfig.securityContextConfig</literal> field is set to <literal>legacy</literal> by default. In a future release of {product-title}, it is planned that the default setting will change to <literal>restricted</literal>. If your catalog cannot run under restricted enforcement, it is recommended that you manually set this field to <literal>legacy</literal>.</simpara>
</tip>
</listitem>
<listitem>
<simpara>Edit your <literal>&lt;namespace&gt;.yaml</literal> file to add elevated pod security admission standards to your catalog source namespace, as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;namespace&gt;.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
...
  labels:
    security.openshift.io/scc.podSecurityLabelSync: "false" <co xml:id="CO39-1"/>
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: baseline <co xml:id="CO39-2"/>
  name: "&lt;namespace_name&gt;"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO39-1">
<para>Turn off pod security label synchronization by adding the <literal>security.openshift.io/scc.podSecurityLabelSync=false</literal> label to the namespace.</para>
</callout>
<callout arearefs="CO39-2">
<para>Apply the pod security admission <literal>pod-security.kubernetes.io/enforce</literal> label. Set the label to <literal>baseline</literal> or <literal>privileged</literal>. Use the <literal>baseline</literal> pod security profile unless other workloads in the namespace require a <literal>privileged</literal> profile.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-creating-catalog-from-index_olm-managing-custom-catalogs">
<title>Adding a catalog source to a cluster</title>
<simpara>Adding a catalog source to an {product-title} cluster enables the discovery and installation of Operators for users.
Cluster administrators
can create a <literal>CatalogSource</literal> object that references an index image. OperatorHub uses catalog sources to populate the user interface.</simpara>
<tip>
<simpara>Alternatively, you can use the web console to manage catalog sources. From the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page, click the <emphasis role="strong">Sources</emphasis> tab, where you can create, update, delete, disable, and enable individual sources.</simpara>
</tip>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You built and pushed an index image to a registry.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>CatalogSource</literal> object that references your index image.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Modify the following to your specifications and save it as a <literal>catalogSource.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: my-operator-catalog
  namespace: openshift-marketplace <co xml:id="CO40-1"/>
  annotations:
    olm.catalogImageTemplate: <co xml:id="CO40-2"/>
      "&lt;registry&gt;/&lt;namespace&gt;/&lt;index_image_name&gt;:v{kube_major_version}.{kube_minor_version}.{kube_patch_version}"
spec:
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO40-3"/>
  image: &lt;registry&gt;/&lt;namespace&gt;/&lt;index_image_name&gt;:&lt;tag&gt; <co xml:id="CO40-4"/>
  displayName: My Operator Catalog
  publisher: &lt;publisher_name&gt; <co xml:id="CO40-5"/>
  updateStrategy:
    registryPoll: <co xml:id="CO40-6"/>
      interval: 30m</programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>If you want the catalog source to be available globally to users in all namespaces, specify the <literal>openshift-marketplace</literal> namespace. Otherwise, you can specify a different namespace for the catalog to be scoped and available only for that namespace.</para>
</callout>
<callout arearefs="CO40-2">
<para>Optional: Set the <literal>olm.catalogImageTemplate</literal> annotation to your index image name and use one or more of the Kubernetes cluster version variables as shown when constructing the template for the image tag.</para>
</callout>
<callout arearefs="CO40-3">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
<callout arearefs="CO40-4">
<para>Specify your index image. If you specify a tag after the image name, for example <literal>:v{product-version}</literal>, the catalog source pod uses an image pull policy of <literal>Always</literal>, meaning the pod always pulls the image prior to starting the container. If you specify a digest, for example <literal>@sha256:&lt;id&gt;</literal>, the image pull policy is <literal>IfNotPresent</literal>, meaning the pod pulls the image only if it does not already exist on the node.</para>
</callout>
<callout arearefs="CO40-5">
<para>Specify your name or an organization name publishing the catalog.</para>
</callout>
<callout arearefs="CO40-6">
<para>Catalog sources can automatically check for new versions to keep up to date.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the file to create the <literal>CatalogSource</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f catalogSource.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify the following resources are created successfully.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS    RESTARTS  AGE
my-operator-catalog-6njx6               1/1     Running   0         28s
marketplace-operator-d9f549946-96sgr    1/1     Running   0         26h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the catalog source:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsource -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                  DISPLAY               TYPE PUBLISHER  AGE
my-operator-catalog   My Operator Catalog   grpc            5s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the package manifest:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifest -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          CATALOG               AGE
jaeger-product                My Operator Catalog   93s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now install the Operators from the <emphasis role="strong">OperatorHub</emphasis> page on your {product-title} web console.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource_olm-understanding-olm">Operator Lifecycle Manager concepts and resources &#8594; Catalog source</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-accessing-images-private-registries_olm-managing-custom-catalogs">Accessing images for Operators from private registries</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../openshift_images/managing_images/image-pull-policy.xml#image-pull-policy">Image pull policy</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-accessing-images-private-registries_olm-managing-custom-catalogs">
<title>Accessing images for Operators from private registries</title>
<simpara>If certain images relevant to Operators managed by Operator Lifecycle Manager (OLM) are hosted in an authenticated container image registry, also known as a private registry, OLM and OperatorHub are unable to pull the images by default. To enable access, you can create a pull secret that contains the authentication credentials for the registry. By referencing one or more pull secrets in a catalog source, OLM can handle placing the secrets in the Operator and catalog namespace to allow installation.</simpara>
<simpara>Other images required by an Operator or its Operands might require access to private registries as well. OLM does not handle placing the secrets in target tenant namespaces for this scenario, but authentication credentials can be added to the global cluster pull secret or individual namespace service accounts to enable the required access.</simpara>
<simpara>The following types of images should be considered when determining whether Operators managed by OLM have appropriate pull access:</simpara>
<variablelist>
<varlistentry>
<term>Index images</term>
<listitem>
<simpara>A <literal>CatalogSource</literal> object can reference an index image, which use the Operator bundle format and are catalog sources packaged as container images hosted in images registries. If an index image is hosted in a private registry, a secret can be used to enable pull access.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle images</term>
<listitem>
<simpara>Operator bundle images are metadata and manifests packaged as container images that represent a unique version of an Operator. If any bundle images referenced in a catalog source are hosted in one or more private registries, a secret can be used to enable pull access.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator and Operand images</term>
<listitem>
<simpara>If an Operator installed from a catalog source uses a private image, either for the Operator image itself or one of the Operand images it watches, the Operator will fail to install because the deployment will not have access to the required registry authentication. Referencing secrets in a catalog source does not enable OLM to place the secrets in target tenant namespaces in which Operands are installed.</simpara>
<simpara>Instead, the authentication details can be added to the global cluster pull secret in the <literal>openshift-config</literal> namespace, which provides access to all namespaces on the cluster. Alternatively, if providing access to the entire cluster is not permissible, the pull secret can be added to the <literal>default</literal> service accounts of the target tenant namespaces.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have at least one of the following hosted in a private registry:</simpara>
<itemizedlist>
<listitem>
<simpara>An index image or catalog image.</simpara>
</listitem>
<listitem>
<simpara>An Operator bundle image.</simpara>
</listitem>
<listitem>
<simpara>An Operator or Operand image.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a secret for each required private registry.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the private registry to create or update your registry credentials file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman login &lt;registry&gt;:&lt;port&gt;</programlisting>
<note>
<simpara>The file path of your registry credentials can be different depending on the container tool used to log in to the registry. For the <literal>podman</literal> CLI, the default location is <literal>${XDG_RUNTIME_DIR}/containers/auth.json</literal>. For the <literal>docker</literal> CLI, the default location is <literal>/root/.docker/config.json</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>It is recommended to include credentials for only one registry per secret, and manage credentials for multiple registries in separate secrets. Multiple secrets can be included in a <literal>CatalogSource</literal> object in later steps, and {product-title} will merge the secrets into a single virtual credentials file for use during an image pull.</simpara>
<simpara>A registry credentials file can, by default, store details for more than one registry or for multiple repositories in one registry. Verify the current contents of your file. For example:</simpara>
<formalpara>
<title>File storing credentials for multiple registries</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "auths": {
        "registry.redhat.io": {
            "auth": "FrNHNydQXdzclNqdg=="
        },
        "quay.io": {
            "auth": "fegdsRib21iMQ=="
        },
        "https://quay.io/my-namespace/my-user/my-image": {
            "auth": "eWfjwsDdfsa221=="
        },
        "https://quay.io/my-namespace/my-user": {
            "auth": "feFweDdscw34rR=="
        },
        "https://quay.io/my-namespace": {
            "auth": "frwEews4fescyq=="
        }
    }
}</programlisting>
</para>
</formalpara>
<simpara>Because this file is used to create secrets in later steps, ensure that you are storing details for only one registry per file. This can be accomplished by using either of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Use the <literal>podman logout &lt;registry&gt;</literal> command to remove credentials for additional registries until only the one registry you want remains.</simpara>
</listitem>
<listitem>
<simpara>Edit your registry credentials file and separate the registry details to be stored in multiple files. For example:</simpara>
<formalpara>
<title>File storing credentials for one registry</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
        "auths": {
                "registry.redhat.io": {
                        "auth": "FrNHNydQXdzclNqdg=="
                }
        }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>File storing credentials for another registry</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
        "auths": {
                "quay.io": {
                        "auth": "Xd2lhdsbnRib21iMQ=="
                }
        }
}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create a secret in the <literal>openshift-marketplace</literal> namespace that contains the authentication credentials for a private registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    -n openshift-marketplace \
    --from-file=.dockerconfigjson=&lt;path/to/registry/credentials&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
<simpara>Repeat this step to create additional secrets for any other required private registries, updating the <literal>--from-file</literal> flag to specify another registry credentials file path.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create or update an existing <literal>CatalogSource</literal> object to reference one or more secrets:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: my-operator-catalog
  namespace: openshift-marketplace
spec:
  sourceType: grpc
  secrets: <co xml:id="CO41-1"/>
  - "&lt;secret_name_1&gt;"
  - "&lt;secret_name_2&gt;"
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO41-2"/>
  image: &lt;registry&gt;:&lt;port&gt;/&lt;namespace&gt;/&lt;image&gt;:&lt;tag&gt;
  displayName: My Operator Catalog
  publisher: &lt;publisher_name&gt;
  updateStrategy:
    registryPoll:
      interval: 30m</programlisting>
<calloutlist>
<callout arearefs="CO41-1">
<para>Add a <literal>spec.secrets</literal> section and specify any required secrets.</para>
</callout>
<callout arearefs="CO41-2">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If any Operator or Operand images that are referenced by a subscribed Operator require access to a private registry, you can either provide access to all namespaces in the cluster, or individual target tenant namespaces.</simpara>
<itemizedlist>
<listitem>
<simpara>To provide access to all namespaces in the cluster, add authentication details to the global cluster pull secret in the <literal>openshift-config</literal> namespace.</simpara>
<warning>
<simpara>Cluster resources must adjust to the new global pull secret, which can temporarily limit the usability of the cluster.</simpara>
</warning>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Extract the <literal>.dockerconfigjson</literal> file from the global pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc extract secret/pull-secret -n openshift-config --confirm</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>.dockerconfigjson</literal> file with your authentication credentials for the required private registry or registries and save it as a new file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat .dockerconfigjson | \
    jq --compact-output '.auths["&lt;registry&gt;:&lt;port&gt;/&lt;namespace&gt;/"] |= . + {"auth":"&lt;token&gt;"}' \<co xml:id="CO42-1"/>
    &gt; new_dockerconfigjson</programlisting>
<calloutlist>
<callout arearefs="CO42-1">
<para>Replace <literal>&lt;registry&gt;:&lt;port&gt;/&lt;namespace&gt;</literal> with the private registry details and <literal>&lt;token&gt;</literal> with your authentication credentials.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update the global pull secret with the new file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set data secret/pull-secret -n openshift-config \
    --from-file=.dockerconfigjson=new_dockerconfigjson</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To update an individual namespace, add a pull secret to the service account for the Operator that requires access in the target tenant namespace.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Recreate the secret that you created for the <literal>openshift-marketplace</literal> in the tenant namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; \
    -n &lt;tenant_namespace&gt; \
    --from-file=.dockerconfigjson=&lt;path/to/registry/credentials&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
</listitem>
<listitem>
<simpara>Verify the name of the service account for the Operator by searching the tenant namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sa -n &lt;tenant_namespace&gt; <co xml:id="CO43-1"/></programlisting>
<calloutlist>
<callout arearefs="CO43-1">
<para>If the Operator was installed in an individual namespace, search that namespace. If the Operator was installed for all namespaces, search the <literal>openshift-operators</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            SECRETS   AGE
builder         2         6m1s
default         2         6m1s
deployer        2         6m1s
etcd-operator   2         5m18s <co xml:id="CO44-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>Service account for an installed etcd Operator.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Link the secret to the service account for the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link &lt;operator_sa&gt; \
    -n &lt;tenant_namespace&gt; \
     &lt;secret_name&gt; \
    --for=pull</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../cicd/builds/creating-build-inputs.xml#builds-secrets-overview_creating-build-inputs">What is a secret?</link> for more information on the types of secrets, including those used for registry credentials.</simpara>
</listitem>
<listitem>
<simpara>See <link xl:href="../../openshift_images/managing_images/using-image-pull-secrets.xml#images-update-global-pull-secret_using-image-pull-secrets">Updating the global cluster pull secret</link> for more details on the impact of changing this secret.</simpara>
</listitem>
<listitem>
<simpara>See <link xl:href="../../openshift_images/managing_images/using-image-pull-secrets.xml#images-allow-pods-to-reference-images-from-secure-registries_using-image-pull-secrets">Allowing pods to reference images from other secured registries</link> for more details on linking pull secrets to service accounts per namespace.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-restricted-networks-operatorhub_olm-managing-custom-catalogs">
<title>Disabling the default OperatorHub catalog sources</title>
<simpara>Operator catalogs that source content provided by Red Hat and community projects are configured for OperatorHub by default during an {product-title} installation.
As a cluster administrator, you can disable the set of default catalogs.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Disable the sources for the default catalogs by adding <literal>disableAllDefaultSources: true</literal> to the <literal>OperatorHub</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch OperatorHub cluster --type json \
    -p '[{"op": "add", "path": "/spec/disableAllDefaultSources", "value": true}]'</programlisting>
</listitem>
</itemizedlist>
<tip>
<simpara>Alternatively, you can use the web console to manage catalog sources. From the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page, click the <emphasis role="strong">Sources</emphasis> tab, where you can create, update, delete, disable, and enable individual sources.</simpara>
</tip>
</section>
<section xml:id="olm-removing-catalogs_olm-managing-custom-catalogs">
<title>Removing custom catalogs</title>
<simpara>As a cluster administrator, you can remove custom Operator catalogs that have been previously added to your cluster by deleting the related catalog source.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Configuration</emphasis> tab, and then click <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Sources</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Options</emphasis> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> for the catalog that you want to remove, and then click <emphasis role="strong">Delete CatalogSource</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-restricted-networks">
<title>Using Operator Lifecycle Manager on restricted networks</title>

<simpara>For {product-title} clusters that are installed on restricted networks, also known as <emphasis>disconnected clusters</emphasis>, Operator Lifecycle Manager (OLM) by default cannot access the Red&#160;Hat-provided OperatorHub sources hosted on remote registries because those remote sources require full internet connectivity.</simpara>
<simpara>However, as a cluster administrator you can still enable your cluster to use OLM in a restricted network if you have a workstation that has full internet access. The workstation, which requires full internet access to pull the remote OperatorHub content, is used to prepare local mirrors of the remote sources, and push the content to a mirror registry.</simpara>
<simpara>The mirror registry can be located on a bastion host, which requires connectivity to both your workstation and the disconnected cluster, or a completely disconnected, or <emphasis>airgapped</emphasis>, host, which requires removable media to physically move the mirrored content to the disconnected environment.</simpara>
<simpara>This guide describes the following process that is required to enable OLM in restricted networks:</simpara>
<itemizedlist>
<listitem>
<simpara>Disable the default remote OperatorHub sources for OLM.</simpara>
</listitem>
<listitem>
<simpara>Use a workstation with full internet access to create and push local mirrors of the OperatorHub content to a mirror registry.</simpara>
</listitem>
<listitem>
<simpara>Configure OLM to install and manage Operators from local sources on the mirror registry instead of the default remote sources.</simpara>
</listitem>
</itemizedlist>
<simpara>After enabling OLM in a restricted network, you can continue to use your unrestricted workstation to keep your local OperatorHub sources updated as newer versions of Operators are released.</simpara>
<important>
<simpara>While OLM can manage Operators from local sources, the ability for a given Operator to run successfully in a restricted network still depends on the Operator itself meeting the following criteria:</simpara>
<itemizedlist>
<listitem>
<simpara>List any related images, or other container images that the Operator might require to perform their functions, in the <literal>relatedImages</literal> parameter of its <literal>ClusterServiceVersion</literal> (CSV) object.</simpara>
</listitem>
<listitem>
<simpara>Reference all specified images by a digest (SHA) and not by a tag.</simpara>
</listitem>
</itemizedlist>
<simpara>You can search software on the <link xl:href="https://catalog.redhat.com/software/search?p=1&amp;deployed_as=Operator&amp;type=Containerized%20application&amp;badges_and_features=Disconnected">Red&#160;Hat Ecosystem Catalog</link> for a list of Red&#160;Hat Operators that support running in disconnected mode by filtering with the following selections:</simpara>
<informaltable tabstyle="horizontal" frame="none" colsep="0" rowsep="0">
<tgroup cols="2">
<colspec colwidth="15*"/>
<colspec colwidth="85*"/>
<tbody valign="top">
<row>
<entry>
<simpara>Type</simpara>
</entry>
<entry>
<simpara>Containerized application</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Deployment method</simpara>
</entry>
<entry>
<simpara>Operator</simpara>
</entry>
</row>
<row>
<entry>
<simpara>Infrastructure features</simpara>
</entry>
<entry>
<simpara>Disconnected</simpara>
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs">Red&#160;Hat-provided Operator catalogs</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#olm-enabling-operator-for-restricted-network_osdk-generating-csvs">Enabling your Operator for restricted network environments</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-restricted-network-prereqs">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Log in to your {product-title} cluster as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you are using OLM in a restricted network on IBM Z&#174;, you must have at least 12 GB allocated to the directory where you place your registry.</simpara>
</note>
</section>
<section xml:id="olm-restricted-networks-operatorhub_olm-restricted-networks">
<title>Disabling the default OperatorHub catalog sources</title>
<simpara>Operator catalogs that source content provided by Red Hat and community projects are configured for OperatorHub by default during an {product-title} installation.
In a restricted network environment, you must disable the default catalogs as a cluster administrator.
You can then configure OperatorHub to use local catalog sources.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Disable the sources for the default catalogs by adding <literal>disableAllDefaultSources: true</literal> to the <literal>OperatorHub</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch OperatorHub cluster --type json \
    -p '[{"op": "add", "path": "/spec/disableAllDefaultSources", "value": true}]'</programlisting>
</listitem>
</itemizedlist>
<tip>
<simpara>Alternatively, you can use the web console to manage catalog sources. From the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page, click the <emphasis role="strong">Sources</emphasis> tab, where you can create, update, delete, disable, and enable individual sources.</simpara>
</tip>
</section>
<section xml:id="olm-mirror-catalog_olm-restricted-networks">
<title>Mirroring an Operator catalog</title>
<simpara>For instructions about mirroring Operator catalogs for use with disconnected clusters, see <link xl:href="../../installing/disconnected_install/installing-mirroring-installation-images.xml#olm-mirroring-catalog_installing-mirroring-installation-images">Installing &#8594; Mirroring images for a disconnected installation</link>.</simpara>
<important>
<simpara>As of {product-title} 4.11, the default Red&#160;Hat-provided Operator catalog releases in the file-based catalog format. The default Red&#160;Hat-provided Operator catalogs for {product-title} 4.6 through 4.10 released in the deprecated SQLite database format.</simpara>
<simpara>The <literal>opm</literal> subcommands, flags, and functionality related to the SQLite database format are also deprecated and will be removed in a future release. The features are still supported and must be used for catalogs that use the deprecated SQLite database format.</simpara>
<simpara>Many of the <literal>opm</literal> subcommands and flags for working with the SQLite database format, such as <literal>opm index prune</literal>, do not work with the file-based catalog format. For more information about working with file-based catalogs, see <link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">Operator Framework packaging format</link>, <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs-fb">Managing custom catalogs</link>, and <link xl:href="../../installing/disconnected_install/installing-mirroring-disconnected.xml#installing-mirroring-disconnected">Mirroring images for a disconnected installation using the oc-mirror plugin</link>.</simpara>
</important>
</section>
<section xml:id="olm-creating-catalog-from-index_olm-restricted-networks">
<title>Adding a catalog source to a cluster</title>
<simpara>Adding a catalog source to an {product-title} cluster enables the discovery and installation of Operators for users.
Cluster administrators
can create a <literal>CatalogSource</literal> object that references an index image. OperatorHub uses catalog sources to populate the user interface.</simpara>
<tip>
<simpara>Alternatively, you can use the web console to manage catalog sources. From the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Configuration</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis> page, click the <emphasis role="strong">Sources</emphasis> tab, where you can create, update, delete, disable, and enable individual sources.</simpara>
</tip>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You built and pushed an index image to a registry.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>CatalogSource</literal> object that references your index image.
If you used the <literal>oc adm catalog mirror</literal> command to mirror your catalog to a target registry, you can use the generated <literal>catalogSource.yaml</literal> file in your manifests directory as a starting point.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Modify the following to your specifications and save it as a <literal>catalogSource.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: my-operator-catalog <co xml:id="CO45-1"/>
  namespace: openshift-marketplace <co xml:id="CO45-2"/>
spec:
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO45-3"/>
  image: &lt;registry&gt;/&lt;namespace&gt;/redhat-operator-index:v{product-version} <co xml:id="CO45-4"/>
  displayName: My Operator Catalog
  publisher: &lt;publisher_name&gt; <co xml:id="CO45-5"/>
  updateStrategy:
    registryPoll: <co xml:id="CO45-6"/>
      interval: 30m</programlisting>
<calloutlist>
<callout arearefs="CO45-1">
<para>If you mirrored content to local files before uploading to a registry, remove any backslash (<literal>/</literal>) characters from the <literal>metadata.name</literal> field to avoid an "invalid resource name" error when you create the object.</para>
</callout>
<callout arearefs="CO45-2">
<para>If you want the catalog source to be available globally to users in all namespaces, specify the <literal>openshift-marketplace</literal> namespace. Otherwise, you can specify a different namespace for the catalog to be scoped and available only for that namespace.</para>
</callout>
<callout arearefs="CO45-3">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
<callout arearefs="CO45-4">
<para>Specify your index image. If you specify a tag after the image name, for example <literal>:v{product-version}</literal>, the catalog source pod uses an image pull policy of <literal>Always</literal>, meaning the pod always pulls the image prior to starting the container. If you specify a digest, for example <literal>@sha256:&lt;id&gt;</literal>, the image pull policy is <literal>IfNotPresent</literal>, meaning the pod pulls the image only if it does not already exist on the node.</para>
</callout>
<callout arearefs="CO45-5">
<para>Specify your name or an organization name publishing the catalog.</para>
</callout>
<callout arearefs="CO45-6">
<para>Catalog sources can automatically check for new versions to keep up to date.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use the file to create the <literal>CatalogSource</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f catalogSource.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify the following resources are created successfully.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS    RESTARTS  AGE
my-operator-catalog-6njx6               1/1     Running   0         28s
marketplace-operator-d9f549946-96sgr    1/1     Running   0         26h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the catalog source:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsource -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                  DISPLAY               TYPE PUBLISHER  AGE
my-operator-catalog   My Operator Catalog   grpc            5s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the package manifest:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get packagemanifest -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                          CATALOG               AGE
jaeger-product                My Operator Catalog   93s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now install the Operators from the <emphasis role="strong">OperatorHub</emphasis> page on your {product-title} web console.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-accessing-images-private-registries_olm-managing-custom-catalogs">Accessing images for Operators from private registries</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource-image-template_olm-understanding-olm">Image template for custom catalog sources</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../openshift_images/managing_images/image-pull-policy.xml#image-pull-policy">Image pull policy</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="next-steps_olm-restricted-networks">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-cs-podsched">
<title>Catalog source pod scheduling</title>

<simpara>When an Operator Lifecycle Manager (OLM) catalog source of source type <literal>grpc</literal> defines a <literal>spec.image</literal>, the Catalog Operator creates a pod that serves the defined image content. By default, this pod defines the following in its specification:</simpara>
<itemizedlist>
<listitem>
<simpara>Only the <literal>kubernetes.io/os=linux</literal> node selector.</simpara>
</listitem>
<listitem>
<simpara>The default priority class name: <literal>system-cluster-critical</literal>.</simpara>
</listitem>
<listitem>
<simpara>No tolerations.</simpara>
</listitem>
</itemizedlist>
<simpara>As an administrator, you can override these values by modifying fields in the <literal>CatalogSource</literal> object&#8217;s optional <literal>spec.grpcPodConfig</literal> section.</simpara>
<important>
<simpara>The Marketplace Operator, <literal>openshift-marketplace</literal>, manages the default <literal>OperatorHub</literal> custom resource&#8217;s (CR). This CR manages <literal>CatalogSource</literal> objects. If you attempt to modify fields in the <literal>CatalogSource</literal> object’s <literal>spec.grpcPodConfig</literal> section, the Marketplace Operator automatically reverts these modifications.By default, if you modify fields in the <literal>spec.grpcPodConfig</literal> section of the   <literal>CatalogSource</literal> object, the Marketplace Operator automatically reverts these changes.</simpara>
<simpara>To apply persistent changes to <literal>CatalogSource</literal> object, you must first disable a default <literal>CatalogSource</literal> object.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource_olm-understanding-olm">OLM concepts and resources &#8594; Catalog source</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="disabling-catalogsource-objects_olm-cs-podsched">
<title>Disabling default CatalogSource objects at a local level</title>
<simpara>You can apply persistent changes to a <literal>CatalogSource</literal> object, such as catalog source pods, at a local level, by disabling a default <literal>CatalogSource</literal> object. Consider the default configuration in situations where the default <literal>CatalogSource</literal> object&#8217;s configuration does not meet your organization&#8217;s needs. By default, if you modify fields in the <literal>spec.grpcPodConfig</literal> section of the   <literal>CatalogSource</literal> object, the Marketplace Operator automatically reverts these changes.</simpara>
<simpara>The Marketplace Operator, <literal>openshift-marketplace</literal>, manages the default custom resources (CRs) of the <literal>OperatorHub</literal>. The <literal>OperatorHub</literal> manages <literal>CatalogSource</literal> objects.</simpara>
<simpara>To apply persistent changes to <literal>CatalogSource</literal> object, you must first disable a default <literal>CatalogSource</literal> object.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To disable all the default <literal>CatalogSource</literal> objects at a local level, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch operatorhub cluster -p '{"spec": {"disableAllDefaultSources": true}}' --type=merge</programlisting>
<note>
<simpara>You can also configure the default <literal>OperatorHub</literal> CR to either disable all <literal>CatalogSource</literal> objects or disable a specific object.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-understanding-operatorhub.xml#olm-operatorhub-arch-operatorhub_crd_olm-understanding-operatorhub">OperatorHub custom resource</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-restricted-networks.html#olm-restricted-networks-operatorhub_olm-restricted-networks">Disabling the default OperatorHub catalog sources</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-node-selector_olm-cs-podsched">
<title>Overriding the node selector for catalog source pods</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A <literal>CatalogSource</literal> object of source type <literal>grpc</literal> with <literal>spec.image</literal> is defined.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CatalogSource</literal> object and add or modify the <literal>spec.grpcPodConfig</literal> section to include the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  grpcPodConfig:
    nodeSelector:
      custom_label: &lt;label&gt;</programlisting>
<simpara>where <literal>&lt;label&gt;</literal> is the label for the node selector that you want catalog source pods to use for scheduling.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-selectors.xml#nodes-scheduler-node-selectors">Placing pods on specific nodes using node selectors</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-priority-class-name_olm-cs-podsched">
<title>Overriding the priority class name for catalog source pods</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A <literal>CatalogSource</literal> object of source type <literal>grpc</literal> with <literal>spec.image</literal> is defined.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CatalogSource</literal> object and add or modify the <literal>spec.grpcPodConfig</literal> section to include the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  grpcPodConfig:
    priorityClassName: &lt;priority_class&gt;</programlisting>
<simpara>where <literal>&lt;priority_class&gt;</literal> is one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>One of the default priority classes provided by Kubernetes: <literal>system-cluster-critical</literal> or <literal>system-node-critical</literal></simpara>
</listitem>
<listitem>
<simpara>An empty set (<literal>""</literal>) to assign the default priority</simpara>
</listitem>
<listitem>
<simpara>A pre-existing and custom defined priority class</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>Previously, the only pod scheduling parameter that could be overriden was <literal>priorityClassName</literal>. This was done by adding the <literal>operatorframework.io/priorityclass</literal> annotation to the <literal>CatalogSource</literal> object. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: example-catalog
  namespace: openshift-marketplace
  annotations:
    operatorframework.io/priorityclass: system-cluster-critical</programlisting>
<simpara>If a <literal>CatalogSource</literal> object defines both the annotation and <literal>spec.grpcPodConfig.priorityClassName</literal>, the annotation takes precedence over the configuration parameter.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-priority.xml#admin-guide-priority-preemption-priority-class_nodes-pods-priority">Pod priority classes</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-tolerations_olm-cs-podsched">
<title>Overriding tolerations for catalog source pods</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A <literal>CatalogSource</literal> object of source type <literal>grpc</literal> with <literal>spec.image</literal> is defined.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>CatalogSource</literal> object and add or modify the <literal>spec.grpcPodConfig</literal> section to include the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  grpcPodConfig:
    tolerations:
      - key: "&lt;key_name&gt;"
        operator: "&lt;operator_type&gt;"
        value: "&lt;value&gt;"
        effect: "&lt;effect&gt;"</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-taints-tolerations.xml#nodes-scheduler-taints-tolerations-about_nodes-scheduler-taints-tolerations">Understanding taints and tolerations</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-managing-po">
<title>Managing platform Operators (Technology Preview)</title>

<simpara>A platform Operator is an OLM-based Operator that can be installed during or after an OpenShift Container Platform cluster&#8217;s Day 0 operations and participates in the cluster&#8217;s lifecycle. As a cluster administrator, you can manage platform Operators by using the <literal>PlatformOperator</literal> API.</simpara>
<important>
<simpara>The platform Operator type is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="platform-operators_olm-managing-po">
<title>About platform Operators</title>
<simpara>Operator Lifecycle Manager (OLM) introduces a new type of Operator called <emphasis>platform Operators</emphasis>. A platform Operator is an OLM-based Operator that can be installed during or after an {product-title} cluster&#8217;s Day 0 operations and participates in the cluster&#8217;s lifecycle. As a cluster administrator, you can use platform Operators to further customize your {product-title} installation to meet your requirements and use cases.</simpara>
<simpara>Using the existing cluster capabilities feature in {product-title}, cluster administrators can already disable a subset of Cluster Version Operator-based (CVO) components considered non-essential to the initial payload prior to cluster installation. Platform Operators iterate on this model by providing additional customization options. Through the platform Operator mechanism, which relies on resources from the RukPak component, OLM-based Operators can now be installed at cluster installation time and can block cluster rollout if the Operator fails to install successfully.</simpara>
<simpara>In {product-title} 4.12, this Technology Preview release focuses on the basic platform Operator mechanism and builds a foundation for expanding the concept in upcoming releases. You can use the cluster-wide <literal>PlatformOperator</literal> API to configure Operators before or after cluster creation on clusters that have enabled the <literal>TechPreviewNoUpgrades</literal> feature set.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-rukpak-about_olm-packaging-format">RukPak component and packaging format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/cluster-capabilities.xml#cluster-capabilities">Cluster capabilities</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-po-techpreview_olm-managing-po">
<title>Technology Preview restrictions for platform Operators</title>
<simpara>During the Technology Preview release of the platform Operators feature in {product-title} 4.12, the following restrictions determine whether an Operator can be installed through the platform Operators mechanism:</simpara>
<itemizedlist>
<listitem>
<simpara>Kubernetes manifests must be packaged using the Operator Lifecycle Manager (OLM) <literal>registry+v1</literal> bundle format.</simpara>
</listitem>
<listitem>
<simpara>The Operator cannot declare package or group/version/kind (GVK) dependencies.</simpara>
</listitem>
<listitem>
<simpara>The Operator cannot specify cluster service version (CSV) install modes other than <literal>AllNamespaces</literal></simpara>
</listitem>
<listitem>
<simpara>The Operator cannot specify any <literal>Webhook</literal> or <literal>APIService</literal> definitions.</simpara>
</listitem>
<listitem>
<simpara>All package bundles must be in the <literal>redhat-operators</literal> catalog source.</simpara>
</listitem>
</itemizedlist>
<simpara>After considering these restrictions, the following Operators can be successfully installed:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>OLM-based Operators installable as platform Operators</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>3scale-operator</simpara></entry>
<entry align="left" valign="top"><simpara>amq-broker-rhel8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>amq-online</simpara></entry>
<entry align="left" valign="top"><simpara>amq-streams</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ansible-cloud-addons-operator</simpara></entry>
<entry align="left" valign="top"><simpara>apicast-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>container-security-operator</simpara></entry>
<entry align="left" valign="top"><simpara>eap</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>file-integrity-operator</simpara></entry>
<entry align="left" valign="top"><simpara>gatekeeper-operator-product</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>integration-operator</simpara></entry>
<entry align="left" valign="top"><simpara>jws-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>kiali-ossm</simpara></entry>
<entry align="left" valign="top"><simpara>node-healthcheck-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>odf-csi-addons-operator</simpara></entry>
<entry align="left" valign="top"><simpara>odr-hub-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>openshift-custom-metrics-autoscaler-operator</simpara></entry>
<entry align="left" valign="top"><simpara>openshift-gitops-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>openshift-pipelines-operator-rh</simpara></entry>
<entry align="left" valign="top"><simpara>quay-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>red-hat-camel-k</simpara></entry>
<entry align="left" valign="top"><simpara>rhpam-kogito-operator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>service-registry-operator</simpara></entry>
<entry align="left" valign="top"><simpara>servicemeshoperator</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>skupper-operator</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>The following features are not available during this Technology Preview release:</simpara>
<itemizedlist>
<listitem>
<simpara>Automatically upgrading platform Operator packages after cluster rollout</simpara>
</listitem>
<listitem>
<simpara>Extending the platform Operator mechanism to support any optional, CVO-based components</simpara>
</listitem>
</itemizedlist>
</note>
</section>
</section>
<section xml:id="prerequisites_olm-managing-po">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Access to an {product-title} cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
<listitem>
<simpara>The <literal>TechPreviewNoUpgrades</literal> feature set enabled on the cluster.</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set cannot be undone and prevents minor version updates. These feature sets are not recommended on production clusters.</simpara>
</warning>
</listitem>
<listitem>
<simpara>Only the <literal>redhat-operators</literal> catalog source enabled on the cluster. This is a restriction during the Technology Preview release.</simpara>
</listitem>
<listitem>
<simpara>The <literal>oc</literal> command installed on your workstation.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-enabling-features.xml#nodes-cluster-enabling">Enabling features using feature gates</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-restricted-networks-operatorhub_olm-managing-custom-catalogs">Disabling the default OperatorHub catalog sources</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-po-during_olm-managing-po">
<title>Installing platform Operators during cluster creation</title>
<simpara>As a cluster administrator, you can install platform Operators by providing <literal>FeatureGate</literal> and <literal>PlatformOperator</literal> manifests during cluster creation.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Choose a platform Operator from the supported set of OLM-based Operators. For the list of this set and details on current limitations, see "Technology Preview restrictions for platform Operators".</simpara>
</listitem>
<listitem>
<simpara>Select a cluster installation method and follow the instructions through creating an <literal>install-config.yaml</literal> file. For more details on preparing for a cluster installation, see "Selecting a cluster installation method and preparing it for users".</simpara>
</listitem>
<listitem>
<simpara>After you have created the <literal>install-config.yaml</literal> file and completed any modifications to it, change to the directory that contains the installation program and create the manifests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ./openshift-install create manifests --dir &lt;installation_directory&gt; <co xml:id="CO46-1"/></programlisting>
<calloutlist>
<callout arearefs="CO46-1">
<para>For <literal>&lt;installation_directory&gt;</literal>, specify the name of the directory that contains the <literal>install-config.yaml</literal> file for your cluster.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>FeatureGate</literal> object YAML file in the <literal>&lt;installation_directory&gt;/manifests/</literal> directory that enables the <literal>TechPreviewNoUpgrade</literal> feature set, for example a <literal>feature-gate.yaml</literal> file:</simpara>
<formalpara>
<title>Example <literal>feature-gate.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: FeatureGate
metadata:
  annotations:
    include.release.openshift.io/self-managed-high-availability: "true"
    include.release.openshift.io/single-node-developer: "true"
    release.openshift.io/create-only: "true"
  name: cluster
spec:
  featureSet: TechPreviewNoUpgrade <co xml:id="CO47-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO47-1">
<para>Enable the <literal>TechPreviewNoUpgrade</literal> feature set.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>PlatformOperator</literal> object YAML file for your chosen platform Operator in the <literal>&lt;installation_directory&gt;/manifests/</literal> directory, for example a <literal>service-mesh-po.yaml</literal> file for the Red Hat OpenShift Service Mesh Operator:</simpara>
<formalpara>
<title>Example <literal>service-mesh-po.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: platform.openshift.io/v1alpha1
kind: PlatformOperator
metadata:
  name: service-mesh-po
spec:
  package:
    name: servicemeshoperator</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>When you are ready to complete the cluster install, refer to your chosen installation method and continue through running the <literal>openshift-install create cluster</literal> command.</simpara>
<simpara>During cluster creation, your provided manifests are used to enable the <literal>TechPreviewNoUpgrade</literal> feature set and install your chosen platform Operator.</simpara>
<important>
<simpara>Failure of the platform Operator to successfully install will block the cluster installation process.</simpara>
</important>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the status of the <literal>service-mesh-po</literal> platform Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get platformoperator service-mesh-po -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:
  activeBundleDeployment:
    name: service-mesh-po
  conditions:
  - lastTransitionTime: "2022-10-24T17:24:40Z"
    message: Successfully applied the service-mesh-po BundleDeployment resource
    reason: InstallSuccessful
    status: "True" <co xml:id="CO48-1"/>
    type: Installed</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO48-1">
<para>Wait until the <literal>Installed</literal> status condition reports <literal>True</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify that the <literal>platform-operators-aggregated</literal> cluster Operator is reporting an <literal>Available=True</literal> status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperator platform-operators-aggregated -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:
  conditions:
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    message: All platform operators are in a successful state
    reason: AsExpected
    status: "False"
    type: Progressing
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    status: "False"
    type: Degraded
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    message: All platform operators are in a successful state
    reason: AsExpected
    status: "True"
    type: Available</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing-preparing.xml#installing-preparing">Selecting a cluster installation method and preparing it for users</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-po.xml#olm-po-techpreview_olm-managing-po">Technology Preview restrictions for platform Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-installing-po-after_olm-managing-po">
<title>Installing platform Operators after cluster creation</title>
<simpara>As a cluster administrator, you can install platform Operators after cluster creation on clusters that have enabled the <literal>TechPreviewNoUpgrades</literal> feature set by using the cluster-wide <literal>PlatformOperator</literal> API.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Choose a platform Operator from the supported set of OLM-based Operators. For the list of this set and details on current limitations, see "Technology Preview restrictions for platform Operators".</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>PlatformOperator</literal> object YAML file for your chosen platform Operator, for example a <literal>service-mesh-po.yaml</literal> file for the Red Hat OpenShift Service Mesh Operator:</simpara>
<formalpara>
<title>Example <literal>sevice-mesh-po.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: platform.openshift.io/v1alpha1
kind: PlatformOperator
metadata:
  name: service-mesh-po
spec:
  package:
    name: servicemeshoperator</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the <literal>PlatformOperator</literal> object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f service-mesh-po.yaml</programlisting>
<note>
<simpara>If your cluster does not have the <literal>TechPreviewNoUpgrades</literal> feature set enabled, the object creation fails with the following message:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">error: resource mapping not found for name: "service-mesh-po" namespace: "" from "service-mesh-po.yaml": no matches for kind "PlatformOperator" in version "platform.openshift.io/v1alpha1"
ensure CRDs are installed first</programlisting>
</note>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Check the status of the <literal>service-mesh-po</literal> platform Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get platformoperator service-mesh-po -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:
  activeBundleDeployment:
    name: service-mesh-po
  conditions:
  - lastTransitionTime: "2022-10-24T17:24:40Z"
    message: Successfully applied the service-mesh-po BundleDeployment resource
    reason: InstallSuccessful
    status: "True" <co xml:id="CO49-1"/>
    type: Installed</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO49-1">
<para>Wait until the <literal>Installed</literal> status condition reports <literal>True</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify that the <literal>platform-operators-aggregated</literal> cluster Operator is reporting an <literal>Available=True</literal> status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperator platform-operators-aggregated -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
status:
  conditions:
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    message: All platform operators are in a successful state
    reason: AsExpected
    status: "False"
    type: Progressing
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    status: "False"
    type: Degraded
  - lastTransitionTime: "2022-10-24T17:43:26Z"
    message: All platform operators are in a successful state
    reason: AsExpected
    status: "True"
    type: Available</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-po.xml#olm-po-techpreview_olm-managing-po">Technology Preview restrictions for platform Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-deleting-po_olm-managing-po">
<title>Deleting platform Operators</title>
<simpara>As a cluster administrator, you can delete existing platform Operators. Operator Lifecycle Manager (OLM) performs a cascading deletion. First, OLM removes the bundle deployment for the platform Operator, which then deletes any objects referenced in the <literal>registry+v1</literal> type bundle.</simpara>
<note>
<simpara>The platform Operator manager and bundle deployment provisioner only manage objects that are referenced in the bundle, but not objects subsequently deployed by any bundle workloads themselves. For example, if a bundle workload creates a namespace and the Operator is not configured to clean it up before the Operator is removed, it is outside of the scope of OLM to remove the namespace during platform Operator deletion.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get a list of installed platform Operators and find the name for the Operator you want to delete:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get platformoperator</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>PlatformOperator</literal> resource for the chosen Operator, for example, for the Quay Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete platformoperator quay-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">platformoperator.platform.openshift.io "quay-operator" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify the namespace for the platform Operator is eventually deleted, for example, for the Quay Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ns quay-operator-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error from server (NotFound): namespaces "quay-operator-system" not found</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify the <literal>platform-operators-aggregated</literal> cluster Operator continues to report an <literal>Available=True</literal> status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get co platform-operators-aggregated</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                            VERSION     AVAILABLE   PROGRESSING   DEGRADED   SINCE   MESSAGE
platform-operators-aggregated   {product-version}.0-0    True        False         False      70s</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="olm-troubleshooting-operator-issues">
<title>Troubleshooting Operator issues</title>

<simpara>If you experience Operator issues, verify Operator subscription status. Check Operator pod health across the cluster and gather Operator logs for diagnosis.</simpara>
<section xml:id="olm-status-conditions_olm-troubleshooting-operator-issues">
<title>Operator subscription condition types</title>
<simpara>Subscriptions can report the following condition types:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Subscription condition types</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Condition</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>CatalogSourcesUnhealthy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Some or all of the catalog sources to be used in resolution are unhealthy.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanMissing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription is missing.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanPending</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription is pending installation.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlanFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An install plan for a subscription has failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ResolutionFailed</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The dependency resolution for a subscription has failed.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Default {product-title} cluster Operators are managed by the Cluster Version Operator (CVO) and they do not have a <literal>Subscription</literal> object. Application Operators are managed by Operator Lifecycle Manager (OLM) and they have a <literal>Subscription</literal> object.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-cs-health_olm-understanding-olm">Catalog health requirements</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-status-viewing-cli_olm-troubleshooting-operator-issues">
<title>Viewing Operator subscription status by using the CLI</title>
<simpara>You can view Operator subscription status by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List Operator subscriptions:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subs -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to inspect a <literal>Subscription</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe sub &lt;subscription_name&gt; -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>In the command output, find the <literal>Conditions</literal> section for the status of Operator subscription condition types. In the following example, the <literal>CatalogSourcesUnhealthy</literal> condition type has a status of <literal>false</literal> because all available catalog sources are healthy:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         cluster-logging
Namespace:    openshift-logging
Labels:       operators.coreos.com/cluster-logging.openshift-logging=
Annotations:  &lt;none&gt;
API Version:  operators.coreos.com/v1alpha1
Kind:         Subscription
# ...
Conditions:
   Last Transition Time:  2019-07-29T13:42:57Z
   Message:               all available catalogsources are healthy
   Reason:                AllCatalogSourcesHealthy
   Status:                False
   Type:                  CatalogSourcesUnhealthy
# ...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<note>
<simpara>Default {product-title} cluster Operators are managed by the Cluster Version Operator (CVO) and they do not have a <literal>Subscription</literal> object. Application Operators are managed by Operator Lifecycle Manager (OLM) and they have a <literal>Subscription</literal> object.</simpara>
</note>
</section>
<section xml:id="olm-cs-status-cli_olm-troubleshooting-operator-issues">
<title>Viewing Operator catalog source status by using the CLI</title>
<simpara>You can view the status of an Operator catalog source by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the catalog sources in a namespace. For example, you can check the <literal>openshift-marketplace</literal> namespace, which is used for cluster-wide catalog sources:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsources -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                  DISPLAY               TYPE   PUBLISHER   AGE
certified-operators   Certified Operators   grpc   Red Hat     55m
community-operators   Community Operators   grpc   Red Hat     55m
example-catalog       Example Catalog       grpc   Example Org 2m25s
redhat-marketplace    Red Hat Marketplace   grpc   Red Hat     55m
redhat-operators      Red Hat Operators     grpc   Red Hat     55m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to get more details and status about a catalog source:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe catalogsource example-catalog -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         example-catalog
Namespace:    openshift-marketplace
Labels:       &lt;none&gt;
Annotations:  operatorframework.io/managed-by: marketplace-operator
              target.workload.openshift.io/management: {"effect": "PreferredDuringScheduling"}
API Version:  operators.coreos.com/v1alpha1
Kind:         CatalogSource
# ...
Status:
  Connection State:
    Address:              example-catalog.openshift-marketplace.svc:50051
    Last Connect:         2021-09-09T17:07:35Z
    Last Observed State:  TRANSIENT_FAILURE
  Registry Service:
    Created At:         2021-09-09T17:05:45Z
    Port:               50051
    Protocol:           grpc
    Service Name:       example-catalog
    Service Namespace:  openshift-marketplace
# ...</programlisting>
</para>
</formalpara>
<simpara>In the preceding example output, the last observed state is <literal>TRANSIENT_FAILURE</literal>. This state indicates that there is a problem establishing a connection for the catalog source.</simpara>
</listitem>
<listitem>
<simpara>List the pods in the namespace where your catalog source was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS             RESTARTS   AGE
certified-operators-cv9nn               1/1     Running            0          36m
community-operators-6v8lp               1/1     Running            0          36m
marketplace-operator-86bfc75f9b-jkgbc   1/1     Running            0          42m
example-catalog-bwt8z                   0/1     ImagePullBackOff   0          3m55s
redhat-marketplace-57p8c                1/1     Running            0          36m
redhat-operators-smxx8                  1/1     Running            0          36m</programlisting>
</para>
</formalpara>
<simpara>When a catalog source is created in a namespace, a pod for the catalog source is created in that namespace. In the preceding example output, the status for the <literal>example-catalog-bwt8z</literal> pod is <literal>ImagePullBackOff</literal>. This status indicates that there is an issue pulling the catalog source&#8217;s index image.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>oc describe</literal> command to inspect a pod for more detailed information:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod example-catalog-bwt8z -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         example-catalog-bwt8z
Namespace:    openshift-marketplace
Priority:     0
Node:         ci-ln-jyryyg2-f76d1-ggdbq-worker-b-vsxjd/10.0.128.2
...
Events:
  Type     Reason          Age                From               Message
  ----     ------          ----               ----               -------
  Normal   Scheduled       48s                default-scheduler  Successfully assigned openshift-marketplace/example-catalog-bwt8z to ci-ln-jyryyf2-f76d1-fgdbq-worker-b-vsxjd
  Normal   AddedInterface  47s                multus             Add eth0 [10.131.0.40/23] from openshift-sdn
  Normal   BackOff         20s (x2 over 46s)  kubelet            Back-off pulling image "quay.io/example-org/example-catalog:v1"
  Warning  Failed          20s (x2 over 46s)  kubelet            Error: ImagePullBackOff
  Normal   Pulling         8s (x3 over 47s)   kubelet            Pulling image "quay.io/example-org/example-catalog:v1"
  Warning  Failed          8s (x3 over 47s)   kubelet            Failed to pull image "quay.io/example-org/example-catalog:v1": rpc error: code = Unknown desc = reading manifest v1 in quay.io/example-org/example-catalog: unauthorized: access to the requested resource is not authorized
  Warning  Failed          8s (x3 over 47s)   kubelet            Error: ErrImagePull</programlisting>
</para>
</formalpara>
<simpara>In the preceding example output, the error messages indicate that the catalog source&#8217;s index image is failing to pull successfully because of an authorization issue. For example, the index image might be stored in a registry that requires login credentials.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-understanding-olm.xml#olm-catalogsource_olm-understanding-olm">Operator Lifecycle Manager concepts and resources &#8594; Catalog source</link></simpara>
</listitem>
<listitem>
<simpara>gRPC documentation: <link xl:href="https://grpc.github.io/grpc/core/md_doc_connectivity-semantics-and-api.html">States of Connectivity</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-accessing-images-private-registries_olm-managing-custom-catalogs">Accessing images for Operators from private registries</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="querying-operator-pod-status_olm-troubleshooting-operator-issues">
<title>Querying Operator pod status</title>
<simpara>You can list Operator pods within a cluster and their status. You can also collect a detailed Operator pod summary.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Your API service is still functional.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List Operators running in the cluster. The output includes Operator version, availability, and up-time information:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperators</programlisting>
</listitem>
<listitem>
<simpara>List Operator pods running in the Operator&#8217;s namespace, plus pod status, restarts, and age:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Output a detailed Operator pod summary:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod &lt;operator_pod_name&gt; -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>If an Operator issue is node-specific, query Operator container status on that node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Start a debug pod for the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/my-node</programlisting>
</listitem>
<listitem>
<simpara>Set <literal>/host</literal> as the root directory within the debug shell. The debug pod mounts the host&#8217;s root file system in <literal>/host</literal> within the pod. By changing the root directory to <literal>/host</literal>, you can run binaries contained in the host&#8217;s executable paths:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># chroot /host</programlisting>
<note>
<simpara>{product-title} {product-version} cluster nodes running Red Hat Enterprise Linux CoreOS (RHCOS) are immutable and rely on Operators to apply cluster changes. Accessing cluster nodes by using SSH is not recommended. However, if the {product-title} API is not available, or the kubelet is not properly functioning on the target node, <literal>oc</literal> operations will be impacted. In such situations, it is possible to access nodes using <literal>ssh core@&lt;node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal> instead.</simpara>
</note>
</listitem>
<listitem>
<simpara>List details about the node&#8217;s containers, including state and associated pod IDs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># crictl ps</programlisting>
</listitem>
<listitem>
<simpara>List information about a specific Operator container on the node. The following example lists information about the <literal>network-operator</literal> container:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># crictl ps --name network-operator</programlisting>
</listitem>
<listitem>
<simpara>Exit from the debug shell.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="gathering-operator-logs_olm-troubleshooting-operator-issues">
<title>Gathering Operator logs</title>
<simpara>If you experience Operator issues, you can gather detailed diagnostic information from Operator pod logs.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Your API service is still functional.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have the fully qualified domain names of the control plane or control plane machines.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the Operator pods that are running in the Operator&#8217;s namespace, plus the pod status, restarts, and age:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Review logs for an Operator pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs pod/&lt;pod_name&gt; -n &lt;operator_namespace&gt;</programlisting>
<simpara>If an Operator pod has multiple containers, the preceding command will produce an error that includes the name of each container. Query logs from an individual container:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs pod/&lt;operator_pod_name&gt; -c &lt;container_name&gt; -n &lt;operator_namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>If the API is not functional, review Operator pod and container logs on each control plane node by using SSH instead. Replace <literal>&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal> with appropriate values.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List pods on each control plane node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt; sudo crictl pods</programlisting>
</listitem>
<listitem>
<simpara>For any Operator pods not showing a <literal>Ready</literal> status, inspect the pod&#8217;s status in detail. Replace <literal>&lt;operator_pod_id&gt;</literal> with the Operator pod&#8217;s ID listed in the output of the preceding command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt; sudo crictl inspectp &lt;operator_pod_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>List containers related to an Operator pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt; sudo crictl ps --pod=&lt;operator_pod_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>For any Operator container not showing a <literal>Ready</literal> status, inspect the container&#8217;s status in detail. Replace <literal>&lt;container_id&gt;</literal> with a container ID listed in the output of the preceding command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt; sudo crictl inspect &lt;container_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>Review the logs for any Operator containers not showing a <literal>Ready</literal> status. Replace <literal>&lt;container_id&gt;</literal> with a container ID listed in the output of the preceding command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ssh core@&lt;master-node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt; sudo crictl logs -f &lt;container_id&gt;</programlisting>
<note>
<simpara>{product-title} {product-version} cluster nodes running Red Hat Enterprise Linux CoreOS (RHCOS) are immutable and rely on Operators to apply cluster changes. Accessing cluster nodes by using SSH is not recommended. Before attempting to collect diagnostic data over SSH, review whether the data collected by running <literal>oc adm must gather</literal> and other <literal>oc</literal> commands is sufficient instead. However, if the {product-title} API is not available, or the kubelet is not properly functioning on the target node, <literal>oc</literal> operations will be impacted. In such situations, it is possible to access nodes using <literal>ssh core@&lt;node&gt;.&lt;cluster_name&gt;.&lt;base_domain&gt;</literal>.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="troubleshooting-disabling-autoreboot-mco_olm-troubleshooting-operator-issues">
<title>Disabling the Machine Config Operator from automatically rebooting</title>
<simpara>When configuration changes are made by the Machine Config Operator (MCO), Red Hat Enterprise Linux CoreOS (RHCOS) must reboot for the changes to take effect. Whether the configuration change is automatic or manual, an RHCOS node reboots automatically unless it is paused.</simpara>
<note>
<simpara>The following modifications do not trigger a node reboot:</simpara>
<itemizedlist>
<listitem>
<simpara>When the MCO detects any of the following changes, it applies the update without draining or rebooting the node:</simpara>
<itemizedlist>
<listitem>
<simpara>Changes to the SSH key in the <literal>spec.config.passwd.users.sshAuthorizedKeys</literal> parameter of a machine config.</simpara>
</listitem>
<listitem>
<simpara>Changes to the global pull secret or pull secret in the <literal>openshift-config</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Automatic rotation of the <literal>/etc/kubernetes/kubelet-ca.crt</literal> certificate authority (CA) by the Kubernetes API Server Operator.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>When the MCO detects changes to the <literal>/etc/containers/registries.conf</literal> file, such as adding or editing an <literal>ImageDigestMirrorSet</literal>, <literal>ImageTagMirrorSet</literal>, or <literal>ImageContentSourcePolicy</literal> object, it drains the corresponding nodes, applies the changes, and uncordons the nodes. The node drain does not happen for the following changes:</simpara>
<itemizedlist>
<listitem>
<simpara>The addition of a registry with the <literal>pull-from-mirror = "digest-only"</literal> parameter set for each mirror.</simpara>
</listitem>
<listitem>
<simpara>The addition of a mirror with the <literal>pull-from-mirror = "digest-only"</literal> parameter set in a registry.</simpara>
</listitem>
<listitem>
<simpara>The addition of items to the <literal>unqualified-search-registries</literal> list.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</note>
<simpara>To avoid unwanted disruptions, you can modify the machine config pool (MCP) to prevent automatic rebooting after the Operator makes changes to the machine config.</simpara>
<section xml:id="troubleshooting-disabling-autoreboot-mco-console_olm-troubleshooting-operator-issues">
<title>Disabling the Machine Config Operator from automatically rebooting by using the console</title>
<simpara>To avoid unwanted disruptions from changes made by the Machine Config Operator (MCO), you can use the {product-title} web console to modify the machine config pool (MCP) to prevent the MCO from making any changes to nodes in that pool. This prevents any reboots that would normally be part of the MCO update process.</simpara>
<note>
<simpara>See second <literal>NOTE</literal> in <link xl:href="../../support/troubleshooting/troubleshooting-operator-issues.xml#troubleshooting-disabling-autoreboot-mco_troubleshooting-operator-issues">Disabling the Machine Config Operator from automatically rebooting</link>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To pause or unpause automatic MCO update rebooting:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Pause the autoreboot process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the {product-title} web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineConfigPools</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">MachineConfigPools</emphasis> page, click either <emphasis role="strong">master</emphasis> or <emphasis role="strong">worker</emphasis>, depending upon which nodes you want to pause rebooting for.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">master</emphasis> or <emphasis role="strong">worker</emphasis> page, click <emphasis role="strong">YAML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the YAML, update the <literal>spec.paused</literal> field to <literal>true</literal>.</simpara>
<formalpara>
<title>Sample MachineConfigPool object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
# ...
spec:
# ...
  paused: true <co xml:id="CO50-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO50-1">
<para>Update the <literal>spec.paused</literal> field to <literal>true</literal> to pause rebooting.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To verify that the MCP is paused, return to the <emphasis role="strong">MachineConfigPools</emphasis> page.</simpara>
<simpara>On the <emphasis role="strong">MachineConfigPools</emphasis> page, the <emphasis role="strong">Paused</emphasis> column reports <emphasis role="strong">True</emphasis> for the MCP you modified.</simpara>
<simpara>If the MCP has pending changes while paused, the <emphasis role="strong">Updated</emphasis> column is <emphasis role="strong">False</emphasis> and <emphasis role="strong">Updating</emphasis> is <emphasis role="strong">False</emphasis>. When <emphasis role="strong">Updated</emphasis> is <emphasis role="strong">True</emphasis> and <emphasis role="strong">Updating</emphasis> is <emphasis role="strong">False</emphasis>, there are no pending changes.</simpara>
<important>
<simpara>If there are pending changes (where both the <emphasis role="strong">Updated</emphasis> and <emphasis role="strong">Updating</emphasis> columns are <emphasis role="strong">False</emphasis>), it is recommended to schedule a maintenance window for a reboot as early as possible. Use the following steps for unpausing the autoreboot process to apply the changes that were queued since the last reboot.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Unpause the autoreboot process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the {product-title} web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineConfigPools</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">MachineConfigPools</emphasis> page, click either <emphasis role="strong">master</emphasis> or <emphasis role="strong">worker</emphasis>, depending upon which nodes you want to pause rebooting for.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">master</emphasis> or <emphasis role="strong">worker</emphasis> page, click <emphasis role="strong">YAML</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the YAML, update the <literal>spec.paused</literal> field to <literal>false</literal>.</simpara>
<formalpara>
<title>Sample MachineConfigPool object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
# ...
spec:
# ...
  paused: false <co xml:id="CO51-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO51-1">
<para>Update the <literal>spec.paused</literal> field to <literal>false</literal> to allow rebooting.</para>
</callout>
</calloutlist>
<note>
<simpara>By unpausing an MCP, the MCO applies all paused changes reboots Red Hat Enterprise Linux CoreOS (RHCOS) as needed.</simpara>
</note>
</listitem>
<listitem>
<simpara>To verify that the MCP is paused, return to the <emphasis role="strong">MachineConfigPools</emphasis> page.</simpara>
<simpara>On the <emphasis role="strong">MachineConfigPools</emphasis> page, the <emphasis role="strong">Paused</emphasis> column reports <emphasis role="strong">False</emphasis> for the MCP you modified.</simpara>
<simpara>If the MCP is applying any pending changes, the <emphasis role="strong">Updated</emphasis> column is <emphasis role="strong">False</emphasis> and the <emphasis role="strong">Updating</emphasis> column is <emphasis role="strong">True</emphasis>. When <emphasis role="strong">Updated</emphasis> is <emphasis role="strong">True</emphasis> and <emphasis role="strong">Updating</emphasis> is <emphasis role="strong">False</emphasis>, there are no further changes being made.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="troubleshooting-disabling-autoreboot-mco-cli_olm-troubleshooting-operator-issues">
<title>Disabling the Machine Config Operator from automatically rebooting by using the CLI</title>
<simpara>To avoid unwanted disruptions from changes made by the Machine Config Operator (MCO), you can modify the machine config pool (MCP) using the OpenShift CLI (oc) to prevent the MCO from making any changes to nodes in that pool. This prevents any reboots that would normally be part of the MCO update process.</simpara>
<note>
<simpara>See second <literal>NOTE</literal> in <link xl:href="../../support/troubleshooting/troubleshooting-operator-issues.xml#troubleshooting-disabling-autoreboot-mco_troubleshooting-operator-issues">Disabling the Machine Config Operator from automatically rebooting</link>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To pause or unpause automatic MCO update rebooting:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Pause the autoreboot process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Update the <literal>MachineConfigPool</literal> custom resource to set the <literal>spec.paused</literal> field to <literal>true</literal>.</simpara>
<formalpara>
<title>Control plane (master) nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch --type=merge --patch='{"spec":{"paused":true}}' machineconfigpool/master</programlisting>
</para>
</formalpara>
<formalpara>
<title>Worker nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch --type=merge --patch='{"spec":{"paused":true}}' machineconfigpool/worker</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the MCP is paused:</simpara>
<formalpara>
<title>Control plane (master) nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool/master --template='{{.spec.paused}}'</programlisting>
</para>
</formalpara>
<formalpara>
<title>Worker nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool/worker --template='{{.spec.paused}}'</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">true</programlisting>
</para>
</formalpara>
<simpara>The <literal>spec.paused</literal> field is <literal>true</literal> and the MCP is paused.</simpara>
</listitem>
<listitem>
<simpara>Determine if the MCP has pending changes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get machineconfigpool</programlisting>
<formalpara>
<title>Example output</title>
<para>
<screen>NAME     CONFIG                                             UPDATED   UPDATING
master   rendered-master-33cf0a1254318755d7b48002c597bf91   True      False
worker   rendered-worker-e405a5bdb0db1295acea08bcca33fa60   False     False</screen>
</para>
</formalpara>
<simpara>If the <emphasis role="strong">UPDATED</emphasis> column is <emphasis role="strong">False</emphasis> and <emphasis role="strong">UPDATING</emphasis> is <emphasis role="strong">False</emphasis>, there are pending changes. When <emphasis role="strong">UPDATED</emphasis> is <emphasis role="strong">True</emphasis> and <emphasis role="strong">UPDATING</emphasis> is <emphasis role="strong">False</emphasis>, there are no pending changes. In the previous example, the worker node has pending changes. The control plane node does not have any pending changes.</simpara>
<important>
<simpara>If there are pending changes (where both the <emphasis role="strong">Updated</emphasis> and <emphasis role="strong">Updating</emphasis> columns are <emphasis role="strong">False</emphasis>), it is recommended to schedule a maintenance window for a reboot as early as possible. Use the following steps for unpausing the autoreboot process to apply the changes that were queued since the last reboot.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Unpause the autoreboot process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Update the <literal>MachineConfigPool</literal> custom resource to set the <literal>spec.paused</literal> field to <literal>false</literal>.</simpara>
<formalpara>
<title>Control plane (master) nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch --type=merge --patch='{"spec":{"paused":false}}' machineconfigpool/master</programlisting>
</para>
</formalpara>
<formalpara>
<title>Worker nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch --type=merge --patch='{"spec":{"paused":false}}' machineconfigpool/worker</programlisting>
</para>
</formalpara>
<note>
<simpara>By unpausing an MCP, the MCO applies all paused changes and reboots Red Hat Enterprise Linux CoreOS (RHCOS) as needed.</simpara>
</note>
</listitem>
<listitem>
<simpara>Verify that the MCP is unpaused:</simpara>
<formalpara>
<title>Control plane (master) nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool/master --template='{{.spec.paused}}'</programlisting>
</para>
</formalpara>
<formalpara>
<title>Worker nodes</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool/worker --template='{{.spec.paused}}'</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">false</programlisting>
</para>
</formalpara>
<simpara>The <literal>spec.paused</literal> field is <literal>false</literal> and the MCP is unpaused.</simpara>
</listitem>
<listitem>
<simpara>Determine if the MCP has pending changes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool</programlisting>
<formalpara>
<title>Example output</title>
<para>
<screen>NAME     CONFIG                                   UPDATED  UPDATING
master   rendered-master-546383f80705bd5aeaba93   True     False
worker   rendered-worker-b4c51bb33ccaae6fc4a6a5   False    True</screen>
</para>
</formalpara>
<simpara>If the MCP is applying any pending changes, the <emphasis role="strong">UPDATED</emphasis> column is <emphasis role="strong">False</emphasis> and the <emphasis role="strong">UPDATING</emphasis> column is <emphasis role="strong">True</emphasis>. When <emphasis role="strong">UPDATED</emphasis> is <emphasis role="strong">True</emphasis> and <emphasis role="strong">UPDATING</emphasis> is <emphasis role="strong">False</emphasis>, there are no further changes being made. In the previous example, the MCO is updating the worker node.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-refresh-subs_olm-troubleshooting-operator-issues">
<title>Refreshing failing subscriptions</title>
<simpara>In Operator Lifecycle Manager (OLM), if you subscribe to an Operator that references images that are not accessible on your network, you can find jobs in the <literal>openshift-marketplace</literal> namespace that are failing with the following errors:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ImagePullBackOff for
Back-off pulling image "example.com/openshift4/ose-elasticsearch-operator-bundle@sha256:6d2587129c846ec28d384540322b40b05833e7e00b25cca584e004af9a1d292e"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">rpc error: code = Unknown desc = error pinging docker registry example.com: Get "https://example.com/v2/": dial tcp: lookup example.com on 10.0.0.1:53: no such host</programlisting>
</para>
</formalpara>
<simpara>As a result, the subscription is stuck in this failing state and the Operator is unable to install or upgrade.</simpara>
<simpara>You can refresh a failing subscription by deleting the subscription, cluster service version (CSV), and other related objects. After recreating the subscription, OLM then reinstalls the correct version of the Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a failing subscription that is unable to pull an inaccessible bundle image.</simpara>
</listitem>
<listitem>
<simpara>You have confirmed that the correct bundle image is accessible.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the names of the <literal>Subscription</literal> and <literal>ClusterServiceVersion</literal> objects from the namespace where the Operator is installed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sub,csv -n &lt;namespace&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       PACKAGE                  SOURCE             CHANNEL
subscription.operators.coreos.com/elasticsearch-operator   elasticsearch-operator   redhat-operators   5.0

NAME                                                                         DISPLAY                            VERSION    REPLACES   PHASE
clusterserviceversion.operators.coreos.com/elasticsearch-operator.5.0.0-65   OpenShift Elasticsearch Operator   5.0.0-65              Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the subscription:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete subscription &lt;subscription_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Delete the cluster service version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete csv &lt;csv_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
<listitem>
<simpara>Get the names of any failing jobs and related config maps in the <literal>openshift-marketplace</literal> namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get job,configmap -n openshift-marketplace</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                                        COMPLETIONS   DURATION   AGE
job.batch/1de9443b6324e629ddf31fed0a853a121275806170e34c926d69e53a7fcbccb   1/1           26s        9m30s

NAME                                                                        DATA   AGE
configmap/1de9443b6324e629ddf31fed0a853a121275806170e34c926d69e53a7fcbccb   3      9m30s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the job:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete job &lt;job_name&gt; -n openshift-marketplace</programlisting>
<simpara>This ensures pods that try to pull the inaccessible image are not recreated.</simpara>
</listitem>
<listitem>
<simpara>Delete the config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete configmap &lt;configmap_name&gt; -n openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Reinstall the Operator using OperatorHub in the web console.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the Operator has been reinstalled successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sub,csv,installplan -n &lt;namespace&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-reinstall_olm-troubleshooting-operator-issues">
<title>Reinstalling Operators after failed uninstallation</title>
<simpara>You must successfully and completely uninstall an Operator prior to attempting to reinstall the same Operator. Failure to fully uninstall the Operator properly can leave resources, such as a project or namespace, stuck in a "Terminating" state and cause "error resolving resource" messages. For example:</simpara>
<formalpara>
<title>Example <literal>Project</literal> resource description</title>
<para>
<screen>...
    message: 'Failed to delete all resource types, 1 remaining: Internal error occurred:
      error resolving resource'
...</screen>
</para>
</formalpara>
<simpara>These types of issues can prevent an Operator from being reinstalled successfully.</simpara>
<warning>
<simpara>Forced deletion of a namespace is not likely to resolve "Terminating" state issues and can lead to unstable or unpredictable cluster behavior, so it is better to try to find related resources that might be preventing the namespace from being deleted. For more information, see the <link xl:href="https://access.redhat.com/solutions/4165791">Red Hat Knowledgebase Solution #4165791</link>, paying careful attention to the cautions and warnings.</simpara>
</warning>
<simpara>The following procedure shows how to troubleshoot when an Operator cannot be reinstalled because an existing custom resource definition (CRD) from a previous installation of the Operator is preventing a related namespace from deleting successfully.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Check if there are any namespaces related to the Operator that are stuck in "Terminating" state:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get namespaces</programlisting>
<formalpara>
<title>Example output</title>
<para>
<screen>operator-ns-1                                       Terminating</screen>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check if there are any CRDs related to the Operator that are still present after the failed uninstallation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crds</programlisting>
<note>
<simpara>CRDs are global cluster definitions; the actual custom resource (CR) instances related to the CRDs could be in other namespaces or be global cluster instances.</simpara>
</note>
</listitem>
<listitem>
<simpara>If there are any CRDs that you know were provided or managed by the Operator and that should have been deleted after uninstallation, delete the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete crd &lt;crd_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Check if there are any remaining CR instances related to the Operator that are still present after uninstallation, and if so, delete the CRs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>The type of CRs to search for can be difficult to determine after uninstallation and can require knowing what CRDs the Operator manages. For example, if you are troubleshooting an uninstallation of the etcd Operator, which provides the <literal>EtcdCluster</literal> CRD, you can search for remaining <literal>EtcdCluster</literal> CRs in a namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get EtcdCluster -n &lt;namespace_name&gt;</programlisting>
<simpara>Alternatively, you can search across all namespaces:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get EtcdCluster --all-namespaces</programlisting>
</listitem>
<listitem>
<simpara>If there are any remaining CRs that should be removed, delete the instances:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete &lt;cr_name&gt; &lt;cr_instance_name&gt; -n &lt;namespace_name&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the namespace deletion has successfully resolved:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get namespace &lt;namespace_name&gt;</programlisting>
<important>
<simpara>If the namespace or other Operator resources are still not uninstalled cleanly, contact Red Hat Support.</simpara>
</important>
</listitem>
<listitem>
<simpara>Reinstall the Operator using OperatorHub in the web console.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Check that the Operator has been reinstalled successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sub,csv,installplan -n &lt;namespace&gt;</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-deleting-operators-from-cluster.xml#olm-deleting-operators-from-a-cluster">Deleting Operators from a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-adding-operators-to-a-cluster">Adding Operators to a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_developing_operators">
<title>Developing Operators</title>
<section xml:id="osdk-about">
<title>About the Operator SDK</title>

<simpara>The <link xl:href="https://operatorframework.io/">Operator Framework</link> is an open source toolkit to manage Kubernetes native applications, called <emphasis>Operators</emphasis>, in an effective, automated, and scalable way. Operators take advantage of Kubernetes extensibility to deliver the automation advantages of cloud services, like provisioning, scaling, and backup and restore, while being able to run anywhere that Kubernetes can run.</simpara>
<simpara>Operators make it easy to manage complex, stateful applications on top of Kubernetes. However, writing an Operator today can be difficult because of challenges such as using low-level APIs, writing boilerplate, and a lack of modularity, which leads to duplication.</simpara>
<simpara>The Operator SDK, a component of the Operator Framework, provides a command-line interface (CLI) tool that Operator developers can use to build, test, and deploy an Operator.</simpara>
<simpara><emphasis role="strong">Why use the Operator SDK?</emphasis></simpara>
<simpara>The Operator SDK simplifies this process of building Kubernetes-native applications, which can require deep, application-specific operational knowledge. The Operator SDK not only lowers that barrier, but it also helps reduce the amount of boilerplate code required for many common management capabilities, such as metering or monitoring.</simpara>
<simpara>The Operator SDK is a framework that uses the <link xl:href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</link> library to make writing Operators easier by providing the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>High-level APIs and abstractions to write the operational logic more intuitively</simpara>
</listitem>
<listitem>
<simpara>Tools for scaffolding and code generation to quickly bootstrap a new project</simpara>
</listitem>
<listitem>
<simpara>Integration with Operator Lifecycle Manager (OLM) to streamline packaging, installing, and running Operators on a cluster</simpara>
</listitem>
<listitem>
<simpara>Extensions to cover common Operator use cases</simpara>
</listitem>
<listitem>
<simpara>Metrics set up automatically in any generated Go-based Operator for use on clusters where the Prometheus Operator is deployed</simpara>
</listitem>
</itemizedlist>
<simpara>Operator authors with cluster administrator access to a Kubernetes-based cluster (such as {product-title})
can use the Operator SDK CLI to develop their own Operators based on Go, Ansible, Java, or Helm. <link xl:href="https://kubebuilder.io/">Kubebuilder</link> is embedded into the Operator SDK as the scaffolding solution for Go-based Operators, which means existing Kubebuilder projects can be used as is with the Operator SDK and continue to work.</simpara>
<note>
<simpara>{product-title} {product-version} supports Operator SDK 1.31.0.</simpara>
</note>
<section xml:id="osdk-about-what-are-operators">
<title>What are Operators?</title>
<simpara>For an overview about basic Operator concepts and terminology, see <link xl:href="../../operators/understanding/olm-what-operators-are.xml#olm-what-operators-are">Understanding Operators</link>.</simpara>
</section>
<section xml:id="osdk-workflow_osdk-about">
<title>Development workflow</title>
<simpara>The Operator SDK provides the following workflow to develop a new Operator:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create an Operator project by using the Operator SDK command-line interface (CLI).</simpara>
</listitem>
<listitem>
<simpara>Define new resource APIs by adding custom resource definitions (CRDs).</simpara>
</listitem>
<listitem>
<simpara>Specify resources to watch by using the Operator SDK API.</simpara>
</listitem>
<listitem>
<simpara>Define the Operator reconciling logic in a designated handler and use the Operator SDK API to interact with resources.</simpara>
</listitem>
<listitem>
<simpara>Use the Operator SDK CLI to build and generate the Operator deployment manifests.</simpara>
</listitem>
</orderedlist>
<figure>
<title>Operator SDK workflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/osdk-workflow.png"/>
</imageobject>
<textobject><phrase>osdk workflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>At a high level, an Operator that uses the Operator SDK processes events for watched resources in an Operator author-defined handler and takes actions to reconcile the state of the application.</simpara>
</section>
<section xml:id="osdk-about-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://redhat-connect.gitbook.io/certified-operator-guide/">Certified Operator Build Guide</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-installing-cli">
<title>Installing the Operator SDK CLI</title>

<simpara>The Operator SDK provides a command-line interface (CLI) tool that Operator developers can use to build, test, and deploy an Operator. You can install the Operator SDK CLI on your workstation so that you are prepared to start authoring your own Operators.</simpara>
<simpara>Operator authors with cluster administrator access to a Kubernetes-based cluster, such as {product-title},
can use the Operator SDK CLI to develop their own Operators based on Go, Ansible, Java, or Helm. <link xl:href="https://kubebuilder.io/">Kubebuilder</link> is embedded into the Operator SDK as the scaffolding solution for Go-based Operators, which means existing Kubebuilder projects can be used as is with the Operator SDK and continue to work.</simpara>
<note>
<simpara>{product-title} {product-version} supports Operator SDK 1.31.0.</simpara>
</note>
<section xml:id="osdk-installing-cli-linux-macos_osdk-installing-cli">
<title>Installing the Operator SDK CLI on Linux</title>
<simpara>You can install the OpenShift SDK CLI tool on Linux.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xl:href="https://golang.org/dl/">Go</link> v1.19+</simpara>
</listitem>
<listitem>
<simpara><literal>docker</literal> v17.03+, <literal>podman</literal> v1.9.3+, or <literal>buildah</literal> v1.7+</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the <link xl:href="https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/operator-sdk/">OpenShift mirror site</link>.</simpara>
</listitem>
<listitem>
<simpara>From the latest {product-version} directory, download the latest version of the tarball for Linux.</simpara>
</listitem>
<listitem>
<simpara>Unpack the archive:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvf operator-sdk-v1.31.0-ocp-linux-x86_64.tar.gz</programlisting>
</listitem>
<listitem>
<simpara>Make the file executable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod +x operator-sdk</programlisting>
</listitem>
<listitem>
<simpara>Move the extracted <literal>operator-sdk</literal> binary to a directory that is on your <literal>PATH</literal>.</simpara>
<tip>
<simpara>To check your <literal>PATH</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</tip>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo mv ./operator-sdk /usr/local/bin/operator-sdk</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the Operator SDK CLI, verify that it is available:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk version</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">operator-sdk version: "v1.31.0-ocp", ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-installing-cli-macos_osdk-installing-cli">
<title>Installing the Operator SDK CLI on macOS</title>
<simpara>You can install the OpenShift SDK CLI tool on macOS.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xl:href="https://golang.org/dl/">Go</link> v1.19+</simpara>
</listitem>
<listitem>
<simpara><literal>docker</literal> v17.03+, <literal>podman</literal> v1.9.3+, or <literal>buildah</literal> v1.7+</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>For the <literal>amd64</literal> and <literal>arm64</literal> architectures, navigate to the <link xl:href="https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/operator-sdk/">OpenShift mirror site for the <literal>amd64</literal> architecture</link> and <link xl:href="https://mirror.openshift.com/pub/openshift-v4/arm64/clients/operator-sdk/">OpenShift mirror site for the <literal>arm64</literal> architecture</link> respectively.</simpara>
</listitem>
<listitem>
<simpara>From the latest {product-version} directory, download the latest version of the tarball for macOS.</simpara>
</listitem>
<listitem>
<simpara>Unpack the Operator SDK archive for <literal>amd64</literal> architecture by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvf operator-sdk-v1.31.0-ocp-darwin-x86_64.tar.gz</programlisting>
</listitem>
<listitem>
<simpara>Unpack the Operator SDK archive for <literal>arm64</literal> architecture by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvf operator-sdk-v1.31.0-ocp-darwin-aarch64.tar.gz</programlisting>
</listitem>
<listitem>
<simpara>Make the file executable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod +x operator-sdk</programlisting>
</listitem>
<listitem>
<simpara>Move the extracted <literal>operator-sdk</literal> binary to a directory that is on your <literal>PATH</literal> by running the following command:</simpara>
<tip>
<simpara>Check your <literal>PATH</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</tip>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo mv ./operator-sdk /usr/local/bin/operator-sdk</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the Operator SDK CLI, verify that it is available by running the following command::</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk version</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">operator-sdk version: "v1.31.0-ocp", ...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="_go_based_operators">
<title>Go-based Operators</title>
<section xml:id="osdk-golang-quickstart">
<title>Getting started with Operator SDK for Go-based Operators</title>

<simpara>To demonstrate the basics of setting up and running a Go-based Operator using tools and libraries provided by the Operator SDK, Operator developers can build an example Go-based Operator for Memcached, a distributed key-value store, and deploy it to a cluster.</simpara>
<section xml:id="osdk-common-prereqs_osdk-golang-quickstart">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://golang.org/dl/">Go</link> 1.19+</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-quickstart_osdk-golang-quickstart">
<title>Creating and deploying Go-based Operators</title>
<simpara>You can build and deploy a simple Go-based Operator for Memcached by using the Operator SDK.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara><emphasis role="strong">Create a project.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create your project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change into the project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --domain=example.com \
    --repo=github.com/example-inc/memcached-operator</programlisting>
<simpara>The command uses the Go plugin by default.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create an API.</emphasis></simpara>
<simpara>Create a simple Memcached API:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --resource=true \
    --controller=true \
    --group cache \
    --version v1 \
    --kind Memcached</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Build and push the Operator image.</emphasis></simpara>
<simpara>Use the default <literal>Makefile</literal> targets to build and push your Operator. Set <literal>IMG</literal> with a pull spec for your image that uses a registry you can push to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Run the Operator.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Install the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
</listitem>
<listitem>
<simpara>Deploy the project to the cluster. Set <literal>IMG</literal> to the image that you pushed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create a sample custom resource (CR).</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a sample CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml \
    -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Watch for the CR to reconcile the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment.apps/memcached-operator-controller-manager \
    -c manager \
    -n memcached-operator-system</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete a CR.</emphasis></simpara>
<simpara>Delete a CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Clean up.</emphasis></simpara>
<simpara>Run the following command to clean up the resources that have been created as part of this procedure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-golang-quickstart-next-steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-golang-tutorial">Operator SDK tutorial for Go-based Operators</link> for a more in-depth walkthrough on building a Go-based Operator.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-golang-tutorial">
<title>Operator SDK tutorial for Go-based Operators</title>

<simpara>Operator developers can take advantage of Go programming language support in the Operator SDK to build an example Go-based Operator for Memcached, a distributed key-value store, and manage its lifecycle.</simpara>
<simpara>This process is accomplished using two centerpieces of the Operator Framework:</simpara>
<variablelist>
<varlistentry>
<term>Operator SDK</term>
<listitem>
<simpara>The <literal>operator-sdk</literal> CLI tool and <literal>controller-runtime</literal> library API</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager (OLM)</term>
<listitem>
<simpara>Installation, upgrade, and role-based access control (RBAC) of Operators on a cluster</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>This tutorial goes into greater detail than <link xl:href="../../../operators/operator_sdk/golang/osdk-golang-quickstart.xml#osdk-golang-quickstart">Getting started with Operator SDK for Go-based Operators</link>.</simpara>
</note>
<section xml:id="osdk-common-prereqs_osdk-golang-tutorial">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://golang.org/dl/">Go</link> 1.19+</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-create-project_osdk-golang-tutorial">
<title>Creating a project</title>
<simpara>Use the Operator SDK CLI to create a project called <literal>memcached-operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change to the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Activate support for Go modules:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export GO111MODULE=on</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --domain=example.com \
    --repo=github.com/example-inc/memcached-operator</programlisting>
<note>
<simpara>The <literal>operator-sdk init</literal> command uses the Go plugin by default.</simpara>
</note>
<simpara>The <literal>operator-sdk init</literal> command generates a <literal>go.mod</literal> file to be used with <link xl:href="https://golang.org/ref/mod">Go modules</link>. The <literal>--repo</literal> flag is required when creating a project outside of <literal>$GOPATH/src/</literal>, because generated files require a valid module path.</simpara>
</listitem>
</orderedlist>
<section xml:id="osdk-project-file_osdk-golang-tutorial">
<title>PROJECT file</title>
<simpara>Among the files generated by the <literal>operator-sdk init</literal> command is a Kubebuilder <literal>PROJECT</literal> file. Subsequent <literal>operator-sdk</literal> commands, as well as <literal>help</literal> output, that are run from the project root read this file and are aware that the project type is Go. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">domain: example.com
layout:
- go.kubebuilder.io/v3
projectName: memcached-operator
repo: github.com/example-inc/memcached-operator
version: "3"
plugins:
  manifests.sdk.operatorframework.io/v2: {}
  scorecard.sdk.operatorframework.io/v2: {}
  sdk.x-openshift.io/v1: {}</programlisting>
</section>
<section xml:id="osdk-golang-manager_osdk-golang-tutorial">
<title>About the Manager</title>
<simpara>The main program for the Operator is the <literal>main.go</literal> file, which initializes and runs the <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/manager#Manager">Manager</link>. The Manager automatically registers the Scheme for all custom resource (CR) API definitions and sets up and runs controllers and webhooks.</simpara>
<simpara>The Manager can restrict the namespace that all controllers watch for resources:</simpara>
<programlisting language="go" linenumbering="unnumbered">mgr, err := ctrl.NewManager(cfg, manager.Options{Namespace: namespace})</programlisting>
<simpara>By default, the Manager watches the namespace where the Operator runs. To watch all namespaces, you can leave the <literal>namespace</literal> option empty:</simpara>
<programlisting language="go" linenumbering="unnumbered">mgr, err := ctrl.NewManager(cfg, manager.Options{Namespace: ""})</programlisting>
<simpara>You can also use the <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/cache#MultiNamespacedCacheBuilder"><literal>MultiNamespacedCacheBuilder</literal></link> function to watch a specific set of namespaces:</simpara>
<programlisting language="go" linenumbering="unnumbered">var namespaces []string <co xml:id="CO52-1"/>
mgr, err := ctrl.NewManager(cfg, manager.Options{ <co xml:id="CO52-2"/>
   NewCache: cache.MultiNamespacedCacheBuilder(namespaces),
})</programlisting>
<calloutlist>
<callout arearefs="CO52-1">
<para>List of namespaces.</para>
</callout>
<callout arearefs="CO52-2">
<para>Creates a <literal>Cmd</literal> struct to provide shared dependencies and start components.</para>
</callout>
</calloutlist>
</section>
<section xml:id="osdk-golang-multi-group-apis_osdk-golang-tutorial">
<title>About multi-group APIs</title>
<simpara>Before you create an API and controller, consider whether your Operator requires multiple API groups. This tutorial covers the default case of a single group API, but to change the layout of your project to support multi-group APIs, you can run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk edit --multigroup=true</programlisting>
<simpara>This command updates the <literal>PROJECT</literal> file, which should look like the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">domain: example.com
layout: go.kubebuilder.io/v3
multigroup: true
...</programlisting>
<simpara>For multi-group projects, the API Go type files are created in the <literal>apis/&lt;group&gt;/&lt;version&gt;/</literal> directory, and the controllers are created in the <literal>controllers/&lt;group&gt;/</literal> directory. The Dockerfile is then updated accordingly.</simpara>
<itemizedlist>
<title>Additional resource</title>
<listitem>
<simpara>For more details on migrating to a multi-group project, see the <link xl:href="https://book.kubebuilder.io/migration/multi-group.html">Kubebuilder documentation</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-golang-create-api-controller_osdk-golang-tutorial">
<title>Creating an API and controller</title>
<simpara>Use the Operator SDK CLI to create a custom resource definition (CRD) API and controller.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to create an API with group <literal>cache</literal>, version, <literal>v1</literal>, and kind <literal>Memcached</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group=cache \
    --version=v1 \
    --kind=Memcached</programlisting>
</listitem>
<listitem>
<simpara>When prompted, enter <literal>y</literal> for creating both the resource and controller:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">Create Resource [y/n]
y
Create Controller [y/n]
y</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Writing scaffold for you to edit...
api/v1/memcached_types.go
controllers/memcached_controller.go
...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<simpara>This process generates the <literal>Memcached</literal> resource API at <literal>api/v1/memcached_types.go</literal> and the controller at <literal>controllers/memcached_controller.go</literal>.</simpara>
<section xml:id="osdk-golang-define-api_osdk-golang-tutorial">
<title>Defining the API</title>
<simpara>Define the API for the <literal>Memcached</literal> custom resource (CR).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Modify the Go type definitions at <literal>api/v1/memcached_types.go</literal> to have the following <literal>spec</literal> and <literal>status</literal>:</simpara>
<programlisting language="go" linenumbering="unnumbered">// MemcachedSpec defines the desired state of Memcached
type MemcachedSpec struct {
	// +kubebuilder:validation:Minimum=0
	// Size is the size of the memcached deployment
	Size int32 `json:"size"`
}

// MemcachedStatus defines the observed state of Memcached
type MemcachedStatus struct {
	// Nodes are the names of the memcached pods
	Nodes []string `json:"nodes"`
}</programlisting>
</listitem>
<listitem>
<simpara>Update the generated code for the resource type:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make generate</programlisting>
<tip>
<simpara>After you modify a <literal>*_types.go</literal> file, you must run the <literal>make generate</literal> command to update the generated code for that resource type.</simpara>
</tip>
<simpara>The above Makefile target invokes the <literal>controller-gen</literal> utility to update the <literal>api/v1/zz_generated.deepcopy.go</literal> file. This ensures your API Go type definitions implement the <literal>runtime.Object</literal> interface that all Kind types must implement.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-golang-generate-crd_osdk-golang-tutorial">
<title>Generating CRD manifests</title>
<simpara>After the API is defined with <literal>spec</literal> and <literal>status</literal> fields and custom resource definition (CRD) validation markers, you can generate CRD manifests.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to generate and update CRD manifests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make manifests</programlisting>
<simpara>This Makefile target invokes the <literal>controller-gen</literal> utility to generate the CRD manifests in the <literal>config/crd/bases/cache.example.com_memcacheds.yaml</literal> file.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-about-openapi-validation_osdk-golang-tutorial">
<title>About OpenAPI validation</title>
<simpara>OpenAPIv3 schemas are added to CRD manifests in the <literal>spec.validation</literal> block when the manifests are generated. This validation block allows Kubernetes to validate the properties in a Memcached custom resource (CR) when it is created or updated.</simpara>
<simpara>Markers, or annotations, are available to configure validations for your API. These markers always have a <literal>+kubebuilder:validation</literal> prefix.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more details on the usage of markers in API code, see the following Kubebuilder documentation:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://book.kubebuilder.io/reference/generating-crd.html">CRD generation</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://book.kubebuilder.io/reference/markers.html">Markers</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://book.kubebuilder.io/reference/markers/crd-validation.html">List of OpenAPIv3 validation markers</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>For more details about OpenAPIv3 validation schemas in CRDs, see the <link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema">Kubernetes documentation</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-golang-implement-controller_osdk-golang-tutorial">
<title>Implementing the controller</title>
<simpara>After creating a new API and controller, you can implement the controller logic.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>For this example, replace the generated controller file <literal>controllers/memcached_controller.go</literal> with following example implementation:</simpara>
<example>
<title>Example <literal>memcached_controller.go</literal></title>
<programlisting language="golang" linenumbering="unnumbered">/*
Copyright 2020.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "reflect"

        "context"

        "github.com/go-logr/logr"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        ctrllog "sigs.k8s.io/controller-runtime/pkg/log"

        cachev1 "github.com/example-inc/memcached-operator/api/v1"
)

// MemcachedReconciler reconciles a Memcached object
type MemcachedReconciler struct {
        client.Client
        Log    logr.Logger
        Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the Memcached object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.7.0/pkg/reconcile
func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
        //log := r.Log.WithValues("memcached", req.NamespacedName)
        log := ctrllog.FromContext(ctx)
        // Fetch the Memcached instance
        memcached := &amp;cachev1.Memcached{}
        err := r.Get(ctx, req.NamespacedName, memcached)
        if err != nil {
                if errors.IsNotFound(err) {
                        // Request object not found, could have been deleted after reconcile request.
                        // Owned objects are automatically garbage collected. For additional cleanup logic use finalizers.
                        // Return and don't requeue
                        log.Info("Memcached resource not found. Ignoring since object must be deleted")
                        return ctrl.Result{}, nil
                }
                // Error reading the object - requeue the request.
                log.Error(err, "Failed to get Memcached")
                return ctrl.Result{}, err
        }

        // Check if the deployment already exists, if not create a new one
        found := &amp;appsv1.Deployment{}
        err = r.Get(ctx, types.NamespacedName{Name: memcached.Name, Namespace: memcached.Namespace}, found)
        if err != nil &amp;&amp; errors.IsNotFound(err) {
                // Define a new deployment
                dep := r.deploymentForMemcached(memcached)
                log.Info("Creating a new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
                err = r.Create(ctx, dep)
                if err != nil {
                        log.Error(err, "Failed to create new Deployment", "Deployment.Namespace", dep.Namespace, "Deployment.Name", dep.Name)
                        return ctrl.Result{}, err
                }
                // Deployment created successfully - return and requeue
                return ctrl.Result{Requeue: true}, nil
        } else if err != nil {
                log.Error(err, "Failed to get Deployment")
                return ctrl.Result{}, err
        }

        // Ensure the deployment size is the same as the spec
        size := memcached.Spec.Size
        if *found.Spec.Replicas != size {
                found.Spec.Replicas = &amp;size
                err = r.Update(ctx, found)
                if err != nil {
                        log.Error(err, "Failed to update Deployment", "Deployment.Namespace", found.Namespace, "Deployment.Name", found.Name)
                        return ctrl.Result{}, err
                }
                // Spec updated - return and requeue
                return ctrl.Result{Requeue: true}, nil
        }

        // Update the Memcached status with the pod names
        // List the pods for this memcached's deployment
        podList := &amp;corev1.PodList{}
        listOpts := []client.ListOption{
                client.InNamespace(memcached.Namespace),
                client.MatchingLabels(labelsForMemcached(memcached.Name)),
        }
        if err = r.List(ctx, podList, listOpts...); err != nil {
                log.Error(err, "Failed to list pods", "Memcached.Namespace", memcached.Namespace, "Memcached.Name", memcached.Name)
                return ctrl.Result{}, err
        }
        podNames := getPodNames(podList.Items)

        // Update status.Nodes if needed
        if !reflect.DeepEqual(podNames, memcached.Status.Nodes) {
                memcached.Status.Nodes = podNames
                err := r.Status().Update(ctx, memcached)
                if err != nil {
                        log.Error(err, "Failed to update Memcached status")
                        return ctrl.Result{}, err
                }
        }

        return ctrl.Result{}, nil
}

// deploymentForMemcached returns a memcached Deployment object
func (r *MemcachedReconciler) deploymentForMemcached(m *cachev1.Memcached) *appsv1.Deployment {
        ls := labelsForMemcached(m.Name)
        replicas := m.Spec.Size

        dep := &amp;appsv1.Deployment{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      m.Name,
                        Namespace: m.Namespace,
                },
                Spec: appsv1.DeploymentSpec{
                        Replicas: &amp;replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: ls,
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: ls,
                                },
                                Spec: corev1.PodSpec{
                                        Containers: []corev1.Container{{
                                                Image:   "memcached:1.4.36-alpine",
                                                Name:    "memcached",
                                                Command: []string{"memcached", "-m=64", "-o", "modern", "-v"},
                                                Ports: []corev1.ContainerPort{{
                                                        ContainerPort: 11211,
                                                        Name:          "memcached",
                                                }},
                                        }},
                                },
                        },
                },
        }
        // Set Memcached instance as the owner and controller
        ctrl.SetControllerReference(m, dep, r.Scheme)
        return dep
}

// labelsForMemcached returns the labels for selecting the resources
// belonging to the given memcached CR name.
func labelsForMemcached(name string) map[string]string {
        return map[string]string{"app": "memcached", "memcached_cr": name}
}

// getPodNames returns the pod names of the array of pods passed in
func getPodNames(pods []corev1.Pod) []string {
        var podNames []string
        for _, pod := range pods {
                podNames = append(podNames, pod.Name)
        }
        return podNames
}

// SetupWithManager sets up the controller with the Manager.
func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;cachev1.Memcached{}).
                Owns(&amp;appsv1.Deployment{}).
                Complete(r)
}</programlisting>
</example>
<simpara>The example controller runs the following reconciliation logic for each <literal>Memcached</literal> custom resource (CR):</simpara>
<itemizedlist>
<listitem>
<simpara>Create a Memcached deployment if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment size is the same as specified by the <literal>Memcached</literal> CR spec.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>Memcached</literal> CR status with the names of the <literal>memcached</literal> pods.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The next subsections explain how the controller in the example implementation watches resources and how the reconcile loop is triggered. You can skip these subsections to go directly to <link xl:href="../../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-run-operator_osdk-golang-tutorial">Running the Operator</link>.</simpara>
<section xml:id="osdk-golang-controller-resources_osdk-golang-tutorial">
<title>Resources watched by the controller</title>
<simpara>The <literal>SetupWithManager()</literal> function in <literal>controllers/memcached_controller.go</literal> specifies how the controller is built to watch a CR and other resources that are owned and managed by that controller.</simpara>
<programlisting language="go" linenumbering="unnumbered">import (
	...
	appsv1 "k8s.io/api/apps/v1"
	...
)

func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&amp;cachev1.Memcached{}).
		Owns(&amp;appsv1.Deployment{}).
		Complete(r)
}</programlisting>
<simpara><literal>NewControllerManagedBy()</literal> provides a controller builder that allows various controller configurations.</simpara>
<simpara><literal>For(&amp;cachev1.Memcached{})</literal> specifies the <literal>Memcached</literal> type as the primary resource to watch. For each Add, Update, or Delete event for a <literal>Memcached</literal> type, the reconcile loop is sent a reconcile <literal>Request</literal> argument, which consists of a namespace and name key, for that <literal>Memcached</literal> object.</simpara>
<simpara><literal>Owns(&amp;appsv1.Deployment{})</literal> specifies the <literal>Deployment</literal> type as the secondary resource to watch. For each <literal>Deployment</literal> type Add, Update, or Delete event, the event handler maps each event to a reconcile request for the owner of the deployment. In this case, the owner is the <literal>Memcached</literal> object for which the deployment was created.</simpara>
</section>
<section xml:id="osdk-golang-controller-configs_osdk-golang-tutorial">
<title>Controller configurations</title>
<simpara>You can initialize a controller by using many other useful configurations. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the maximum number of concurrent reconciles for the controller by using the <literal>MaxConcurrentReconciles</literal> option, which defaults to <literal>1</literal>:</simpara>
<programlisting language="go" linenumbering="unnumbered">func (r *MemcachedReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&amp;cachev1.Memcached{}).
        Owns(&amp;appsv1.Deployment{}).
        WithOptions(controller.Options{
            MaxConcurrentReconciles: 2,
        }).
        Complete(r)
}</programlisting>
</listitem>
<listitem>
<simpara>Filter watch events using predicates.</simpara>
</listitem>
<listitem>
<simpara>Choose the type of <link xl:href="https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/handler#EventHandler">EventHandler</link> to change how a watch event translates to reconcile requests for the reconcile loop. For Operator relationships that are more complex than primary and secondary resources, you can use the <literal>EnqueueRequestsFromMapFunc</literal> handler to transform a watch event into an arbitrary set of reconcile requests.</simpara>
</listitem>
</itemizedlist>
<simpara>For more details on these and other configurations, see the upstream <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/builder#example-Builder">Builder</link> and <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/controller">Controller</link> GoDocs.</simpara>
</section>
<section xml:id="osdk-golang-controller-reconcile-loop_osdk-golang-tutorial">
<title>Reconcile loop</title>
<simpara>Every controller has a reconciler object with a <literal>Reconcile()</literal> method that implements the reconcile loop. The reconcile loop is passed the <literal>Request</literal> argument, which is a namespace and name key used to find the primary resource object, <literal>Memcached</literal>, from the cache:</simpara>
<programlisting language="go" linenumbering="unnumbered">import (
	ctrl "sigs.k8s.io/controller-runtime"

	cachev1 "github.com/example-inc/memcached-operator/api/v1"
	...
)

func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
  // Lookup the Memcached instance for this reconcile request
  memcached := &amp;cachev1.Memcached{}
  err := r.Get(ctx, req.NamespacedName, memcached)
  ...
}</programlisting>
<simpara>Based on the return values, result, and error, the request might be requeued and the reconcile loop might be triggered again:</simpara>
<programlisting language="go" linenumbering="unnumbered">// Reconcile successful - don't requeue
return ctrl.Result{}, nil
// Reconcile failed due to error - requeue
return ctrl.Result{}, err
// Requeue for any reason other than an error
return ctrl.Result{Requeue: true}, nil</programlisting>
<simpara>You can set the <literal>Result.RequeueAfter</literal> to requeue the request after a grace period as well:</simpara>
<programlisting language="go" linenumbering="unnumbered">import "time"

// Reconcile for any reason other than an error after 5 seconds
return ctrl.Result{RequeueAfter: time.Second*5}, nil</programlisting>
<note>
<simpara>You can return <literal>Result</literal> with <literal>RequeueAfter</literal> set to periodically reconcile a CR.</simpara>
</note>
<simpara>For more on reconcilers, clients, and interacting with resource events, see the <link xl:href="https://sdk.operatorframework.io/docs/building-operators/golang/references/client/">Controller Runtime Client API</link> documentation.</simpara>
</section>
<section xml:id="osdk-golang-controller-rbac-markers_osdk-golang-tutorial">
<title>Permissions and RBAC manifests</title>
<simpara>The controller requires certain RBAC permissions to interact with the resources it manages. These are specified using RBAC markers, such as the following:</simpara>
<programlisting language="go" linenumbering="unnumbered">// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cache.example.com,resources=memcacheds/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=core,resources=pods,verbs=get;list;

func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
  ...
}</programlisting>
<simpara>The <literal>ClusterRole</literal> object manifest at <literal>config/rbac/role.yaml</literal> is generated from the previous markers by using the <literal>controller-gen</literal> utility whenever the <literal>make manifests</literal> command is run.</simpara>
</section>
</section>
<section xml:id="osdk-run-proxy_osdk-golang-tutorial">
<title>Enabling proxy support</title>
<simpara>Operator authors can develop Operators that support network proxies.
Cluster administrators
configure proxy support for the environment variables that are handled by Operator Lifecycle Manager (OLM). To support proxied clusters, your Operator must inspect the environment for the following standard proxy variables and pass the values to Operands:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HTTP_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>HTTPS_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NO_PROXY</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This tutorial uses <literal>HTTP_PROXY</literal> as an example environment variable.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A cluster with cluster-wide egress proxy enabled.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>controllers/memcached_controller.go</literal> file to include the following:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Import the <literal>proxy</literal> package from the <link xl:href="https://github.com/operator-framework/operator-lib/releases/tag/v0.7.0"><literal>operator-lib</literal></link> library:</simpara>
<programlisting language="golang" linenumbering="unnumbered">import (
  ...
   "github.com/operator-framework/operator-lib/proxy"
)</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>proxy.ReadProxyVarsFromEnv</literal> helper function to the reconcile loop and append the results to the Operand environments:</simpara>
<programlisting language="golang" linenumbering="unnumbered">for i, container := range dep.Spec.Template.Spec.Containers {
		dep.Spec.Template.Spec.Containers[i].Env = append(container.Env, proxy.ReadProxyVarsFromEnv()...)
}
...</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Set the environment variable on the Operator deployment by adding the following to the <literal>config/manager/manager.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
 - args:
   - --leader-elect
   - --leader-election-id=ansible-proxy-demo
   image: controller:latest
   name: manager
   env:
     - name: "HTTP_PROXY"
       value: "http_proxy_test"</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-run-operator_osdk-golang-tutorial">
<title>Running the Operator</title>
<simpara>There are three ways you can use the Operator SDK CLI to build and run your Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Run locally outside the cluster as a Go program.</simpara>
</listitem>
<listitem>
<simpara>Run as a deployment on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Bundle your Operator and use Operator Lifecycle Manager (OLM) to deploy on the cluster.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Before running your Go-based Operator as either a deployment on {product-title} or as a bundle that uses OLM, ensure that your project has been updated to use supported images.</simpara>
</note>
<section xml:id="osdk-run-locally_osdk-golang-tutorial">
<title>Running locally outside the cluster</title>
<simpara>You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to install the custom resource definitions (CRDs) in the cluster configured in your <literal>~/.kube/config</literal> file and run the Operator locally:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install run</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
2021-01-10T21:09:29.016-0700	INFO	controller-runtime.metrics	metrics server is starting to listen	{"addr": ":8080"}
2021-01-10T21:09:29.017-0700	INFO	setup	starting manager
2021-01-10T21:09:29.017-0700	INFO	controller-runtime.manager	starting metrics server	{"path": "/metrics"}
2021-01-10T21:09:29.018-0700	INFO	controller-runtime.manager.controller.memcached	Starting EventSource	{"reconciler group": "cache.example.com", "reconciler kind": "Memcached", "source": "kind source: /, Kind="}
2021-01-10T21:09:29.218-0700	INFO	controller-runtime.manager.controller.memcached	Starting Controller	{"reconciler group": "cache.example.com", "reconciler kind": "Memcached"}
2021-01-10T21:09:29.218-0700	INFO	controller-runtime.manager.controller.memcached	Starting workers	{"reconciler group": "cache.example.com", "reconciler kind": "Memcached", "worker count": 1}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-golang-tutorial">
<title>Running as a deployment on the cluster</title>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Prepared your Go-based Operator to run on {product-title} by updating the project to use supported images</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>By default, this command creates a namespace with the name of your Operator project in the form <literal>&lt;project_name&gt;-system</literal> and is used for the deployment. This command also installs the RBAC manifests from <literal>config/rbac</literal>.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;project_name&gt;-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
&lt;project_name&gt;-controller-manager       1/1     1            1           8m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-bundle-deploy-olm_osdk-golang-tutorial">
<title>Bundling an Operator and deploying with Operator Lifecycle Manager</title>
<section xml:id="osdk-bundle-operator_osdk-golang-tutorial">
<title>Bundling an Operator</title>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) v{product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initialized by using the Operator SDK</simpara>
</listitem>
<listitem>
<simpara>If your Operator is Go-based, your project must be updated to use supported images for running on {product-title}</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands in your Operator project directory to build and push your Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create your Operator bundle manifest by running the <literal>make bundle</literal> command, which invokes several commands, including the Operator SDK <literal>generate bundle</literal> and <literal>bundle validate</literal> subcommands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>Bundle manifests for an Operator describe how to display, create, and manage an application. The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These files are then automatically validated by using <literal>operator-sdk bundle validate</literal> to ensure the on-disk bundle representation is correct.</simpara>
</listitem>
<listitem>
<simpara>Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the bundle image. Set <literal>BUNDLE_IMG</literal> with the details for the registry, user namespace, and image tag where you intend to push the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build BUNDLE_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker push &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-deploy-olm_osdk-golang-tutorial">
<title>Deploying an Operator with Operator Lifecycle Manager</title>
<simpara>Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on {product-title} and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (<literal>oc</literal>) for all Operator lifecycle management functions without any additional tools.</simpara>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>If your Operator is Go-based, your project must be updated to use supported images for running on {product-title}</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to run the Operator on the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle \<co xml:id="CO53-1"/>
    -n &lt;namespace&gt; \<co xml:id="CO53-2"/>
    &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; <co xml:id="CO53-3"/></programlisting>
<calloutlist>
<callout arearefs="CO53-1">
<para>The <literal>run bundle</literal> command creates a valid file-based catalog and installs the Operator bundle on your cluster using OLM.</para>
</callout>
<callout arearefs="CO53-2">
<para>Optional: By default, the command installs the Operator in the currently active project in your <literal>~/.kube/config</literal> file. You can add the <literal>-n</literal> flag to set a different namespace scope for the installation.</para>
</callout>
<callout arearefs="CO53-3">
<para>If you do not specify an image, the command uses <literal>quay.io/operator-framework/opm:latest</literal> as the default index image. If you specify an image, the command uses the bundle image itself as the index image.</para>
</callout>
</calloutlist>
<important>
<simpara>As of {product-title} 4.11, the <literal>run bundle</literal> command supports the file-based catalog format for Operator catalogs by default. The deprecated SQLite database format for Operator catalogs continues to be supported; however, it will be removed in a future release. It is recommended that Operator authors migrate their workflows to the file-based catalog format.</simpara>
</important>
<simpara>This command performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an index image referencing your bundle image. The index image is opaque and ephemeral, but accurately reflects how a bundle would be added to a catalog in production.</simpara>
</listitem>
<listitem>
<simpara>Create a catalog source that points to your new index image, which enables OperatorHub to discover your Operator.</simpara>
</listitem>
<listitem>
<simpara>Deploy your Operator to your cluster by creating an <literal>OperatorGroup</literal>, <literal>Subscription</literal>, <literal>InstallPlan</literal>, and all other required resources, including RBAC.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-create-cr_osdk-golang-tutorial">
<title>Creating a custom resource</title>
<simpara>After your Operator is installed, you can test it by creating a custom resource (CR) that is now provided on the cluster by the Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Example Memcached Operator, which provides the <literal>Memcached</literal> CR, installed on a cluster</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the namespace where your Operator is installed. For example, if you deployed the Operator using the <literal>make deploy</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the sample <literal>Memcached</literal> CR manifest at <literal>config/samples/cache_v1_memcached.yaml</literal> to contain the following specification:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
  name: memcached-sample
...
spec:
...
  size: 3</programlisting>
</listitem>
<listitem>
<simpara>Create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the <literal>Memcached</literal> Operator creates the deployment for the sample CR with the correct size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
memcached-operator-controller-manager   1/1     1            1           8m
memcached-sample                        3/3     3            3           1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the pods and CR status to confirm the status is updated with the Memcached pod names.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY     STATUS    RESTARTS   AGE
memcached-sample-6fd7c98d8-7dqdr      1/1       Running   0          1m
memcached-sample-6fd7c98d8-g5k7v      1/1       Running   0          1m
memcached-sample-6fd7c98d8-m7vn7      1/1       Running   0          1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the CR status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get memcached/memcached-sample -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
...
  name: memcached-sample
...
spec:
  size: 3
status:
  nodes:
  - memcached-sample-6fd7c98d8-7dqdr
  - memcached-sample-6fd7c98d8-g5k7v
  - memcached-sample-6fd7c98d8-m7vn7</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the deployment size.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update <literal>config/samples/cache_v1_memcached.yaml</literal> file to change the <literal>spec.size</literal> field in the <literal>Memcached</literal> CR from <literal>3</literal> to <literal>5</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch memcached memcached-sample \
    -p '{"spec":{"size": 5}}' \
    --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the Operator changes the deployment size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
memcached-operator-controller-manager   1/1     1            1           10m
memcached-sample                        5/5     5            5           3m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Clean up the resources that have been created as part of this tutorial.</simpara>
<itemizedlist>
<listitem>
<simpara>If you used the <literal>make deploy</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
<listitem>
<simpara>If you used the <literal>operator-sdk run bundle</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk cleanup &lt;project_name&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-golang-tutorial-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/golang/osdk-golang-project-layout.xml#osdk-golang-project-layout">Project layout for Go-based Operators</link> to learn about the directory structures created by the Operator SDK.</simpara>
</listitem>
<listitem>
<simpara>If a <link xl:href="../../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">cluster-wide egress proxy is configured</link>, cluster administrators can <link xl:href="../../../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">override the proxy settings or inject a custom CA certificate</link> for specific Operators running on Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-golang-project-layout">
<title>Project layout for Go-based Operators</title>

<simpara>The <literal>operator-sdk</literal> CLI can generate, or <emphasis>scaffold</emphasis>, a number of packages and files for each Operator project.</simpara>
<section xml:id="osdk-golang-project-layout_osdk-golang-project-layout">
<title>Go-based project layout</title>
<simpara>Go-based Operator projects, the default type, generated using the <literal>operator-sdk init</literal> command contain the following files and directories:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">File or directory</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>main.go</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Main program of the Operator. This instantiates a new manager that registers all custom resource definitions (CRDs) in the <literal>apis/</literal> directory and starts all controllers in the <literal>controllers/</literal> directory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>apis/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Directory tree that defines the APIs of the CRDs. You must edit the <literal>apis/&lt;version&gt;/&lt;kind&gt;_types.go</literal> files to define the API for each resource type and import these packages in your controllers to watch for these resource types.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>controllers/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controller implementations. Edit the <literal>controller/&lt;kind&gt;_controller.go</literal> files to define the reconcile logic of the controller for handling a resource type of the specified kind.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes manifests used to deploy your controller on a cluster, including CRDs, RBAC, and certificates.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Makefile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Targets used to build and deploy your controller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Dockerfile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Instructions used by a container engine to build your Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manifests/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes manifests for registering CRDs, setting up RBAC, and deploying the Operator as a deployment.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="osdk-golang-updating-projects">
<title>Updating Go-based Operator projects for newer Operator SDK versions</title>

<simpara>{product-title} {product-version} supports Operator SDK 1.31.0. If you already have the 1.28.0 CLI installed on your workstation, you can update the CLI to 1.31.0 by <link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">installing the latest version</link>.</simpara>
<simpara>However, to ensure your existing Operator projects maintain compatibility with Operator SDK 1.31.0, update steps are required for the associated breaking changes introduced since 1.28.0. You must perform the update steps manually in any of your Operator projects that were previously created or maintained with 1.28.0.</simpara>
<section xml:id="osdk-upgrading-projects_osdk-golang-updating-projects">
<title>Updating Go-based Operator projects for Operator SDK 1.31.0</title>
<simpara>The following procedure updates an existing Go-based Operator project for compatibility with 1.31.0.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK 1.31.0 installed</simpara>
</listitem>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.28.0</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit your Operator project&#8217;s makefile to update the Operator SDK version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># Set the Operator SDK version to use. By default, what is installed on the system is used.
# This is useful for CI or a project to utilize a specific version of the operator-sdk toolkit.
OPERATOR_SDK_VERSION ?= v1.31.0 <co xml:id="CO54-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>Change the version from <literal>1.28.0</literal> to <literal>1.31.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_osdk-upgrading-projects-golang" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-pkgman-to-bundle.xml#osdk-pkgman-to-bundle">Migrating package manifest projects to bundle format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.10/html-single/operators/index#osdk-upgrading-v1101-to-v1160_osdk-upgrading-projects">Upgrading projects for Operator SDK 1.16.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.9/html/operators/developing-operators#osdk-upgrading-v180-to-v1101_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.10.1</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.8/html/operators/developing-operators#osdk-upgrading-v130-to-v180_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.8.0</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="_ansible_based_operators">
<title>Ansible-based Operators</title>
<section xml:id="osdk-ansible-quickstart">
<title>Getting started with Operator SDK for Ansible-based Operators</title>

<simpara>The Operator SDK includes options for generating an Operator project that leverages existing Ansible playbooks and modules to deploy Kubernetes resources as a unified application, without having to write any Go code.</simpara>
<simpara>To demonstrate the basics of setting up and running an <link xl:href="https://docs.ansible.com/ansible/latest/index.html">Ansible</link>-based Operator using tools and libraries provided by the Operator SDK, Operator developers can build an example Ansible-based Operator for Memcached, a distributed key-value store, and deploy it to a cluster.</simpara>
<section xml:id="osdk-common-prereqs_osdk-ansible-quickstart">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.ansible.com/ansible/latest/roadmap/ROADMAP_2_15.html">Ansible</link> 2.15.0</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://ansible-runner.readthedocs.io/en/latest/install.html">Ansible Runner</link> 2.3.3+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/ansible/ansible-runner-http">Ansible Runner HTTP Event Emitter plugin</link> 1.0.0+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.python.org/downloads/">Python</link> 3.9+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://pypi.org/project/kubernetes/">Python Kubernetes client</link></simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-quickstart_osdk-ansible-quickstart">
<title>Creating and deploying Ansible-based Operators</title>
<simpara>You can build and deploy a simple Ansible-based Operator for Memcached by using the Operator SDK.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara><emphasis role="strong">Create a project.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create your project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change into the project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>ansible</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=ansible \
    --domain=example.com</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create an API.</emphasis></simpara>
<simpara>Create a simple Memcached API:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group cache \
    --version v1 \
    --kind Memcached \
    --generate-role <co xml:id="CO55-1"/></programlisting>
<calloutlist>
<callout arearefs="CO55-1">
<para>Generates an Ansible role for the API.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Build and push the Operator image.</emphasis></simpara>
<simpara>Use the default <literal>Makefile</literal> targets to build and push your Operator. Set <literal>IMG</literal> with a pull spec for your image that uses a registry you can push to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Run the Operator.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Install the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
</listitem>
<listitem>
<simpara>Deploy the project to the cluster. Set <literal>IMG</literal> to the image that you pushed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create a sample custom resource (CR).</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a sample CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml \
    -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Watch for the CR to reconcile the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment.apps/memcached-operator-controller-manager \
    -c manager \
    -n memcached-operator-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
I0205 17:48:45.881666       7 leaderelection.go:253] successfully acquired lease memcached-operator-system/memcached-operator
{"level":"info","ts":1612547325.8819902,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting EventSource","source":"kind source: cache.example.com/v1, Kind=Memcached"}
{"level":"info","ts":1612547325.98242,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting Controller"}
{"level":"info","ts":1612547325.9824686,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting workers","worker count":4}
{"level":"info","ts":1612547348.8311093,"logger":"runner","msg":"Ansible-runner exited successfully","job":"4037200794235010051","name":"memcached-sample","namespace":"memcached-operator-system"}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete a CR.</emphasis></simpara>
<simpara>Delete a CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Clean up.</emphasis></simpara>
<simpara>Run the following command to clean up the resources that have been created as part of this procedure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-ansible-quickstart-next-steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/ansible/osdk-ansible-tutorial.xml#osdk-ansible-tutorial">Operator SDK tutorial for Ansible-based Operators</link> for a more in-depth walkthrough on building an Ansible-based Operator.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ansible-tutorial">
<title>Operator SDK tutorial for Ansible-based Operators</title>

<simpara>Operator developers can take advantage of <link xl:href="https://docs.ansible.com/ansible/latest/index.html">Ansible</link> support in the Operator SDK to build an example Ansible-based Operator for Memcached, a distributed key-value store, and manage its lifecycle. This tutorial walks through the following process:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a Memcached deployment</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment size is the same as specified by the <literal>Memcached</literal> custom resource (CR) spec</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>Memcached</literal> CR status using the status writer with the names of the <literal>memcached</literal> pods</simpara>
</listitem>
</itemizedlist>
<simpara>This process is accomplished by using two centerpieces of the Operator Framework:</simpara>
<variablelist>
<varlistentry>
<term>Operator SDK</term>
<listitem>
<simpara>The <literal>operator-sdk</literal> CLI tool and <literal>controller-runtime</literal> library API</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager (OLM)</term>
<listitem>
<simpara>Installation, upgrade, and role-based access control (RBAC) of Operators on a cluster</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>This tutorial goes into greater detail than <link xl:href="../../../operators/operator_sdk/ansible/osdk-ansible-quickstart.xml#osdk-ansible-quickstart">Getting started with Operator SDK for Ansible-based Operators</link>.</simpara>
</note>
<section xml:id="osdk-common-prereqs_osdk-ansible-tutorial">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://docs.ansible.com/ansible/latest/roadmap/ROADMAP_2_15.html">Ansible</link> 2.15.0</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://ansible-runner.readthedocs.io/en/latest/install.html">Ansible Runner</link> 2.3.3+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/ansible/ansible-runner-http">Ansible Runner HTTP Event Emitter plugin</link> 1.0.0+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://www.python.org/downloads/">Python</link> 3.9+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://pypi.org/project/kubernetes/">Python Kubernetes client</link></simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-create-project_osdk-ansible-tutorial">
<title>Creating a project</title>
<simpara>Use the Operator SDK CLI to create a project called <literal>memcached-operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change to the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>ansible</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=ansible \
    --domain=example.com</programlisting>
</listitem>
</orderedlist>
<section xml:id="osdk-project-file_osdk-ansible-tutorial">
<title>PROJECT file</title>
<simpara>Among the files generated by the <literal>operator-sdk init</literal> command is a Kubebuilder <literal>PROJECT</literal> file. Subsequent <literal>operator-sdk</literal> commands, as well as <literal>help</literal> output, that are run from the project root read this file and are aware that the project type is Ansible. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">domain: example.com
layout:
- ansible.sdk.operatorframework.io/v1
plugins:
  manifests.sdk.operatorframework.io/v2: {}
  scorecard.sdk.operatorframework.io/v2: {}
  sdk.x-openshift.io/v1: {}
projectName: memcached-operator
version: "3"</programlisting>
</section>
</section>
<section xml:id="osdk-ansible-create-api-controller_osdk-ansible-tutorial">
<title>Creating an API</title>
<simpara>Use the Operator SDK CLI to create a Memcached API.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to create an API with group <literal>cache</literal>, version, <literal>v1</literal>, and kind <literal>Memcached</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group cache \
    --version v1 \
    --kind Memcached \
    --generate-role <co xml:id="CO56-1"/></programlisting>
<calloutlist>
<callout arearefs="CO56-1">
<para>Generates an Ansible role for the API.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<simpara>After creating the API, your Operator project updates with the following structure:</simpara>
<variablelist>
<varlistentry>
<term>Memcached CRD</term>
<listitem>
<simpara>Includes a sample <literal>Memcached</literal> resource</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Manager</term>
<listitem>
<simpara>Program that reconciles the state of the cluster to the desired state by using:</simpara>
<itemizedlist>
<listitem>
<simpara>A reconciler, either an Ansible role or playbook</simpara>
</listitem>
<listitem>
<simpara>A <literal>watches.yaml</literal> file, which connects the <literal>Memcached</literal> resource to the <literal>memcached</literal> Ansible role</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="osdk-ansible-modify-manager_osdk-ansible-tutorial">
<title>Modifying the manager</title>
<simpara>Update your Operator project to provide the reconcile logic, in the form of an Ansible role, which runs every time a <literal>Memcached</literal> resource is created, updated, or deleted.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>roles/memcached/tasks/main.yml</literal> file with the following structure:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
- name: start memcached
  k8s:
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: '{{ ansible_operator_meta.name }}-memcached'
        namespace: '{{ ansible_operator_meta.namespace }}'
      spec:
        replicas: "{{size}}"
        selector:
          matchLabels:
            app: memcached
        template:
          metadata:
            labels:
              app: memcached
          spec:
            containers:
            - name: memcached
              command:
              - memcached
              - -m=64
              - -o
              - modern
              - -v
              image: "docker.io/memcached:1.4.36-alpine"
              ports:
                - containerPort: 11211</programlisting>
<simpara>This <literal>memcached</literal> role ensures a <literal>memcached</literal> deployment exist and sets the deployment size.</simpara>
</listitem>
<listitem>
<simpara>Set default values for variables used in your Ansible role by editing the <literal>roles/memcached/defaults/main.yml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
# defaults file for Memcached
size: 1</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>Memcached</literal> sample resource in the <literal>config/samples/cache_v1_memcached.yaml</literal> file with the following structure:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
  labels:
    app.kubernetes.io/name: memcached
    app.kubernetes.io/instance: memcached-sample
    app.kubernetes.io/part-of: memcached-operator
    app.kubernetes.io/managed-by: kustomize
    app.kubernetes.io/created-by: memcached-operator
  name: memcached-sample
spec:
  size: 3</programlisting>
<simpara>The key-value pairs in the custom resource (CR) spec are passed to Ansible as extra variables.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The names of all variables in the <literal>spec</literal> field are converted to snake case, meaning lowercase with an underscore, by the Operator before running Ansible. For example, <literal>serviceAccount</literal> in the spec becomes <literal>service_account</literal> in Ansible.</simpara>
<simpara>You can disable this case conversion by setting the <literal>snakeCaseParameters</literal> option to <literal>false</literal> in your <literal>watches.yaml</literal> file. It is recommended that you perform some type validation in Ansible on the variables to ensure that your application is receiving expected input.</simpara>
</note>
</section>
<section xml:id="osdk-run-proxy_osdk-ansible-tutorial">
<title>Enabling proxy support</title>
<simpara>Operator authors can develop Operators that support network proxies.
Cluster administrators
configure proxy support for the environment variables that are handled by Operator Lifecycle Manager (OLM). To support proxied clusters, your Operator must inspect the environment for the following standard proxy variables and pass the values to Operands:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HTTP_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>HTTPS_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NO_PROXY</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This tutorial uses <literal>HTTP_PROXY</literal> as an example environment variable.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A cluster with cluster-wide egress proxy enabled.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add the environment variables to the deployment by updating the <literal>roles/memcached/tasks/main.yml</literal> file with the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">...
env:
   - name: HTTP_PROXY
     value: '{{ lookup("env", "HTTP_PROXY") | default("", True) }}'
   - name: http_proxy
     value: '{{ lookup("env", "HTTP_PROXY") | default("", True) }}'
...</programlisting>
</listitem>
<listitem>
<simpara>Set the environment variable on the Operator deployment by adding the following to the <literal>config/manager/manager.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
 - args:
   - --leader-elect
   - --leader-election-id=ansible-proxy-demo
   image: controller:latest
   name: manager
   env:
     - name: "HTTP_PROXY"
       value: "http_proxy_test"</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-run-operator_osdk-ansible-tutorial">
<title>Running the Operator</title>
<simpara>There are three ways you can use the Operator SDK CLI to build and run your Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Run locally outside the cluster as a Go program.</simpara>
</listitem>
<listitem>
<simpara>Run as a deployment on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Bundle your Operator and use Operator Lifecycle Manager (OLM) to deploy on the cluster.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-run-locally_osdk-ansible-tutorial">
<title>Running locally outside the cluster</title>
<simpara>You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to install the custom resource definitions (CRDs) in the cluster configured in your <literal>~/.kube/config</literal> file and run the Operator locally:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install run</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
{"level":"info","ts":1612589622.7888272,"logger":"ansible-controller","msg":"Watching resource","Options.Group":"cache.example.com","Options.Version":"v1","Options.Kind":"Memcached"}
{"level":"info","ts":1612589622.7897573,"logger":"proxy","msg":"Starting to serve","Address":"127.0.0.1:8888"}
{"level":"info","ts":1612589622.789971,"logger":"controller-runtime.manager","msg":"starting metrics server","path":"/metrics"}
{"level":"info","ts":1612589622.7899997,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting EventSource","source":"kind source: cache.example.com/v1, Kind=Memcached"}
{"level":"info","ts":1612589622.8904517,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting Controller"}
{"level":"info","ts":1612589622.8905244,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting workers","worker count":8}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-ansible-tutorial">
<title>Running as a deployment on the cluster</title>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>By default, this command creates a namespace with the name of your Operator project in the form <literal>&lt;project_name&gt;-system</literal> and is used for the deployment. This command also installs the RBAC manifests from <literal>config/rbac</literal>.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;project_name&gt;-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
&lt;project_name&gt;-controller-manager       1/1     1            1           8m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-bundle-deploy-olm_osdk-ansible-tutorial">
<title>Bundling an Operator and deploying with Operator Lifecycle Manager</title>
<section xml:id="osdk-bundle-operator_osdk-ansible-tutorial">
<title>Bundling an Operator</title>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) v{product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initialized by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands in your Operator project directory to build and push your Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create your Operator bundle manifest by running the <literal>make bundle</literal> command, which invokes several commands, including the Operator SDK <literal>generate bundle</literal> and <literal>bundle validate</literal> subcommands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>Bundle manifests for an Operator describe how to display, create, and manage an application. The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These files are then automatically validated by using <literal>operator-sdk bundle validate</literal> to ensure the on-disk bundle representation is correct.</simpara>
</listitem>
<listitem>
<simpara>Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the bundle image. Set <literal>BUNDLE_IMG</literal> with the details for the registry, user namespace, and image tag where you intend to push the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build BUNDLE_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker push &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-deploy-olm_osdk-ansible-tutorial">
<title>Deploying an Operator with Operator Lifecycle Manager</title>
<simpara>Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on {product-title} and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (<literal>oc</literal>) for all Operator lifecycle management functions without any additional tools.</simpara>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to run the Operator on the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle \<co xml:id="CO57-1"/>
    -n &lt;namespace&gt; \<co xml:id="CO57-2"/>
    &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; <co xml:id="CO57-3"/></programlisting>
<calloutlist>
<callout arearefs="CO57-1">
<para>The <literal>run bundle</literal> command creates a valid file-based catalog and installs the Operator bundle on your cluster using OLM.</para>
</callout>
<callout arearefs="CO57-2">
<para>Optional: By default, the command installs the Operator in the currently active project in your <literal>~/.kube/config</literal> file. You can add the <literal>-n</literal> flag to set a different namespace scope for the installation.</para>
</callout>
<callout arearefs="CO57-3">
<para>If you do not specify an image, the command uses <literal>quay.io/operator-framework/opm:latest</literal> as the default index image. If you specify an image, the command uses the bundle image itself as the index image.</para>
</callout>
</calloutlist>
<important>
<simpara>As of {product-title} 4.11, the <literal>run bundle</literal> command supports the file-based catalog format for Operator catalogs by default. The deprecated SQLite database format for Operator catalogs continues to be supported; however, it will be removed in a future release. It is recommended that Operator authors migrate their workflows to the file-based catalog format.</simpara>
</important>
<simpara>This command performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an index image referencing your bundle image. The index image is opaque and ephemeral, but accurately reflects how a bundle would be added to a catalog in production.</simpara>
</listitem>
<listitem>
<simpara>Create a catalog source that points to your new index image, which enables OperatorHub to discover your Operator.</simpara>
</listitem>
<listitem>
<simpara>Deploy your Operator to your cluster by creating an <literal>OperatorGroup</literal>, <literal>Subscription</literal>, <literal>InstallPlan</literal>, and all other required resources, including RBAC.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-create-cr_osdk-ansible-tutorial">
<title>Creating a custom resource</title>
<simpara>After your Operator is installed, you can test it by creating a custom resource (CR) that is now provided on the cluster by the Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Example Memcached Operator, which provides the <literal>Memcached</literal> CR, installed on a cluster</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the namespace where your Operator is installed. For example, if you deployed the Operator using the <literal>make deploy</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the sample <literal>Memcached</literal> CR manifest at <literal>config/samples/cache_v1_memcached.yaml</literal> to contain the following specification:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
  name: memcached-sample
...
spec:
...
  size: 3</programlisting>
</listitem>
<listitem>
<simpara>Create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the <literal>Memcached</literal> Operator creates the deployment for the sample CR with the correct size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
memcached-operator-controller-manager   1/1     1            1           8m
memcached-sample                        3/3     3            3           1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the pods and CR status to confirm the status is updated with the Memcached pod names.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY     STATUS    RESTARTS   AGE
memcached-sample-6fd7c98d8-7dqdr      1/1       Running   0          1m
memcached-sample-6fd7c98d8-g5k7v      1/1       Running   0          1m
memcached-sample-6fd7c98d8-m7vn7      1/1       Running   0          1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the CR status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get memcached/memcached-sample -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
...
  name: memcached-sample
...
spec:
  size: 3
status:
  nodes:
  - memcached-sample-6fd7c98d8-7dqdr
  - memcached-sample-6fd7c98d8-g5k7v
  - memcached-sample-6fd7c98d8-m7vn7</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the deployment size.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update <literal>config/samples/cache_v1_memcached.yaml</literal> file to change the <literal>spec.size</literal> field in the <literal>Memcached</literal> CR from <literal>3</literal> to <literal>5</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch memcached memcached-sample \
    -p '{"spec":{"size": 5}}' \
    --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the Operator changes the deployment size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
memcached-operator-controller-manager   1/1     1            1           10m
memcached-sample                        5/5     5            5           3m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Clean up the resources that have been created as part of this tutorial.</simpara>
<itemizedlist>
<listitem>
<simpara>If you used the <literal>make deploy</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
<listitem>
<simpara>If you used the <literal>operator-sdk run bundle</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk cleanup &lt;project_name&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-ansible-tutorial-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/ansible/osdk-ansible-project-layout.xml#osdk-ansible-project-layout">Project layout for Ansible-based Operators</link> to learn about the directory structures created by the Operator SDK.</simpara>
</listitem>
<listitem>
<simpara>If a <link xl:href="../../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">cluster-wide egress proxy is configured</link>, cluster administrators can <link xl:href="../../../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">override the proxy settings or inject a custom CA certificate</link> for specific Operators running on Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ansible-project-layout">
<title>Project layout for Ansible-based Operators</title>

<simpara>The <literal>operator-sdk</literal> CLI can generate, or <emphasis>scaffold</emphasis>, a number of packages and files for each Operator project.</simpara>
<section xml:id="osdk-ansible-project-layout_osdk-ansible-project-layout">
<title>Ansible-based project layout</title>
<simpara>Ansible-based Operator projects generated using the <literal>operator-sdk init --plugins ansible</literal> command contain the following directories and files:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">File or directory</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Dockerfile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Dockerfile for building the container image for the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Makefile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Targets for building, publishing, deploying the container image that wraps the Operator binary, and targets for installing and uninstalling the custom resource definition (CRD).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PROJECT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>YAML file containing metadata information for the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/crd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Base CRD files and the <literal>kustomization.yaml</literal> file settings.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/default</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Collects all Operator manifests for deployment. Use by the <literal>make deploy</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/manager</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Controller manager deployment.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/prometheus</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>ServiceMonitor</literal> resource for monitoring the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/rbac</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Role and role binding for leader election and authentication proxy.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/samples</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sample resources created for the CRDs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/testing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sample configurations for testing.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>playbooks/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A subdirectory for the playbooks to run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>roles/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Subdirectory for the roles tree to run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>watches.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Group/version/kind (GVK) of the resources to watch, and the Ansible invocation method. New entries are added by using the <literal>create api</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>requirements.yml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>YAML file containing the Ansible collections and role dependencies to install during a build.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>molecule/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Molecule scenarios for end-to-end testing of your role and Operator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="osdk-ansible-updating-projects">
<title>Updating projects for newer Operator SDK versions</title>

<simpara>{product-title} {product-version} supports Operator SDK 1.31.0. If you already have the 1.28.0 CLI installed on your workstation, you can update the CLI to 1.31.0 by <link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">installing the latest version</link>.</simpara>
<simpara>However, to ensure your existing Operator projects maintain compatibility with Operator SDK 1.31.0, update steps are required for the associated breaking changes introduced since 1.28.0. You must perform the update steps manually in any of your Operator projects that were previously created or maintained with 1.28.0.</simpara>
<section xml:id="osdk-upgrading-projects_osdk-ansible-updating-projects">
<title>Updating Ansible-based Operator projects for Operator SDK 1.31.0</title>
<simpara>The following procedure updates an existing Ansible-based Operator project for compatibility with 1.31.0.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK 1.31.0 installed</simpara>
</listitem>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.28.0</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Make the following changes to your Operator&#8217;s Dockerfile:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Replace the <literal>ansible-operator-2.11-preview</literal> base image with the <literal>ansible-operator</literal> base image and update the version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example Dockerfile</title>
<para>
<programlisting language="docker" linenumbering="unnumbered">FROM quay.io/operator-framework/ansible-operator:v1.31.0</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>The update to Ansible 2.15.0 in version 1.30.0 of the Ansible Operator removed the following preinstalled Python modules:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ipaddress</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift</literal></simpara>
</listitem>
<listitem>
<simpara><literal>jmespath</literal></simpara>
</listitem>
<listitem>
<simpara><literal>cryptography</literal></simpara>
</listitem>
<listitem>
<simpara><literal>oauthlib</literal></simpara>
</listitem>
</itemizedlist>
<simpara>If your Operator depends on one of these removed Python modules, update your Dockerfile to install the required modules using the <literal>pip install</literal> command.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Edit your Operator project&#8217;s makefile to update the Operator SDK version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># Set the Operator SDK version to use. By default, what is installed on the system is used.
# This is useful for CI or a project to utilize a specific version of the operator-sdk toolkit.
OPERATOR_SDK_VERSION ?= v1.31.0 <co xml:id="CO58-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO58-1">
<para>Change the version from <literal>{osdk_ver-n1}</literal> to <literal>1.31.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Update your <literal>requirements.yaml</literal> and <literal>requirements.go</literal> files to remove the <literal>community.kubernetes</literal> collection and update the <literal>operator_sdk.util</literal> collection to version <literal>0.5.0</literal>, as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>requirements.yaml</literal> file</title>
<para>
<programlisting language="diff" linenumbering="unnumbered">  collections:
-  - name: community.kubernetes <co xml:id="CO59-1"/>
-    version: "2.0.1"
   - name: operator_sdk.util
-    version: "0.4.0"
+    version: "0.5.0" <co xml:id="CO59-2"/>
   - name: kubernetes.core
     version: "2.4.0"
   - name: cloud.common</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO59-1">
<para>Remove the <literal>community.kubernetes</literal> collection</para>
</callout>
<callout arearefs="CO59-2">
<para>Update the <literal>operator_sdk.util</literal> collection to version <literal>0.5.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Remove all instances of the <literal>lint</literal> field from your <literal>molecule/kind/molecule.yml</literal> and <literal>molecule/default/molecule.yml</literal> files, as shown in the following example:</simpara>
<programlisting language="diff" linenumbering="unnumbered">  ---
  dependency:
    name: galaxy
  driver:
    name: delegated
-   lint: |
-     set -e
-     yamllint -d "{extends: relaxed, rules: {line-length: {max: 120}}}" .
  platforms:
    - name: cluster
      groups:
	- k8s
  provisioner:
    name: ansible
-     lint: |
-       set -e
      ansible-lint
    inventory:
      group_vars:
	all:
	  namespace: ${TEST_OPERATOR_NAMESPACE:-osdk-test}
      host_vars:
	localhost:
	  ansible_python_interpreter: '{{ ansible_playbook_python }}'
	  config_dir: ${MOLECULE_PROJECT_DIRECTORY}/config
	  samples_dir: ${MOLECULE_PROJECT_DIRECTORY}/config/samples
	  operator_image: ${OPERATOR_IMAGE:-""}
	  operator_pull_policy: ${OPERATOR_PULL_POLICY:-"Always"}
	  kustomize: ${KUSTOMIZE_PATH:-kustomize}
    env:
      K8S_AUTH_KUBECONFIG: ${KUBECONFIG:-"~/.kube/config"}
  verifier:
    name: ansible
-     lint: |
-       set -e
-      ansible-lint</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_osdk-ansible-upgrading-projects" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.12/html-single/operators/index#osdk-upgrading-projects_osdk-ansible-updating-projects">Upgrading projects for Operator SDK v1.25.4</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.11/html-single/operators/index#osdk-upgrading-projects_osdk-ansible-updating-projects">Upgrading projects for Operator SDK v1.22.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.10/html-single/operators/index#osdk-upgrading-v1101-to-v1160_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.16.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.9/html/operators/developing-operators#osdk-upgrading-v180-to-v1101_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.10.1</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.8/html/operators/developing-operators#osdk-upgrading-v130-to-v180_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.8.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-pkgman-to-bundle.xml#osdk-pkgman-to-bundle">Migrating package manifest projects to bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ansible-support">
<title>Ansible support in Operator SDK</title>

<section xml:id="osdk-ansible-custom-resource-files_osdk-ansible-support">
<title>Custom resource files</title>
<simpara>Operators use the Kubernetes extension mechanism, custom resource definitions (CRDs), so your custom resource (CR) looks and acts just like the built-in, native Kubernetes objects.</simpara>
<simpara>The CR file format is a Kubernetes resource file. The object has mandatory and optional fields:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Custom resource fields</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Version of the CR to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kind of the CR to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes-specific metadata to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec</literal> (optional)</simpara></entry>
<entry align="left" valign="top"><simpara>Key-value list of variables which are passed to Ansible. This field is empty by default.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Summarizes the current state of the object. For Ansible-based Operators, the <link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource"><literal>status</literal> subresource</link> is enabled for CRDs and managed by the <literal>operator_sdk.util.k8s_status</literal> Ansible module by default, which includes <literal>condition</literal> information to the CR <literal>status</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes-specific annotations to be appended to the CR.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following list of CR annotations modify the behavior of the Operator:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Ansible-based Operator annotations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ansible.operator-sdk/reconcile-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the reconciliation interval for the CR. This value is parsed using the standard Golang package <link xl:href="https://golang.org/pkg/time/"><literal>time</literal></link>. Specifically, <link xl:href="https://golang.org/pkg/time/#ParseDuration"><literal>ParseDuration</literal></link> is used which applies the default suffix of <literal>s</literal>, giving the value in seconds.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example Ansible-based Operator annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "test1.example.com/v1alpha1"
kind: "Test1"
metadata:
  name: "example"
annotations:
  ansible.operator-sdk/reconcile-period: "30s"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="osdk-ansible-watches-file_osdk-ansible-support">
<title>watches.yaml file</title>
<simpara>A <emphasis>group/version/kind (GVK)</emphasis> is a unique identifier for a Kubernetes API. The <literal>watches.yaml</literal> file contains a list of mappings from custom resources (CRs), identified by its GVK, to an Ansible role or playbook. The Operator expects this mapping file in a predefined location at <literal>/opt/ansible/watches.yaml</literal>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>watches.yaml</literal> file mappings</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Group of CR to watch.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Version of CR to watch.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kind of CR to watch</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>role</literal> (default)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to the Ansible role added to the container. For example, if your <literal>roles</literal> directory is at <literal>/opt/ansible/roles/</literal> and your role is named <literal>busybox</literal>, this value would be <literal>/opt/ansible/roles/busybox</literal>. This field is mutually exclusive with the <literal>playbook</literal> field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>playbook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Path to the Ansible playbook added to the container. This playbook is expected to be a way to call roles. This field is mutually exclusive with the <literal>role</literal> field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>reconcilePeriod</literal> (optional)</simpara></entry>
<entry align="left" valign="top"><simpara>The reconciliation interval, how often the role or playbook is run, for a given CR.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>manageStatus</literal> (optional)</simpara></entry>
<entry align="left" valign="top"><simpara>When set to <literal>true</literal> (default), the Operator manages the status of the CR generically. When set to <literal>false</literal>, the status of the CR is managed elsewhere, by the specified role or playbook or in a separate controller.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example <literal>watches.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">- version: v1alpha1 <co xml:id="CO60-1"/>
  group: test1.example.com
  kind: Test1
  role: /opt/ansible/roles/Test1

- version: v1alpha1 <co xml:id="CO60-2"/>
  group: test2.example.com
  kind: Test2
  playbook: /opt/ansible/playbook.yml

- version: v1alpha1 <co xml:id="CO60-3"/>
  group: test3.example.com
  kind: Test3
  playbook: /opt/ansible/test3.yml
  reconcilePeriod: 0
  manageStatus: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO60-1">
<para>Simple example mapping <literal>Test1</literal> to the <literal>test1</literal> role.</para>
</callout>
<callout arearefs="CO60-2">
<para>Simple example mapping <literal>Test2</literal> to a playbook.</para>
</callout>
<callout arearefs="CO60-3">
<para>More complex example for the <literal>Test3</literal> kind. Disables re-queuing and managing the CR status in the playbook.</para>
</callout>
</calloutlist>
<section xml:id="osdk-ansible-watches-file-advanced_osdk-ansible-support">
<title>Advanced options</title>
<simpara>Advanced features can be enabled by adding them to your <literal>watches.yaml</literal> file per GVK. They can go below the <literal>group</literal>, <literal>version</literal>, <literal>kind</literal> and <literal>playbook</literal> or <literal>role</literal> fields.</simpara>
<simpara>Some features can be overridden per resource using an annotation on that CR. The options that can be overridden have the annotation specified below.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Advanced watches.yaml file options</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="33.3333*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="8.3335*"/>
<thead>
<row>
<entry align="left" valign="top">Feature</entry>
<entry align="left" valign="top">YAML key</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Annotation for override</entry>
<entry align="left" valign="top">Default value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Reconcile period</simpara></entry>
<entry align="left" valign="top"><simpara><literal>reconcilePeriod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time between reconcile runs for a particular CR.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ansible.operator-sdk/reconcile-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1m</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Manage status</simpara></entry>
<entry align="left" valign="top"><simpara><literal>manageStatus</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows the Operator to manage the <literal>conditions</literal> section of each CR <literal>status</literal> section.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Watch dependent resources</simpara></entry>
<entry align="left" valign="top"><simpara><literal>watchDependentResources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows the Operator to dynamically watch resources that are created by Ansible.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Watch cluster-scoped resources</simpara></entry>
<entry align="left" valign="top"><simpara><literal>watchClusterScopedResources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows the Operator to watch cluster-scoped resources that are created by Ansible.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Max runner artifacts</simpara></entry>
<entry align="left" valign="top"><simpara><literal>maxRunnerArtifacts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Manages the number of <link xl:href="https://ansible-runner.readthedocs.io/en/latest/intro.html#runner-artifacts-directory-hierarchy">artifact directories</link> that Ansible Runner keeps in the Operator container for each individual resource.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ansible.operator-sdk/max-runner-artifacts</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>20</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example watches.yml file with advanced options</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">- version: v1alpha1
  group: app.example.com
  kind: AppService
  playbook: /opt/ansible/playbook.yml
  maxRunnerArtifacts: 30
  reconcilePeriod: 5s
  manageStatus: False
  watchDependentResources: False</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="osdk-ansible-extra-variables_osdk-ansible-support">
<title>Extra variables sent to Ansible</title>
<simpara>Extra variables can be sent to Ansible, which are then managed by the Operator. The <literal>spec</literal> section of the custom resource (CR) passes along the key-value pairs as extra variables. This is equivalent to extra variables passed in to the <literal>ansible-playbook</literal> command.</simpara>
<simpara>The Operator also passes along additional variables under the <literal>meta</literal> field for the name of the CR and the namespace of the CR.</simpara>
<simpara>For the following CR example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "app.example.com/v1alpha1"
kind: "Database"
metadata:
  name: "example"
spec:
  message: "Hello world 2"
  newParameter: "newParam"</programlisting>
<simpara>The structure passed to Ansible as extra variables is:</simpara>
<programlisting language="json" linenumbering="unnumbered">{ "meta": {
        "name": "&lt;cr_name&gt;",
        "namespace": "&lt;cr_namespace&gt;",
  },
  "message": "Hello world 2",
  "new_parameter": "newParam",
  "_app_example_com_database": {
     &lt;full_crd&gt;
   },
}</programlisting>
<simpara>The <literal>message</literal> and <literal>newParameter</literal> fields are set in the top level as extra variables, and <literal>meta</literal> provides the relevant metadata for the CR as defined in the Operator. The <literal>meta</literal> fields can be accessed using dot notation in Ansible, for example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
- debug:
    msg: "name: {{ ansible_operator_meta.name }}, {{ ansible_operator_meta.namespace }}"</programlisting>
</section>
<section xml:id="osdk-ansible-runner-directory_osdk-ansible-support">
<title>Ansible Runner directory</title>
<simpara>Ansible Runner keeps information about Ansible runs in the container. This is located at <literal>/tmp/ansible-operator/runner/&lt;group&gt;/&lt;version&gt;/&lt;kind&gt;/&lt;namespace&gt;/&lt;name&gt;</literal>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>To learn more about the <literal>runner</literal> directory, see the <link xl:href="https://ansible-runner.readthedocs.io/en/latest/index.html">Ansible Runner documentation</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ansible-k8s-collection">
<title>Kubernetes Collection for Ansible</title>

<simpara>To manage the lifecycle of your application on Kubernetes using Ansible, you can use the <link xl:href="https://galaxy.ansible.com/community/kubernetes">Kubernetes Collection for Ansible</link>. This collection of Ansible modules allows a developer to either leverage their existing Kubernetes resource files written in YAML or express the lifecycle management in native Ansible.</simpara>
<simpara>One of the biggest benefits of using Ansible in conjunction with existing Kubernetes resource files is the ability to use Jinja templating so that you can customize resources with the simplicity of a few variables in Ansible.</simpara>
<simpara>This section goes into detail on usage of the Kubernetes Collection. To get started, install the collection on your local workstation and test it using a playbook before moving on to using it within an Operator.</simpara>
<section xml:id="osdk-ansible-installing-k8s-collection_osdk-ansible-k8s-collection">
<title>Installing the Kubernetes Collection for Ansible</title>
<simpara>You can install the Kubernetes Collection for Ansible on your local workstation.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install Ansible 2.15+:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo dnf install ansible</programlisting>
</listitem>
<listitem>
<simpara>Install the <link xl:href="https://pypi.org/project/kubernetes/">Python Kubernetes client</link> package:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ pip install kubernetes</programlisting>
</listitem>
<listitem>
<simpara>Install the Kubernetes Collection using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>You can install the collection directly from Ansible Galaxy:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-galaxy collection install community.kubernetes</programlisting>
</listitem>
<listitem>
<simpara>If you have already initialized your Operator, you might have a <literal>requirements.yml</literal> file at the top level of your project. This file specifies Ansible dependencies that must be installed for your Operator to function. By default, this file installs the <literal>community.kubernetes</literal> collection as well as the <literal>operator_sdk.util</literal> collection, which provides modules and plugins for Operator-specific functions.</simpara>
<simpara>To install the dependent modules from the <literal>requirements.yml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-galaxy collection install -r requirements.yml</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-ansible-k8s-local_osdk-ansible-k8s-collection">
<title>Testing the Kubernetes Collection locally</title>
<simpara>Operator developers can run the Ansible code from their local machine as opposed to running and rebuilding the Operator each time.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Initialize an Ansible-based Operator project and create an API that has a generated Ansible role by using the Operator SDK</simpara>
</listitem>
<listitem>
<simpara>Install the Kubernetes Collection for Ansible</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your Ansible-based Operator project directory, modify the <literal>roles/&lt;kind&gt;/tasks/main.yml</literal> file with the Ansible logic that you want. The <literal>roles/&lt;kind&gt;/</literal> directory is created when you use the <literal>--generate-role</literal> flag while creating an API. The <literal>&lt;kind&gt;</literal> replaceable matches the kind that you specified for the API.</simpara>
<simpara>The following example creates and deletes a config map based on the value of a variable named <literal>state</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
- name: set ConfigMap example-config to {{ state }}
  community.kubernetes.k8s:
    api_version: v1
    kind: ConfigMap
    name: example-config
    namespace: &lt;operator_namespace&gt; <co xml:id="CO61-1"/>
    state: "{{ state }}"
  ignore_errors: true <co xml:id="CO61-2"/></programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>Specify the namespace where you want the config map created.</para>
</callout>
<callout arearefs="CO61-2">
<para>Setting <literal>ignore_errors: true</literal> ensures that deleting a nonexistent config map does not fail.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Modify the <literal>roles/&lt;kind&gt;/defaults/main.yml</literal> file to set <literal>state</literal> to <literal>present</literal> by default:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
state: present</programlisting>
</listitem>
<listitem>
<simpara>Create an Ansible playbook by creating a <literal>playbook.yml</literal> file in the top-level of your project directory, and include your <literal>&lt;kind&gt;</literal> role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">---
- hosts: localhost
  roles:
    - &lt;kind&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the playbook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-playbook playbook.yml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'

PLAY [localhost] ********************************************************************************

TASK [Gathering Facts] ********************************************************************************
ok: [localhost]

TASK [memcached : set ConfigMap example-config to present] ********************************************************************************
changed: [localhost]

PLAY RECAP ********************************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the config map was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME               DATA   AGE
example-config     0      2m1s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Rerun the playbook setting <literal>state</literal> to <literal>absent</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-playbook playbook.yml --extra-vars state=absent</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'

PLAY [localhost] ********************************************************************************

TASK [Gathering Facts] ********************************************************************************
ok: [localhost]

TASK [memcached : set ConfigMap example-config to absent] ********************************************************************************
changed: [localhost]

PLAY RECAP ********************************************************************************
localhost                  : ok=2    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the config map was deleted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-ansible-k8s-collection-next-steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/ansible/osdk-ansible-inside-operator.xml#osdk-ansible-inside-operator">Using Ansible inside an Operator</link> for details on triggering your custom Ansible logic inside of an Operator when a custom resource (CR) changes.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ansible-inside-operator">
<title>Using Ansible inside an Operator</title>

<simpara>After you are familiar with <link xl:href="../../../operators/operator_sdk/ansible/osdk-ansible-k8s-collection.xml#osdk-ansible-k8s-collection">using the Kubernetes Collection for Ansible locally</link>, you can trigger the same Ansible logic inside of an Operator when a custom resource (CR) changes. This example maps an Ansible role to a specific Kubernetes resource that the Operator watches. This mapping is done in the <literal>watches.yaml</literal> file.</simpara>
<section xml:id="osdk-ansible-custom-resource-files_osdk-ansible-inside-operator">
<title>Custom resource files</title>
<simpara>Operators use the Kubernetes extension mechanism, custom resource definitions (CRDs), so your custom resource (CR) looks and acts just like the built-in, native Kubernetes objects.</simpara>
<simpara>The CR file format is a Kubernetes resource file. The object has mandatory and optional fields:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Custom resource fields</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Version of the CR to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kind of the CR to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes-specific metadata to be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec</literal> (optional)</simpara></entry>
<entry align="left" valign="top"><simpara>Key-value list of variables which are passed to Ansible. This field is empty by default.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Summarizes the current state of the object. For Ansible-based Operators, the <link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource"><literal>status</literal> subresource</link> is enabled for CRDs and managed by the <literal>operator_sdk.util.k8s_status</literal> Ansible module by default, which includes <literal>condition</literal> information to the CR <literal>status</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>annotations</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes-specific annotations to be appended to the CR.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following list of CR annotations modify the behavior of the Operator:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Ansible-based Operator annotations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ansible.operator-sdk/reconcile-period</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the reconciliation interval for the CR. This value is parsed using the standard Golang package <link xl:href="https://golang.org/pkg/time/"><literal>time</literal></link>. Specifically, <link xl:href="https://golang.org/pkg/time/#ParseDuration"><literal>ParseDuration</literal></link> is used which applies the default suffix of <literal>s</literal>, giving the value in seconds.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example Ansible-based Operator annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "test1.example.com/v1alpha1"
kind: "Test1"
metadata:
  name: "example"
annotations:
  ansible.operator-sdk/reconcile-period: "30s"</programlisting>
</para>
</formalpara>
</section>
<section xml:id="osdk-ansible-inside-operator-local_osdk-ansible-inside-operator">
<title>Testing an Ansible-based Operator locally</title>
<simpara>You can test the logic inside of an Ansible-based Operator running locally by using the <literal>make run</literal> command from the top-level directory of your Operator project. The <literal>make run</literal> Makefile target runs the <literal>ansible-operator</literal> binary locally, which reads from the <literal>watches.yaml</literal> file and uses your <literal>~/.kube/config</literal> file to communicate with a Kubernetes cluster just as the <literal>k8s</literal> modules do.</simpara>
<note>
<simpara>You can customize the roles path by setting the environment variable <literal>ANSIBLE_ROLES_PATH</literal> or by using the <literal>ansible-roles-path</literal> flag. If the role is not found in the <literal>ANSIBLE_ROLES_PATH</literal> value, the Operator looks for it in <literal>{{current directory}}/roles</literal>.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara><link xl:href="https://ansible-runner.readthedocs.io/en/latest/install.html">Ansible Runner</link> v2.3.3+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://github.com/ansible/ansible-runner-http">Ansible Runner HTTP Event Emitter plugin</link> v1.0.0+</simpara>
</listitem>
<listitem>
<simpara>Performed the previous steps for testing the Kubernetes Collection locally</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install your custom resource definition (CRD) and proper role-based access control (RBAC) definitions for your custom resource (CR):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/usr/bin/kustomize build config/crd | kubectl apply -f -
customresourcedefinition.apiextensions.k8s.io/memcacheds.cache.example.com created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the <literal>make run</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make run</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">/home/user/memcached-operator/bin/ansible-operator run
{"level":"info","ts":1612739145.2871568,"logger":"cmd","msg":"Version","Go Version":"go1.15.5","GOOS":"linux","GOARCH":"amd64","ansible-operator":"v1.10.1","commit":"1abf57985b43bf6a59dcd18147b3c574fa57d3f6"}
...
{"level":"info","ts":1612739148.347306,"logger":"controller-runtime.metrics","msg":"metrics server is starting to listen","addr":":8080"}
{"level":"info","ts":1612739148.3488882,"logger":"watches","msg":"Environment variable not set; using default value","envVar":"ANSIBLE_VERBOSITY_MEMCACHED_CACHE_EXAMPLE_COM","default":2}
{"level":"info","ts":1612739148.3490262,"logger":"cmd","msg":"Environment variable not set; using default value","Namespace":"","envVar":"ANSIBLE_DEBUG_LOGS","ANSIBLE_DEBUG_LOGS":false}
{"level":"info","ts":1612739148.3490646,"logger":"ansible-controller","msg":"Watching resource","Options.Group":"cache.example.com","Options.Version":"v1","Options.Kind":"Memcached"}
{"level":"info","ts":1612739148.350217,"logger":"proxy","msg":"Starting to serve","Address":"127.0.0.1:8888"}
{"level":"info","ts":1612739148.3506632,"logger":"controller-runtime.manager","msg":"starting metrics server","path":"/metrics"}
{"level":"info","ts":1612739148.350784,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting EventSource","source":"kind source: cache.example.com/v1, Kind=Memcached"}
{"level":"info","ts":1612739148.5511978,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting Controller"}
{"level":"info","ts":1612739148.5512562,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting workers","worker count":8}</programlisting>
</para>
</formalpara>
<simpara>With the Operator now watching your CR for events, the creation of a CR will trigger your Ansible role to run.</simpara>
<note>
<simpara>Consider an example <literal>config/samples/&lt;gvk&gt;.yaml</literal> CR manifest:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: &lt;group&gt;.example.com/v1alpha1
kind: &lt;kind&gt;
metadata:
  name: "&lt;kind&gt;-sample"</programlisting>
<simpara>Because the <literal>spec</literal> field is not set, Ansible is invoked with no extra variables. Passing extra variables from a CR to Ansible is covered in another section. It is important to set reasonable defaults for the Operator.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create an instance of your CR with the default variable <literal>state</literal> set to <literal>present</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/&lt;gvk&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Check that the <literal>example-config</literal> config map was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmaps</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    STATUS    AGE
example-config          Active    3s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Modify your <literal>config/samples/&lt;gvk&gt;.yaml</literal> file to set the <literal>state</literal> field to <literal>absent</literal>. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
  name: memcached-sample
spec:
  state: absent</programlisting>
</listitem>
<listitem>
<simpara>Apply the changes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/&lt;gvk&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the config map is deleted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get configmap</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-ansible-inside-operator">
<title>Testing an Ansible-based Operator on the cluster</title>
<simpara>After you have tested your custom Ansible logic locally inside of an Operator, you can test the Operator inside of a pod on an {product-title} cluster, which is preferred for production use.</simpara>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>By default, this command creates a namespace with the name of your Operator project in the form <literal>&lt;project_name&gt;-system</literal> and is used for the deployment. This command also installs the RBAC manifests from <literal>config/rbac</literal>.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;project_name&gt;-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
&lt;project_name&gt;-controller-manager       1/1     1            1           8m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-ansible-inside-operator-logs_osdk-ansible-inside-operator">
<title>Ansible logs</title>
<simpara>Ansible-based Operators provide logs about the Ansible run, which can be useful for debugging your Ansible tasks. The logs can also contain detailed information about the internals of the Operator and its interactions with Kubernetes.</simpara>
<section xml:id="osdk-ansible-inside-operator-logs-view_osdk-ansible-inside-operator">
<title>Viewing Ansible logs</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Ansible-based Operator running as a deployment on a cluster</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To view logs from an Ansible-based Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment/&lt;project_name&gt;-controller-manager \
    -c manager \<co xml:id="CO62-1"/>
    -n &lt;namespace&gt; <co xml:id="CO62-2"/></programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para>View logs from the <literal>manager</literal> container.</para>
</callout>
<callout arearefs="CO62-2">
<para>If you used the <literal>make deploy</literal> command to run the Operator as a deployment, use the <literal>&lt;project_name&gt;-system</literal> namespace.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">{"level":"info","ts":1612732105.0579333,"logger":"cmd","msg":"Version","Go Version":"go1.15.5","GOOS":"linux","GOARCH":"amd64","ansible-operator":"v1.10.1","commit":"1abf57985b43bf6a59dcd18147b3c574fa57d3f6"}
{"level":"info","ts":1612732105.0587437,"logger":"cmd","msg":"WATCH_NAMESPACE environment variable not set. Watching all namespaces.","Namespace":""}
I0207 21:08:26.110949       7 request.go:645] Throttling request took 1.035521578s, request: GET:https://172.30.0.1:443/apis/flowcontrol.apiserver.k8s.io/v1alpha1?timeout=32s
{"level":"info","ts":1612732107.768025,"logger":"controller-runtime.metrics","msg":"metrics server is starting to listen","addr":"127.0.0.1:8080"}
{"level":"info","ts":1612732107.768796,"logger":"watches","msg":"Environment variable not set; using default value","envVar":"ANSIBLE_VERBOSITY_MEMCACHED_CACHE_EXAMPLE_COM","default":2}
{"level":"info","ts":1612732107.7688773,"logger":"cmd","msg":"Environment variable not set; using default value","Namespace":"","envVar":"ANSIBLE_DEBUG_LOGS","ANSIBLE_DEBUG_LOGS":false}
{"level":"info","ts":1612732107.7688901,"logger":"ansible-controller","msg":"Watching resource","Options.Group":"cache.example.com","Options.Version":"v1","Options.Kind":"Memcached"}
{"level":"info","ts":1612732107.770032,"logger":"proxy","msg":"Starting to serve","Address":"127.0.0.1:8888"}
I0207 21:08:27.770185       7 leaderelection.go:243] attempting to acquire leader lease  memcached-operator-system/memcached-operator...
{"level":"info","ts":1612732107.770202,"logger":"controller-runtime.manager","msg":"starting metrics server","path":"/metrics"}
I0207 21:08:27.784854       7 leaderelection.go:253] successfully acquired lease memcached-operator-system/memcached-operator
{"level":"info","ts":1612732107.7850506,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting EventSource","source":"kind source: cache.example.com/v1, Kind=Memcached"}
{"level":"info","ts":1612732107.8853772,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting Controller"}
{"level":"info","ts":1612732107.8854098,"logger":"controller-runtime.manager.controller.memcached-controller","msg":"Starting workers","worker count":4}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-ansible-inside-operator-logs-full-result_osdk-ansible-inside-operator">
<title>Enabling full Ansible results in logs</title>
<simpara>You can set the environment variable <literal>ANSIBLE_DEBUG_LOGS</literal> to <literal>True</literal> to enable checking the full Ansible result in logs, which can be helpful when debugging.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>config/manager/manager.yaml</literal> and <literal>config/default/manager_auth_proxy_patch.yaml</literal> files to include the following configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">      containers:
      - name: manager
        env:
        - name: ANSIBLE_DEBUG_LOGS
          value: "True"</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-ansible-inside-operator-logs-verbose_osdk-ansible-inside-operator">
<title>Enabling verbose debugging in logs</title>
<simpara>While developing an Ansible-based Operator, it can be helpful to enable additional debugging in logs.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>ansible.sdk.operatorframework.io/verbosity</literal> annotation to your custom resource to enable the verbosity level that you want. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: "cache.example.com/v1alpha1"
kind: "Memcached"
metadata:
  name: "example-memcached"
  annotations:
    "ansible.sdk.operatorframework.io/verbosity": "4"
spec:
  size: 4</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-ansible-cr-status">
<title>Custom resource status management</title>

<section xml:id="osdk-ansible-cr-status-about_osdk-ansible-cr-mgmt">
<title>About custom resource status in Ansible-based Operators</title>
<simpara>Ansible-based Operators automatically update custom resource (CR) <link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource"><literal>status</literal> subresources</link> with generic information about the previous Ansible run. This includes the number of successful and failed tasks and relevant error messages as shown:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">status:
  conditions:
  - ansibleResult:
      changed: 3
      completion: 2018-12-03T13:45:57.13329
      failures: 1
      ok: 6
      skipped: 0
    lastTransitionTime: 2018-12-03T13:45:57Z
    message: 'Status code was -1 and not [200]: Request failed: &lt;urlopen error [Errno
      113] No route to host&gt;'
    reason: Failed
    status: "True"
    type: Failure
  - lastTransitionTime: 2018-12-03T13:46:13Z
    message: Running reconciliation
    reason: Running
    status: "True"
    type: Running</programlisting>
<simpara>Ansible-based Operators also allow Operator authors to supply custom status values with the <literal>k8s_status</literal> Ansible module, which is included in the <link xl:href="https://galaxy.ansible.com/operator_sdk/util"><literal>operator_sdk.util</literal> collection</link>. This allows the author to update the <literal>status</literal> from within Ansible with any key-value pair as desired.</simpara>
<simpara>By default, Ansible-based Operators always include the generic Ansible run output as shown above. If you would prefer your application did <emphasis>not</emphasis> update the status with Ansible output, you can track the status manually from your application.</simpara>
</section>
<section xml:id="osdk-ansible-cr-status-manual_osdk-ansible-cr-mgmt">
<title>Tracking custom resource status manually</title>
<simpara>You can use the <literal>operator_sdk.util</literal> collection to modify your Ansible-based Operator to track custom resource (CR) status manually from your application.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Ansible-based Operator project created by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>watches.yaml</literal> file with a <literal>manageStatus</literal> field set to <literal>false</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- version: v1
  group: api.example.com
  kind: &lt;kind&gt;
  role: &lt;role&gt;
  manageStatus: false</programlisting>
</listitem>
<listitem>
<simpara>Use the <literal>operator_sdk.util.k8s_status</literal> Ansible module to update the subresource. For example, to update with key <literal>test</literal> and value <literal>data</literal>, <literal>operator_sdk.util</literal> can be used as shown:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">- operator_sdk.util.k8s_status:
    api_version: app.example.com/v1
    kind: &lt;kind&gt;
    name: "{{ ansible_operator_meta.name }}"
    namespace: "{{ ansible_operator_meta.namespace }}"
    status:
      test: data</programlisting>
</listitem>
<listitem>
<simpara>You can declare collections in the <literal>meta/main.yml</literal> file for the role, which is included for scaffolded Ansible-based Operators:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">collections:
  - operator_sdk.util</programlisting>
</listitem>
<listitem>
<simpara>After declaring collections in the role meta, you can invoke the <literal>k8s_status</literal> module directly:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">k8s_status:
  ...
  status:
    key1: value1</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="_helm_based_operators">
<title>Helm-based Operators</title>
<section xml:id="osdk-helm-quickstart">
<title>Getting started with Operator SDK for Helm-based Operators</title>

<simpara>The Operator SDK includes options for generating an Operator project that leverages existing <link xl:href="https://helm.sh/docs/">Helm</link> charts to deploy Kubernetes resources as a unified application, without having to write any Go code.</simpara>
<simpara>To demonstrate the basics of setting up and running an <link xl:href="https://helm.sh/docs/">Helm</link>-based Operator using tools and libraries provided by the Operator SDK, Operator developers can build an example Helm-based Operator for Nginx and deploy it to a cluster.</simpara>
<section xml:id="osdk-common-prereqs_osdk-helm-quickstart">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-quickstart_osdk-helm-quickstart">
<title>Creating and deploying Helm-based Operators</title>
<simpara>You can build and deploy a simple Helm-based Operator for Nginx by using the Operator SDK.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara><emphasis role="strong">Create a project.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create your project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir nginx-operator</programlisting>
</listitem>
<listitem>
<simpara>Change into the project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd nginx-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>helm</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=helm</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create an API.</emphasis></simpara>
<simpara>Create a simple Nginx API:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group demo \
    --version v1 \
    --kind Nginx</programlisting>
<simpara>This API uses the built-in Helm chart boilerplate from the <literal>helm create</literal> command.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Build and push the Operator image.</emphasis></simpara>
<simpara>Use the default <literal>Makefile</literal> targets to build and push your Operator. Set <literal>IMG</literal> with a pull spec for your image that uses a registry you can push to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Run the Operator.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Install the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
</listitem>
<listitem>
<simpara>Deploy the project to the cluster. Set <literal>IMG</literal> to the image that you pushed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Add a security context constraint (SCC).</emphasis></simpara>
<simpara>The Nginx service account requires privileged access to run in {product-title}. Add the following SCC to the service account for the <literal>nginx-sample</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user \
    anyuid system:serviceaccount:nginx-operator-system:nginx-sample</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create a sample custom resource (CR).</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a sample CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/demo_v1_nginx.yaml \
    -n nginx-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Watch for the CR to reconcile the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment.apps/nginx-operator-controller-manager \
    -c manager \
    -n nginx-operator-system</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete a CR.</emphasis></simpara>
<simpara>Delete a CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/demo_v1_nginx -n nginx-operator-system</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Clean up.</emphasis></simpara>
<simpara>Run the following command to clean up the resources that have been created as part of this procedure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-helm-quickstart-next-steps">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/helm/osdk-helm-tutorial.xml#osdk-helm-tutorial">Operator SDK tutorial for Helm-based Operators</link> for a more in-depth walkthrough on building a Helm-based Operator.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-helm-tutorial">
<title>Operator SDK tutorial for Helm-based Operators</title>

<simpara>Operator developers can take advantage of <link xl:href="https://helm.sh/docs/">Helm</link> support in the Operator SDK to build an example Helm-based Operator for Nginx and manage its lifecycle. This tutorial walks through the following process:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a Nginx deployment</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment size is the same as specified by the <literal>Nginx</literal> custom resource (CR) spec</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>Nginx</literal> CR status using the status writer with the names of the <literal>nginx</literal> pods</simpara>
</listitem>
</itemizedlist>
<simpara>This process is accomplished using two centerpieces of the Operator Framework:</simpara>
<variablelist>
<varlistentry>
<term>Operator SDK</term>
<listitem>
<simpara>The <literal>operator-sdk</literal> CLI tool and <literal>controller-runtime</literal> library API</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager (OLM)</term>
<listitem>
<simpara>Installation, upgrade, and role-based access control (RBAC) of Operators on a cluster</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>This tutorial goes into greater detail than <link xl:href="../../../operators/operator_sdk/helm/osdk-helm-quickstart.xml#osdk-helm-quickstart">Getting started with Operator SDK for Helm-based Operators</link>.</simpara>
</note>
<section xml:id="osdk-common-prereqs_osdk-helm-tutorial">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-create-project_osdk-helm-tutorial">
<title>Creating a project</title>
<simpara>Use the Operator SDK CLI to create a project called <literal>nginx-operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p $HOME/projects/nginx-operator</programlisting>
</listitem>
<listitem>
<simpara>Change to the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd $HOME/projects/nginx-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>helm</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=helm \
    --domain=example.com \
    --group=demo \
    --version=v1 \
    --kind=Nginx</programlisting>
<note>
<simpara>By default, the <literal>helm</literal> plugin initializes a project using a boilerplate Helm chart. You can use additional flags, such as the <literal>--helm-chart</literal> flag, to initialize a project using an existing Helm chart.</simpara>
</note>
<simpara>The <literal>init</literal> command creates the <literal>nginx-operator</literal> project specifically for watching a resource with API version <literal>example.com/v1</literal> and kind <literal>Nginx</literal>.</simpara>
</listitem>
<listitem>
<simpara>For Helm-based projects, the <literal>init</literal> command generates the RBAC rules in the <literal>config/rbac/role.yaml</literal> file based on the resources that would be deployed by the default manifest for the chart. Verify that the rules generated in this file meet the permission requirements of the Operator.</simpara>
</listitem>
</orderedlist>
<section xml:id="osdk-helm-existing-chart_osdk-helm-tutorial">
<title>Existing Helm charts</title>
<simpara>Instead of creating your project with a boilerplate Helm chart, you can alternatively use an existing chart, either from your local file system or a remote chart repository, by using the following flags:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>--helm-chart</literal></simpara>
</listitem>
<listitem>
<simpara><literal>--helm-chart-repo</literal></simpara>
</listitem>
<listitem>
<simpara><literal>--helm-chart-version</literal></simpara>
</listitem>
</itemizedlist>
<simpara>If the <literal>--helm-chart</literal> flag is specified, the <literal>--group</literal>, <literal>--version</literal>, and <literal>--kind</literal> flags become optional. If left unset, the following default values are used:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--domain</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>my.domain</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--group</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>charts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--version</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>v1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Deduced from the specified chart</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If the <literal>--helm-chart</literal> flag specifies a local chart archive, for example <literal>example-chart-1.2.0.tgz</literal>, or directory, the chart is validated and unpacked or copied into the project. Otherwise, the Operator SDK attempts to fetch the chart from a remote repository.</simpara>
<simpara>If a custom repository URL is not specified by the <literal>--helm-chart-repo</literal> flag, the following chart reference formats are supported:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Format</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;repo_name&gt;/&lt;chart_name&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fetch the Helm chart named <literal>&lt;chart_name&gt;</literal> from the helm chart repository named <literal>&lt;repo_name&gt;</literal>, as specified in the <literal>$HELM_HOME/repositories/repositories.yaml</literal> file. Use the <literal>helm repo add</literal> command to configure this file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;url&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fetch the Helm chart archive at the specified URL.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If a custom repository URL is specified by <literal>--helm-chart-repo</literal>, the following chart reference format is supported:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Format</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;chart_name&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fetch the Helm chart named <literal>&lt;chart_name&gt;</literal> in the Helm chart repository specified by the <literal>--helm-chart-repo</literal> URL value.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If the <literal>--helm-chart-version</literal> flag is unset, the Operator SDK fetches the latest available version of the Helm chart. Otherwise, it fetches the specified version. The optional <literal>--helm-chart-version</literal> flag is not used when the chart specified with the <literal>--helm-chart</literal> flag refers to a specific version, for example when it is a local path or a URL.</simpara>
<simpara>For more details and examples, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init --plugins helm --help</programlisting>
</section>
<section xml:id="osdk-project-file_osdk-helm-tutorial">
<title>PROJECT file</title>
<simpara>Among the files generated by the <literal>operator-sdk init</literal> command is a Kubebuilder <literal>PROJECT</literal> file. Subsequent <literal>operator-sdk</literal> commands, as well as <literal>help</literal> output, that are run from the project root read this file and are aware that the project type is Helm. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">domain: example.com
layout:
- helm.sdk.operatorframework.io/v1
plugins:
  manifests.sdk.operatorframework.io/v2: {}
  scorecard.sdk.operatorframework.io/v2: {}
  sdk.x-openshift.io/v1: {}
projectName: nginx-operator
resources:
- api:
    crdVersion: v1
    namespaced: true
  domain: example.com
  group: demo
  kind: Nginx
  version: v1
version: "3"</programlisting>
</section>
</section>
<section xml:id="osdk-helm-logic_osdk-helm-tutorial">
<title>Understanding the Operator logic</title>
<simpara>For this example, the <literal>nginx-operator</literal> project executes the following reconciliation logic for each <literal>Nginx</literal> custom resource (CR):</simpara>
<itemizedlist>
<listitem>
<simpara>Create an Nginx deployment if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Create an Nginx service if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Create an Nginx ingress if it is enabled and does not exist.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment, service, and optional ingress match the desired configuration as specified by the <literal>Nginx</literal> CR, for example the replica count, image, and service type.</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the <literal>nginx-operator</literal> project watches <literal>Nginx</literal> resource events as shown in the <literal>watches.yaml</literal> file and executes Helm releases using the specified chart:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># Use the 'create api' subcommand to add watches to this file.
- group: demo
  version: v1
  kind: Nginx
  chart: helm-charts/nginx
# +kubebuilder:scaffold:watch</programlisting>
<section xml:id="osdk-helm-sample-chart_osdk-helm-tutorial">
<title>Sample Helm chart</title>
<simpara>When a Helm Operator project is created, the Operator SDK creates a sample Helm chart that contains a set of templates for a simple Nginx release.</simpara>
<simpara>For this example, templates are available for deployment, service, and ingress resources, along with a <literal>NOTES.txt</literal> template, which Helm chart developers use to convey helpful information about a release.</simpara>
<simpara>If you are not already familiar with Helm charts, review the <link xl:href="https://docs.helm.sh/developing_charts/">Helm developer documentation</link>.</simpara>
</section>
<section xml:id="osdk-helm-modify-cr_osdk-helm-tutorial">
<title>Modifying the custom resource spec</title>
<simpara>Helm uses a concept called <link xl:href="https://helm.sh/docs/intro/using_helm/#customizing-the-chart-before-installing">values</link> to provide customizations to the defaults of a Helm chart, which are defined in the <literal>values.yaml</literal> file.</simpara>
<simpara>You can override these defaults by setting the desired values in the custom resource (CR) spec. You can use the number of replicas as an example.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>The <literal>helm-charts/nginx/values.yaml</literal> file has a value called <literal>replicaCount</literal> set to <literal>1</literal> by default. To have two Nginx instances in your deployment, your CR spec must contain <literal>replicaCount: 2</literal>.</simpara>
<simpara>Edit the <literal>config/samples/demo_v1_nginx.yaml</literal> file to set <literal>replicaCount: 2</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: demo.example.com/v1
kind: Nginx
metadata:
  name: nginx-sample
...
spec:
...
  replicaCount: 2</programlisting>
</listitem>
<listitem>
<simpara>Similarly, the default service port is set to <literal>80</literal>. To use <literal>8080</literal>, edit the <literal>config/samples/demo_v1_nginx.yaml</literal> file to set <literal>spec.port: 8080</literal>,which adds the service port override:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: demo.example.com/v1
kind: Nginx
metadata:
  name: nginx-sample
spec:
  replicaCount: 2
  service:
    port: 8080</programlisting>
</listitem>
</orderedlist>
<simpara>The Helm Operator applies the entire spec as if it was the contents of a values file, just like the <literal>helm install -f ./overrides.yaml</literal> command.</simpara>
</section>
</section>
<section xml:id="osdk-run-proxy_osdk-helm-tutorial">
<title>Enabling proxy support</title>
<simpara>Operator authors can develop Operators that support network proxies.
Cluster administrators
configure proxy support for the environment variables that are handled by Operator Lifecycle Manager (OLM). To support proxied clusters, your Operator must inspect the environment for the following standard proxy variables and pass the values to Operands:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HTTP_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>HTTPS_PROXY</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NO_PROXY</literal></simpara>
</listitem>
</itemizedlist>
<note>
<simpara>This tutorial uses <literal>HTTP_PROXY</literal> as an example environment variable.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A cluster with cluster-wide egress proxy enabled.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>watches.yaml</literal> file to include overrides based on an environment variable by adding the <literal>overrideValues</literal> field:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">...
- group: demo.example.com
  version: v1alpha1
  kind: Nginx
  chart: helm-charts/nginx
  overrideValues:
    proxy.http: $HTTP_PROXY
...</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>proxy.http</literal> value in the <literal>helm-charts/nginx/values.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">...
proxy:
  http: ""
  https: ""
  no_proxy: ""</programlisting>
</listitem>
<listitem>
<simpara>To make sure the chart template supports using the variables, edit the chart template in the <literal>helm-charts/nginx/templates/deployment.yaml</literal> file to contain the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
  - name: {{ .Chart.Name }}
    securityContext:
      - toYaml {{ .Values.securityContext | nindent 12 }}
    image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
    imagePullPolicy: {{ .Values.image.pullPolicy }}
    env:
      - name: http_proxy
        value: "{{ .Values.proxy.http }}"</programlisting>
</listitem>
<listitem>
<simpara>Set the environment variable on the Operator deployment by adding the following to the <literal>config/manager/manager.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">containers:
 - args:
   - --leader-elect
   - --leader-election-id=ansible-proxy-demo
   image: controller:latest
   name: manager
   env:
     - name: "HTTP_PROXY"
       value: "http_proxy_test"</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-run-operator_osdk-helm-tutorial">
<title>Running the Operator</title>
<simpara>There are three ways you can use the Operator SDK CLI to build and run your Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Run locally outside the cluster as a Go program.</simpara>
</listitem>
<listitem>
<simpara>Run as a deployment on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Bundle your Operator and use Operator Lifecycle Manager (OLM) to deploy on the cluster.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-run-locally_osdk-helm-tutorial">
<title>Running locally outside the cluster</title>
<simpara>You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to install the custom resource definitions (CRDs) in the cluster configured in your <literal>~/.kube/config</literal> file and run the Operator locally:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install run</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
{"level":"info","ts":1612652419.9289865,"logger":"controller-runtime.metrics","msg":"metrics server is starting to listen","addr":":8080"}
{"level":"info","ts":1612652419.9296563,"logger":"helm.controller","msg":"Watching resource","apiVersion":"demo.example.com/v1","kind":"Nginx","namespace":"","reconcilePeriod":"1m0s"}
{"level":"info","ts":1612652419.929983,"logger":"controller-runtime.manager","msg":"starting metrics server","path":"/metrics"}
{"level":"info","ts":1612652419.930015,"logger":"controller-runtime.manager.controller.nginx-controller","msg":"Starting EventSource","source":"kind source: demo.example.com/v1, Kind=Nginx"}
{"level":"info","ts":1612652420.2307851,"logger":"controller-runtime.manager.controller.nginx-controller","msg":"Starting Controller"}
{"level":"info","ts":1612652420.2309358,"logger":"controller-runtime.manager.controller.nginx-controller","msg":"Starting workers","worker count":8}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-helm-tutorial">
<title>Running as a deployment on the cluster</title>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>By default, this command creates a namespace with the name of your Operator project in the form <literal>&lt;project_name&gt;-system</literal> and is used for the deployment. This command also installs the RBAC manifests from <literal>config/rbac</literal>.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;project_name&gt;-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
&lt;project_name&gt;-controller-manager       1/1     1            1           8m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-bundle-deploy-olm_osdk-helm-tutorial">
<title>Bundling an Operator and deploying with Operator Lifecycle Manager</title>
<section xml:id="osdk-bundle-operator_osdk-helm-tutorial">
<title>Bundling an Operator</title>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) v{product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initialized by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands in your Operator project directory to build and push your Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create your Operator bundle manifest by running the <literal>make bundle</literal> command, which invokes several commands, including the Operator SDK <literal>generate bundle</literal> and <literal>bundle validate</literal> subcommands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>Bundle manifests for an Operator describe how to display, create, and manage an application. The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These files are then automatically validated by using <literal>operator-sdk bundle validate</literal> to ensure the on-disk bundle representation is correct.</simpara>
</listitem>
<listitem>
<simpara>Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the bundle image. Set <literal>BUNDLE_IMG</literal> with the details for the registry, user namespace, and image tag where you intend to push the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build BUNDLE_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker push &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-deploy-olm_osdk-helm-tutorial">
<title>Deploying an Operator with Operator Lifecycle Manager</title>
<simpara>Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on {product-title} and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (<literal>oc</literal>) for all Operator lifecycle management functions without any additional tools.</simpara>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to run the Operator on the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle \<co xml:id="CO63-1"/>
    -n &lt;namespace&gt; \<co xml:id="CO63-2"/>
    &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; <co xml:id="CO63-3"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>The <literal>run bundle</literal> command creates a valid file-based catalog and installs the Operator bundle on your cluster using OLM.</para>
</callout>
<callout arearefs="CO63-2">
<para>Optional: By default, the command installs the Operator in the currently active project in your <literal>~/.kube/config</literal> file. You can add the <literal>-n</literal> flag to set a different namespace scope for the installation.</para>
</callout>
<callout arearefs="CO63-3">
<para>If you do not specify an image, the command uses <literal>quay.io/operator-framework/opm:latest</literal> as the default index image. If you specify an image, the command uses the bundle image itself as the index image.</para>
</callout>
</calloutlist>
<important>
<simpara>As of {product-title} 4.11, the <literal>run bundle</literal> command supports the file-based catalog format for Operator catalogs by default. The deprecated SQLite database format for Operator catalogs continues to be supported; however, it will be removed in a future release. It is recommended that Operator authors migrate their workflows to the file-based catalog format.</simpara>
</important>
<simpara>This command performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an index image referencing your bundle image. The index image is opaque and ephemeral, but accurately reflects how a bundle would be added to a catalog in production.</simpara>
</listitem>
<listitem>
<simpara>Create a catalog source that points to your new index image, which enables OperatorHub to discover your Operator.</simpara>
</listitem>
<listitem>
<simpara>Deploy your Operator to your cluster by creating an <literal>OperatorGroup</literal>, <literal>Subscription</literal>, <literal>InstallPlan</literal>, and all other required resources, including RBAC.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-create-cr_osdk-helm-tutorial">
<title>Creating a custom resource</title>
<simpara>After your Operator is installed, you can test it by creating a custom resource (CR) that is now provided on the cluster by the Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Example Nginx Operator, which provides the <literal>Nginx</literal> CR, installed on a cluster</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the namespace where your Operator is installed. For example, if you deployed the Operator using the <literal>make deploy</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project nginx-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Edit the sample <literal>Nginx</literal> CR manifest at <literal>config/samples/demo_v1_nginx.yaml</literal> to contain the following specification:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: demo.example.com/v1
kind: Nginx
metadata:
  name: nginx-sample
...
spec:
...
  replicaCount: 3</programlisting>
</listitem>
<listitem>
<simpara>The Nginx service account requires privileged access to run in {product-title}. Add the following security context constraint (SCC) to the service account for the <literal>nginx-sample</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user \
    anyuid system:serviceaccount:nginx-operator-system:nginx-sample</programlisting>
</listitem>
<listitem>
<simpara>Create the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/demo_v1_nginx.yaml</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the <literal>Nginx</literal> Operator creates the deployment for the sample CR with the correct size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
nginx-operator-controller-manager       1/1     1            1           8m
nginx-sample                            3/3     3            3           1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the pods and CR status to confirm the status is updated with the Nginx pod names.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the pods:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY     STATUS    RESTARTS   AGE
nginx-sample-6fd7c98d8-7dqdr          1/1       Running   0          1m
nginx-sample-6fd7c98d8-g5k7v          1/1       Running   0          1m
nginx-sample-6fd7c98d8-m7vn7          1/1       Running   0          1m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the CR status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nginx/nginx-sample -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: demo.example.com/v1
kind: Nginx
metadata:
...
  name: nginx-sample
...
spec:
  replicaCount: 3
status:
  nodes:
  - nginx-sample-6fd7c98d8-7dqdr
  - nginx-sample-6fd7c98d8-g5k7v
  - nginx-sample-6fd7c98d8-m7vn7</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update the deployment size.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update <literal>config/samples/demo_v1_nginx.yaml</literal> file to change the <literal>spec.size</literal> field in the <literal>Nginx</literal> CR from <literal>3</literal> to <literal>5</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch nginx nginx-sample \
    -p '{"spec":{"replicaCount": 5}}' \
    --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the Operator changes the deployment size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployments</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
nginx-operator-controller-manager       1/1     1            1           10m
nginx-sample                            5/5     5            5           3m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete the CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/demo_v1_nginx.yaml</programlisting>
</listitem>
<listitem>
<simpara>Clean up the resources that have been created as part of this tutorial.</simpara>
<itemizedlist>
<listitem>
<simpara>If you used the <literal>make deploy</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
<listitem>
<simpara>If you used the <literal>operator-sdk run bundle</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk cleanup &lt;project_name&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-helm-tutorial-addtl-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/helm/osdk-helm-project-layout.xml#osdk-helm-project-layout">Project layout for Helm-based Operators</link> to learn about the directory structures created by the Operator SDK.</simpara>
</listitem>
<listitem>
<simpara>If a <link xl:href="../../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">cluster-wide egress proxy is configured</link>, cluster administrators can <link xl:href="../../../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">override the proxy settings or inject a custom CA certificate</link> for specific Operators running on Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-helm-project-layout">
<title>Project layout for Helm-based Operators</title>

<simpara>The <literal>operator-sdk</literal> CLI can generate, or <emphasis>scaffold</emphasis>, a number of packages and files for each Operator project.</simpara>
<section xml:id="osdk-helm-project-layout_osdk-helm-project-layout">
<title>Helm-based project layout</title>
<simpara>Helm-based Operator projects generated using the <literal>operator-sdk init --plugins helm</literal> command contain the following directories and files:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">File/folders</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>config/</literal></simpara></entry>
<entry align="left" valign="top"><simpara><link xl:href="https://kustomize.io/">Kustomize</link> manifests for deploying the Operator on a Kubernetes cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>helm-charts/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Helm chart initialized with the <literal>operator-sdk create api</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Dockerfile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used to build the Operator image with the <literal>make docker-build</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>watches.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Group/version/kind (GVK) and Helm chart location.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Makefile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Targets used to manage the project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PROJECT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>YAML file containing metadata information for the Operator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="osdk-helm-updating-projects">
<title>Updating Helm-based projects for newer Operator SDK versions</title>

<simpara>{product-title} {product-version} supports Operator SDK 1.31.0. If you already have the 1.28.0 CLI installed on your workstation, you can update the CLI to 1.31.0 by <link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">installing the latest version</link>.</simpara>
<simpara>However, to ensure your existing Operator projects maintain compatibility with Operator SDK 1.31.0, update steps are required for the associated breaking changes introduced since 1.28.0. You must perform the update steps manually in any of your Operator projects that were previously created or maintained with 1.28.0.</simpara>
<section xml:id="osdk-upgrading-projects_osdk-helm-updating-projects">
<title>Updating Helm-based Operator projects for Operator SDK 1.31.0</title>
<simpara>The following procedure updates an existing Helm-based Operator project for compatibility with 1.31.0.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK 1.31.0 installed</simpara>
</listitem>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.28.0</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit your Operator&#8217;s Dockerfile to update the Helm Operator version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example Dockerfile</title>
<para>
<programlisting language="docker" linenumbering="unnumbered">FROM quay.io/operator-framework/helm-operator:v1.31.0 <co xml:id="CO64-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO64-1">
<para>Update the Helm Operator version from <literal>1.28.0</literal> to <literal>1.31.0</literal></para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit your Operator project&#8217;s makefile to update the Operator SDK to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># Set the Operator SDK version to use. By default, what is installed on the system is used.
# This is useful for CI or a project to utilize a specific version of the operator-sdk toolkit.
OPERATOR_SDK_VERSION ?= v1.31.0 <co xml:id="CO65-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO65-1">
<para>Change the version from <literal>{osdk_ver-n1}</literal> to <literal>1.31.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If you use a custom service account for deployment, define the following role to require a watch operation on your secrets resource, as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>config/rbac/role.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: &lt;operator_name&gt;-admin
subjects:
- kind: ServiceAccount
  name: &lt;operator_name&gt;
  namespace: &lt;operator_namespace&gt;
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: ""
rules: <co xml:id="CO66-1"/>
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - watch</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1">
<para>Add the <literal>rules</literal> stanza to create a watch operation for your secrets resource.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_osdk-helm-upgrading-projects" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-pkgman-to-bundle.xml#osdk-pkgman-to-bundle">Migrating package manifest projects to bundle format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.10/html-single/operators/index#osdk-upgrading-v1101-to-v1160_osdk-upgrading-projects">Upgrading projects for Operator SDK 1.16.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.9/html/operators/developing-operators#osdk-upgrading-v180-to-v1101_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.10.1</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.8/html/operators/developing-operators#osdk-upgrading-v130-to-v180_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.8.0</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-helm-support">
<title>Helm support in Operator SDK</title>

<section xml:id="osdk-helm-charts_osdk-helm-support">
<title>Helm charts</title>
<simpara>One of the Operator SDK options for generating an Operator project includes leveraging an existing Helm chart to deploy Kubernetes resources as a unified application, without having to write any Go code. Such Helm-based Operators are designed to excel at stateless applications that require very little logic when rolled out, because changes should be applied to the Kubernetes objects that are generated as part of the chart. This may sound limiting, but can be sufficient for a surprising amount of use-cases as shown by the proliferation of Helm charts built by the Kubernetes community.</simpara>
<simpara>The main function of an Operator is to read from a custom object that represents your application instance and have its desired state match what is running. In the case of a Helm-based Operator, the <literal>spec</literal> field of the object is a list of configuration options that are typically described in the Helm <literal>values.yaml</literal> file. Instead of setting these values with flags using the Helm CLI (for example, <literal>helm install -f values.yaml</literal>), you can express them within a custom resource (CR), which, as a native Kubernetes object, enables the benefits of RBAC applied to it and an audit trail.</simpara>
<simpara>For an example of a simple CR called <literal>Tomcat</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apache.org/v1alpha1
kind: Tomcat
metadata:
  name: example-app
spec:
  replicaCount: 2</programlisting>
<simpara>The <literal>replicaCount</literal> value, <literal>2</literal> in this case, is propagated into the template of the chart where the following is used:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">{{ .Values.replicaCount }}</programlisting>
<simpara>After an Operator is built and deployed, you can deploy a new instance of an app by creating a new instance of a CR, or list the different instances running in all environments using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get Tomcats --all-namespaces</programlisting>
<simpara>There is no requirement use the Helm CLI or install Tiller; Helm-based Operators import code from the Helm project. All you have to do is have an instance of the Operator running and register the CR with a custom resource definition (CRD). Because it obeys RBAC, you can more easily prevent production changes.</simpara>
</section>
</section>
<section xml:id="osdk-hybrid-helm">
<title>Operator SDK tutorial for Hybrid Helm Operators</title>

<simpara>The standard Helm-based Operator support in the Operator SDK has limited functionality compared to the Go-based and Ansible-based Operator support that has reached the Auto Pilot capability (level V) in the <link xl:href="../../../operators/understanding/olm-what-operators-are.xml#olm-maturity-model_olm-what-operators-are">Operator maturity model</link>.</simpara>
<simpara>The Hybrid Helm Operator enhances the existing Helm-based support&#8217;s abilities through Go APIs. With this hybrid approach of Helm and Go, the Operator SDK enables Operator authors to use the following process:</simpara>
<itemizedlist>
<listitem>
<simpara>Generate a default structure for, or <emphasis>scaffold</emphasis>, a Go API in the same project as Helm.</simpara>
</listitem>
<listitem>
<simpara>Configure the Helm reconciler in the <literal>main.go</literal> file of the project, through the libraries provided by the Hybrid Helm Operator.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The Hybrid Helm Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>This tutorial walks through the following process using the Hybrid Helm Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a <literal>Memcached</literal> deployment through a Helm chart if it does not exist</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment size is the same as specified by <literal>Memcached</literal> custom resource (CR) spec</simpara>
</listitem>
<listitem>
<simpara>Create a <literal>MemcachedBackup</literal> deployment by using the Go API</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-common-prereqs_osdk-hybrid-helm">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-hh-create-project_osdk-hybrid-helm">
<title>Creating a project</title>
<simpara>Use the Operator SDK CLI to create a project called <literal>memcached-operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p $HOME/github.com/example/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change to the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd $HOME/github.com/example/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command to initialize the project. Use a domain of <literal>example.com</literal> so that all API groups are <literal>&lt;group&gt;.example.com</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=hybrid.helm.sdk.operatorframework.io \
    --project-version="3" \
    --domain example.com \
    --repo=github.com/example/memcached-operator</programlisting>
<simpara>The <literal>init</literal> command generates the RBAC rules in the <literal>config/rbac/role.yaml</literal> file based on the resources that would be deployed by the chart&#8217;s default manifests. Verify that the rules generated in the <literal>config/rbac/role.yaml</literal> file meet your Operator&#8217;s permission requirements.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>This procedure creates a project structure that is compatible with both Helm and Go APIs. To learn more about the project directory structure, see <link xl:href="../../../operators/operator_sdk/helm/osdk-hybrid-helm.xml#osdk-hh-project-layout_osdk-hybrid-helm">Project layout</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-hh-create-helm-api_osdk-hybrid-helm">
<title>Creating a Helm API</title>
<simpara>Use the Operator SDK CLI to create a Helm API.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to create a Helm API with group <literal>cache</literal>, version <literal>v1</literal>, and kind <literal>Memcached</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --plugins helm.sdk.operatorframework.io/v1 \
    --group cache \
    --version v1 \
    --kind Memcached</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>This procedure also configures your Operator project to watch the <literal>Memcached</literal> resource with API version <literal>v1</literal> and scaffolds a boilerplate Helm chart. Instead of creating the project from the boilerplate Helm chart scaffolded by the Operator SDK, you can alternatively use an existing chart from your local file system or remote chart repository.</simpara>
<simpara>For more details and examples for creating Helm API based on existing or new charts, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api --plugins helm.sdk.operatorframework.io/v1 --help</programlisting>
</note>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/helm/osdk-helm-tutorial.xml#osdk-helm-existing-chart_osdk-helm-tutorial">Existing Helm charts</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-hh-helm-api-logic_osdk-hybrid-helm">
<title>Operator logic for the Helm API</title>
<simpara>By default, your scaffolded Operator project watches <literal>Memcached</literal> resource events as shown in the <literal>watches.yaml</literal> file and executes Helm releases using the specified chart.</simpara>
<example>
<title>Example <literal>watches.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered"># Use the 'create api' subcommand to add watches to this file.
- group: cache.my.domain
  version: v1
  kind: Memcached
  chart: helm-charts/memcached
#+kubebuilder:scaffold:watch</programlisting>
</example>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>For detailed documentation on customizing the Helm Operator logic through the chart, see <link xl:href="../../../operators/operator_sdk/helm/osdk-helm-tutorial.xml#osdk-helm-logic_osdk-helm-tutorial">Understanding the Operator logic</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-hh-helm-reconciler_osdk-hybrid-helm">
<title>Custom Helm reconciler configurations using provided library APIs</title>
<simpara>A disadvantage of existing Helm-based Operators is the inability to configure the Helm reconciler, because it is abstracted from users. For a Helm-based Operator to reach the Seamless Upgrades capability (level II and later) that reuses an already existing Helm chart, a hybrid between the Go and Helm Operator types adds value.</simpara>
<simpara>The APIs provided in the <link xl:href="https://github.com/operator-framework/helm-operator-plugins"><literal>helm-operator-plugins</literal></link> library allow Operator authors to make the following configurations:</simpara>
<itemizedlist>
<listitem>
<simpara>Customize value mapping based on cluster state</simpara>
</listitem>
<listitem>
<simpara>Execute code in specific events by configuring the reconciler&#8217;s event recorder</simpara>
</listitem>
<listitem>
<simpara>Customize the reconciler&#8217;s logger</simpara>
</listitem>
<listitem>
<simpara>Setup <literal>Install</literal>, <literal>Upgrade</literal>, and <literal>Uninstall</literal> annotations to enable Helm&#8217;s actions to be configured based on the annotations found in custom resources watched by the reconciler</simpara>
</listitem>
<listitem>
<simpara>Configure the reconciler to run with <literal>Pre</literal> and <literal>Post</literal> hooks</simpara>
</listitem>
</itemizedlist>
<simpara>The above configurations to the reconciler can be done in the <literal>main.go</literal> file:</simpara>
<informalexample>
<formalpara>
<title>Example <literal>main.go</literal> file</title>
<para>
<programlisting language="golang" linenumbering="unnumbered">// Operator's main.go
// With the help of helpers provided in the library, the reconciler can be
// configured here before starting the controller with this reconciler.
reconciler := reconciler.New(
 reconciler.WithChart(*chart),
 reconciler.WithGroupVersionKind(gvk),
)

if err := reconciler.SetupWithManager(mgr); err != nil {
 panic(fmt.Sprintf("unable to create reconciler: %s", err))
}</programlisting>
</para>
</formalpara>
</informalexample>
</section>
</section>
<section xml:id="osdk-hh-create-go-api_osdk-hybrid-helm">
<title>Creating a Go API</title>
<simpara>Use the Operator SDK CLI to create a Go API.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to create a Go API with group <literal>cache</literal>, version <literal>v1</literal>, and kind <literal>MemcachedBackup</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group=cache \
    --version v1 \
    --kind MemcachedBackup \
    --resource \
    --controller \
    --plugins=go/v3</programlisting>
</listitem>
<listitem>
<simpara>When prompted, enter <literal>y</literal> for creating both resource and controller:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ Create Resource [y/n]
y
Create Controller [y/n]
y</programlisting>
</listitem>
</orderedlist>
<simpara>This procedure generates the <literal>MemcachedBackup</literal> resource API at <literal>api/v1/memcachedbackup_types.go</literal> and the controller at <literal>controllers/memcachedbackup_controller.go</literal>.</simpara>
<section xml:id="osdk-hh-defining-go-api_osdk-hybrid-helm">
<title>Defining the API</title>
<simpara>Define the API for the <literal>MemcachedBackup</literal> custom resource (CR).</simpara>
<simpara>Represent this Go API by defining the <literal>MemcachedBackup</literal> type, which will have a <literal>MemcachedBackupSpec.Size</literal> field to set the quantity of Memcached backup instances (CRs) to be deployed, and a <literal>MemcachedBackupStatus.Nodes</literal> field to store a CR&#8217;s pod names.</simpara>
<note>
<simpara>The <literal>Node</literal> field is used to illustrate an example of a <literal>Status</literal> field.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define the API for the <literal>MemcachedBackup</literal> CR by modifying the Go type definitions in the <literal>api/v1/memcachedbackup_types.go</literal> file to have the following <literal>spec</literal> and <literal>status</literal>:</simpara>
<example>
<title>Example <literal>api/v1/memcachedbackup_types.go</literal> file</title>
<programlisting language="golang" linenumbering="unnumbered">// MemcachedBackupSpec defines the desired state of MemcachedBackup
type MemcachedBackupSpec struct {
	// INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
	// Important: Run "make" to regenerate code after modifying this file

	//+kubebuilder:validation:Minimum=0
	// Size is the size of the memcached deployment
	Size int32 `json:"size"`
}

// MemcachedBackupStatus defines the observed state of MemcachedBackup
type MemcachedBackupStatus struct {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
	// Important: Run "make" to regenerate code after modifying this file
	// Nodes are the names of the memcached pods
	Nodes []string `json:"nodes"`
}</programlisting>
</example>
</listitem>
<listitem>
<simpara>Update the generated code for the resource type:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make generate</programlisting>
<tip>
<simpara>After you modify a <literal>*_types.go</literal> file, you must run the <literal>make generate</literal> command to update the generated code for that resource type.</simpara>
</tip>
</listitem>
<listitem>
<simpara>After the API is defined with <literal>spec</literal> and <literal>status</literal> fields and CRD validation markers, generate and update the CRD manifests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make manifests</programlisting>
</listitem>
</orderedlist>
<simpara>This Makefile target invokes the <literal>controller-gen</literal> utility to generate the CRD manifests in the <literal>config/crd/bases/cache.my.domain_memcachedbackups.yaml</literal> file.</simpara>
</section>
<section xml:id="osdk-hh-implement-controller_osdk-hybrid-helm">
<title>Controller implementation</title>
<simpara>The controller in this tutorial performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a <literal>Memcached</literal> deployment if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the deployment size is the same as specified by the <literal>Memcached</literal> CR spec.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>Memcached</literal> CR status with the names of the <literal>memcached</literal> pods.</simpara>
</listitem>
</itemizedlist>
<simpara>For a detailed explanation on how to configure the controller to perform the above mentioned actions, see <link xl:href="../../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-golang-implement-controller_osdk-golang-tutorial">Implementing the controller</link> in the Operator SDK tutorial for standard Go-based Operators.</simpara>
</section>
<section xml:id="osdk-hh-main-go_osdk-hybrid-helm">
<title>Differences in main.go</title>
<simpara>For standard Go-based Operators and the Hybrid Helm Operator, the <literal>main.go</literal> file handles the scaffolding the initialization and running of the <link xl:href="https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/manager#Manager"><literal>Manager</literal></link> program for the Go API. For the Hybrid Helm Operator, however, the <literal>main.go</literal> file also exposes the logic for loading the <literal>watches.yaml</literal> file and configuring the Helm reconciler.</simpara>
<example>
<title>Example <literal>main.go</literal> file</title>
<programlisting language="terminal" linenumbering="unnumbered">...
	for _, w := range ws {
		// Register controller with the factory
		reconcilePeriod := defaultReconcilePeriod
		if w.ReconcilePeriod != nil {
			reconcilePeriod = w.ReconcilePeriod.Duration
		}

		maxConcurrentReconciles := defaultMaxConcurrentReconciles
		if w.MaxConcurrentReconciles != nil {
			maxConcurrentReconciles = *w.MaxConcurrentReconciles
		}

		r, err := reconciler.New(
			reconciler.WithChart(*w.Chart),
			reconciler.WithGroupVersionKind(w.GroupVersionKind),
			reconciler.WithOverrideValues(w.OverrideValues),
			reconciler.SkipDependentWatches(w.WatchDependentResources != nil &amp;&amp; !*w.WatchDependentResources),
			reconciler.WithMaxConcurrentReconciles(maxConcurrentReconciles),
			reconciler.WithReconcilePeriod(reconcilePeriod),
			reconciler.WithInstallAnnotations(annotation.DefaultInstallAnnotations...),
			reconciler.WithUpgradeAnnotations(annotation.DefaultUpgradeAnnotations...),
			reconciler.WithUninstallAnnotations(annotation.DefaultUninstallAnnotations...),
		)
...</programlisting>
</example>
<simpara>The manager is initialized with both <literal>Helm</literal> and <literal>Go</literal> reconcilers:</simpara>
<example>
<title>Example <literal>Helm</literal> and <literal>Go</literal> reconcilers</title>
<programlisting language="terminal" linenumbering="unnumbered">...
// Setup manager with Go API
   if err = (&amp;controllers.MemcachedBackupReconciler{
		Client: mgr.GetClient(),
		Scheme: mgr.GetScheme(),
	}).SetupWithManager(mgr); err != nil {
		setupLog.Error(err, "unable to create controller", "controller", "MemcachedBackup")
		os.Exit(1)
	}

   ...
// Setup manager with Helm API
	for _, w := range ws {

      ...
		if err := r.SetupWithManager(mgr); err != nil {
			setupLog.Error(err, "unable to create controller", "controller", "Helm")
			os.Exit(1)
		}
		setupLog.Info("configured watch", "gvk", w.GroupVersionKind, "chartPath", w.ChartPath, "maxConcurrentReconciles", maxConcurrentReconciles, "reconcilePeriod", reconcilePeriod)
	}

// Start the manager
   if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil {
		setupLog.Error(err, "problem running manager")
		os.Exit(1)
	}</programlisting>
</example>
</section>
<section xml:id="osdk-hh-rbac_osdk-hybrid-helm">
<title>Permissions and RBAC manifests</title>
<simpara>The controller requires certain role-based access control (RBAC) permissions to interact with the resources it manages. For the Go API, these are specified with RBAC markers, as shown in the Operator SDK tutorial for standard Go-based Operators.</simpara>
<simpara>For the Helm API, the permissions are scaffolded by default in <literal>roles.yaml</literal>. Currently, however, due to a known issue when the Go API is scaffolded, the permissions for the Helm API are overwritten. As a result of this issue, ensure that the permissions defined in <literal>roles.yaml</literal> match your requirements.</simpara>
<note>
<simpara>This known issue is being tracked in <link xl:href="https://github.com/operator-framework/helm-operator-plugins/issues/142">https://github.com/operator-framework/helm-operator-plugins/issues/142</link>.</simpara>
</note>
<simpara>The following is an example <literal>role.yaml</literal> for a Memcached Operator:</simpara>
<example>
<title>Example <literal>Helm</literal> and <literal>Go</literal> reconcilers</title>
<programlisting language="yaml" linenumbering="unnumbered">---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: manager-role
rules:
- apiGroups:
  - ""
  resources:
  - namespaces
  verbs:
  - get
- apiGroups:
  - apps
  resources:
  - deployments
  - daemonsets
  - replicasets
  - statefulsets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - cache.my.domain
  resources:
  - memcachedbackups
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - cache.my.domain
  resources:
  - memcachedbackups/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - pods
  - services
  - services/finalizers
  - endpoints
  - persistentvolumeclaims
  - events
  - configmaps
  - secrets
  - serviceaccounts
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - cache.my.domain
  resources:
  - memcachedbackups/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - policy
  resources:
  - events
  - poddisruptionbudgets
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - cache.my.domain
  resources:
  - memcacheds
  - memcacheds/status
  - memcacheds/finalizers
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch</programlisting>
</example>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-golang-controller-rbac-markers_osdk-golang-tutorial">RBAC markers for Go-based Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-run-locally_osdk-hybrid-helm">
<title>Running locally outside the cluster</title>
<simpara>You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to install the custom resource definitions (CRDs) in the cluster configured in your <literal>~/.kube/config</literal> file and run the Operator locally:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install run</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-hybrid-helm">
<title>Running as a deployment on the cluster</title>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>By default, this command creates a namespace with the name of your Operator project in the form <literal>&lt;project_name&gt;-system</literal> and is used for the deployment. This command also installs the RBAC manifests from <literal>config/rbac</literal>.</simpara>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n &lt;project_name&gt;-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
&lt;project_name&gt;-controller-manager       1/1     1            1           8m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-hh-create-cr_osdk-hybrid-helm">
<title>Creating custom resources</title>
<simpara>After your Operator is installed, you can test it by creating custom resources (CRs) that are now provided on the cluster by the Operator.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the namespace where your Operator is installed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project &lt;project_name&gt;-system</programlisting>
</listitem>
<listitem>
<simpara>Update the sample <literal>Memcached</literal> CR manifest at the <literal>config/samples/cache_v1_memcached.yaml</literal> file by updating the <literal>replicaCount</literal> field to <literal>3</literal>:</simpara>
<example>
<title>Example <literal>config/samples/cache_v1_memcached.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.my.domain/v1
kind: Memcached
metadata:
  name: memcached-sample
spec:
  # Default values copied from &lt;project_dir&gt;/helm-charts/memcached/values.yaml
  affinity: {}
  autoscaling:
    enabled: false
    maxReplicas: 100
    minReplicas: 1
    targetCPUUtilizationPercentage: 80
  fullnameOverride: ""
  image:
    pullPolicy: IfNotPresent
    repository: nginx
    tag: ""
  imagePullSecrets: []
  ingress:
    annotations: {}
    className: ""
    enabled: false
    hosts:
    - host: chart-example.local
      paths:
      - path: /
        pathType: ImplementationSpecific
    tls: []
  nameOverride: ""
  nodeSelector: {}
  podAnnotations: {}
  podSecurityContext: {}
  replicaCount: 3
  resources: {}
  securityContext: {}
  service:
    port: 80
    type: ClusterIP
  serviceAccount:
    annotations: {}
    create: true
    name: ""
  tolerations: []</programlisting>
</example>
</listitem>
<listitem>
<simpara>Create the <literal>Memcached</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the Memcached Operator creates the deployment for the sample CR with the correct size:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY     STATUS    RESTARTS   AGE
memcached-sample-6fd7c98d8-7dqdr      1/1       Running   0          18m
memcached-sample-6fd7c98d8-g5k7v      1/1       Running   0          18m
memcached-sample-6fd7c98d8-m7vn7      1/1       Running   0          18m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Update the sample <literal>MemcachedBackup</literal> CR manifest at the <literal>config/samples/cache_v1_memcachedbackup.yaml</literal> file by updating the <literal>size</literal> to <literal>2</literal>:</simpara>
<example>
<title>Example <literal>config/samples/cache_v1_memcachedbackup.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.my.domain/v1
kind: MemcachedBackup
metadata:
  name: memcachedbackup-sample
spec:
  size: 2</programlisting>
</example>
</listitem>
<listitem>
<simpara>Create the <literal>MemcachedBackup</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcachedbackup.yaml</programlisting>
</listitem>
<listitem>
<simpara>Ensure that the count of <literal>memcachedbackup</literal> pods is the same as specified in the CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                        READY     STATUS    RESTARTS   AGE
memcachedbackup-sample-8649699989-4bbzg     1/1       Running   0          22m
memcachedbackup-sample-8649699989-mq6mx     1/1       Running   0          22m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>You can update the <literal>spec</literal> in each of the above CRs, and then apply them again. The controller reconciles again and ensures that the size of the pods is as specified in the <literal>spec</literal> of the respective CRs.</simpara>
</listitem>
<listitem>
<simpara>Clean up the resources that have been created as part of this tutorial:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the <literal>Memcached</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached.yaml</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>MemcachedBackup</literal> resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcachedbackup.yaml</programlisting>
</listitem>
<listitem>
<simpara>If you used the <literal>make deploy</literal> command to test the Operator, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-hh-project-layout_osdk-hybrid-helm">
<title>Project layout</title>
<simpara>The Hybrid Helm Operator scaffolding is customized to be compatible with both Helm and Go APIs.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">File/folders</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Dockerfile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Instructions used by a container engine to build your Operator image with the <literal>make docker-build</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Makefile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Build file with helper targets to help you work with your project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PROJECT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>YAML file containing metadata information for the Operator. Represents the project&#8217;s configuration and is used to track useful information for the CLI and plugins.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>bin/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains useful binaries such as the <literal>manager</literal> which is used to run your project locally and  the <literal>kustomize</literal> utility used for the project configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>config/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains configuration files, including all <link xl:href="https://kustomize.io/">Kustomize</link> manifests, to launch your Operator project on a cluster. Plugins might use it to provide functionality. For example, for the Operator SDK to help create your Operator bundle, the CLI looks up the CRDs and CRs which are scaffolded in this directory.</simpara>
<variablelist>
<varlistentry>
<term><literal>config/crd/</literal></term>
<listitem>
<simpara>Contains custom resource definitions (CRDs).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/default/</literal></term>
<listitem>
<simpara>Contains a Kustomize base for launching the controller in a standard configuration.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/manager/</literal></term>
<listitem>
<simpara>Contains the manifests to launch your Operator project as pods on the cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/manifests/</literal></term>
<listitem>
<simpara>Contains the base to generate your OLM manifests in the <literal>bundle/</literal> directory.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/prometheus/</literal></term>
<listitem>
<simpara>Contains the manifests required to enable project to serve metrics to Prometheus such as the <literal>ServiceMonitor</literal> resource.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/scorecard/</literal></term>
<listitem>
<simpara>Contains the manifests required to allow you test your project with the scorecard tool.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/rbac/</literal></term>
<listitem>
<simpara>Contains the RBAC permissions required to run your project.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>config/samples/</literal></term>
<listitem>
<simpara>Contains samples for custom resources.</simpara>
</listitem>
</varlistentry>
</variablelist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>api/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the Go API definition.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>controllers/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the controllers for the Go API.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hack/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains utility files, such as the file used to scaffold the license header for your project files.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>main.go</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Main program of the Operator. Instantiates a new manager that registers all custom resource definitions (CRDs) in the <literal>apis/</literal> directory and starts all controllers in the <literal>controllers/</literal> directory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>helm-charts/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains the Helm charts which can be specified using the <literal>create api</literal> command with the Helm plugin.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>watches.yaml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains group/version/kind (GVK) and Helm chart location. Used to configure the Helm watches.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="osdk-hybrid-helm-updating-projects">
<title>Updating Hybrid Helm-based projects for newer Operator SDK versions</title>

<simpara>{product-title} {product-version} supports Operator SDK 1.31.0. If you already have the 1.28.0 CLI installed on your workstation, you can update the CLI to 1.31.0 by <link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">installing the latest version</link>.</simpara>
<simpara>However, to ensure your existing Operator projects maintain compatibility with Operator SDK 1.31.0, update steps are required for the associated breaking changes introduced since 1.28.0. You must perform the update steps manually in any of your Operator projects that were previously created or maintained with 1.28.0.</simpara>
<section xml:id="osdk-upgrading-projects_osdk-hybrid-helm-updating-projects">
<title>Updating Hybrid Helm-based Operator projects for Operator SDK 1.31.0</title>
<simpara>The following procedure updates an existing Hybrid Helm-based Operator project for compatibility with 1.31.0.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK 1.31.0 installed</simpara>
</listitem>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.28.0</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit your Operator project&#8217;s makefile to update the Operator SDK version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># Set the Operator SDK version to use. By default, what is installed on the system is used.
# This is useful for CI or a project to utilize a specific version of the operator-sdk toolkit.
OPERATOR_SDK_VERSION ?= v1.31.0 <co xml:id="CO67-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO67-1">
<para>Change the version from <literal>1.28.0</literal> to <literal>1.31.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_osdk-hybrid-helm-upgrading-projects" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-pkgman-to-bundle.xml#osdk-pkgman-to-bundle">Migrating package manifest projects to bundle format</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.10/html-single/operators/index#osdk-upgrading-v1101-to-v1160_osdk-upgrading-projects">Upgrading projects for Operator SDK 1.16.0</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.9/html/operators/developing-operators#osdk-upgrading-v180-to-v1101_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.10.1</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.8/html/operators/developing-operators#osdk-upgrading-v130-to-v180_osdk-upgrading-projects">Upgrading projects for Operator SDK v1.8.0</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="_java_based_operators">
<title>Java-based Operators</title>
<section xml:id="osdk-java-quickstart">
<title>Getting started with Operator SDK for Java-based Operators</title>
<important>
<simpara>Java-based Operator SDK is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>

<simpara>To demonstrate the basics of setting up and running a Java-based Operator using tools and libraries provided by the Operator SDK, Operator developers can build an example Java-based Operator for Memcached, a distributed key-value store, and deploy it to a cluster.</simpara>
<section xml:id="osdk-common-prereqs_osdk-java-quickstart">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://java.com/en/download/help/download_options.html">Java</link> 11+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://maven.apache.org/install.html">Maven</link> 3.6.3+</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-quickstart_osdk-java-quickstart">
<title>Creating and deploying Java-based Operators</title>
<simpara>You can build and deploy a simple Java-based Operator for Memcached by using the Operator SDK.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara><emphasis role="strong">Create a project.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create your project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change into the project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>quarkus</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=quarkus \
    --domain=example.com \
    --project-name=memcached-operator</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create an API.</emphasis></simpara>
<simpara>Create a simple Memcached API:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --plugins quarkus \
    --group cache \
    --version v1 \
    --kind Memcached</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Build and push the Operator image.</emphasis></simpara>
<simpara>Use the default <literal>Makefile</literal> targets to build and push your Operator. Set <literal>IMG</literal> with a pull spec for your image that uses a registry you can push to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Run the Operator.</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Install the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
</listitem>
<listitem>
<simpara>Deploy the project to the cluster. Set <literal>IMG</literal> to the image that you pushed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Create a sample custom resource (CR).</emphasis></simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a sample CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/samples/cache_v1_memcached.yaml \
    -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara>Watch for the CR to reconcile the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs deployment.apps/memcached-operator-controller-manager \
    -c manager \
    -n memcached-operator-system</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Delete a CR.</emphasis></simpara>
<simpara>Delete a CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete -f config/samples/cache_v1_memcached -n memcached-operator-system</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Clean up.</emphasis></simpara>
<simpara>Run the following command to clean up the resources that have been created as part of this procedure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make undeploy</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="next-steps_osdk-java-quickstart">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/java/osdk-java-tutorial.xml#osdk-java-tutorial">Operator SDK tutorial for Java-based Operators</link> for a more in-depth walkthrough on building a Java-based Operator.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-java-tutorial">
<title>Operator SDK tutorial for Java-based Operators</title>
<important>
<simpara>Java-based Operator SDK is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>

<simpara>Operator developers can take advantage of Java programming language support in the Operator SDK to build an example Java-based Operator for Memcached, a distributed key-value store, and manage its lifecycle.</simpara>
<simpara>This process is accomplished using two centerpieces of the Operator Framework:</simpara>
<variablelist>
<varlistentry>
<term>Operator SDK</term>
<listitem>
<simpara>The <literal>operator-sdk</literal> CLI tool and <literal>java-operator-sdk</literal> library API</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Operator Lifecycle Manager (OLM)</term>
<listitem>
<simpara>Installation, upgrade, and role-based access control (RBAC) of Operators on a cluster</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>This tutorial goes into greater detail than <link xl:href="../../../operators/operator_sdk/java/osdk-java-quickstart.xml#osdk-java-quickstart">Getting started with Operator SDK for Java-based Operators</link>.</simpara>
</note>
<section xml:id="osdk-common-prereqs_osdk-java-tutorial">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) {product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://java.com/en/download/help/download_options.html">Java</link> 11+</simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://maven.apache.org/install.html">Maven</link> 3.6.3+</simpara>
</listitem>
<listitem>
<simpara>Logged into an {product-title} {product-version} cluster with <literal>oc</literal> with an account that has <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>To allow the cluster to pull the image, the repository where you push your image must be set as public, or you must configure an image pull secret</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">Installing the Operator SDK CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/getting-started-cli.xml#getting-started-cli">Getting started with the OpenShift CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-create-project_osdk-java-tutorial">
<title>Creating a project</title>
<simpara>Use the Operator SDK CLI to create a project called <literal>memcached-operator</literal>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir -p $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Change to the directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd $HOME/projects/memcached-operator</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>operator-sdk init</literal> command
with the <literal>quarkus</literal> plugin
to initialize the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=quarkus \
    --domain=example.com \
    --project-name=memcached-operator</programlisting>
</listitem>
</orderedlist>
<section xml:id="osdk-project-file_osdk-java-tutorial">
<title>PROJECT file</title>
<simpara>Among the files generated by the <literal>operator-sdk init</literal> command is a Kubebuilder <literal>PROJECT</literal> file. Subsequent <literal>operator-sdk</literal> commands, as well as <literal>help</literal> output, that are run from the project root read this file and are aware that the project type is Java. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">domain: example.com
layout:
- quarkus.javaoperatorsdk.io/v1-alpha
projectName: memcached-operator
version: "3"</programlisting>
</section>
</section>
<section xml:id="osdk-java-create-api-controller_osdk-java-tutorial">
<title>Creating an API and controller</title>
<simpara>Use the Operator SDK CLI to create a custom resource definition (CRD) API and controller.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to create an API:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --plugins=quarkus \ <co xml:id="CO68-1"/>
    --group=cache \ <co xml:id="CO68-2"/>
    --version=v1 \ <co xml:id="CO68-3"/>
    --kind=Memcached <co xml:id="CO68-4"/></programlisting>
<calloutlist>
<callout arearefs="CO68-1">
<para>Set the plugin flag to <literal>quarkus</literal>.</para>
</callout>
<callout arearefs="CO68-2">
<para>Set the group flag to <literal>cache</literal>.</para>
</callout>
<callout arearefs="CO68-3">
<para>Set the version flag to <literal>v1</literal>.</para>
</callout>
<callout arearefs="CO68-4">
<para>Set the kind flag to <literal>Memcached</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Run the <literal>tree</literal> command to view the file structure:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tree</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">.
├── Makefile
├── PROJECT
├── pom.xml
└── src
    └── main
        ├── java
        │   └── com
        │       └── example
        │           ├── Memcached.java
        │           ├── MemcachedReconciler.java
        │           ├── MemcachedSpec.java
        │           └── MemcachedStatus.java
        └── resources
            └── application.properties

6 directories, 8 files</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="osdk-java-define-api_osdk-java-tutorial">
<title>Defining the API</title>
<simpara>Define the API for the <literal>Memcached</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the following files that were generated as part of the <literal>create api</literal> process:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Update the following attributes in the <literal>MemcachedSpec.java</literal> file to define the desired state of the <literal>Memcached</literal> CR:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MemcachedSpec {

    private Integer size;

    public Integer getSize() {
        return size;
    }

    public void setSize(Integer size) {
        this.size = size;
    }
}</programlisting>
</listitem>
<listitem>
<simpara>Update the following attributes in the <literal>MemcachedStatus.java</literal> file to define the observed state of the <literal>Memcached</literal> CR:</simpara>
<note>
<simpara>The example below illustrates a Node status field. It is recommended that you use <link xl:href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties">typical status properties</link> in practice.</simpara>
</note>
<programlisting language="java" linenumbering="unnumbered">import java.util.ArrayList;
import java.util.List;

public class MemcachedStatus {

    // Add Status information here
    // Nodes are the names of the memcached pods
    private List&lt;String&gt; nodes;

    public List&lt;String&gt; getNodes() {
        if (nodes == null) {
            nodes = new ArrayList&lt;&gt;();
        }
        return nodes;
    }

    public void setNodes(List&lt;String&gt; nodes) {
        this.nodes = nodes;
    }
}</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>Memcached.java</literal> file to define the Schema for Memcached APIs that extends to both <literal>MemcachedSpec.java</literal> and <literal>MemcachedStatus.java</literal> files.</simpara>
<programlisting language="java" linenumbering="unnumbered">@Version("v1")
@Group("cache.example.com")
public class Memcached extends CustomResource&lt;MemcachedSpec, MemcachedStatus&gt; implements Namespaced {}</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-java-generate-crd_osdk-java-tutorial">
<title>Generating CRD manifests</title>
<simpara>After the API is defined with <literal>MemcachedSpec</literal> and <literal>MemcachedStatus</literal> files, you can generate CRD manifests.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command from the <literal>memcached-operator</literal> directory to generate the CRD:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mvn clean install</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify the contents of the CRD in the <literal>target/kubernetes/memcacheds.cache.example.com-v1.yml</literal> file as shown in the following example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat target/kubernetes/memcacheds.cache.example.com-v1.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># Generated by Fabric8 CRDGenerator, manual edits might get overwritten!
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: memcacheds.cache.example.com
spec:
  group: cache.example.com
  names:
    kind: Memcached
    plural: memcacheds
    singular: memcached
  scope: Namespaced
  versions:
  - name: v1
    schema:
      openAPIV3Schema:
        properties:
          spec:
            properties:
              size:
                type: integer
            type: object
          status:
            properties:
              nodes:
                items:
                  type: string
                type: array
            type: object
        type: object
    served: true
    storage: true
    subresources:
      status: {}</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-java-create-cr_osdk-java-tutorial">
<title>Creating a Custom Resource</title>
<simpara>After generating the CRD manifests, you can create the Custom Resource (CR).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a Memcached CR called <literal>memcached-sample.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cache.example.com/v1
kind: Memcached
metadata:
  name: memcached-sample
spec:
  # Add spec fields here
  size: 1</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-java-implement-controller_osdk-java-tutorial">
<title>Implementing the controller</title>
<simpara>After creating a new API and controller, you can implement the controller logic.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Append the following dependency to the <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;commons-collections&lt;/groupId&gt;
      &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;
      &lt;version&gt;3.2.2&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
</listitem>
<listitem>
<simpara>For this example, replace the generated controller file <literal>MemcachedReconciler.java</literal> with following example implementation:</simpara>
<example>
<title>Example <literal>MemcachedReconciler.java</literal></title>
<programlisting language="java" linenumbering="unnumbered">package com.example;

import io.fabric8.kubernetes.client.KubernetesClient;
import io.javaoperatorsdk.operator.api.reconciler.Context;
import io.javaoperatorsdk.operator.api.reconciler.Reconciler;
import io.javaoperatorsdk.operator.api.reconciler.UpdateControl;
import io.fabric8.kubernetes.api.model.ContainerBuilder;
import io.fabric8.kubernetes.api.model.ContainerPortBuilder;
import io.fabric8.kubernetes.api.model.LabelSelectorBuilder;
import io.fabric8.kubernetes.api.model.ObjectMetaBuilder;
import io.fabric8.kubernetes.api.model.OwnerReferenceBuilder;
import io.fabric8.kubernetes.api.model.Pod;
import io.fabric8.kubernetes.api.model.PodSpecBuilder;
import io.fabric8.kubernetes.api.model.PodTemplateSpecBuilder;
import io.fabric8.kubernetes.api.model.apps.Deployment;
import io.fabric8.kubernetes.api.model.apps.DeploymentBuilder;
import io.fabric8.kubernetes.api.model.apps.DeploymentSpecBuilder;
import org.apache.commons.collections.CollectionUtils;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class MemcachedReconciler implements Reconciler&lt;Memcached&gt; {
  private final KubernetesClient client;

  public MemcachedReconciler(KubernetesClient client) {
    this.client = client;
  }

  // TODO Fill in the rest of the reconciler

  @Override
  public UpdateControl&lt;Memcached&gt; reconcile(
      Memcached resource, Context context) {
      // TODO: fill in logic
      Deployment deployment = client.apps()
              .deployments()
              .inNamespace(resource.getMetadata().getNamespace())
              .withName(resource.getMetadata().getName())
              .get();

      if (deployment == null) {
          Deployment newDeployment = createMemcachedDeployment(resource);
          client.apps().deployments().create(newDeployment);
          return UpdateControl.noUpdate();
      }

      int currentReplicas = deployment.getSpec().getReplicas();
      int requiredReplicas = resource.getSpec().getSize();

      if (currentReplicas != requiredReplicas) {
          deployment.getSpec().setReplicas(requiredReplicas);
          client.apps().deployments().createOrReplace(deployment);
          return UpdateControl.noUpdate();
      }

      List&lt;Pod&gt; pods = client.pods()
          .inNamespace(resource.getMetadata().getNamespace())
          .withLabels(labelsForMemcached(resource))
          .list()
          .getItems();

      List&lt;String&gt; podNames =
          pods.stream().map(p -&gt; p.getMetadata().getName()).collect(Collectors.toList());


      if (resource.getStatus() == null
               || !CollectionUtils.isEqualCollection(podNames, resource.getStatus().getNodes())) {
           if (resource.getStatus() == null) resource.setStatus(new MemcachedStatus());
           resource.getStatus().setNodes(podNames);
           return UpdateControl.updateResource(resource);
      }

      return UpdateControl.noUpdate();
  }

  private Map&lt;String, String&gt; labelsForMemcached(Memcached m) {
    Map&lt;String, String&gt; labels = new HashMap&lt;&gt;();
    labels.put("app", "memcached");
    labels.put("memcached_cr", m.getMetadata().getName());
    return labels;
  }

  private Deployment createMemcachedDeployment(Memcached m) {
      Deployment deployment = new DeploymentBuilder()
          .withMetadata(
              new ObjectMetaBuilder()
                  .withName(m.getMetadata().getName())
                  .withNamespace(m.getMetadata().getNamespace())
                  .build())
          .withSpec(
              new DeploymentSpecBuilder()
                  .withReplicas(m.getSpec().getSize())
                  .withSelector(
                      new LabelSelectorBuilder().withMatchLabels(labelsForMemcached(m)).build())
                  .withTemplate(
                      new PodTemplateSpecBuilder()
                          .withMetadata(
                              new ObjectMetaBuilder().withLabels(labelsForMemcached(m)).build())
                          .withSpec(
                              new PodSpecBuilder()
                                  .withContainers(
                                      new ContainerBuilder()
                                          .withImage("memcached:1.4.36-alpine")
                                          .withName("memcached")
                                          .withCommand("memcached", "-m=64", "-o", "modern", "-v")
                                          .withPorts(
                                              new ContainerPortBuilder()
                                                  .withContainerPort(11211)
                                                  .withName("memcached")
                                                  .build())
                                          .build())
                                  .build())
                          .build())
                  .build())
          .build();
    deployment.addOwnerReference(m);
    return deployment;
  }
}</programlisting>
</example>
<simpara>The example controller runs the following reconciliation logic for each <literal>Memcached</literal> custom resource (CR):</simpara>
<itemizedlist>
<listitem>
<simpara>Creates a Memcached deployment if it does not exist.</simpara>
</listitem>
<listitem>
<simpara>Ensures that the deployment size matches the size specified by the <literal>Memcached</literal> CR spec.</simpara>
</listitem>
<listitem>
<simpara>Updates the <literal>Memcached</literal> CR status with the names of the <literal>memcached</literal> pods.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>The next subsections explain how the controller in the example implementation watches resources and how the reconcile loop is triggered. You can skip these subsections to go directly to <link xl:href="../../../operators/operator_sdk/java/osdk-java-tutorial.xml#osdk-run-operator_osdk-java-tutorial">Running the Operator</link>.</simpara>
<section xml:id="osdk-java-controller-reconcile-loop_osdk-java-tutorial">
<title>Reconcile loop</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Every controller has a reconciler object with a <literal>Reconcile()</literal> method that implements the reconcile loop. The reconcile loop is passed the <literal>Deployment</literal> argument, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">        Deployment deployment = client.apps()
                .deployments()
                .inNamespace(resource.getMetadata().getNamespace())
                .withName(resource.getMetadata().getName())
                .get();</programlisting>
</listitem>
<listitem>
<simpara>As shown in the following example, if the <literal>Deployment</literal> is <literal>null</literal>, the deployment needs to be created. After you create the <literal>Deployment</literal>, you can determine if reconciliation is necessary. If there is no need of reconciliation, return the value of <literal>UpdateControl.noUpdate()</literal>, otherwise, return the value of `UpdateControl.updateStatus(resource):</simpara>
<programlisting language="java" linenumbering="unnumbered">        if (deployment == null) {
            Deployment newDeployment = createMemcachedDeployment(resource);
            client.apps().deployments().create(newDeployment);
            return UpdateControl.noUpdate();
        }</programlisting>
</listitem>
<listitem>
<simpara>After getting the <literal>Deployment</literal>, get the current and required replicas, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">        int currentReplicas = deployment.getSpec().getReplicas();
        int requiredReplicas = resource.getSpec().getSize();</programlisting>
</listitem>
<listitem>
<simpara>If <literal>currentReplicas</literal> does not match the <literal>requiredReplicas</literal>, you must update the <literal>Deployment</literal>, as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">        if (currentReplicas != requiredReplicas) {
            deployment.getSpec().setReplicas(requiredReplicas);
            client.apps().deployments().createOrReplace(deployment);
            return UpdateControl.noUpdate();
        }</programlisting>
</listitem>
<listitem>
<simpara>The following example shows how to obtain the list of pods and their names:</simpara>
<programlisting language="java" linenumbering="unnumbered">        List&lt;Pod&gt; pods = client.pods()
            .inNamespace(resource.getMetadata().getNamespace())
            .withLabels(labelsForMemcached(resource))
            .list()
            .getItems();

        List&lt;String&gt; podNames =
            pods.stream().map(p -&gt; p.getMetadata().getName()).collect(Collectors.toList());</programlisting>
</listitem>
<listitem>
<simpara>Check if resources were created and verify podnames with the Memcached resources. If a mismatch exists in either of these conditions, perform a reconciliation as shown in the following example:</simpara>
<programlisting language="java" linenumbering="unnumbered">        if (resource.getStatus() == null
                || !CollectionUtils.isEqualCollection(podNames, resource.getStatus().getNodes())) {
            if (resource.getStatus() == null) resource.setStatus(new MemcachedStatus());
            resource.getStatus().setNodes(podNames);
            return UpdateControl.updateResource(resource);
        }</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-java-controller-labels-memcached_osdk-java-tutorial">
<title>Defining <literal>labelsForMemcached</literal></title>
<simpara><literal>labelsForMemcached</literal> is a utility to return a map of the labels to attach to the resources:</simpara>
<programlisting language="java" linenumbering="unnumbered">    private Map&lt;String, String&gt; labelsForMemcached(Memcached m) {
        Map&lt;String, String&gt; labels = new HashMap&lt;&gt;();
        labels.put("app", "memcached");
        labels.put("memcached_cr", m.getMetadata().getName());
        return labels;
    }</programlisting>
</section>
<section xml:id="osdk-java-controller-memcached-deployment_osdk-java-tutorial">
<title>Define the <literal>createMemcachedDeployment</literal></title>
<simpara>The <literal>createMemcachedDeployment</literal> method uses the <link xl:href="https://fabric8.io/">fabric8</link> <literal>DeploymentBuilder</literal> class:</simpara>
<programlisting language="java" linenumbering="unnumbered">    private Deployment createMemcachedDeployment(Memcached m) {
        Deployment deployment = new DeploymentBuilder()
            .withMetadata(
                new ObjectMetaBuilder()
                    .withName(m.getMetadata().getName())
                    .withNamespace(m.getMetadata().getNamespace())
                    .build())
            .withSpec(
                new DeploymentSpecBuilder()
                    .withReplicas(m.getSpec().getSize())
                    .withSelector(
                        new LabelSelectorBuilder().withMatchLabels(labelsForMemcached(m)).build())
                    .withTemplate(
                        new PodTemplateSpecBuilder()
                            .withMetadata(
                                new ObjectMetaBuilder().withLabels(labelsForMemcached(m)).build())
                            .withSpec(
                                new PodSpecBuilder()
                                    .withContainers(
                                        new ContainerBuilder()
                                            .withImage("memcached:1.4.36-alpine")
                                            .withName("memcached")
                                            .withCommand("memcached", "-m=64", "-o", "modern", "-v")
                                            .withPorts(
                                                new ContainerPortBuilder()
                                                    .withContainerPort(11211)
                                                    .withName("memcached")
                                                    .build())
                                            .build())
                                    .build())
                            .build())
                    .build())
            .build();
      deployment.addOwnerReference(m);
      return deployment;
    }</programlisting>
</section>
</section>
<section xml:id="osdk-run-operator_osdk-java-tutorial">
<title>Running the Operator</title>
<simpara>There are three ways you can use the Operator SDK CLI to build and run your Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>Run locally outside the cluster as a Go program.</simpara>
</listitem>
<listitem>
<simpara>Run as a deployment on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Bundle your Operator and use Operator Lifecycle Manager (OLM) to deploy on the cluster.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-run-locally_osdk-java-tutorial">
<title>Running locally outside the cluster</title>
<simpara>You can run your Operator project as a Go program outside of the cluster. This is useful for development purposes to speed up deployment and testing.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command to compile the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mvn clean install</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  11.193 s
[INFO] Finished at: 2021-05-26T12:16:54-04:00
[INFO] ------------------------------------------------------------------------</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to install the CRD to the default namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f target/kubernetes/memcacheds.cache.example.com-v1.yml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">customresourcedefinition.apiextensions.k8s.io/memcacheds.cache.example.com created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a file called <literal>rbac.yaml</literal> as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: memcached-operator-admin
subjects:
- kind: ServiceAccount
  name: memcached-quarkus-operator-operator
  namespace: &lt;operator_namespace&gt;
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: ""</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to grant <literal>cluster-admin</literal> privileges to the <literal>memcached-quarkus-operator-operator</literal> by applying the <literal>rbac.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f rbac.yaml</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command to run the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ java -jar target/quarkus-app/quarkus-run.jar</programlisting>
<note>
<simpara>The <literal>java</literal> command will run the Operator and remain running until you end the process. You will need another terminal to complete the rest of these commands.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply the <literal>memcached-sample.yaml</literal> file with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ kubectl apply -f memcached-sample.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">memcached.cache.example.com/memcached-sample created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Run the following command to confirm that the pod has started:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       READY   STATUS    RESTARTS   AGE
pod/memcached-sample-6c765df685-mfqnz                      1/1     Running   0          18s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-run-deployment_osdk-java-tutorial">
<title>Running as a deployment on the cluster</title>
<simpara>You can run your Operator project as a deployment on your cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands to build and push the Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The name and tag of the image, for example <literal>IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</literal>, in both the commands can also be set in your Makefile. Modify the <literal>IMG ?= controller:latest</literal> value to set your default image name.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Run the following command to install the CRD to the default namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f target/kubernetes/memcacheds.cache.example.com-v1.yml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">customresourcedefinition.apiextensions.k8s.io/memcacheds.cache.example.com created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a file called <literal>rbac.yaml</literal> as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: memcached-operator-admin
subjects:
- kind: ServiceAccount
  name: memcached-quarkus-operator-operator
  namespace: &lt;operator_namespace&gt;
roleRef:
  kind: ClusterRole
  name: cluster-admin
  apiGroup: ""</programlisting>
<important>
<simpara>The <literal>rbac.yaml</literal> file will be applied at a later step.</simpara>
</important>
</listitem>
<listitem>
<simpara>Run the following command to deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to grant <literal>cluster-admin</literal> privileges to the <literal>memcached-quarkus-operator-operator</literal> by applying the <literal>rbac.yaml</literal> file created in a previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f rbac.yaml</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to verify that the Operator is running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n default</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                      READY   UP-TO-DATE   AVAILABLE   AGE
pod/memcached-quarkus-operator-operator-7db86ccf58-k4mlm   0/1       Running   0           18s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following command to apply the <literal>memcached-sample.yaml</literal> and create the <literal>memcached-sample</literal> pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f memcached-sample.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">memcached.cache.example.com/memcached-sample created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Run the following command to confirm the pods have started:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                       READY   STATUS    RESTARTS   AGE
pod/memcached-quarkus-operator-operator-7b766f4896-kxnzt   1/1     Running   1          79s
pod/memcached-sample-6c765df685-mfqnz                      1/1     Running   0          18s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-bundle-deploy-olm_osdk-java-tutorial">
<title>Bundling an Operator and deploying with Operator Lifecycle Manager</title>
<section xml:id="osdk-bundle-operator_osdk-java-tutorial">
<title>Bundling an Operator</title>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) v{product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initialized by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands in your Operator project directory to build and push your Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create your Operator bundle manifest by running the <literal>make bundle</literal> command, which invokes several commands, including the Operator SDK <literal>generate bundle</literal> and <literal>bundle validate</literal> subcommands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>Bundle manifests for an Operator describe how to display, create, and manage an application. The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These files are then automatically validated by using <literal>operator-sdk bundle validate</literal> to ensure the on-disk bundle representation is correct.</simpara>
</listitem>
<listitem>
<simpara>Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the bundle image. Set <literal>BUNDLE_IMG</literal> with the details for the registry, user namespace, and image tag where you intend to push the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build BUNDLE_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker push &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-deploy-olm_osdk-java-tutorial">
<title>Deploying an Operator with Operator Lifecycle Manager</title>
<simpara>Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on {product-title} and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (<literal>oc</literal>) for all Operator lifecycle management functions without any additional tools.</simpara>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to run the Operator on the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle \<co xml:id="CO69-1"/>
    -n &lt;namespace&gt; \<co xml:id="CO69-2"/>
    &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; <co xml:id="CO69-3"/></programlisting>
<calloutlist>
<callout arearefs="CO69-1">
<para>The <literal>run bundle</literal> command creates a valid file-based catalog and installs the Operator bundle on your cluster using OLM.</para>
</callout>
<callout arearefs="CO69-2">
<para>Optional: By default, the command installs the Operator in the currently active project in your <literal>~/.kube/config</literal> file. You can add the <literal>-n</literal> flag to set a different namespace scope for the installation.</para>
</callout>
<callout arearefs="CO69-3">
<para>If you do not specify an image, the command uses <literal>quay.io/operator-framework/opm:latest</literal> as the default index image. If you specify an image, the command uses the bundle image itself as the index image.</para>
</callout>
</calloutlist>
<important>
<simpara>As of {product-title} 4.11, the <literal>run bundle</literal> command supports the file-based catalog format for Operator catalogs by default. The deprecated SQLite database format for Operator catalogs continues to be supported; however, it will be removed in a future release. It is recommended that Operator authors migrate their workflows to the file-based catalog format.</simpara>
</important>
<simpara>This command performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an index image referencing your bundle image. The index image is opaque and ephemeral, but accurately reflects how a bundle would be added to a catalog in production.</simpara>
</listitem>
<listitem>
<simpara>Create a catalog source that points to your new index image, which enables OperatorHub to discover your Operator.</simpara>
</listitem>
<listitem>
<simpara>Deploy your Operator to your cluster by creating an <literal>OperatorGroup</literal>, <literal>Subscription</literal>, <literal>InstallPlan</literal>, and all other required resources, including RBAC.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="additional-resources_osdk-java-tutorial" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../../operators/operator_sdk/java/osdk-java-project-layout.xml#osdk-java-project-layout">Project layout for Java-based Operators</link> to learn about the directory structures created by the Operator SDK.</simpara>
</listitem>
<listitem>
<simpara>If a <link xl:href="../../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">cluster-wide egress proxy is configured</link>, cluster administrators can <link xl:href="../../../operators/admin/olm-configuring-proxy-support.xml#olm-configuring-proxy-support">override the proxy settings or inject a custom CA certificate</link> for specific Operators running on Operator Lifecycle Manager (OLM).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-java-project-layout">
<title>Project layout for Java-based Operators</title>
<important>
<simpara>Java-based Operator SDK is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>

<simpara>The <literal>operator-sdk</literal> CLI can generate, or <emphasis>scaffold</emphasis>, a number of packages and files for each Operator project.</simpara>
<section xml:id="osdk-java-project-layout_osdk-java-project-layout">
<title>Java-based project layout</title>
<simpara>Java-based Operator projects generated by the <literal>operator-sdk init</literal> command contain the following files and directories:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">File or directory</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>pom.xml</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File that contains the dependencies required to run the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;domain&gt;/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Directory that contains the files that represent the API. If the domain is <literal>example.com</literal>, this folder is called <literal>example/</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MemcachedReconciler.java</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Java file that defines controller implementations.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MemcachedSpec.java</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Java file that defines the desired state of the Memcached CR.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MemcachedStatus.java</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Java file that defines the observed state of the Memcached CR.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Memcached.java</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Java file that defines the Schema for Memcached APIs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>target/kubernetes/</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Directory that contains the CRD yaml files.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="osdk-java-updating-projects">
<title>Updating projects for newer Operator SDK versions</title>

<simpara>{product-title} {product-version} supports Operator SDK 1.31.0. If you already have the 1.28.0 CLI installed on your workstation, you can update the CLI to 1.31.0 by <link xl:href="../../../operators/operator_sdk/osdk-installing-cli.xml#osdk-installing-cli">installing the latest version</link>.</simpara>
<simpara>However, to ensure your existing Operator projects maintain compatibility with Operator SDK 1.31.0, update steps are required for the associated breaking changes introduced since 1.28.0. You must perform the update steps manually in any of your Operator projects that were previously created or maintained with 1.28.0.</simpara>
<section xml:id="osdk-upgrading-projects_osdk-java-updating-projects">
<title>Updating Java-based Operator projects for Operator SDK 1.31.0</title>
<simpara>The following procedure updates an existing Java-based Operator project for compatibility with 1.31.0.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK 1.31.0 installed</simpara>
</listitem>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.28.0</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit your Operator project&#8217;s makefile to update the Operator SDK version to 1.31.0, as shown in the following example:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># Set the Operator SDK version to use. By default, what is installed on the system is used.
# This is useful for CI or a project to utilize a specific version of the operator-sdk toolkit.
OPERATOR_SDK_VERSION ?= v1.31.0 <co xml:id="CO70-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO70-1">
<para>Change the version from <literal>1.28.0</literal> to <literal>1.31.0</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_osdk-java-upgrading-projects" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/operator_sdk/osdk-pkgman-to-bundle.xml#osdk-pkgman-to-bundle">Migrating package manifest projects to bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-generating-csvs">
<title>Defining cluster service versions (CSVs)</title>

<simpara>A <emphasis>cluster service version</emphasis> (CSV), defined by a <literal>ClusterServiceVersion</literal> object, is a YAML manifest created from Operator metadata that assists Operator Lifecycle Manager (OLM) in running the Operator in a cluster. It is the metadata that accompanies an Operator container image, used to populate user interfaces with information such as its logo, description, and version. It is also a source of technical information that is required to run the Operator, like the RBAC rules it requires and which custom resources (CRs) it manages or depends on.</simpara>
<simpara>The Operator SDK includes the CSV generator to generate a CSV for the current Operator project, customized using information contained in YAML manifests and Operator source files.</simpara>
<simpara>A CSV-generating command removes the responsibility of Operator authors having in-depth OLM knowledge in order for their Operator to interact with OLM or publish metadata to the Catalog Registry. Further, because the CSV spec will likely change over time as new Kubernetes and OLM features are implemented, the Operator SDK is equipped to easily extend its update system to handle new CSV features going forward.</simpara>
<section xml:id="osdk-how-csv-gen-works_osdk-generating-csvs">
<title>How CSV generation works</title>
<simpara>Operator bundle manifests, which include cluster service versions (CSVs), describe how to display, create, and manage an application with Operator Lifecycle Manager (OLM). The CSV generator in the Operator SDK, called by the <literal>generate bundle</literal> subcommand, is the first step towards publishing your Operator to a catalog and deploying it with OLM. The subcommand requires certain input manifests to construct a CSV manifest; all inputs are read when the command is invoked, along with a CSV base, to idempotently generate or regenerate a CSV.</simpara>
<simpara>Typically, the <literal>generate kustomize manifests</literal> subcommand would be run first to generate the input <link xl:href="https://kustomize.io/">Kustomize</link> bases that are consumed by the <literal>generate bundle</literal> subcommand. However, the Operator SDK provides the <literal>make bundle</literal> command, which automates several tasks, including running the following subcommands in order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>generate kustomize manifests</literal></simpara>
</listitem>
<listitem>
<simpara><literal>generate bundle</literal></simpara>
</listitem>
<listitem>
<simpara><literal>bundle validate</literal></simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../operators/operator_sdk/osdk-working-bundle-images.xml#osdk-bundle-operator_osdk-working-bundle-images">Bundling an Operator</link> for a full procedure that includes generating a bundle and CSV.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-csv-bundle-files_osdk-generating-csvs">
<title>Generated files and resources</title>
<simpara>The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> (CSV) object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The following resources are typically included in a CSV:</simpara>
<variablelist>
<varlistentry>
<term>Role</term>
<listitem>
<simpara>Defines Operator permissions within a namespace.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ClusterRole</term>
<listitem>
<simpara>Defines cluster-wide Operator permissions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Deployment</term>
<listitem>
<simpara>Defines how an Operand of an Operator is run in pods.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>CustomResourceDefinition (CRD)</term>
<listitem>
<simpara>Defines custom resources that your Operator reconciles.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Custom resource examples</term>
<listitem>
<simpara>Examples of resources adhering to the spec of a particular CRD.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="osdk-csv-ver_osdk-generating-csvs">
<title>Version management</title>
<simpara>The <literal>--version</literal> flag for the <literal>generate bundle</literal> subcommand supplies a semantic version for your bundle when creating one for the first time and when upgrading an existing one.</simpara>
<simpara>By setting the <literal>VERSION</literal> variable in your <literal>Makefile</literal>, the <literal>--version</literal> flag is automatically invoked using that value when the <literal>generate bundle</literal> subcommand is run by the <literal>make bundle</literal> command. The CSV version is the same as the Operator version, and a new CSV is generated when upgrading Operator versions.</simpara>
</section>
</section>
<section xml:id="osdk-manually-defined-csv-fields_osdk-generating-csvs">
<title>Manually-defined CSV fields</title>
<simpara>Many CSV fields cannot be populated using generated, generic manifests that are not specific to Operator SDK. These fields are mostly human-written metadata about the Operator and various custom resource definitions (CRDs).</simpara>
<simpara>Operator authors must directly modify their cluster service version (CSV) YAML file, adding personalized data to the following required fields. The Operator SDK gives a warning during CSV generation when a lack of data in any of the required fields is detected.</simpara>
<simpara>The following tables detail which manually-defined CSV fields are required and which are optional.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Required CSV fields</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A unique name for this CSV. Operator version should be included in the name to ensure uniqueness, for example <literal>app-operator.v0.1.1</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>metadata.capabilities</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The capability level according to the Operator maturity model. Options include <literal>Basic Install</literal>, <literal>Seamless Upgrades</literal>, <literal>Full Lifecycle</literal>, <literal>Deep Insights</literal>, and <literal>Auto Pilot</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.displayName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A public name to identify the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A short description of the functionality of the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.keywords</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Keywords describing the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.maintainers</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Human or organizational entities maintaining the Operator, with a <literal>name</literal> and <literal>email</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.provider</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The provider of the Operator (usually an organization), with a <literal>name</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.labels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Key-value pairs to be used by Operator internals.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Semantic version of the Operator, for example <literal>0.1.1</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.customresourcedefinitions</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any CRDs the Operator uses. This field is populated automatically by the Operator SDK if any CRD YAML files are present in <literal>deploy/</literal>. However, several fields not in the CRD manifest spec require user input:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>description</literal>: description of the CRD.</simpara>
</listitem>
<listitem>
<simpara><literal>resources</literal>: any Kubernetes resources leveraged by the CRD, for example <literal>Pod</literal> and <literal>StatefulSet</literal> objects.</simpara>
</listitem>
<listitem>
<simpara><literal>specDescriptors</literal>: UI hints for inputs and outputs of the Operator.</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Optional CSV fields</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>spec.replaces</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the CSV being replaced by this CSV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.links</literal></simpara></entry>
<entry align="left" valign="top"><simpara>URLs (for example, websites and documentation) pertaining to the Operator or application being managed, each with a <literal>name</literal> and <literal>url</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.selector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Selectors by which the Operator can pair resources in a cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.icon</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A base64-encoded icon unique to the Operator, set in a <literal>base64data</literal> field with a <literal>mediatype</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>spec.maturity</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The level of maturity the software has achieved at this version. Options include <literal>planning</literal>, <literal>pre-alpha</literal>, <literal>alpha</literal>, <literal>beta</literal>, <literal>stable</literal>, <literal>mature</literal>, <literal>inactive</literal>, and <literal>deprecated</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Further details on what data each field above should hold are found in the <link xl:href="https://github.com/operator-framework/operator-lifecycle-manager/blob/master/doc/design/building-your-csv.md">CSV spec</link>.</simpara>
<note>
<simpara>Several YAML fields currently requiring user intervention can potentially be parsed from Operator code.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-what-operators-are.xml#olm-maturity-model_olm-what-operators-are">Operator maturity model</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-csv-manual-annotations_osdk-generating-csvs">
<title>Operator metadata annotations</title>
<simpara>Operator developers can set certain annotations in the metadata of a cluster service version (CSV) to enable features or highlight capabilities in user interfaces (UIs), such as OperatorHub or the <link xl:href="https://catalog.redhat.com/software/search?deployed_as=Operator">Red Hat Ecosystem Catalog</link>. Operator metadata annotations are manually defined by setting the <literal>metadata.annotations</literal> field in the CSV YAML file.</simpara>
<section xml:id="osdk-csv-annotations-infra_osdk-generating-csvs">
<title>Infrastructure features annotations</title>
<simpara>Annotations in the <literal>features.operators.openshift.io</literal> group detail the infrastructure features that an Operator might support, specified by setting a <literal>"true"</literal> or <literal>"false"</literal> value. Users can view and filter by these features when discovering Operators through OperatorHub in the web console or on the <link xl:href="https://catalog.redhat.com/software/search?deployed_as=Operator">Red Hat Ecosystem Catalog</link>. These annotations are supported in {product-title} 4.10 and later.</simpara>
<important>
<simpara>The <literal>features.operators.openshift.io</literal> infrastructure feature annotations deprecate the <literal>operators.openshift.io/infrastructure-features</literal> annotations used in earlier versions of {product-title}. See "Deprecated infrastructure feature annotations" for more information.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Infrastructure features annotations</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="41.6666*"/>
<colspec colname="col_3" colwidth="25.0001*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Valid values<superscript>[1]</superscript></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/disconnected</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator leverages the <literal>spec.relatedImages</literal> CSV field and can run without an internet connection by referring to any related image by its digest.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/fips-compliant</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator accepts the FIPS-140 configuration of the underlying platform and works on nodes that are booted into FIPS mode. In this mode, the Operator and any workloads it manages (operands) are solely calling the Red Hat Enterprise Linux (RHEL) cryptographic library submitted for FIPS-140 validation.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/proxy-aware</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator supports running on a cluster behind a proxy by accepting the standard <literal>HTTP_PROXY</literal> and <literal>HTTPS_PROXY</literal> proxy environment variables. If applicable, the Operator passes this information to the workload it manages (operands).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/tls-profiles</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator implements well-known tunables to modify the TLS cipher suite used by the Operator and, if applicable, any of the workloads it manages (operands).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/token-auth-aws</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator supports configuration for tokenzied authentication with AWS APIs via AWS Secure Token Service (STS) by using the Cloud Credential Operator (CCO).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/token-auth-azure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator supports configuration for tokenzied authentication with Azure APIs via Azure Managed Identity by using the Cloud Credential Operator (CCO).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/token-auth-gcp</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator supports configuration for tokenzied authentication with Google Cloud APIs via GCP Workload Identity Foundation (WIF) by using the Cloud Credential Operator (CCO).</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/cnf</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator provides a Cloud-Native Network Function (CNF) Kubernetes plugin.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/cni</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator provides a Container Network Interface (CNI) Kubernetes plugin.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>features.operators.openshift.io/csi</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify whether an Operator provides a Container Storage Interface (CSI) Kubernetes plugin.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>"true"</literal> or <literal>"false"</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Valid values are shown intentionally with double quotes, because Kubernetes annotations must be strings.</simpara>
</listitem>
</orderedlist>
</para>
<formalpara>
<title>Example CSV with infrastructure feature annotations</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  annotations:
    features.operators.openshift.io/disconnected: "true"
    features.operators.openshift.io/fips-compliant: "false"
    features.operators.openshift.io/proxy-aware: "false"
    features.operators.openshift.io/tls-profiles: "false"
    features.operators.openshift.io/token-auth-aws: "false"
    features.operators.openshift.io/token-auth-azure: "false"
    features.operators.openshift.io/token-auth-gcp: "false"</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#olm-enabling-operator-for-restricted-network_osdk-generating-csvs">Enabling your Operator for restricted network environments</link> (disconnected mode)</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing-fips.xml#installing-fips">Support for FIPS cryptography</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-csv-manual-annotations-deprecated_osdk-generating-csvs">
<title>Deprecated infrastructure feature annotations</title>
<simpara>Starting in {product-title} 4.14, the <literal>operators.openshift.io/infrastructure-features</literal> group of annotations are deprecated by the group of annotations with the <literal>features.operators.openshift.io</literal> namespace. While you are encouraged to use the newer annotations, both groups are currently accepted when used in parallel.</simpara>
<simpara>These annotations detail the infrastructure features that an Operator supports. Users can view and filter by these features when discovering Operators through OperatorHub in the web console or on the <link xl:href="https://catalog.redhat.com/software/search?deployed_as=Operator">Red Hat Ecosystem Catalog</link>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Deprecated <literal>operators.openshift.io/infrastructure-features</literal> annotations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Valid annotation values</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>disconnected</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator supports being mirrored into disconnected catalogs, including all dependencies, and does not require internet access. All related images required for mirroring are listed by the Operator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cnf</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator provides a Cloud-native Network Functions (CNF) Kubernetes plugin.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cni</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator provides a Container Network Interface (CNI) Kubernetes plugin.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>csi</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator provides a Container Storage Interface (CSI) Kubernetes plugin.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>fips</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator accepts the FIPS mode of the underlying platform and works on nodes that are booted into FIPS mode.</simpara>
<important>
<simpara>When running Red Hat Enterprise Linux (RHEL) or Red Hat Enterprise Linux CoreOS (RHCOS) booted in FIPS mode, {product-title} core components use the RHEL cryptographic libraries that have been submitted to NIST for FIPS 140-2/140-3 Validation on only the x86_64, ppc64le, and s390x architectures.</simpara>
</important></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>proxy-aware</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operator supports running on a cluster behind a proxy. Operator accepts the standard proxy environment variables  <literal>HTTP_PROXY</literal> and <literal>HTTPS_PROXY</literal>, which Operator Lifecycle Manager (OLM) provides to the Operator automatically when the cluster is configured to use a proxy. Required environment variables are passed down to Operands for managed workloads.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example CSV with <literal>disconnected</literal> and <literal>proxy-aware</literal> support</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  annotations:
    operators.openshift.io/infrastructure-features: '["disconnected", "proxy-aware"]'</programlisting>
</para>
</formalpara>
</section>
<section xml:id="osdk-csv-annotations-other_osdk-generating-csvs">
<title>Other optional annotations</title>
<simpara>The following Operator annotations are optional.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Other optional annotations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Annotation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>alm-examples</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provide custom resource definition (CRD) templates with a minimum set of configuration. Compatible UIs pre-fill this template for users to further customize.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operatorframework.io/initialization-resource</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify a single required custom resource by adding <literal>operatorframework.io/initialization-resource</literal> annotation to the cluster service version (CSV) during Operator installation. The user is then prompted to create the custom resource through a template provided in the CSV.  Must include a template that contains a complete YAML definition.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operatorframework.io/suggested-namespace</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a suggested namespace where the Operator should be deployed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operatorframework.io/suggested-namespace-template</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a manifest for a <literal>Namespace</literal> object with the default node selector for the namespace specified.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operators.openshift.io/valid-subscription</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Free-form array for listing any specific subscriptions that are required to use the Operator. For example, <literal>'["3Scale Commercial License", "Red Hat Managed Integration"]'</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>operators.operatorframework.io/internal-objects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Hides CRDs in the UI that are not meant for user manipulation.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example CSV with an {product-title} license requirement</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  annotations:
    operators.openshift.io/valid-subscription: '["OpenShift Container Platform"]'</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example CSV with a 3scale license requirement</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  annotations:
    operators.openshift.io/valid-subscription: '["3Scale Commercial License", "Red Hat Managed Integration"]'</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-crds-templates_osdk-generating-csvs">CRD templates</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-init-resource_osdk-generating-csvs">Initializing required custom resources</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-suggested-namespace_osdk-generating-csvs">Setting a suggested namespace</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-suggested-namespace-default-node_osdk-generating-csvs">Setting a suggested namespace with default node selector</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#osdk-hiding-internal-objects_osdk-generating-csvs">Hiding internal objects</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-enabling-operator-for-restricted-network_osdk-generating-csvs">
<title>Enabling your Operator for restricted network environments</title>
<simpara>As an Operator author, your Operator must meet additional requirements to run properly in a restricted network, or disconnected, environment.</simpara>
<itemizedlist>
<title>Operator requirements for supporting disconnected mode</title>
<listitem>
<simpara>Replace hard-coded image references with environment variables.</simpara>
</listitem>
<listitem>
<simpara>In the cluster service version (CSV) of your Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>List any <emphasis>related images</emphasis>, or other container images that your Operator might require to perform their functions.</simpara>
</listitem>
<listitem>
<simpara>Reference all specified images by a digest (SHA) and not by a tag.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>All dependencies of your Operator must also support running in a disconnected mode.</simpara>
</listitem>
<listitem>
<simpara>Your Operator must not require any off-cluster resources.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project with a CSV. The following procedure uses the Memcached Operator as an example for Go-, Ansible-, and Helm-based projects.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set an environment variable for the additional image references used by the Operator in the <literal>config/manager/manager.yaml</literal> file:</simpara>
<example>
<title>Example <literal>config/manager/manager.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
  ...
    spec:
      ...
      containers:
      - command:
        - /manager
        ...
        env:
        - name: &lt;related_image_environment_variable&gt; <co xml:id="CO71-1"/>
          value: "&lt;related_image_reference_with_tag&gt;" <co xml:id="CO71-2"/></programlisting>
<calloutlist>
<callout arearefs="CO71-1">
<para>Define the environment variable, such as <literal>RELATED_IMAGE_MEMCACHED</literal>.</para>
</callout>
<callout arearefs="CO71-2">
<para>Set the related image reference and tag, such as <literal>docker.io/memcached:1.4.36-alpine</literal>.</para>
</callout>
</calloutlist>
</example>
</listitem>
<listitem>
<simpara>Replace hard-coded image references with environment variables in the relevant file for your Operator project type:</simpara>
<itemizedlist>
<listitem>
<simpara>For Go-based Operator projects, add the environment variable to the <literal>controllers/memcached_controller.go</literal> file as shown in the following example:</simpara>
<example>
<title>Example <literal>controllers/memcached_controller.go</literal> file</title>
<programlisting language="diff" linenumbering="unnumbered">  // deploymentForMemcached returns a memcached Deployment object

...

	Spec: corev1.PodSpec{
        	Containers: []corev1.Container{{
-			Image:   "memcached:1.4.36-alpine", <co xml:id="CO72-1"/>
+			Image:   os.Getenv("&lt;related_image_environment_variable&gt;"), <co xml:id="CO72-2"/>
			Name:    "memcached",
			Command: []string{"memcached", "-m=64", "-o", "modern", "-v"},
			Ports: []corev1.ContainerPort{{

...</programlisting>
<calloutlist>
<callout arearefs="CO72-1">
<para>Delete the image reference and tag.</para>
</callout>
<callout arearefs="CO72-2">
<para>Use the <literal>os.Getenv</literal> function to call the <literal>&lt;related_image_environment_variable&gt;</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>os.Getenv</literal> function returns an empty string if a variable is not set. Set the <literal>&lt;related_image_environment_variable&gt;</literal> before changing the file.</simpara>
</note>
</example>
</listitem>
<listitem>
<simpara>For Ansible-based Operator projects, add the environment variable to the <literal>roles/memcached/tasks/main.yml</literal> file as shown in the following example:</simpara>
<example>
<title>Example <literal>roles/memcached/tasks/main.yml</literal> file</title>
<programlisting language="diff" linenumbering="unnumbered">spec:
  containers:
  - name: memcached
    command:
    - memcached
    - -m=64
    - -o
    - modern
    - -v
-   image: "docker.io/memcached:1.4.36-alpine" <co xml:id="CO73-1"/>
+   image: "{{ lookup('env', '&lt;related_image_environment_variable&gt;') }}" <co xml:id="CO73-2"/>
    ports:
      - containerPort: 11211

...</programlisting>
<calloutlist>
<callout arearefs="CO73-1">
<para>Delete the image reference and tag.</para>
</callout>
<callout arearefs="CO73-2">
<para>Use the <literal>lookup</literal> function to call the <literal>&lt;related_image_environment_variable&gt;</literal>.</para>
</callout>
</calloutlist>
</example>
</listitem>
<listitem>
<simpara>For Helm-based Operator projects, add the <literal>overrideValues</literal> field to the <literal>watches.yaml</literal> file as shown in the following example:</simpara>
<example>
<title>Example <literal>watches.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">...
- group: demo.example.com
  version: v1alpha1
  kind: Memcached
  chart: helm-charts/memcached
  overrideValues: <co xml:id="CO74-1"/>
    relatedImage: ${&lt;related_image_environment_variable&gt;} <co xml:id="CO74-2"/></programlisting>
<calloutlist>
<callout arearefs="CO74-1">
<para>Add the <literal>overrideValues</literal> field.</para>
</callout>
<callout arearefs="CO74-2">
<para>Define the <literal>overrideValues</literal> field by using the <literal>&lt;related_image_environment_variable&gt;</literal>, such as <literal>RELATED_IMAGE_MEMCACHED</literal>.</para>
</callout>
</calloutlist>
</example>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Add the value of the <literal>overrideValues</literal> field to the <literal>helm-charts/memchached/values.yaml</literal> file as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>helm-charts/memchached/values.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
relatedImage: ""</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit the chart template in the <literal>helm-charts/memcached/templates/deployment.yaml</literal> file as shown in the following example:</simpara>
<example>
<title>Example <literal>helm-charts/memcached/templates/deployment.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">containers:
  - name: {{ .Chart.Name }}
    securityContext:
      - toYaml {{ .Values.securityContext | nindent 12 }}
    image: "{{ .Values.image.pullPolicy }}
    env: <co xml:id="CO75-1"/>
      - name: related_image <co xml:id="CO75-2"/>
        value: "{{ .Values.relatedImage }}" <co xml:id="CO75-3"/></programlisting>
<calloutlist>
<callout arearefs="CO75-1">
<para>Add the <literal>env</literal> field.</para>
</callout>
<callout arearefs="CO75-2">
<para>Name the environment variable.</para>
</callout>
<callout arearefs="CO75-3">
<para>Define the value of the environment variable.</para>
</callout>
</calloutlist>
</example>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Add the <literal>BUNDLE_GEN_FLAGS</literal> variable definition to your <literal>Makefile</literal> with the following changes:</simpara>
<formalpara>
<title>Example <literal>Makefile</literal></title>
<para>
<programlisting language="diff" linenumbering="unnumbered">   BUNDLE_GEN_FLAGS ?= -q --overwrite --version $(VERSION) $(BUNDLE_METADATA_OPTS)

   # USE_IMAGE_DIGESTS defines if images are resolved via tags or digests
   # You can enable this value if you would like to use SHA Based Digests
   # To enable set flag to true
   USE_IMAGE_DIGESTS ?= false
   ifeq ($(USE_IMAGE_DIGESTS), true)
         BUNDLE_GEN_FLAGS += --use-image-digests
   endif

...

-  $(KUSTOMIZE) build config/manifests | operator-sdk generate bundle -q --overwrite --version $(VERSION) $(BUNDLE_METADATA_OPTS) <co xml:id="CO76-1"/>
+  $(KUSTOMIZE) build config/manifests | operator-sdk generate bundle $(BUNDLE_GEN_FLAGS) <co xml:id="CO76-2"/>

...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO76-1">
<para>Delete this line in the <literal>Makefile</literal>.</para>
</callout>
<callout arearefs="CO76-2">
<para>Replace the line above with this line.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To update your Operator image to use a digest (SHA) and not a tag, run the <literal>make bundle</literal> command and set <literal>USE_IMAGE_DIGESTS</literal> to <literal>true</literal> :</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle USE_IMAGE_DIGESTS=true</programlisting>
</listitem>
<listitem>
<simpara>Add the <literal>disconnected</literal> annotation, which indicates that the Operator works in a disconnected environment:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">metadata:
  annotations:
    operators.openshift.io/infrastructure-features: '["disconnected"]'</programlisting>
<simpara>Operators can be filtered in OperatorHub by this infrastructure feature.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-enabling-operator-for-multi-arch_osdk-generating-csvs">
<title>Enabling your Operator for multiple architectures and operating systems</title>
<simpara>Operator Lifecycle Manager (OLM) assumes that all Operators run on Linux hosts. However, as an Operator author, you can specify whether your Operator supports managing workloads on other architectures, if worker nodes are available in the {product-title} cluster.</simpara>
<simpara>If your Operator supports variants other than AMD64 and Linux, you can add labels to the cluster service version (CSV) that provides the Operator to list the supported variants. Labels indicating supported architectures and operating systems are defined by the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">labels:
    operatorframework.io/arch.&lt;arch&gt;: supported <co xml:id="CO77-1"/>
    operatorframework.io/os.&lt;os&gt;: supported <co xml:id="CO77-2"/></programlisting>
<calloutlist>
<callout arearefs="CO77-1">
<para>Set <literal>&lt;arch&gt;</literal> to a supported string.</para>
</callout>
<callout arearefs="CO77-2">
<para>Set <literal>&lt;os&gt;</literal> to a supported string.</para>
</callout>
</calloutlist>
<note>
<simpara>Only the labels on the channel head of the default channel are considered for filtering package manifests by label. This means, for example, that providing an additional architecture for an Operator in the non-default channel is possible, but that architecture is not available for filtering in the <literal>PackageManifest</literal> API.</simpara>
</note>
<simpara>If a CSV does not include an <literal>os</literal> label, it is treated as if it has the following Linux support label by default:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">labels:
    operatorframework.io/os.linux: supported</programlisting>
<simpara>If a CSV does not include an <literal>arch</literal> label, it is treated as if it has the following AMD64 support label by default:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">labels:
    operatorframework.io/arch.amd64: supported</programlisting>
<simpara>If an Operator supports multiple node architectures or operating systems, you can add multiple labels, as well.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project with a CSV.</simpara>
</listitem>
<listitem>
<simpara>To support listing multiple architectures and operating systems, your Operator image referenced in the CSV must be a manifest list image.</simpara>
</listitem>
<listitem>
<simpara>For the Operator to work properly in restricted network, or disconnected, environments, the image referenced must also be specified using a digest (SHA) and not by a tag.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add a label in the <literal>metadata.labels</literal> of your CSV for each supported architecture and operating system that your Operator supports:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">labels:
  operatorframework.io/arch.s390x: supported
  operatorframework.io/os.zos: supported
  operatorframework.io/os.linux: supported <co xml:id="CO78-1"/>
  operatorframework.io/arch.amd64: supported <co xml:id="CO78-2"/></programlisting>
<calloutlist>
<callout arearefs="CO78-1 CO78-2">
<para>After you add a new architecture or operating system, you must also now include the default <literal>os.linux</literal> and <literal>arch.amd64</literal> variants explicitly.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See the <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2/#manifest-list">Image Manifest V 2, Schema 2</link> specification for more information on manifest lists.</simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-arch-os-support_osdk-generating-csvs">
<title>Architecture and operating system support for Operators</title>
<simpara>The following strings are supported in Operator Lifecycle Manager (OLM) on {product-title} when labeling or filtering Operators that support multiple architectures and operating systems:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Architectures supported on {product-title}</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">String</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AMD64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>amd64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Power&#174;</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ppc64le</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Z&#174;</simpara></entry>
<entry align="left" valign="top"><simpara><literal>s390x</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Operating systems supported on {product-title}</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Operating system</entry>
<entry align="left" valign="top">String</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Linux</simpara></entry>
<entry align="left" valign="top"><simpara><literal>linux</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>z/OS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>zos</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Different versions of {product-title} and other Kubernetes-based distributions
might support a different set of architectures and operating systems.</simpara>
</note>
</section>
</section>
<section xml:id="osdk-suggested-namespace_osdk-generating-csvs">
<title>Setting a suggested namespace</title>
<simpara>Some Operators must be deployed in a specific namespace, or with ancillary resources in specific namespaces, to work properly. If resolved from a subscription, Operator Lifecycle Manager (OLM) defaults the namespaced resources of an Operator to the namespace of its subscription.</simpara>
<simpara>As an Operator author, you can instead express a desired target namespace as part of your cluster service version (CSV) to maintain control over the final namespaces of the resources installed for their Operators. When adding the Operator to a cluster using OperatorHub, this enables the web console to autopopulate the suggested namespace for the
cluster administrator
during the installation process.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>In your CSV, set the <literal>operatorframework.io/suggested-namespace</literal> annotation to your suggested namespace:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">metadata:
  annotations:
    operatorframework.io/suggested-namespace: &lt;namespace&gt; <co xml:id="CO79-1"/></programlisting>
<calloutlist>
<callout arearefs="CO79-1">
<para>Set your suggested namespace.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-suggested-namespace-default-node_osdk-generating-csvs">
<title>Setting a suggested namespace with default node selector</title>
<simpara>Some Operators expect to run only on control plane nodes, which can be done by setting a <literal>nodeSelector</literal> in the <literal>Pod</literal> spec by the Operator itself.</simpara>
<simpara>To avoid getting duplicated and potentially conflicting cluster-wide default <literal>nodeSelector</literal>, you can set a default node selector on the namespace where the Operator runs. The default node selector will take precedence over the cluster default so the cluster default will not be applied to the pods in the Operators namespace.</simpara>
<simpara>When adding the Operator to a cluster using OperatorHub, the web console auto-populates the suggested namespace for the
cluster administrator
during the installation process. The suggested namespace is created using the namespace manifest in YAML which is included in the cluster service version (CSV).</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>In your CSV, set the <literal>operatorframework.io/suggested-namespace-template</literal> with a manifest for a <literal>Namespace</literal> object. The following sample is a manifest for an example <literal>Namespace</literal> with the namespace default node selector specified:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">metadata:
  annotations:
    operatorframework.io/suggested-namespace-template: <co xml:id="CO80-1"/>
      {
        "apiVersion": "v1",
        "kind": "Namespace",
        "metadata": {
          "name": "vertical-pod-autoscaler-suggested-template",
          "annotations": {
            "openshift.io/node-selector": ""
          }
        }
      }</programlisting>
<calloutlist>
<callout arearefs="CO80-1">
<para>Set your suggested namespace.</para>
</callout>
</calloutlist>
<note>
<simpara>If both <literal>suggested-namespace</literal> and <literal>suggested-namespace-template</literal> annotations are present in the CSV, <literal>suggested-namespace-template</literal> should take precedence.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-operatorconditions_osdk-generating-csvs">
<title>Enabling Operator conditions</title>
<simpara>Operator Lifecycle Manager (OLM) provides Operators with a channel to communicate complex states that influence OLM behavior while managing the Operator. By default, OLM creates an <literal>OperatorCondition</literal> custom resource definition (CRD) when it installs an Operator. Based on the conditions set in the <literal>OperatorCondition</literal> custom resource (CR), the behavior of OLM changes accordingly.</simpara>
<simpara>To support Operator conditions, an Operator must be able to read the <literal>OperatorCondition</literal> CR created by OLM and have the ability to complete the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Get the specific condition.</simpara>
</listitem>
<listitem>
<simpara>Set the status of a specific condition.</simpara>
</listitem>
</itemizedlist>
<simpara>This can be accomplished by using the <link xl:href="https://github.com/operator-framework/operator-lib/tree/v0.11.0"><literal>operator-lib</literal></link> library. An Operator author can provide a <link xl:href="https://github.com/kubernetes-sigs/controller-runtime/tree/master/pkg/client"><literal>controller-runtime</literal> client</link> in their Operator for the library to access the <literal>OperatorCondition</literal> CR owned by the Operator in the cluster.</simpara>
<simpara>The library provides a generic <literal>Conditions</literal> interface, which has the following methods to <literal>Get</literal> and <literal>Set</literal> a <literal>conditionType</literal> in the <literal>OperatorCondition</literal> CR:</simpara>
<variablelist>
<varlistentry>
<term><literal>Get</literal></term>
<listitem>
<simpara>To get the specific condition, the library uses the <literal>client.Get</literal> function from <literal>controller-runtime</literal>, which requires an <literal>ObjectKey</literal> of type <literal>types.NamespacedName</literal> present in <literal>conditionAccessor</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>Set</literal></term>
<listitem>
<simpara>To update the status of the specific condition, the library uses the <literal>client.Update</literal> function from <literal>controller-runtime</literal>. An error occurs if the <literal>conditionType</literal> is not present in the CRD.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The Operator is allowed to modify only the <literal>status</literal> subresource of the CR. Operators can either delete or update the <literal>status.conditions</literal> array to include the condition. For more details on the format and description of the fields present in the conditions, see the upstream <link xl:href="https://godoc.org/k8s.io/apimachinery/pkg/apis/meta/v1#Condition">Condition GoDocs</link>.</simpara>
<note>
<simpara>Operator SDK 1.31.0 supports <literal>operator-lib</literal> v0.11.0.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project generated using the Operator SDK.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To enable Operator conditions in your Operator project:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <literal>go.mod</literal> file of your Operator project, add <literal>operator-framework/operator-lib</literal> as a required library:</simpara>
<programlisting language="go" linenumbering="unnumbered">module github.com/example-inc/memcached-operator

go 1.15

require (
  k8s.io/apimachinery v0.19.2
  k8s.io/client-go v0.19.2
  sigs.k8s.io/controller-runtime v0.7.0
  operator-framework/operator-lib v0.3.0
)</programlisting>
</listitem>
<listitem>
<simpara>Write your own constructor in your Operator logic that will result in the following outcomes:</simpara>
<itemizedlist>
<listitem>
<simpara>Accepts a <literal>controller-runtime</literal> client.</simpara>
</listitem>
<listitem>
<simpara>Accepts a <literal>conditionType</literal>.</simpara>
</listitem>
<listitem>
<simpara>Returns a <literal>Condition</literal> interface to update or add conditions.</simpara>
</listitem>
</itemizedlist>
<simpara>Because OLM currently supports the <literal>Upgradeable</literal> condition, you can create an interface that has methods to access the <literal>Upgradeable</literal> condition. For example:</simpara>
<programlisting language="go" linenumbering="unnumbered">import (
  ...
  apiv1 "github.com/operator-framework/api/pkg/operators/v1"
)

func NewUpgradeable(cl client.Client) (Condition, error) {
  return NewCondition(cl, "apiv1.OperatorUpgradeable")
}

cond, err := NewUpgradeable(cl);</programlisting>
<simpara>In this example, the <literal>NewUpgradeable</literal> constructor is further used to create a variable <literal>cond</literal> of type <literal>Condition</literal>. The <literal>cond</literal> variable would in turn have <literal>Get</literal> and <literal>Set</literal> methods, which can be used for handling the OLM <literal>Upgradeable</literal> condition.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm/olm-operatorconditions.xml#olm-operatorconditions">Operator conditions</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olm-defining-csv-webhook_osdk-generating-csvs">
<title>Defining webhooks</title>
<simpara>Webhooks allow Operator authors to intercept, modify, and accept or reject resources before they are saved to the object store and handled by the Operator controller. Operator Lifecycle Manager (OLM) can manage the lifecycle of these webhooks when they are shipped alongside your Operator.</simpara>
<simpara>The cluster service version (CSV) resource of an Operator can include a <literal>webhookdefinitions</literal> section to define the following types of webhooks:</simpara>
<itemizedlist>
<listitem>
<simpara>Admission webhooks (validating and mutating)</simpara>
</listitem>
<listitem>
<simpara>Conversion webhooks</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add a <literal>webhookdefinitions</literal> section to the <literal>spec</literal> section of the CSV of your Operator and include any webhook definitions using a <literal>type</literal> of <literal>ValidatingAdmissionWebhook</literal>, <literal>MutatingAdmissionWebhook</literal>, or <literal>ConversionWebhook</literal>. The following example contains all three types of webhooks:</simpara>
<formalpara>
<title>CSV containing webhooks</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: operators.coreos.com/v1alpha1
  kind: ClusterServiceVersion
  metadata:
    name: webhook-operator.v0.0.1
  spec:
    customresourcedefinitions:
      owned:
      - kind: WebhookTest
        name: webhooktests.webhook.operators.coreos.io <co xml:id="CO81-1"/>
        version: v1
    install:
      spec:
        deployments:
        - name: webhook-operator-webhook
          ...
          ...
          ...
      strategy: deployment
    installModes:
    - supported: false
      type: OwnNamespace
    - supported: false
      type: SingleNamespace
    - supported: false
      type: MultiNamespace
    - supported: true
      type: AllNamespaces
    webhookdefinitions:
    - type: ValidatingAdmissionWebhook <co xml:id="CO81-2"/>
      admissionReviewVersions:
      - v1beta1
      - v1
      containerPort: 443
      targetPort: 4343
      deploymentName: webhook-operator-webhook
      failurePolicy: Fail
      generateName: vwebhooktest.kb.io
      rules:
      - apiGroups:
        - webhook.operators.coreos.io
        apiVersions:
        - v1
        operations:
        - CREATE
        - UPDATE
        resources:
        - webhooktests
      sideEffects: None
      webhookPath: /validate-webhook-operators-coreos-io-v1-webhooktest
    - type: MutatingAdmissionWebhook <co xml:id="CO81-3"/>
      admissionReviewVersions:
      - v1beta1
      - v1
      containerPort: 443
      targetPort: 4343
      deploymentName: webhook-operator-webhook
      failurePolicy: Fail
      generateName: mwebhooktest.kb.io
      rules:
      - apiGroups:
        - webhook.operators.coreos.io
        apiVersions:
        - v1
        operations:
        - CREATE
        - UPDATE
        resources:
        - webhooktests
      sideEffects: None
      webhookPath: /mutate-webhook-operators-coreos-io-v1-webhooktest
    - type: ConversionWebhook <co xml:id="CO81-4"/>
      admissionReviewVersions:
      - v1beta1
      - v1
      containerPort: 443
      targetPort: 4343
      deploymentName: webhook-operator-webhook
      generateName: cwebhooktest.kb.io
      sideEffects: None
      webhookPath: /convert
      conversionCRDs:
      - webhooktests.webhook.operators.coreos.io <co xml:id="CO81-5"/>
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO81-1">
<para>The CRDs targeted by the conversion webhook must exist here.</para>
</callout>
<callout arearefs="CO81-2">
<para>A validating admission webhook.</para>
</callout>
<callout arearefs="CO81-3">
<para>A mutating admission webhook.</para>
</callout>
<callout arearefs="CO81-4">
<para>A conversion webhook.</para>
</callout>
<callout arearefs="CO81-5">
<para>The <literal>spec.PreserveUnknownFields</literal> property of each CRD must be set to <literal>false</literal> or <literal>nil</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../architecture/admission-plug-ins.xml#admission-webhook-types_admission-plug-ins">Types of webhook admission plugins</link></simpara>
</listitem>
<listitem>
<simpara>Kubernetes documentation:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook">Validating admission webhooks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook">Mutating admission webhooks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#webhook-conversion">Conversion webhooks</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<section xml:id="olm-webhook-considerations_osdk-generating-csvs">
<title>Webhook considerations for OLM</title>
<simpara>When deploying an Operator with webhooks using Operator Lifecycle Manager (OLM), you must define the following:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>type</literal> field must be set to either <literal>ValidatingAdmissionWebhook</literal>, <literal>MutatingAdmissionWebhook</literal>, or <literal>ConversionWebhook</literal>, or the CSV will be placed in a failed phase.</simpara>
</listitem>
<listitem>
<simpara>The CSV must contain a deployment whose name is equivalent to the value supplied in the <literal>deploymentName</literal> field of the <literal>webhookdefinition</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>When the webhook is created, OLM ensures that the webhook only acts upon namespaces that match the Operator group that the Operator is deployed in.</simpara>
<bridgehead xml:id="olm-webhook-ca_osdk-generating-csvs" renderas="sect6">Certificate authority constraints</bridgehead>
<simpara>OLM is configured to provide each deployment with a single certificate authority (CA). The logic that generates and mounts the CA into the deployment was originally used by the API service lifecycle logic. As a result:</simpara>
<itemizedlist>
<listitem>
<simpara>The TLS certificate file is mounted to the deployment at <literal>/apiserver.local.config/certificates/apiserver.crt</literal>.</simpara>
</listitem>
<listitem>
<simpara>The TLS key file is mounted to the deployment at <literal>/apiserver.local.config/certificates/apiserver.key</literal>.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="olm-admission-webhook-constraints_osdk-generating-csvs" renderas="sect6">Admission webhook rules constraints</bridgehead>
<simpara>To prevent an Operator from configuring the cluster into an unrecoverable state, OLM places the CSV in the failed phase if the rules defined in an admission webhook intercept any of the following requests:</simpara>
<itemizedlist>
<listitem>
<simpara>Requests that target all groups</simpara>
</listitem>
<listitem>
<simpara>Requests that target the <literal>operators.coreos.com</literal> group</simpara>
</listitem>
<listitem>
<simpara>Requests that target the <literal>ValidatingWebhookConfigurations</literal> or <literal>MutatingWebhookConfigurations</literal> resources</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="olm-conversion-webhook-constraints_osdk-generating-csvs" renderas="sect6">Conversion webhook constraints</bridgehead>
<simpara>OLM places the CSV in the failed phase if a conversion webhook definition does not adhere to the following constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>CSVs featuring a conversion webhook can only support the <literal>AllNamespaces</literal> install mode.</simpara>
</listitem>
<listitem>
<simpara>The CRD targeted by the conversion webhook must have its
<literal>spec.preserveUnknownFields</literal> field set to <literal>false</literal> or <literal>nil</literal>.</simpara>
</listitem>
<listitem>
<simpara>The conversion webhook defined in the CSV must target an owned CRD.</simpara>
</listitem>
<listitem>
<simpara>There can only be one conversion webhook on the entire cluster for a given CRD.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-crds_osdk-generating-csvs">
<title>Understanding your custom resource definitions (CRDs)</title>
<simpara>There are two types of custom resource definitions (CRDs) that your Operator can use: ones that are <emphasis>owned</emphasis> by it and ones that it depends on, which are <emphasis>required</emphasis>.</simpara>
<section xml:id="osdk-crds-owned_osdk-generating-csvs">
<title>Owned CRDs</title>
<simpara>The custom resource definitions (CRDs) owned by your Operator are the most important part of your CSV. This establishes the link between your Operator and the required RBAC rules, dependency management, and other Kubernetes concepts.</simpara>
<simpara>It is common for your Operator to use multiple CRDs to link together concepts, such as top-level database configuration in one object and a representation of replica sets in another. Each one should be listed out in the CSV file.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Owned CRD fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="22.2222*"/>
<colspec colname="col_2" colwidth="55.5555*"/>
<colspec colname="col_3" colwidth="22.2223*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required/optional</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The full name of your CRD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of that object API.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The machine readable name of your CRD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DisplayName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A human readable version of your CRD name, for example <literal>MongoDB Standalone</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A short description of how this CRD is used by the Operator or a description of the functionality provided by the CRD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The API group that this CRD belongs to, for example <literal>database.example.com</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Resources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Your CRDs own one or more types of Kubernetes objects. These are listed in the <literal>resources</literal> section to inform your users of the objects they might need to troubleshoot or how to connect to the application, such as the service or ingress rule that exposes a database.</simpara>
<simpara>It is recommended to only list out the objects that are important to a human, not an exhaustive list of everything you orchestrate. For example, do not list config maps that store internal state that are not meant to be modified by a user.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SpecDescriptors</literal>, <literal>StatusDescriptors</literal>, and <literal>ActionDescriptors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These descriptors are a way to hint UIs with certain inputs or outputs of your Operator that are most important to an end user. If your CRD contains the name of a secret or config map that the user must provide, you can specify that here. These items are linked and highlighted in compatible UIs.</simpara>
<simpara>There are three types of descriptors:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>SpecDescriptors</literal>: A reference to fields in the <literal>spec</literal> block of an object.</simpara>
</listitem>
<listitem>
<simpara><literal>StatusDescriptors</literal>: A reference to fields in the <literal>status</literal> block of an object.</simpara>
</listitem>
<listitem>
<simpara><literal>ActionDescriptors</literal>: A reference to actions that can be performed on an object.</simpara>
</listitem>
</itemizedlist>
<simpara>All descriptors accept the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DisplayName</literal>: A human readable name for the <literal>Spec</literal>, <literal>Status</literal>, or <literal>Action</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Description</literal>: A short description of the <literal>Spec</literal>, <literal>Status</literal>, or <literal>Action</literal> and how it is used by the Operator.</simpara>
</listitem>
<listitem>
<simpara><literal>Path</literal>: A dot-delimited path of the field on the object that this descriptor describes.</simpara>
</listitem>
<listitem>
<simpara><literal>X-Descriptors</literal>: Used to determine which "capabilities" this descriptor has and which UI component to use. See the <emphasis role="strong">openshift/console</emphasis> project for a canonical <link xl:href="https://github.com/openshift/console/tree/release-4.3/frontend/packages/operator-lifecycle-manager/src/components/descriptors/types.ts">list of React UI X-Descriptors</link> for {product-title}.</simpara>
</listitem>
</itemizedlist>
<simpara>Also see the <emphasis role="strong">openshift/console</emphasis> project for more information on <link xl:href="https://github.com/openshift/console/tree/release-4.3/frontend/packages/operator-lifecycle-manager/src/components/descriptors">Descriptors</link> in general.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>The following example depicts a <literal>MongoDB Standalone</literal> CRD that requires some user input in the form of a secret and config map, and orchestrates services, stateful sets, pods and config maps:</simpara>
<formalpara xml:id="osdk-crds-owned-example_osdk-generating-csvs">
<title>Example owned CRD</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">      - displayName: MongoDB Standalone
        group: mongodb.com
        kind: MongoDbStandalone
        name: mongodbstandalones.mongodb.com
        resources:
          - kind: Service
            name: ''
            version: v1
          - kind: StatefulSet
            name: ''
            version: v1beta2
          - kind: Pod
            name: ''
            version: v1
          - kind: ConfigMap
            name: ''
            version: v1
        specDescriptors:
          - description: Credentials for Ops Manager or Cloud Manager.
            displayName: Credentials
            path: credentials
            x-descriptors:
              - 'urn:alm:descriptor:com.tectonic.ui:selector:core:v1:Secret'
          - description: Project this deployment belongs to.
            displayName: Project
            path: project
            x-descriptors:
              - 'urn:alm:descriptor:com.tectonic.ui:selector:core:v1:ConfigMap'
          - description: MongoDB version to be installed.
            displayName: Version
            path: version
            x-descriptors:
              - 'urn:alm:descriptor:com.tectonic.ui:label'
        statusDescriptors:
          - description: The status of each of the pods for the MongoDB cluster.
            displayName: Pod Status
            path: pods
            x-descriptors:
              - 'urn:alm:descriptor:com.tectonic.ui:podStatuses'
        version: v1
        description: &gt;-
          MongoDB Deployment consisting of only one host. No replication of
          data.</programlisting>
</para>
</formalpara>
</section>
<section xml:id="osdk-crds-required_osdk-generating-csvs">
<title>Required CRDs</title>
<simpara>Relying on other required CRDs is completely optional and only exists to reduce the scope of individual Operators and provide a way to compose multiple Operators together to solve an end-to-end use case.</simpara>
<simpara>An example of this is an Operator that might set up an application and install an etcd cluster (from an etcd Operator) to use for distributed locking and a Postgres database (from a Postgres Operator) for data storage.</simpara>
<simpara>Operator Lifecycle Manager (OLM) checks against the available CRDs and Operators in the cluster to fulfill these requirements. If suitable versions are found, the Operators are started within the desired namespace and a service account created for each Operator to create, watch, and modify the Kubernetes resources required.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Required CRD fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="22.2222*"/>
<colspec colname="col_2" colwidth="55.5555*"/>
<colspec colname="col_3" colwidth="22.2223*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required/optional</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The full name of the CRD you require.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of that object API.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Kubernetes object kind.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DisplayName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A human readable version of the CRD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A summary of how the component fits in your larger architecture.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<formalpara>
<title>Example required CRD</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">    required:
    - name: etcdclusters.etcd.database.coreos.com
      version: v1beta2
      kind: EtcdCluster
      displayName: etcd Cluster
      description: Represents a cluster of etcd nodes.</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olm-dependency-resolution-crd-upgrades_osdk-generating-csvs">
<title>CRD upgrades</title>
<simpara>OLM upgrades a custom resource definition (CRD) immediately if it is owned by a singular cluster service version (CSV). If a CRD is owned by multiple CSVs, then the CRD is upgraded when it has satisfied all of the following backward compatible conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>All existing serving versions in the current CRD are present in the new CRD.</simpara>
</listitem>
<listitem>
<simpara>All existing instances, or custom resources, that are associated with the serving versions of the CRD are valid when validated against the validation schema of the new CRD.</simpara>
</listitem>
</itemizedlist>
<section xml:id="olm-dependency-resolution-adding-new-crd-version_osdk-generating-csvs">
<title>Adding a new CRD version</title>
<formalpara>
<title>Procedure</title>
<para>To add a new version of a CRD to your Operator:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a new entry in the CRD resource under the <literal>versions</literal> section of your CSV.</simpara>
<simpara>For example, if the current CRD has a version <literal>v1alpha1</literal> and you want to add a new version <literal>v1beta1</literal> and mark it as the new storage version, add a new entry for <literal>v1beta1</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">versions:
  - name: v1alpha1
    served: true
    storage: false
  - name: v1beta1 <co xml:id="CO82-1"/>
    served: true
    storage: true</programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>New entry.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Ensure the referencing version of the CRD in the <literal>owned</literal> section of your CSV is updated if the CSV intends to use the new version:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">customresourcedefinitions:
  owned:
  - name: cluster.example.com
    version: v1beta1 <co xml:id="CO83-1"/>
    kind: cluster
    displayName: Cluster</programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para>Update the <literal>version</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Push the updated CRD and CSV to your bundle.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olm-dependency-resolution-removing-crd-version_osdk-generating-csvs">
<title>Deprecating or removing a CRD version</title>
<simpara>Operator Lifecycle Manager (OLM) does not allow a serving version of a custom resource definition (CRD) to be removed right away. Instead, a deprecated version of the CRD must be first disabled by setting the <literal>served</literal> field in the CRD to <literal>false</literal>. Then, the non-serving version can be removed on the subsequent CRD upgrade.</simpara>
<formalpara>
<title>Procedure</title>
<para>To deprecate and remove a specific version of a CRD:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Mark the deprecated version as non-serving to indicate this version is no longer in use and may be removed in a subsequent upgrade. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">versions:
  - name: v1alpha1
    served: false <co xml:id="CO84-1"/>
    storage: true</programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para>Set to <literal>false</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Switch the <literal>storage</literal> version to a serving version if the version to be deprecated is currently the <literal>storage</literal> version. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">versions:
  - name: v1alpha1
    served: false
    storage: false <co xml:id="CO85-1"/>
  - name: v1beta1
    served: true
    storage: true <co xml:id="CO85-2"/></programlisting>
<calloutlist>
<callout arearefs="CO85-1 CO85-2">
<para>Update the <literal>storage</literal> fields accordingly.</para>
</callout>
</calloutlist>
<note>
<simpara>To remove a specific version that is or was the <literal>storage</literal> version from a CRD, that version must be removed from the <literal>storedVersion</literal> in the status of the CRD. OLM will attempt to do this for you if it detects a stored version no longer exists in the new CRD.</simpara>
</note>
</listitem>
<listitem>
<simpara>Upgrade the CRD with the above changes.</simpara>
</listitem>
<listitem>
<simpara>In subsequent upgrade cycles, the non-serving version can be removed completely from the CRD. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">versions:
  - name: v1beta1
    served: true
    storage: true</programlisting>
</listitem>
<listitem>
<simpara>Ensure the referencing CRD version in the <literal>owned</literal> section of your CSV is updated accordingly if that version is removed from the CRD.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="osdk-crds-templates_osdk-generating-csvs">
<title>CRD templates</title>
<simpara>Users of your Operator must be made aware of which options are required versus optional. You can provide templates for each of your custom resource definitions (CRDs) with a minimum set of configuration as an annotation named <literal>alm-examples</literal>. Compatible UIs will pre-fill this template for users to further customize.</simpara>
<simpara>The annotation consists of a list of the kind, for example, the CRD name and the corresponding <literal>metadata</literal> and <literal>spec</literal> of the Kubernetes object.</simpara>
<simpara>The following full example provides templates for <literal>EtcdCluster</literal>, <literal>EtcdBackup</literal> and <literal>EtcdRestore</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">metadata:
  annotations:
    alm-examples: &gt;-
      [{"apiVersion":"etcd.database.coreos.com/v1beta2","kind":"EtcdCluster","metadata":{"name":"example","namespace":"&lt;operator_namespace&gt;"},"spec":{"size":3,"version":"3.2.13"}},{"apiVersion":"etcd.database.coreos.com/v1beta2","kind":"EtcdRestore","metadata":{"name":"example-etcd-cluster"},"spec":{"etcdCluster":{"name":"example-etcd-cluster"},"backupStorageType":"S3","s3":{"path":"&lt;full-s3-path&gt;","awsSecret":"&lt;aws-secret&gt;"}}},{"apiVersion":"etcd.database.coreos.com/v1beta2","kind":"EtcdBackup","metadata":{"name":"example-etcd-cluster-backup"},"spec":{"etcdEndpoints":["&lt;etcd-cluster-endpoints&gt;"],"storageType":"S3","s3":{"path":"&lt;full-s3-path&gt;","awsSecret":"&lt;aws-secret&gt;"}}}]</programlisting>
</section>
<section xml:id="osdk-hiding-internal-objects_osdk-generating-csvs">
<title>Hiding internal objects</title>
<simpara>It is common practice for Operators to use custom resource definitions (CRDs) internally to accomplish a task. These objects are not meant for users to manipulate and can be confusing to users of the Operator. For example, a database Operator might have a <literal>Replication</literal> CRD that is created whenever a user creates a Database object with <literal>replication: true</literal>.</simpara>
<simpara>As an Operator author, you can hide any CRDs in the user interface that are not meant for user manipulation by adding the <literal>operators.operatorframework.io/internal-objects</literal> annotation to the cluster service version (CSV) of your Operator.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Before marking one of your CRDs as internal, ensure that any debugging information or configuration that might be required to manage the application is reflected on the status or <literal>spec</literal> block of your CR, if applicable to your Operator.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>operators.operatorframework.io/internal-objects</literal> annotation to the CSV of your Operator to specify any internal objects to hide in the user interface:</simpara>
<formalpara>
<title>Internal object annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  name: my-operator-v1.2.3
  annotations:
    operators.operatorframework.io/internal-objects: '["my.internal.crd1.io","my.internal.crd2.io"]' <co xml:id="CO86-1"/>
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO86-1">
<para>Set any internal CRDs as an array of strings.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-init-resource_osdk-generating-csvs">
<title>Initializing required custom resources</title>
<simpara>An Operator might require the user to instantiate a custom resource before the Operator can be fully functional. However, it can be challenging for a user to determine what is required or how to define the resource.</simpara>
<simpara>As an Operator developer, you can specify a single required custom resource by adding <literal>operatorframework.io/initialization-resource</literal> to the cluster service version (CSV) during Operator installation. You are then prompted to create the custom resource through a template that is provided in the CSV.
The annotation must include a template that contains a complete YAML definition that is required to initialize the resource during installation.</simpara>
<simpara>If this annotation is defined, after installing the Operator from the {product-title} web console, the user is prompted to create the resource using the template provided in the CSV.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add the <literal>operatorframework.io/initialization-resource</literal> annotation to the CSV of your Operator to specify a required custom resource. For example, the following annotation requires the creation of a <literal>StorageCluster</literal> resource and provides a full YAML definition:</simpara>
<formalpara>
<title>Initialization resource annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  name: my-operator-v1.2.3
  annotations:
    operatorframework.io/initialization-resource: |-
        {
            "apiVersion": "ocs.openshift.io/v1",
            "kind": "StorageCluster",
            "metadata": {
                "name": "example-storagecluster"
            },
            "spec": {
                "manageNodes": false,
                "monPVCTemplate": {
                    "spec": {
                        "accessModes": [
                            "ReadWriteOnce"
                        ],
                        "resources": {
                            "requests": {
                                "storage": "10Gi"
                            }
                        },
                        "storageClassName": "gp2"
                    }
                },
                "storageDeviceSets": [
                    {
                        "count": 3,
                        "dataPVCTemplate": {
                            "spec": {
                                "accessModes": [
                                    "ReadWriteOnce"
                                ],
                                "resources": {
                                    "requests": {
                                        "storage": "1Ti"
                                    }
                                },
                                "storageClassName": "gp2",
                                "volumeMode": "Block"
                            }
                        },
                        "name": "example-deviceset",
                        "placement": {},
                        "portable": true,
                        "resources": {}
                    }
                ]
            }
        }
...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-apiservices_osdk-generating-csvs">
<title>Understanding your API services</title>
<simpara>As with CRDs, there are two types of API services that your Operator may use: <emphasis>owned</emphasis> and <emphasis>required</emphasis>.</simpara>
<section xml:id="osdk-apiservices-owned_osdk-generating-csvs">
<title>Owned API services</title>
<simpara>When a CSV owns an API service, it is responsible for describing the deployment of the extension <literal>api-server</literal> that backs it and the group/version/kind (GVK) it provides.</simpara>
<simpara>An API service is uniquely identified by the group/version it provides and can be listed multiple times to denote the different kinds it is expected to provide.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Owned API service fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="22.2222*"/>
<colspec colname="col_2" colwidth="55.5555*"/>
<colspec colname="col_3" colwidth="22.2223*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required/optional</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Group that the API service provides, for example <literal>database.example.com</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Version of the API service, for example <literal>v1alpha1</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A kind that the API service is expected to provide.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The plural name for the API service provided.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeploymentName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Name of the deployment defined by your CSV that corresponds to your API service (required for owned API services). During the CSV pending phase, the OLM Operator searches the <literal>InstallStrategy</literal> of your CSV for a <literal>Deployment</literal> spec with a matching name, and if not found, does not transition the CSV to the "Install Ready" phase.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DisplayName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A human readable version of your API service name, for example <literal>MongoDB Standalone</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A short description of how this API service is used by the Operator or a description of the functionality provided by the API service.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Resources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Your API services own one or more types of Kubernetes objects. These are listed in the resources section to inform your users of the objects they might need to troubleshoot or how to connect to the application, such as the service or ingress rule that exposes a database.</simpara>
<simpara>It is recommended to only list out the objects that are important to a human, not an exhaustive list of everything you orchestrate. For example, do not list config maps that store internal state that are not meant to be modified by a user.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SpecDescriptors</literal>, <literal>StatusDescriptors</literal>, and <literal>ActionDescriptors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Essentially the same as for owned CRDs.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="osdk-apiservices-resource-creation_osdk-generating-csvs">
<title>API service resource creation</title>
<simpara>Operator Lifecycle Manager (OLM) is responsible for creating or replacing the service and API service resources for each unique owned API service:</simpara>
<itemizedlist>
<listitem>
<simpara>Service pod selectors are copied from the CSV deployment matching the <literal>DeploymentName</literal> field of the API service description.</simpara>
</listitem>
<listitem>
<simpara>A new CA key/certificate pair is generated for each installation and the base64-encoded CA bundle is embedded in the respective API service resource.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-apiservices-service-certs_osdk-generating-csvs">
<title>API service serving certificates</title>
<simpara>OLM handles generating a serving key/certificate pair whenever an owned API service is being installed. The serving certificate has a common name (CN) containing the hostname of the generated <literal>Service</literal> resource and is signed by the private key of the CA bundle embedded in the corresponding API service resource.</simpara>
<simpara>The certificate is stored as a type <literal>kubernetes.io/tls</literal> secret in the deployment namespace, and a volume named <literal>apiservice-cert</literal> is automatically appended to the volumes section of the deployment in the CSV matching the <literal>DeploymentName</literal> field of the API service description.</simpara>
<simpara>If one does not already exist, a volume mount with a matching name is also appended to all containers of that deployment. This allows users to define a volume mount with the expected name to accommodate any custom path requirements. The path of the generated volume mount defaults to <literal>/apiserver.local.config/certificates</literal> and any existing volume mounts with the same path are replaced.</simpara>
</section>
</section>
<section xml:id="osdk-apiservice-required_osdk-generating-csvs">
<title>Required API services</title>
<simpara>OLM ensures all required CSVs have an API service that is available and all expected GVKs are discoverable before attempting installation. This allows a CSV to rely on specific kinds provided by API services it does not own.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Required API service fields</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="22.2222*"/>
<colspec colname="col_2" colwidth="55.5555*"/>
<colspec colname="col_3" colwidth="22.2223*"/>
<thead>
<row>
<entry align="left" valign="top">Field</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Required/optional</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Group</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Group that the API service provides, for example <literal>database.example.com</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Version of the API service, for example <literal>v1alpha1</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A kind that the API service is expected to provide.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DisplayName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A human readable version of your API service name, for example <literal>MongoDB Standalone</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A short description of how this API service is used by the Operator or a description of the functionality provided by the API service.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
</section>
<section xml:id="osdk-working-bundle-images">
<title>Working with bundle images</title>

<simpara>You can use the Operator SDK to package, deploy, and upgrade Operators in the bundle format for use on Operator Lifecycle Manager (OLM).</simpara>
<section xml:id="osdk-bundle-operator_osdk-working-bundle-images">
<title>Bundling an Operator</title>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and Operator Lifecycle Manager (OLM). You can get your Operator ready for use on OLM by using the Operator SDK to build and push your Operator project as a bundle image.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>OpenShift CLI (<literal>oc</literal>) v{product-version}+ installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initialized by using the Operator SDK</simpara>
</listitem>
<listitem>
<simpara>If your Operator is Go-based, your project must be updated to use supported images for running on {product-title}</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> commands in your Operator project directory to build and push your Operator image. Modify the <literal>IMG</literal> argument in the following steps to reference a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<note>
<simpara>The Dockerfile generated by the SDK for the Operator explicitly references <literal>GOARCH=amd64</literal> for <literal>go build</literal>. This can be amended to <literal>GOARCH=$TARGETARCH</literal> for non-AMD64 architectures. Docker will automatically set the environment variable to the value specified by <literal>–platform</literal>. With Buildah, the <literal>–build-arg</literal> will need to be used for the purpose. For more information, see <link xl:href="https://sdk.operatorframework.io/docs/advanced-topics/multi-arch/#supporting-multiple-architectures">Multiple Architectures</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Push the image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create your Operator bundle manifest by running the <literal>make bundle</literal> command, which invokes several commands, including the Operator SDK <literal>generate bundle</literal> and <literal>bundle validate</literal> subcommands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle IMG=&lt;registry&gt;/&lt;user&gt;/&lt;operator_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>Bundle manifests for an Operator describe how to display, create, and manage an application. The <literal>make bundle</literal> command creates the following files and directories in your Operator project:</simpara>
<itemizedlist>
<listitem>
<simpara>A bundle manifests directory named <literal>bundle/manifests</literal> that contains a <literal>ClusterServiceVersion</literal> object</simpara>
</listitem>
<listitem>
<simpara>A bundle metadata directory named <literal>bundle/metadata</literal></simpara>
</listitem>
<listitem>
<simpara>All custom resource definitions (CRDs) in a <literal>config/crd</literal> directory</simpara>
</listitem>
<listitem>
<simpara>A Dockerfile <literal>bundle.Dockerfile</literal></simpara>
</listitem>
</itemizedlist>
<simpara>These files are then automatically validated by using <literal>operator-sdk bundle validate</literal> to ensure the on-disk bundle representation is correct.</simpara>
</listitem>
<listitem>
<simpara>Build and push your bundle image by running the following commands. OLM consumes Operator bundles using an index image, which reference one or more bundle images.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the bundle image. Set <literal>BUNDLE_IMG</literal> with the details for the registry, user namespace, and image tag where you intend to push the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build BUNDLE_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Push the bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker push &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-deploy-olm_osdk-working-bundle-images">
<title>Deploying an Operator with Operator Lifecycle Manager</title>
<simpara>Operator Lifecycle Manager (OLM) helps you to install, update, and manage the lifecycle of Operators and their associated services on a Kubernetes cluster. OLM is installed by default on {product-title} and runs as a Kubernetes extension so that you can use the web console and the OpenShift CLI (<literal>oc</literal>) for all Operator lifecycle management functions without any additional tools.</simpara>
<simpara>The Operator bundle format is the default packaging method for Operator SDK and OLM. You can use the Operator SDK to quickly run a bundle image on OLM to ensure that it runs properly.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
<listitem>
<simpara>If your Operator is Go-based, your project must be updated to use supported images for running on {product-title}</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enter the following command to run the Operator on the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle \<co xml:id="CO87-1"/>
    -n &lt;namespace&gt; \<co xml:id="CO87-2"/>
    &lt;registry&gt;/&lt;user&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt; <co xml:id="CO87-3"/></programlisting>
<calloutlist>
<callout arearefs="CO87-1">
<para>The <literal>run bundle</literal> command creates a valid file-based catalog and installs the Operator bundle on your cluster using OLM.</para>
</callout>
<callout arearefs="CO87-2">
<para>Optional: By default, the command installs the Operator in the currently active project in your <literal>~/.kube/config</literal> file. You can add the <literal>-n</literal> flag to set a different namespace scope for the installation.</para>
</callout>
<callout arearefs="CO87-3">
<para>If you do not specify an image, the command uses <literal>quay.io/operator-framework/opm:latest</literal> as the default index image. If you specify an image, the command uses the bundle image itself as the index image.</para>
</callout>
</calloutlist>
<important>
<simpara>As of {product-title} 4.11, the <literal>run bundle</literal> command supports the file-based catalog format for Operator catalogs by default. The deprecated SQLite database format for Operator catalogs continues to be supported; however, it will be removed in a future release. It is recommended that Operator authors migrate their workflows to the file-based catalog format.</simpara>
</important>
<simpara>This command performs the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an index image referencing your bundle image. The index image is opaque and ephemeral, but accurately reflects how a bundle would be added to a catalog in production.</simpara>
</listitem>
<listitem>
<simpara>Create a catalog source that points to your new index image, which enables OperatorHub to discover your Operator.</simpara>
</listitem>
<listitem>
<simpara>Deploy your Operator to your cluster by creating an <literal>OperatorGroup</literal>, <literal>Subscription</literal>, <literal>InstallPlan</literal>, and all other required resources, including RBAC.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">File-based catalogs</link> in Operator Framework packaging format</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs-fb">File-based catalogs</link> in Managing custom catalogs</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">Bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-publish-catalog_osdk-working-bundle-images">
<title>Publishing a catalog containing a bundled Operator</title>
<simpara>To install and manage Operators, Operator Lifecycle Manager (OLM) requires that Operator bundles are listed in an index image, which is referenced by a catalog on the cluster. As an Operator author, you can use the Operator SDK to create an index containing the bundle for your Operator and all of its dependencies. This is useful for testing on remote clusters and publishing to container registries.</simpara>
<note>
<simpara>The Operator SDK uses the <literal>opm</literal> CLI to facilitate index image creation. Experience with the <literal>opm</literal> command is not required. For advanced use cases, the <literal>opm</literal> command can be used directly instead of the Operator SDK.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed on a development workstation</simpara>
</listitem>
<listitem>
<simpara>Operator bundle image built and pushed to a registry</simpara>
</listitem>
<listitem>
<simpara>OLM installed on a Kubernetes-based cluster (v1.16.0 or later if you use <literal>apiextensions.k8s.io/v1</literal> CRDs, for example {product-title} {product-version})</simpara>
</listitem>
<listitem>
<simpara>Logged in to the cluster with <literal>oc</literal> using an account with <literal>cluster-admin</literal> permissions</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following <literal>make</literal> command in your Operator project directory to build an index image containing your Operator bundle:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make catalog-build CATALOG_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;index_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>where the <literal>CATALOG_IMG</literal> argument references a repository that you have access to. You can obtain an account for storing containers at repository sites such as Quay.io.</simpara>
</listitem>
<listitem>
<simpara>Push the built index image to a repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make catalog-push CATALOG_IMG=&lt;registry&gt;/&lt;user&gt;/&lt;index_image_name&gt;:&lt;tag&gt;</programlisting>
<tip>
<simpara>You can use Operator SDK <literal>make</literal> commands together if you would rather perform multiple actions in sequence at once. For example, if you had not yet built a bundle image for your Operator project, you can build and push both a bundle image and an index image with the following syntax:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build bundle-push catalog-build catalog-push \
    BUNDLE_IMG=&lt;bundle_image_pull_spec&gt; \
    CATALOG_IMG=&lt;index_image_pull_spec&gt;</programlisting>
<simpara>Alternatively, you can set the <literal>IMAGE_TAG_BASE</literal> field in your <literal>Makefile</literal>  to an existing repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">IMAGE_TAG_BASE=quay.io/example/my-operator</programlisting>
<simpara>You can then use the following syntax to build and push images with automatically-generated names, such as <literal>quay.io/example/my-operator-bundle:v0.0.1</literal> for the bundle image and <literal>quay.io/example/my-operator-catalog:v0.0.1</literal> for the index image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle-build bundle-push catalog-build catalog-push</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Define a <literal>CatalogSource</literal> object that references the index image you just generated, and then create the object by using the <literal>oc apply</literal> command or web console:</simpara>
<formalpara>
<title>Example <literal>CatalogSource</literal> YAML</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: CatalogSource
metadata:
  name: cs-memcached
  namespace: &lt;operator_namespace&gt;
spec:
  displayName: My Test
  publisher: Company
  sourceType: grpc
  grpcPodConfig:
    securityContextConfig: &lt;security_mode&gt; <co xml:id="CO88-1"/>
  image: quay.io/example/memcached-catalog:v0.0.1 <co xml:id="CO88-2"/>
  updateStrategy:
    registryPoll:
      interval: 10m</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO88-1">
<para>Specify the value of <literal>legacy</literal> or <literal>restricted</literal>. If the field is not set, the default value is <literal>legacy</literal>. In a future {product-title} release, it is planned that the default value will be <literal>restricted</literal>. If your catalog cannot run with <literal>restricted</literal> permissions, it is recommended that you manually set this field to <literal>legacy</literal>.</para>
</callout>
<callout arearefs="CO88-2">
<para>Set <literal>image</literal> to the image pull spec you used previously with the <literal>CATALOG_IMG</literal> argument.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Check the catalog source:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsource</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME           DISPLAY     TYPE   PUBLISHER   AGE
cs-memcached   My Test     grpc   Company     4h31m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Install the Operator using your catalog:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define an <literal>OperatorGroup</literal> object and create it by using the <literal>oc apply</literal> command or web console:</simpara>
<formalpara>
<title>Example <literal>OperatorGroup</literal> YAML</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: my-test
  namespace: &lt;operator_namespace&gt;
spec:
  targetNamespaces:
  - &lt;operator_namespace&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Define a <literal>Subscription</literal> object and create it by using the <literal>oc apply</literal> command or web console:</simpara>
<formalpara>
<title>Example <literal>Subscription</literal> YAML</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">﻿apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: catalogtest
  namespace: &lt;catalog_namespace&gt;
spec:
  channel: "alpha"
  installPlanApproval: Manual
  name: catalog
  source: cs-memcached
  sourceNamespace: &lt;operator_namespace&gt;
  startingCSV: memcached-operator.v0.0.1</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify the installed Operator is running:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the Operator group:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get og</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             AGE
my-test           4h40m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the cluster service version (CSV):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                        DISPLAY   VERSION   REPLACES   PHASE
memcached-operator.v0.0.1   Test      0.0.1                Succeeded</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the pods for the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                              READY   STATUS      RESTARTS   AGE
9098d908802769fbde8bd45255e69710a9f8420a8f3d814abe88b68f8ervdj6   0/1     Completed   0          4h33m
catalog-controller-manager-7fd5b7b987-69s4n                       2/2     Running     0          4h32m
cs-memcached-7622r                                                1/1     Running     0          4h33m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs">Managing custom catalogs</link> for details on direct usage of the <literal>opm</literal> CLI for more advanced use cases.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-bundle-upgrade-olm_osdk-working-bundle-images">
<title>Testing an Operator upgrade on Operator Lifecycle Manager</title>
<simpara>You can quickly test upgrading your Operator by using Operator Lifecycle Manager (OLM) integration in the Operator SDK, without requiring you to manually manage index images and catalog sources.</simpara>
<simpara>The <literal>run bundle-upgrade</literal> subcommand automates triggering an installed Operator to upgrade to a later version by specifying a bundle image for the later version.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator installed with OLM either by using the <literal>run bundle</literal> subcommand or with traditional OLM installation</simpara>
</listitem>
<listitem>
<simpara>A bundle image that represents a later version of the installed Operator</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If your Operator has not already been installed with OLM, install the earlier version either by using the <literal>run bundle</literal> subcommand or with traditional OLM installation.</simpara>
<note>
<simpara>If the earlier version of the bundle was installed traditionally using OLM, the newer bundle that you intend to upgrade to must not exist in the index image referenced by the catalog source. Otherwise, running the <literal>run bundle-upgrade</literal> subcommand will cause the registry pod to fail because the newer bundle is already referenced by the index that provides the package and cluster service version (CSV).</simpara>
</note>
<simpara>For example, you can use the following <literal>run bundle</literal> subcommand for a Memcached Operator by specifying the earlier bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle &lt;registry&gt;/&lt;user&gt;/memcached-operator:v0.0.1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">INFO[0006] Creating a File-Based Catalog of the bundle "quay.io/demo/memcached-operator:v0.0.1"
INFO[0008] Generated a valid File-Based Catalog
INFO[0012] Created registry pod: quay-io-demo-memcached-operator-v1-0-1
INFO[0012] Created CatalogSource: memcached-operator-catalog
INFO[0012] OperatorGroup "operator-sdk-og" created
INFO[0012] Created Subscription: memcached-operator-v0-0-1-sub
INFO[0015] Approved InstallPlan install-h9666 for the Subscription: memcached-operator-v0-0-1-sub
INFO[0015] Waiting for ClusterServiceVersion "my-project/memcached-operator.v0.0.1" to reach 'Succeeded' phase
INFO[0015] Waiting for ClusterServiceVersion ""my-project/memcached-operator.v0.0.1" to appear
INFO[0026] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.1" phase: Pending
INFO[0028] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.1" phase: Installing
INFO[0059] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.1" phase: Succeeded
INFO[0059] OLM has successfully installed "memcached-operator.v0.0.1"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Upgrade the installed Operator by specifying the bundle image for the later Operator version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle-upgrade &lt;registry&gt;/&lt;user&gt;/memcached-operator:v0.0.2</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">INFO[0002] Found existing subscription with name memcached-operator-v0-0-1-sub and namespace my-project
INFO[0002] Found existing catalog source with name memcached-operator-catalog and namespace my-project
INFO[0008] Generated a valid Upgraded File-Based Catalog
INFO[0009] Created registry pod: quay-io-demo-memcached-operator-v0-0-2
INFO[0009] Updated catalog source memcached-operator-catalog with address and annotations
INFO[0010] Deleted previous registry pod with name "quay-io-demo-memcached-operator-v0-0-1"
INFO[0041] Approved InstallPlan install-gvcjh for the Subscription: memcached-operator-v0-0-1-sub
INFO[0042] Waiting for ClusterServiceVersion "my-project/memcached-operator.v0.0.2" to reach 'Succeeded' phase
INFO[0019] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.2" phase: Pending
INFO[0042] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.2" phase: InstallReady
INFO[0043] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.2" phase: Installing
INFO[0044] Found ClusterServiceVersion "my-project/memcached-operator.v0.0.2" phase: Succeeded
INFO[0044] Successfully upgraded to "memcached-operator.v0.0.2"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Clean up the installed Operators:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk cleanup memcached-operator</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-adding-operators-to-a-cluster">Traditional Operator installation with OLM</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-control-compat_osdk-working-bundle-images">
<title>Controlling Operator compatibility with {product-title} versions</title>
<important>
<simpara>Kubernetes periodically deprecates certain APIs that are removed in subsequent releases. If your Operator is using a deprecated API, it might no longer work after the {product-title} cluster is upgraded to the Kubernetes version where the API has been removed.</simpara>
<simpara>As an Operator author, it is strongly recommended that you review the <link xl:href="https://kubernetes.io/docs/reference/using-api/deprecation-guide/">Deprecated API Migration Guide</link> in Kubernetes documentation and keep your Operator projects up to date to avoid using deprecated and removed APIs. Ideally, you should update your Operator before the release of a future version of {product-title} that would make the Operator incompatible.</simpara>
</important>
<simpara>When an API is removed from an {product-title} version, Operators running on that cluster version that are still using removed APIs will no longer work properly. As an Operator author, you should plan to update your Operator projects to accommodate API deprecation and removal to avoid interruptions for users of your Operator.</simpara>
<tip>
<simpara>You can check the event alerts of your Operators to find whether there are any warnings about APIs currently in use. The following alerts fire when they detect an API in use that will be removed in the next release:</simpara>
<variablelist>
<varlistentry>
<term><literal>APIRemovedInNextReleaseInUse</literal></term>
<listitem>
<simpara>APIs that will be removed in the next {product-title} release.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>APIRemovedInNextEUSReleaseInUse</literal></term>
<listitem>
<simpara>APIs that will be removed in the next {product-title} <link xl:href="https://access.redhat.com/support/policy/updates/openshift#ocp4_phases">Extended Update Support (EUS)</link> release.</simpara>
</listitem>
</varlistentry>
</variablelist>
</tip>
<simpara>If a cluster administrator has installed your Operator, before they upgrade to the next version of {product-title}, they must ensure a version of your Operator is installed that is compatible with that next cluster version. While it is recommended that you update your Operator projects to no longer use deprecated or removed APIs, if you still need to publish your Operator bundles with removed APIs for continued use on earlier versions of {product-title}, ensure that the bundle is configured accordingly.</simpara>
<simpara>The following procedure helps prevent administrators from installing versions of your Operator on an incompatible version of {product-title}. These steps also prevent administrators from upgrading to a newer version of {product-title} that is incompatible with the version of your Operator that is currently installed on their cluster.</simpara>
<simpara>This procedure is also useful when you know that the current version of your Operator will not work well, for any reason, on a specific {product-title} version. By defining the cluster versions where the Operator should be distributed, you ensure that the Operator does not appear in a catalog of a cluster version which is outside of the allowed range.</simpara>
<important>
<simpara>Operators that use deprecated APIs can adversely impact critical workloads when cluster administrators upgrade to a future version of {product-title} where the API is no longer supported. If your Operator is using deprecated APIs, you should configure the following settings in your Operator project as soon as possible.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An existing Operator project</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If you know that a specific bundle of your Operator is not supported and will not work correctly on {product-title} later than a certain cluster version, configure the maximum version of {product-title} that your Operator is compatible with. In your Operator project&#8217;s cluster service version (CSV), set the <literal>olm.maxOpenShiftVersion</literal> annotation to prevent administrators from upgrading their cluster before upgrading the installed Operator to a compatible version:</simpara>
<important>
<simpara>You must use <literal>olm.maxOpenShiftVersion</literal> annotation only if your Operator bundle version cannot work in later versions. Be aware that cluster admins cannot upgrade their clusters with your solution installed. If you do not provide later version and a valid upgrade path, administrators may uninstall your Operator and can upgrade the cluster version.</simpara>
</important>
<formalpara>
<title>Example CSV with <literal>olm.maxOpenShiftVersion</literal> annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: ClusterServiceVersion
metadata:
  annotations:
    "olm.properties": '[{"type": "olm.maxOpenShiftVersion", "value": "&lt;cluster_version&gt;"}]' <co xml:id="CO89-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO89-1">
<para>Specify the maximum cluster version of {product-title} that your Operator is compatible with. For example, setting <literal>value</literal> to <literal>4.9</literal> prevents cluster upgrades to {product-title} versions later than 4.9 when this bundle is installed on a cluster.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If your bundle is intended for distribution in a Red Hat-provided Operator catalog, configure the compatible versions of {product-title} for your Operator by setting the following properties. This configuration ensures your Operator is only included in catalogs that target compatible versions of {product-title}:</simpara>
<note>
<simpara>This step is only valid when publishing Operators in Red Hat-provided catalogs. If your bundle is only intended for distribution in a custom catalog, you can skip this step. For more details, see "Red Hat-provided Operator catalogs".</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set the <literal>com.redhat.openshift.versions</literal> annotation in your project&#8217;s <literal>bundle/metadata/annotations.yaml</literal> file:</simpara>
<formalpara>
<title>Example <literal>bundle/metadata/annotations.yaml</literal> file with compatible versions</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">com.redhat.openshift.versions: "v4.7-v4.9" <co xml:id="CO90-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO90-1">
<para>Set to a range or single version.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To prevent your bundle from being carried on to an incompatible version of {product-title}, ensure that the index image is generated with the proper <literal>com.redhat.openshift.versions</literal> label in your Operator&#8217;s bundle image. For example, if your project was generated using the Operator SDK, update the <literal>bundle.Dockerfile</literal> file:</simpara>
<formalpara>
<title>Example <literal>bundle.Dockerfile</literal> with compatible versions</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">LABEL com.redhat.openshift.versions="&lt;versions&gt;" <co xml:id="CO91-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO91-1">
<para>Set to a range or single version, for example, <literal>v4.7-v4.9</literal>. This setting defines the cluster versions where the Operator should be distributed, and the Operator does not appear in a catalog of a cluster version which is outside of the range.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>You can now bundle a new version of your Operator and publish the updated version to a catalog for distribution.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="https://redhat-connect.gitbook.io/certified-operator-guide/ocp-deployment/operator-metadata/bundle-directory/managing-openshift-versions">Managing OpenShift Versions</link> in the <emphasis>Certified Operator Build Guide</emphasis></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs">Red Hat-provided Operator catalogs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-working-bundle-images-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">Operator Framework packaging format</link> for details on the bundle format.</simpara>
</listitem>
<listitem>
<simpara>See <link xl:href="../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs">Managing custom catalogs</link> for details on adding bundle images to index images by using the <literal>opm</literal> command.</simpara>
</listitem>
<listitem>
<simpara>See <link xl:href="../../operators/understanding/olm/olm-workflow.xml#olm-workflow">Operator Lifecycle Manager workflow</link> for details on how upgrades work for installed Operators.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-complying-with-psa">
<title>Complying with pod security admission</title>

<simpara><emphasis>Pod security admission</emphasis> is an implementation of the <link xl:href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Kubernetes pod security standards</link>. <link xl:href="https://kubernetes.io/docs/concepts/security/pod-security-admission/">Pod security admission</link> restricts the behavior of pods. Pods that do not comply with the pod security admission defined globally or at the namespace level are not admitted to the cluster and cannot run.</simpara>
<simpara>If your Operator project does not require escalated permissions to run, you can ensure your workloads run in namespaces set to the <literal>restricted</literal> pod security level. If your Operator project requires escalated permissions to run, you must set the following security context configurations:</simpara>
<itemizedlist>
<listitem>
<simpara>The allowed pod security admission level for the Operator&#8217;s namespace</simpara>
</listitem>
<listitem>
<simpara>The allowed security context constraints (SCC) for the workload&#8217;s service account</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see <link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link>.</simpara>
<section xml:id="security-context-constraints-psa-about_osdk-complying-with-psa">
<title>About pod security admission</title>
<simpara>{product-title} includes <link xl:href="https://kubernetes.io/docs/concepts/security/pod-security-admission">Kubernetes pod security admission</link>. Pods that do not comply with the pod security admission defined globally or at the namespace level are not admitted to the cluster and cannot run.</simpara>
<simpara>Globally, the <literal>privileged</literal> profile is enforced, and the <literal>restricted</literal> profile is used for warnings and audits.</simpara>
<simpara>You can also configure the pod security admission settings at the namespace level.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<section xml:id="psa-modes_osdk-complying-with-psa">
<title>Pod security admission modes</title>
<simpara>You can configure the following pod security admission modes for a namespace:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security admission modes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="50.0001*"/>
<thead>
<row>
<entry align="left" valign="top">Mode</entry>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>enforce</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/enforce</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rejects a pod from admission if it does not comply with the set profile</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>audit</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/audit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs audit events if a pod does not comply with the set profile</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>warn</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/warn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Displays warnings if a pod does not comply with the set profile</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="psa-profiles_osdk-complying-with-psa">
<title>Pod security admission profiles</title>
<simpara>You can set each of the pod security admission modes to one of the following profiles:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security admission profiles</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>privileged</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Least restrictive policy; allows for known privilege escalation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>baseline</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Minimally restrictive policy; prevents known privilege escalations</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>restricted</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Most restrictive policy; follows current pod hardening best practices</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="psa-privileged-namespaces_osdk-complying-with-psa">
<title>Privileged namespaces</title>
<simpara>The following system namespaces are always set to the <literal>privileged</literal> pod security admission profile:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>default</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-public</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-system</literal></simpara>
</listitem>
</itemizedlist>
<simpara>You cannot change the pod security profile for these privileged namespaces.</simpara>
</section>
</section>
<section xml:id="security-context-constraints-psa-synchronization_osdk-complying-with-psa">
<title>About pod security admission synchronization</title>
<simpara>In addition to the global pod security admission control configuration, a controller applies pod security admission control <literal>warn</literal> and <literal>audit</literal> labels to namespaces according to the SCC permissions of the service accounts that are in a given namespace.</simpara>
<simpara>The controller examines <literal>ServiceAccount</literal> object permissions to use security context constraints in each namespace. Security context constraints (SCCs) are mapped to pod security profiles based on their field values; the controller uses these translated profiles. Pod security admission <literal>warn</literal> and <literal>audit</literal> labels are set to the most privileged pod security profile in the namespace to prevent displaying warnings and logging audit events when pods are created.</simpara>
<simpara>Namespace labeling is based on consideration of namespace-local service account privileges.</simpara>
<simpara>Applying pods directly might use the SCC privileges of the user who runs the pod. However, user privileges are not considered during automatic labeling.</simpara>
<section xml:id="security-context-constraints-psa-sync-exclusions_osdk-complying-with-psa">
<title>Pod security admission synchronization namespace exclusions</title>
<simpara>Pod security admission synchronization is permanently disabled on most system-created namespaces. Synchronization is also initially disabled on user-created <literal>openshift-*</literal> prefixed namespaces, but you can enable synchronization on them later.</simpara>
<important>
<simpara>If a pod security admission label (<literal>pod-security.kubernetes.io/&lt;mode&gt;</literal>) is manually modified from the automatically labeled value on a label-synchronized namespace, synchronization is disabled for that label.</simpara>
<simpara>If necessary, you can enable synchronization again by using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>By removing the modified pod security admission label from the namespace</simpara>
</listitem>
<listitem>
<simpara>By setting the <literal>security.openshift.io/scc.podSecurityLabelSync</literal> label to <literal>true</literal></simpara>
<simpara>If you force synchronization by adding this label, then any modified pod security admission labels will be overwritten.</simpara>
</listitem>
</itemizedlist>
</important>
<bridgehead xml:id="_permanently_disabled_namespaces" renderas="sect5">Permanently disabled namespaces</bridgehead>
<simpara>Namespaces that are defined as part of the cluster payload have pod security admission synchronization disabled permanently. The following namespaces are permanently disabled:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>default</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-node-lease</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-system</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-public</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift</literal></simpara>
</listitem>
<listitem>
<simpara>All system-created namespaces that are prefixed with <literal>openshift-</literal>
, except for <literal>openshift-operators</literal></simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_initially_disabled_namespaces" renderas="sect5">Initially disabled namespaces</bridgehead>
<simpara>By default, all namespaces that have an <literal>openshift-</literal> prefix have pod security admission synchronization disabled initially. You can enable synchronization for user-created <literal>openshift-*</literal> namespaces and for the <literal>openshift-operators</literal> namespace.</simpara>
<note>
<simpara>You cannot enable synchronization for any system-created <literal>openshift-*</literal> namespaces, except for <literal>openshift-operators</literal>.</simpara>
</note>
<simpara>If an Operator is installed in a user-created <literal>openshift-*</literal> namespace, synchronization is enabled automatically after a cluster service version (CSV) is created in the namespace. The synchronized label is derived from the permissions of the service accounts in the namespace.</simpara>
</section>
</section>
<section xml:id="osdk-ensuring-operator-workloads-run-restricted-psa_osdk-complying-with-psa">
<title>Ensuring Operator workloads run in namespaces set to the restricted pod security level</title>
<simpara>To ensure your Operator project can run on a wide variety of deployments and environments, configure the Operator&#8217;s workloads to run in namespaces set to the <literal>restricted</literal> pod security level.</simpara>
<warning>
<simpara>You must leave the <literal>runAsUser</literal> field empty. If your image requires a specific user, it cannot be run under restricted security context constraints (SCC) and restricted pod security enforcement.</simpara>
</warning>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To configure Operator workloads to run in namespaces set to the <literal>restricted</literal> pod security level, edit your Operator&#8217;s namespace definition similar to the following examples:</simpara>
<important>
<simpara>It is recommended that you set the seccomp profile in your Operator&#8217;s namespace definition. However, setting the seccomp profile is not supported in {product-title} 4.10.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara>For Operator projects that must run in only {product-title} 4.11 and later, edit your Operator&#8217;s namespace definition similar to the following example:</simpara>
<formalpara>
<title>Example <literal>config/manager/manager.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
 securityContext:
   seccompProfile:
     type: RuntimeDefault <co xml:id="CO92-1"/>
   runAsNonRoot: true
 containers:
   - name: &lt;operator_workload_container&gt;
     securityContext:
       allowPrivilegeEscalation: false
       capabilities:
         drop:
           - ALL
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO92-1">
<para>By setting the seccomp profile type to <literal>RuntimeDefault</literal>, the SCC defaults to the pod security profile of the namespace.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>For Operator projects that must also run in {product-title} 4.10, edit your Operator&#8217;s namespace definition similar to the following example:</simpara>
<formalpara>
<title>Example <literal>config/manager/manager.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
 securityContext: <co xml:id="CO93-1"/>
   runAsNonRoot: true
 containers:
   - name: &lt;operator_workload_container&gt;
     securityContext:
       allowPrivilegeEscalation: false
       capabilities:
         drop:
           - ALL
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO93-1">
<para>Leaving the seccomp profile type unset ensures your Operator project can run in {product-title} 4.10.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../authentication/managing-security-context-constraints.xml#managing-security-context-constraints">Managing security context constraints</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-managing-psa-for-operators-with-escalated-permissions_osdk-complying-with-psa">
<title>Managing pod security admission for Operator workloads that require escalated permissions</title>
<simpara>If your Operator project requires escalated permissions to run, you must edit your Operator&#8217;s cluster service version (CSV).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the security context configuration to the required permission level in your Operator&#8217;s CSV, similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;operator_name&gt;.clusterserviceversion.yaml</literal> file with network administrator privileges</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
containers:
   - name: my-container
     securityContext:
       allowPrivilegeEscalation: false
       capabilities:
         add:
           - "NET_ADMIN"
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set the service account privileges that allow your Operator&#8217;s workloads to use the required security context constraints (SCC), similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;operator_name&gt;.clusterserviceversion.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
  install:
    spec:
      clusterPermissions:
      - rules:
        - apiGroups:
          - security.openshift.io
          resourceNames:
          - privileged
          resources:
          - securitycontextconstraints
          verbs:
          - use
        serviceAccountName: default
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Edit your Operator&#8217;s CSV description to explain why your Operator project requires escalated permissions similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;operator_name&gt;.clusterserviceversion.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
  apiservicedefinitions:{}
  ...
description: The &lt;operator_name&gt; requires a privileged pod security admission label set on the Operator's namespace. The Operator's agents require escalated permissions to restart the node if the node needs remediation.</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-complying-with-psa-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-token-auth">
<title>Token authentication for Operators on cloud providers</title>

<simpara>Many cloud providers can enable authentication by using account tokens that provide short-term, limited-privilege security credentials.</simpara>
<simpara>{product-title} includes the Cloud Credential Operator (CCO) to manage cloud provider credentials as custom resource definitions (CRDs). The CCO syncs on <literal>CredentialsRequest</literal> custom resources (CRs) to allow {product-title} components to request cloud provider credentials with any specific permissions required.</simpara>
<simpara>Previously, on clusters where the CCO is in <emphasis>manual mode</emphasis>, Operators managed by Operator Lifecycle Manager (OLM) often provided detailed instructions in the OperatorHub for how users could manually provision any required cloud credentials.</simpara>
<simpara>Starting in {product-title} 4.14, the CCO can detect when it is running on clusters enabled to use short-term credentials on certain cloud providers. It can then semi-automate provisioning certain credentials, provided that the Operator author has enabled their Operator to support the updated CCO.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../authentication/managing_cloud_provider_credentials/about-cloud-credential-operator.xml#about-cloud-credential-operator">About the Cloud Credential Operator</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-cco-aws-sts_osdk-token-auth">
<title>CCO-based workflow for OLM-managed Operators with AWS STS</title>
<simpara>When an {product-title} cluster running on AWS is in Security Token Service (STS) mode, it means the cluster is utilizing features of AWS and {product-title} to use IAM roles at an application level. STS enables applications to provide a JSON Web Token (JWT) that can assume an IAM role.</simpara>
<simpara>The JWT includes an Amazon Resource Name (ARN) for the <literal>sts:AssumeRoleWithWebIdentity</literal> IAM action to allow temporarily-granted permission for the service account. The JWT contains the signing keys for the <literal>ProjectedServiceAccountToken</literal> that AWS IAM can validate. The service account token itself, which is signed, is used as the JWT required for assuming the AWS role.</simpara>
<simpara>The Cloud Credential Operator (CCO) is a cluster Operator installed by default in {product-title} clusters running on cloud providers. For the purposes of STS, the CCO provides the following functions:</simpara>
<itemizedlist>
<listitem>
<simpara>Detects when it is running on an STS-enabled cluster</simpara>
</listitem>
<listitem>
<simpara>Checks for the presence of fields in the <literal>CredentialsRequest</literal> object that provide the required information for granting Operators access to AWS resources</simpara>
</listitem>
</itemizedlist>
<simpara>The CCO performs this detection even when in manual mode. When properly configured, the CCO projects a <literal>Secret</literal> object with the required access information into the Operator namespace.</simpara>
<simpara>Starting in {product-title} 4.14, the CCO can semi-automate this task through an expanded use of <literal>CredentialsRequest</literal> objects, which can request the creation of <literal>Secrets</literal> that contain the information required for STS workflows. Users can provide a role ARN when installing the Operator from either the web console or CLI.</simpara>
<note>
<simpara>Subscriptions with automatic update approvals are not recommended because there might be permission changes to make prior to updating. Subscriptions with manual update approvals ensure that administrators have the opportunity to verify the permissions of the later version and take any necessary steps prior to update.</simpara>
</note>
<simpara>As an Operator author preparing an Operator for use alongside the updated CCO in {product-title} 4.14 or later, you should instruct users and add code to handle the divergence from earlier CCO versions, in addition to handling STS token authentication (if your Operator is not already STS-enabled). The recommended method is to provide a <literal>CredentialsRequest</literal> object with correctly filled STS-related fields and let the CCO create the <literal>Secret</literal> for you.</simpara>
<important>
<simpara>If you plan to support {product-title} clusters earlier than version 4.14, consider providing users with instructions on how to manually create a secret with the STS-enabling information by using the CCO utility (<literal>ccoctl</literal>). Earlier CCO versions are unaware of STS mode on the cluster and cannot create secrets for you.</simpara>
<simpara>Your code should check for secrets that never appear and warn users to follow the fallback instructions you have provided. For more information, see the "Alternative method" subsection.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../authentication/managing_cloud_provider_credentials/cco-short-term-creds.xml#cco-short-term-creds-aws-olm_cco-short-term-creds">OLM-managed Operator support for authentication with AWS STS</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-from-operatorhub-using-web-console_olm-adding-operators-to-a-cluster">Installing from OperatorHub using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-adding-operators-to-cluster.xml#olm-installing-operator-from-operatorhub-using-cli_olm-adding-operators-to-a-cluster">Installing from OperatorHub using the CLI</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-cco-aws-sts-enabling_osdk-token-auth">
<title>Enabling Operators to support CCO-based workflows with AWS STS</title>
<simpara>As an Operator author designing your project to run on Operator Lifecycle Manager (OLM), you can enable your Operator to authenticate against AWS on STS-enabled {product-title} clusters by customizing your project to support the Cloud Credential Operator (CCO).</simpara>
<simpara>With this method, the Operator is responsible for creating the <literal>CredentialsRequest</literal> object, which means the Operator requires RBAC permission to create these objects. Then, the Operator must be able to read the resulting <literal>Secret</literal> object.</simpara>
<note>
<simpara>By default, pods related to the Operator deployment mount a <literal>serviceAccountToken</literal> volume so that the service account token can be referenced in the resulting <literal>Secret</literal> object.</simpara>
</note>
<itemizedlist>
<title>Prerequisities</title>
<listitem>
<simpara>{product-title} 4.14 or later</simpara>
</listitem>
<listitem>
<simpara>Cluster in STS mode</simpara>
</listitem>
<listitem>
<simpara>OLM-based Operator project</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update your Operator project&#8217;s <literal>ClusterServiceVersion</literal> (CSV) object:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Ensure your Operator has RBAC permission to create <literal>CredentialsRequests</literal> objects:</simpara>
<example>
<title>Example <literal>clusterPermissions</literal> list</title>
<programlisting language="yaml" linenumbering="unnumbered"># ...
install:
  spec:
    clusterPermissions:
    - rules:
      - apiGroups:
        - "cloudcredential.openshift.io"
        resources:
        - credentialsrequests
        verbs:
        - create
        - delete
        - get
        - list
        - patch
        - update
        - watch</programlisting>
</example>
</listitem>
<listitem>
<simpara>Add the following annotation to claim support for this method of CCO-based workflow with AWS STS:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># ...
metadata:
 annotations:
   features.operators.openshift.io/token-auth-aws: "true"</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update your Operator project code:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get the role ARN from the environment variable set on the pod by the <literal>Subscription</literal> object. For example:</simpara>
<programlisting language="go" linenumbering="unnumbered">// Get ENV var
roleARN := os.Getenv("ROLEARN")
setupLog.Info("getting role ARN", "role ARN = ", roleARN)
webIdentityTokenPath := "/var/run/secrets/openshift/serviceaccount/token"</programlisting>
</listitem>
<listitem>
<simpara>Ensure you have a <literal>CredentialsRequest</literal> object ready to be patched and applied. For example:</simpara>
<example>
<title>Example <literal>CredentialsRequest</literal> object creation</title>
<programlisting language="go" linenumbering="unnumbered">import (
   minterv1 "github.com/openshift/cloud-credential-operator/pkg/apis/cloudcredential/v1"
   corev1 "k8s.io/api/core/v1"
   metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var in = minterv1.AWSProviderSpec{
   StatementEntries: []minterv1.StatementEntry{
      {
         Action: []string{
            "s3:*",
         },
         Effect:   "Allow",
         Resource: "arn:aws:s3:*:*:*",
      },
   },
	STSIAMRoleARN: "&lt;role_arn&gt;",
}

var codec = minterv1.Codec
var ProviderSpec, _ = codec.EncodeProviderSpec(in.DeepCopyObject())

const (
   name      = "&lt;credential_request_name&gt;"
   namespace = "&lt;namespace_name&gt;"
)

var CredentialsRequestTemplate = &amp;minterv1.CredentialsRequest{
   ObjectMeta: metav1.ObjectMeta{
       Name:      name,
       Namespace: "openshift-cloud-credential-operator",
   },
   Spec: minterv1.CredentialsRequestSpec{
      ProviderSpec: ProviderSpec,
      SecretRef: corev1.ObjectReference{
         Name:      "&lt;secret_name&gt;",
         Namespace: namespace,
      },
      ServiceAccountNames: []string{
         "&lt;service_account_name&gt;",
      },
      CloudTokenPath:   "",
   },
}</programlisting>
</example>
<simpara>Alternatively, if you are starting from a <literal>CredentialsRequest</literal> object in YAML form (for example, as part of your Operator project code), you can handle it differently:</simpara>
<example>
<title>Example <literal>CredentialsRequest</literal> object creation in YAML form</title>
<programlisting language="go" linenumbering="unnumbered">// CredentialsRequest is a struct that represents a request for credentials
type CredentialsRequest struct {
  APIVersion string `yaml:"apiVersion"`
  Kind       string `yaml:"kind"`
  Metadata   struct {
     Name      string `yaml:"name"`
     Namespace string `yaml:"namespace"`
  } `yaml:"metadata"`
  Spec struct {
     SecretRef struct {
        Name      string `yaml:"name"`
        Namespace string `yaml:"namespace"`
     } `yaml:"secretRef"`
     ProviderSpec struct {
        APIVersion     string `yaml:"apiVersion"`
        Kind           string `yaml:"kind"`
        StatementEntries []struct {
           Effect   string   `yaml:"effect"`
           Action   []string `yaml:"action"`
           Resource string   `yaml:"resource"`
        } `yaml:"statementEntries"`
        STSIAMRoleARN   string `yaml:"stsIAMRoleARN"`
     } `yaml:"providerSpec"`

     // added new field
      CloudTokenPath   string `yaml:"cloudTokenPath"`
  } `yaml:"spec"`
}

// ConsumeCredsRequestAddingTokenInfo is a function that takes a YAML filename and two strings as arguments
// It unmarshals the YAML file to a CredentialsRequest object and adds the token information.
func ConsumeCredsRequestAddingTokenInfo(fileName, tokenString, tokenPath string) (*CredentialsRequest, error) {
  // open a file containing YAML form of a CredentialsRequest
  file, err := os.Open(fileName)
  if err != nil {
     return nil, err
  }
  defer file.Close()

  // create a new CredentialsRequest object
  cr := &amp;CredentialsRequest{}

  // decode the yaml file to the object
  decoder := yaml.NewDecoder(file)
  err = decoder.Decode(cr)
  if err != nil {
     return nil, err
  }

  // assign the string to the existing field in the object
  cr.Spec.CloudTokenPath = tokenPath

  // return the modified object
  return cr, nil
}</programlisting>
</example>
<note>
<simpara>Adding a <literal>CredentialsRequest</literal> object to the Operator bundle is not currently supported.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add the role ARN and web identity token path to the credentials request and apply it during Operator initialization:</simpara>
<example>
<title>Example applying <literal>CredentialsRequest</literal> object during Operator initialization</title>
<programlisting language="go" linenumbering="unnumbered">// apply credentialsRequest on install
credReq := credreq.CredentialsRequestTemplate
credReq.Spec.CloudTokenPath = webIdentityTokenPath

c := mgr.GetClient()
if err := c.Create(context.TODO(), credReq); err != nil {
   if !errors.IsAlreadyExists(err) {
      setupLog.Error(err, "unable to create CredRequest")
      os.Exit(1)
   }
}</programlisting>
</example>
</listitem>
<listitem>
<simpara>Ensure your Operator can wait for a <literal>Secret</literal> object to show up from the CCO, as shown in the following example, which is called along with the other items you are reconciling in your Operator:</simpara>
<example>
<title>Example wait for <literal>Secret</literal> object</title>
<programlisting language="go" linenumbering="unnumbered">// WaitForSecret is a function that takes a Kubernetes client, a namespace, and a v1 "k8s.io/api/core/v1" name as arguments
// It waits until the secret object with the given name exists in the given namespace
// It returns the secret object or an error if the timeout is exceeded
func WaitForSecret(client kubernetes.Interface, namespace, name string) (*v1.Secret, error) {
  // set a timeout of 10 minutes
  timeout := time.After(10 * time.Minute) <co xml:id="CO94-1"/>

  // set a polling interval of 10 seconds
  ticker := time.NewTicker(10 * time.Second)

  // loop until the timeout or the secret is found
  for {
     select {
     case &lt;-timeout:
        // timeout is exceeded, return an error
        return nil, fmt.Errorf("timed out waiting for secret %s in namespace %s", name, namespace)
           // add to this error with a pointer to instructions for following a manual path to a Secret that will work on STS
     case &lt;-ticker.C:
        // polling interval is reached, try to get the secret
        secret, err := client.CoreV1().Secrets(namespace).Get(context.Background(), name, metav1.GetOptions{})
        if err != nil {
           if errors.IsNotFound(err) {
              // secret does not exist yet, continue waiting
              continue
           } else {
              // some other error occurred, return it
              return nil, err
           }
        } else {
           // secret is found, return it
           return secret, nil
        }
     }
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO94-1">
<para>The <literal>timeout</literal> value is based on an estimate of how fast the CCO might detect an added <literal>CredentialsRequest</literal> object and generate a <literal>Secret</literal> object. You might consider lowering the time or creating custom feedback for cluster administrators that could be wondering why the Operator is not yet accessing the cloud resources.</para>
</callout>
</calloutlist>
</example>
</listitem>
<listitem>
<simpara>Set up the AWS configuration by reading the secret created by the CCO from the credentials request and creating the AWS config file containing the data from that secret:</simpara>
<example>
<title>Example AWS configuration creation</title>
<programlisting language="go" linenumbering="unnumbered">func SharedCredentialsFileFromSecret(secret *corev1.Secret) (string, error) {
   var data []byte
   switch {
   case len(secret.Data["credentials"]) &gt; 0:
       data = secret.Data["credentials"]
   default:
       return "", errors.New("invalid secret for aws credentials")
   }


   f, err := ioutil.TempFile("", "aws-shared-credentials")
   if err != nil {
       return "", errors.Wrap(err, "failed to create file for shared credentials")
   }
   defer f.Close()
   if _, err := f.Write(data); err != nil {
       return "", errors.Wrapf(err, "failed to write credentials to %s", f.Name())
   }
   return f.Name(), nil
}</programlisting>
</example>
<important>
<simpara>The secret is assumed to exist, but your Operator code should wait and retry when using this secret to give time to the CCO to create the secret.</simpara>
<simpara>Additionally, the wait period should eventually time out and warn users that the {product-title} cluster version, and therefore the CCO, might be an earlier version that does not support the <literal>CredentialsRequest</literal> object workflow with STS detection. In such cases, instruct users that they must add a secret by using another method.</simpara>
</important>
</listitem>
<listitem>
<simpara>Configure the AWS SDK session, for example:</simpara>
<example>
<title>Example AWS SDK session configuration</title>
<programlisting language="go" linenumbering="unnumbered">sharedCredentialsFile, err := SharedCredentialsFileFromSecret(secret)
if err != nil {
   // handle error
}
options := session.Options{
   SharedConfigState: session.SharedConfigEnable,
   SharedConfigFiles: []string{sharedCredentialsFile},
}</programlisting>
</example>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-cco-aws-sts-role_osdk-token-auth">
<title>Role specification</title>
<simpara>The Operator description should contain the specifics of the role required to be created before installation, ideally in the form of a script that the administrator can run. For example:</simpara>
<example>
<title>Example role creation script</title>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash
set -x

AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
OIDC_PROVIDER=$(oc get authentication cluster -ojson | jq -r .spec.serviceAccountIssuer | sed -e "s/^https:\/\///")
NAMESPACE=my-namespace
SERVICE_ACCOUNT_NAME="my-service-account"
POLICY_ARN_STRINGS="arn:aws:iam::aws:policy/AmazonS3FullAccess"


read -r -d '' TRUST_RELATIONSHIP &lt;&lt;EOF
{
 "Version": "2012-10-17",
 "Statement": [
   {
     "Effect": "Allow",
     "Principal": {
       "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/${OIDC_PROVIDER}"
     },
     "Action": "sts:AssumeRoleWithWebIdentity",
     "Condition": {
       "StringEquals": {
         "${OIDC_PROVIDER}:sub": "system:serviceaccount:${NAMESPACE}:${SERVICE_ACCOUNT_NAME}"
       }
     }
   }
 ]
}
EOF

echo "${TRUST_RELATIONSHIP}" &gt; trust.json

aws iam create-role --role-name "$SERVICE_ACCOUNT_NAME" --assume-role-policy-document file://trust.json --description "role for demo"

while IFS= read -r POLICY_ARN; do
   echo -n "Attaching $POLICY_ARN ... "
   aws iam attach-role-policy \
       --role-name "$SERVICE_ACCOUNT_NAME" \
       --policy-arn "${POLICY_ARN}"
   echo "ok."
done &lt;&lt;&lt; "$POLICY_ARN_STRINGS"</programlisting>
</example>
</section>
<section xml:id="osdk-cco-aws-sts-tshooting_osdk-token-auth">
<title>Troubleshooting</title>
<section xml:id="osdk-cco-aws-sts-tshooting-auth-fail_osdk-token-auth">
<title>Authentication failure</title>
<simpara>If authentication was not successful, ensure you can assume the role with web identity by using the token provided to the Operator.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Extract the token from the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec operator-pod -n &lt;namespace_name&gt; \
    -- cat /var/run/secrets/openshift/serviceaccount/token</programlisting>
</listitem>
<listitem>
<simpara>Extract the role ARN from the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec operator-pod -n &lt;namespace_name&gt; \
    -- cat /&lt;path&gt;/&lt;to&gt;/&lt;secret_name&gt; <co xml:id="CO95-1"/></programlisting>
<calloutlist>
<callout arearefs="CO95-1">
<para>Do not use root for the path.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Try assuming the role with the web identity token:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ aws sts assume-role-with-web-identity \
    --role-arn $ROLEARN \
    --role-session-name &lt;session_name&gt; \
    --web-identity-token $TOKEN</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-cco-aws-sts-tshooting-mounting_osdk-token-auth">
<title>Secret not mounting correctly</title>
<simpara>Pods that run as non-root users cannot write to the <literal>/root</literal> directory where the AWS shared credentials file is expected to exist by default. If the secret is not mounting correctly to the AWS credentials file path, consider mounting the secret to a different location and enabling the shared credentials file option in the AWS SDK.</simpara>
</section>
</section>
<section xml:id="osdk-cco-aws-sts-alt_osdk-token-auth">
<title>Alternative method</title>
<simpara>As an alternative method for Operator authors, you can indicate that the user is responsible for creating the <literal>CredentialsRequest</literal> object for the Cloud Credential Operator (CCO) before installing the Operator.</simpara>
<simpara>The Operator instructions must indicate the following to users:</simpara>
<itemizedlist>
<listitem>
<simpara>Provide a YAML version of a <literal>CredentialsRequest</literal> object, either by providing the YAML inline in the instructions or pointing users to a download location</simpara>
</listitem>
<listitem>
<simpara>Instruct the user to create the <literal>CredentialsRequest</literal> object</simpara>
</listitem>
</itemizedlist>
<simpara>In {product-title} 4.14 and later, after the <literal>CredentialsRequest</literal> object appears on the cluster with the appropriate STS information added, the Operator can then read the CCO-generated <literal>Secret</literal> or mount it, having defined the mount in the cluster service version (CSV).</simpara>
<simpara>For earlier versions of {product-title}, the Operator instructions must also indicate the following to users:</simpara>
<itemizedlist>
<listitem>
<simpara>Use the CCO utility (<literal>ccoctl</literal>) to generate the <literal>Secret</literal> YAML object from the <literal>CredentialsRequest</literal> object</simpara>
</listitem>
<listitem>
<simpara>Apply the <literal>Secret</literal> object to the cluster in the appropriate namespace</simpara>
</listitem>
</itemizedlist>
<simpara>The Operator still must be able to consume the resulting secret to communicate with cloud APIs. Because in this case the secret is created by the user before the Operator is installed, the Operator can do either of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Define an explicit mount in the <literal>Deployment</literal> object within the CSV</simpara>
</listitem>
<listitem>
<simpara>Programmatically read the <literal>Secret</literal> object from the API server, as shown in the recommended "Enabling Operators to support CCO-based workflows with AWS STS" method</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="osdk-scorecard">
<title>Validating Operators using the scorecard tool</title>

<simpara>As an Operator author, you can use the scorecard tool in the Operator SDK to do the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Validate that your Operator project is free of syntax errors and packaged correctly</simpara>
</listitem>
<listitem>
<simpara>Review suggestions about ways you can improve your Operator</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-about-scorecard_osdk-scorecard">
<title>About the scorecard tool</title>
<simpara>While the Operator SDK <literal>bundle validate</literal> subcommand can validate local bundle directories and remote bundle images for content and structure, you can use the <literal>scorecard</literal> command to run tests on your Operator based on a configuration file and test images. These tests are implemented within test images that are configured and constructed to be executed by the scorecard.</simpara>
<simpara>The scorecard assumes it is run with access to a configured Kubernetes cluster, such as {product-title}. The scorecard runs each test within a pod, from which pod logs are aggregated and test results are sent to the console. The scorecard has built-in basic and Operator Lifecycle Manager (OLM) tests and also provides a means to execute custom test definitions.</simpara>
<orderedlist numeration="arabic">
<title>Scorecard workflow</title>
<listitem>
<simpara>Create all resources required by any related custom resources (CRs) and the Operator</simpara>
</listitem>
<listitem>
<simpara>Create a proxy container in the deployment of the Operator to record calls to the API server and run tests</simpara>
</listitem>
<listitem>
<simpara>Examine parameters in the CRs</simpara>
</listitem>
</orderedlist>
<simpara>The scorecard tests make no assumptions as to the state of the Operator being tested. Creating Operators and CRs for an Operators are beyond the scope of the scorecard itself. Scorecard tests can, however, create whatever resources they require if the tests are designed for resource creation.</simpara>
<formalpara>
<title><literal>scorecard</literal> command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard &lt;bundle_dir_or_image&gt; [flags]</programlisting>
</para>
</formalpara>
<simpara>The scorecard requires a positional argument for either the on-disk path to
your Operator bundle or the name of a bundle image.</simpara>
<simpara>For further information about the flags, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard -h</programlisting>
</section>
<section xml:id="osdk-scorecard-config_osdk-scorecard">
<title>Scorecard configuration</title>
<simpara>The scorecard tool uses a configuration that allows you to configure internal plugins, as well as several global configuration options. Tests are driven by a configuration file named <literal>config.yaml</literal>, which is generated by the <literal>make bundle</literal> command, located in your <literal>bundle/</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">./bundle
...
└── tests
    └── scorecard
        └── config.yaml</programlisting>
<formalpara>
<title>Example scorecard configuration file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Configuration
apiversion: scorecard.operatorframework.io/v1alpha3
metadata:
  name: config
stages:
- parallel: true
  tests:
  - image: quay.io/operator-framework/scorecard-test:v1.31.0
    entrypoint:
    - scorecard-test
    - basic-check-spec
    labels:
      suite: basic
      test: basic-check-spec-test
  - image: quay.io/operator-framework/scorecard-test:v1.31.0
    entrypoint:
    - scorecard-test
    - olm-bundle-validation
    labels:
      suite: olm
      test: olm-bundle-validation-test</programlisting>
</para>
</formalpara>
<simpara>The configuration file defines each test that scorecard can execute. The
following fields of the scorecard configuration file define the test as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Configuration field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>image</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Test container image name that implements a test</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>entrypoint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Command and arguments that are invoked in the test image to execute a test</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>labels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Scorecard-defined or custom labels that select which tests to run</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="osdk-scorecard-tests_osdk-scorecard">
<title>Built-in scorecard tests</title>
<simpara>The scorecard ships with pre-defined tests that are arranged into suites: the basic test suite and the Operator Lifecycle Manager (OLM) suite.</simpara>
<table xml:id="osdk-scorecard-basic-tests_osdk-scorecard" frame="all" rowsep="1" colsep="1">
<title>Basic test suite</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="23.0769*"/>
<colspec colname="col_2" colwidth="53.8461*"/>
<colspec colname="col_3" colwidth="23.077*"/>
<thead>
<row>
<entry align="left" valign="top">Test</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Short name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Spec Block Exists</simpara></entry>
<entry align="left" valign="top"><simpara>This test checks the custom resource (CR) created in the cluster to make sure that all CRs have a <literal>spec</literal> block.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>basic-check-spec-test</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table xml:id="osdk-scorecard-olm-tests_osdk-scorecard" frame="all" rowsep="1" colsep="1">
<title>OLM test suite</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="23.0769*"/>
<colspec colname="col_2" colwidth="53.8461*"/>
<colspec colname="col_3" colwidth="23.077*"/>
<thead>
<row>
<entry align="left" valign="top">Test</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Short name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Bundle Validation</simpara></entry>
<entry align="left" valign="top"><simpara>This test validates the bundle manifests found in the bundle that is passed into scorecard. If the bundle contents contain errors, then the test result output includes the validator log as well as error messages from the validation library.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm-bundle-validation-test</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Provided APIs Have Validation</simpara></entry>
<entry align="left" valign="top"><simpara>This test verifies that the custom resource definitions (CRDs) for the provided CRs contain a validation section and that there is validation for each <literal>spec</literal> and <literal>status</literal> field detected in the CR.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm-crds-have-validation-test</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Owned CRDs Have Resources Listed</simpara></entry>
<entry align="left" valign="top"><simpara>This test makes sure that the CRDs for each CR provided via the <literal>cr-manifest</literal> option have a <literal>resources</literal> subsection in the <literal>owned</literal> CRDs section of the ClusterServiceVersion (CSV). If the test detects used resources that are not listed in the resources section, it lists them in the suggestions at the end of the test. Users are required to fill out the resources section after initial code generation for this test to pass.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm-crds-have-resources-test</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Spec Fields With Descriptors</simpara></entry>
<entry align="left" valign="top"><simpara>This test verifies that every field in the CRs <literal>spec</literal> sections has a corresponding descriptor listed in the CSV.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm-spec-descriptors-test</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Status Fields With Descriptors</simpara></entry>
<entry align="left" valign="top"><simpara>This test verifies that every field in the CRs <literal>status</literal> sections have a corresponding descriptor listed in the CSV.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>olm-status-descriptors-test</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="osdk-scorecard-run_osdk-scorecard">
<title>Running the scorecard tool</title>
<simpara>A default set of Kustomize files are generated by the Operator SDK after running the <literal>init</literal> command. The default <literal>bundle/tests/scorecard/config.yaml</literal> file that is generated can be immediately used to run the scorecard tool against your Operator, or you can modify this file to your test specifications.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator project generated by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Generate or regenerate your bundle manifests and metadata for your Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make bundle</programlisting>
<simpara>This command automatically adds scorecard annotations to your bundle metadata, which is used by the <literal>scorecard</literal> command to run tests.</simpara>
</listitem>
<listitem>
<simpara>Run the scorecard against the on-disk path to your Operator bundle or the name of a bundle image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard &lt;bundle_dir_or_image&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-scorecard-output_osdk-scorecard">
<title>Scorecard output</title>
<simpara>The <literal>--output</literal> flag for the <literal>scorecard</literal> command specifies the scorecard results output format: either <literal>text</literal> or <literal>json</literal>.</simpara>
<example>
<title>Example JSON output snippet</title>
<programlisting language="json" linenumbering="unnumbered">{
  "apiVersion": "scorecard.operatorframework.io/v1alpha3",
  "kind": "TestList",
  "items": [
    {
      "kind": "Test",
      "apiVersion": "scorecard.operatorframework.io/v1alpha3",
      "spec": {
        "image": "quay.io/operator-framework/scorecard-test:v1.31.0",
        "entrypoint": [
          "scorecard-test",
          "olm-bundle-validation"
        ],
        "labels": {
          "suite": "olm",
          "test": "olm-bundle-validation-test"
        }
      },
      "status": {
        "results": [
          {
            "name": "olm-bundle-validation",
            "log": "time=\"2020-06-10T19:02:49Z\" level=debug msg=\"Found manifests directory\" name=bundle-test\ntime=\"2020-06-10T19:02:49Z\" level=debug msg=\"Found metadata directory\" name=bundle-test\ntime=\"2020-06-10T19:02:49Z\" level=debug msg=\"Getting mediaType info from manifests directory\" name=bundle-test\ntime=\"2020-06-10T19:02:49Z\" level=info msg=\"Found annotations file\" name=bundle-test\ntime=\"2020-06-10T19:02:49Z\" level=info msg=\"Could not find optional dependencies file\" name=bundle-test\n",
            "state": "pass"
          }
        ]
      }
    }
  ]
}</programlisting>
</example>
<example>
<title>Example text output snippet</title>
<programlisting language="text" linenumbering="unnumbered">--------------------------------------------------------------------------------
Image:      quay.io/operator-framework/scorecard-test:v1.31.0
Entrypoint: [scorecard-test olm-bundle-validation]
Labels:
	"suite":"olm"
	"test":"olm-bundle-validation-test"
Results:
	Name: olm-bundle-validation
	State: pass
	Log:
		time="2020-07-15T03:19:02Z" level=debug msg="Found manifests directory" name=bundle-test
		time="2020-07-15T03:19:02Z" level=debug msg="Found metadata directory" name=bundle-test
		time="2020-07-15T03:19:02Z" level=debug msg="Getting mediaType info from manifests directory" name=bundle-test
		time="2020-07-15T03:19:02Z" level=info msg="Found annotations file" name=bundle-test
		time="2020-07-15T03:19:02Z" level=info msg="Could not find optional dependencies file" name=bundle-test</programlisting>
</example>
<note>
<simpara>The output format spec matches the <link xl:href="https://pkg.go.dev/github.com/operator-framework/api/pkg/apis/scorecard/v1alpha3#Test"><literal>Test</literal></link> type layout.</simpara>
</note>
</section>
<section xml:id="osdk-scorecard-select-tests_osdk-scorecard">
<title>Selecting tests</title>
<simpara>Scorecard tests are selected by setting the <literal>--selector</literal> CLI flag to a set of label strings. If a selector flag is not supplied, then all of the tests within the scorecard configuration file are run.</simpara>
<simpara>Tests are run serially with test results being aggregated by the scorecard and written to standard output, or <emphasis>stdout</emphasis>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To select a single test, for example <literal>basic-check-spec-test</literal>, specify the test by using the <literal>--selector</literal> flag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard &lt;bundle_dir_or_image&gt; \
    -o text \
    --selector=test=basic-check-spec-test</programlisting>
</listitem>
<listitem>
<simpara>To select a suite of tests, for example <literal>olm</literal>, specify a label that is used by all of the OLM tests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard &lt;bundle_dir_or_image&gt; \
    -o text \
    --selector=suite=olm</programlisting>
</listitem>
<listitem>
<simpara>To select multiple tests, specify the test names by using the <literal>selector</literal> flag using the following syntax:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk scorecard &lt;bundle_dir_or_image&gt; \
    -o text \
    --selector='test in (basic-check-spec-test,olm-bundle-validation-test)'</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-scorecard-parallel_osdk-scorecard">
<title>Enabling parallel testing</title>
<simpara>As an Operator author, you can define separate stages for your tests using the scorecard configuration file. Stages run sequentially in the order they are defined in the configuration file. A stage contains a list of tests and a configurable <literal>parallel</literal> setting.</simpara>
<simpara>By default, or when a stage explicitly sets <literal>parallel</literal> to <literal>false</literal>, tests in a stage are run sequentially in the order they are defined in the configuration file. Running tests one at a time is helpful to guarantee that no two tests interact and conflict with each other.</simpara>
<simpara>However, if tests are designed to be fully isolated, they can be parallelized.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To run a set of isolated tests in parallel, include them in the same stage and set <literal>parallel</literal> to <literal>true</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: scorecard.operatorframework.io/v1alpha3
kind: Configuration
metadata:
  name: config
stages:
- parallel: true <co xml:id="CO96-1"/>
  tests:
  - entrypoint:
    - scorecard-test
    - basic-check-spec
    image: quay.io/operator-framework/scorecard-test:v1.31.0
    labels:
      suite: basic
      test: basic-check-spec-test
  - entrypoint:
    - scorecard-test
    - olm-bundle-validation
    image: quay.io/operator-framework/scorecard-test:v1.31.0
    labels:
      suite: olm
      test: olm-bundle-validation-test</programlisting>
<calloutlist>
<callout arearefs="CO96-1">
<para>Enables parallel testing</para>
</callout>
</calloutlist>
<simpara>All tests in a parallel stage are executed simultaneously, and scorecard waits for all of them to finish before proceding to the next stage. This can make your tests run much faster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-scorecard-custom-tests_osdk-scorecard">
<title>Custom scorecard tests</title>
<simpara>The scorecard tool can run custom tests that follow these mandated conventions:</simpara>
<itemizedlist>
<listitem>
<simpara>Tests are implemented within a container image</simpara>
</listitem>
<listitem>
<simpara>Tests accept an entrypoint which include a command and arguments</simpara>
</listitem>
<listitem>
<simpara>Tests produce <literal>v1alpha3</literal> scorecard output in JSON format with no extraneous logging in the test output</simpara>
</listitem>
<listitem>
<simpara>Tests can obtain the bundle contents at a shared mount point of <literal>/bundle</literal></simpara>
</listitem>
<listitem>
<simpara>Tests can access the Kubernetes API using an in-cluster client connection</simpara>
</listitem>
</itemizedlist>
<simpara>Writing custom tests in other programming languages is possible if the test
image follows the above guidelines.</simpara>
<simpara>The following example shows of a custom test image written in Go:</simpara>
<example>
<title>Example custom scorecard test</title>
<programlisting language="go" linenumbering="unnumbered">// Copyright 2020 The Operator-SDK Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	scapiv1alpha3 "github.com/operator-framework/api/pkg/apis/scorecard/v1alpha3"
	apimanifests "github.com/operator-framework/api/pkg/manifests"
)

// This is the custom scorecard test example binary
// As with the Redhat scorecard test image, the bundle that is under
// test is expected to be mounted so that tests can inspect the
// bundle contents as part of their test implementations.
// The actual test is to be run is named and that name is passed
// as an argument to this binary.  This argument mechanism allows
// this binary to run various tests all from within a single
// test image.

const PodBundleRoot = "/bundle"

func main() {
	entrypoint := os.Args[1:]
	if len(entrypoint) == 0 {
		log.Fatal("Test name argument is required")
	}

	// Read the pod's untar'd bundle from a well-known path.
	cfg, err := apimanifests.GetBundleFromDir(PodBundleRoot)
	if err != nil {
		log.Fatal(err.Error())
	}

	var result scapiv1alpha3.TestStatus

	// Names of the custom tests which would be passed in the
	// `operator-sdk` command.
	switch entrypoint[0] {
	case CustomTest1Name:
		result = CustomTest1(cfg)
	case CustomTest2Name:
		result = CustomTest2(cfg)
	default:
		result = printValidTests()
	}

	// Convert scapiv1alpha3.TestResult to json.
	prettyJSON, err := json.MarshalIndent(result, "", "    ")
	if err != nil {
		log.Fatal("Failed to generate json", err)
	}
	fmt.Printf("%s\n", string(prettyJSON))

}

// printValidTests will print out full list of test names to give a hint to the end user on what the valid tests are.
func printValidTests() scapiv1alpha3.TestStatus {
	result := scapiv1alpha3.TestResult{}
	result.State = scapiv1alpha3.FailState
	result.Errors = make([]string, 0)
	result.Suggestions = make([]string, 0)

	str := fmt.Sprintf("Valid tests for this image include: %s %s",
		CustomTest1Name,
		CustomTest2Name)
	result.Errors = append(result.Errors, str)
	return scapiv1alpha3.TestStatus{
		Results: []scapiv1alpha3.TestResult{result},
	}
}

const (
	CustomTest1Name = "customtest1"
	CustomTest2Name = "customtest2"
)

// Define any operator specific custom tests here.
// CustomTest1 and CustomTest2 are example test functions. Relevant operator specific
// test logic is to be implemented in similarly.

func CustomTest1(bundle *apimanifests.Bundle) scapiv1alpha3.TestStatus {
	r := scapiv1alpha3.TestResult{}
	r.Name = CustomTest1Name
	r.State = scapiv1alpha3.PassState
	r.Errors = make([]string, 0)
	r.Suggestions = make([]string, 0)
	almExamples := bundle.CSV.GetAnnotations()["alm-examples"]
	if almExamples == "" {
		fmt.Println("no alm-examples in the bundle CSV")
	}

	return wrapResult(r)
}

func CustomTest2(bundle *apimanifests.Bundle) scapiv1alpha3.TestStatus {
	r := scapiv1alpha3.TestResult{}
	r.Name = CustomTest2Name
	r.State = scapiv1alpha3.PassState
	r.Errors = make([]string, 0)
	r.Suggestions = make([]string, 0)
	almExamples := bundle.CSV.GetAnnotations()["alm-examples"]
	if almExamples == "" {
		fmt.Println("no alm-examples in the bundle CSV")
	}
	return wrapResult(r)
}

func wrapResult(r scapiv1alpha3.TestResult) scapiv1alpha3.TestStatus {
	return scapiv1alpha3.TestStatus{
		Results: []scapiv1alpha3.TestResult{r},
	}
}</programlisting>
</example>
</section>
</section>
<section xml:id="osdk-bundle-validate">
<title>Validating Operator bundles</title>

<simpara>As an Operator author, you can run the <literal>bundle validate</literal> command in the Operator SDK to validate the content and format of an Operator bundle. You can run the command on a remote Operator bundle image or a local Operator bundle directory.</simpara>
<section xml:id="osdk-about-bundle-validate_osdk-bundle-validate">
<title>About the bundle validate command</title>
<simpara>While the Operator SDK <literal>scorecard</literal> command can run tests on your Operator based on a configuration file and test images, the <literal>bundle validate</literal> subcommand can validate local bundle directories and remote bundle images for content and structure.</simpara>
<formalpara>
<title><literal>bundle validate</literal> command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate &lt;bundle_dir_or_image&gt; &lt;flags&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>The <literal>bundle validate</literal> command runs automatically when you build your bundle using the <literal>make bundle</literal> command.</simpara>
</note>
<simpara>Bundle images are pulled from a remote registry and built locally before they are validated. Local bundle directories must contain Operator metadata and manifests. The bundle metadata and manifests must have a structure similar to the following bundle layout:</simpara>
<formalpara>
<title>Example bundle layout</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">./bundle
  ├── manifests
  │   ├── cache.my.domain_memcacheds.yaml
  │   └── memcached-operator.clusterserviceversion.yaml
  └── metadata
      └── annotations.yaml</programlisting>
</para>
</formalpara>
<simpara>Bundle tests pass validation and finish with an exit code of <literal>0</literal> if no errors are detected.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">INFO[0000] All validation tests have completed successfully</programlisting>
</para>
</formalpara>
<simpara>Tests fail validation and finish with an exit code of <literal>1</literal> if errors are detected.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ERRO[0000] Error: Value cache.example.com/v1alpha1, Kind=Memcached: CRD "cache.example.com/v1alpha1, Kind=Memcached" is present in bundle "" but not defined in CSV</programlisting>
</para>
</formalpara>
<simpara>Bundle tests that result in warnings can still pass validation with an exit code of <literal>0</literal> as long as no errors are detected. Tests only fail on errors.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">WARN[0000] Warning: Value : (memcached-operator.v0.0.1) annotations not found
INFO[0000] All validation tests have completed successfully</programlisting>
</para>
</formalpara>
<simpara>For further information about the <literal>bundle validate</literal> subcommand, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate -h</programlisting>
</section>
<section xml:id="osdk-bundle-validate-tests_osdk-bundle-validate">
<title>Built-in bundle validate tests</title>
<simpara>The Operator SDK ships with pre-defined validators arranged into suites. If you run the <literal>bundle validate</literal> command without specifying a validator, the default test runs. The default test verifies that a bundle adheres to the specifications defined by the Operator Framework community. For more information, see "Bundle format".</simpara>
<simpara>You can run optional validators to test for issues such as OperatorHub compatibility or deprecated Kubernetes APIs. Optional validators always run in addition to the default test.</simpara>
<formalpara>
<title><literal>bundle validate</literal> command syntax for optional test suites</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate &lt;bundle_dir_or_image&gt;
  --select-optional &lt;test_label&gt;</programlisting>
</para>
</formalpara>
<table xml:id="osdk-bundle-validate-additional-tests_osdk-bundle-validate" frame="all" rowsep="1" colsep="1">
<title>Addtional <literal>bundle validate</literal> validators</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="23.0769*"/>
<colspec colname="col_2" colwidth="53.8461*"/>
<colspec colname="col_3" colwidth="23.077*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Label</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Operator Framework</simpara></entry>
<entry align="left" valign="top"><simpara>This validator tests an Operator bundle against the entire suite of validators provided by the Operator Framework.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>suite=operatorframework</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OperatorHub</simpara></entry>
<entry align="left" valign="top"><simpara>This validator tests an Operator bundle for compatibility with OperatorHub.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>name=operatorhub</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Good Practices</simpara></entry>
<entry align="left" valign="top"><simpara>This validator tests whether an Operator bundle complies with good practices as defined by the Operator Framework. It checks for issues, such as an empty CRD description or unsupported Operator Lifecycle Manager (OLM) resources.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>name=good-practices</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">Bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-bundle-validate-run_osdk-bundle-validate">
<title>Running the bundle validate command</title>
<simpara>The default validator runs a test every time you enter the <literal>bundle validate</literal> command. You can run optional validators using the <literal>--select-optional</literal> flag. Optional validators run tests in addition to the default test.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator project generated by using the Operator SDK</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If you want to run the default validator against a local bundle directory, enter the following command from your Operator project directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate ./bundle</programlisting>
</listitem>
<listitem>
<simpara>If you want to run the default validator against a remote Operator bundle image, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate \
  &lt;bundle_registry&gt;/&lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;bundle_registry&gt;</term>
<listitem>
<simpara>Specifies the registry where the bundle is hosted, such as <literal>quay.io/example</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;bundle_image_name&gt;</term>
<listitem>
<simpara>Specifies the name of the bundle image, such as <literal>memcached-operator</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;tag&gt;</term>
<listitem>
<simpara>Specifies the tag of the bundle image, such as <literal>v1.31.0</literal>.</simpara>
<note>
<simpara>If you want to validate an Operator bundle image, you must host your image in a remote registry. The Operator SDK pulls the image and builds it locally before running tests. The <literal>bundle validate</literal> command does not support testing local bundle images.</simpara>
</note>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>If you want to run an additional validator against an Operator bundle, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate \
  &lt;bundle_dir_or_image&gt; \
  --select-optional &lt;test_label&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;bundle_dir_or_image&gt;</term>
<listitem>
<simpara>Specifies the local bundle directory or remote bundle image, such as <literal>~/projects/memcached</literal> or <literal>quay.io/example/memcached-operator:v1.31.0</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;test_label&gt;</term>
<listitem>
<simpara>Specifies the name of the validator you want to run, such as <literal>name=good-practices</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ERRO[0000] Error: Value apiextensions.k8s.io/v1, Kind=CustomResource: unsupported media type registry+v1 for bundle object
WARN[0000] Warning: Value k8sevent.v0.0.1: owned CRD "k8sevents.k8s.k8sevent.com" has an empty description</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-multi-arch-validate_osdk-bundle-validate">
<title>Validating your Operator&#8217;s multi-platform readiness</title>
<simpara>You can validate your Operator&#8217;s multi-platform readiness by running the <literal>bundle validate</literal> command. The command verifies that your Operator project meets the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>Your Operator&#8217;s manager image supports the platforms labeled in the cluster service version (CSV) file.</simpara>
</listitem>
<listitem>
<simpara>Your Operator&#8217;s CSV has labels for the supported platforms for Operator Lifecycle Manager (OLM) and OperatorHub.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to validate your Operator project for multiple architecture readiness:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk bundle validate ./bundle \
  --select-optional name=multiarch</programlisting>
<formalpara>
<title>Example validation message</title>
<para>
<programlisting language="text" linenumbering="unnumbered">INFO[0020] All validation tests have completed successfully</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example error message for missing CSV labels in the manager image</title>
<para>
<programlisting language="text" linenumbering="unnumbered">ERRO[0016] Error: Value test-operator.v0.0.1: not all images specified are providing the support described via the CSV labels. Note that (SO.architecture): (linux.ppc64le) was not found for the image(s) [quay.io/example-org/test-operator:v1alpha1]
ERRO[0016] Error: Value test-operator.v0.0.1: not all images specified are providing the support described via the CSV labels. Note that (SO.architecture): (linux.s390x) was not found for the image(s) [quay.io/example-org/test-operator:v1alpha1]
ERRO[0016] Error: Value test-operator.v0.0.1: not all images specified are providing the support described via the CSV labels. Note that (SO.architecture): (linux.amd64) was not found for the image(s) [quay.io/example-org/test-operator:v1alpha1]
ERRO[0016] Error: Value test-operator.v0.0.1: not all images specified are providing the support described via the CSV labels. Note that (SO.architecture): (linux.arm64) was not found for the image(s) [quay.io/example-org/test-operator:v1alpha1]</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example error message for missing OperatorHub flags</title>
<para>
<programlisting language="text" linenumbering="unnumbered">WARN[0014] Warning: Value test-operator.v0.0.1: check if the CSV is missing the label (operatorframework.io/arch.&lt;value&gt;) for the Arch(s): ["amd64" "arm64" "ppc64le" "s390x"]. Be aware that your Operator manager image ["quay.io/example-org/test-operator:v1alpha1"] provides this support. Thus, it is very likely that you want to provide it and if you support more than amd64 architectures, you MUST,use the required labels for all which are supported.Otherwise, your solution cannot be listed on the cluster for these architectures</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-multi-arch-support.xml#osdk-multi-platform-support">Configuring Operator projects for multi-platform support</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-ha-sno">
<title>High-availability or single-node cluster detection and support</title>

<simpara>An OpenShift Container Platform cluster can be configured in high-availability (HA) mode, which uses multiple nodes, or in non-HA mode, which uses a single node. A single-node cluster, also known as single-node OpenShift, is likely to have more conservative resource constraints. Therefore, it is important that Operators installed on a single-node cluster can adjust accordingly and still run well.</simpara>
<simpara>By accessing the cluster high-availability mode API provided in {product-title}, Operator authors can use the Operator SDK to enable their Operator to detect a cluster&#8217;s infrastructure topology, either HA or non-HA mode. Custom Operator logic can be developed that uses the detected cluster topology to automatically switch the resource requirements, both for the Operator and for any Operands or workloads it manages, to a profile that best fits the topology.</simpara>
<section xml:id="osdk-ha-sno-api_osdk-ha-sno">
<title>About the cluster high-availability mode API</title>
<simpara>{product-title} provides a cluster high-availability mode API that can be used by Operators to help detect infrastructure topology. The Infrastructure API holds cluster-wide information regarding infrastructure. Operators managed by Operator Lifecycle Manager (OLM) can use the Infrastructure API if they need to configure an Operand or managed workload differently based on the high-availability mode.</simpara>
<simpara>In the Infrastructure API, the <literal>infrastructureTopology</literal> status expresses the expectations for infrastructure services that do not run on control plane nodes, usually indicated by a node selector for a <literal>role</literal> value other than <literal>master</literal>. The <literal>controlPlaneTopology</literal> status expresses the expectations for Operands that normally run on control plane nodes.</simpara>
<simpara>The default setting for either status is <literal>HighlyAvailable</literal>, which represents the behavior Operators have in multiple node clusters. The <literal>SingleReplica</literal> setting is used in single-node clusters, also known as single-node OpenShift, and indicates that Operators should not configure their Operands for high-availability operation.</simpara>
<simpara>The {product-title} installer sets the <literal>controlPlaneTopology</literal> and <literal>infrastructureTopology</literal> status fields based on the replica counts for the cluster when it is created, according to the following rules:</simpara>
<itemizedlist>
<listitem>
<simpara>When the control plane replica count is less than 3, the <literal>controlPlaneTopology</literal> status is set to <literal>SingleReplica</literal>. Otherwise, it is set to <literal>HighlyAvailable</literal>.</simpara>
</listitem>
<listitem>
<simpara>When the worker replica count is 0, the control plane nodes are also configured as workers. Therefore, the <literal>infrastructureTopology</literal> status will be the same as the <literal>controlPlaneTopology</literal> status.</simpara>
</listitem>
<listitem>
<simpara>When the worker replica count is 1, the <literal>infrastructureTopology</literal> is set to <literal>SingleReplica</literal>. Otherwise, it is set to <literal>HighlyAvailable</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-ha-sno-api-examples_osdk-ha-sno">
<title>Example API usage in Operator projects</title>
<simpara>As an Operator author, you can update your Operator project to access the Infrastructure API by using normal Kubernetes constructs and the <literal>controller-runtime</literal> library, as shown in the following examples:</simpara>
<formalpara>
<title><literal>controller-runtime</literal> library example</title>
<para>
<programlisting language="go" linenumbering="unnumbered">// Simple query
 nn := types.NamespacedName{
 Name: "cluster",
 }
 infraConfig := &amp;configv1.Infrastructure{}
 err = crClient.Get(context.Background(), nn, infraConfig)
 if err != nil {
 return err
 }
 fmt.Printf("using crclient: %v\n", infraConfig.Status.ControlPlaneTopology)
 fmt.Printf("using crclient: %v\n", infraConfig.Status.InfrastructureTopology)</programlisting>
</para>
</formalpara>
<formalpara>
<title>Kubernetes constructs example</title>
<para>
<programlisting language="go" linenumbering="unnumbered">operatorConfigInformer := configinformer.NewSharedInformerFactoryWithOptions(configClient, 2*time.Second)
 infrastructureLister = operatorConfigInformer.Config().V1().Infrastructures().Lister()
 infraConfig, err := configClient.ConfigV1().Infrastructures().Get(context.Background(), "cluster", metav1.GetOptions{})
 if err != nil {
 return err
 }
// fmt.Printf("%v\n", infraConfig)
 fmt.Printf("%v\n", infraConfig.Status.ControlPlaneTopology)
 fmt.Printf("%v\n", infraConfig.Status.InfrastructureTopology)</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="osdk-monitoring-prometheus">
<title>Configuring built-in monitoring with Prometheus</title>

<simpara>This guide describes the built-in monitoring support provided by the Operator SDK using the Prometheus Operator and details usage for authors of Go-based and Ansible-based Operators.</simpara>
<section xml:id="osdk-monitoring-prometheus-operator-support_osdk-monitoring-prometheus">
<title>Prometheus Operator support</title>
<simpara><link xl:href="https://prometheus.io/">Prometheus</link> is an open-source systems monitoring and alerting toolkit. The Prometheus Operator creates, configures, and manages Prometheus clusters running on Kubernetes-based clusters, such as {product-title}.</simpara>
<simpara>Helper functions exist in the Operator SDK by default to automatically set up metrics in any generated Go-based Operator for use on clusters where the Prometheus Operator is deployed.</simpara>
</section>
<section xml:id="osdk-monitoring-custom-metrics_osdk-monitoring-prometheus">
<title>Exposing custom metrics for Go-based Operators</title>
<simpara>As an Operator author, you can publish custom metrics by using the global Prometheus registry from the <literal>controller-runtime/pkg/metrics</literal> library.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Go-based Operator generated using the Operator SDK</simpara>
</listitem>
<listitem>
<simpara>Prometheus Operator, which is deployed by default on {product-title} clusters</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In your Operator SDK project, uncomment the following line in the <literal>config/default/kustomization.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">../prometheus</programlisting>
</listitem>
<listitem>
<simpara>Create a custom controller class to publish additional metrics from the Operator. The following example declares the <literal>widgets</literal> and <literal>widgetFailures</literal> collectors as global variables, and then registers them with the <literal>init()</literal> function in the controller&#8217;s package:</simpara>
<example>
<title><literal>controllers/memcached_controller_test_metrics.go</literal> file</title>
<programlisting language="go" linenumbering="unnumbered">package controllers

import (
	"github.com/prometheus/client_golang/prometheus"
	"sigs.k8s.io/controller-runtime/pkg/metrics"
)


var (
    widgets = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "widgets_total",
            Help: "Number of widgets processed",
        },
    )
    widgetFailures = prometheus.NewCounter(
        prometheus.CounterOpts{
            Name: "widget_failures_total",
            Help: "Number of failed widgets",
        },
    )
)

func init() {
    // Register custom metrics with the global prometheus registry
    metrics.Registry.MustRegister(widgets, widgetFailures)
}</programlisting>
</example>
</listitem>
<listitem>
<simpara>Record to these collectors from any part of the reconcile loop in the <literal>main</literal> controller class, which determines the business logic for the metric:</simpara>
<example>
<title><literal>controllers/memcached_controller.go</literal> file</title>
<programlisting language="go" linenumbering="unnumbered">func (r *MemcachedReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	...
	...
	// Add metrics
	widgets.Inc()
	widgetFailures.Inc()

	return ctrl.Result{}, nil
}</programlisting>
</example>
</listitem>
<listitem>
<simpara>Build and push the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Create role and role binding definitions to allow the service monitor of the Operator to be scraped by the Prometheus instance of the {product-title} cluster.</simpara>
<simpara>Roles must be assigned so that service accounts have the permissions to scrape the metrics of the namespace:</simpara>
<example>
<title><literal>config/prometheus/role.yaml</literal> role</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus-k8s-role
  namespace: memcached-operator-system
rules:
  - apiGroups:
      - ""
    resources:
      - endpoints
      - pods
      - services
      - nodes
      - secrets
    verbs:
      - get
      - list
      - watch</programlisting>
</example>
<example>
<title><literal>config/prometheus/rolebinding.yaml</literal> role binding</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus-k8s-rolebinding
  namespace: memcached-operator-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus-k8s-role
subjects:
  - kind: ServiceAccount
    name: prometheus-k8s
    namespace: openshift-monitoring</programlisting>
</example>
</listitem>
<listitem>
<simpara>Apply the roles and role bindings for the deployed Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/prometheus/role.yaml</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f config/prometheus/rolebinding.yaml</programlisting>
</listitem>
<listitem>
<simpara>Set the labels for the namespace that you want to scrape, which enables OpenShift cluster monitoring for that namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;operator_namespace&gt; openshift.io/cluster-monitoring="true"</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Query and view the metrics in the {product-title} web console. You can use the names that were set in the custom controller class, for example <literal>widgets_total</literal> and <literal>widget_failures_total</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-ansible-metrics_osdk-monitoring-prometheus">
<title>Exposing custom metrics for Ansible-based Operators</title>
<simpara>As an Operator author creating Ansible-based Operators, you can use the Operator SDK&#8217;s <literal>osdk_metrics</literal> module to expose custom Operator and Operand metrics, emit events, and support logging.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Ansible-based Operator generated using the Operator SDK</simpara>
</listitem>
<listitem>
<simpara>Prometheus Operator, which is deployed by default on {product-title} clusters</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Generate an Ansible-based Operator. This example uses a <literal>testmetrics.com</literal> domain:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk init \
    --plugins=ansible \
    --domain=testmetrics.com</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>metrics</literal> API. This example uses a <literal>kind</literal> named <literal>Testmetrics</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk create api \
    --group metrics \
    --version v1 \
    --kind Testmetrics \
    --generate-role</programlisting>
</listitem>
<listitem>
<simpara>Edit the <literal>roles/testmetrics/tasks/main.yml</literal> file and use the <literal>osdk_metrics</literal> module to create custom metrics for your Operator project:</simpara>
<example>
<title>Example <literal>roles/testmetrics/tasks/main.yml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">---
# tasks file for Memcached
- name: start k8sstatus
  k8s:
    definition:
      kind: Deployment
      apiVersion: apps/v1
      metadata:
        name: '{{ ansible_operator_meta.name }}-memcached'
        namespace: '{{ ansible_operator_meta.namespace }}'
      spec:
        replicas: "{{size}}"
        selector:
          matchLabels:
            app: memcached
        template:
          metadata:
            labels:
              app: memcached
          spec:
            containers:
            - name: memcached
              command:
              - memcached
              - -m=64
              - -o
              - modern
              - -v
              image: "docker.io/memcached:1.4.36-alpine"
              ports:
                - containerPort: 11211

- osdk_metric:
    name: my_thing_counter
    description: This metric counts things
    counter: {}

- osdk_metric:
    name: my_counter_metric
    description: Add 3.14 to the counter
    counter:
      increment: yes

- osdk_metric:
    name: my_gauge_metric
    description: Create my gauge and set it to 2.
    gauge:
      set: 2

- osdk_metric:
    name: my_histogram_metric
    description: Observe my histogram
    histogram:
      observe: 2

- osdk_metric:
    name: my_summary_metric
    description: Observe my summary
    summary:
      observe: 2</programlisting>
</example>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Run your Operator on a cluster. For example, to use the "run as a deployment" method:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Build the Operator image and push it to a registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-build docker-push IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
<listitem>
<simpara>Install the Operator on a cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make install</programlisting>
</listitem>
<listitem>
<simpara>Deploy the Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make deploy IMG=&lt;registry&gt;/&lt;user&gt;/&lt;image_name&gt;:&lt;tag&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a <literal>Testmetrics</literal> custom resource (CR):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Define the CR spec:</simpara>
<example>
<title>Example <literal>config/samples/metrics_v1_testmetrics.yaml</literal> file</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: metrics.testmetrics.com/v1
kind: Testmetrics
metadata:
  name: testmetrics-sample
spec:
  size: 1</programlisting>
</example>
</listitem>
<listitem>
<simpara>Create the object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f config/samples/metrics_v1_testmetrics.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Get the pod details:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                    READY   STATUS    RESTARTS   AGE
ansiblemetrics-controller-manager-&lt;id&gt;  2/2     Running   0          149m
testmetrics-sample-memcached-&lt;id&gt;       1/1     Running   0          147m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the endpoint details:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ep</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                                ENDPOINTS          AGE
ansiblemetrics-controller-manager-metrics-service   10.129.2.70:8443   150m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Request a custom metrics token:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ token=`oc create token prometheus-k8s -n openshift-monitoring`</programlisting>
</listitem>
<listitem>
<simpara>Check the metrics values:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check the <literal>my_counter_metric</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec ansiblemetrics-controller-manager-&lt;id&gt; -- curl -k -H "Authoriza
tion: Bearer $token" 'https://10.129.2.70:8443/metrics' | grep  my_counter</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">HELP my_counter_metric Add 3.14 to the counter
TYPE my_counter_metric counter
my_counter_metric 2</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>my_gauge_metric</literal> value:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec ansiblemetrics-controller-manager-&lt;id&gt; -- curl -k -H "Authoriza
tion: Bearer $token" 'https://10.129.2.70:8443/metrics' | grep  gauge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">HELP my_gauge_metric Create my gauge and set it to 2.</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the <literal>my_histogram_metric</literal> and <literal>my_summary_metric</literal> values:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc exec ansiblemetrics-controller-manager-&lt;id&gt; -- curl -k -H "Authoriza
tion: Bearer $token" 'https://10.129.2.70:8443/metrics' | grep  Observe</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">HELP my_histogram_metric Observe my histogram
HELP my_summary_metric Observe my summary</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="osdk-leader-election">
<title>Configuring leader election</title>

<simpara>During the lifecycle of an Operator, it is possible that there may be more than one instance running at any given time, for example when rolling out an upgrade for the Operator. In such a scenario, it is necessary to avoid contention between multiple Operator instances using leader election. This ensures only one leader instance handles the reconciliation while the other instances are inactive but ready to take over when the leader steps down.</simpara>
<simpara>There are two different leader election implementations to choose from, each with its own trade-off:</simpara>
<variablelist>
<varlistentry>
<term>Leader-for-life</term>
<listitem>
<simpara>The leader pod only gives up leadership, using garbage collection, when it is deleted. This implementation precludes the possibility of two instances mistakenly running as leaders, a state also known as split brain. However, this method can be subject to a delay in electing a new leader. For example, when the leader pod is on an unresponsive or partitioned node, you can specify <literal>node.kubernetes.io/unreachable</literal> and <literal>node.kubernetes.io/not-ready</literal> tolerations on the leader pod and use the <literal>tolerationSeconds</literal> value to dictate how long it takes for the leader pod to be deleted from the node and step down. These tolerations are added to the pod by default on admission with a <literal>tolerationSeconds</literal> value of 5 minutes. See the <link xl:href="https://godoc.org/github.com/operator-framework/operator-sdk/pkg/leader">Leader-for-life</link> Go documentation for more.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Leader-with-lease</term>
<listitem>
<simpara>The leader pod periodically renews the leader lease and gives up leadership when it cannot renew the lease. This implementation allows for a faster transition to a new leader when the existing leader is isolated, but there is a possibility of split brain in <link xl:href="https://github.com/kubernetes/client-go/blob/30b06a83d67458700a5378239df6b96948cb9160/tools/leaderelection/leaderelection.go#L21-L24">certain situations</link>. See the <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/leaderelection">Leader-with-lease</link> Go documentation for more.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>By default, the Operator SDK enables the Leader-for-life implementation. Consult the related Go documentation for both approaches to consider the trade-offs that make sense for your use case.</simpara>
<section xml:id="osdk-leader-election-types_osdk-leader-election">
<title>Operator leader election examples</title>
<simpara>The following examples illustrate how to use the two leader election options for an Operator, Leader-for-life and Leader-with-lease.</simpara>
<section xml:id="osdk-leader-for-life-election_osdk-leader-election">
<title>Leader-for-life election</title>
<simpara>With the Leader-for-life election implementation, a call to <literal>leader.Become()</literal> blocks the Operator as it retries until it can become the leader by creating the config map named <literal>memcached-operator-lock</literal>:</simpara>
<programlisting language="go" linenumbering="unnumbered">import (
  ...
  "github.com/operator-framework/operator-sdk/pkg/leader"
)

func main() {
  ...
  err = leader.Become(context.TODO(), "memcached-operator-lock")
  if err != nil {
    log.Error(err, "Failed to retry for leader lock")
    os.Exit(1)
  }
  ...
}</programlisting>
<simpara>If the Operator is not running inside a cluster, <literal>leader.Become()</literal> simply returns without error to skip the leader election since it cannot detect the name of the Operator.</simpara>
</section>
<section xml:id="osdk-leader-with-lease-election_osdk-leader-election">
<title>Leader-with-lease election</title>
<simpara>The Leader-with-lease implementation can be enabled using the <link xl:href="https://godoc.org/github.com/kubernetes-sigs/controller-runtime/pkg/manager#Options">Manager Options</link> for leader election:</simpara>
<programlisting language="go" linenumbering="unnumbered">import (
  ...
  "sigs.k8s.io/controller-runtime/pkg/manager"
)

func main() {
  ...
  opts := manager.Options{
    ...
    LeaderElection: true,
    LeaderElectionID: "memcached-operator-lock"
  }
  mgr, err := manager.New(cfg, opts)
  ...
}</programlisting>
<simpara>When the Operator is not running in a cluster, the Manager returns an error when starting because it cannot detect the namespace of the Operator to create the config map for leader election. You can override this namespace by setting the <literal>LeaderElectionNamespace</literal> option for the Manager.</simpara>
</section>
</section>
</section>
<section xml:id="osdk-multi-platform-support">
<title>Configuring Operator projects for multi-platform support</title>

<simpara>Operator projects that support multiple architectures and operating systems, or <emphasis>platforms</emphasis>, can run on more Kubernetes and {product-title} clusters than Operator projects that support only a single platform. Example architectures include <literal>amd64</literal>, <literal>arm64</literal>, <literal>ppc64le</literal>, and <literal>s390x</literal>. Example operating systems include Linux and Windows.</simpara>
<simpara>Perform the following actions to ensure your Operator project can run on multiple {product-title} platforms:</simpara>
<itemizedlist>
<listitem>
<simpara>Build a manifest list that specifies the platforms that your Operator supports.</simpara>
</listitem>
<listitem>
<simpara>Set your Operator&#8217;s node affinity to support multi-architecture compute machines.</simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-multi-arch-building-images_osdk-multi-arch">
<title>Building a manifest list of the platforms your Operator supports</title>
<simpara>You can use the <literal>make docker-buildx</literal> command to build a manifest list of the platforms supported by your Operator and operands. A manifest list references specific image manifests for one or more architectures. An image manifest specifies the platforms that an image supports.</simpara>
<simpara>For more information, see <link xl:href="https://specs.opencontainers.org/image-spec/image-index">OpenContainers Image Index Spec</link> or <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2/#manifest-list">Image Manifest v2, Schema 2</link>.</simpara>
<important>
<simpara>If your Operator project deploys an application or other workload resources, the following procedure assumes the application&#8217;s multi-platform images are built during the application release process.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project built using the Operator SDK version 1.31.0 or later</simpara>
</listitem>
<listitem>
<simpara>Docker installed</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Inspect the image manifests of your Operator and operands to find which platforms your Operator project can support. Run the following command to inspect an image manifest:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker manifest inspect &lt;image_manifest&gt; <co xml:id="CO97-1"/></programlisting>
<calloutlist>
<callout arearefs="CO97-1">
<para>Specifies an image manifest, such as <literal>redhat/ubi9:latest</literal>.</para>
</callout>
</calloutlist>
<simpara>The platforms that your Operator and operands mutually support determine the platform compatibility of your Operator project.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "manifests": [
        {
            "digest": "sha256:c0669ef34cdc14332c0f1ab0c2c01acb91d96014b172f1a76f3a39e63d1f0bda",
            "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
            "platform": {
                "architecture": "amd64",
                "os": "linux"
            },
            "size": 528
        },
...
        {
            "digest": "sha256:30e6d35703c578ee703230b9dc87ada2ba958c1928615ac8a674fcbbcbb0f281",
            "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
            "platform": {
                "architecture": "arm64",
                "os": "linux",
                "variant": "v8"
            },
            "size": 528
        },
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the previous command does not output platform information, then the specified base image might be a single image instead of an image manifest. You can find which architectures an image supports by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker inspect &lt;image&gt;</programlisting>
</listitem>
<listitem>
<simpara>For Go-based Operator projects, the Operator SDK explicitly references the <literal>amd64</literal> architecture in your project&#8217;s Dockerfile. Make the following change
to your Dockerfile to set an environment variable to the value specified by the platform flag:</simpara>
<formalpara>
<title>Example Dockerfile</title>
<para>
<programlisting language="docker" linenumbering="unnumbered">FROM golang:1.19 as builder
ARG TARGETOS
ARG TARGETARCH
...
RUN CGO_ENABLED=0 GOOS=${TARGETOS:-linux} GOARCH=${TARGETARCH} go build -a -o manager main.go <co xml:id="CO98-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO98-1">
<para>Change the <literal>GOARCH</literal> field from <literal>amd64</literal> to <literal>$TARGETARCH</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Your Operator project&#8217;s makefile defines the <literal>PLATFORMS</literal> environment variable. If your Operator&#8217;s images do not support all of the platforms set by default, edit the variable to specify the supported platforms. The following example defines the supported platforms as <literal>linux/arm64</literal> and <literal>linux/amd64</literal>:</simpara>
<formalpara>
<title>Example makefile</title>
<para>
<programlisting language="make" linenumbering="unnumbered"># ...
PLATFORMS ?= linux/arm64,linux/amd64 <co xml:id="CO99-1"/>
.PHONY: docker-buildx
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO99-1">
<para>The following <literal>PLATFORMS</literal> values are set by default: <literal>linux/arm64</literal>, <literal>linux/amd64</literal>, <literal>linux/s390x</literal>, and <literal>linux/ppc64le</literal>.</para>
</callout>
</calloutlist>
<simpara>When you run the <literal>make docker buildx</literal> command to generate a manifest list, the Operator SDK creates an image manifest for each of the platforms specified by the <literal>PLATFORMS</literal> variable.</simpara>
</listitem>
<listitem>
<simpara>Run the following command from your Operator project directory to build your manager image. Running the command builds a manager image with multi-platform support and pushes the manifest list to your registry.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ make docker-buildx \
  IMG=&lt;image_registry&gt;/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;version_or_sha&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="osdk-multi-arch-node-affinity_osdk-multi-arch">
<title>About node affinity rules for multi-architecture compute machines and Operator workloads</title>
<simpara>You must set node affinity rules to ensure your Operator workloads can run on multi-architecture compute machines. Node affinity is a set of rules used by the scheduler to define a pod&#8217;s placement. Setting node affinity rules ensures your Operator&#8217;s workloads are scheduled to compute machines with compatible architectures.</simpara>
<simpara>If your Operator performs better on particular architectures, you can set preferred node affinity rules to schedule pods to machines with the specified architectures.</simpara>
<simpara>For more information, see "About clusters with multi-architecture compute machines" and "Controlling pod placement on nodes using node affinity rules".</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity">Controlling pod placement on nodes using node affinity rules</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#olm-overriding-operator-pod-affinity_nodes-scheduler-node-affinity">Using node affinity to control where an Operator is installed</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../post_installation_configuration/configuring-multi-arch-compute-machines/multi-architecture-configuration.xml#post-install-multi-architecture-configuration">About clusters with multi-architecture compute machines</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="osdk-multi-arch-node-reqs_osdk-multi-arch">
<title>Using required node affinity rules to support multi-architecture compute machines for Operator projects</title>
<simpara>If you want your Operator to support multi-architecture compute machines, you must define your Operator&#8217;s required node affinity rules.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.31.0 or later.</simpara>
</listitem>
<listitem>
<simpara>A manifest list defining the platforms your Operator supports.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Search your Operator project for Kubernetes manifests that define pod spec and pod template spec objects.</simpara>
<important>
<simpara>Because object type names are not declared in YAML files, look for the mandatory <literal>containers</literal> field in your Kubernetes manifests. The <literal>containers</literal> field is required when specifying both pod spec and pod template spec objects.</simpara>
<simpara>You must set node affinity rules in all Kubernetes manifests that define a pod spec or pod template spec, including objects such as <literal>Pod</literal>, <literal>Deployment</literal>, <literal>DaemonSet</literal>, and <literal>StatefulSet</literal>.</simpara>
</important>
<formalpara>
<title>Example Kubernetes manifest</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  containers:
    - name: &lt;container_name&gt;
      image: docker.io/&lt;org&gt;/&lt;image_name&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set the required node affinity rules in the Kubernetes manifests that define pod spec and pod template spec objects, similar to the following example:</simpara>
<formalpara>
<title>Example Kubernetes manifest</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  containers:
    - name: &lt;container_name&gt;
      image: docker.io/&lt;org&gt;/&lt;image_name&gt;
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO100-1"/>
        nodeSelectorTerms: <co xml:id="CO100-2"/>
        - matchExpressions: <co xml:id="CO100-3"/>
          - key: kubernetes.io/arch <co xml:id="CO100-4"/>
            operator: In
            values:
            - amd64
            - arm64
            - ppc64le
            - s390x
          - key: kubernetes.io/os <co xml:id="CO100-5"/>
            operator: In
            values:
                - linux</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO100-1">
<para>Defines a required rule.</para>
</callout>
<callout arearefs="CO100-2">
<para>If you specify multiple <literal>nodeSelectorTerms</literal> associated with <literal>nodeAffinity</literal> types, then the pod can be scheduled onto a node if one of the <literal>nodeSelectorTerms</literal> is satisfied.</para>
</callout>
<callout arearefs="CO100-3">
<para>If you specify multiple <literal>matchExpressions</literal> associated with <literal>nodeSelectorTerms</literal>, then the pod can be scheduled onto a node only if all <literal>matchExpressions</literal> are satisfied.</para>
</callout>
<callout arearefs="CO100-4">
<para>Specifies the architectures defined in the manifest list.</para>
</callout>
<callout arearefs="CO100-5">
<para>Specifies the operating systems defined in the manifest list.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Go-based Operator projects that use dynamically created workloads might embed pod spec and pod template spec objects in the Operator&#8217;s logic.</simpara>
<simpara>If your project embeds pod spec or pod template spec objects in the Operator&#8217;s logic, edit your Operator&#8217;s logic similar to the following example. The following example shows how to update a <literal>PodSpec</literal> object by using the Go API:</simpara>
<programlisting language="go" linenumbering="unnumbered">Template: corev1.PodTemplateSpec{
    ...
    Spec: corev1.PodSpec{
        Affinity: &amp;corev1.Affinity{
            NodeAffinity: &amp;corev1.NodeAffinity{
                RequiredDuringSchedulingIgnoredDuringExecution: &amp;corev1.NodeSelector{
                    NodeSelectorTerms: []corev1.NodeSelectorTerm{
                        {
                            MatchExpressions: []corev1.NodeSelectorRequirement{
                                {
                                    Key:      "kubernetes.io/arch",
                                    Operator: "In",
                                    Values:   []string{"amd64","arm64","ppc64le","s390x"},
                                },
                                {
                                    Key:      "kubernetes.io/os",
                                    Operator: "In",
                                    Values:   []string{"linux"},
                                },
                            },
                        },
                    },
                },
            },
        },
        SecurityContext: &amp;corev1.PodSecurityContext{
            ...
        },
        Containers: []corev1.Container{{
            ...
        }},
    },</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>RequiredDuringSchedulingIgnoredDuringExecution</literal></term>
<listitem>
<simpara>Defines a required rule.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>NodeSelectorTerms</literal></term>
<listitem>
<simpara>If you specify multiple <literal>nodeSelectorTerms</literal> associated with <literal>nodeAffinity</literal> types, then the pod can be scheduled onto a node if one of the <literal>nodeSelectorTerms</literal> is satisfied.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>MatchExpressions</literal></term>
<listitem>
<simpara>If you specify multiple <literal>matchExpressions</literal> associated with <literal>nodeSelectorTerms</literal>, then the pod can be scheduled onto a node only if all <literal>matchExpressions</literal> are satisfied.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>kubernetes.io/arch</literal></term>
<listitem>
<simpara>Specifies the architectures defined in the manifest list.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>kubernetes.io/os</literal></term>
<listitem>
<simpara>Specifies the operating systems defined in the manifest list.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
<warning>
<simpara>If you do not set node affinity rules and a container is scheduled to a compute machine with an incompatible architecture, the pod fails and triggers one of the following events:</simpara>
<variablelist>
<varlistentry>
<term><literal>CrashLoopBackOff</literal></term>
<listitem>
<simpara>Occurs when an image manifest&#8217;s entry point fails to run and an <literal>exec format error</literal> message is printed in the logs.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>ImagePullBackOff</literal></term>
<listitem>
<simpara>Occurs when a manifest list does not include a manifest for the architecture where a pod is scheduled or the node affinity terms are set to the wrong values.</simpara>
</listitem>
</varlistentry>
</variablelist>
</warning>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity-configuring-required_nodes-scheduler-node-affinity">Configuring a required node affinity rule</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity-example_nodes-scheduler-node-affinity">Sample node affinity rules</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-multi-arch-node-preference_osdk-multi-arch">
<title>Using preferred node affinity rules to configure support for multi-architecture compute machines for Operator projects</title>
<simpara>If your Operator performs better on particular architectures, you can configure preferred node affinity rules to schedule pods to nodes to the specified architectures.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Operator project created or maintained with Operator SDK 1.31.0 or later.</simpara>
</listitem>
<listitem>
<simpara>A manifest list defining the platforms your Operator supports.</simpara>
</listitem>
<listitem>
<simpara>Required node affinity rules are set for your Operator project.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Search your Operator project for Kubernetes manifests that define pod spec and pod template spec objects.</simpara>
<formalpara>
<title>Example Kubernetes manifest</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  containers:
    - name: &lt;container_name&gt;
      image: docker.io/&lt;org&gt;/&lt;image_name&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set your Operator&#8217;s preferred node affinity rules in the Kubernetes manifests that define pod spec and pod template spec objects, similar to the following example:</simpara>
<formalpara>
<title>Example Kubernetes manifest</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: s1
spec:
  containers:
    - name: &lt;container_name&gt;
      image: docker.io/&lt;org&gt;/&lt;image_name&gt;
  affinity:
      nodeAffinity:
        preferredDuringSchedulingIgnoredDuringExecution: <co xml:id="CO101-1"/>
          - preference:
            matchExpressions: <co xml:id="CO101-2"/>
              - key: kubernetes.io/arch <co xml:id="CO101-3"/>
                operator: In <co xml:id="CO101-4"/>
                values:
                - amd64
                - arm64
            weight: 90 <co xml:id="CO101-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO101-1">
<para>Defines a preferred rule.</para>
</callout>
<callout arearefs="CO101-2">
<para>If you specify multiple <literal>matchExpressions</literal> associated with <literal>nodeSelectorTerms</literal>, then the pod can be scheduled onto a node only if all <literal>matchExpressions</literal> are satisfied.</para>
</callout>
<callout arearefs="CO101-3">
<para>Specifies the architectures defined in the manifest list.</para>
</callout>
<callout arearefs="CO101-4">
<para>Specifies an <literal>operator</literal>. The Operator can be <literal>In</literal>, <literal>NotIn</literal>,  <literal>Exists</literal>, or <literal>DoesNotExist</literal>. For example, use the value of <literal>In</literal> to require the label to be in the node.</para>
</callout>
<callout arearefs="CO101-5">
<para>Specifies a weight for the node, valid values are <literal>1</literal>-<literal>100</literal>. The node with highest weight is preferred.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/scheduling/nodes-scheduler-node-affinity.xml#nodes-scheduler-node-affinity-configuring-preferred_nodes-scheduler-node-affinity">Configuring a preferred node affinity rule</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="next-steps_osdk-multi-arch-support">
<title>Next steps</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-generating-csvs.xml#olm-enabling-operator-for-multi-arch_osdk-generating-csvs">Label the platforms your Operator supports for Operator Lifecycle Manager (OLM)</link></simpara>
</listitem>
<listitem>
<simpara>Bundle your Operator and Deploy with OLM</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/golang/osdk-golang-tutorial.xml#osdk-bundle-deploy-olm_osdk-golang-tutorial">Go-based Operator projects</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/ansible/osdk-ansible-tutorial.xml#osdk-bundle-deploy-olm_osdk-ansible-tutorial">Ansible-based Operator projects</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/helm/osdk-helm-tutorial.html#osdk-bundle-deploy-olm_osdk-helm-tutorial">Helm-based Operator projects</link></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-bundle-validate.html#osdk-multi-arch-validate_osdk-bundle-validate">Validate your Operator&#8217;s multi-platform readiness</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-pruning-utility">
<title>Object pruning utility for Go-based Operators</title>

<simpara>The <literal>operator-lib</literal> pruning utility lets Go-based Operators clean up, or prune, objects when they are no longer needed. Operator authors can also use the utility to create custom hooks and strategies.</simpara>
<section xml:id="osdk-about-pruning-utility_osdk-pruning-utility">
<title>About the operator-lib pruning utility</title>
<simpara>Objects, such as jobs or pods, are created as a normal part of the Operator life cycle. If
the cluster administrator
or the Operator does not remove these object, they can stay in the cluster and consume resources.</simpara>
<simpara>Previously, the following options were available for pruning unnecessary objects:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator authors had to create a unique pruning solution for their Operators.</simpara>
</listitem>
<listitem>
<simpara>Cluster administrators had to clean up objects on their own.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>operator-lib</literal> <link xl:href="https://github.com/operator-framework/operator-lib/tree/main/prune">pruning utility</link> removes objects from a Kubernetes cluster for a given namespace. The library was added in version <literal>0.9.0</literal> of the <link xl:href="https://github.com/operator-framework/operator-lib/releases/tag/v0.9.0"><literal>operator-lib</literal> library</link> as part of the Operator Framework.</simpara>
</section>
<section xml:id="osdk-pruning-utility-config_osdk-pruning-utility">
<title>Pruning utility configuration</title>
<simpara>The <literal>operator-lib</literal> pruning utility is written in Go and includes common pruning strategies for Go-based Operators.</simpara>
<formalpara>
<title>Example configuration</title>
<para>
<programlisting language="go" linenumbering="unnumbered">cfg = Config{
        log:           logf.Log.WithName("prune"),
        DryRun:        false,
        Clientset:     client,
        LabelSelector: "app=&lt;operator_name&gt;",
        Resources: []schema.GroupVersionKind{
                {Group: "", Version: "", Kind: PodKind},
        },
        Namespaces: []string{"&lt;operator_namespace&gt;"},
        Strategy: StrategyConfig{
                Mode:            MaxCountStrategy,
                MaxCountSetting: 1,
        },
        PreDeleteHook: myhook,
}</programlisting>
</para>
</formalpara>
<simpara>The pruning utility configuration file defines pruning actions by using the following fields:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="70*"/>
<thead>
<row>
<entry align="left" valign="top">Configuration field</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>log</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logger used to handle library log messages.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DryRun</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Boolean that determines whether resources should be removed. If set to <literal>true</literal>, the utility runs but does not to remove resources.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Clientset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Client-go Kubernetes ClientSet used for Kubernetes API calls.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LabelSelector</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes label selector expression used to find resources to prune.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Resources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Kubernetes resource kinds. <literal>PodKind</literal> and <literal>JobKind</literal> are currently supported.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Namespaces</literal></simpara></entry>
<entry align="left" valign="top"><simpara>List of Kubernetes namespaces to search for resources.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Strategy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pruning strategy to run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Strategy.Mode</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>MaxCountStrategy</literal>, <literal>MaxAgeStrategy</literal>, or <literal>CustomStrategy</literal> are currently supported.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Strategy.MaxCountSetting</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Integer value for <literal>MaxCountStrategy</literal> that specifies how many resources should remain after the pruning utility runs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Strategy.MaxAgeSetting</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Go <literal>time.Duration</literal> string value, such as <literal>48h</literal>, that specifies the age of resources to prune.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Strategy.CustomSettings</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Go map of values that can be passed into a custom strategy function.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PreDeleteHook</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional: Go function to call before pruning a resource.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CustomStrategy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional: Go function that implements a custom pruning strategy.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<formalpara>
<title>Pruning execution</title>
<para>You can call the pruning action by running the execute function on the pruning configuration.</para>
</formalpara>
<programlisting language="go" linenumbering="unnumbered">err := cfg.Execute(ctx)</programlisting>
<simpara>You can also call a pruning action by using a cron package or by calling the pruning utility with a triggering event.</simpara>
</section>
</section>
<section xml:id="osdk-pkgman-to-bundle">
<title>Migrating package manifest projects to bundle format</title>

<simpara>Support for the legacy <emphasis>package manifest format</emphasis> for Operators is removed in {product-title} 4.8 and later. If you have an Operator project that was initially created using the package manifest format, you can use the Operator SDK to migrate the project to the bundle format. The bundle format is the preferred packaging format for Operator Lifecycle Manager (OLM) starting in {product-title} 4.6.</simpara>
<section xml:id="osdk-about-pkg-format-migration_osdk-pkgman-to-bundle">
<title>About packaging format migration</title>
<simpara>The Operator SDK <literal>pkgman-to-bundle</literal> command helps in migrating Operator Lifecycle Manager (OLM) package manifests to bundles. The command takes an input package manifest directory and generates bundles for each of the versions of manifests present in the input directory. You can also then build bundle images for each of the generated bundles.</simpara>
<simpara>For example, consider the following <literal>packagemanifests/</literal> directory for a project in the package manifest format:</simpara>
<formalpara>
<title>Example package manifest format layout</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">packagemanifests/
└── etcd
    ├── 0.0.1
    │   ├── etcdcluster.crd.yaml
    │   └── etcdoperator.clusterserviceversion.yaml
    ├── 0.0.2
    │   ├── etcdbackup.crd.yaml
    │   ├── etcdcluster.crd.yaml
    │   ├── etcdoperator.v0.0.2.clusterserviceversion.yaml
    │   └── etcdrestore.crd.yaml
    └── etcd.package.yaml</programlisting>
</para>
</formalpara>
<simpara>After running the migration, the following bundles are generated in the <literal>bundle/</literal> directory:</simpara>
<formalpara>
<title>Example bundle format layout</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">bundle/
├── bundle-0.0.1
│   ├── bundle.Dockerfile
│   ├── manifests
│   │   ├── etcdcluster.crd.yaml
│   │   ├── etcdoperator.clusterserviceversion.yaml
│   ├── metadata
│   │   └── annotations.yaml
│   └── tests
│       └── scorecard
│           └── config.yaml
└── bundle-0.0.2
    ├── bundle.Dockerfile
    ├── manifests
    │   ├── etcdbackup.crd.yaml
    │   ├── etcdcluster.crd.yaml
    │   ├── etcdoperator.v0.0.2.clusterserviceversion.yaml
    │   ├── etcdrestore.crd.yaml
    ├── metadata
    │   └── annotations.yaml
    └── tests
        └── scorecard
            └── config.yaml</programlisting>
</para>
</formalpara>
<simpara>Based on this generated layout, bundle images for both of the bundles are also built with the following names:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>quay.io/example/etcd:0.0.1</literal></simpara>
</listitem>
<listitem>
<simpara><literal>quay.io/example/etcd:0.0.2</literal></simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-packaging-format">Operator Framework packaging format</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-migrating-pkgman_osdk-pkgman-to-bundle">
<title>Migrating a package manifest project to bundle format</title>
<simpara>Operator authors can use the Operator SDK to migrate a package manifest format Operator project to a bundle format project.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Operator SDK CLI installed</simpara>
</listitem>
<listitem>
<simpara>Operator project initially generated using the Operator SDK in package manifest format</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the Operator SDK to migrate your package manifest project to the bundle format and generate bundle images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk pkgman-to-bundle &lt;package_manifests_dir&gt; \ <co xml:id="CO102-1"/>
    [--output-dir &lt;directory&gt;] \ <co xml:id="CO102-2"/>
    --image-tag-base &lt;image_name_base&gt; <co xml:id="CO102-3"/></programlisting>
<calloutlist>
<callout arearefs="CO102-1">
<para>Specify the location of the package manifests directory for the project, such as <literal>packagemanifests/</literal> or <literal>manifests/</literal>.</para>
</callout>
<callout arearefs="CO102-2">
<para>Optional: By default, the generated bundles are written locally to disk to the <literal>bundle/</literal> directory. You can use the <literal>--output-dir</literal> flag to specify an alternative location.</para>
</callout>
<callout arearefs="CO102-3">
<para>Set the <literal>--image-tag-base</literal> flag to provide the base of the image name, such as <literal>quay.io/example/etcd</literal>, that will be used for the bundles. Provide the name without a tag, because the tag for the images will be set according to the bundle version. For example, the full bundle image names are generated in the format <literal>&lt;image_name_base&gt;:&lt;bundle_version&gt;</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the generated bundle image runs successfully:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk run bundle &lt;bundle_image_name&gt;:&lt;tag&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">INFO[0025] Successfully created registry pod: quay-io-my-etcd-0-9-4
INFO[0025] Created CatalogSource: etcd-catalog
INFO[0026] OperatorGroup "operator-sdk-og" created
INFO[0026] Created Subscription: etcdoperator-v0-9-4-sub
INFO[0031] Approved InstallPlan install-5t58z for the Subscription: etcdoperator-v0-9-4-sub
INFO[0031] Waiting for ClusterServiceVersion "default/etcdoperator.v0.9.4" to reach 'Succeeded' phase
INFO[0032]   Waiting for ClusterServiceVersion "default/etcdoperator.v0.9.4" to appear
INFO[0048]   Found ClusterServiceVersion "default/etcdoperator.v0.9.4" phase: Pending
INFO[0049]   Found ClusterServiceVersion "default/etcdoperator.v0.9.4" phase: Installing
INFO[0064]   Found ClusterServiceVersion "default/etcdoperator.v0.9.4" phase: Succeeded
INFO[0065] OLM has successfully installed "etcdoperator.v0.9.4"</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-cli-ref">
<title>Operator SDK CLI reference</title>

<simpara>The Operator SDK command-line interface (CLI) is a development kit designed to make writing Operators easier.</simpara>
<formalpara>
<title>Operator SDK CLI syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk &lt;command&gt; [&lt;subcommand&gt;] [&lt;argument&gt;] [&lt;flags&gt;]</programlisting>
</para>
</formalpara>
<simpara>Operator authors with cluster administrator access to a Kubernetes-based cluster (such as {product-title}) can use the Operator SDK CLI to develop their own Operators based on Go, Ansible, or Helm. <link xl:href="https://kubebuilder.io/">Kubebuilder</link> is embedded into the Operator SDK as the scaffolding solution for Go-based Operators, which means existing Kubebuilder projects can be used as is with the Operator SDK and continue to work.</simpara>
<section xml:id="osdk-cli-ref-bundle_osdk-cli-ref">
<title>bundle</title>
<simpara>The <literal>operator-sdk bundle</literal> command manages Operator bundle metadata.</simpara>
<section xml:id="osdk-cli-ref-bundle-validate_osdk-cli-ref">
<title>validate</title>
<simpara>The <literal>bundle validate</literal> subcommand validates an Operator bundle.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>bundle validate</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>bundle validate</literal> subcommand.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--index-builder</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Tool to pull and unpack bundle images. Only used when validating a bundle image. Available options are <literal>docker</literal>, which is the default, <literal>podman</literal>, or <literal>none</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--list-optional</literal></simpara></entry>
<entry align="left" valign="top"><simpara>List all optional validators available. When set, no validators are run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--select-optional</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Label selector to select optional validators to run. When run with the <literal>--list-optional</literal> flag, lists available optional validators.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="osdk-cli-ref-cleanup_osdk-cli-ref">
<title>cleanup</title>
<simpara>The <literal>operator-sdk cleanup</literal> command destroys and removes resources that were created for an Operator that was deployed with the <literal>run</literal> command.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>cleanup</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>run bundle</literal> subcommand.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kubeconfig</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to the <literal>kubeconfig</literal> file to use for CLI requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n</literal>, <literal>--namespace</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>If present, namespace in which to run the CLI request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--timeout &lt;duration&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Time to wait for the command to complete before failing. The default value is <literal>2m0s</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="osdk-cli-ref-completion_osdk-cli-ref">
<title>completion</title>
<simpara>The <literal>operator-sdk completion</literal> command generates shell completions to make issuing CLI commands quicker and easier.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>completion</literal> subcommands</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Subcommand</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>bash</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate bash completions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>zsh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate zsh completions.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title><literal>completion</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h, --help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Usage help output.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ operator-sdk completion bash</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># bash completion for operator-sdk                         -*- shell-script -*-
...
# ex: ts=4 sw=4 et filetype=sh</programlisting>
</para>
</formalpara>
</section>
<section xml:id="osdk-cli-ref-create_osdk-cli-ref">
<title>create</title>
<simpara>The <literal>operator-sdk create</literal> command is used to create, or <emphasis>scaffold</emphasis>, a Kubernetes API.</simpara>
<section xml:id="osdk-cli-ref-create-api_osdk-cli-ref">
<title>api</title>
<simpara>The <literal>create api</literal> subcommand scaffolds a Kubernetes API. The subcommand must be run in a project that was initialized with the <literal>init</literal> command.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>create api</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>run bundle</literal> subcommand.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="osdk-cli-ref-generate_osdk-cli-ref">
<title>generate</title>
<simpara>The <literal>operator-sdk generate</literal> command invokes a specific generator to generate code or manifests.</simpara>
<section xml:id="osdk-cli-ref-generate-bundle_osdk-cli-ref">
<title>bundle</title>
<simpara>The <literal>generate bundle</literal> subcommand generates a set of bundle manifests, metadata, and a <literal>bundle.Dockerfile</literal> file for your Operator project.</simpara>
<note>
<simpara>Typically, you run the <literal>generate kustomize manifests</literal> subcommand first to generate the input <link xl:href="https://kustomize.io/">Kustomize</link> bases that are used by the <literal>generate bundle</literal> subcommand. However, you can use the <literal>make bundle</literal> command in an initialized project to automate running these commands in sequence.</simpara>
</note>
<table frame="all" rowsep="1" colsep="1">
<title><literal>generate bundle</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--channels</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Comma-separated list of channels to which the bundle belongs. The default value is <literal>alpha</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--crds-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Root directory for <literal>CustomResoureDefinition</literal> manifests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--default-channel</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>The default channel for the bundle.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--deploy-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Root directory for Operator manifests, such as deployments and RBAC. This directory is different from the directory passed to the <literal>--input-dir</literal> flag.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help for <literal>generate bundle</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--input-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Directory from which to read an existing bundle. This directory is the parent of your bundle <literal>manifests</literal> directory and is different from the <literal>--deploy-dir</literal> directory.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kustomize-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Directory containing Kustomize bases and a <literal>kustomization.yaml</literal> file for bundle manifests. The default path is <literal>config/manifests</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--manifests</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate bundle manifests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--metadata</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate bundle metadata and Dockerfile.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--output-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Directory to write the bundle to.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--overwrite</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Overwrite the bundle metadata and Dockerfile if they exist. The default value is <literal>true</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--package</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Package name for the bundle.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-q</literal>, <literal>--quiet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run in quiet mode.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--stdout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Write bundle manifest to standard out.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--version</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Semantic version of the Operator in the generated bundle. Set only when creating a new bundle or upgrading the Operator.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../operators/operator_sdk/osdk-working-bundle-images.xml#osdk-bundle-operator_osdk-working-bundle-images">Bundling an Operator</link> for a full procedure that includes using the <literal>make bundle</literal> command to call the <literal>generate bundle</literal> subcommand.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-cli-ref-generate-kustomize_osdk-cli-ref">
<title>kustomize</title>
<simpara>The <literal>generate kustomize</literal> subcommand contains subcommands that generate <link xl:href="https://kustomize.io/">Kustomize</link> data for the Operator.</simpara>
<section xml:id="osdk-cli-ref-generate-kustomize-manifests_osdk-cli-ref">
<title>manifests</title>
<simpara>The <literal>generate kustomize manifests</literal> subcommand generates or regenerates Kustomize bases and a <literal>kustomization.yaml</literal> file in the <literal>config/manifests</literal> directory, which are used to build bundle manifests by other Operator SDK commands. This command interactively asks for UI metadata, an important component of manifest bases, by default unless a base already exists or you set the <literal>--interactive=false</literal> flag.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>generate kustomize manifests</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--apis-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Root directory for API type definitions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help for <literal>generate kustomize manifests</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--input-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Directory containing existing Kustomize files.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--interactive</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When set to <literal>false</literal>, if no Kustomize base exists, an interactive command prompt is presented to accept custom metadata.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--output-dir</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Directory where to write Kustomize files.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--package</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Package name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-q</literal>, <literal>--quiet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Run in quiet mode.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
</section>
<section xml:id="osdk-cli-ref-init_osdk-cli-ref">
<title>init</title>
<simpara>The <literal>operator-sdk init</literal> command initializes an Operator project and generates, or <emphasis>scaffolds</emphasis>, a default project directory layout for the given plugin.</simpara>
<simpara>This command writes the following files:</simpara>
<itemizedlist>
<listitem>
<simpara>Boilerplate license file</simpara>
</listitem>
<listitem>
<simpara><literal>PROJECT</literal> file with the domain and repository</simpara>
</listitem>
<listitem>
<simpara><literal>Makefile</literal> to build the project</simpara>
</listitem>
<listitem>
<simpara><literal>go.mod</literal> file with project dependencies</simpara>
</listitem>
<listitem>
<simpara><literal>kustomization.yaml</literal> file for customizing manifests</simpara>
</listitem>
<listitem>
<simpara>Patch file for customizing images for manager manifests</simpara>
</listitem>
<listitem>
<simpara>Patch file for enabling Prometheus metrics</simpara>
</listitem>
<listitem>
<simpara><literal>main.go</literal> file to run</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title><literal>init</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--help, -h</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>init</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--plugins</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Name and optionally version of the plugin to initialize the project with. Available plugins are <literal>ansible.sdk.operatorframework.io/v1</literal>, <literal>go.kubebuilder.io/v2</literal>, <literal>go.kubebuilder.io/v3</literal>, and <literal>helm.sdk.operatorframework.io/v1</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--project-version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Project version. Available values are <literal>2</literal> and <literal>3-alpha</literal>, which is the default.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="osdk-cli-ref-run_osdk-cli-ref">
<title>run</title>
<simpara>The <literal>operator-sdk run</literal> command provides options that can launch the Operator in various environments.</simpara>
<section xml:id="osdk-cli-ref-run-bundle_osdk-cli-ref">
<title>bundle</title>
<simpara>The <literal>run bundle</literal> subcommand deploys an Operator in the bundle format with Operator Lifecycle Manager (OLM).</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>run bundle</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--index-image</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Index image in which to inject a bundle. The default image is <literal>quay.io/operator-framework/upstream-opm-builder:latest</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--install-mode &lt;install_mode_value&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Install mode supported by the cluster service version (CSV) of the Operator, for example <literal>AllNamespaces</literal> or <literal>SingleNamespace</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--timeout &lt;duration&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Install timeout. The default value is <literal>2m0s</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kubeconfig</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to the <literal>kubeconfig</literal> file to use for CLI requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n</literal>, <literal>--namespace</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>If present, namespace in which to run the CLI request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--security-context-config &lt;security_context&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the security context to use for the catalog pod. Allowed values include <literal>restricted</literal> and <literal>legacy</literal>. The default value is <literal>legacy</literal>. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>run bundle</literal> subcommand.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>restricted</literal> security context is not compatible with the <literal>default</literal> namespace. To configure your Operator&#8217;s pod security admission in your production environment, see "Complying with pod security admission". For more information about pod security admission, see "Understanding and managing pod security admission".</simpara>
</listitem>
</orderedlist>
</para>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../operators/understanding/olm/olm-understanding-operatorgroups.xml#olm-operatorgroups-membership_olm-understanding-operatorgroups">Operator group membership</link> for details on possible install modes.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-complying-with-psa.xml#osdk-complying-with-psa">Complying with pod security admission</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="osdk-cli-ref-run-bundle-upgrade_osdk-cli-ref">
<title>bundle-upgrade</title>
<simpara>The <literal>run bundle-upgrade</literal> subcommand upgrades an Operator that was previously installed in the bundle format with Operator Lifecycle Manager (OLM).</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>run bundle-upgrade</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>--timeout &lt;duration&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Upgrade timeout. The default value is <literal>2m0s</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kubeconfig</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to the <literal>kubeconfig</literal> file to use for CLI requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n</literal>, <literal>--namespace</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>If present, namespace in which to run the CLI request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--security-context-config &lt;security_context&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the security context to use for the catalog pod. Allowed values include <literal>restricted</literal> and <literal>legacy</literal>. The default value is <literal>legacy</literal>. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>run bundle</literal> subcommand.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>restricted</literal> security context is not compatible with the <literal>default</literal> namespace. To configure your Operator&#8217;s pod security admission in your production environment, see "Complying with pod security admission". For more information about pod security admission, see "Understanding and managing pod security admission".</simpara>
</listitem>
</orderedlist>
</para>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-complying-with-psa.xml#osdk-complying-with-psa">Complying with pod security admission</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="osdk-cli-ref-scorecard_osdk-cli-ref">
<title>scorecard</title>
<simpara>The <literal>operator-sdk scorecard</literal> command runs the scorecard tool to validate an Operator bundle and provide suggestions for improvements. The command takes one argument, either a bundle image or directory containing manifests and metadata. If the argument holds an image tag, the image must be present remotely.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>scorecard</literal> flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-c</literal>, <literal>--config</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to scorecard configuration file. The default path is <literal>bundle/tests/scorecard/config.yaml</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Help output for the <literal>scorecard</literal> command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--kubeconfig</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Path to <literal>kubeconfig</literal> file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-L</literal>, <literal>--list</literal></simpara></entry>
<entry align="left" valign="top"><simpara>List which tests are available to run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-n</literal>, --namespace (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Namespace in which to run the test images.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-o</literal>, <literal>--output</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Output format for results. Available values are <literal>text</literal>, which is the default, and <literal>json</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--pod-security &lt;security_context&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Option to run scorecard with the specified security context. Allowed values include <literal>restricted</literal> and <literal>legacy</literal>. The default value is <literal>legacy</literal>. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-l</literal>, <literal>--selector</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Label selector to determine which tests are run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-s</literal>, <literal>--service-account</literal> (string)</simpara></entry>
<entry align="left" valign="top"><simpara>Service account to use for tests. The default value is <literal>default</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-x</literal>, <literal>--skip-cleanup</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable resource cleanup after tests are run.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-w</literal>, <literal>--wait-time &lt;duration&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Seconds to wait for tests to complete, for example <literal>35s</literal>. The default value is <literal>30s</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>restricted</literal> security context is not compatible with the <literal>default</literal> namespace. To configure your Operator&#8217;s pod security admission in your production environment, see "Complying with pod security admission". For more information about pod security admission, see "Understanding and managing pod security admission".</simpara>
</listitem>
</orderedlist>
</para>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xl:href="../../operators/operator_sdk/osdk-scorecard.xml#osdk-scorecard">Validating Operators using the scorecard tool</link> for details about running the scorecard tool.</simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/operator_sdk/osdk-complying-with-psa.xml#osdk-complying-with-psa">Complying with pod security admission</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../authentication/understanding-and-managing-pod-security-admission.xml#understanding-and-managing-pod-security-admission">Understanding and managing pod security admission</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="cluster-operators-ref">
<title>Cluster Operators reference</title>

<simpara>This reference guide indexes the <emphasis>cluster Operators</emphasis> shipped by Red Hat that serve as the architectural foundation for {product-title}. Cluster Operators are installed by default, unless otherwise noted, and are managed by the Cluster Version Operator (CVO). For more details on the control plane architecture, see <link xl:href="../architecture/control-plane.xml#operators-overview_control-plane">Operators in {product-title}</link>.</simpara>
<simpara>Cluster administrators can view cluster Operators in the {product-title} web console from the <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> page.</simpara>
<note>
<simpara>Cluster Operators are not managed by Operator Lifecycle Manager (OLM) and OperatorHub. OLM and OperatorHub are part of the <link xl:href="https://operatorframework.io/">Operator Framework</link> used in {product-title} for installing and running optional <link xl:href="../architecture/control-plane.xml#olm-operators_control-plane">add-on Operators</link>.</simpara>
</note>
<simpara>Some of the following cluster Operators can be disabled prior to installation. For more information see <link xl:href="../installing/cluster-capabilities.xml#cluster-capabilities">cluster capabilities</link>.</simpara>
<section xml:id="cluster-bare-metal-operator_cluster-operators-ref">
<title>Cluster Baremetal Operator</title>
<note>
<simpara>The Cluster Baremetal Operator is an optional cluster capability that can be disabled by cluster administrators during installation. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Baremetal Operator (CBO) deploys all the components necessary to take a bare-metal server to a fully functioning worker node ready to run {product-title} compute nodes. The CBO ensures that the metal3 deployment, which consists of the Bare Metal Operator (BMO) and Ironic containers, runs on one of the control plane nodes within the {product-title} cluster. The CBO also listens for {product-title} updates to resources that it watches and takes appropriate action.</simpara>
<bridgehead xml:id="_project" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-baremetal-operator">cluster-baremetal-operator</link></simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#cluster-bare-metal-operator_cluster-capabilities">Bare-metal capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="baremetal-event-relay_cluster-operators-ref">
<title>Bare Metal Event Relay</title>
<bridgehead xml:id="_purpose_2" renderas="sect3">Purpose</bridgehead>
<simpara>The OpenShift Bare Metal Event Relay manages the life-cycle of the Bare Metal Event Relay. The Bare Metal Event Relay enables you to configure the types of cluster event that are monitored using Redfish hardware events.</simpara>
<bridgehead xml:id="_configuration_objects" renderas="sect3">Configuration objects</bridgehead>
<simpara>You can use this command to edit the configuration after installation: for example, the webhook port.
You can edit configuration objects with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n [namespace] edit cm hw-event-proxy-operator-manager-config</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: controller-runtime.sigs.k8s.io/v1alpha1
kind: ControllerManagerConfig
health:
  healthProbeBindAddress: :8081
metrics:
  bindAddress: 127.0.0.1:8080
webhook:
  port: 9443
leaderElection:
  leaderElect: true
  resourceName: 6e7a703c.redhat-cne.org</programlisting>
<bridgehead xml:id="_project_2" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/redhat-cne/hw-event-proxy-operator">hw-event-proxy-operator</link></simpara>
<bridgehead xml:id="_crd" renderas="sect3">CRD</bridgehead>
<simpara>The proxy enables applications running on bare-metal clusters to respond quickly to Redfish hardware changes and failures such as breaches of temperature thresholds, fan failure, disk loss, power outages, and memory failure, reported using the HardwareEvent CR.</simpara>
<simpara><literal>hardwareevents.event.redhat-cne.org</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: HardwareEvent</simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cloud-credential-operator_cluster-operators-ref">
<title>Cloud Credential Operator</title>
<bridgehead xml:id="_purpose_3" renderas="sect3">Purpose</bridgehead>
<simpara>The Cloud Credential Operator (CCO) manages cloud provider credentials as Kubernetes custom resource definitions (CRDs). The CCO syncs on <literal>CredentialsRequest</literal> custom resources (CRs) to allow {product-title} components to request cloud provider credentials with the specific permissions that are required for the cluster to run.</simpara>
<simpara>By setting different values for the <literal>credentialsMode</literal> parameter in the <literal>install-config.yaml</literal> file, the CCO can be configured to operate in several different modes. If no mode is specified, or the <literal>credentialsMode</literal> parameter is set to an empty string (<literal>""</literal>), the CCO operates in its default mode.</simpara>
<bridgehead xml:id="_project_3" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cloud-credential-operator">openshift-cloud-credential-operator</link></simpara>
<bridgehead xml:id="_crds_2" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>credentialsrequests.cloudcredential.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>CredentialsRequest</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_configuration_objects_2" renderas="sect3">Configuration objects</bridgehead>
<simpara>No configuration required.</simpara>
<bridgehead xml:id="additional-resources_cluster-op-ref-cco" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xl:href="../authentication/managing_cloud_provider_credentials/about-cloud-credential-operator.xml#about-cloud-credential-operator">About the Cloud Credential Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../rest_api/security_apis/credentialsrequest-cloudcredential-openshift-io-v1.xml#credentialsrequest-cloudcredential-openshift-io-v1"><literal>CredentialsRequest</literal> custom resource</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-authentication-operator_cluster-operators-ref">
<title>Cluster Authentication Operator</title>
<bridgehead xml:id="_purpose_4" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Authentication Operator installs and maintains the <literal>Authentication</literal> custom resource in a cluster and can be viewed with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperator authentication -o yaml</programlisting>
<bridgehead xml:id="_project_4" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-authentication-operator">cluster-authentication-operator</link></simpara>
</section>
<section xml:id="cluster-autoscaler-operator_cluster-operators-ref">
<title>Cluster Autoscaler Operator</title>
<bridgehead xml:id="_purpose_5" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Autoscaler Operator manages deployments of the OpenShift Cluster Autoscaler using the <literal>cluster-api</literal> provider.</simpara>
<bridgehead xml:id="_project_5" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-autoscaler-operator">cluster-autoscaler-operator</link></simpara>
<bridgehead xml:id="_crds_3" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>ClusterAutoscaler</literal>: This is a singleton resource, which controls the configuration autoscaler instance for the cluster. The Operator only responds to the <literal>ClusterAutoscaler</literal> resource named <literal>default</literal> in the managed namespace, the value of the <literal>WATCH_NAMESPACE</literal> environment variable.</simpara>
</listitem>
<listitem>
<simpara><literal>MachineAutoscaler</literal>: This resource targets a node group and manages the annotations to enable and configure autoscaling for that group, the <literal>min</literal> and <literal>max</literal> size. Currently only <literal>MachineSet</literal> objects can be targeted.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-cloud-controller-manager-operator_cluster-operators-ref">
<title>Cluster Cloud Controller Manager Operator</title>
<bridgehead xml:id="_purpose_6" renderas="sect3">Purpose</bridgehead>
<note>
<simpara>The status of this Operator is General Availability for Amazon Web Services, Google Cloud Platform (GCP), IBM Cloud&#174;, global Microsoft Azure, Microsoft Azure Stack Hub, Nutanix, Red Hat OpenStack Platform (RHOSP), and VMware vSphere.</simpara>
<simpara>The Operator is available as a <link xl:href="https://access.redhat.com/support/offerings/techpreview">Technology Preview</link> for Alibaba Cloud and IBM Power&#174; Virtual Server.</simpara>
</note>
<simpara>The Cluster Cloud Controller Manager Operator manages and updates the cloud controller managers deployed on top of {product-title}. The Operator is based on the Kubebuilder framework and <literal>controller-runtime</literal> libraries. It is installed via the Cluster Version Operator (CVO).</simpara>
<simpara>It contains the following components:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator</simpara>
</listitem>
<listitem>
<simpara>Cloud configuration observer</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the Operator exposes Prometheus metrics through the <literal>metrics</literal> service.</simpara>
<bridgehead xml:id="_project_6" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-cloud-controller-manager-operator">cluster-cloud-controller-manager-operator</link></simpara>
</section>
<section xml:id="cluster-capi-operator_cluster-operators-ref">
<title>Cluster CAPI Operator</title>
<note>
<simpara>This Operator is available as a <link xl:href="https://access.redhat.com/support/offerings/techpreview">Technology Preview</link> for Amazon Web Services (AWS) and Google Cloud Platform (GCP) clusters.</simpara>
</note>
<bridgehead xml:id="_purpose_7" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster CAPI Operator maintains the lifecycle of Cluster API resources. This Operator is responsible for all administrative tasks related to deploying the Cluster API project within an {product-title} cluster.</simpara>
<bridgehead xml:id="_project_7" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-capi-operator">cluster-capi-operator</link></simpara>
<bridgehead xml:id="_crds_4" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>awsmachines.infrastructure.cluster.x-k8s.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>awsmachine</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: No</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>gcpmachines.infrastructure.cluster.x-k8s.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>gcpmachine</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: No</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>awsmachinetemplates.infrastructure.cluster.x-k8s.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>awsmachinetemplate</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: No</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>gcpmachinetemplates.infrastructure.cluster.x-k8s.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>gcpmachinetemplate</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: No</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-config-operator_cluster-operators-ref">
<title>Cluster Config Operator</title>
<bridgehead xml:id="_purpose_8" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Config Operator performs the following tasks related to <literal>config.openshift.io</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Creates CRDs.</simpara>
</listitem>
<listitem>
<simpara>Renders the initial custom resources.</simpara>
</listitem>
<listitem>
<simpara>Handles migrations.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_project_8" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-config-operator">cluster-config-operator</link></simpara>
</section>
<section xml:id="cluster-csi-snapshot-controller-operator_cluster-operators-ref">
<title>Cluster CSI Snapshot Controller Operator</title>
<note>
<simpara>The Cluster CSI Snapshot Controller Operator is an optional cluster capability that can be disabled by cluster administrators during installation. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_9" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster CSI Snapshot Controller Operator installs and maintains the CSI Snapshot Controller. The CSI Snapshot Controller is responsible for watching the <literal>VolumeSnapshot</literal> CRD objects and manages the creation and deletion lifecycle of volume snapshots.</simpara>
<bridgehead xml:id="_project_9" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-csi-snapshot-controller-operator">cluster-csi-snapshot-controller-operator</link></simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#cluster-csi-snapshot-controller-operator_cluster-capabilities">CSI snapshot controller capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-image-registry-operator_cluster-operators-ref">
<title>Cluster Image Registry Operator</title>
<bridgehead xml:id="_purpose_10" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Image Registry Operator manages a singleton instance of the OpenShift image registry. It manages all configuration of the registry, including creating storage.</simpara>
<simpara>On initial start up, the Operator creates a default <literal>image-registry</literal> resource instance based on the configuration detected in the cluster. This indicates what cloud storage type to use based on the cloud provider.</simpara>
<simpara>If insufficient information is available to define a complete <literal>image-registry</literal> resource, then an incomplete resource is defined and the Operator updates the resource status with information about what is missing.</simpara>
<simpara>The Cluster Image Registry Operator runs in the <literal>openshift-image-registry</literal> namespace and it also manages the registry instance in that location. All configuration and workload resources for the registry reside in that namespace.</simpara>
<bridgehead xml:id="_project_10" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-image-registry-operator">cluster-image-registry-operator</link></simpara>
</section>
<section xml:id="cluster-machine-approver-operator_cluster-operators-ref">
<title>Cluster Machine Approver Operator</title>
<bridgehead xml:id="_purpose_11" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Machine Approver Operator automatically approves the CSRs requested for a new worker node after cluster installation.</simpara>
<note>
<simpara>For the control plane node, the <literal>approve-csr</literal> service on the bootstrap node automatically approves all CSRs during the cluster bootstrapping phase.</simpara>
</note>
<bridgehead xml:id="_project_11" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-machine-approver">cluster-machine-approver-operator</link></simpara>
</section>
<section xml:id="cluster-monitoring-operator_cluster-operators-ref">
<title>Cluster Monitoring Operator</title>
<bridgehead xml:id="_purpose_12" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Monitoring Operator manages and updates the Prometheus-based cluster monitoring stack deployed on top of {product-title}.</simpara>
<bridgehead xml:id="_project_12" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-monitoring-operator">openshift-monitoring</link></simpara>
<bridgehead xml:id="_crds_5" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>alertmanagers.monitoring.coreos.com</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>alertmanager</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>prometheuses.monitoring.coreos.com</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>prometheus</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>prometheusrules.monitoring.coreos.com</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>prometheusrule</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>servicemonitors.monitoring.coreos.com</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>servicemonitor</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_configuration_objects_3" renderas="sect3">Configuration objects</bridgehead>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-monitoring edit cm cluster-monitoring-config</programlisting>
</section>
<section xml:id="cluster-network-operator_cluster-operators-ref">
<title>Cluster Network Operator</title>
<bridgehead xml:id="_purpose_13" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Network Operator installs and upgrades the networking components on an {product-title} cluster.</simpara>
</section>
<section xml:id="cluster-samples-operator_cluster-operators-ref">
<title>Cluster Samples Operator</title>
<note>
<simpara>The Cluster Samples Operator is an optional cluster capability that can be disabled by cluster administrators during installation. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_14" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Samples Operator manages the sample image streams and templates stored in the <literal>openshift</literal> namespace.</simpara>
<simpara>On initial start up, the Operator creates the default samples configuration resource to initiate the creation of the image streams and templates. The configuration object is a cluster scoped object with the key <literal>cluster</literal> and type <literal>configs.samples</literal>.</simpara>
<simpara>The image streams are the Red Hat Enterprise Linux CoreOS (RHCOS)-based {product-title} image streams pointing to images on <literal>registry.redhat.io</literal>. Similarly, the templates are those categorized as {product-title} templates.</simpara>
<simpara>The Cluster Samples Operator deployment is contained within the <literal>openshift-cluster-samples-operator</literal> namespace. On start up, the install pull secret is used by the image stream import logic in the OpenShift image registry and API server to authenticate with <literal>registry.redhat.io</literal>. An administrator can create any additional secrets in the <literal>openshift</literal> namespace if they change the registry used for the sample image streams. If created, those secrets contain the content of a <literal>config.json</literal> for <literal>docker</literal> needed to facilitate image import.</simpara>
<simpara>The image for the Cluster Samples Operator contains image stream and template definitions for the associated {product-title} release. After the Cluster Samples Operator creates a sample, it adds an annotation that denotes the {product-title} version that it is compatible with. The Operator uses this annotation to ensure that each sample matches the compatible release version. Samples outside of its inventory are ignored, as are skipped samples.</simpara>
<simpara>Modifications to any samples that are managed by the Operator are allowed as long as the version annotation is not modified or deleted. However, on an upgrade, as the version annotation will change, those modifications can get replaced as the sample will be updated with the newer version. The Jenkins images are part of the image payload from the installation and are tagged into the image streams directly.</simpara>
<simpara>The samples resource includes a finalizer, which cleans up the following upon its deletion:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator-managed image streams</simpara>
</listitem>
<listitem>
<simpara>Operator-managed templates</simpara>
</listitem>
<listitem>
<simpara>Operator-generated configuration resources</simpara>
</listitem>
<listitem>
<simpara>Cluster status resources</simpara>
</listitem>
</itemizedlist>
<simpara>Upon deletion of the samples resource, the Cluster Samples Operator recreates the resource using the default configuration.</simpara>
<bridgehead xml:id="_project_13" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-samples-operator">cluster-samples-operator</link></simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#cluster-samples-operator_cluster-capabilities">OpenShift samples capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-storage-operator_cluster-operators-ref">
<title>Cluster Storage Operator</title>
<note>
<simpara>The Cluster Storage Operator is an optional cluster capability that can be disabled by cluster administrators during installation. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_15" renderas="sect3">Purpose</bridgehead>
<simpara>The Cluster Storage Operator sets {product-title} cluster-wide storage defaults. It ensures a default <literal>storageclass</literal> exists for {product-title} clusters. It also installs Container Storage Interface (CSI) drivers which enable your cluster to use various storage backends.</simpara>
<bridgehead xml:id="_project_14" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-storage-operator">cluster-storage-operator</link></simpara>
<bridgehead xml:id="_configuration" renderas="sect3">Configuration</bridgehead>
<simpara>No configuration is required.</simpara>
<bridgehead xml:id="_notes" renderas="sect3">Notes</bridgehead>
<itemizedlist>
<listitem>
<simpara>The storage class that the Operator creates can be made non-default by editing its annotation, but this storage class cannot be deleted as long as the Operator runs.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#cluster-storage-operator_cluster-capabilities">Storage capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-version-operator_cluster-operators-ref">
<title>Cluster Version Operator</title>
<bridgehead xml:id="_purpose_16" renderas="sect3">Purpose</bridgehead>
<simpara>Cluster Operators manage specific areas of cluster functionality. The Cluster Version Operator (CVO) manages the lifecycle of cluster Operators, many of which are installed in {product-title} by default.</simpara>
<simpara>The CVO also checks with the OpenShift Update Service to see the valid updates and update paths based on current component versions and information in the graph.</simpara>
<bridgehead xml:id="_project_15" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-version-operator">cluster-version-operator</link></simpara>
</section>
<section xml:id="console-operator_cluster-operators-ref">
<title>Console Operator</title>
<note>
<simpara>The Console Operator is an optional cluster capability that can be disabled by cluster administrators during installation. If you disable the Console Operator at installation, your cluster is still supported and upgradable. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_17" renderas="sect3">Purpose</bridgehead>
<simpara>The Console Operator installs and maintains the {product-title} web console on a cluster. The Console Operator is installed by default and automatically maintains a console.</simpara>
<bridgehead xml:id="_project_16" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/console-operator">console-operator</link></simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#console-operator_cluster-capabilities">Web console capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="control-plane-machine-set-operator_cluster-operators-ref">
<title>Control Plane Machine Set Operator</title>
<note>
<simpara>This Operator is available for Amazon Web Services (AWS), Google Cloud Platform (GCP), Microsoft Azure, Nutanix, and VMware vSphere.</simpara>
</note>
<bridgehead xml:id="_purpose_18" renderas="sect3">Purpose</bridgehead>
<simpara>The Control Plane Machine Set Operator automates the management of control plane machine resources within an {product-title} cluster.</simpara>
<bridgehead xml:id="_project_17" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-control-plane-machine-set-operator">cluster-control-plane-machine-set-operator</link></simpara>
<bridgehead xml:id="_crds_6" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>controlplanemachineset.machine.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>ControlPlaneMachineSet</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="additional-resources_cluster-op-ref-cpmso" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xl:href="../machine_management/control_plane_machine_management/cpmso-about.xml#cpmso-about">About control plane machine sets</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../rest_api/machine_apis/controlplanemachineset-machine-openshift-io-v1.xml#controlplanemachineset-machine-openshift-io-v1"><literal>ControlPlaneMachineSet</literal> custom resource</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="dns-operator_cluster-operators-ref">
<title>DNS Operator</title>
<bridgehead xml:id="_purpose_19" renderas="sect3">Purpose</bridgehead>
<simpara>The DNS Operator deploys and manages CoreDNS to provide a name resolution service to pods that enables DNS-based Kubernetes Service discovery in {product-title}.</simpara>
<simpara>The Operator creates a working default deployment based on the cluster&#8217;s configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>The default cluster domain is <literal>cluster.local</literal>.</simpara>
</listitem>
<listitem>
<simpara>Configuration of the CoreDNS Corefile or Kubernetes plugin is not yet supported.</simpara>
</listitem>
</itemizedlist>
<simpara>The DNS Operator manages CoreDNS as a Kubernetes daemon set exposed as a service with a static IP. CoreDNS runs on all nodes in the cluster.</simpara>
<bridgehead xml:id="_project_18" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-dns-operator">cluster-dns-operator</link></simpara>
</section>
<section xml:id="etcd-cluster-operator_cluster-operators-ref">
<title>etcd cluster Operator</title>
<bridgehead xml:id="_purpose_20" renderas="sect3">Purpose</bridgehead>
<simpara>The etcd cluster Operator automates etcd cluster scaling, enables etcd monitoring and metrics, and simplifies disaster recovery procedures.</simpara>
<bridgehead xml:id="_project_19" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-etcd-operator/">cluster-etcd-operator</link></simpara>
<bridgehead xml:id="_crds_7" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>etcds.operator.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Cluster</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>etcd</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_configuration_objects_4" renderas="sect3">Configuration objects</bridgehead>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit etcd cluster</programlisting>
</section>
<section xml:id="ingress-operator_cluster-operators-ref">
<title>Ingress Operator</title>
<bridgehead xml:id="_purpose_21" renderas="sect3">Purpose</bridgehead>
<simpara>The Ingress Operator configures and manages the {product-title} router.</simpara>
<bridgehead xml:id="_project_20" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-ingress-operator">openshift-ingress-operator</link></simpara>
<bridgehead xml:id="_crds_8" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>clusteringresses.ingress.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Namespaced</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>clusteringresses</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: No</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_configuration_objects_5" renderas="sect3">Configuration objects</bridgehead>
<itemizedlist>
<listitem>
<simpara>Cluster config</simpara>
<itemizedlist>
<listitem>
<simpara>Type Name: <literal>clusteringresses.ingress.openshift.io</literal></simpara>
</listitem>
<listitem>
<simpara>Instance Name: <literal>default</literal></simpara>
</listitem>
<listitem>
<simpara>View Command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteringresses.ingress.openshift.io -n openshift-ingress-operator default -o yaml</programlisting>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_notes_2" renderas="sect3">Notes</bridgehead>
<simpara>The Ingress Operator sets up the router in the <literal>openshift-ingress</literal> project and creates the deployment for the router:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get deployment -n openshift-ingress</programlisting>
<simpara>The Ingress Operator uses the <literal>clusterNetwork[].cidr</literal> from the <literal>network/cluster</literal> status to determine what mode (IPv4, IPv6, or dual stack) the managed Ingress Controller (router) should operate in. For example, if <literal>clusterNetwork</literal> contains only a v6 <literal>cidr</literal>, then the Ingress Controller operates in IPv6-only mode.</simpara>
<simpara>In the following example, Ingress Controllers managed by the Ingress Operator will run in IPv4-only mode because only one cluster network exists and the network is an IPv4 <literal>cidr</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get network/cluster -o jsonpath='{.status.clusterNetwork[*]}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">map[cidr:10.128.0.0/14 hostPrefix:23]</programlisting>
</para>
</formalpara>
</section>
<section xml:id="insights-operator_cluster-operators-ref">
<title>Insights Operator</title>
<note>
<simpara>The Insights Operator is an optional cluster capability that can be disabled by cluster administrators during installation. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_22" renderas="sect3">Purpose</bridgehead>
<simpara>The Insights Operator gathers {product-title} configuration data and sends it to Red Hat. The data is used to produce proactive insights recommendations about potential issues that a cluster might be exposed to. These insights are communicated to cluster administrators through Insights Advisor on <link xl:href="https://console.redhat.com/">console.redhat.com</link>.</simpara>
<bridgehead xml:id="_project_21" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/insights-operator">insights-operator</link></simpara>
<bridgehead xml:id="_configuration_2" renderas="sect3">Configuration</bridgehead>
<simpara>No configuration is required.</simpara>
<bridgehead xml:id="_notes_3" renderas="sect3">Notes</bridgehead>
<simpara>Insights Operator complements {product-title} Telemetry.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#insights-operator_cluster-capabilities">Insights capability</link></simpara>
</listitem>
<listitem>
<simpara>See <link xl:href="../support/remote_health_monitoring/about-remote-health-monitoring.xml#about-remote-health-monitoring">About remote health monitoring</link> for details about Insights Operator and Telemetry.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="kube-apiserver-operator_cluster-operators-ref">
<title>Kubernetes API Server Operator</title>
<bridgehead xml:id="_purpose_23" renderas="sect3">Purpose</bridgehead>
<simpara>The Kubernetes API Server Operator manages and updates the Kubernetes API server deployed on top of {product-title}. The Operator is based on the {product-title} <literal>library-go</literal> framework and it is installed using the Cluster Version Operator (CVO).</simpara>
<bridgehead xml:id="_project_22" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-kube-apiserver-operator">openshift-kube-apiserver-operator</link></simpara>
<bridgehead xml:id="_crds_9" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>kubeapiservers.operator.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Cluster</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>kubeapiserver</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<bridgehead xml:id="_configuration_objects_6" renderas="sect3">Configuration objects</bridgehead>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit kubeapiserver</programlisting>
</section>
<section xml:id="kube-controller-manager-operator_cluster-operators-ref">
<title>Kubernetes Controller Manager Operator</title>
<bridgehead xml:id="_purpose_24" renderas="sect3">Purpose</bridgehead>
<simpara>The Kubernetes Controller Manager Operator manages and updates the Kubernetes Controller Manager deployed on top of {product-title}. The Operator is based on {product-title} <literal>library-go</literal> framework and it is installed via the Cluster Version Operator (CVO).</simpara>
<simpara>It contains the following components:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator</simpara>
</listitem>
<listitem>
<simpara>Bootstrap manifest renderer</simpara>
</listitem>
<listitem>
<simpara>Installer based on static pods</simpara>
</listitem>
<listitem>
<simpara>Configuration observer</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the Operator exposes Prometheus metrics through the <literal>metrics</literal> service.</simpara>
<bridgehead xml:id="_project_23" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-kube-controller-manager-operator">cluster-kube-controller-manager-operator</link></simpara>
</section>
<section xml:id="cluster-kube-scheduler-operator_cluster-operators-ref">
<title>Kubernetes Scheduler Operator</title>
<bridgehead xml:id="_purpose_25" renderas="sect3">Purpose</bridgehead>
<simpara>The Kubernetes Scheduler Operator manages and updates the Kubernetes Scheduler deployed on top of {product-title}. The Operator is based on the {product-title} <literal>library-go</literal> framework and it is installed with the Cluster Version Operator (CVO).</simpara>
<simpara>The Kubernetes Scheduler Operator contains the following components:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator</simpara>
</listitem>
<listitem>
<simpara>Bootstrap manifest renderer</simpara>
</listitem>
<listitem>
<simpara>Installer based on static pods</simpara>
</listitem>
<listitem>
<simpara>Configuration observer</simpara>
</listitem>
</itemizedlist>
<simpara>By default, the Operator exposes Prometheus metrics through the metrics service.</simpara>
<bridgehead xml:id="_project_24" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-kube-scheduler-operator">cluster-kube-scheduler-operator</link></simpara>
<bridgehead xml:id="_configuration_3" renderas="sect3">Configuration</bridgehead>
<simpara>The configuration for the Kubernetes Scheduler is the result of merging:</simpara>
<itemizedlist>
<listitem>
<simpara>a default configuration.</simpara>
</listitem>
<listitem>
<simpara>an observed configuration from the spec <literal>schedulers.config.openshift.io</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>All of these are sparse configurations, invalidated JSON snippets which are merged to form a valid configuration at the end.</simpara>
</section>
<section xml:id="cluster-kube-storage-version-migrator-operator_cluster-operators-ref">
<title>Kubernetes Storage Version Migrator Operator</title>
<bridgehead xml:id="_purpose_26" renderas="sect3">Purpose</bridgehead>
<simpara>The Kubernetes Storage Version Migrator Operator detects changes of the default storage version, creates migration requests for resource types when the storage version changes, and processes migration requests.</simpara>
<bridgehead xml:id="_project_25" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-kube-storage-version-migrator-operator">cluster-kube-storage-version-migrator-operator</link></simpara>
</section>
<section xml:id="machine-api-operator_cluster-operators-ref">
<title>Machine API Operator</title>
<bridgehead xml:id="_purpose_27" renderas="sect3">Purpose</bridgehead>
<simpara>The Machine API Operator manages the lifecycle of specific purpose custom resource definitions (CRD), controllers, and RBAC objects that extend the Kubernetes API. This declares the desired state of machines in a cluster.</simpara>
<bridgehead xml:id="_project_26" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/machine-api-operator">machine-api-operator</link></simpara>
<bridgehead xml:id="_crds_10" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>MachineSet</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Machine</literal></simpara>
</listitem>
<listitem>
<simpara><literal>MachineHealthCheck</literal></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-config-operator_cluster-operators-ref">
<title>Machine Config Operator</title>
<bridgehead xml:id="_purpose_28" renderas="sect3">Purpose</bridgehead>
<simpara>The Machine Config Operator manages and applies configuration and updates of the base operating system and container runtime, including everything between the kernel and kubelet.</simpara>
<simpara>There are four components:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>machine-config-server</literal>: Provides Ignition configuration to new machines joining the cluster.</simpara>
</listitem>
<listitem>
<simpara><literal>machine-config-controller</literal>: Coordinates the upgrade of machines to the desired configurations defined by a <literal>MachineConfig</literal> object. Options are provided to control the upgrade for sets of machines individually.</simpara>
</listitem>
<listitem>
<simpara><literal>machine-config-daemon</literal>: Applies new machine configuration during update. Validates and verifies the state of the machine to the requested machine configuration.</simpara>
</listitem>
<listitem>
<simpara><literal>machine-config</literal>: Provides a complete source of machine configuration at installation, first start up, and updates for a machine.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Currently, there is no supported way to block or restrict the machine config server endpoint. The machine config server must be exposed to the network so that newly-provisioned machines, which have no existing configuration or state, are able to fetch their configuration. In this model, the root of trust is the certificate signing requests (CSR) endpoint, which is where the kubelet sends its certificate signing request for approval to join the cluster. Because of this, machine configs should not be used to distribute sensitive information, such as secrets and certificates.</simpara>
<simpara>To ensure that the machine config server endpoints, ports 22623 and 22624, are secured in bare metal scenarios, customers must configure proper network policies.</simpara>
</important>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../networking/openshift_sdn/about-openshift-sdn.xml#about-openshift-sdn">About the OpenShift SDN network plugin</link>.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_project_27" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/machine-config-operator">openshift-machine-config-operator</link></simpara>
</section>
<section xml:id="marketplace-operator_cluster-operators-ref">
<title>Marketplace Operator</title>
<note>
<simpara>The Marketplace Operator is an optional cluster capability that can be disabled by cluster administrators if it is not needed. For more information about optional cluster capabilities, see "Cluster capabilities" in <emphasis>Installing</emphasis>.</simpara>
</note>
<bridgehead xml:id="_purpose_29" renderas="sect3">Purpose</bridgehead>
<simpara>The Marketplace Operator simplifies the process for bringing off-cluster Operators to your cluster by using a set of default Operator Lifecycle Manager (OLM) catalogs on the cluster. When the Marketplace Operator is installed, it creates the <literal>openshift-marketplace</literal> namespace. OLM ensures catalog sources installed in the <literal>openshift-marketplace</literal> namespace are available for all namespaces on the cluster.</simpara>
<bridgehead xml:id="_project_28" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/operator-framework/operator-marketplace">operator-marketplace</link></simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../installing/cluster-capabilities.xml#marketplace-operator_cluster-capabilities">Marketplace capability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-node-tuning-operator_cluster-operators-ref">
<title>Node Tuning Operator</title>
<bridgehead xml:id="_purpose_30" renderas="sect3">Purpose</bridgehead>
<simpara>The Node Tuning Operator helps you manage node-level tuning by orchestrating the TuneD daemon and achieves low latency performance by using the Performance Profile controller. The majority of high-performance applications require some level of kernel tuning. The Node Tuning Operator provides a unified management interface to users of node-level sysctls and more flexibility to add custom tuning specified by user needs.</simpara>
<simpara>The Operator manages the containerized TuneD daemon for {product-title} as a Kubernetes daemon set. It ensures the custom tuning specification is passed to all containerized TuneD daemons running in the cluster in the format that the daemons understand. The daemons run on all nodes in the cluster, one per node.</simpara>
<simpara>Node-level settings applied by the containerized TuneD daemon are rolled back on an event that triggers a profile change or when the containerized TuneD daemon is terminated gracefully by receiving and handling a termination signal.</simpara>
<simpara>The Node Tuning Operator uses the Performance Profile controller to implement automatic tuning to achieve low latency performance for {product-title} applications.</simpara>
<simpara>The cluster administrator configures a performance profile to define node-level settings such as the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Updating the kernel to kernel-rt.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for housekeeping.</simpara>
</listitem>
<listitem>
<simpara>Choosing CPUs for running workloads.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Currently, disabling CPU load balancing is not supported by cgroup v2. As a result, you might not get the desired behavior from performance profiles if you have cgroup v2 enabled. Enabling cgroup v2 is not recommended if you are using performance profiles.</simpara>
</note>
<simpara>The Node Tuning Operator is part of a standard {product-title} installation in version 4.1 and later.</simpara>
<note>
<simpara>In earlier versions of {product-title}, the Performance Addon Operator was used to implement automatic tuning to achieve low latency performance for OpenShift applications. In {product-title} 4.11 and later, this functionality is part of the Node Tuning Operator.</simpara>
</note>
<bridgehead xml:id="_project_29" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-node-tuning-operator">cluster-node-tuning-operator</link></simpara>
<bridgehead xml:id="cluster-operators-ref-nto-addtl-resources" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara><link xl:href="../scalability_and_performance/cnf-low-latency-tuning.xml#cnf-understanding-low-latency_cnf-master">Low latency tuning of OCP nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-apiserver-operator_cluster-operators-ref">
<title>OpenShift API Server Operator</title>
<bridgehead xml:id="_purpose_31" renderas="sect3">Purpose</bridgehead>
<simpara>The OpenShift API Server Operator installs and maintains the <literal>openshift-apiserver</literal> on a cluster.</simpara>
<bridgehead xml:id="_project_30" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-openshift-apiserver-operator">openshift-apiserver-operator</link></simpara>
<bridgehead xml:id="_crds_11" renderas="sect3">CRDs</bridgehead>
<itemizedlist>
<listitem>
<simpara><literal>openshiftapiservers.operator.openshift.io</literal></simpara>
<itemizedlist>
<listitem>
<simpara>Scope: Cluster</simpara>
</listitem>
<listitem>
<simpara>CR: <literal>openshiftapiserver</literal></simpara>
</listitem>
<listitem>
<simpara>Validation: Yes</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-openshift-controller-manager-operator_cluster-operators-ref">
<title>OpenShift Controller Manager Operator</title>
<bridgehead xml:id="_purpose_32" renderas="sect3">Purpose</bridgehead>
<simpara>The OpenShift Controller Manager Operator installs and maintains the <literal>OpenShiftControllerManager</literal> custom resource in a cluster and can be viewed with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperator openshift-controller-manager -o yaml</programlisting>
<simpara>The custom resource definition (CRD) <literal>openshiftcontrollermanagers.operator.openshift.io</literal> can be viewed in a cluster with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get crd openshiftcontrollermanagers.operator.openshift.io -o yaml</programlisting>
<bridgehead xml:id="_project_31" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/cluster-openshift-controller-manager-operator">cluster-openshift-controller-manager-operator</link></simpara>
</section>
<section xml:id="cluster-operators-ref-olm">
<title>Operator Lifecycle Manager Operators</title>
<bridgehead xml:id="olm-overview_cluster-operators-ref" renderas="sect3">Purpose</bridgehead>
<simpara><emphasis>Operator Lifecycle Manager</emphasis> (OLM) helps users install, update, and manage the lifecycle of Kubernetes native applications (Operators) and their associated services running across their {product-title} clusters. It is part of the <link xl:href="https://operatorframework.io/">Operator Framework</link>, an open source toolkit designed to manage Operators in an effective, automated, and scalable way.</simpara>
<figure>
<title>Operator Lifecycle Manager workflow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/olm-workflow.png"/>
</imageobject>
<textobject><phrase>olm workflow</phrase></textobject>
</mediaobject>
</figure>
<simpara>OLM runs by default in {product-title} {product-version}, which aids
cluster administrators
in installing, upgrading, and granting access to Operators running on their cluster. The {product-title} web console provides management screens for
cluster administrators
to install Operators, as well as grant specific projects access to use the catalog of Operators available on the cluster.</simpara>
<simpara>For developers, a self-service experience allows provisioning and configuring instances of databases, monitoring, and big data services without having to be subject matter experts, because the Operator has that knowledge baked into it.</simpara>
<bridgehead xml:id="olm-architecture_cluster-operators-ref" renderas="sect3">CRDs</bridgehead>
<simpara>Operator Lifecycle Manager (OLM) is composed of two Operators: the OLM Operator and the Catalog Operator.</simpara>
<simpara>Each of these Operators is responsible for managing the custom resource definitions (CRDs) that are the basis for the OLM framework:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CRDs managed by OLM and Catalog Operators</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="8.3333*"/>
<colspec colname="col_3" colwidth="8.3333*"/>
<colspec colname="col_4" colwidth="66.6668*"/>
<thead>
<row>
<entry align="left" valign="top">Resource</entry>
<entry align="left" valign="top">Short name</entry>
<entry align="left" valign="top">Owner</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterServiceVersion</literal> (CSV)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>csv</literal></simpara></entry>
<entry align="left" valign="top"><simpara>OLM</simpara></entry>
<entry align="left" valign="top"><simpara>Application metadata: name, version, icon, required resources, installation, and so on.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InstallPlan</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>ip</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>Calculated list of resources to be created to automatically install or upgrade a CSV.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CatalogSource</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>catsrc</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>A repository of CSVs, CRDs, and packages that define an application.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Subscription</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>sub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Catalog</simpara></entry>
<entry align="left" valign="top"><simpara>Keeps CSVs up to date by tracking a channel in a package.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OperatorGroup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>og</literal></simpara></entry>
<entry align="left" valign="top"><simpara>OLM</simpara></entry>
<entry align="left" valign="top"><simpara>Configures all Operators deployed in the same namespace as the <literal>OperatorGroup</literal> object to watch for their custom resource (CR) in a list of namespaces or cluster-wide.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>Each of these Operators is also responsible for creating the following resources:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Resources created by OLM and Catalog Operators</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Resource</entry>
<entry align="left" valign="top">Owner</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Deployments</literal></simpara></entry>
<entry align="left" valign="middle" morerows="3"><simpara>OLM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ServiceAccounts</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>(Cluster)Roles</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>(Cluster)RoleBindings</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CustomResourceDefinitions</literal> (CRDs)</simpara></entry>
<entry align="left" valign="middle" morerows="1"><simpara>Catalog</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClusterServiceVersions</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<bridgehead xml:id="olm-arch-olm-operator_cluster-operators-ref" renderas="sect3">OLM Operator</bridgehead>
<simpara>The OLM Operator is responsible for deploying applications defined by CSV resources after the required resources specified in the CSV are present in the cluster.</simpara>
<simpara>The OLM Operator is not concerned with the creation of the required resources; you can choose to manually create these resources using the CLI or using the Catalog Operator. This separation of concern allows users incremental buy-in in terms of how much of the OLM framework they choose to leverage for their application.</simpara>
<simpara>The OLM Operator uses the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Watch for cluster service versions (CSVs) in a namespace and check that requirements are met.</simpara>
</listitem>
<listitem>
<simpara>If requirements are met, run the install strategy for the CSV.</simpara>
<note>
<simpara>A CSV must be an active member of an Operator group for the install strategy to run.</simpara>
</note>
</listitem>
</orderedlist>
<bridgehead xml:id="olm-arch-catalog-operator_cluster-operators-ref" renderas="sect3">Catalog Operator</bridgehead>
<simpara>The Catalog Operator is responsible for resolving and installing cluster service versions (CSVs) and the required resources they specify. It is also responsible for watching catalog sources for updates to packages in channels and upgrading them, automatically if desired, to the latest available versions.</simpara>
<simpara>To track a package in a channel, you can create a <literal>Subscription</literal> object configuring the desired package, channel, and the <literal>CatalogSource</literal> object you want to use for pulling updates. When updates are found, an appropriate <literal>InstallPlan</literal> object is written into the namespace on behalf of the user.</simpara>
<simpara>The Catalog Operator uses the following workflow:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Connect to each catalog source in the cluster.</simpara>
</listitem>
<listitem>
<simpara>Watch for unresolved install plans created by a user, and if found:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Find the CSV matching the name requested and add the CSV as a resolved resource.</simpara>
</listitem>
<listitem>
<simpara>For each managed or required CRD, add the CRD as a resolved resource.</simpara>
</listitem>
<listitem>
<simpara>For each required CRD, find the CSV that manages it.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Watch for resolved install plans and create all of the discovered resources for it, if approved by a user or automatically.</simpara>
</listitem>
<listitem>
<simpara>Watch for catalog sources and subscriptions and create install plans based on them.</simpara>
</listitem>
</orderedlist>
<bridgehead xml:id="olm-arch-catalog-registry_cluster-operators-ref" renderas="sect3">Catalog Registry</bridgehead>
<simpara>The Catalog Registry stores CSVs and CRDs for creation in a cluster and stores metadata about packages and channels.</simpara>
<simpara>A <emphasis>package manifest</emphasis> is an entry in the Catalog Registry that associates a package identity with sets of CSVs. Within a package, channels point to a particular CSV. Because CSVs explicitly reference the CSV that they replace, a package manifest provides the Catalog Operator with all of the information that is required to update a CSV to the latest version in a channel, stepping through each intermediate version.</simpara>
<bridgehead xml:id="cluster-operators-ref-olm-addtl-resources" role="_additional-resources" renderas="sect3">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara>For more information, see the sections on <link xl:href="../operators/understanding/olm/olm-understanding-olm.xml#olm-understanding-olm">understanding Operator Lifecycle Manager (OLM)</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="openshift-service-ca-operator_cluster-operators-ref">
<title>OpenShift Service CA Operator</title>
<bridgehead xml:id="_purpose_33" renderas="sect3">Purpose</bridgehead>
<simpara>The OpenShift Service CA Operator mints and manages serving certificates for Kubernetes services.</simpara>
<bridgehead xml:id="_project_32" renderas="sect3">Project</bridgehead>
<simpara><link xl:href="https://github.com/openshift/service-ca-operator">openshift-service-ca-operator</link></simpara>
</section>
<section xml:id="vsphere-problem-detector-operator_cluster-operators-ref">
<title>vSphere Problem Detector Operator</title>
<bridgehead xml:id="_purpose_34" renderas="sect3">Purpose</bridgehead>
<simpara>The vSphere Problem Detector Operator checks clusters that are deployed on vSphere for common installation and misconfiguration issues that are related to storage.</simpara>
<note>
<simpara>The vSphere Problem Detector Operator is only started by the Cluster Storage Operator when the Cluster Storage Operator detects that the cluster is deployed on vSphere.</simpara>
</note>
<bridgehead xml:id="_configuration_4" renderas="sect3">Configuration</bridgehead>
<simpara>No configuration is required.</simpara>
<bridgehead xml:id="_notes_4" renderas="sect3">Notes</bridgehead>
<itemizedlist>
<listitem>
<simpara>The Operator supports {product-title} installations on vSphere.</simpara>
</listitem>
<listitem>
<simpara>The Operator uses the <literal>vsphere-cloud-credentials</literal> to communicate with vSphere.</simpara>
</listitem>
<listitem>
<simpara>The Operator performs checks that are related to storage.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more details, see <link xl:href="../installing/installing_vsphere/using-vsphere-problem-detector-operator.xml#using-vsphere-problem-detector-operator">Using the vSphere Problem Detector Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="_olm_1_0_technology_preview">
<title>OLM 1.0 (Technology Preview)</title>
<section xml:id="olmv1-about">
<title>About Operator Lifecycle Manager 1.0 (Technology Preview)</title>

<simpara>Operator Lifecycle Manager (OLM) has been included with {product-title} 4 since its initial release. {product-title} 4.14 introduces components for a next-generation iteration of OLM as a Technology Preview feature, known during this phase as <emphasis>OLM 1.0</emphasis>. This updated framework evolves many of the concepts that have been part of previous versions of OLM and adds new capabilities.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>During this Technology Preview phase of OLM 1.0 in {product-title} 4.14, administrators can explore the following features:</simpara>
<variablelist>
<varlistentry>
<term>Fully declarative model that supports GitOps workflows</term>
<listitem>
<simpara>OLM 1.0 simplifies Operator management through two key APIs:</simpara>
<itemizedlist>
<listitem>
<simpara>A new <literal>Operator</literal> API, provided as <literal>operator.operators.operatorframework.io</literal> by the new Operator Controller component, streamlines management of installed Operators by consolidating user-facing APIs into a single object. This empowers administrators and SREs to automate processes and define desired states by using GitOps principles.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Catalog</literal> API, provided by the new catalogd component, serves as the foundation for OLM 1.0, unpacking catalogs for on-cluster clients so that users can discover installable content, such as Operators and Kubernetes extensions. This provides increased visibility into all available Operator bundle versions, including their details, channels, and update edges.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see <link xl:href="../../operators/olm_v1/arch/olmv1-operator-controller.xml#olmv1-operator-controller">Operator Controller</link> and <link xl:href="../../operators/olm_v1/arch/olmv1-catalogd.xml#olmv1-catalogd">Catalogd</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Improved control over Operator updates</term>
<listitem>
<simpara>With improved insight into catalog content, administrators can specify target versions for installation and updates. This grants administrators more control over the target version of Operator updates. For more information, see <link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-updating-an-operator_olmv1-installing-operator">Updating an Operator</link>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Flexible Operator packaging format</term>
<listitem>
<simpara>Administrators can use file-based catalogs to install and manage the following types of content:</simpara>
<itemizedlist>
<listitem>
<simpara>OLM-based Operators, similar to the existing OLM experience</simpara>
</listitem>
<listitem>
<simpara><emphasis>Plain bundles</emphasis>, which are static collections of arbitrary Kubernetes manifests</simpara>
</listitem>
</itemizedlist>
<simpara>In addition, bundle size is no longer constrained by the etcd value size limit. For more information, see <link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-installing-an-operator-from-a-catalog">Installing an Operator from a catalog</link> and <link xl:href="../../operators/olm_v1/olmv1-managing-plain-bundles.xml#olmv1-managing-plain-bundles">Managing plain bundles</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<section xml:id="olmv1-about-purpose_olmv1-about">
<title>Purpose</title>
<simpara>The mission of Operator Lifecycle Manager (OLM) has been to manage the lifecycle of cluster extensions centrally and declaratively on Kubernetes clusters. Its purpose has always been to make installing, running, and updating functional extensions to the cluster easy, safe, and reproducible for cluster and platform-as-a-service (PaaS) administrators throughout the lifecycle of the underlying cluster.</simpara>
<simpara>The initial version of OLM, which launched with {product-title} 4 and is included by default, focused on providing unique support for these specific needs for a particular type of cluster extension, known as Operators. Operators are classified as one or more Kubernetes controllers, shipping with one or more API extensions, as <literal>CustomResourceDefinition</literal> (CRD) objects, to provide additional functionality to the cluster.</simpara>
<simpara>After running in production clusters for many releases, the next-generation of OLM aims to encompass lifecycles for cluster extensions that are not just Operators.</simpara>
</section>
</section>
<section xml:id="_components_and_architecture">
<title>Components and architecture</title>
<section xml:id="olmv1-components">
<title>OLM 1.0 components overview (Technology Preview)</title>

<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Operator Lifecycle Manager (OLM) 1.0 comprises the following component projects:</simpara>
<variablelist>
<varlistentry>
<term>Operator Controller</term>
<listitem>
<simpara><link xl:href="../../../operators/olm_v1/arch/olmv1-operator-controller.xml#olmv1-operator-controller">Operator Controller</link> is the central component of OLM 1.0 that extends Kubernetes with an API through which users can install and manage the lifecycle of Operators and extensions. It consumes information from each of the following components.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>RukPak</term>
<listitem>
<simpara><link xl:href="../../../operators/olm_v1/arch/olmv1-rukpak.xml#olmv1-rukpak">RukPak</link> is a pluggable solution for packaging and distributing cloud-native content. It supports advanced strategies for installation, updates, and policy.</simpara>
<simpara>RukPak provides a content ecosystem for installing a variety of artifacts on a Kubernetes cluster. Artifact examples include Git repositories, Helm charts, and OLM bundles. RukPak can then manage, scale, and upgrade these artifacts in a safe way to enable powerful cluster extensions.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Catalogd</term>
<listitem>
<simpara><link xl:href="../../../operators/olm_v1/arch/olmv1-catalogd.xml#olmv1-catalogd">Catalogd</link> is a Kubernetes extension that unpacks file-based catalog (FBC) content packaged and shipped in container images for consumption by on-cluster clients. As a component of the OLM 1.0 microservices architecture, catalogd hosts metadata for Kubernetes extensions packaged by the authors of the extensions, and as a result helps users discover installable content.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="olmv1-operator-controller">
<title>Operator Controller (Technology Preview)</title>

<simpara>Operator Controller is the central component of Operator Lifecycle Manager (OLM) 1.0 and consumes the other OLM 1.0 components, RukPak and catalogd. It extends Kubernetes with an API through which users can install Operators and extensions.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="olmv1-operator-api">
<title>Operator API</title>
<simpara>Operator Controller provides a new <literal>Operator</literal> API object, which is a single resource that represents an instance of an installed Operator. This <literal>operator.operators.operatorframework.io</literal> API streamlines management of installed Operators by consolidating user-facing APIs into a single object.</simpara>
<important>
<simpara>In OLM 1.0, <literal>Operator</literal> objects are cluster-scoped. This differs from earlier OLM versions where Operators could be either namespace-scoped or cluster-scoped, depending on the configuration of their related <literal>Subscription</literal> and <literal>OperatorGroup</literal> objects.</simpara>
<simpara>For more information about the earlier behavior, see <emphasis>Multitenancy and Operator colocation</emphasis>.</simpara>
</important>
<formalpara>
<title>Example <literal>Operator</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: &lt;operator_name&gt;
spec:
  packageName: &lt;package_name&gt;
  channel: &lt;channel_name&gt;
  version: &lt;version_number&gt;</programlisting>
</para>
</formalpara>
<note>
<simpara>When using the OpenShift CLI (<literal>oc)</literal>, the <literal>Operator</literal> resource provided with OLM 1.0 during this Technology Preview phase requires specifying the full <literal>&lt;resource&gt;.&lt;group&gt;</literal> format: <literal>operator.operators.operatorframework.io</literal>. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io</programlisting>
<simpara>If you specify only the <literal>Operator</literal> resource without the API group, the CLI returns results for an earlier API (<literal>operator.operators.coreos.com</literal>) that is unrelated to OLM 1.0.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm/olm-colocation.xml#olm-colocation">Operator Lifecycle Manager (OLM) &#8594; Multitenancy and Operator colocation</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olmv1-about-target-versions_olmv1-operator-controller">
<title>Example custom resources (CRs) that specify a target version</title>
<simpara>In Operator Lifecycle Manager (OLM) 1.0, cluster administrators can declaratively set the target version of an Operator or extension in the custom resource (CR).</simpara>
<simpara>You can define a target version by specifying any of the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel</simpara>
</listitem>
<listitem>
<simpara>Version number</simpara>
</listitem>
<listitem>
<simpara>Version range</simpara>
</listitem>
</itemizedlist>
<simpara>If you specify a channel in the CR, OLM 1.0 installs the latest version of the Operator or extension that can be resolved within the specified channel. When updates are published to the specified channel, OLM 1.0 automatically updates to the latest release that can be resolved from the channel.</simpara>
<formalpara>
<title>Example CR with a specified channel</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  channel: latest <co xml:id="CO103-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO103-1">
<para>Installs the latest release that can be resolved from the specified channel. Updates to the channel are automatically installed.</para>
</callout>
</calloutlist>
<simpara>If you specify the Operator or extension&#8217;s target version in the CR, OLM 1.0 installs the specified version. When the target version is specified in the CR, OLM 1.0 does not change the target version when updates are published to the catalog.</simpara>
<simpara>If you want to update the version of the Operator that is installed on the cluster, you must manually edit the Operator&#8217;s CR. Specifying an Operator&#8217;s target version pins the Operator&#8217;s version to the specified release.</simpara>
<formalpara>
<title>Example CR with the target version specified</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: 1.11.1 <co xml:id="CO104-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO104-1">
<para>Specifies the target version. If you want to update the version of the Operator or extension that is installed, you must manually update this field the CR to the desired target version.</para>
</callout>
</calloutlist>
<simpara>If you want to define a range of acceptable versions for an Operator or extension, you can specify a version range by using a comparison string. When you specify a version range, OLM 1.0 installs the latest version of an Operator or extension that can be resolved by the Operator Controller.</simpara>
<formalpara>
<title>Example CR with a version range specified</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: &gt;1.11.1 <co xml:id="CO105-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO105-1">
<para>Specifies that the desired version range is greater than version <literal>1.11.1</literal>. For more information, see "Support for version ranges".</para>
</callout>
</calloutlist>
<simpara>After you create or update a CR, apply the configuration file by running the following command:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;extension_name&gt;.yaml</programlisting>
</para>
</formalpara>
</section>
</section>
</section>
<section xml:id="olmv1-rukpak">
<title>Rukpak (Technology Preview)</title>

<simpara>Operator Lifecycle Manager (OLM) 1.0 uses the RukPak component and its resources to manage cloud-native content.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="olm-rukpak-about_olmv1-rukpak">
<title>About RukPak</title>
<simpara>RukPak is a pluggable solution for packaging and distributing cloud-native content. It supports advanced strategies for installation, updates, and policy.</simpara>
<simpara>RukPak provides a content ecosystem for installing a variety of artifacts on a Kubernetes cluster. Artifact examples include Git repositories, Helm charts, and OLM bundles. RukPak can then manage, scale, and upgrade these artifacts in a safe way to enable powerful cluster extensions.</simpara>
<simpara>At its core, RukPak is a small set of APIs and controllers. The APIs are packaged as custom resource definitions (CRDs) that express what content to install on a cluster and how to create a running deployment of the content. The controllers watch for the APIs.</simpara>
<variablelist>
<title>Common terminology</title>
<varlistentry>
<term>Bundle</term>
<listitem>
<simpara>A collection of Kubernetes manifests that define content to be deployed to a cluster</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle image</term>
<listitem>
<simpara>A container image that contains a bundle within its filesystem</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle Git repository</term>
<listitem>
<simpara>A Git repository that contains a bundle within a directory</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Provisioner</term>
<listitem>
<simpara>Controllers that install and manage content on a Kubernetes cluster</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Bundle deployment</term>
<listitem>
<simpara>Generates deployed instances of a bundle</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="olm-rukpak-provisioner_olmv1-rukpak">
<title>About provisioners</title>
<simpara>RukPak consists of a series of controllers, known as <emphasis>provisioners</emphasis>, that install and manage content on a Kubernetes cluster. RukPak also provides two primary APIs: <literal>Bundle</literal> and <literal>BundleDeployment</literal>. These components work together to bring content onto the cluster and install it, generating resources within the cluster.</simpara>
<simpara>Two provisioners are currently implemented and bundled with RukPak: the <emphasis>plain provisioner</emphasis> that sources and unpacks <literal>plain+v0</literal> bundles, and the <emphasis>registry provisioner</emphasis> that sources and unpacks Operator Lifecycle Manager (OLM) <literal>registry+v1</literal> bundles.</simpara>
<simpara>Each provisioner is assigned a unique ID and is responsible for reconciling <literal>Bundle</literal> and <literal>BundleDeployment</literal> objects with a <literal>spec.provisionerClassName</literal> field that matches that particular ID. For example, the plain provisioner is able to unpack a given <literal>plain+v0</literal> bundle onto a cluster and then instantiate it, making the content of the bundle available in the cluster.</simpara>
<simpara>A provisioner places a watch on both <literal>Bundle</literal> and <literal>BundleDeployment</literal> resources that refer to the provisioner explicitly. For a given bundle, the provisioner unpacks the contents of the <literal>Bundle</literal> resource onto the cluster. Then, given a <literal>BundleDeployment</literal> resource referring to that bundle, the provisioner installs the bundle contents and is responsible for managing the lifecycle of those resources.</simpara>
</section>
<section xml:id="olm-rukpak-bundle_olmv1-rukpak">
<title>Bundle</title>
<simpara>A RukPak <literal>Bundle</literal> object represents content to make available to other consumers in the cluster. Much like the contents of a container image must be pulled and unpacked in order for pod to start using them, <literal>Bundle</literal> objects are used to reference content that might need to be pulled and unpacked. In this sense, a bundle is a generalization of the image concept and can be used to represent any type of content.</simpara>
<simpara>Bundles cannot do anything on their own; they require a provisioner to unpack and make their content available in the cluster. They can be unpacked to any arbitrary storage medium, such as a <literal>tar.gz</literal> file in a directory mounted into the provisioner pods. Each <literal>Bundle</literal> object has an associated <literal>spec.provisionerClassName</literal> field that indicates the <literal>Provisioner</literal> object that watches and unpacks that particular bundle type.</simpara>
<formalpara>
<title>Example <literal>Bundle</literal> object configured to work with the plain provisioner</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core.rukpak.io/v1alpha1
kind: Bundle
metadata:
  name: my-bundle
spec:
  source:
    type: image
    image:
      ref: my-bundle@sha256:xyz123
  provisionerClassName: core-rukpak-io-plain</programlisting>
</para>
</formalpara>
<note>
<simpara>Bundles are considered immutable after they are created.</simpara>
</note>
<section xml:id="olm-rukpak-bundle-immutability_olmv1-rukpak">
<title>Bundle immutability</title>
<simpara>After a <literal>Bundle</literal> object is accepted by the API server, the bundle is considered an immutable artifact by the rest of the RukPak system. This behavior enforces the notion that a bundle represents some unique, static piece of content to source onto the cluster. A user can have confidence that a particular bundle is pointing to a specific set of manifests and cannot be updated without creating a new bundle. This property is true for both standalone bundles and dynamic bundles created by an embedded <literal>BundleTemplate</literal> object.</simpara>
<simpara>Bundle immutability is enforced by the core RukPak webhook. This webhook watches <literal>Bundle</literal> object events and, for any update to a bundle, checks whether the <literal>spec</literal> field of the existing bundle is semantically equal to that in the proposed updated bundle. If they are not equal, the update is rejected by the webhook. Other <literal>Bundle</literal> object fields, such as <literal>metadata</literal> or <literal>status</literal>, are updated during the bundle&#8217;s lifecycle; it is only the <literal>spec</literal> field that is considered immutable.</simpara>
<simpara>Applying a <literal>Bundle</literal> object and then attempting to update its spec should fail. For example, the following example creates a bundle:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f -&lt;&lt;EOF
apiVersion: core.rukpak.io/v1alpha1
kind: Bundle
metadata:
  name: combo-tag-ref
spec:
  source:
    type: git
    git:
      ref:
        tag: v0.0.2
      repository: https://github.com/operator-framework/combo
  provisionerClassName: core-rukpak-io-plain
EOF</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">bundle.core.rukpak.io/combo-tag-ref created</programlisting>
</para>
</formalpara>
<simpara>Then, patching the bundle to point to a newer tag returns an error:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch bundle combo-tag-ref --type='merge' -p '{"spec":{"source":{"git":{"ref":{"tag":"v0.0.3"}}}}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Error from server (bundle.spec is immutable): admission webhook "vbundles.core.rukpak.io" denied the request: bundle.spec is immutable</programlisting>
</para>
</formalpara>
<simpara>The core RukPak admission webhook rejected the patch because the spec of the bundle is immutable. The recommended method to change the content of a bundle is by creating a new <literal>Bundle</literal> object instead of updating it in-place.</simpara>
<bridgehead xml:id="olm-rukpak-bundle-immutability-considerations_olmv1-rukpak" renderas="sect6">Further immutability considerations</bridgehead>
<simpara>While the <literal>spec</literal> field of the <literal>Bundle</literal> object is immutable, it is still possible for a <literal>BundleDeployment</literal> object to pivot to a newer version of bundle content without changing the underlying <literal>spec</literal> field. This unintentional pivoting could occur in the following scenario:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A user sets an image tag, a Git branch, or a Git tag in the <literal>spec.source</literal> field of the <literal>Bundle</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The image tag moves to a new digest, a user pushes changes to a Git branch, or a user deletes and re-pushes a Git tag on a different commit.</simpara>
</listitem>
<listitem>
<simpara>A user does something to cause the bundle unpack pod to be re-created, such as deleting the unpack pod.</simpara>
</listitem>
</orderedlist>
<simpara>If this scenario occurs, the new content from step 2 is unpacked as a result of step 3. The bundle deployment detects the changes and pivots to the newer version of the content.</simpara>
<simpara>This is similar to pod behavior, where one of the pod&#8217;s container images uses a tag, the tag is moved to a different digest, and then at some point in the future the existing pod is rescheduled on a different node. At that point, the node pulls the new image at the new digest and runs something different without the user explicitly asking for it.</simpara>
<simpara>To be confident that the underlying <literal>Bundle</literal> spec content does not change, use a digest-based image or a Git commit reference when creating the bundle.</simpara>
</section>
<section xml:id="olm-rukpak-plain-bundle_olmv1-rukpak">
<title>Plain bundle spec</title>
<simpara>A plain bundle in RukPak is a collection of static, arbitrary, Kubernetes YAML manifests in a given directory.</simpara>
<simpara>The currently implemented plain bundle format is the <literal>plain+v0</literal> format. The name of the bundle format, <literal>plain+v0</literal>, combines the type of bundle (<literal>plain</literal>) with the current schema version (<literal>v0</literal>).</simpara>
<note>
<simpara>The <literal>plain+v0</literal> bundle format is at schema version <literal>v0</literal>, which means it is an experimental format that is subject to change.</simpara>
</note>
<simpara>For example, the following shows the file tree in a <literal>plain+v0</literal> bundle. It must have a <literal>manifests/</literal> directory containing the Kubernetes resources required to deploy an application.</simpara>
<formalpara>
<title>Example <literal>plain+v0</literal> bundle file tree</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ tree manifests

manifests
├── namespace.yaml
├── service_account.yaml
├── cluster_role.yaml
├── cluster_role_binding.yaml
└── deployment.yaml</programlisting>
</para>
</formalpara>
<simpara>The static manifests must be located in the <literal>manifests/</literal> directory with at least one resource in it for the bundle to be a valid <literal>plain+v0</literal> bundle that the provisioner can unpack. The <literal>manifests/</literal> directory must also be flat; all manifests must be at the top-level with no subdirectories.</simpara>
<important>
<simpara>Do not include any content in the <literal>manifests/</literal> directory of a plain bundle that are not static manifests. Otherwise, a failure will occur when creating content on-cluster from that bundle. Any file that would not successfully apply with the <literal>oc apply</literal> command will result in an error. Multi-object YAML or JSON files are valid, as well.</simpara>
</important>
</section>
<section xml:id="olm-rukpak-registry-bundle_olmv1-rukpak">
<title>Registry bundle spec</title>
<simpara>A registry bundle, or <literal>registry+v1</literal> bundle, contains a set of static Kubernetes YAML manifests organized in the legacy Operator Lifecycle Manager (OLM) bundle format.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-packaging-format.xml#olm-bundle-format_olm-packaging-format">Legacy OLM bundle format</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olm-rukpak-bd_olmv1-rukpak">
<title>BundleDeployment</title>
<warning>
<simpara>A <literal>BundleDeployment</literal> object changes the state of a Kubernetes cluster by installing and removing objects. It is important to verify and trust the content that is being installed and limit access, by using RBAC, to the <literal>BundleDeployment</literal> API to only those who require those permissions.</simpara>
</warning>
<simpara>The RukPak <literal>BundleDeployment</literal> API points to a <literal>Bundle</literal> object and indicates that it should be active. This includes pivoting from older versions of an active bundle. A <literal>BundleDeployment</literal> object might also include an embedded spec for a desired bundle.</simpara>
<simpara>Much like pods generate instances of container images, a bundle deployment generates a deployed version of a bundle. A bundle deployment can be seen as a generalization of the pod concept.</simpara>
<simpara>The specifics of how a bundle deployment makes changes to a cluster based on a referenced bundle is defined by the provisioner that is configured to watch that bundle deployment.</simpara>
<formalpara>
<title>Example <literal>BundleDeployment</literal> object configured to work with the plain provisioner</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: core.rukpak.io/v1alpha1
kind: BundleDeployment
metadata:
  name: my-bundle-deployment
spec:
  provisionerClassName: core-rukpak-io-plain
  template:
    metadata:
      labels:
        app: my-bundle
    spec:
      source:
        type: image
        image:
          ref: my-bundle@sha256:xyz123
      provisionerClassName: core-rukpak-io-plain</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="olmv1-dependency">
<title>Dependency resolution in OLM 1.0 (Technology Preview)</title>

<simpara>Operator Lifecycle Manager (OLM) 1.0 uses a dependency manager for resolving constraints over catalogs of RukPak bundles.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="olmv1-dependency-concepts_olmv1-dependency">
<title>Concepts</title>
<simpara>There are a set of expectations from the user that the package manager should never do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Install a package whose dependencies can not be fulfilled or that conflict with the dependencies of another package</simpara>
</listitem>
<listitem>
<simpara>Install a package whose constraints can not be met by the current set of installable packages</simpara>
</listitem>
<listitem>
<simpara>Update a package in a way that breaks another that depends on it</simpara>
</listitem>
</itemizedlist>
<section xml:id="olmv1-dependency-example-successful_olmv1-dependency">
<title>Example: Successful resolution</title>
<simpara>A user wants to install packages A and B that have the following dependencies:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Package A <literal>v0.1.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Package B <literal>latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>↓ (depends on)</simpara></entry>
<entry align="left" valign="top"><simpara>↓ (depends on)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Package C <literal>v0.1.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Package D <literal>latest</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Additionally, the user wants to pin the version of A to <literal>v0.1.0</literal>.</simpara>
<simpara><emphasis role="strong">Packages and constraints passed to OLM 1.0</emphasis></simpara>
<itemizedlist>
<title>Packages</title>
<listitem>
<simpara>A</simpara>
</listitem>
<listitem>
<simpara>B</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Constraints</title>
<listitem>
<simpara>A <literal>v0.1.0</literal> depends on C <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>A pinned to <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>B depends on D</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Output</title>
<listitem>
<simpara>Resolution set:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>B <literal>latest</literal></simpara>
</listitem>
<listitem>
<simpara>C <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>D <literal>latest</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-dependency-example-unsuccessful_olmv1-dependency">
<title>Example: Unsuccessful resolution</title>
<simpara>A user wants to install packages A and B that have the following dependencies:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Package A <literal>v0.1.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Package B <literal>latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>↓ (depends on)</simpara></entry>
<entry align="left" valign="top"><simpara>↓ (depends on)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Package C <literal>v0.1.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Package C <literal>v0.2.0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Additionally, the user wants to pin the version of A to <literal>v0.1.0</literal>.</simpara>
<simpara><emphasis role="strong">Packages and constraints passed to OLM 1.0</emphasis></simpara>
<itemizedlist>
<title>Packages</title>
<listitem>
<simpara>A</simpara>
</listitem>
<listitem>
<simpara>B</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Constraints</title>
<listitem>
<simpara>A <literal>v0.1.0</literal> depends on C <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>A pinned to <literal>v0.1.0</literal></simpara>
</listitem>
<listitem>
<simpara>B <literal>latest</literal> depends on C <literal>v0.2.0</literal></simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Output</title>
<listitem>
<simpara>Resolution set:</simpara>
<itemizedlist>
<listitem>
<simpara>Unable to resolve because A <literal>v0.1.0</literal> requires C <literal>v0.1.0</literal>, which conflicts with B <literal>latest</literal> requiring C <literal>v0.2.0</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="olmv1-catalogd">
<title>Catalogd (Technology Preview)</title>

<simpara>Operator Lifecycle Manager (OLM) 1.0 uses the catalogd component and its resources to manage Operator and extension catalogs.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="olmv1-about-catalogs_olmv1-catalogd">
<title>About catalogs in OLM 1.0</title>
<simpara>You can discover installable content by querying a catalog for Kubernetes extensions, such as Operators and controllers, by using the catalogd component. Catalogd is a Kubernetes extension that unpacks catalog content for on-cluster clients and is part of the Operator Lifecycle Manager (OLM) 1.0 suite of microservices. Currently, catalogd unpacks catalog content that is packaged and distributed as container images.</simpara>
<important>
<simpara>If you try to install an Operator or extension that does not have unique name, the installation might fail or lead to an unpredictable result. This occurs for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>If mulitple catalogs are installed on a cluster, OLM 1.0 does not include a mechanism to specify a catalog when you install an Operator or extension.</simpara>
</listitem>
<listitem>
<simpara>Dependency resolution in Operator Lifecycle Manager (OLM) 1.0 requires that all of the Operators and extensions that are available to install on a cluster use a unique name for their bundles and packages.</simpara>
</listitem>
</itemizedlist>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">File-based catalogs</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="olmv1-red-hat-catalogs_olmv1-catalogd">
<title>Red Hat-provided Operator catalogs in OLM 1.0</title>
<simpara>Operator Lifecycle Manager (OLM) 1.0 does not include Red Hat-provided Operator catalogs by default. If you want to add a Red Hat-provided catalog to your cluster, create a custom resource (CR) for the catalog and apply it to the cluster. The following custom resource (CR) examples show how to create a catalog resources for OLM 1.0.</simpara>
<important>
<simpara>If you want to use a catalog that is hosted on a secure registry, such as Red Hat-provided Operator catalogs from <literal>registry.redhat.io</literal>, you must have a pull secret scoped to the <literal>openshift-catalogd</literal> namespace.
For more information, see "Creating a pull secret for catalogs hosted on a secure registry".</simpara>
</important>
<formalpara>
<title>Example Red Hat Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: redhat-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example Certified Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: certified-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/certified-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example Community Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: community-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/community-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<simpara>The following command adds a catalog to your cluster:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;catalog_name&gt;.yaml <co xml:id="CO106-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO106-1">
<para>Specifies the catalog CR, such as <literal>redhat-operators.yaml</literal>.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-adding-a-catalog-to-a-cluster_olmv1-installing-operator">Adding a catalog to a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs_olm-rh-catalogs">About Red Hat-provided Operator catalogs</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</section>
<section xml:id="olmv1-installing-an-operator-from-a-catalog">
<title>Installing an Operator from a catalog in OLM 1.0 (Technology Preview)</title>

<simpara>Cluster administrators can add <emphasis>catalogs</emphasis>, or curated collections of Operators and Kubernetes extensions, to their clusters. Operator authors publish their products to these catalogs. When you add a catalog to your cluster, you have access to the versions, patches, and over-the-air updates of the Operators and extensions that are published to the catalog.</simpara>
<simpara>In the current Technology Preview release of Operator Lifecycle Manager (OLM) 1.0, you manage catalogs and Operators declaratively from the CLI using custom resources (CRs).</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="prerequisites_olmv1-installing-an-operator-from-a-catalog">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Access to an {product-title} cluster using an account with <literal>cluster-admin</literal> permissions</simpara>
<note>
<simpara>For {product-title} 4.14, documented procedures for OLM 1.0 are CLI-based only. Alternatively, administrators can create and view related objects in the web console by using normal methods, such as the <emphasis role="strong">Import YAML</emphasis> and <emphasis role="strong">Search</emphasis> pages. However, the existing <emphasis role="strong">OperatorHub</emphasis> and <emphasis role="strong">Installed Operators</emphasis> pages do not yet display OLM 1.0 components.</simpara>
</note>
</listitem>
<listitem>
<simpara>The <literal>TechPreviewNoUpgrades</literal> feature set enabled on the cluster</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set cannot be undone and prevents minor version updates. These feature sets are not recommended on production clusters.</simpara>
</warning>
</listitem>
<listitem>
<simpara>The OpenShift CLI (<literal>oc</literal>) installed on your workstation</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-enabling-features.xml#nodes-cluster-enabling">Enabling features using feature gates</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-about-catalogs_olmv1-installing-operator">
<title>About catalogs in OLM 1.0</title>
<simpara>You can discover installable content by querying a catalog for Kubernetes extensions, such as Operators and controllers, by using the catalogd component. Catalogd is a Kubernetes extension that unpacks catalog content for on-cluster clients and is part of the Operator Lifecycle Manager (OLM) 1.0 suite of microservices. Currently, catalogd unpacks catalog content that is packaged and distributed as container images.</simpara>
<important>
<simpara>If you try to install an Operator or extension that does not have unique name, the installation might fail or lead to an unpredictable result. This occurs for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>If mulitple catalogs are installed on a cluster, OLM 1.0 does not include a mechanism to specify a catalog when you install an Operator or extension.</simpara>
</listitem>
<listitem>
<simpara>Dependency resolution in Operator Lifecycle Manager (OLM) 1.0 requires that all of the Operators and extensions that are available to install on a cluster use a unique name for their bundles and packages.</simpara>
</listitem>
</itemizedlist>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-packaging-format.xml#olm-file-based-catalogs_olm-packaging-format">File-based catalogs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-red-hat-catalogs_olmv1-installing-operator">
<title>Red Hat-provided Operator catalogs in OLM 1.0</title>
<simpara>Operator Lifecycle Manager (OLM) 1.0 does not include Red Hat-provided Operator catalogs by default. If you want to add a Red Hat-provided catalog to your cluster, create a custom resource (CR) for the catalog and apply it to the cluster. The following custom resource (CR) examples show how to create a catalog resources for OLM 1.0.</simpara>
<important>
<simpara>If you want to use a catalog that is hosted on a secure registry, such as Red Hat-provided Operator catalogs from <literal>registry.redhat.io</literal>, you must have a pull secret scoped to the <literal>openshift-catalogd</literal> namespace.
For more information, see "Creating a pull secret for catalogs hosted on a secure registry".</simpara>
</important>
<formalpara>
<title>Example Red Hat Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: redhat-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example Certified Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: certified-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/certified-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example Community Operators catalog</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: community-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/community-operator-index:v{product-version}
      pullSecret: &lt;pull_secret_name&gt;</programlisting>
</para>
</formalpara>
<simpara>The following command adds a catalog to your cluster:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;catalog_name&gt;.yaml <co xml:id="CO107-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO107-1">
<para>Specifies the catalog CR, such as <literal>redhat-operators.yaml</literal>.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-creating-a-pull-secret-for-catalogs-secure-registry_olmv1-installing-operator">Creating a pull secret for catalogs hosted on a secure registry</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-adding-a-catalog-to-a-cluster_olmv1-installing-operator">Adding a catalog to a cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/understanding/olm-rh-catalogs.xml#olm-rh-catalogs_olm-rh-catalogs">About Red Hat-provided Operator catalogs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-creating-a-pull-secret-for-catalogs-secure-registry_olmv1-installing-operator">
<title>Creating a pull secret for catalogs hosted on a secure registry</title>
<simpara>If you want to use a catalog that is hosted on a secure registry, such as Red Hat-provided Operator catalogs from <literal>registry.redhat.io</literal>, you must have a pull secret scoped to the <literal>openshift-catalogd</literal> namespace.</simpara>
<note>
<simpara>Currently, catalogd cannot read global pull secrets from {product-title} clusters. Catalogd can read references to secrets only in the namespace where it is deployed.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Login credentials for the secure registry</simpara>
</listitem>
<listitem>
<simpara>Docker or Podman installed on your workstation</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>If you already have a <literal>.dockercfg</literal> file with login credentials for the secure registry, create a pull secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockercfg=&lt;file_path&gt;/.dockercfg \
    --type=kubernetes.io/dockercfg \
    --namespace=openshift-catalogd</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic redhat-cred \
    --from-file=.dockercfg=/home/&lt;username&gt;/.dockercfg \
    --type=kubernetes.io/dockercfg \
    --namespace=openshift-catalogd</programlisting>
</example>
</listitem>
<listitem>
<simpara>If you already have a <literal>$HOME/.docker/config.json</literal> file with login credentials for the secured registry, create a pull secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockerconfigjson=&lt;file_path&gt;/.docker/config.json \
    --type=kubernetes.io/dockerconfigjson \
    --namespace=openshift-catalogd</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic redhat-cred \
    --from-file=.dockerconfigjson=/home/&lt;username&gt;/.docker/config.json \
    --type=kubernetes.io/dockerconfigjson \
    --namespace=openshift-catalogd</programlisting>
</example>
</listitem>
<listitem>
<simpara>If you do not have a Docker configuration file with login credentials for the secure registry, create a pull secret by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry &lt;pull_secret_name&gt; \
    --docker-server=&lt;registry_server&gt; \
    --docker-username=&lt;username&gt; \
    --docker-password=&lt;password&gt; \
    --docker-email=&lt;email&gt; \
    --namespace=openshift-catalogd</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry redhat-cred \
    --docker-server=registry.redhat.io \
    --docker-username=username \
    --docker-password=password \
    --docker-email=user@example.com \
    --namespace=openshift-catalogd</programlisting>
</example>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-adding-a-catalog-to-a-cluster_olmv1-installing-operator">
<title>Adding a catalog to a cluster</title>
<simpara>To add a catalog to a cluster, create a catalog custom resource (CR) and apply it to the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara></simpara>
<simpara>If you want to use a catalog that is hosted on a secure registry, such as Red Hat-provided Operator catalogs from <literal>registry.redhat.io</literal>, you must have a pull secret scoped to the <literal>openshift-catalogd</literal> namespace.
For more information, see "Creating a pull secret for catalogs hosted on a secure registry".</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a catalog custom resource (CR), similar to the following example:</simpara>
<formalpara>
<title>Example <literal>redhat-operators.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: catalogd.operatorframework.io/v1alpha1
kind: Catalog
metadata:
  name: redhat-operators
spec:
  source:
    type: image
    image:
      ref: registry.redhat.io/redhat/redhat-operator-index:v{product-version} <co xml:id="CO108-1"/>
      pullSecret: &lt;pull_secret_name&gt; <co xml:id="CO108-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO108-1">
<para>Specify the catalog&#8217;s image in the <literal>spec.source.image</literal> field.</para>
</callout>
<callout arearefs="CO108-2">
<para>If your catalog is hosted on a secure registry, such as <literal>registry.redhat.io</literal>, you must create a pull secret scoped to the <literal>openshift-catalog</literal> namespace.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the catalog to your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f redhat-operators.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">catalog.catalogd.operatorframework.io/redhat-operators created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Run the following commands to verify the status of your catalog:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check if you catalog is available by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalog</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">NAME                  AGE
redhat-operators      20s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the status of your catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe catalog</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Name:         redhat-operators
Namespace:
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
API Version:  catalogd.operatorframework.io/v1alpha1
Kind:         Catalog
Metadata:
  Creation Timestamp:  2024-01-10T16:18:38Z
  Finalizers:
    catalogd.operatorframework.io/delete-server-cache
  Generation:        1
  Resource Version:  57057
  UID:               128db204-49b3-45ee-bfea-a2e6fc8e34ea
Spec:
  Source:
    Image:
      Pull Secret:  redhat-cred
      Ref:          registry.redhat.io/redhat/redhat-operator-index:v4.15
    Type:           image
Status: <co xml:id="CO109-1"/>
  Conditions:
    Last Transition Time:  2024-01-10T16:18:55Z
    Message:
    Reason:                UnpackSuccessful <co xml:id="CO109-2"/>
    Status:                True
    Type:                  Unpacked
  Content URL:             http://catalogd-catalogserver.openshift-catalogd.svc/catalogs/redhat-operators/all.json
  Observed Generation:     1
  Phase:                   Unpacked <co xml:id="CO109-3"/>
  Resolved Source:
    Image:
      Last Poll Attempt:  2024-01-10T16:18:51Z
      Ref:                registry.redhat.io/redhat/redhat-operator-index:v4.15
      Resolved Ref:       registry.redhat.io/redhat/redhat-operator-index@sha256:7b536ae19b8e9f74bb521c4a61e5818e036ac1865a932f2157c6c9a766b2eea5 <co xml:id="CO109-4"/>
    Type:                 image
Events:                   &lt;none&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO109-1">
<para>Describes the status of the catalog.</para>
</callout>
<callout arearefs="CO109-2">
<para>Displays the reason the catalog is in the current state.</para>
</callout>
<callout arearefs="CO109-3">
<para>Displays the phase of the installation process.</para>
</callout>
<callout arearefs="CO109-4">
<para>Displays the image reference of the catalog.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-creating-a-pull-secret-for-catalogs-secure-registry_olmv1-installing-operator">Creating a pull secret for catalogs hosted on a secure registry</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-finding-operators-to-install_olmv1-installing-operator">
<title>Finding Operators to install from a catalog</title>
<simpara>After you add a catalog to your cluster, you can query the catalog to find Operators and extensions to install. Before you can query catalogs, you must port forward the catalog server service.</simpara>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>You have added a catalog to your cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>jq</literal> CLI tool.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Port forward the catalog server service in the <literal>openshift-catalogd</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-catalogd port-forward svc/catalogd-catalogserver 8080:80</programlisting>
</listitem>
<listitem>
<simpara>Download the catalog&#8217;s JSON file locally by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -L http://localhost:8080/catalogs/&lt;catalog_name&gt;/all.json \
  -C - -o /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ curl -L http://localhost:8080/catalogs/redhat-operators/all.json \
  -C - -o /home/username/catalogs/rhoc.json</programlisting>
</example>
</listitem>
<listitem>
<simpara>Run one of the following commands to return a list of Operators and extensions in a catalog.</simpara>
<important>
<simpara>Currently, Operator Lifecycle Manager (OLM) 1.0 supports extensions that do not use webhooks and are configured to use the <literal>AllNamespaces</literal> install mode. Extensions that use webhooks or that target a single or specified set of namespaces cannot be installed.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara>Get a list of all the Operators and extensions from the local catalog file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select(.schema == "olm.package") | .name' \
  /&lt;path&gt;/&lt;filename&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select(.schema == "olm.package") | .name' \
  /home/username/catalogs/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">NAME                                                        AGE
"3scale-operator"
"advanced-cluster-management"
"amq-broker-rhel8"
"amq-online"
"amq-streams"
"amq7-interconnect-operator"
"ansible-automation-platform-operator"
"ansible-cloud-addons-operator"
"apicast-operator"
"aws-efs-csi-driver-operator"
"aws-load-balancer-operator"
"bamoe-businessautomation-operator"
"bamoe-kogito-operator"
"bare-metal-event-relay"
"businessautomation-operator"
...</programlisting>
</example>
</listitem>
<listitem>
<simpara>Get list of packages that support <literal>AllNamespaces</literal> install mode and do not use webhooks from the local catalog file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -c 'select(.schema == "olm.bundle") | \
  {"package":.package, "version":.properties[] | \
  select(.type == "olm.bundle.object").value.data | @base64d | fromjson | \
  select(.kind == "ClusterServiceVersion" and (.spec.installModes[] | \
  select(.type == "AllNamespaces" and .supported == true) != null) \
  and .spec.webhookdefinitions == null).spec.version}' \
  /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">{"package":"3scale-operator","version":"0.10.0-mas"}
{"package":"3scale-operator","version":"0.10.5"}
{"package":"3scale-operator","version":"0.11.0-mas"}
{"package":"3scale-operator","version":"0.11.1-mas"}
{"package":"3scale-operator","version":"0.11.2-mas"}
{"package":"3scale-operator","version":"0.11.3-mas"}
{"package":"3scale-operator","version":"0.11.5-mas"}
{"package":"3scale-operator","version":"0.11.6-mas"}
{"package":"3scale-operator","version":"0.11.7-mas"}
{"package":"3scale-operator","version":"0.11.8-mas"}
{"package":"amq-broker-rhel8","version":"7.10.0-opr-1"}
{"package":"amq-broker-rhel8","version":"7.10.0-opr-2"}
{"package":"amq-broker-rhel8","version":"7.10.0-opr-3"}
{"package":"amq-broker-rhel8","version":"7.10.0-opr-4"}
{"package":"amq-broker-rhel8","version":"7.10.1-opr-1"}
{"package":"amq-broker-rhel8","version":"7.10.1-opr-2"}
{"package":"amq-broker-rhel8","version":"7.10.2-opr-1"}
{"package":"amq-broker-rhel8","version":"7.10.2-opr-2"}
...</programlisting>
</example>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Inspect the contents of an Operator or extension&#8217;s metadata by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.package") | \
  select( .name == "&lt;package_name&gt;")' /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.package") | \
  select( .name == "openshift-pipelines-operator-rh")' \
  /home/username/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">{
  "defaultChannel": "stable",
  "icon": {
    "base64data": "PHN2ZyB4bWxu..."
    "mediatype": "image/png"
  },
  "name": "openshift-pipelines-operator-rh",
  "schema": "olm.package"
}</programlisting>
</example>
</listitem>
</orderedlist>
<section xml:id="olmv1-catalog-queries_olmv1-installing-operator">
<title>Common catalog queries</title>
<simpara>You can query catalogs by using the <literal>jq</literal> CLI tool.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Common package queries</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Query</entry>
<entry align="left" valign="top">Request</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Available packages in a catalog</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.package") | \
  .name' &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Packages that support <literal>AllNamespaces</literal> install mode and do not use webhooks</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -c 'select(.schema == "olm.bundle") | \
  {"package":.package, "version":.properties[] | \
  select(.type == "olm.bundle.object").value.data | \
  @base64d | fromjson | \
  select(.kind == "ClusterServiceVersion" and (.spec.installModes[] | \
  select(.type == "AllNamespaces" and .supported == true) != null) \
  and .spec.webhookdefinitions == null).spec.version}' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Package metadata</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.package") | \
  select( .name == "&lt;package_name&gt;")' &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Catalog blobs in a package</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "&lt;package_name&gt;")' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Common channel queries</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Query</entry>
<entry align="left" valign="top">Request</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Channels in a package</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select( .package == "&lt;package_name&gt;") | .name' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Versions in a channel</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "&lt;package_name" ) | \
  select( .schema == "olm.channel" ) | \
  select( .name == "&lt;channel_name&gt;" ) | \
  .entries | .[] | .name' &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Latest version in a channel</simpara>
</listitem>
<listitem>
<simpara>Upgrade path</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select ( .name == "&lt;channel&gt;") | \
  select( .package == "&lt;package_name&gt;")' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Common bundle queries</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Query</entry>
<entry align="left" valign="top">Request</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Bundles in a package</simpara></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.bundle" ) | \
  select( .package == "&lt;package_name&gt;") | .name' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Bundle dependencies</simpara>
</listitem>
<listitem>
<simpara>Available APIs</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.bundle" ) | \
  select ( .name == "&lt;bundle_name&gt;") | \
  select( .package == "&lt;package_name&gt;")' \
  &lt;catalog_name&gt;.json</programlisting></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="olmv1-installing-an-operator_olmv1-installing-operator">
<title>Installing an Operator from a catalog</title>
<simpara>Operator Lifecycle Manager (OLM) 1.0 supports installing Operators and extensions scoped to the cluster. You can install an Operator or extension from a catalog by creating a custom resource (CR) and applying it to the cluster.</simpara>
<important>
<simpara>Currently, OLM 1.0 supports the installation Operators and extensions that meet the following criteria:</simpara>
<itemizedlist>
<listitem>
<simpara>The Operator or extension must use the <literal>AllNamespaces</literal> install mode.</simpara>
</listitem>
<listitem>
<simpara>The Operator or extension must not use webhooks.</simpara>
</listitem>
</itemizedlist>
<simpara>Operators and extensions that use webhooks or that target a single or specified set of namespaces cannot be installed.</simpara>
</important>
<itemizedlist>
<title>Prerequisite</title>
<listitem>
<simpara>You have added a catalog to your cluster.</simpara>
</listitem>
<listitem>
<simpara>You have downloaded a local copy of the catalog file.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>jq</literal> CLI tool.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Inspect a package for channel and version information from a local copy of your catalog file by completing the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get a list of channels from a selected package by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select( .package == "&lt;package_name&gt;") | \
  .name' /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select( .package == "openshift-pipelines-operator-rh") | \
  .name' /home/username/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">"latest"
"pipelines-1.11"
"pipelines-1.12"
"pipelines-1.13"</programlisting>
</example>
</listitem>
<listitem>
<simpara>Get a list of the versions published in a channel by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "&lt;package_name" ) | \
  select( .schema == "olm.channel" ) | \
  select( .name == "&lt;channel_name" ) | .entries | \
  .[] | .name' /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "openshift-pipelines-operator-rh" ) | \
select( .schema == "olm.channel" ) | select( .name == "latest" ) | \
.entries | .[] | .name' /home/username/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">"openshift-pipelines-operator-rh.v1.11.1"
"openshift-pipelines-operator-rh.v1.12.0"
"openshift-pipelines-operator-rh.v1.12.1"
"openshift-pipelines-operator-rh.v1.12.2"
"openshift-pipelines-operator-rh.v1.13.0"
"openshift-pipelines-operator-rh.v1.13.1"</programlisting>
</example>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a CR, similar to the following example:</simpara>
<formalpara>
<title>Example <literal>pipelines-operator.yaml</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  channel: &lt;channel&gt;
  version: &lt;version&gt;</programlisting>
</para>
</formalpara>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;channel&gt;</term>
<listitem>
<simpara>Optional: Specifies the channel, such as <literal>pipelines-1.11</literal> or <literal>latest</literal>, for the package you want to install or update.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;version&gt;</term>
<listitem>
<simpara>Optional: Specifies the version or version range, such as <literal>1.11.1</literal>, <literal>1.12.x</literal>, or <literal>&gt;=1.12.1</literal>, of the package you want to install or update. For more information, see "Example custom resources (CRs) that specify a target version" and "Support for version ranges".</simpara>
<important>
<simpara>If you try to install an Operator or extension that does not have unique name, the installation might fail or lead to an unpredictable result. This occurs for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>If mulitple catalogs are installed on a cluster, OLM 1.0 does not include a mechanism to specify a catalog when you install an Operator or extension.</simpara>
</listitem>
<listitem>
<simpara>Dependency resolution in Operator Lifecycle Manager (OLM) 1.0 requires that all of the Operators and extensions that are available to install on a cluster use a unique name for their bundles and packages.</simpara>
</listitem>
</itemizedlist>
</important>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Apply the CR to the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f pipeline-operator.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">operator.operators.operatorframework.io/pipelines-operator created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>View the Operator or extension&#8217;s CR in the YAML format by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io pipelines-operator -o yaml</programlisting>
<note>
<simpara>If you specify a channel or define a version range in your Operator or extension&#8217;s CR, OLM 1.0 does not display the resolved version installed on the cluster. Only the version and channel information specified in the CR are displayed.</simpara>
<simpara>If you want to find the specific version that is installed, you must compare the SHA of the image of the <literal>spec.source.image.ref</literal> field to the image reference in the catalog.</simpara>
</note>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"operators.operatorframework.io/v1alpha1","kind":"Operator","metadata":{"annotations":{},"name":"pipelines-operator"},"spec":{"channel":"latest","packageName":"openshift-pipelines-operator-rh","version":"1.11.x"}}
  creationTimestamp: "2024-01-30T20:06:09Z"
  generation: 1
  name: pipelines-operator
  resourceVersion: "44362"
  uid: 4272d228-22e1-419e-b9a7-986f982ee588
spec:
  channel: latest
  packageName: openshift-pipelines-operator-rh
  upgradeConstraintPolicy: Enforce
  version: 1.11.x
status:
  conditions:
  - lastTransitionTime: "2024-01-30T20:06:15Z"
    message: resolved to "registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280"
    observedGeneration: 1
    reason: Success
    status: "True"
    type: Resolved
  - lastTransitionTime: "2024-01-30T20:06:31Z"
    message: installed from "registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280"
    observedGeneration: 1
    reason: Success
    status: "True"
    type: Installed
  installedBundleResource: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280
  resolvedBundleResource: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280</programlisting>
</example>
</listitem>
<listitem>
<simpara>Get information about your bundle deployment by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get bundleDeployment pipelines-operator -o yaml</programlisting>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">apiVersion: core.rukpak.io/v1alpha1
kind: BundleDeployment
metadata:
  creationTimestamp: "2024-01-30T20:06:15Z"
  generation: 2
  name: pipelines-operator
  ownerReferences:
  - apiVersion: operators.operatorframework.io/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: Operator
    name: pipelines-operator
    uid: 4272d228-22e1-419e-b9a7-986f982ee588
  resourceVersion: "44464"
  uid: 0a0c3525-27e2-4c93-bf57-55920a7707c0
spec:
  provisionerClassName: core-rukpak-io-plain
  template:
    metadata: {}
    spec:
      provisionerClassName: core-rukpak-io-registry
      source:
        image:
          ref: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280
        type: image
status:
  activeBundle: pipelines-operator-29x720cjzx8yiowf13a3j75fil2zs3mfw
  conditions:
  - lastTransitionTime: "2024-01-30T20:06:15Z"
    message: Successfully unpacked the pipelines-operator-29x720cjzx8yiowf13a3j75fil2zs3mfw
      Bundle
    reason: UnpackSuccessful
    status: "True"
    type: HasValidBundle
  - lastTransitionTime: "2024-01-30T20:06:28Z"
    message: Instantiated bundle pipelines-operator-29x720cjzx8yiowf13a3j75fil2zs3mfw
      successfully
    reason: InstallationSucceeded
    status: "True"
    type: Installed
  - lastTransitionTime: "2024-01-30T20:06:40Z"
    message: BundleDeployment is healthy
    reason: Healthy
    status: "True"
    type: Healthy
  observedGeneration: 2</programlisting>
</example>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-about-target-versions_olmv1-installing-operator">Example custom resources (CRs) that specify a target version</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-version-range-support_olmv1-installing-operator">Support for version ranges</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-updating-an-operator_olmv1-installing-operator">
<title>Updating an Operator</title>
<simpara>You can update your Operator or extension by manually editing the custom resource (CR) and applying the changes.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a catalog installed.</simpara>
</listitem>
<listitem>
<simpara>You have downloaded a local copy of the catalog file.</simpara>
</listitem>
<listitem>
<simpara>You have an Operator or extension installed.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>jq</literal> CLI tool.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Inspect a package for channel and version information from a local copy of your catalog file by completing the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Get a list of channels from a selected package by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select( .package == "&lt;package_name&gt;") | \
  .name' /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .schema == "olm.channel" ) | \
  select( .package == "openshift-pipelines-operator-rh") | \
  .name' /home/username/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">"latest"
"pipelines-1.11"
"pipelines-1.12"
"pipelines-1.13"</programlisting>
</example>
</listitem>
<listitem>
<simpara>Get a list of the versions published in a channel by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "&lt;package_name" ) | \
  select( .schema == "olm.channel" ) | \
  select( .name == "&lt;channel_name" ) | .entries | \
  .[] | .name' /&lt;path&gt;/&lt;catalog_name&gt;.json</programlisting>
<example>
<title>Example command</title>
<programlisting language="terminal" linenumbering="unnumbered">$ jq -s '.[] | select( .package == "openshift-pipelines-operator-rh" ) | \
select( .schema == "olm.channel" ) | select( .name == "latest" ) | \
.entries | .[] | .name' /home/username/rhoc.json</programlisting>
</example>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">"openshift-pipelines-operator-rh.v1.11.1"
"openshift-pipelines-operator-rh.v1.12.0"
"openshift-pipelines-operator-rh.v1.12.1"
"openshift-pipelines-operator-rh.v1.12.2"
"openshift-pipelines-operator-rh.v1.13.0"
"openshift-pipelines-operator-rh.v1.13.1"</programlisting>
</example>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Find out what version or channel is specified in your Operator or extension&#8217;s CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io &lt;operator_name&gt; -o yaml</programlisting>
<formalpara>
<title>Example command</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io pipelines-operator -o yaml</programlisting>
</para>
</formalpara>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |  {"apiVersion":"operators.operatorframework.io/v1alpha1","kind":"Operator","metadata":{"annotations":{},"name":"pipelines-operator"},"spec":{"channel":"latest","packageName":"openshift-pipelines-operator-rh","version":"1.11.1"}}
  creationTimestamp: "2024-02-06T17:47:15Z"
  generation: 2
  name: pipelines-operator
  resourceVersion: "84528"
  uid: dffe2c89-b9c4-427e-b694-ada0b37fc0a9
spec:
  channel: latest <co xml:id="CO110-1"/>
  packageName: openshift-pipelines-operator-rh
  upgradeConstraintPolicy: Enforce
  version: 1.11.1 <co xml:id="CO110-2"/>
status:
  conditions:
  - lastTransitionTime: "2024-02-06T17:47:21Z"
    message: bundledeployment status is unknown
    observedGeneration: 2
    reason: InstallationStatusUnknown
    status: Unknown
    type: Installed
  - lastTransitionTime: "2024-02-06T17:50:58Z"
    message: resolved to "registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280"
    observedGeneration: 2
    reason: Success
    status: "True"
    type: Resolved
  resolvedBundleResource: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:e09d37bb1e754db42324fd18c1cb3e7ce77e7b7fcbf4932d0535391579938280</programlisting>
<calloutlist>
<callout arearefs="CO110-1">
<para>Specifies the channel for your Operator or extension.</para>
</callout>
<callout arearefs="CO110-2">
<para>Specifies the version or version range for your Operator or extension.</para>
</callout>
</calloutlist>
</example>
<note>
<simpara>If you specify a channel or define a version range in your Operator or extension&#8217;s CR, OLM 1.0 does not display the resolved version installed on the cluster. Only the version and channel information specified in the CR are displayed.</simpara>
<simpara>If you want to find the specific version that is installed, you must compare the SHA of the image of the <literal>spec.source.image.ref</literal> field to the image reference in the catalog.</simpara>
</note>
</listitem>
<listitem>
<simpara>Edit your CR to update the version to <literal>1.12.1</literal>, as shown in the following example:</simpara>
<formalpara>
<title>Example <literal>pipelines-operator.yaml</literal> CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: 1.12.1 <co xml:id="CO111-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO111-1">
<para>Update the version from <literal>1.11.1</literal> to <literal>1.12.1</literal></para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the update to the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f pipelines-operator.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">operator.operators.operatorframework.io/pipelines-operator configured</programlisting>
</para>
</formalpara>
<tip>
<simpara>You can patch and apply the changes to your CR from the CLI by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch operator.operators.operatorframework.io/pipelines-operator -p \
  '{"spec":{"version":"1.12.1"}}' \
  --type=merge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">operator.operators.operatorframework.io/pipelines-operator patched</programlisting>
</para>
</formalpara>
</tip>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the channel and version updates have been applied by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io pipelines-operator -o yaml</programlisting>
<example>
<title>Example output</title>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"operators.operatorframework.io/v1alpha1","kind":"Operator","metadata":{"annotations":{},"name":"pipelines-operator"},"spec":{"channel":"latest","packageName":"openshift-pipelines-operator-rh","version":"1.12.1"}}
  creationTimestamp: "2024-02-06T19:16:12Z"
  generation: 4
  name: pipelines-operator
  resourceVersion: "58122"
  uid: 886bbf73-604f-4484-9f87-af6ce0f86914
spec:
  channel: latest
  packageName: openshift-pipelines-operator-rh
  upgradeConstraintPolicy: Enforce
  version: 1.12.1 <co xml:id="CO112-1"/>
status:
  conditions:
  - lastTransitionTime: "2024-02-06T19:30:57Z"
    message: installed from "registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:2f1b8ef0fd741d1d686489475423dabc07c55633a4dfebc45e1d533183179f6a"
    observedGeneration: 3
    reason: Success
    status: "True"
    type: Installed
  - lastTransitionTime: "2024-02-06T19:30:57Z"
    message: resolved to "registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:2f1b8ef0fd741d1d686489475423dabc07c55633a4dfebc45e1d533183179f6a"
    observedGeneration: 3
    reason: Success
    status: "True"
    type: Resolved
  installedBundleResource: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:2f1b8ef0fd741d1d686489475423dabc07c55633a4dfebc45e1d533183179f6a
  resolvedBundleResource: registry.redhat.io/openshift-pipelines/pipelines-operator-bundle@sha256:2f1b8ef0fd741d1d686489475423dabc07c55633a4dfebc45e1d533183179f6a</programlisting>
<calloutlist>
<callout arearefs="CO112-1">
<para>Verify that the version is updated to <literal>1.12.1</literal>.</para>
</callout>
</calloutlist>
</example>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Troubleshooting</title>
<listitem>
<simpara>If you specify a target version or channel that does not exist, you can run the following command to check the status of your Operator or extension:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io &lt;operator_name&gt; -o yaml</programlisting>
<example>
<title>Example output</title>
<programlisting language="text" linenumbering="unnumbered">oc get operator.operators.operatorframework.io pipelines-operator -o yaml
apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"operators.operatorframework.io/v1alpha1","kind":"Operator","metadata":{"annotations":{},"name":"pipelines-operator"},"spec":{"channel":"latest","packageName":"openshift-pipelines-operator-rh","version":"2.0.0"}}
  creationTimestamp: "2024-02-06T17:47:15Z"
  generation: 1
  name: pipelines-operator
  resourceVersion: "82667"
  uid: dffe2c89-b9c4-427e-b694-ada0b37fc0a9
spec:
  channel: latest
  packageName: openshift-pipelines-operator-rh
  upgradeConstraintPolicy: Enforce
  version: 2.0.0
status:
  conditions:
  - lastTransitionTime: "2024-02-06T17:47:21Z"
    message: installation has not been attempted due to failure to gather data for
      resolution
    observedGeneration: 1
    reason: InstallationStatusUnknown
    status: Unknown
    type: Installed
  - lastTransitionTime: "2024-02-06T17:47:21Z"
    message: no package "openshift-pipelines-operator-rh" matching version "2.0.0"
      found in channel "latest"
    observedGeneration: 1
    reason: ResolutionFailed
    status: "False"
    type: Resolved</programlisting>
</example>
</listitem>
</itemizedlist>
<section xml:id="olmv1-semver-support_olmv1-installing-operator">
<title>Support for semantic versioning</title>
<simpara>Support for <link xl:href="https://semver.org/">semantic versioning (semver)</link> is enabled in OLM 1.0 by default. Operator and extension authors can use the semver standard to define compatible updates.</simpara>
<simpara>Operator Lifecycle Manager (OLM) 1.0 can use an Operator or extension&#8217;s version number to determine if an update can be resolved successfully.</simpara>
<simpara>Cluster administrators can define a range of acceptable versions to install and automtically update. For Operators and extensions that follow the semver standard, you can use comparison strings to define to specify a desired version range.</simpara>
<note>
<simpara>OLM 1.0 does not support automatic updates to the next major version. If you want to perform a major version update, you must verify and apply the update manually. For more information, see "Forcing an update or rollback".</simpara>
</note>
<section xml:id="_major_version_zero_releases">
<title>Major version zero releases</title>
<simpara>The semver standard specifies that major version zero releases (<literal>O.y.z</literal>) are reserved for initial development. During the initial development stage, the API is not stable and breaking changes might be introduced in any published version. As a result, major version zero releases apply a special set of update conditions.</simpara>
<itemizedlist>
<title>Update conditions for major version zero releases</title>
<listitem>
<simpara>You cannot apply automatic updates when the major and minor versions are both zero, such as <literal>0.0.*</literal>. For example, automatic updates with the version range of <literal>&gt;=0.0.1 &lt;0.1.0</literal> are not allowed.</simpara>
</listitem>
<listitem>
<simpara>You cannot apply automatic updates from one minor version to another within a major version zero release. For example, OLM 1.0 does not automatically apply an update from <literal>0.1.0</literal> to <literal>0.2.0</literal>.</simpara>
</listitem>
<listitem>
<simpara>You can apply automatic updates from patch versions, such as <literal>&gt;=0.1.0 &lt;0.2.0</literal> or <literal>&gt;=0.2.0 &lt;0.3.0</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>When an automatic update is blocked by OLM 1.0, you must manually verify and force the update by editing the Operator or extension&#8217;s custom resource (CR).</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-forcing-an-update-or-rollback_olmv1-installing-operator">Forcing an update or rollback</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olmv1-version-range-support_olmv1-installing-operator">
<title>Support for version ranges</title>
<simpara>In Operator Lifecycle Manager (OLM) 1.0, you can specify a version range by using a comparison string in an Operator or extension&#8217;s custom resource (CR). If you specify a version range in the CR, OLM 1.0 installs or updates to the latest version of the Operator that can be resolved within the version range.</simpara>
<itemizedlist>
<title>Resolved version workflow</title>
<listitem>
<simpara>The resolved version is the latest version of the Operator that satisfies the dependencies and constraints of the Operator and the environment.</simpara>
</listitem>
<listitem>
<simpara>An Operator update within the specified range is automatically installed if it is resolved successfully.</simpara>
</listitem>
<listitem>
<simpara>An update is not installed if it is outside of the specified range or if it cannot be resolved successfully.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information about dependency and constraint resolution in OLM 1.0, see "Dependency resolution in OLM 1.0".</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/arch/olmv1-dependency.xml#olmv1-dependency">Dependency resolution in OLM 1.0</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-version-range-comparisons_olmv1-installing-operator">
<title>Version comparison strings</title>
<simpara>You can define a version range by adding a comparison string to the <literal>spec.version</literal> field in an Operator or extension&#8217;s custom resource (CR). A comparison string is a list of space- or comma-separated values and one or more comparison operators. You can add another comparison string by including an <literal>OR</literal>, or double vertical bar (<literal>||</literal>), comparison operator between the strings.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Basic comparisons</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Comparison operator</entry>
<entry align="left" valign="top">Definition</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Equal to</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>!=</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not equal to</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Greater than</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Less than</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&gt;=</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Greater than or equal to</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;=</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Less than or equal to</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can specify a version range in an Operator or extension&#8217;s CR by using a range comparison similar to the following example:</simpara>
<formalpara>
<title>Example version range comparison</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: &gt;=1.11, &lt;1.13</programlisting>
</para>
</formalpara>
<simpara>You can use wildcard characters in all types of comparison strings. OLM 1.0 accepts <literal>x</literal>, <literal>X</literal>, and asterisks (<literal>*</literal>) as wildcard characters. When you use a wildcard character with the equal sign (<literal>=</literal>) comparison operator, you define a comparison at the patch or minor version level.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example wildcard characters in comparison strings</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Wildcard comparison</entry>
<entry align="left" valign="top">Matching string</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>1.11.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1.11.0, &lt;1.12.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&gt;=1.12.X</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1.12.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>&lt;=2.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&lt;3</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>*</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.0.0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can make patch release comparisons by using the tilde (<literal>~</literal>) comparison operator. Patch release comparisons specify a minor version up to the next major version.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example patch release comparisons</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Patch release comparison</entry>
<entry align="left" valign="top">Matching string</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>~1.11.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1.11.0, &lt;1.12.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>~1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1, &lt;2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>~1.12</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1.12, &lt;1.13</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>~1.12.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1.12.0, &lt;1.13.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>~1.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=1, &lt;2</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can use the caret (<literal>^</literal>) comparison operator to make a comparison for a major release. If you use a major release comparison before the first stable release is published, the minor versions define the API&#8217;s level of stability. In the semantic versioning (SemVer) specification, the first stable release is published as the <literal>1.0.0</literal> version.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Example major release comparisons</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Major release comparison</entry>
<entry align="left" valign="top">Matching string</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>^0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.0.0, &lt;1.0.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^0.0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.0.0, &lt;0.1.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^0.0.3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.0.3, &lt;0.0.4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^0.2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.2.0, &lt;0.3.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^0.2.3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;=0.2.3, &lt;0.3.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^1.2.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;= 1.2.0, &lt; 2.0.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^1.2.3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;= 1.2.3, &lt; 2.0.0</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^2.x</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;= 2.0.0, &lt; 3</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>^2.3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>&gt;= 2.3, &lt; 3</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="olmv1-about-target-versions_olmv1-installing-operator">
<title>Example custom resources (CRs) that specify a target version</title>
<simpara>In Operator Lifecycle Manager (OLM) 1.0, cluster administrators can declaratively set the target version of an Operator or extension in the custom resource (CR).</simpara>
<simpara>You can define a target version by specifying any of the following fields:</simpara>
<itemizedlist>
<listitem>
<simpara>Channel</simpara>
</listitem>
<listitem>
<simpara>Version number</simpara>
</listitem>
<listitem>
<simpara>Version range</simpara>
</listitem>
</itemizedlist>
<simpara>If you specify a channel in the CR, OLM 1.0 installs the latest version of the Operator or extension that can be resolved within the specified channel. When updates are published to the specified channel, OLM 1.0 automatically updates to the latest release that can be resolved from the channel.</simpara>
<formalpara>
<title>Example CR with a specified channel</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  channel: latest <co xml:id="CO113-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO113-1">
<para>Installs the latest release that can be resolved from the specified channel. Updates to the channel are automatically installed.</para>
</callout>
</calloutlist>
<simpara>If you specify the Operator or extension&#8217;s target version in the CR, OLM 1.0 installs the specified version. When the target version is specified in the CR, OLM 1.0 does not change the target version when updates are published to the catalog.</simpara>
<simpara>If you want to update the version of the Operator that is installed on the cluster, you must manually edit the Operator&#8217;s CR. Specifying an Operator&#8217;s target version pins the Operator&#8217;s version to the specified release.</simpara>
<formalpara>
<title>Example CR with the target version specified</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: 1.11.1 <co xml:id="CO114-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO114-1">
<para>Specifies the target version. If you want to update the version of the Operator or extension that is installed, you must manually update this field the CR to the desired target version.</para>
</callout>
</calloutlist>
<simpara>If you want to define a range of acceptable versions for an Operator or extension, you can specify a version range by using a comparison string. When you specify a version range, OLM 1.0 installs the latest version of an Operator or extension that can be resolved by the Operator Controller.</simpara>
<formalpara>
<title>Example CR with a version range specified</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: pipelines-operator
spec:
  packageName: openshift-pipelines-operator-rh
  version: &gt;1.11.1 <co xml:id="CO115-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO115-1">
<para>Specifies that the desired version range is greater than version <literal>1.11.1</literal>. For more information, see "Support for version ranges".</para>
</callout>
</calloutlist>
<simpara>After you create or update a CR, apply the configuration file by running the following command:</simpara>
<formalpara>
<title>Command syntax</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;extension_name&gt;.yaml</programlisting>
</para>
</formalpara>
</section>
<section xml:id="olmv1-forcing-an-update-or-rollback_olmv1-installing-operator">
<title>Forcing an update or rollback</title>
<simpara>OLM 1.0 does not support automatic updates to the next major version or rollbacks to an earlier version. If you want to perform a major version update or rollback, you must verify and force the update manually.</simpara>
<warning>
<simpara>You must verify the consequences of forcing a manual update or rollback. Failure to verify a forced update or rollback might have catastrophic consequences such as data loss.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a catalog installed.</simpara>
</listitem>
<listitem>
<simpara>You have an Operator or extension installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the custom resource (CR) of your Operator or extension as shown in the following example:</simpara>
<formalpara>
<title>Example CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: olm.operatorframework.io/v1alpha1
kind: Operator
metadata:
  name: &lt;operator_name&gt; <co xml:id="CO116-1"/>
spec:
  packageName: &lt;package_name&gt; <co xml:id="CO116-2"/>
  version: &lt;version&gt; <co xml:id="CO116-3"/>
  upgradeConstraintPolicy: Ignore <co xml:id="CO116-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO116-1">
<para>Specifies the name of the Operator or extension, such as <literal>pipelines-operator</literal></para>
</callout>
<callout arearefs="CO116-2">
<para>Specifies the package name, such as <literal>openshift-pipelines-operator-rh</literal>.</para>
</callout>
<callout arearefs="CO116-3">
<para>Specifies the blocked update or rollback version.</para>
</callout>
<callout arearefs="CO116-4">
<para>Optional: Specifies the upgrade constraint policy. To force an update or rollback, set the field to <literal>Ignore</literal>. If unspecified, the default setting is <literal>Enforce</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the changes to your Operator or extensions CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;extension_name&gt;.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/olmv1-installing-an-operator-from-a-catalog.xml#olmv1-version-range-support_olmv1-installing-operator">Support for version ranges</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olmv1-deleting-an-operator_olmv1-installing-operator">
<title>Deleting an Operator</title>
<simpara>You can delete an Operator and its custom resource definitions (CRDs) by deleting the Operator&#8217;s custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have a catalog installed.</simpara>
</listitem>
<listitem>
<simpara>You have an Operator installed.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Delete an Operator and its CRDs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete operator.operators.operatorframework.io quay-example</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">operator.operators.operatorframework.io "quay-example" deleted</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Run the following commands to verify that your Operator and its resources were deleted:</simpara>
<itemizedlist>
<listitem>
<simpara>Verify the Operator is deleted by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operator.operators.operatorframework.io</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">No resources found</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Verify that the Operator&#8217;s system namespace is deleted by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ns quay-operator-system</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">Error from server (NotFound): namespaces "quay-operator-system" not found</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="olmv1-managing-plain-bundles">
<title>Managing plain bundles in OLM 1.0 (Technology Preview)</title>

<simpara>In Operator Lifecycle Manager (OLM) 1.0, a <emphasis>plain bundle</emphasis> is a static collection of arbitrary Kubernetes manifests in YAML format. The experimental <literal>olm.bundle.mediatype</literal> property of the <literal>olm.bundle</literal> schema object differentiates a plain bundle (<literal>plain+v0</literal>) from a regular (<literal>registry+v1</literal>) bundle.</simpara>
<important>
<simpara>OLM 1.0 is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xl:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>As a cluster administrator, you can build and publish a file-based catalog that includes a plain bundle image by completing the following procedures:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Build a plain bundle image.</simpara>
</listitem>
<listitem>
<simpara>Create a file-based catalog.</simpara>
</listitem>
<listitem>
<simpara>Add the plain bundle image to your file-based catalog.</simpara>
</listitem>
<listitem>
<simpara>Build your catalog as an image.</simpara>
</listitem>
<listitem>
<simpara>Publish your catalog image.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/olm_v1/arch/olmv1-rukpak.xml#olmv1-rukpak">RukPak component and packaging format</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="prerequisites_olmv1-plain-bundles">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Access to an {product-title} cluster using an account with <literal>cluster-admin</literal> permissions</simpara>
<note>
<simpara>For {product-title} 4.14, documented procedures for OLM 1.0 are CLI-based only. Alternatively, administrators can create and view related objects in the web console by using normal methods, such as the <emphasis role="strong">Import YAML</emphasis> and <emphasis role="strong">Search</emphasis> pages. However, the existing <emphasis role="strong">OperatorHub</emphasis> and <emphasis role="strong">Installed Operators</emphasis> pages do not yet display OLM 1.0 components.</simpara>
</note>
</listitem>
<listitem>
<simpara>The <literal>TechPreviewNoUpgrades</literal> feature set enabled on the cluster</simpara>
<warning>
<simpara>Enabling the <literal>TechPreviewNoUpgrade</literal> feature set cannot be undone and prevents minor version updates. These feature sets are not recommended on production clusters.</simpara>
</warning>
</listitem>
<listitem>
<simpara>The OpenShift CLI (<literal>oc</literal>) installed on your workstation</simpara>
</listitem>
<listitem>
<simpara>The <literal>opm</literal> CLI installed on your workstation</simpara>
</listitem>
<listitem>
<simpara>Docker or Podman installed on your workstation</simpara>
</listitem>
<listitem>
<simpara>Push access to a container registry, such as <link xl:href="https://quay.io">Quay</link></simpara>
</listitem>
<listitem>
<simpara>Kubernetes manifests for your bundle in a flat directory at the root of your project similar to the following structure:</simpara>
<formalpara>
<title>Example directory structure</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">manifests
├── namespace.yaml
├── service_account.yaml
├── cluster_role.yaml
├── cluster_role_binding.yaml
└── deployment.yaml</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/clusters/nodes-cluster-enabling-features.xml#nodes-cluster-enabling">Enabling features using feature gates</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="olmv1-building-plain-bundle-image-source_olmv1-managing-catalogs">
<title>Building a plain bundle image from an image source</title>
<simpara>The Operator Controller currently supports installing plain bundles created only from a <emphasis>plain bundle image</emphasis>.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>At the root of your project, create a Dockerfile that can build a bundle image:</simpara>
<formalpara>
<title>Example <literal>plainbundle.Dockerfile</literal></title>
<para>
<programlisting language="docker" linenumbering="unnumbered">FROM scratch <co xml:id="CO117-1"/>
ADD manifests /manifests</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO117-1">
<para>Use the <literal>FROM scratch</literal> directive to make the size of the image smaller. No other files or directories are required in the bundle image.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Build an Open Container Initiative (OCI)-compliant image by using your preferred build tool, similar to the following example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build -f plainbundle.Dockerfile -t \
    quay.io/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;image_tag&gt; . <co xml:id="CO118-1"/></programlisting>
<calloutlist>
<callout arearefs="CO118-1">
<para>Use an image tag that references a repository where you have push access privileges.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Push the image to your remote registry by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push quay.io/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;image_tag&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="olmv1-creating-fbc_olmv1-managing-catalogs">
<title>Creating a file-based catalog</title>
<simpara>If you do not have a file-based catalog, you must perform the following steps to initialize the catalog.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a directory for the catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ mkdir &lt;catalog_dir&gt;</programlisting>
</listitem>
<listitem>
<simpara>Generate a Dockerfile that can build a catalog image by running the <literal>opm generate dockerfile</literal> command in the same directory level as the previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm generate dockerfile &lt;catalog_dir&gt; \
    -i registry.redhat.io/openshift4/ose-operator-registry:v{product-version} <co xml:id="CO119-1"/></programlisting>
<calloutlist>
<callout arearefs="CO119-1">
<para>Specify the official Red Hat base image by using the <literal>-i</literal> flag, otherwise the Dockerfile uses the default upstream image.</para>
</callout>
</calloutlist>
<note>
<simpara>The generated Dockerfile must be in the same parent directory as the catalog directory that you created in the previous step:</simpara>
<formalpara>
<title>Example directory structure</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">.
├── &lt;catalog_dir&gt;
└── &lt;catalog_dir&gt;.Dockerfile</programlisting>
</para>
</formalpara>
</note>
</listitem>
<listitem>
<simpara>Populate the catalog with the package definition for your extension by running the <literal>opm init</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm init &lt;extension_name&gt; \
    --output json \
    &gt; &lt;catalog_dir&gt;/index.json</programlisting>
<simpara>This command generates an <literal>olm.package</literal> declarative config blob in the specified catalog configuration file.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="olmv1-adding-plain-bundle-to-fbc_olmv1-managing-catalogs">
<title>Adding a plain bundle to a file-based catalog</title>
<simpara>The <literal>opm render</literal> command does not support adding plain bundles to catalogs. You must manually add plain bundles to your file-based catalog, as shown in the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Verify that the <literal>index.json</literal> or <literal>index.yaml</literal> file for your catalog is similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;catalog_dir&gt;/index.json</literal> file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    {
     "schema": "olm.package",
     "name": "&lt;extension_name&gt;",
     "defaultChannel": ""
    }
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To create an <literal>olm.bundle</literal> blob, edit your <literal>index.json</literal> or <literal>index.yaml</literal> file, similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;catalog_dir&gt;/index.json</literal> file with <literal>olm.bundle</literal> blob</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
   "schema": "olm.bundle",
    "name": "&lt;extension_name&gt;.v&lt;version&gt;",
    "package": "&lt;extension_name&gt;",
    "image": "quay.io/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;image_tag&gt;",
    "properties": [
        {
            "type": "olm.package",
            "value": {
            "packageName": "&lt;extension_name&gt;",
            "version": "&lt;bundle_version&gt;"
            }
        },
        {
            "type": "olm.bundle.mediatype",
            "value": "plain+v0"
        }
  ]
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To create an <literal>olm.channel</literal> blob, edit your <literal>index.json</literal> or <literal>index.yaml</literal> file, similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;catalog_dir&gt;/index.json</literal> file with <literal>olm.channel</literal> blob</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "schema": "olm.channel",
    "name": "&lt;desired_channel_name&gt;",
    "package": "&lt;extension_name&gt;",
    "entries": [
        {
            "name": "&lt;extension_name&gt;.v&lt;version&gt;"
        }
    ]
}</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Open your <literal>index.json</literal> or <literal>index.yaml</literal> file and ensure it is similar to the following example:</simpara>
<formalpara>
<title>Example <literal>&lt;catalog_dir&gt;/index.json</literal> file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "schema": "olm.package",
    "name": "example-extension",
    "defaultChannel": "preview"
}
{
    "schema": "olm.bundle",
    "name": "example-extension.v0.0.1",
    "package": "example-extension",
    "image": "quay.io/example-org/example-extension-bundle:v0.0.1",
    "properties": [
        {
            "type": "olm.package",
            "value": {
            "packageName": "example-extension",
            "version": "0.0.1"
            }
        },
        {
            "type": "olm.bundle.mediatype",
            "value": "plain+v0"
        }
    ]
}
{
    "schema": "olm.channel",
    "name": "preview",
    "package": "example-extension",
    "entries": [
        {
            "name": "example-extension.v0.0.1"
        }
    ]
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Validate your catalog by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ opm validate &lt;catalog_dir&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="olmv1-publishing-fbc_olmv1-managing-catalogs">
<title>Building and publishing a file-based catalog</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Build your file-based catalog as an image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build -f &lt;catalog_dir&gt;.Dockerfile -t \
    quay.io/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;image_tag&gt; .</programlisting>
</listitem>
<listitem>
<simpara>Push your catalog image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push quay.io/&lt;organization_name&gt;/&lt;repository_name&gt;:&lt;image_tag&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
</book>