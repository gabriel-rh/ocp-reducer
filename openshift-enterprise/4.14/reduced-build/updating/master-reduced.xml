<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Updating clusters</title>
<date>2024-02-13</date>
</info>
<chapter xml:id="_understanding_openshift_updates">
<title>Understanding OpenShift updates</title>
<section xml:id="understanding-openshift-updates">
<title>Introduction to OpenShift updates</title>

<simpara>With {product-title} 4, you can update an {product-title} cluster with a single operation by using the web console or the OpenShift CLI (<literal>oc</literal>). Platform administrators can view new update options either by going to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> in the web console or by looking at the output of the <literal>oc adm upgrade</literal> command.</simpara>
<simpara>Red Hat hosts a public OpenShift Update Service (OSUS), which serves a graph of update possibilities based on the {product-title} release images in the official registry.
The graph contains update information for any public OCP release.
{product-title} clusters are configured to connect to the OSUS by default, and the OSUS responds to clusters with information about known update targets.</simpara>
<simpara>An update begins when either a cluster administrator or an automatic update controller edits the custom resource (CR) of the Cluster Version Operator (CVO) with a new version.
To reconcile the cluster with the newly specified version, the CVO retrieves the target release image from an image registry and begins to apply changes to the cluster.</simpara>
<note>
<simpara>Operators previously installed through Operator Lifecycle Manager (OLM) follow a different process for updates. See <link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link> for more information.</simpara>
</note>
<simpara>The target release image contains manifest files for all cluster components that form a specific OCP version.
When updating the cluster to a new version, the CVO applies manifests in separate stages called Runlevels.
Most, but not all, manifests support one of the cluster Operators.
As the CVO applies a manifest to a cluster Operator, the Operator might perform update tasks to reconcile itself with its new specified version.</simpara>
<simpara>The CVO monitors the state of each applied resource and the states reported by all cluster Operators. The CVO only proceeds with the update when all manifests and cluster Operators in the active Runlevel reach a stable condition.
After the CVO updates the entire control plane through this process, the Machine Config Operator (MCO) updates the operating system and configuration of every node in the cluster.</simpara>
<section xml:id="update-availability_understanding-openshift-updates">
<title>Common questions about update availability</title>
<simpara>There are several factors that affect if and when an update is made available to an {product-title} cluster. The following list provides common questions regarding the availability of an update:</simpara>
<simpara xml:id="channel-differences_understanding-openshift-updates"><emphasis role="strong">What are the differences between each of the update channels?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>A new release is initially added to the <literal>candidate</literal> channel.</simpara>
</listitem>
<listitem>
<simpara>After successful final testing, a release on the <literal>candidate</literal> channel is promoted to the <literal>fast</literal> channel, an errata is published, and the release is now fully supported.</simpara>
</listitem>
<listitem>
<simpara>After a delay, a release on the <literal>fast</literal> channel is finally promoted to the <literal>stable</literal> channel. This delay represents the only difference between the <literal>fast</literal> and <literal>stable</literal> channels.</simpara>
<note>
<simpara>For the latest z-stream releases, this delay may generally be a week or two. However, the delay for initial updates to the latest minor version may take much longer, generally 45-90 days.</simpara>
</note>
</listitem>
<listitem>
<simpara>Releases promoted to the <literal>stable</literal> channel are simultaneously promoted to the <literal>eus</literal> channel.
The primary purpose of the <literal>eus</literal> channel is to serve as a convenience for clusters performing an EUS-to-EUS update.</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="channel-safety_understanding-openshift-updates"><emphasis role="strong">Is a release on the <literal>stable</literal> channel safer or more supported than a release on the <literal>fast</literal> channel?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>If a regression is identified for a release on a <literal>fast</literal> channel, it will be resolved and managed to the same extent as if that regression was identified for a release on the <literal>stable</literal> channel.</simpara>
</listitem>
<listitem>
<simpara>The only difference between releases on the <literal>fast</literal> and <literal>stable</literal> channels is that a release only appears on the <literal>stable</literal> channel after it has been on the <literal>fast</literal> channel for some time, which provides more time for new update risks to be discovered.</simpara>
</listitem>
<listitem>
<simpara>A release that is available on the <literal>fast</literal> channel always becomes available on the <literal>stable</literal> channel after this delay.</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="supported-updates_understanding-openshift-updates"><emphasis role="strong">What does it mean if an update is supported but not recommended?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat continuously evaluates data from multiple sources to determine whether updates from one version to another lead to issues.
If an issue is identified, an update path may no longer be recommended to users.
However, even if the update path is not recommended, customers are still supported if they perform the update.</simpara>
</listitem>
<listitem>
<simpara>Red Hat does not block users from updating to a certain version.
Red Hat may declare conditional update risks, which may or may not apply to a particular cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>Declared risks provide cluster administrators more context about a supported update.
Cluster administrators can still accept the risk and update to that particular target version.
This update is always supported despite not being recommended in the context of the conditional risk.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara xml:id="removed-recommendation_understanding-openshift-updates"><emphasis role="strong">What if I see that an update to a particular release is no longer recommended?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>If Red Hat removes update recommendations from any supported release due to a regression, a superseding update recommendation will be provided to a future version that corrects the regression.
There may be a delay while the defect is corrected, tested, and promoted to your selected channel.</simpara>
</listitem>
</itemizedlist>
<simpara xml:id="z-stream-release-cadence_understanding-openshift-updates"><emphasis role="strong">How long until the next z-stream release is made available on the fast and stable channels?</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>While the specific cadence can vary based on a number of factors, new z-stream releases for the latest minor version are typically made available about every week. Older minor versions, which have become more stable over time, may take much longer for new z-stream releases to be made available.</simpara>
<important>
<simpara>These are only estimates based on past data about z-stream releases. Red&#160;Hat reserves the right to change the release frequency as needed. Any number of issues could cause irregularities and delays in this release cadence.</simpara>
</important>
</listitem>
<listitem>
<simpara>Once a z-stream release is published, it also appears in the <literal>fast</literal> channel for that minor version. After a delay, the z-stream release may then appear in that minor version&#8217;s <literal>stable</literal> channel.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-service-about_understanding-openshift-updates">
<title>About the OpenShift Update Service</title>
<simpara>The OpenShift Update Service (OSUS) provides update recommendations to {product-title}, including Red Hat Enterprise Linux CoreOS (RHCOS). It provides a graph, or diagram, that contains the <emphasis>vertices</emphasis> of component Operators and the <emphasis>edges</emphasis> that connect them. The edges in the graph show which versions you can safely update to. The vertices are update payloads that specify the intended state of the managed cluster components.</simpara>
<simpara>The Cluster Version Operator (CVO) in your cluster checks with the OpenShift Update Service to see the valid updates and update paths based on current component versions and information in the graph. When you request an update, the CVO uses the corresponding release image to update your cluster. The release artifacts are hosted in Quay as container images.</simpara>
<simpara>To allow the OpenShift Update Service to provide only compatible updates, a release verification pipeline drives automation. Each release artifact is verified for compatibility with supported cloud platforms and system architectures, as well as other component packages. After the pipeline confirms the suitability of a release, the OpenShift Update Service notifies you that it is available.</simpara>
<important>
<simpara>The OpenShift Update Service displays all recommended updates for your current cluster.  If an update path is not recommended by the OpenShift Update Service, it might be because of a known issue with the update or the target release.</simpara>
</important>
<simpara>Two controllers run during continuous update mode. The first controller continuously updates the payload manifests, applies the manifests to the cluster, and outputs the controlled rollout status of the Operators to indicate whether they are available, upgrading, or failed. The second controller polls the OpenShift Update Service to determine if updates are available.</simpara>
<important>
<simpara>Only updating to a newer version is supported. Reverting or rolling back your cluster to a previous version is not supported. If your update fails, contact Red Hat support.</simpara>
</important>
<simpara>During the update process, the Machine Config Operator (MCO) applies the new configuration to your cluster machines. The MCO cordons the number of nodes specified by the <literal>maxUnavailable</literal> field on the machine configuration pool and marks them unavailable. By default, this value is set to <literal>1</literal>. The MCO updates the affected nodes alphabetically by zone, based on the <literal>topology.kubernetes.io/zone</literal> label. If a zone has more than one node, the oldest nodes are updated first. For nodes that do not use zones, such as in bare metal deployments, the nodes are updated by age, with the oldest nodes updated first. The MCO updates the number of nodes as specified by the <literal>maxUnavailable</literal> field on the machine configuration pool at a time. The MCO then applies the new configuration and reboots the machine.</simpara>
<simpara>If you use Red Hat Enterprise Linux (RHEL) machines as workers, the MCO does not update the kubelet because you must update the OpenShift API on the machines first.</simpara>
<simpara>With the specification for the new version applied to the old kubelet, the RHEL machine cannot return to the <literal>Ready</literal> state. You cannot complete the update until the machines are available. However, the maximum number of unavailable nodes is set to ensure that normal cluster operations can continue with that number of machines out of service.</simpara>
<simpara>The OpenShift Update Service is composed of an Operator and one or more application instances.</simpara>
</section>
<section xml:id="understanding_clusteroperator_conditiontypes_understanding-openshift-updates">
<title>Understanding cluster Operator condition types</title>
<simpara>The status of cluster Operators includes their condition type, which informs you of the current state of your Operator&#8217;s health. The following definitions cover a list of some common ClusterOperator condition types. Operators that have additional condition types and use Operator-specific language have been omitted.</simpara>
<simpara>The Cluster Version Operator (CVO) is responsible for collecting the status conditions from cluster Operators so that cluster administrators can better understand the state of the {product-title} cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>Available:
The condition type <literal>Available</literal> indicates that an Operator is functional and available in the cluster. If the status is <literal>False</literal>, at least one part of the operand is non-functional and the condition requires an administrator to intervene.</simpara>
</listitem>
<listitem>
<simpara>Progressing:
The condition type <literal>Progressing</literal> indicates that an Operator is actively rolling out new code, propagating configuration changes, or otherwise moving from one steady state to another.</simpara>
<simpara>Operators do not report the condition type <literal>Progressing</literal> as <literal>True</literal> when they are reconciling a previous known state. If the observed cluster state has changed and the Operator is reacting to it, then the status reports back as <literal>True</literal>, since it is moving from one steady state to another.</simpara>
</listitem>
<listitem>
<simpara>Degraded:
The condition type <literal>Degraded</literal> indicates that an Operator has a current state that does not match its required state over a period of time. The period of time can vary by component, but a <literal>Degraded</literal> status represents persistent observation of an Operator&#8217;s condition.  As a result, an Operator does not fluctuate in and out of the <literal>Degraded</literal> state.</simpara>
<simpara>There might be a different condition type if the transition from one state to another does not persist over a long enough period to report <literal>Degraded</literal>.
An Operator does not report <literal>Degraded</literal> during the course of a normal update.  An Operator may report <literal>Degraded</literal> in response to a persistent infrastructure failure that requires eventual administrator intervention.</simpara>
<note>
<simpara>This condition type is only an indication that something may need investigation and adjustment. As long as the Operator is available, the <literal>Degraded</literal> condition does not cause user workload failure or application downtime.</simpara>
</note>
</listitem>
<listitem>
<simpara>Upgradeable:
The condition type <literal>Upgradeable</literal> indicates whether the Operator is safe to update based on the current cluster state. The message field contains a human-readable description of what the administrator needs to do for the cluster to successfully update. The CVO allows updates when this condition is <literal>True</literal>, <literal>Unknown</literal> or missing.</simpara>
<simpara>When the <literal>Upgradeable</literal> status is <literal>False</literal>, only minor updates are impacted, and the CVO prevents the cluster from performing impacted updates unless forced.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="understanding-clusterversion-conditiontypes_understanding-openshift-updates">
<title>Understanding cluster version condition types</title>
<simpara>The Cluster Version Operator (CVO) monitors cluster Operators and other components, and is responsible for collecting the status of both the cluster version and its Operators. This status includes the condition type, which informs you of the health and current state of the {product-title} cluster.</simpara>
<simpara>In addition to <literal>Available</literal>, <literal>Progressing</literal>, and <literal>Upgradeable</literal>, there are condition types that affect cluster versions and Operators.</simpara>
<itemizedlist>
<listitem>
<simpara>Failing:
The cluster version condition type <literal>Failing</literal> indicates that a cluster cannot reach its desired state, is unhealthy, and requires an administrator to intervene.</simpara>
</listitem>
<listitem>
<simpara>Invalid:
The cluster version condition type <literal>Invalid</literal> indicates that the cluster version has an error that prevents the server from taking action. The CVO only reconciles the current state as long as this condition is set.</simpara>
</listitem>
<listitem>
<simpara>RetrievedUpdates:
The cluster version condition type <literal>RetrievedUpdates</literal> indicates whether or not available updates have been retrieved from the upstream update server. The condition is <literal>Unknown</literal> before retrieval, <literal>False</literal> if the updates either recently failed or could not be retrieved, or <literal>True</literal> if the <literal>availableUpdates</literal> field is both recent and accurate.</simpara>
</listitem>
<listitem>
<simpara>ReleaseAccepted:
The cluster version condition type <literal>ReleaseAccepted</literal> with a <literal>True</literal> status indicates that the requested release payload was successfully loaded without failure during image verification and precondition checking.</simpara>
</listitem>
<listitem>
<simpara>ImplicitlyEnabledCapabilities:
The cluster version condition type <literal>ImplicitlyEnabledCapabilities</literal> with a <literal>True</literal> status indicates that there are enabled capabilities that the user is not currently requesting through <literal>spec.capabilities</literal>. The CVO does not support disabling capabilities if any associated resources were previously managed by the CVO.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-common-terms_understanding-openshift-updates">
<title>Common terms</title>
<variablelist>
<varlistentry>
<term>Control plane</term>
<listitem>
<simpara>The <emphasis>control plane</emphasis>, which is composed of control plane machines, manages the {product-title} cluster. The control plane machines manage workloads on the compute machines, which are also known as worker machines.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Cluster Version Operator</term>
<listitem>
<simpara>The <emphasis>Cluster Version Operator</emphasis> (CVO) starts the update process for the cluster. It checks with OSUS based on the current cluster version and retrieves the graph which contains available or possible update paths.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Machine Config Operator</term>
<listitem>
<simpara>The <emphasis>Machine Config Operator</emphasis> (MCO) is a cluster-level Operator that manages the operating system and machine configurations. Through the MCO, platform administrators can configure and update systemd, CRI-O and Kubelet, the kernel, NetworkManager, and other system features on the worker nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenShift Update Service</term>
<listitem>
<simpara>The <emphasis>OpenShift Update Service</emphasis> (OSUS) provides over-the-air updates to {product-title}, including to Red Hat Enterprise Linux CoreOS (RHCOS). It provides a graph, or diagram, that contains the vertices of component Operators and the edges that connect them.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Channels</term>
<listitem>
<simpara><emphasis>Channels</emphasis> declare an update strategy tied to minor versions of {product-title}. The OSUS uses this configured strategy to recommend update edges consistent with that strategy.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Recommended update edge</term>
<listitem>
<simpara>A <emphasis>recommended update edge</emphasis> is a recommended update between {product-title} releases.  Whether a given update is recommended can depend on the cluster&#8217;s configured channel, current version, known bugs, and other information. OSUS communicates the recommended edges to the CVO, which runs in every cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Extended Update Support</term>
<listitem>
<simpara>All post-4.7 even-numbered minor releases are labeled as <emphasis>Extended Update Support</emphasis> (EUS) releases. These releases introduce a verified update path between EUS releases, permitting customers to streamline updates of worker nodes and formulate update strategies of EUS-to-EUS {product-title} releases that result in fewer reboots of worker nodes.</simpara>
<simpara>For more information, see <link xl:href="https://access.redhat.com/support/policy/updates/openshift-eus">Red Hat OpenShift Extended Update Support (EUS) Overview</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../post_installation_configuration/machine-configuration-tasks.xml#machine-config-overview-post-install-machine-configuration-tasks">Machine config overview</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating_disconnected_cluster/disconnected-update-osus.xml#update-service-overview_updating-restricted-network-cluster-osus">Using the OpenShift Update Service in a disconnected environment</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels_understanding-update-channels-releases">Update channels</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="understanding-openshift-updates-additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/how-updates-work.xml#how-updates-work">How cluster updates work</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="how-updates-work">
<title>How cluster updates work</title>

<simpara>The following sections describe each major aspect of the {product-title} (OCP) update process in detail. For a general overview of how updates work, see the <link xl:href="../../updating/understanding_updates/intro-to-updates.xml#understanding-openshift-updates">Introduction to OpenShift updates</link>.</simpara>
<section xml:id="update-cvo_how-updates-work">
<title>The Cluster Version Operator</title>
<simpara>The Cluster Version Operator (CVO) is the primary component that orchestrates and facilitates the {product-title} update process.
During installation and standard cluster operation, the CVO is constantly comparing the manifests of managed cluster Operators to in-cluster resources, and reconciling discrepancies to ensure that the actual state of these resources match their desired state.</simpara>
<section xml:id="update-cluster-version-object_how-updates-work">
<title>The ClusterVersion object</title>
<simpara>One of the resources that the Cluster Version Operator (CVO) monitors is the <literal>ClusterVersion</literal> resource.</simpara>
<simpara>Administrators and OpenShift components can communicate or interact with the CVO through the <literal>ClusterVersion</literal> object.
The desired CVO state is declared through the <literal>ClusterVersion</literal> object and the current CVO state is reflected in the object&#8217;s status.</simpara>
<note>
<simpara>Do not directly modify the <literal>ClusterVersion</literal> object. Instead, use interfaces such as the <literal>oc</literal> CLI or the web console to declare your update target.</simpara>
</note>
<simpara>The CVO continually reconciles the cluster with the target state declared in the <literal>spec</literal> property of the <literal>ClusterVersion</literal> resource.
When the desired release differs from the actual release, that reconciliation updates the cluster.</simpara>
<bridgehead xml:id="_update_availability_data" renderas="sect5">Update availability data</bridgehead>
<simpara>The <literal>ClusterVersion</literal> resource also contains information about updates that are available to the cluster.
This includes updates that are available, but not recommended due to a known risk that applies to the cluster.
These updates are known as conditional updates.
To learn how the CVO maintains this information about available updates in the <literal>ClusterVersion</literal> resource, see the "Evaluation of update availability" section.</simpara>
<itemizedlist>
<listitem>
<simpara>You can inspect all available updates with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --include-not-recommended</programlisting>
<note>
<simpara>The additional <literal>--include-not-recommended</literal> parameter includes updates that are available but not recommended due to a known risk that applies to the cluster.</simpara>
</note>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cluster version is 4.10.22

Upstream is unset, so the cluster will use an appropriate default.
Channel: fast-4.11 (available channels: candidate-4.10, candidate-4.11, eus-4.10, fast-4.10, fast-4.11, stable-4.10)

Recommended updates:

  VERSION     IMAGE
  4.10.26     quay.io/openshift-release-dev/ocp-release@sha256:e1fa1f513068082d97d78be643c369398b0e6820afab708d26acda2262940954
  4.10.25     quay.io/openshift-release-dev/ocp-release@sha256:ed84fb3fbe026b3bbb4a2637ddd874452ac49c6ead1e15675f257e28664879cc
  4.10.24     quay.io/openshift-release-dev/ocp-release@sha256:aab51636460b5a9757b736a29bc92ada6e6e6282e46b06e6fd483063d590d62a
  4.10.23     quay.io/openshift-release-dev/ocp-release@sha256:e40e49d722cb36a95fa1c03002942b967ccbd7d68de10e003f0baa69abad457b

Supported but not recommended updates:

  Version: 4.11.0
  Image: quay.io/openshift-release-dev/ocp-release@sha256:300bce8246cf880e792e106607925de0a404484637627edf5f517375517d54a4
  Recommended: False
  Reason: RPMOSTreeTimeout
  Message: Nodes with substantial numbers of containers and CPU contention may not reconcile machine configuration https://bugzilla.redhat.com/show_bug.cgi?id=2111817#c22</programlisting>
</para>
</formalpara>
<simpara>The <literal>oc adm upgrade</literal> command queries the <literal>ClusterVersion</literal> resource for information about available updates and presents it in a human-readable format.</simpara>
</listitem>
<listitem>
<simpara>One way to directly inspect the underlying availability data created by the CVO is by querying the <literal>ClusterVersion</literal> resource with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion version -o json | jq '.status.availableUpdates'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[
  {
    "channels": [
      "candidate-4.11",
      "candidate-4.12",
      "fast-4.11",
      "fast-4.12"
    ],
    "image": "quay.io/openshift-release-dev/ocp-release@sha256:400267c7f4e61c6bfa0a59571467e8bd85c9188e442cbd820cc8263809be3775",
    "url": "https://access.redhat.com/errata/RHBA-2023:3213",
    "version": "4.11.41"
  },
  ...
]</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>A similar command can be used to check conditional updates:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion version -o json | jq '.status.conditionalUpdates'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[
  {
    "conditions": [
      {
        "lastTransitionTime": "2023-05-30T16:28:59Z",
        "message": "The 4.11.36 release only resolves an installation issue https://issues.redhat.com//browse/OCPBUGS-11663 , which does not affect already running clusters. 4.11.36 does not include fixes delivered in recent 4.11.z releases and therefore upgrading from these versions would cause fixed bugs to reappear. Red Hat does not recommend upgrading clusters to 4.11.36 version for this reason. https://access.redhat.com/solutions/7007136",
        "reason": "PatchesOlderRelease",
        "status": "False",
        "type": "Recommended"
      }
    ],
    "release": {
      "channels": [...],
      "image": "quay.io/openshift-release-dev/ocp-release@sha256:8c04176b771a62abd801fcda3e952633566c8b5ff177b93592e8e8d2d1f8471d",
      "url": "https://access.redhat.com/errata/RHBA-2023:1733",
      "version": "4.11.36"
    },
    "risks": [...]
  },
  ...
]</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-evaluate-availability_how-updates-work">
<title>Evaluation of update availability</title>
<simpara>The Cluster Version Operator (CVO) periodically queries the OpenShift Update Service (OSUS) for the most recent data about update possibilities.
This data is based on the cluster&#8217;s subscribed channel.
The CVO then saves information about update recommendations into either the <literal>availableUpdates</literal> or <literal>conditionalUpdates</literal> field of its <literal>ClusterVersion</literal> resource.</simpara>
<simpara>The CVO periodically checks the conditional updates for update risks.
These risks are conveyed through the data served by the OSUS, which contains information for each version about known issues that might affect a cluster updated to that version.
Most risks are limited to clusters with specific characteristics, such as clusters with a certain size or clusters that are deployed in a particular cloud platform.</simpara>
<simpara>The CVO continuously evaluates its cluster characteristics against the conditional risk information for each conditional update. If the CVO finds that the cluster matches the criteria, the CVO stores this information in the <literal>conditionalUpdates</literal> field of its <literal>ClusterVersion</literal> resource.
If the CVO finds that the cluster does not match the risks of an update, or that there are no risks associated with the update, it stores the target version in the <literal>availableUpdates</literal> field of its <literal>ClusterVersion</literal> resource.</simpara>
<simpara>The user interface, either the web console or the OpenShift CLI (<literal>oc</literal>), presents this information in sectioned headings to the administrator.
Each <emphasis role="strong">supported but not recommended</emphasis> update recommendation contains a link to further resources about the risk so that the administrator can make an informed decision about the update.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#conditional-updates-overview_understanding-update-channels-releases">Update recommendation removals and Conditional Updates</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="update-release-images_how-updates-work">
<title>Release images</title>
<simpara>A release image is the delivery mechanism for a specific {product-title} (OCP) version.
It contains the release metadata, a Cluster Version Operator (CVO) binary matching the release version, every manifest needed to deploy individual OpenShift cluster Operators, and a list of SHA digest-versioned references to all container images that make up this OpenShift version.</simpara>
<simpara>You can inspect the content of a specific release image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release extract &lt;release image&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release extract quay.io/openshift-release-dev/ocp-release:4.12.6-x86_64
Extracted release payload from digest sha256:800d1e39d145664975a3bb7cbc6e674fbf78e3c45b5dde9ff2c5a11a8690c87b created at 2023-03-01T12:46:29Z

$ ls
0000_03_authorization-openshift_01_rolebindingrestriction.crd.yaml
0000_03_config-operator_01_proxy.crd.yaml
0000_03_marketplace-operator_01_operatorhub.crd.yaml
0000_03_marketplace-operator_02_operatorhub.cr.yaml
0000_03_quota-openshift_01_clusterresourcequota.crd.yaml <co xml:id="CO1-1"/>
...
0000_90_service-ca-operator_02_prometheusrolebinding.yaml <co xml:id="CO1-2"/>
0000_90_service-ca-operator_03_servicemonitor.yaml
0000_99_machine-api-operator_00_tombstones.yaml
image-references <co xml:id="CO1-3"/>
release-metadata</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO1-1">
<para>Manifest for <literal>ClusterResourceQuota</literal> CRD, to be applied on Runlevel 03</para>
</callout>
<callout arearefs="CO1-2">
<para>Manifest for <literal>PrometheusRoleBinding</literal> resource for the <literal>service-ca-operator</literal>, to be applied on Runlevel 90</para>
</callout>
<callout arearefs="CO1-3">
<para>List of SHA digest-versioned references to all required images</para>
</callout>
</calloutlist>
</section>
<section xml:id="update-process-workflow_how-updates-work">
<title>Update process workflow</title>
<simpara>The following steps represent a detailed workflow of the {product-title} (OCP) update process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The target version is stored in the <literal>spec.desiredUpdate.version</literal> field of the <literal>ClusterVersion</literal> resource, which may be managed through the web console or the CLI.</simpara>
</listitem>
<listitem>
<simpara>The Cluster Version Operator (CVO) detects that the <literal>desiredUpdate</literal> in the <literal>ClusterVersion</literal> resource differs from the current cluster version.
Using graph data from the OpenShift Update Service, the CVO resolves the desired cluster version to a pull spec for the release image.</simpara>
</listitem>
<listitem>
<simpara>The CVO validates the integrity and authenticity of the release image.
Red Hat publishes cryptographically-signed statements about published release images at predefined locations by using image SHA digests as unique and immutable release image identifiers.
The CVO utilizes a list of built-in public keys to validate the presence and signatures of the statement matching the checked release image.</simpara>
</listitem>
<listitem>
<simpara>The CVO creates a job named <literal>version-$version-$hash</literal> in the <literal>openshift-cluster-version</literal> namespace.
This job uses containers that are executing the release image, so the cluster downloads the image through the container runtime.
The job then extracts the manifests and metadata from the release image to a shared volume that is accessible to the CVO.</simpara>
</listitem>
<listitem>
<simpara>The CVO validates the extracted manifests and metadata.</simpara>
</listitem>
<listitem>
<simpara>The CVO checks some preconditions to ensure that no problematic condition is detected in the cluster.
Certain conditions can prevent updates from proceeding.
These conditions are either determined by the CVO itself, or reported by individual cluster Operators that detect some details about the cluster that the Operator considers problematic for the update.</simpara>
</listitem>
<listitem>
<simpara>The CVO records the accepted release in <literal>status.desired</literal> and creates a <literal>status.history</literal> entry about the new update.</simpara>
</listitem>
<listitem>
<simpara>The CVO begins reconciling the manifests from the release image.
Cluster Operators are updated in separate stages called Runlevels, and the CVO ensures that all Operators in a Runlevel finish updating before it proceeds to the next level.</simpara>
</listitem>
<listitem>
<simpara>Manifests for the CVO itself are applied early in the process.
When the CVO deployment is applied, the current CVO pod stops, and a CVO pod that uses the new version starts.
The new CVO proceeds to reconcile the remaining manifests.</simpara>
</listitem>
<listitem>
<simpara>The update proceeds until the entire control plane is updated to the new version.
Individual cluster Operators might perform update tasks on their domain of the cluster, and while they do so, they report their state through the <literal>Progressing=True</literal> condition.</simpara>
</listitem>
<listitem>
<simpara>The Machine Config Operator (MCO) manifests are applied towards the end of the process.
The updated MCO then begins updating the system configuration and operating system of every node.
Each node might be drained, updated, and rebooted before it starts to accept workloads again.</simpara>
</listitem>
</orderedlist>
<simpara>The cluster reports as updated after the control plane update is finished, usually before all nodes are updated.
After the update, the CVO maintains all cluster resources to match the state delivered in the release image.</simpara>
</section>
<section xml:id="update-manifest-application_how-updates-work">
<title>Understanding how manifests are applied during an update</title>
<simpara>Some manifests supplied in a release image must be applied in a certain order because of the dependencies between them.
For example, the <literal>CustomResourceDefinition</literal> resource must be created before the matching custom resources.
Additionally, there is a logical order in which the individual cluster Operators must be updated to minimize disruption in the cluster.
The Cluster Version Operator (CVO) implements this logical order through the concept of Runlevels.</simpara>
<simpara>These dependencies are encoded in the filenames of the manifests in the release image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">0000_&lt;runlevel&gt;_&lt;component&gt;_&lt;manifest-name&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">0000_03_config-operator_01_proxy.crd.yaml</programlisting>
<simpara>The CVO internally builds a dependency graph for the manifests, where the CVO obeys the following rules:</simpara>
<itemizedlist>
<listitem>
<simpara>During an update, manifests at a lower Runlevel are applied before those at a higher Runlevel.</simpara>
</listitem>
<listitem>
<simpara>Within one Runlevel, manifests for different components can be applied in parallel.</simpara>
</listitem>
<listitem>
<simpara>Within one Runlevel, manifests for a single component are applied in lexicographic order.</simpara>
</listitem>
</itemizedlist>
<simpara>The CVO then applies manifests following the generated dependency graph.</simpara>
<note>
<simpara>For some resource types, the CVO monitors the resource after its manifest is applied, and considers it to be successfully updated only after the resource reaches a stable state.
Achieving this state can take some time.
This is especially true for <literal>ClusterOperator</literal> resources, while the CVO waits for a cluster Operator to update itself and then update its <literal>ClusterOperator</literal> status.</simpara>
</note>
<simpara>The CVO waits until all cluster Operators in the Runlevel meet the following conditions before it proceeds to the next Runlevel:</simpara>
<itemizedlist>
<listitem>
<simpara>The cluster Operators have an <literal>Available=True</literal> condition.</simpara>
</listitem>
<listitem>
<simpara>The cluster Operators have a <literal>Degraded=False</literal> condition.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara>The cluster Operators declare they have achieved the desired version in their ClusterOperator resource.</simpara>
</listitem>
</itemizedlist>
<simpara>Some actions can take significant time to finish. The CVO waits for the actions to complete in order to ensure the subsequent Runlevels can proceed safely.
Initially reconciling the new release&#8217;s manifests is expected to take 60 to 120 minutes in total; see <emphasis role="strong">Understanding {product-title} update duration</emphasis> for more information about factors that influence update duration.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/update-runlevels.png"/>
</imageobject>
<textobject><phrase>A diagram displaying the sequence of Runlevels and the manifests of components within each level</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the previous example diagram, the CVO is waiting until all work is completed at Runlevel 20.
The CVO has applied all manifests to the Operators in the Runlevel, but the <literal>kube-apiserver-operator ClusterOperator</literal> performs some actions after its new version was deployed. The <literal>kube-apiserver-operator ClusterOperator</literal> declares this progress through the <literal>Progressing=True</literal> condition and by not declaring the new version as reconciled in its <literal>status.versions</literal>.
The CVO waits until the ClusterOperator reports an acceptable status, and then it will start reconciling manifests at Runlevel 25.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-openshift-update-duration.xml#understanding-openshift-update-duration">Understanding {product-title} update duration</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="mco-update-process_how-updates-work">
<title>Understanding how the Machine Config Operator updates nodes</title>
<simpara>The Machine Config Operator (MCO) applies a new machine configuration to each control plane node and compute node. During the machine configuration update, control plane nodes and compute nodes are organized into their own machine config pools, where the pools of machines are updated in parallel. The <literal>.spec.maxUnavailable</literal> parameter, which has a default value of <literal>1</literal>, determines how many nodes in a machine config pool can simultaneously undergo the update process.</simpara>
<simpara>When the machine configuration update process begins, the MCO checks the amount of currently unavailable nodes in a pool. If there are fewer unavailable nodes than the value of <literal>.spec.maxUnavailable</literal>, the MCO initiates the following sequence of actions on available nodes in the pool:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Cordon and drain the node</simpara>
<note>
<simpara>When a node is cordoned, workloads cannot be scheduled to it.</simpara>
</note>
</listitem>
<listitem>
<simpara>Update the system configuration and operating system (OS) of the node</simpara>
</listitem>
<listitem>
<simpara>Reboot the node</simpara>
</listitem>
<listitem>
<simpara>Uncordon the node</simpara>
</listitem>
</orderedlist>
<simpara>A node undergoing this process is unavailable until it is uncordoned and workloads can be scheduled to it again. The MCO begins updating nodes until the number of unavailable nodes is equal to the value of <literal>.spec.maxUnavailable</literal>.</simpara>
<simpara>As a node completes its update and becomes available, the number of unavailable nodes in the machine config pool is once again fewer than <literal>.spec.maxUnavailable</literal>. If there are remaining nodes that need to be updated, the MCO initiates the update process on a node until the <literal>.spec.maxUnavailable</literal> limit is once again reached. This process repeats until each control plane node and compute node has been updated.</simpara>
<simpara>The following example workflow describes how this process might occur in a machine config pool with 5 nodes, where <literal>.spec.maxUnavailable</literal> is 3 and all nodes are initially available:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The MCO cordons nodes 1, 2, and 3, and begins to drain them.</simpara>
</listitem>
<listitem>
<simpara>Node 2 finishes draining, reboots, and becomes available again. The MCO cordons node 4 and begins draining it.</simpara>
</listitem>
<listitem>
<simpara>Node 1 finishes draining, reboots, and becomes available again. The MCO cordons node 5 and begins draining it.</simpara>
</listitem>
<listitem>
<simpara>Node 3 finishes draining, reboots, and becomes available again.</simpara>
</listitem>
<listitem>
<simpara>Node 5 finishes draining, reboots, and becomes available again.</simpara>
</listitem>
<listitem>
<simpara>Node 4 finishes draining, reboots, and becomes available again.</simpara>
</listitem>
</orderedlist>
<simpara>Because the update process for each node is independent of other nodes, some nodes in the example above finish their update out of the order in which they were cordoned by the MCO.</simpara>
<simpara>You can check the status of the machine configuration update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         CONFIG                                                 UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master       rendered-master-acd1358917e9f98cbdb599aea622d78b       True      False      False      3              3                   3                     0                      22h
worker       rendered-worker-1d871ac76e1951d32b2fe92369879826       False     True       False      2              1                   1                     0                      22h</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../post_installation_configuration/machine-configuration-tasks.xml#machine-config-overview-post-install-machine-configuration-tasks">Machine config overview</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="understanding-update-channels-releases">
<title>Understanding update channels and releases</title>

<simpara>Update channels are the mechanism by which users declare the {product-title} minor version they intend to update their clusters to. They also allow users to choose the timing and level of support their updates will have through the <literal>fast</literal>, <literal>stable</literal>, <literal>candidate</literal>, and <literal>eus</literal> channel options. The Cluster Version Operator uses an update graph based on the channel declaration, along with other conditional information, to provide a list of recommended and conditional updates available to the cluster.</simpara>
<simpara>Update channels correspond to a minor version of {product-title}. The version number in the channel represents the target minor version that the cluster will eventually be updated to, even if it is higher than the cluster&#8217;s current minor version.</simpara>
<simpara>For instance, {product-title} 4.10 update channels provide the following recommendations:</simpara>
<itemizedlist>
<listitem>
<simpara>Updates within 4.10.</simpara>
</listitem>
<listitem>
<simpara>Updates within 4.9.</simpara>
</listitem>
<listitem>
<simpara>Updates from 4.9 to 4.10, allowing all 4.9 clusters to eventually update to 4.10, even if they do not immediately meet the minimum z-stream version requirements.</simpara>
</listitem>
<listitem>
<simpara><literal>eus-4.10</literal> only: updates within 4.8.</simpara>
</listitem>
<listitem>
<simpara><literal>eus-4.10</literal> only: updates from 4.8 to 4.9 to 4.10, allowing all 4.8 clusters to eventually update to 4.10.</simpara>
</listitem>
</itemizedlist>
<simpara>4.10 update channels do not recommend updates to 4.11 or later releases. This strategy ensures that administrators must explicitly decide to update to the next minor version of {product-title}.</simpara>
<simpara>Update channels control only release selection and do not impact the version of the cluster that you install. The <literal>openshift-install</literal> binary file for a specific version of {product-title} always installs that version.</simpara>
<simpara>{product-title} {product-version} offers the following update channels:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>stable-{product-version}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>eus-4.y</literal> (only offered for EUS versions and meant to facilitate updates between EUS versions)</simpara>
</listitem>
<listitem>
<simpara><literal>fast-{product-version}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>candidate-{product-version}</literal></simpara>
</listitem>
</itemizedlist>
<simpara>If you do not want the Cluster Version Operator to fetch available updates from the update recommendation service, you can use the <literal>oc adm upgrade channel</literal> command in the OpenShift CLI to configure an empty channel. This configuration can be helpful if, for example, a cluster has restricted network access and there is no local, reachable update recommendation service.</simpara>
<warning>
<simpara>Red Hat recommends updating to versions suggested by OpenShift Update Service only. For a minor version update, versions must be contiguous. Red Hat does not test updates to noncontiguous versions and cannot guarantee compatibility with earlier versions.</simpara>
</warning>
<section xml:id="understanding-update-channels_understanding-update-channels-releases">
<title>Update channels</title>
<section xml:id="fast-version-channel_understanding-update-channels-releases">
<title>fast-{product-version} channel</title>
<simpara>The <literal>fast-{product-version}</literal> channel is updated with new versions of {product-title} {product-version} as soon as Red Hat declares the version as a general availability (GA) release. As such, these releases are fully supported and purposed to be used in production environments.</simpara>
</section>
<section xml:id="stable-version-channel_understanding-update-channels-releases">
<title>stable-{product-version} channel</title>
<simpara>While the <literal>fast-{product-version}</literal> channel contains releases as soon as their errata are published, releases are added to the <literal>stable-{product-version}</literal> channel after a delay. During this delay, data is collected from multiple sources and analyzed for indications of product regressions. Once a significant number of data points have been collected, these releases are added to the stable channel.</simpara>
<note>
<simpara>Since the time required to obtain a significant number of data points varies based on many factors, Service LeveL Objective (SLO) is not offered for the delay duration between fast and stable channels. For more information, please see "Choosing the correct channel for your cluster"</simpara>
</note>
<simpara>Newly installed clusters default to using stable channels.</simpara>
</section>
<section xml:id="eus-4y-channel_understanding-update-channels-releases">
<title>eus-4.y channel</title>
<simpara>In addition to the stable channel, all even-numbered minor versions of {product-title} offer <link xl:href="https://access.redhat.com/support/policy/updates/openshift#ocp4_phases">Extended Update Support</link> (EUS). Releases promoted to the stable channel are also simultaneously promoted to the EUS channels. The primary purpose of the EUS channels is to serve as a convenience for clusters performing an EUS-to-EUS update.</simpara>
<note>
<simpara>Both standard and non-EUS subscribers can access all EUS repositories and necessary RPMs (<literal>rhel-*-eus-rpms</literal>) to be able to support critical purposes such as debugging and building drivers.</simpara>
</note>
</section>
<section xml:id="candidate-version-channel_understanding-update-channels-releases">
<title>candidate-{product-version} channel</title>
<simpara>The <literal>candidate-{product-version}</literal> channel offers unsupported early access to releases as soon as they are built. Releases present only in candidate channels
may not contain the full feature set of eventual GA releases or features may be removed prior to GA. Additionally, these releases have not been subject to full
Red Hat Quality Assurance and may not offer update paths to later GA releases. Given these caveats, the candidate channel is only suitable for testing purposes
where destroying and recreating a cluster is acceptable.</simpara>
</section>
<section xml:id="upgrade-version-paths_understanding-update-channels-releases">
<title>Update recommendations in the channel</title>
<simpara>{product-title} maintains an update recommendation service that knows your installed {product-title} version and the path to take within the channel to get you to the next release. Update paths are also limited to versions relevant to your currently selected channel and its promotion characteristics.</simpara>
<simpara>You can imagine seeing the following releases in your channel:</simpara>
<itemizedlist>
<listitem>
<simpara>{product-version}.0</simpara>
</listitem>
<listitem>
<simpara>{product-version}.1</simpara>
</listitem>
<listitem>
<simpara>{product-version}.3</simpara>
</listitem>
<listitem>
<simpara>{product-version}.4</simpara>
</listitem>
</itemizedlist>
<simpara>The service recommends only updates that have been tested and have no known serious regressions. For example, if your cluster is on {product-version}.1 and {product-title} suggests {product-version}.4, then it is recommended to update from {product-version}.1 to {product-version}.4.</simpara>
<important>
<simpara>Do not rely on consecutive patch numbers. In this example, {product-version}.2 is not and never was available in the channel, therefore updates to {product-version}.2 are not recommended or supported.</simpara>
</important>
</section>
<section xml:id="conditional-updates-overview_understanding-update-channels-releases">
<title>Update recommendations and Conditional Updates</title>
<simpara>Red Hat monitors newly released versions and update paths associated with those versions before and after they are added to supported channels.</simpara>
<simpara>If Red Hat removes update recommendations from any supported release, a superseding update recommendation will be provided to a future version that corrects the regression. There may however be a delay while the defect is corrected, tested, and promoted to your selected channel.</simpara>
<simpara>Beginning in {product-title} 4.10, when update risks are confirmed, they are declared as Conditional Update risks for the relevant updates. Each known risk may apply to all clusters or only clusters matching certain conditions. Some examples include having the <literal>Platform</literal> set to <literal>None</literal> or the CNI provider set to <literal>OpenShiftSDN</literal>. The Cluster Version Operator (CVO) continually evaluates known risks against the current cluster state. If no risks match, the update is recommended. If the risk matches, those updates are supported but not recommended, and a reference link is provided. The reference link helps the cluster admin decide if they would like to accept the risk and update anyway.</simpara>
<simpara>When Red Hat chooses to declare Conditional Update risks, that action is taken in all relevant channels simultaneously. Declaration of a Conditional Update risk may happen either before or after the update has been promoted to supported channels.</simpara>
</section>
<section xml:id="fast-stable-channel-strategies_understanding-update-channels-releases">
<title>Choosing the correct channel for your cluster</title>
<simpara>Choosing the appropriate channel involves two decisions.</simpara>
<simpara>First, select the minor version you want for your cluster update. Selecting a channel which matches your current version ensures that you only apply z-stream updates and do not receive feature updates. Selecting an available channel which has a version greater than your current version will ensure that after one or more updates your cluster will have updated to that version. Your cluster will only be offered channels which match its current version, the next version, or the next EUS version.</simpara>
<note>
<simpara>Due to the complexity involved in planning updates between versions many minors apart, channels that assist in planning updates beyond a single EUS-to-EUS update are not offered.</simpara>
</note>
<simpara>Second, you should choose your desired rollout strategy. You may choose to update as soon as Red Hat declares a release GA by selecting from fast channels or you may want to wait for Red Hat to promote releases to the stable channel. Update recommendations offered in the <literal>fast-{product-version}</literal> and <literal>stable-{product-version}</literal> are both fully supported and benefit equally from ongoing data analysis. The promotion delay before promoting a release to the stable channel represents the only difference between the two channels. Updates to the latest z-streams are generally promoted to the stable channel within a week or two, however the delay when initially rolling out updates to the latest minor is much longer, generally 45-90 days. Please consider the promotion delay when choosing your desired channel, as waiting for promotion to the stable channel may affect your scheduling plans.</simpara>
<simpara>Additionally, there are several factors which may lead an organization to move clusters to the fast channel either permanently or temporarily including:</simpara>
<itemizedlist>
<listitem>
<simpara>The desire to apply a specific fix known to affect your environment without delay.</simpara>
</listitem>
<listitem>
<simpara>Application of CVE fixes without delay. CVE fixes may introduce regressions, so promotion delays still apply to z-streams with CVE fixes.</simpara>
</listitem>
<listitem>
<simpara>Internal testing processes. If it takes your organization several weeks to qualify releases it is best test concurrently with our promotion process rather than waiting. This also assures that any telemetry signal provided to Red Hat is a factored into our rollout, so issues relevant to you can be fixed faster.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="restricted-network-clusters_understanding-update-channels-releases">
<title>Restricted network clusters</title>
<simpara>If you manage the container images for your {product-title} clusters yourself, you must consult the Red Hat errata that is associated with product releases and note any comments that impact updates. During an update, the user interface might warn you about switching between these versions, so you must ensure that you selected an appropriate version before you bypass those warnings.</simpara>
</section>
<section xml:id="switching-between-channels_understanding-update-channels-releases">
<title>Switching between channels</title>
<simpara>A channel can be switched from the web console or through the <literal>adm upgrade channel</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade channel &lt;channel&gt;</programlisting>
<simpara>The web console will display an alert if you switch to a channel that does not include the current release. The web console does not recommend any updates while on a channel without the current release. You can return to the original channel at any point, however.</simpara>
<simpara>Changing your channel might impact the supportability of your cluster. The following conditions might apply:</simpara>
<itemizedlist>
<listitem>
<simpara>Your cluster is still supported if you change from the <literal>stable-{product-version}</literal> channel to the <literal>fast-{product-version}</literal> channel.</simpara>
</listitem>
<listitem>
<simpara>You can switch to the <literal>candidate-{product-version}</literal> channel at any time, but some releases for this channel might be unsupported.</simpara>
</listitem>
<listitem>
<simpara>You can switch from the <literal>candidate-{product-version}</literal> channel to the <literal>fast-{product-version}</literal> channel if your current release is a general availability release.</simpara>
</listitem>
<listitem>
<simpara>You can always switch from the <literal>fast-{product-version}</literal> channel to the <literal>stable-{product-version}</literal> channel. There is a possible delay of up to a day for the release to be promoted to <literal>stable-{product-version}</literal> if the current release was recently promoted.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-cli.xml#update-conditional-upgrade-pathupdating-cluster-cli">Updating along a conditional upgrade path</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#fast-stable-channel-strategies_understanding-update-channels-releases">Choosing the correct channel for your cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="understanding-openshift-update-duration">
<title>Understanding {product-title} update duration</title>

<simpara>{product-title} update duration varies based on the deployment topology. This page helps you understand the factors that affect update duration and estimate how long the cluster update takes in your environment.</simpara>
<section xml:id="factors-affecting-update-duration_openshift-update-duration">
<title>Factors affecting update duration</title>
<simpara>The following factors can affect your cluster update duration:</simpara>
<itemizedlist>
<listitem>
<simpara>The reboot of compute nodes to the new machine configuration by Machine Config Operator (MCO)</simpara>
<itemizedlist>
<listitem>
<simpara>The value of <literal>MaxUnavailable</literal> in the machine config pool</simpara>
</listitem>
<listitem>
<simpara>The minimum number or percentages of replicas set in pod disruption budget (PDB)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The number of nodes in the cluster</simpara>
</listitem>
<listitem>
<simpara>The health of the cluster nodes</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cluster-update-phases">
<title>Cluster update phases</title>
<simpara>In {product-title}, the cluster update happens in two phases:</simpara>
<itemizedlist>
<listitem>
<simpara>Cluster Version Operator (CVO) target update payload deployment</simpara>
</listitem>
<listitem>
<simpara>Machine Config Operator (MCO) node updates</simpara>
</listitem>
</itemizedlist>
<section xml:id="cluster-version-operator_openshift-update-duration">
<title>Cluster Version Operator target update payload deployment</title>
<simpara>The Cluster Version Operator (CVO) retrieves the target update release image and applies to the cluster. All components which run as pods are updated during this phase, whereas the host components are updated by the Machine Config Operator (MCO). This process might take 60 to 120 minutes.</simpara>
<note>
<simpara>The CVO phase of the update does not restart the nodes.</simpara>
</note>
</section>
<section xml:id="machine-config-operator-node-updates_openshift-update-duration">
<title>Machine Config Operator node updates</title>
<simpara>The Machine Config Operator (MCO) applies a new machine configuration to each control plane and compute node. During this process, the MCO performs the following sequential actions on each node of the cluster:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Cordon and drain all the nodes</simpara>
</listitem>
<listitem>
<simpara>Update the operating system (OS)</simpara>
</listitem>
<listitem>
<simpara>Reboot the nodes</simpara>
</listitem>
<listitem>
<simpara>Uncordon all nodes and schedule workloads on the node</simpara>
</listitem>
</orderedlist>
<note>
<simpara>When a node is cordoned, workloads cannot be scheduled to it.</simpara>
</note>
<simpara>The time to complete this process depends on several factors including the node and infrastructure configuration. This process might take 5 or more minutes to complete per node.</simpara>
<simpara>In addition to MCO, you should consider the impact of the following parameters:</simpara>
<itemizedlist>
<listitem>
<simpara>The control plane node update duration is predictable and oftentimes shorter than compute nodes, because the control plane workloads are tuned for graceful updates and quick drains.</simpara>
</listitem>
<listitem>
<simpara>You can update the compute nodes in parallel by setting the <literal>maxUnavailable</literal> field to greater than <literal>1</literal> in the Machine Config Pool (MCP). The MCO cordons the number of nodes specified in <literal>maxUnavailable</literal> and marks them unavailable for update.</simpara>
</listitem>
<listitem>
<simpara>When you increase <literal>maxUnavailable</literal> on the MCP, it can help the pool to update more quickly. However, if <literal>maxUnavailable</literal> is set too high, and several nodes are cordoned simultaneously, the pod disruption budget (PDB) guarded workloads could fail to drain because a schedulable node cannot be found to run the replicas. If you increase <literal>maxUnavailable</literal> for the MCP, ensure that you still have sufficient schedulable nodes to allow PDB guarded workloads to drain.</simpara>
</listitem>
<listitem>
<simpara>Before you begin the update, you must ensure that all the nodes are available. Any unavailable nodes can significantly impact the update duration because the node unavailability affects the <literal>maxUnavailable</literal> and pod disruption budgets.</simpara>
<simpara>To check the status of nodes from the terminal, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node</programlisting>
<formalpara>
<title>Example Output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                        STATUS                      ROLES   AGE     VERSION
ip-10-0-137-31.us-east-2.compute.internal   Ready,SchedulingDisabled    worker  12d     v1.23.5+3afdacb
ip-10-0-151-208.us-east-2.compute.internal  Ready                       master  12d     v1.23.5+3afdacb
ip-10-0-176-138.us-east-2.compute.internal  Ready                       master  12d     v1.23.5+3afdacb
ip-10-0-183-194.us-east-2.compute.internal  Ready                       worker  12d     v1.23.5+3afdacb
ip-10-0-204-102.us-east-2.compute.internal  Ready                       master  12d     v1.23.5+3afdacb
ip-10-0-207-224.us-east-2.compute.internal  Ready                       worker  12d     v1.23.5+3afdacb</programlisting>
</para>
</formalpara>
<simpara>If the status of the node is <literal>NotReady</literal> or <literal>SchedulingDisabled</literal>, then the node is not available and this impacts the update duration.</simpara>
<simpara>You can check the status of nodes from the <emphasis role="strong">Administrator</emphasis> perspective in the web console by expanding <emphasis role="strong">Compute</emphasis> → <emphasis role="strong">Node</emphasis>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../post_installation_configuration/machine-configuration-tasks.xml#machine-config-overview-post-install-machine-configuration-tasks">Machine config overview</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../nodes/pods/nodes-pods-configuring.xml#nodes-pods-configuring-pod-distruption-about_nodes-pods-configuring">Pod disruption budget</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-duration-example_openshift-update-duration">
<title>Example update duration of cluster Operators</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/update-duration.png"/>
</imageobject>
<textobject><phrase>A diagram displaying the periods during which cluster Operators update themselves during an OCP update</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The previous diagram shows an example of the time that cluster Operators might take to update to their new versions.
The example is based on a three-node AWS OVN cluster, which has a healthy compute <literal>MachineConfigPool</literal> and no workloads that take long to drain, updating from 4.13 to 4.14.</simpara>
<note>
<itemizedlist>
<listitem>
<simpara>The specific update duration of a cluster and its Operators can vary based on several cluster characteristics, such as the target version, the amount of nodes, and the types of workloads scheduled to the nodes.</simpara>
</listitem>
<listitem>
<simpara>Some Operators, such as the Cluster Version Operator, update themselves in a short amount of time.
These Operators have either been omitted from the diagram or are included in the broader group of Operators labeled "Other Operators in parallel".</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>Each cluster Operator has characteristics that affect the time it takes to update itself.
For instance, the Kube API Server Operator in this example took more than eleven minutes to update because <literal>kube-apiserver</literal> provides graceful termination support, meaning that existing, in-flight requests are allowed to complete gracefully.
This might result in a longer shutdown of the <literal>kube-apiserver</literal>.
In the case of this Operator, update speed is sacrificed to help prevent and limit disruptions to cluster functionality during an update.</simpara>
<simpara>Another characteristic that affects the update duration of an Operator is whether the Operator utilizes DaemonSets.
The Network and DNS Operators utilize full-cluster DaemonSets, which can take time to roll out their version changes, and this is one of several reasons why these Operators might take longer to update themselves.</simpara>
<simpara>The update duration for some Operators is heavily dependent on characteristics of the cluster itself. For instance, the Machine Config Operator update applies machine configuration changes to each node in the cluster. A cluster with many nodes has a longer update duration for the Machine Config Operator compared to a cluster with fewer nodes.</simpara>
<note>
<simpara>Each cluster Operator is assigned a stage during which it can be updated.
Operators within the same stage can update simultaneously, and Operators in a given stage cannot begin updating until all previous stages have been completed.
For more information, see "Understanding how manifests are applied during an update" in the "Additional resources" section.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/intro-to-updates.xml#understanding-openshift-updates">Introduction to OpenShift updates</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/how-updates-work.xml#update-manifest-application_how-updates-work">Understanding how manifests are applied during an update</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="estimating-cluster-update-time_openshift-update-duration">
<title>Estimating cluster update time</title>
<simpara>Historical update duration of similar clusters provides you the best estimate for the future cluster updates. However, if the historical data is not available, you can use the following convention to estimate your cluster update time:</simpara>
<screen>Cluster update time = CVO target update payload deployment time + (# node update iterations x MCO node update time)</screen>
<simpara>A node update iteration consists of one or more nodes updated in parallel. The control plane nodes are always updated in parallel with the compute nodes. In addition, one or more compute nodes can be updated in parallel based on the <literal>maxUnavailable</literal> value.</simpara>
<simpara>For example, to estimate the update time, consider an {product-title} cluster with three control plane nodes and six compute nodes and each host takes about 5 minutes to reboot.</simpara>
<note>
<simpara>The time it takes to reboot a particular node varies significantly. In cloud instances, the reboot might take about 1 to 2 minutes, whereas in physical bare metal hosts the reboot might take more than 15 minutes.</simpara>
</note>
<formalpara>
<title>Scenario-1</title>
<para>When you set <literal>maxUnavailable</literal> to <literal>1</literal> for both the control plane and compute nodes Machine Config Pool (MCP), then all the six compute nodes will update one after another in each iteration:</para>
</formalpara>
<screen>Cluster update time = 60 + (6 x 5) = 90 minutes</screen>
<formalpara>
<title>Scenario-2</title>
<para>When you set <literal>maxUnavailable</literal> to <literal>2</literal> for the compute node MCP, then two compute nodes will update in parallel in each iteration. Therefore it takes total three iterations to update all the nodes.</para>
</formalpara>
<screen>Cluster update time = 60 + (3 x 5) = 75 minutes</screen>
<important>
<simpara>The default setting for <literal>maxUnavailable</literal> is <literal>1</literal> for all the MCPs in {product-title}. It is recommended that you do not change the <literal>maxUnavailable</literal> in the control plane MCP.</simpara>
</important>
</section>
<section xml:id="redhat-enterprise-linux-nodes_openshift-update-duration">
<title>Red Hat Enterprise Linux (RHEL) compute nodes</title>
<simpara>Red Hat Enterprise Linux (RHEL) compute nodes require an additional usage of <literal>openshift-ansible</literal> to update node binary components. The actual time spent updating RHEL compute nodes should not be significantly different from Red Hat Enterprise Linux CoreOS (RHCOS) compute nodes.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-rhel-compute.xml#updating-cluster-rhel-compute">Updating RHEL compute machines</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="additional-resources_update-duration" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../architecture/architecture.xml#architecture">OpenShift Container Platform architecture</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/intro-to-updates.xml#understanding-openshift-updates">OpenShift Container Platform updates</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="_preparing_to_update_a_cluster">
<title>Preparing to update a cluster</title>
<section xml:id="updating-cluster-prepare">
<title>Preparing to update to {product-title} 4.15</title>

<simpara>Learn more about administrative tasks that cluster admins must perform to successfully initialize an update, as well as optional guidelines for ensuring a successful update.</simpara>
<section xml:id="kube-api-removals_updating-cluster-prepare">
<title>Kubernetes API removals</title>
<simpara>There are no Kubernetes API removals in {product-title} 4.15.</simpara>
</section>
<section xml:id="update-preparing-conditional_updating-cluster-prepare">
<title>Assessing the risk of conditional updates</title>
<simpara>A <emphasis>conditional update</emphasis> is an update target that is available but not recommended due to a known risk that applies to your cluster.
The Cluster Version Operator (CVO) periodically queries the OpenShift Update Service (OSUS) for the most recent data about update recommendations, and some potential update targets might have risks associated with them.</simpara>
<simpara>The CVO evaluates the conditional risks, and if the risks are not applicable to the cluster, then the target version is available as a recommended update path for the cluster.
If the risk is determined to be applicable, or if for some reason CVO cannot evaluate the risk, then the update target is available to the cluster as a conditional update.</simpara>
<simpara>When you encounter a conditional update while you are trying to update to a target version, you must assess the risk of updating your cluster to that version.
Generally, if you do not have a specific need to update to that target version, it is best to wait for a recommended update path from Red Hat.</simpara>
<simpara>However, if you have a strong reason to update to that version, for example, if you need to fix an important CVE, then the benefit of fixing the CVE might outweigh the risk of the update being problematic for your cluster.
You can complete the following tasks to determine whether you agree with the Red Hat assessment of the update risk:</simpara>
<itemizedlist>
<listitem>
<simpara>Complete extensive testing in a non-production environment to the extent that you are comfortable completing the update in your production environment.</simpara>
</listitem>
<listitem>
<simpara>Follow the links provided in the conditional update description, investigate the bug, and determine if it is likely to cause issues for your cluster. If you need help understanding the risk, contact Red Hat Support.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/how-updates-work.xml#update-evaluate-availability_how-updates-work">Evaluation of update availability</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-best-practices_updating-cluster-prepare">
<title>Best practices for cluster updates</title>
<simpara>{product-title} provides a robust update experience that minimizes workload disruptions during an update.
Updates will not begin unless the cluster is in an upgradeable state at the time of the update request.</simpara>
<simpara>This design enforces some key conditions before initiating an update, but there are a number of actions you can take to increase your chances of a successful cluster update.</simpara>
<section xml:id="recommended-versions_updating-cluster-prepare">
<title>Choose versions recommended by the OpenShift Update Service</title>
<simpara>The OpenShift Update Service (OSUS) provides update recommendations based on cluster characteristics such as the cluster&#8217;s subscribed channel.
The Cluster Version Operator saves these recommendations as either recommended or conditional updates.
While it is possible to attempt an update to a version that is not recommended by OSUS, following a recommended update path protects users from encountering known issues or unintended consequences on the cluster.</simpara>
<simpara>Choose only update targets that are recommended by OSUS to ensure a successful update.</simpara>
</section>
<section xml:id="critical-alerts_updating-cluster-prepare">
<title>Address all critical alerts on the cluster</title>
<simpara>Critical alerts must always be addressed as soon as possible, but it is especially important to address these alerts and resolve any problems before initiating a cluster update.
Failing to address critical alerts before beginning an update can cause problematic conditions for the cluster.</simpara>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Observe</emphasis> &#8594; <emphasis role="strong">Alerting</emphasis> to find critical alerts.</simpara>
</section>
<section xml:id="cluster-upgradeable_updating-cluster-prepare">
<title>Ensure that the cluster is in an Upgradable state</title>
<simpara>When one or more Operators have not reported their <literal>Upgradeable</literal> condition as <literal>True</literal> for more than an hour, the <literal>ClusterNotUpgradeable</literal> warning alert is triggered in the cluster.
In most cases this alert does not block patch updates, but you cannot perform a minor version update until you resolve this alert and all Operators report <literal>Upgradeable</literal> as <literal>True</literal>.</simpara>
<simpara>For more information about the <literal>Upgradeable</literal> condition, see "Understanding cluster Operator condition types" in the additional resources section.</simpara>
</section>
<section xml:id="nodes-ready_updating-cluster-prepare">
<title>Ensure that enough spare nodes are available</title>
<simpara>A cluster should not be running with little to no spare node capacity, especially when initiating a cluster update.
Nodes that are not running and available may limit a cluster&#8217;s ability to perform an update with minimal disruption to cluster workloads.</simpara>
<simpara>Depending on the configured value of the cluster&#8217;s <literal>maxUnavailable</literal> spec, the cluster might not be able to apply machine configuration changes to nodes if there is an unavailable node.
Additionally, if compute nodes do not have enough spare capacity, workloads might not be able to temporarily shift to another node while the first node is taken offline for an update.</simpara>
<simpara>Make sure that you have enough available nodes in each worker pool, as well as enough spare capacity on your compute nodes, to increase the chance of successful node updates.</simpara>
</section>
<section xml:id="pod-disruption-budget_updating-cluster-prepare">
<title>Ensure that the cluster&#8217;s PodDisruptionBudget is properly configured</title>
<simpara>You can use the <literal>PodDisruptionBudget</literal> object to define the minimum number or percentage of pod replicas that must be available at any given time.
This configuration protects workloads from disruptions during maintenance tasks such as cluster updates.</simpara>
<simpara>However, it is possible to configure the <literal>PodDisruptionBudget</literal> for a given topology in a way that prevents nodes from being drained and updated during a cluster update.</simpara>
<simpara>When planning a cluster update, check the configuration of the <literal>PodDisruptionBudget</literal> object for the following factors:</simpara>
<itemizedlist>
<listitem>
<simpara>For highly available workloads, make sure there are replicas that can be temporarily taken offline without being prohibited by the <literal>PodDisruptionBudget</literal>.</simpara>
</listitem>
<listitem>
<simpara>For workloads that aren&#8217;t highly available, make sure they are either not protected by a <literal>PodDisruptionBudget</literal> or have some alternative mechanism for draining these workloads eventually, such as periodic restart or guaranteed eventual termination.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/intro-to-updates.xml#understanding_clusteroperator_conditiontypes_understanding-openshift-updates">Understanding cluster Operator condition types</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="preparing-manual-creds-update">
<title>Preparing to update a cluster with manually maintained credentials</title>

<simpara>The Cloud Credential Operator (CCO) <literal>Upgradable</literal> status for a cluster with manually maintained credentials is <literal>False</literal> by default.</simpara>
<itemizedlist>
<listitem>
<simpara>For minor releases, for example, from 4.12 to 4.13, this status prevents you from updating until you have addressed any updated permissions and annotated the <literal>CloudCredential</literal> resource to indicate that the permissions are updated as needed for the next version. This annotation changes the <literal>Upgradable</literal> status to <literal>True</literal>.</simpara>
</listitem>
<listitem>
<simpara>For z-stream releases, for example, from 4.13.0 to 4.13.1, no permissions are added or changed, so the update is not blocked.</simpara>
</listitem>
</itemizedlist>
<simpara>Before updating a cluster with manually maintained credentials, you must accommodate any new or changed credentials in the release image for the version of {product-title} you are updating to.</simpara>
<section xml:id="about-manually-maintained-credentials-upgrade_preparing-manual-creds-update">
<title>Update requirements for clusters with manually maintained credentials</title>
<simpara>Before you update a cluster that uses manually maintained credentials with the Cloud Credential Operator (CCO), you must update the cloud provider resources for the new release.</simpara>
<simpara>If the cloud credential management for your cluster was configured using the CCO utility (<literal>ccoctl</literal>), use the <literal>ccoctl</literal> utility to update the resources. Clusters that were configured to use manual mode without the <literal>ccoctl</literal> utility require manual updates for the resources.</simpara>
<simpara>After updating the cloud provider resources, you must update the <literal>upgradeable-to</literal> annotation for the cluster to indicate that it is ready to update.</simpara>
<note>
<simpara>The process to update the cloud provider resources and the <literal>upgradeable-to</literal> annotation can only be completed by using command line tools.</simpara>
</note>
<section xml:id="cco-platform-options_preparing-manual-creds-update">
<title>Cloud credential configuration options and update requirements by platform type</title>
<simpara>Some platforms only support using the CCO in one mode. For clusters that are installed on those platforms, the platform type determines the credentials update requirements.</simpara>
<simpara>For platforms that support using the CCO in multiple modes, you must determine which mode the cluster is configured to use and take the required actions for that configuration.</simpara>
<figure>
<title>Credentials update requirements by platform type</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/334_OpenShift_cluster_updating_and_CCO_workflows_0523_4.11_B.png"/>
</imageobject>
<textobject><phrase>Decision tree showing the possible update paths for your cluster depending on the configured CCO credentials mode.</phrase></textobject>
</mediaobject>
</figure>
<variablelist>
<varlistentry>
<term>Red Hat OpenStack Platform (RHOSP) and VMware vSphere</term>
<listitem>
<simpara>These platforms do not support using the CCO in manual mode. Clusters on these platforms handle changes in cloud provider resources automatically and do not require an update to the <literal>upgradeable-to</literal> annotation.</simpara>
<simpara>Administrators of clusters on these platforms should skip the manually maintained credentials section of the update process.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Alibaba Cloud, IBM Cloud, and Nutanix</term>
<listitem>
<simpara>Clusters installed on these platforms are configured using the <literal>ccoctl</literal> utility.</simpara>
<simpara>Administrators of clusters on these platforms must take the following actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Configure the <literal>ccoctl</literal> utility for the new release and use it to update the cloud provider resources.</simpara>
</listitem>
<listitem>
<simpara>Indicate that the cluster is ready to update with the <literal>upgradeable-to</literal> annotation.</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Microsoft Azure Stack Hub</term>
<listitem>
<simpara>These clusters use manual mode with long-term credentials and do not use the <literal>ccoctl</literal> utility.</simpara>
<simpara>Administrators of clusters on these platforms must take the following actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Manually update the cloud provider resources for the new release.</simpara>
</listitem>
<listitem>
<simpara>Indicate that the cluster is ready to update with the <literal>upgradeable-to</literal> annotation.</simpara>
</listitem>
</orderedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Amazon Web Services (AWS), global Microsoft Azure, and Google Cloud Platform (GCP)</term>
<listitem>
<simpara>Clusters installed on these platforms support multiple CCO modes.</simpara>
<simpara>The required update process depends on the mode that the cluster is configured to use. If you are not sure what mode the CCO is configured to use on your cluster, you can use the web console or the CLI to determine this information.</simpara>
</listitem>
</varlistentry>
</variablelist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-determine-mode-gui_preparing-manual-creds-update">Determining the Cloud Credential Operator mode by using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-determine-mode-cli_preparing-manual-creds-update">Determining the Cloud Credential Operator mode by using the CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-ccoctl-upgrading-extracting_preparing-manual-creds-update">Extracting and preparing credentials request resources</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../authentication/managing_cloud_provider_credentials/about-cloud-credential-operator.xml#about-cloud-credential-operator">About the Cloud Credential Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cco-determine-mode-gui_preparing-manual-creds-update">
<title>Determining the Cloud Credential Operator mode by using the web console</title>
<simpara>You can determine what mode the Cloud Credential Operator (CCO) is configured to use by using the web console.</simpara>
<note>
<simpara>Only Amazon Web Services (AWS), global Microsoft Azure, and Google Cloud Platform (GCP) clusters support multiple CCO modes.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an {product-title} account with cluster administrator permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Cluster Settings</emphasis> page, select the <emphasis role="strong">Configuration</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Configuration resource</emphasis>, select <emphasis role="strong">CloudCredential</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">CloudCredential details</emphasis> page, select the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>In the YAML block, check the value of <literal>spec.credentialsMode</literal>. The following values are possible, though not all are supported on all platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>''</literal>: The CCO is operating in the default mode. In this configuration, the CCO operates in mint or passthrough mode, depending on the credentials provided during installation.</simpara>
</listitem>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Manual</literal>: The CCO is operating in manual mode.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>To determine the specific configuration of an AWS, GCP, or global Microsoft Azure cluster that has a <literal>spec.credentialsMode</literal> of <literal>''</literal>, <literal>Mint</literal>, or <literal>Manual</literal>, you must investigate further.</simpara>
<simpara>AWS and GCP clusters support using mint mode with the root secret deleted.
If the cluster is specifically configured to use mint mode or uses mint mode by default, you must determine if the root secret is present on the cluster before updating.</simpara>
<simpara>An AWS, GCP, or global Microsoft Azure cluster that uses manual mode might be configured to create and manage cloud credentials from outside of the cluster with AWS STS, GCP Workload Identity, or Azure AD Workload Identity. You can determine whether your cluster uses this strategy by examining the cluster <literal>Authentication</literal> object.</simpara>
</important>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use mint mode only: To determine whether the cluster is operating without the root secret, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis> and look for the root secret for your cloud provider.</simpara>
<note>
<simpara>Ensure that the <emphasis role="strong">Project</emphasis> dropdown is set to <emphasis role="strong">All Projects</emphasis>.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Secret name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AWS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-creds</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gcp-credentials</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara>If you see one of these values, your cluster is using mint or passthrough mode with the root secret present.</simpara>
</listitem>
<listitem>
<simpara>If you do not see these values, your cluster is using the CCO in mint mode with the root secret removed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>AWS, GCP, or global Microsoft Azure clusters that use manual mode only: To determine whether the cluster is configured to create and manage cloud credentials from outside of the cluster, you must check the cluster <literal>Authentication</literal> object YAML values.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Cluster Settings</emphasis> page, select the <emphasis role="strong">Configuration</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Configuration resource</emphasis>, select <emphasis role="strong">Authentication</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Authentication details</emphasis> page, select the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>In the YAML block, check the value of the <literal>.spec.serviceAccountIssuer</literal> parameter.</simpara>
<itemizedlist>
<listitem>
<simpara>A value that contains a URL that is associated with your cloud provider indicates that the CCO is using manual mode with short-term credentials for components. These clusters are configured using the <literal>ccoctl</literal> utility to create and manage cloud credentials from outside of the cluster.</simpara>
</listitem>
<listitem>
<simpara>An empty value (<literal>''</literal>) indicates that the cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>If you are updating a cluster that has the CCO operating in mint or passthrough mode and the root secret is present, you do not need to update any cloud provider resources and can continue to the next part of the update process.</simpara>
</listitem>
<listitem>
<simpara>If your cluster is using the CCO in mint mode with the root secret removed, you must reinstate the credential secret with the administrator-level credential before continuing to the next part of the update process.</simpara>
</listitem>
<listitem>
<simpara>If your cluster was configured using the CCO utility (<literal>ccoctl</literal>), you must take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Configure the <literal>ccoctl</literal> utility for the new release and use it to update the cloud provider resources.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to update.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If your cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility, you must take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Manually update the cloud provider resources for the new release.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to update.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-ccoctl-upgrading-extracting_preparing-manual-creds-update">Extracting and preparing credentials request resources</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cco-determine-mode-cli_preparing-manual-creds-update">
<title>Determining the Cloud Credential Operator mode by using the CLI</title>
<simpara>You can determine what mode the Cloud Credential Operator (CCO) is configured to use by using the CLI.</simpara>
<note>
<simpara>Only Amazon Web Services (AWS), global Microsoft Azure, and Google Cloud Platform (GCP) clusters support multiple CCO modes.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an {product-title} account with cluster administrator permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <literal>oc</literal> on the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>To determine the mode that the CCO is configured to use, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cloudcredentials cluster \
  -o=jsonpath={.spec.credentialsMode}</programlisting>
<simpara>The following output values are possible, though not all are supported on all platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>''</literal>: The CCO is operating in the default mode. In this configuration, the CCO operates in mint or passthrough mode, depending on the credentials provided during installation.</simpara>
</listitem>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Manual</literal>: The CCO is operating in manual mode.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>To determine the specific configuration of an AWS, GCP, or global Microsoft Azure cluster that has a <literal>spec.credentialsMode</literal> of <literal>''</literal>, <literal>Mint</literal>, or <literal>Manual</literal>, you must investigate further.</simpara>
<simpara>AWS and GCP clusters support using mint mode with the root secret deleted.
If the cluster is specifically configured to use mint mode or uses mint mode by default, you must determine if the root secret is present on the cluster before updating.</simpara>
<simpara>An AWS, GCP, or global Microsoft Azure cluster that uses manual mode might be configured to create and manage cloud credentials from outside of the cluster with AWS STS, GCP Workload Identity, or Azure AD Workload Identity. You can determine whether your cluster uses this strategy by examining the cluster <literal>Authentication</literal> object.</simpara>
</important>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use mint mode only: To determine whether the cluster is operating without the root secret, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;secret_name&gt; \
  -n=kube-system</programlisting>
<simpara>where <literal>&lt;secret_name&gt;</literal> is <literal>aws-creds</literal> for AWS or <literal>gcp-credentials</literal> for GCP.</simpara>
<simpara>If the root secret is present, the output of this command returns information about the secret. An error indicates that the root secret is not present on the cluster.</simpara>
</listitem>
<listitem>
<simpara>AWS, GCP, or global Microsoft Azure clusters that use manual mode only: To determine whether the cluster is configured to create and manage cloud credentials from outside of the cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get authentication cluster \
  -o jsonpath \
  --template='{ .spec.serviceAccountIssuer }'</programlisting>
<simpara>This command displays the value of the <literal>.spec.serviceAccountIssuer</literal> parameter in the cluster <literal>Authentication</literal> object.</simpara>
<itemizedlist>
<listitem>
<simpara>An output of a URL that is associated with your cloud provider indicates that the CCO is using manual mode with short-term credentials for components. These clusters are configured using the <literal>ccoctl</literal> utility to create and manage cloud credentials from outside of the cluster.</simpara>
</listitem>
<listitem>
<simpara>An empty output indicates that the cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>If you are updating a cluster that has the CCO operating in mint or passthrough mode and the root secret is present, you do not need to update any cloud provider resources and can continue to the next part of the update process.</simpara>
</listitem>
<listitem>
<simpara>If your cluster is using the CCO in mint mode with the root secret removed, you must reinstate the credential secret with the administrator-level credential before continuing to the next part of the update process.</simpara>
</listitem>
<listitem>
<simpara>If your cluster was configured using the CCO utility (<literal>ccoctl</literal>), you must take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Configure the <literal>ccoctl</literal> utility for the new release and use it to update the cloud provider resources.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to update.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If your cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility, you must take the following actions:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
</listitem>
<listitem>
<simpara>Manually update the cloud provider resources for the new release.</simpara>
</listitem>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to update.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-ccoctl-upgrading-extracting_preparing-manual-creds-update">Extracting and preparing credentials request resources</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-ccoctl-upgrading-extracting_preparing-manual-creds-update">
<title>Extracting and preparing credentials request resources</title>
<simpara>Before updating a cluster that uses the Cloud Credential Operator (CCO) in manual mode, you must extract and prepare the <literal>CredentialsRequest</literal> custom resources (CRs) for the new release.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>) that matches the version for your updated version.</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster as user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Obtain the pull spec for the update that you want to apply by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<simpara>The output of this command includes pull specs for the available updates similar to the following:</simpara>
<formalpara>
<title>Partial example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">...
Recommended updates:

VERSION IMAGE
4.15.0  quay.io/openshift-release-dev/ocp-release@sha256:6a899c54dda6b844bb12a247e324a0f6cde367e880b73ba110c056df6d018032
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Set a <literal>$RELEASE_IMAGE</literal> variable with the release image that you want to use by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RELEASE_IMAGE=&lt;update_pull_spec&gt;</programlisting>
<simpara>where <literal>&lt;update_pull_spec&gt;</literal> is the pull spec for the release image that you want to use. For example:</simpara>
<programlisting language="text" linenumbering="unnumbered">quay.io/openshift-release-dev/ocp-release@sha256:6a899c54dda6b844bb12a247e324a0f6cde367e880b73ba110c056df6d018032</programlisting>
</listitem>
<listitem>
<simpara>Extract the list of <literal>CredentialsRequest</literal> custom resources (CRs) from the {product-title} release image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release extract \
  --from=$RELEASE_IMAGE \
  --credentials-requests \
  --included \<co xml:id="CO2-1"/>
  --to=&lt;path_to_directory_for_credentials_requests&gt; <co xml:id="CO2-2"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>The <literal>--included</literal> parameter includes only the manifests that your specific cluster configuration requires for the target release.</para>
</callout>
<callout arearefs="CO2-2">
<para>Specify the path to the directory where you want to store the <literal>CredentialsRequest</literal> objects. If the specified directory does not exist, this command creates it.</para>
</callout>
</calloutlist>
<simpara>This command creates a YAML file for each <literal>CredentialsRequest</literal> object.</simpara>
</listitem>
<listitem>
<simpara>For each <literal>CredentialsRequest</literal> CR in the release image, ensure that a namespace that matches the text in the <literal>spec.secretRef.namespace</literal> field exists in the cluster. This field is where the generated secrets that hold the credentials configuration are stored.</simpara>
<formalpara>
<title>Sample AWS <literal>CredentialsRequest</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: cloud-credential-operator-iam-ro
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - effect: Allow
      action:
      - iam:GetUser
      - iam:GetUserPolicy
      - iam:ListAccessKeys
      resource: "*"
  secretRef:
    name: cloud-credential-operator-iam-ro-creds
    namespace: openshift-cloud-credential-operator <co xml:id="CO3-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>This field indicates the namespace which must exist to hold the generated secret.</para>
</callout>
</calloutlist>
<simpara>The <literal>CredentialsRequest</literal> CRs for other platforms have a similar format with different platform-specific values.</simpara>
</listitem>
<listitem>
<simpara>For any <literal>CredentialsRequest</literal> CR for which the cluster does not already have a namespace with the name specified in <literal>spec.secretRef.namespace</literal>, create the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create namespace &lt;component_namespace&gt;</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>If the cloud credential management for your cluster was configured using the CCO utility (<literal>ccoctl</literal>), configure the <literal>ccoctl</literal> utility for a cluster update and use it to update your cloud provider resources.</simpara>
</listitem>
<listitem>
<simpara>If your cluster was not configured with the <literal>ccoctl</literal> utility, manually update your cloud provider resources.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-ccoctl-configuring_preparing-manual-creds-update">Configuring the Cloud Credential Operator utility for a cluster update</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#manually-maintained-credentials-upgrade_preparing-manual-creds-update">Manually updating cloud provider resources</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cco-ccoctl-configuring_preparing-manual-creds-update">
<title>Configuring the Cloud Credential Operator utility for a cluster update</title>
<simpara>To upgrade a cluster that uses the Cloud Credential Operator (CCO) in manual mode to create and manage cloud credentials from outside of the cluster, extract and prepare the CCO utility (<literal>ccoctl</literal>) binary.</simpara>
<note>
<simpara>The <literal>ccoctl</literal> utility is a Linux binary that must run in a Linux environment.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an {product-title} account with cluster administrator access.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<listitem>
<simpara>Your cluster was configured using the <literal>ccoctl</literal> utility to create and manage cloud credentials from outside of the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have extracted the <literal>CredentialsRequest</literal> custom resources (CRs) from the {product-title} release image and ensured that a namespace that matches the text in the <literal>spec.secretRef.namespace</literal> field exists in the cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Obtain the CCO container image from the {product-title} release image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ CCO_IMAGE=$(oc adm release info --image-for='cloud-credential-operator' $RELEASE_IMAGE -a ~/.pull-secret)</programlisting>
<note>
<simpara>Ensure that the architecture of the <literal>$RELEASE_IMAGE</literal> matches the architecture of the environment in which you will use the <literal>ccoctl</literal> tool.</simpara>
</note>
</listitem>
<listitem>
<simpara>Extract the <literal>ccoctl</literal> binary from the CCO container image within the {product-title} release image by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image extract $CCO_IMAGE --file="/usr/bin/ccoctl" -a ~/.pull-secret</programlisting>
</listitem>
<listitem>
<simpara>Change the permissions to make <literal>ccoctl</literal> executable by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod 775 ccoctl</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that <literal>ccoctl</literal> is ready to use, display the help file by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl --help</programlisting>
<formalpara>
<title>Output of <literal>ccoctl --help</literal></title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">OpenShift credentials provisioning tool

Usage:
  ccoctl [command]

Available Commands:
  alibabacloud Manage credentials objects for alibaba cloud
  aws          Manage credentials objects for AWS cloud
  azure        Manage credentials objects for Azure
  gcp          Manage credentials objects for Google cloud
  help         Help about any command
  ibmcloud     Manage credentials objects for IBM Cloud
  nutanix      Manage credentials objects for Nutanix

Flags:
  -h, --help   help for ccoctl

Use "ccoctl [command] --help" for more information about a command.</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cco-ccoctl-upgrading_preparing-manual-creds-update">
<title>Updating cloud provider resources with the Cloud Credential Operator utility</title>
<simpara>The process for upgrading an {product-title} cluster that was configured using the CCO utility (<literal>ccoctl</literal>) is similar to creating the cloud provider resources during installation.</simpara>
<note>
<simpara>On AWS clusters, some <literal>ccoctl</literal> commands make AWS API calls to create or modify AWS resources. You can use the <literal>--dry-run</literal> flag to avoid making API calls. Using this flag creates JSON files on the local file system instead. You can review and modify the JSON files and then apply them with the AWS CLI tool using the <literal>--cli-input-json</literal> parameters.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have extracted the <literal>CredentialsRequest</literal> custom resources (CRs) from the {product-title} release image and ensured that a namespace that matches the text in the <literal>spec.secretRef.namespace</literal> field exists in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You have extracted and configured the <literal>ccoctl</literal> binary from the release image.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>ccoctl</literal> tool to process all <literal>CredentialsRequest</literal> objects by running the command for your cloud provider. The following commands process <literal>CredentialsRequest</literal> objects:</simpara>
<example>
<title>Alibaba Cloud</title>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl alibabacloud create-ram-users \
  --name &lt;name&gt; \<co xml:id="CO4-1"/>
  --region=&lt;alibaba_region&gt; \<co xml:id="CO4-2"/>
  --credentials-requests-dir=&lt;path_to_credentials_requests_directory&gt; \<co xml:id="CO4-3"/>
  --output-dir=&lt;path_to_ccoctl_output_dir&gt; <co xml:id="CO4-4"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Specify the name used to tag any cloud resources that are created for tracking.</para>
</callout>
<callout arearefs="CO4-2">
<para>Specify the Alibaba Cloud region in which cloud resources will be created.</para>
</callout>
<callout arearefs="CO4-3">
<para>Specify the directory containing the files for the component <literal>CredentialsRequest</literal> objects.</para>
</callout>
<callout arearefs="CO4-4">
<para>Optional: Specify the directory in which you want the <literal>ccoctl</literal> utility to create objects. By default, the utility creates objects in the directory in which the commands are run.</para>
</callout>
</calloutlist>
<note>
<simpara>A RAM user can have up to two AccessKeys at the same time. If you run <literal>ccoctl alibabacloud create-ram-users</literal> more than twice, the previously generated manifests secret becomes stale and you must reapply the newly generated secrets.</simpara>
</note>
</example>
<example>
<title>Amazon Web Services (AWS)</title>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-all \<co xml:id="CO5-1"/>
  --name=&lt;name&gt; \<co xml:id="CO5-2"/>
  --region=&lt;aws_region&gt; \<co xml:id="CO5-3"/>
  --credentials-requests-dir=&lt;path_to_credentials_requests_directory&gt; \<co xml:id="CO5-4"/>
  --output-dir=&lt;path_to_ccoctl_output_dir&gt; \<co xml:id="CO5-5"/>
  --create-private-s3-bucket <co xml:id="CO5-6"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>To create the AWS resources individually, use the "Creating AWS resources individually" procedure in the "Installing a cluster on AWS with customizations" content. This option might be useful if you need to review the JSON files that the <literal>ccoctl</literal> tool creates before modifying AWS resources, or if the process the <literal>ccoctl</literal> tool uses to create AWS resources automatically does not meet the requirements of your organization.</para>
</callout>
<callout arearefs="CO5-2">
<para>Specify the name used to tag any cloud resources that are created for tracking.</para>
</callout>
<callout arearefs="CO5-3">
<para>Specify the AWS region in which cloud resources will be created.</para>
</callout>
<callout arearefs="CO5-4">
<para>Specify the directory containing the files for the component <literal>CredentialsRequest</literal> objects.</para>
</callout>
<callout arearefs="CO5-5">
<para>Optional: Specify the directory in which you want the <literal>ccoctl</literal> utility to create objects. By default, the utility creates objects in the directory in which the commands are run.</para>
</callout>
<callout arearefs="CO5-6">
<para>Optional: By default, the <literal>ccoctl</literal> utility stores the OpenID Connect (OIDC) configuration files in a public S3 bucket and uses the S3 URL as the public OIDC endpoint. To store the OIDC configuration in a private S3 bucket that is accessed by the IAM identity provider through a public CloudFront distribution URL instead, use the <literal>--create-private-s3-bucket</literal> parameter.</para>
</callout>
</calloutlist>
</example>
<example>
<title>Google Cloud Platform (GCP)</title>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl gcp create-all \
  --name=&lt;name&gt; \<co xml:id="CO6-1"/>
  --region=&lt;gcp_region&gt; \<co xml:id="CO6-2"/>
  --project=&lt;gcp_project_id&gt; \<co xml:id="CO6-3"/>
  --credentials-requests-dir=&lt;path_to_credentials_requests_directory&gt; \<co xml:id="CO6-4"/>
  --output-dir=&lt;path_to_ccoctl_output_dir&gt; <co xml:id="CO6-5"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>Specify the user-defined name for all created GCP resources used for tracking.</para>
</callout>
<callout arearefs="CO6-2">
<para>Specify the GCP region in which cloud resources will be created.</para>
</callout>
<callout arearefs="CO6-3">
<para>Specify the GCP project ID in which cloud resources will be created.</para>
</callout>
<callout arearefs="CO6-4">
<para>Specify the directory containing the files of <literal>CredentialsRequest</literal> manifests to create GCP service accounts.</para>
</callout>
<callout arearefs="CO6-5">
<para>Optional: Specify the directory in which you want the <literal>ccoctl</literal> utility to create objects. By default, the utility creates objects in the directory in which the commands are run.</para>
</callout>
</calloutlist>
</example>
<example>
<title>IBM Cloud</title>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl ibmcloud create-service-id \
  --credentials-requests-dir=&lt;path_to_credential_requests_directory&gt; \<co xml:id="CO7-1"/>
  --name=&lt;cluster_name&gt; \<co xml:id="CO7-2"/>
  --output-dir=&lt;installation_directory&gt; \<co xml:id="CO7-3"/>
  --resource-group-name=&lt;resource_group_name&gt; <co xml:id="CO7-4"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Specify the directory containing the files for the component <literal>CredentialsRequest</literal> objects.</para>
</callout>
<callout arearefs="CO7-2">
<para>Specify the name of the {product-title} cluster.</para>
</callout>
<callout arearefs="CO7-3">
<para>Optional: Specify the directory in which you want the <literal>ccoctl</literal> utility to create objects. By default, the utility creates objects in the directory in which the commands are run.</para>
</callout>
<callout arearefs="CO7-4">
<para>Optional: Specify the name of the resource group used for scoping the access policies.</para>
</callout>
</calloutlist>
</example>
<example>
<title>Nutanix</title>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl nutanix create-shared-secrets \
  --credentials-requests-dir=&lt;path_to_credentials_requests_directory&gt; \<co xml:id="CO8-1"/>
  --output-dir=&lt;ccoctl_output_dir&gt; \<co xml:id="CO8-2"/>
  --credentials-source-filepath=&lt;path_to_credentials_file&gt; <co xml:id="CO8-3"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Specify the path to the directory that contains the files for the component <literal>CredentialsRequests</literal> objects.</para>
</callout>
<callout arearefs="CO8-2">
<para>Optional: Specify the directory in which you want the <literal>ccoctl</literal> utility to create objects. By default, the utility creates objects in the directory in which the commands are run.</para>
</callout>
<callout arearefs="CO8-3">
<para>Optional: Specify the directory that contains the credentials data YAML file. By default, <literal>ccoctl</literal> expects this file to be in <literal>&lt;home_directory&gt;/.nutanix/credentials</literal>.</para>
</callout>
</calloutlist>
</example>
<simpara>For each <literal>CredentialsRequest</literal> object, <literal>ccoctl</literal> creates the required provider resources and a permissions policy as defined in each <literal>CredentialsRequest</literal> object from the {product-title} release image.</simpara>
</listitem>
<listitem>
<simpara>Apply the secrets to your cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls &lt;path_to_ccoctl_output_dir&gt;/manifests/*-credentials.yaml | xargs -I{} oc apply -f {}</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>You can verify that the required provider resources and permissions policies are created by querying the cloud provider. For more information, refer to your cloud provider documentation on listing roles or service accounts.</para>
</formalpara>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to upgrade.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-manual-upgrade-annotation_preparing-manual-creds-update">Indicating that the cluster is ready to upgrade</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="manually-maintained-credentials-upgrade_preparing-manual-creds-update">
<title>Manually updating cloud provider resources</title>
<simpara>Before upgrading a cluster with manually maintained credentials, you must create secrets for any new credentials for the release image that you are upgrading to. You must also review the required permissions for existing credentials and accommodate any new permissions requirements in the new release for those components.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have extracted the <literal>CredentialsRequest</literal> custom resources (CRs) from the {product-title} release image and ensured that a namespace that matches the text in the <literal>spec.secretRef.namespace</literal> field exists in the cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create YAML files with secrets for any <literal>CredentialsRequest</literal> custom resources that the new release image adds. The secrets must be stored using the namespace and secret name defined in the <literal>spec.secretRef</literal> for each <literal>CredentialsRequest</literal> object.</simpara>
<example>
<title>Sample AWS YAML files</title>
<formalpara>
<title>Sample AWS <literal>CredentialsRequest</literal> object with secrets</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: &lt;component_credentials_request&gt;
  namespace: openshift-cloud-credential-operator
  ...
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - effect: Allow
      action:
      - s3:CreateBucket
      - s3:DeleteBucket
      resource: "*"
      ...
  secretRef:
    name: &lt;component_secret&gt;
    namespace: &lt;component_namespace&gt;
  ...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample AWS <literal>Secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;component_secret&gt;
  namespace: &lt;component_namespace&gt;
data:
  aws_access_key_id: &lt;base64_encoded_aws_access_key_id&gt;
  aws_secret_access_key: &lt;base64_encoded_aws_secret_access_key&gt;</programlisting>
</para>
</formalpara>
</example>
<example>
<title>Sample Azure YAML files</title>
<note>
<simpara>Global Azure and Azure Stack Hub use the same <literal>CredentialsRequest</literal> object and secret formats.</simpara>
</note>
<formalpara>
<title>Sample Azure <literal>CredentialsRequest</literal> object with secrets</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: &lt;component_credentials_request&gt;
  namespace: openshift-cloud-credential-operator
  ...
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AzureProviderSpec
    roleBindings:
    - role: Contributor
      ...
  secretRef:
    name: &lt;component_secret&gt;
    namespace: &lt;component_namespace&gt;
  ...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample Azure <literal>Secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;component_secret&gt;
  namespace: &lt;component_namespace&gt;
data:
  azure_subscription_id: &lt;base64_encoded_azure_subscription_id&gt;
  azure_client_id: &lt;base64_encoded_azure_client_id&gt;
  azure_client_secret: &lt;base64_encoded_azure_client_secret&gt;
  azure_tenant_id: &lt;base64_encoded_azure_tenant_id&gt;
  azure_resource_prefix: &lt;base64_encoded_azure_resource_prefix&gt;
  azure_resourcegroup: &lt;base64_encoded_azure_resourcegroup&gt;
  azure_region: &lt;base64_encoded_azure_region&gt;</programlisting>
</para>
</formalpara>
</example>
<example>
<title>Sample GCP YAML files</title>
<formalpara>
<title>Sample GCP <literal>CredentialsRequest</literal> object with secrets</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: &lt;component_credentials_request&gt;
  namespace: openshift-cloud-credential-operator
  ...
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: GCPProviderSpec
      predefinedRoles:
      - roles/iam.securityReviewer
      - roles/iam.roleViewer
      skipServiceCheck: true
      ...
  secretRef:
    name: &lt;component_secret&gt;
    namespace: &lt;component_namespace&gt;
  ...</programlisting>
</para>
</formalpara>
<formalpara>
<title>Sample GCP <literal>Secret</literal> object</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;component_secret&gt;
  namespace: &lt;component_namespace&gt;
data:
  service_account.json: &lt;base64_encoded_gcp_service_account_file&gt;</programlisting>
</para>
</formalpara>
</example>
</listitem>
<listitem>
<simpara>If the <literal>CredentialsRequest</literal> custom resources for any existing credentials that are stored in secrets have changed permissions requirements, update the permissions as required.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Update the <literal>upgradeable-to</literal> annotation to indicate that the cluster is ready to upgrade.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">Manually creating long-term credentials for AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Manually creating long-term credentials for Azure</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_azure_stack_hub/installing-azure-stack-hub-default.xml#manually-create-iam_installing-azure-stack-hub-default">Manually creating long-term credentials for Azure Stack Hub</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">Manually creating long-term credentials for GCP</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#cco-manual-upgrade-annotation_preparing-manual-creds-update">Indicating that the cluster is ready to upgrade</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="cco-manual-upgrade-annotation_preparing-manual-creds-update">
<title>Indicating that the cluster is ready to upgrade</title>
<simpara>The Cloud Credential Operator (CCO) <literal>Upgradable</literal> status for a cluster with manually maintained credentials is <literal>False</literal> by default.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>For the release image that you are upgrading to, you have processed any new credentials manually or by using the Cloud Credential Operator utility (<literal>ccoctl</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <literal>oc</literal> on the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>CloudCredential</literal> resource to add an <literal>upgradeable-to</literal> annotation within the <literal>metadata</literal> field by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit cloudcredential cluster</programlisting>
<formalpara>
<title>Text to add</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
  metadata:
    annotations:
      cloudcredential.openshift.io/upgradeable-to: &lt;version_number&gt;
...</programlisting>
</para>
</formalpara>
<simpara>Where <literal>&lt;version_number&gt;</literal> is the version that you are upgrading to, in the format <literal>x.y.z</literal>. For example, use <literal>4.12.2</literal> for {product-title} 4.12.2.</simpara>
<simpara>It may take several minutes after adding the annotation for the upgradeable status to change.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To view the CCO status details, click <emphasis role="strong">cloud-credential</emphasis> in the <emphasis role="strong">Cluster Operators</emphasis> list.</simpara>
<itemizedlist>
<listitem>
<simpara>If the <emphasis role="strong">Upgradeable</emphasis> status in the <emphasis role="strong">Conditions</emphasis> section is <emphasis role="strong">False</emphasis>, verify that the <literal>upgradeable-to</literal> annotation is free of typographical errors.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>When the <emphasis role="strong">Upgradeable</emphasis> status in the <emphasis role="strong">Conditions</emphasis> section is <emphasis role="strong">True</emphasis>, begin the {product-title} upgrade.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="kmm-preflight-validation">
<title>Preflight validation for Kernel Module Management (KMM) Modules</title>

<simpara>Before performing an upgrade on the cluster with applied KMM modules, the administrator must verify that kernel modules installed using KMM are able to be installed on the nodes after the cluster upgrade and possible kernel upgrade. Preflight attempts to validate every <literal>Module</literal> loaded in the cluster, in parallel. Preflight does not wait for validation of one <literal>Module</literal> to complete before starting validation of another <literal>Module</literal>.</simpara>
<section xml:id="kmm-validation-kickoff_kmm-preflight-validation">
<title>Validation kickoff</title>
<simpara>Preflight validation is triggered by creating a <literal>PreflightValidationOCP</literal> resource in the cluster. This spec contains two fields:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">type PreflightValidationOCPSpec struct {
	// releaseImage describes the OCP release image that all Modules need to be checked against.
	// +kubebuilder:validation:Required
	ReleaseImage string `json:"releaseImage"` <co xml:id="CO9-1"/>
	// Boolean flag that determines whether images build during preflight must also
	// be pushed to a defined repository
	// +optional
	PushBuiltImage bool `json:"pushBuiltImage"` <co xml:id="CO9-2"/>
}</programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para><literal>ReleaseImage</literal> - Mandatory field that provides the name of the release image for the {product-title} version the cluster is upgraded to.</para>
</callout>
<callout arearefs="CO9-2">
<para><literal>PushBuiltImage</literal> - If <literal>true</literal>, then the images created during the Build and Sign validation are pushed to their repositories (<literal>false</literal> by default).</para>
</callout>
</calloutlist>
</section>
<section xml:id="kmm-validation-lifecycle_kmm-preflight-validation">
<title>Validation lifecycle</title>
<simpara>Preflight validation attempts to validate every module loaded in the cluster. Preflight will stop running validation on a <literal>Module</literal> resource after the validation is successful. In case module validation has failed, you can change the module definitions and Preflight will try to validate the module again in the next loop.</simpara>
<simpara>If you want to run Preflight validation for an additional kernel, then you should create another <literal>PreflightValidationOCP</literal> resource for that kernel. After all the modules have been validated, it is recommended to delete the <literal>PreflightValidationOCP</literal> resource.</simpara>
</section>
<section xml:id="kmm-validation-status_kmm-preflight-validation">
<title>Validation status</title>
<simpara>Preflight reports the status and progress of each module in the cluster that it attempts to
validate.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">type CRStatus struct {
	// Status of Module CR verification: true (verified), false (verification failed),
	// error (error during verification process), unknown (verification has not started yet)
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Enum=True;False
	VerificationStatus string `json:"verificationStatus"` <co xml:id="CO10-1"/>
	// StatusReason contains a string describing the status source.
	// +optional
	StatusReason string `json:"statusReason,omitempty"` <co xml:id="CO10-2"/>
	// Current stage of the verification process:
	// image (image existence verification), build(build process verification)
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Enum=Image;Build;Sign;Requeued;Done
	VerificationStage string `json:"verificationStage"` <co xml:id="CO10-3"/>
	// LastTransitionTime is the last time the CR status transitioned from one status to another.
	// This should be when the underlying status changed.  If that is not known, then using the time when the API field changed is acceptable.
	// +required
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Type=string
	// +kubebuilder:validation:Format=date-time
	LastTransitionTime metav1.Time `json:"lastTransitionTime" protobuf:"bytes,4,opt,name=lastTransitionTime"` <co xml:id="CO10-4"/>
}</programlisting>
<simpara>The following fields apply to each module:</simpara>
<calloutlist>
<callout arearefs="CO10-1">
<para><literal>VerificationStatus</literal> - <literal>true</literal> or <literal>false</literal>, validated or not.</para>
</callout>
<callout arearefs="CO10-2">
<para><literal>StatusReason</literal> - Verbal explanation regarding the status.</para>
</callout>
<callout arearefs="CO10-3">
<para><literal>VerificationStage</literal> - Describes the validation stage being executed (Image, Build, Sign).</para>
</callout>
<callout arearefs="CO10-4">
<para><literal>LastTransitionTime</literal> - The time of the last update to the status.</para>
</callout>
</calloutlist>
</section>
<section xml:id="kmm-preflight-validation-stages-per-module_kmm-preflight-validation">
<title>Preflight validation stages per Module</title>
<simpara>Preflight runs the following validations on every KMM Module present in the cluster:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Image validation stage</simpara>
</listitem>
<listitem>
<simpara>Build validation stage</simpara>
</listitem>
<listitem>
<simpara>Sign validation stage</simpara>
</listitem>
</orderedlist>
<section xml:id="kmm-image-validation-stage_kmm-preflight-validation">
<title>Image validation stage</title>
<simpara>Image validation is always the first stage of the preflight validation to be executed. If image validation is successful, no other validations are run on that specific module.</simpara>
<simpara>Image validation consists of two stages:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Image existence and accessibility. The code tries to access the image defined for the upgraded kernel in the module and get its manifests.</simpara>
</listitem>
<listitem>
<simpara>Verify the presence of the kernel module defined in the <literal>Module</literal> in the correct path for future <literal>modprobe</literal> execution. The correct path is <literal>&lt;dirname&gt;/lib/modules/&lt;upgraded_kernel&gt;/</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>If this validation is successful, it probably means that the kernel module was compiled with the correct Linux headers.</simpara>
</section>
<section xml:id="kmm-build-validation-stage_kmm-preflight-validation">
<title>Build validation stage</title>
<simpara>Build validation is executed only when image validation has failed and there is a <literal>build</literal> section in the <literal>Module</literal> that is relevant for the upgraded kernel. Build validation attempts to run the build job and validate that it finishes successfully.</simpara>
<note>
<simpara>You must specify the kernel version when running <literal>depmod</literal>, as shown here:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RUN depmod -b /opt ${KERNEL_VERSION}</programlisting>
</note>
<simpara>If the <literal>PushBuiltImage</literal> flag is defined in the <literal>PreflightValidationOCP</literal> custom resource (CR), it will also try to push the resulting image into its repository. The resulting image name is taken from the definition of the <literal>containerImage</literal> field of the <literal>Module</literal> CR.</simpara>
<note>
<simpara>If the <literal>sign</literal> section is defined for the upgraded kernel, then the resulting image will not be the <literal>containerImage</literal> field of the <literal>Module</literal> CR, but a temporary image name, because the resulting image should be the product of Sign flow.</simpara>
</note>
</section>
<section xml:id="kmm-sign-validation-stage_kmm-preflight-validation">
<title>Sign validation stage</title>
<simpara>Sign validation is executed only when image validation has failed, there is a <literal>sign</literal> section in the <literal>Module</literal> that is relevant for the upgrade kernel, and build validation finished successfully in the event there was a <literal>build</literal> section in the <literal>Module</literal> relevant for the upgraded kernel. Sign validation will try to run the sign job and validate that it finishes successfully.</simpara>
<simpara>If the <literal>PushBuiltImage</literal> flag is defined in the <literal>PreflightValidationOCP</literal> CR, sign validation will also try to push the resulting image to its registry.</simpara>
<simpara>The resulting image is always the image defined in the <literal>containerImage</literal> field of the <literal>Module</literal>. The input image is either the output of the Build stage, or an image defined in the <literal>UnsignedImage</literal> field.</simpara>
<note>
<simpara>If a <literal>build</literal> section exists, the <literal>sign</literal> section input image is the <literal>build</literal> section&#8217;s output image. Therefore, in order for the input image to be available for the <literal>sign</literal> section, the <literal>PushBuiltImage</literal> flag must be defined in the <literal>PreflightValidationOCP</literal> CR.</simpara>
</note>
</section>
</section>
<section xml:id="kmm-example-cr_kmm-preflight-validation">
<title>Example PreflightValidationOCP resource</title>
<simpara>This section shows an example of the <literal>PreflightValidationOCP</literal> resource in the YAML format.</simpara>
<simpara>The example verifies all the currently present modules against the upcoming kernel version included in the {product-title} release 4.11.18, which the following release image points to:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">quay.io/openshift-release-dev/ocp-release@sha256:22e149142517dfccb47be828f012659b1ccf71d26620e6f62468c264a7ce7863</programlisting>
<simpara>Because <literal>.spec.pushBuiltImage</literal> is set to <literal>true</literal>, KMM pushes the resulting images of Build/Sign into the defined repositories.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: kmm.sigs.x-k8s.io/v1beta1
kind: PreflightValidationOCP
metadata:
 name: preflight
spec:
 releaseImage: quay.io/openshift-release-dev/ocp-release@sha256:22e149142517dfccb47be828f012659b1ccf71d26620e6f62468c264a7ce7863
 pushBuiltImage: true</programlisting>
</section>
</section>
</chapter>
<chapter xml:id="_performing_a_cluster_update">
<title>Performing a cluster update</title>
<section xml:id="updating-cluster-cli">
<title>Updating a cluster using the CLI</title>

<simpara>You can update, or upgrade, an {product-title} cluster within a minor version by using the OpenShift CLI (<literal>oc</literal>). You can also update a cluster between minor versions by following the same instructions.</simpara>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Have access to the cluster as a user with <literal>admin</literal> privileges.
See <link xl:href="../../authentication/using-rbac.xml#using-rbac">Using RBAC to define and apply permissions</link>.</simpara>
</listitem>
<listitem>
<simpara>Have a recent <link xl:href="../../backup_and_restore/control_plane_backup_and_restore/backing-up-etcd.xml#backup-etcd">etcd backup</link> in case your update fails and you must restore your cluster to a previous state.</simpara>
</listitem>
<listitem>
<simpara>Have a recent <link xl:href="../../backup_and_restore/application_backup_and_restore/installing/oadp-backup-restore-csi-snapshots.xml">Container Storage Interface (CSI) volume snapshot</link> in case you need to restore persistent volumes due to a pod failure.</simpara>
</listitem>
<listitem>
<simpara>Your RHEL7 workers are replaced with RHEL8 or RHCOS workers. Red&#160;Hat does not support in-place RHEL7 to RHEL8 updates for RHEL workers; those hosts must be replaced with a clean operating system install.</simpara>
</listitem>
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See <link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link> for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Ensure that all machine config pools (MCPs) are running and not paused. Nodes associated with a paused MCP are skipped during the update process. You can pause the MCPs if you are performing a canary rollout update strategy.</simpara>
</listitem>
<listitem>
<simpara>If your cluster uses manually maintained credentials, update the cloud provider resources for the new release. For more information, including how to determine if this is a requirement for your cluster, see <link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#preparing-manual-creds-update">Preparing to update a cluster with manually maintained credentials</link>.</simpara>
</listitem>
<listitem>
<simpara>Ensure that you address all <literal>Upgradeable=False</literal> conditions so the cluster allows an update to the next minor version. An alert displays at the top of the <emphasis role="strong">Cluster Settings</emphasis> page when you have one or more cluster Operators that cannot be updated. You can still update to the next available patch update for the minor release you are currently on.</simpara>
</listitem>
<listitem>
<simpara>If you run an Operator or you have configured any application with the pod disruption budget, you might experience an interruption during the update process. If <literal>minAvailable</literal> is set to 1 in <literal>PodDisruptionBudget</literal>, the nodes are drained to apply pending machine configs which might block the eviction process. If several nodes are rebooted, all the pods might run on only one node, and the <literal>PodDisruptionBudget</literal> field can prevent the node drain.</simpara>
</listitem>
</itemizedlist>
<important>
<itemizedlist>
<listitem>
<simpara>When an update is failing to complete, the Cluster Version Operator (CVO) reports the status of any blocking components while attempting to reconcile the update. Rolling your cluster back to a previous version is not supported. If your update is failing to complete, contact Red&#160;Hat support.</simpara>
</listitem>
<listitem>
<simpara>Using the <literal>unsupportedConfigOverrides</literal> section to modify the configuration of an Operator is unsupported and might block cluster updates. You must remove this setting before you can update your cluster.</simpara>
</listitem>
</itemizedlist>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../architecture/architecture-installation.xml#unmanaged-operators_architecture-installation">Support policy for unmanaged Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-health-checks-pausing_updating-cluster-cli">
<title>Pausing a MachineHealthCheck resource</title>
<simpara>During the update process, nodes in the cluster might become temporarily unavailable. In the case of worker nodes, the machine health check might identify such nodes as unhealthy and reboot them. To avoid rebooting such nodes, pause all the <literal>MachineHealthCheck</literal> resources before updating the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To list all the available <literal>MachineHealthCheck</literal> resources that you want to pause, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinehealthcheck -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>To pause the machine health checks, add the <literal>cluster.x-k8s.io/paused=""</literal> annotation to the <literal>MachineHealthCheck</literal> resource. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api annotate mhc &lt;mhc-name&gt; cluster.x-k8s.io/paused=""</programlisting>
<simpara>The annotated <literal>MachineHealthCheck</literal> resource resembles the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineHealthCheck
metadata:
  name: example
  namespace: openshift-machine-api
  annotations:
    cluster.x-k8s.io/paused: ""
spec:
  selector:
    matchLabels:
      role: worker
  unhealthyConditions:
  - type:    "Ready"
    status:  "Unknown"
    timeout: "300s"
  - type:    "Ready"
    status:  "False"
    timeout: "300s"
  maxUnhealthy: "40%"
status:
  currentHealthy: 5
  expectedMachines: 5</programlisting>
<important>
<simpara>Resume the machine health checks after updating the cluster. To resume the check, remove the pause annotation from the <literal>MachineHealthCheck</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api annotate mhc &lt;mhc-name&gt; cluster.x-k8s.io/paused-</programlisting>
</important>
</listitem>
</orderedlist>
</section>
<section xml:id="update-single-node-openshift_updating-cluster-cli">
<title>About updating single node {product-title}</title>
<simpara>You can update, or upgrade, a single-node {product-title} cluster by using either the console or CLI.</simpara>
<simpara>However, note the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The prerequisite to pause the <literal>MachineHealthCheck</literal> resources is not required because there is no other node to perform the health check.</simpara>
</listitem>
<listitem>
<simpara>Restoring a single-node {product-title} cluster using an etcd backup is not officially supported. However, it is good practice to perform the etcd backup in case your update fails. If your control plane is healthy, you might be able to restore your cluster to a previous state by using the backup.</simpara>
</listitem>
<listitem>
<simpara>Updating a single-node {product-title} cluster requires downtime and can include an automatic reboot. The amount of downtime depends on the update payload, as described in the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>If the update payload contains an operating system update, which requires a reboot, the downtime is significant and impacts cluster management and user workloads.</simpara>
</listitem>
<listitem>
<simpara>If the update contains machine configuration changes that do not require a reboot, the downtime is less, and the impact on the cluster management and user workloads is lessened. In this case, the node draining step is skipped with single-node {product-title} because there is no other node in the cluster to reschedule the workloads to.</simpara>
</listitem>
<listitem>
<simpara>If the update payload does not contain an operating system update or machine configuration changes, a short API outage occurs and resolves quickly.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<important>
<simpara>There are conditions, such as bugs in an updated package, that can cause the single node to not restart after a reboot. In this case, the update does not rollback automatically.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information on which machine configuration changes require a reboot, see the note in <link xl:href="../../architecture/control-plane.xml#about-machine-config-operator_control-plane">About the Machine Config Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-upgrading-cli_updating-cluster-cli">
<title>Updating a cluster by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to review and request cluster updates.</simpara>
<simpara>You can find information about available {product-title} advisories and updates
<link xl:href="https://access.redhat.com/downloads/content/290">in the errata section</link>
of the Customer Portal.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>) that matches the version for your updated version.</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster as user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Pause all <literal>MachineHealthCheck</literal> resources.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the available updates and note the version number of the update that
you want to apply:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cluster version is 4.13.10
Upstream is unset, so the cluster will use an appropriate default.
Channel: stable-4.13 (available channels: candidate-4.13, candidate-4.14, fast-4.13, stable-4.13)
Recommended updates:
  VERSION     IMAGE
  4.13.14     quay.io/openshift-release-dev/ocp-release@sha256:406fcc160c097f61080412afcfa7fd65284ac8741ac7ad5b480e304aba73674b
  4.13.13     quay.io/openshift-release-dev/ocp-release@sha256:d62495768e335c79a215ba56771ff5ae97e3cbb2bf49ed8fb3f6cefabcdc0f17
  4.13.12     quay.io/openshift-release-dev/ocp-release@sha256:73946971c03b43a0dc6f7b0946b26a177c2f3c9d37105441315b4e3359373a55
  4.13.11     quay.io/openshift-release-dev/ocp-release@sha256:e1c2377fdae1d063aaddc753b99acf25972b6997ab9a0b7e80cfef627b9ef3dd</programlisting>
</para>
</formalpara>
<note>
<itemizedlist>
<listitem>
<simpara>If there are no available updates, updates that are supported but not recommended might still be available.
See <emphasis>Updating along a conditional update path</emphasis> for more information.</simpara>
</listitem>
<listitem>
<simpara>For details and information on how to perform an <literal>EUS-to-EUS</literal> channel update, please refer to the <emphasis>Preparing to perform an EUS-to-EUS upgrade</emphasis> page, listed in the Additional resources section.</simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
<listitem>
<simpara>Based on your organization requirements, set the appropriate update channel. For example, you can set your channel to <literal>stable-4.13</literal> or <literal>fast-4.13</literal>. For more information about channels, refer to <emphasis>Understanding update channels and releases</emphasis> listed in the Additional resources section.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade channel &lt;channel&gt;</programlisting>
<simpara>For example, to set the channel to <literal>stable-{product-version}</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade channel stable-{product-version}</programlisting>
<important>
<simpara>For production clusters, you must subscribe to a <literal>stable-*</literal>, <literal>eus-*</literal>, or <literal>fast-*</literal> channel.</simpara>
</important>
<note>
<simpara>When you are ready to move to the next minor version, choose the channel that corresponds to that minor version.
The sooner the update channel is declared, the more effectively the cluster can recommend update paths to your target version.
The cluster might take some time to evaluate all the possible updates that are available and offer the best update recommendations to choose from.
Update recommendations can change over time, as they are based on what update options are available at the time.</simpara>
<simpara>If you cannot see an update path to your target minor version, keep updating your cluster to the latest patch release for your current version until the next minor version is available in the path.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply an update:</simpara>
<itemizedlist>
<listitem>
<simpara>To update to the latest version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --to-latest=true <co xml:id="CO11-1"/></programlisting>
</listitem>
<listitem>
<simpara>To update to a specific version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --to=&lt;version&gt; <co xml:id="CO11-2"/></programlisting>
<calloutlist>
<callout arearefs="CO11-1 CO11-2">
<para><literal>&lt;version&gt;</literal> is the update version that you obtained from the output of the
<literal>oc adm upgrade</literal> command.</para>
</callout>
</calloutlist>
<important>
<simpara>When using <literal>oc adm upgrade --help</literal>, there is a listed option for <literal>--force</literal>. This is <emphasis role="strong">heavily discouraged</emphasis>, as using the <literal>--force</literal> option bypasses cluster-side guards, including release verification and precondition checks. Using <literal>--force</literal> does not guarantee a successful update. Bypassing guards put the cluster at risk.</simpara>
</important>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Review the status of the Cluster Version Operator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
</listitem>
<listitem>
<simpara>After the update completes, you can confirm that the cluster version has
updated to the new version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cluster version is &lt;version&gt;

Upstream is unset, so the cluster will use an appropriate default.
Channel: stable-&lt;version&gt; (available channels: candidate-&lt;version&gt;, eus-&lt;version&gt;, fast-&lt;version&gt;, stable-&lt;version&gt;)

No updates available. You may force an update to a specific release image, but doing so might not be supported and might result in downtime or data loss.</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If you are updating your cluster to the next minor version, such as version X.y to X.(y+1), it is recommended to confirm that your nodes are updated before deploying workloads that rely on a new feature:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS   ROLES    AGE   VERSION
ip-10-0-168-251.ec2.internal   Ready    master   82m   v1.28.5
ip-10-0-170-223.ec2.internal   Ready    master   82m   v1.28.5
ip-10-0-179-95.ec2.internal    Ready    worker   70m   v1.28.5
ip-10-0-182-134.ec2.internal   Ready    worker   70m   v1.28.5
ip-10-0-211-16.ec2.internal    Ready    master   82m   v1.28.5
ip-10-0-250-100.ec2.internal   Ready    worker   69m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/eus-eus-update.xml#eus-eus-update">Performing an EUS-to-EUS update</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-cli.xml#update-conditional-upgrade-pathupdating-cluster-cli">Updating along a conditional update path</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-conditional-upgrade-pathupdating-cluster-cli">
<title>Updating along a conditional update path</title>
<simpara>You can update along a recommended conditional update path using the web console or the OpenShift CLI (<literal>oc</literal>).
When a conditional update is not recommended for your cluster, you can update along a conditional update path using the OpenShift CLI (<literal>oc</literal>) 4.10 or later.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To view the description of the update when it is not recommended because a risk might apply, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --include-not-recommended</programlisting>
</listitem>
<listitem>
<simpara>If the cluster administrator evaluates the potential known risks and decides it is acceptable for the current cluster, then the administrator can waive the safety guards and proceed the update by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --allow-not-recommended --to &lt;version&gt; <co xml:id="CO12-1"/></programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para><literal>&lt;version&gt;</literal> is the supported but not recommended update version that you obtained from the output of the previous command.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-changing-update-server-cli_updating-cluster-cli">
<title>Changing the update server by using the CLI</title>
<simpara>Changing the update server is optional. If you have an OpenShift Update Service (OSUS) installed and configured locally, you must set the URL for the server as the <literal>upstream</literal> to use the local server during updates. The default value for <literal>upstream</literal> is <literal>https://api.openshift.com/api/upgrades_info/v1/graph</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Change the <literal>upstream</literal> parameter value in the cluster version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch clusterversion/version --patch '{"spec":{"upstream":"&lt;update-server-url&gt;"}}' --type=merge</programlisting>
<simpara>The <literal>&lt;update-server-url&gt;</literal> variable specifies the URL for the update server.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">clusterversion.config.openshift.io/version patched</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="updating-cluster-web-console">
<title>Updating a cluster using the web console</title>

<simpara>You can update, or upgrade, an {product-title} cluster by using the web console. The following steps update a cluster within a minor version. You can use the same instructions for updating a cluster between minor versions.</simpara>
<note>
<simpara>Use the web console or <literal>oc adm upgrade channel <emphasis>&lt;channel&gt;</emphasis></literal> to change the update channel. You can follow the steps in <link xl:href="../../updating/updating_a_cluster/updating-cluster-cli.xml#updating-cluster-cli">Updating a cluster using the CLI</link> to complete the update after you change to a {product-version} channel.</simpara>
</note>
<section xml:id="before-updating-ocp_updating-cluster-web-console">
<title>Before updating the {product-title} cluster</title>
<simpara>Before updating, consider the following:</simpara>
<itemizedlist>
<listitem>
<simpara>You have recently backed up etcd.</simpara>
</listitem>
<listitem>
<simpara>In <literal>PodDisruptionBudget</literal>, if <literal>minAvailable</literal> is set to <literal>1</literal>, the nodes are drained to apply pending machine configs that might block the eviction process. If several nodes are rebooted, all the pods might run on only one node, and the <literal>PodDisruptionBudget</literal> field can prevent the node drain.</simpara>
</listitem>
<listitem>
<simpara>You might need to update the cloud provider resources for the new release if your cluster uses manually maintained credentials.</simpara>
</listitem>
<listitem>
<simpara>You must review administrator acknowledgement requests, take any recommended actions, and provide the acknowledgement when you are ready.</simpara>
</listitem>
<listitem>
<simpara>You can perform a partial update by updating the worker or custom pool nodes to accommodate the time it takes to update. You can pause and resume within the progress bar of each pool.</simpara>
</listitem>
</itemizedlist>
<important>
<itemizedlist>
<listitem>
<simpara>When an update is failing to complete, the Cluster Version Operator (CVO) reports the status of any blocking components while attempting to reconcile the update. Rolling your cluster back to a previous version is not supported. If your update is failing to complete, contact Red&#160;Hat support.</simpara>
</listitem>
<listitem>
<simpara>Using the <literal>unsupportedConfigOverrides</literal> section to modify the configuration of an Operator is unsupported and might block cluster updates. You must remove this setting before you can update your cluster.</simpara>
</listitem>
</itemizedlist>
</important>
</section>
<section xml:id="update-changing-update-server-web_updating-cluster-web-console">
<title>Changing the update server by using the web console</title>
<simpara>Changing the update server is optional. If you have an OpenShift Update Service (OSUS) installed and configured locally, you must set the URL for the server as the <literal>upstream</literal> to use the local server during updates.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>, click <emphasis role="strong">version</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">YAML</emphasis> tab and then edit the <literal>upstream</literal> parameter value:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  ...
  spec:
    clusterID: db93436d-7b05-42cc-b856-43e11ad2d31a
    upstream: '&lt;update-server-url&gt;' <co xml:id="CO13-1"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO13-1">
<para>The <literal>&lt;update-server-url&gt;</literal> variable specifies the URL for the update server.</para>
</callout>
</calloutlist>
<simpara>The default <literal>upstream</literal> is <literal>https://api.openshift.com/api/upgrades_info/v1/graph</literal>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="machine-health-checks-pausing-web-console_updating-cluster-web-console">
<title>Pausing a MachineHealthCheck resource by using the web console</title>
<simpara>During the update process, nodes in the cluster might become temporarily unavailable. In the case of worker nodes, the machine health check might identify such nodes as unhealthy and reboot them. To avoid rebooting such nodes, pause all the <literal>MachineHealthCheck</literal> resources before updating the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineHealthChecks</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>To pause the machine health checks, add the <literal>cluster.x-k8s.io/paused=""</literal> annotation to each <literal>MachineHealthCheck</literal> resource. For example, to add the annotation to the <literal>machine-api-termination-handler</literal> resource, complete the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> next to the <literal>machine-api-termination-handler</literal> and click <emphasis role="strong">Edit annotations</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Edit annotations</emphasis> dialog, click <emphasis role="strong">Add more</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Key</emphasis> and <emphasis role="strong">Value</emphasis> fields, add <literal>cluster.x-k8s.io/paused</literal> and <literal>""</literal> values, respectively, and click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="update-upgrading-web_updating-cluster-web-console">
<title>Updating a cluster by using the web console</title>
<simpara>If updates are available, you can update your cluster from the web console.</simpara>
<simpara>You can find information about available {product-title} advisories and updates
<link xl:href="https://access.redhat.com/downloads/content/290">in the errata section</link> of the Customer Portal.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have access to the web console as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Pause all <literal>MachineHealthCheck</literal> resources.</simpara>
</listitem>
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See "Updating installed Operators" in the "Additional resources" section for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Your machine config pools (MCPs) are running and not paused. Nodes associated with a paused MCP are skipped during the update process. You can pause the MCPs if you are performing a canary rollout update strategy.</simpara>
</listitem>
<listitem>
<simpara>Your RHEL7 workers are replaced with RHEL8 or RHCOS workers. Red&#160;Hat does not support in-place RHEL7 to RHEL8 updates for RHEL workers; those hosts must be replaced with a clean operating system install.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the web console, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> and review the contents of the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>For production clusters, ensure that the <emphasis role="strong">Channel</emphasis> is set to the correct channel for the version that you want to update to, such as <literal>stable-{product-version}</literal>.</simpara>
<important>
<simpara>For production clusters, you must subscribe to a <literal>stable-*</literal>, <literal>eus-*</literal> or <literal>fast-*</literal> channel.</simpara>
</important>
<note>
<simpara>When you are ready to move to the next minor version, choose the channel that corresponds to that minor version.
The sooner the update channel is declared, the more effectively the cluster can recommend update paths to your target version.
The cluster might take some time to evaluate all the possible updates that are available and offer the best update recommendations to choose from.
Update recommendations can change over time, as they are based on what update options are available at the time.</simpara>
<simpara>If you cannot see an update path to your target minor version, keep updating your cluster to the latest patch release for your current version until the next minor version is available in the path.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>If the <emphasis role="strong">Update status</emphasis> is not <emphasis role="strong">Updates available</emphasis>, you cannot update your cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Select channel</emphasis> indicates the cluster version that your cluster is running or is updating to.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select a version to update to and click <emphasis role="strong">Save</emphasis>.</simpara>
<simpara>The Input channel
<emphasis role="strong">Update status</emphasis> changes to <emphasis role="strong">Update to &lt;product-version&gt; in progress</emphasis>, and you can review the progress of the cluster update by watching the progress bars for the Operators and nodes.</simpara>
<note>
<simpara>If you are updating your cluster to the next minor version, for example from version 4.10 to 4.11, confirm that your nodes are updated before deploying workloads that rely on a new feature. Any pools with worker nodes that are not yet updated are displayed on the <emphasis role="strong">Cluster Settings</emphasis> page.</simpara>
</note>
</listitem>
<listitem>
<simpara>After the update completes and the Cluster Version Operator refreshes the available updates, check if more updates are available in your current channel.</simpara>
<itemizedlist>
<listitem>
<simpara>If updates are available, continue to perform updates in the current channel until you can no longer update.</simpara>
</listitem>
<listitem>
<simpara>If no updates are available, change the <emphasis role="strong">Channel</emphasis> to the <literal>stable-*</literal>, <literal>eus-*</literal> or <literal>fast-*</literal> channel for the next minor version, and update to the version that you want in that channel.</simpara>
</listitem>
</itemizedlist>
<simpara>You might need to perform several intermediate updates until you reach the version that you want.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-conditional-web-console_updating-cluster-web-console">
<title>Viewing conditional updates in the web console</title>
<simpara>You can view and assess the risks associated with particular updates with conditional updates.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Pause all <literal>MachineHealthCheck</literal> resources.</simpara>
</listitem>
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See "Updating installed Operators" in the "Additional resources" section for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Your machine config pools (MCPs) are running and not paused. Nodes associated with a paused MCP are skipped during the update process. You can pause the MCPs if you are performing an advanced update strategy, such as a canary rollout, an EUS update, or a control-plane update.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the web console, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster settings</emphasis> page and review the contents of the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>You can enable <literal>Include supported but not recommended versions</literal> in the <literal>Select new version</literal> dropdown of the <emphasis role="strong">Update cluster</emphasis> modal to populate the dropdown list with conditional updates.</simpara>
<note>
<simpara>If a <literal>Supported but not recommended</literal> version is selected, more information is provided with potential issues with the version.</simpara>
</note>
</listitem>
<listitem>
<simpara>Review the notification detailing the potential risks to updating.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#conditional-updates-overview_understanding-update-channels-releases">Update recommendations and Conditional Updates</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-using-custom-machine-config-pools-canary_updating-cluster-web-console">
<title>Performing a canary rollout update</title>
<simpara>In some specific use cases, you might want a more controlled update process where you do not want specific nodes updated concurrently with the rest of the cluster. These use cases include, but are not limited to:</simpara>
<itemizedlist>
<listitem>
<simpara>You have mission-critical applications that you do not want unavailable during the update. You can slowly test the applications on your nodes in small batches after the update.</simpara>
</listitem>
<listitem>
<simpara>You have a small maintenance window that does not allow the time for all nodes to be updated, or you have multiple maintenance windows.</simpara>
</listitem>
</itemizedlist>
<simpara>The rolling update process is <emphasis role="strong">not</emphasis> a typical update workflow. With larger clusters, it can be a time-consuming process that requires you execute multiple commands. This complexity can result in errors that can affect the entire cluster.  It is recommended that you carefully consider whether your organization wants to use a rolling update and carefully plan the implementation of the process before you start.</simpara>
<simpara>The rolling update process described in this topic involves:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating one or more custom machine config pools (MCPs).</simpara>
</listitem>
<listitem>
<simpara>Labeling each node that you do not want to  update immediately to move those nodes to the custom MCPs.</simpara>
</listitem>
<listitem>
<simpara>Pausing those custom MCPs, which prevents updates to those nodes.</simpara>
</listitem>
<listitem>
<simpara>Performing the cluster update.</simpara>
</listitem>
<listitem>
<simpara>Unpausing one custom MCP, which triggers the update on those nodes.</simpara>
</listitem>
<listitem>
<simpara>Testing the applications on those nodes to make sure the applications work as expected on those newly-updated nodes.</simpara>
</listitem>
<listitem>
<simpara>Optionally removing the custom labels from the remaining nodes in small batches and testing the applications on those nodes.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Pausing an MCP should be done with careful consideration and for short periods of time only.</simpara>
</note>
<simpara>If you want to use the canary rollout update process, see <link xl:href="../../updating/updating_a_cluster/update-using-custom-machine-config-pools.xml#update-using-custom-machine-config-pools">Performing a canary rollout update</link>.</simpara>
</section>
<section xml:id="update-single-node-openshift_updating-cluster-web-console">
<title>About updating single node {product-title}</title>
<simpara>You can update, or upgrade, a single-node {product-title} cluster by using either the console or CLI.</simpara>
<simpara>However, note the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The prerequisite to pause the <literal>MachineHealthCheck</literal> resources is not required because there is no other node to perform the health check.</simpara>
</listitem>
<listitem>
<simpara>Restoring a single-node {product-title} cluster using an etcd backup is not officially supported. However, it is good practice to perform the etcd backup in case your update fails. If your control plane is healthy, you might be able to restore your cluster to a previous state by using the backup.</simpara>
</listitem>
<listitem>
<simpara>Updating a single-node {product-title} cluster requires downtime and can include an automatic reboot. The amount of downtime depends on the update payload, as described in the following scenarios:</simpara>
<itemizedlist>
<listitem>
<simpara>If the update payload contains an operating system update, which requires a reboot, the downtime is significant and impacts cluster management and user workloads.</simpara>
</listitem>
<listitem>
<simpara>If the update contains machine configuration changes that do not require a reboot, the downtime is less, and the impact on the cluster management and user workloads is lessened. In this case, the node draining step is skipped with single-node {product-title} because there is no other node in the cluster to reschedule the workloads to.</simpara>
</listitem>
<listitem>
<simpara>If the update payload does not contain an operating system update or machine configuration changes, a short API outage occurs and resolves quickly.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<important>
<simpara>There are conditions, such as bugs in an updated package, that can cause the single node to not restart after a reboot. In this case, the update does not rollback automatically.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../architecture/control-plane.xml#about-machine-config-operator_control-plane">About the Machine Config Operator</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="eus-eus-update">
<title>Performing an EUS-to-EUS update</title>

<simpara>Due to fundamental Kubernetes design, all {product-title} updates between minor versions must be serialized.
You must update from {product-title} &lt;4.y&gt; to &lt;4.y+1&gt;, and then to &lt;4.y+2&gt;. You cannot update from {product-title} &lt;4.y&gt; to &lt;4.y+2&gt; directly.
However, administrators who want to update between two Extended Update Support (EUS) versions can do so incurring only a single reboot of non-control plane hosts.</simpara>
<important>
<simpara>EUS-to-EUS updates are only viable between <emphasis role="strong">even-numbered minor versions</emphasis> of {product-title}.</simpara>
</important>
<simpara>There are a number of caveats to consider when attempting an EUS-to-EUS update.</simpara>
<itemizedlist>
<listitem>
<simpara>EUS-to-EUS updates are only offered after updates between all versions involved have been made available in <literal>stable</literal> channels.</simpara>
</listitem>
<listitem>
<simpara>If you encounter issues during or after updating to the odd-numbered minor version but before updating to the next even-numbered version, then remediation of those issues may require that non-control plane hosts complete the update to the odd-numbered version before moving forward.</simpara>
</listitem>
<listitem>
<simpara>You can do a partial update by updating the worker or custom pool nodes to accommodate the time it takes for maintenance.</simpara>
</listitem>
<listitem>
<simpara>You can complete the update process during multiple maintenance windows by pausing at intermediate steps. However, plan to complete the entire update within 60 days. This is critical to ensure that normal cluster automation processes are completed.</simpara>
</listitem>
<listitem>
<simpara>Until the machine config pools are unpaused and the update is complete, some features and bugs fixes in &lt;4.y+1&gt; and &lt;4.y+2&gt; of {product-title} are not available.</simpara>
</listitem>
<listitem>
<simpara>All the clusters might update using EUS channels for a conventional update without pools paused, but only clusters with non control-plane <literal>MachineConfigPools</literal> objects can do EUS-to-EUS update with pools paused.</simpara>
</listitem>
</itemizedlist>
<section xml:id="updating-eus-to-eus-upgrade_eus-to-eus-update">
<title>EUS-to-EUS update</title>
<simpara>The following procedure pauses all non-master machine config pools and performs updates from {product-title} &lt;4.y&gt; to &lt;4.y+1&gt; to &lt;4.y+2&gt;, then unpauses the previously paused machine config pools.
Following this procedure reduces the total update duration and the number of times worker nodes are restarted.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Review the release notes for {product-title} &lt;4.y+1&gt; and &lt;4.y+2&gt;</simpara>
</listitem>
<listitem>
<simpara>Review the release notes and product lifecycles for any layered products and Operator Lifecycle Manager (OLM) Operators. Some may require updates either before or during an EUS-to-EUS update.</simpara>
</listitem>
<listitem>
<simpara>Ensure that you are familiar with version-specific prerequisites, such as the removal of deprecated APIs, that are required prior to updating from {product-title} &lt;4.y+1&gt; to &lt;4.y+2&gt;.</simpara>
</listitem>
</itemizedlist>
<section xml:id="updating-eus-to-eus-upgrade-console_eus-to-eus-update">
<title>EUS-to-EUS update using the web console</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Verify that machine config pools are unpaused.</simpara>
</listitem>
<listitem>
<simpara>Have access to the web console as a user with <literal>admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Using the Administrator perspective on the web console, update any Operator Lifecycle Manager (OLM) Operators to the versions that are compatible with your intended updated version. You can find more information on how to perform this action in "Updating installed Operators"; see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>Verify that all machine config pools display a status of <literal>Up to date</literal> and that no machine config pool displays a status of <literal>UPDATING</literal>.</simpara>
<simpara>To view the status of all machine config pools, click <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">MachineConfigPools</emphasis> and review the contents of the <emphasis role="strong">Update status</emphasis> column.</simpara>
<note>
<simpara>If your machine config pools have an <literal>Updating</literal> status, please wait for this status to change to <literal>Up to date</literal>. This process could take several minutes.</simpara>
</note>
</listitem>
<listitem>
<simpara>Set your channel to <literal>eus-&lt;4.y+2&gt;</literal>.</simpara>
<simpara>To set your channel, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> &#8594; <emphasis role="strong">Channel</emphasis>. You can edit your channel by clicking on the current hyperlinked channel.</simpara>
</listitem>
<listitem>
<simpara>Pause all worker machine pools except for the master pool. You can perform this action on the <emphasis role="strong">MachineConfigPools</emphasis> tab under the <emphasis role="strong">Compute</emphasis> page. Select the vertical ellipses next to the machine config pool you&#8217;d like to pause and click <emphasis role="strong">Pause updates</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Update to version &lt;4.y+1&gt; and complete up to the <emphasis role="strong">Save</emphasis> step. You can find more information on how to perform these actions in "Updating a cluster by using the web console"; see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>Ensure that the &lt;4.y+1&gt; updates are complete by viewing the <emphasis role="strong">Last completed version</emphasis> of your cluster. You can find this information on the <emphasis role="strong">Cluster Settings</emphasis> page under the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>If necessary, update your OLM Operators by using the Administrator perspective on the web console. You can find more information on how to perform these actions in "Updating installed Operators"; see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>Update to version &lt;4.y+2&gt; and complete up to the <emphasis role="strong">Save</emphasis> step. You can find more information on how to perform these actions in "Updating a cluster by using the web console"; see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>Ensure that the &lt;4.y+2&gt; update is complete by viewing the <emphasis role="strong">Last completed version</emphasis> of your cluster. You can find this information on the <emphasis role="strong">Cluster Settings</emphasis> page under the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Unpause all previously paused machine config pools. You can perform this action on the <emphasis role="strong">MachineConfigPools</emphasis> tab under the <emphasis role="strong">Compute</emphasis> page. Select the vertical ellipses next to the machine config pool you&#8217;d like to unpause and click <emphasis role="strong">Unpause updates</emphasis>.</simpara>
<important>
<simpara>If pools are paused, the cluster is not permitted to upgrade to any future minor versions, and some maintenance tasks are inhibited. This puts the cluster at risk for future degradation.</simpara>
</important>
</listitem>
<listitem>
<simpara>Verify that your previously paused pools are updated and that your cluster has completed the update to version &lt;4.y+2&gt;.</simpara>
<simpara>You can verify that your pools have updated on the <emphasis role="strong">MachineConfigPools</emphasis> tab under the <emphasis role="strong">Compute</emphasis> page by confirming that the <emphasis role="strong">Update status</emphasis> has a value of <emphasis role="strong">Up to date</emphasis>.</simpara>
<simpara>You can verify that your cluster has completed the update by viewing the <emphasis role="strong">Last completed version</emphasis> of your cluster. You can find this information on the <emphasis role="strong">Cluster Settings</emphasis> page under the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
</orderedlist>
<itemizedlist xml:id="additional-resources_updating-eus-to-eus-upgrade-console" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-web-console.xml#update-upgrading-web_updating-cluster-web-console">Updating a cluster by using the web console</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="updating-eus-to-eus-upgrade-cli_eus-to-eus-update">
<title>EUS-to-EUS update using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Verify that machine config pools are unpaused.</simpara>
</listitem>
<listitem>
<simpara>Update the OpenShift CLI (<literal>oc</literal>) to the target version before each update.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>It is highly discouraged to skip this prerequisite. If the OpenShift CLI (<literal>oc</literal>) is not updated to the target version before your update, unexpected issues may occur.</simpara>
</important>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Using the Administrator perspective on the web console, update any Operator Lifecycle Manager (OLM) Operators to the versions that are compatible with your intended updated version. You can find more information on how to perform this action in "Updating installed Operators"; see "Additional resources".</simpara>
</listitem>
<listitem>
<simpara>Verify that all machine config pools display a status of <literal>UPDATED</literal> and that no machine config pool displays a status of <literal>UPDATING</literal>.
To view the status of all machine config pools, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     CONFIG                                         	UPDATED   UPDATING
master   rendered-master-ecbb9582781c1091e1c9f19d50cf836c       True  	  False
worker   rendered-worker-00a3f0c68ae94e747193156b491553d5       True  	  False</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Your current version is &lt;4.y&gt;, and your intended version to update is &lt;4.y+2&gt;. Change to the <literal>eus-&lt;4.y+2&gt;</literal> channel by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade channel eus-&lt;4.y+2&gt;</programlisting>
<note>
<simpara>If you receive an error message indicating that <literal>eus-&lt;4.y+2&gt;</literal> is not one of the
available channels, this indicates that Red Hat is still rolling out EUS version updates.
This rollout process generally takes 45-90 days starting at the GA date.</simpara>
</note>
</listitem>
<listitem>
<simpara>Pause all worker machine pools except for the master pool by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch mcp/worker --type merge --patch '{"spec":{"paused":true}}'</programlisting>
<note>
<simpara>You cannot pause the master pool.</simpara>
</note>
</listitem>
<listitem>
<simpara>Update to the latest version by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --to-latest</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Updating to latest version &lt;4.y+1.z&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Review the cluster version to ensure that the updates are complete by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cluster version is &lt;4.y+1.z&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Update to version &lt;4.y+2&gt; by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --to-latest</programlisting>
</listitem>
<listitem>
<simpara>Retrieve the cluster version to ensure that the &lt;4.y+2&gt; updates are complete by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Cluster version is &lt;4.y+2.z&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To update your worker nodes to &lt;4.y+2&gt;, unpause all previously paused machine config pools by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch mcp/worker --type merge --patch '{"spec":{"paused":false}}'</programlisting>
<important>
<simpara>If pools are not unpaused, the cluster is not permitted to update to any future minor versions, and some maintenance tasks are inhibited. This puts the cluster at risk for future degradation.</simpara>
</important>
</listitem>
<listitem>
<simpara>Verify that your previously paused pools are updated and that the update to version &lt;4.y+2&gt; is complete by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get mcp</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME 	   CONFIG                                            UPDATED     UPDATING
master   rendered-master-52da4d2760807cb2b96a3402179a9a4c    True  	 False
worker   rendered-worker-4756f60eccae96fb9dcb4c392c69d497    True 	 False</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist xml:id="additional-resources_updating-eus-to-eus-upgrade-cli" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="updating-eus-to-eus-olm-operators_eus-to-eus-update">
<title>EUS-to-EUS update for layered products and Operators installed through Operator Lifecycle Manager</title>
<simpara>In addition to the EUS-to-EUS update steps mentioned for the web console and CLI, there are additional steps to consider when performing EUS-to-EUS updates for clusters with the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Layered products</simpara>
</listitem>
<listitem>
<simpara>Operators installed through Operator Lifecycle Manager (OLM)</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>What is a layered product?</title>
<para>Layered products refer to products that are made of multiple underlying products that are intended to be used together and cannot be broken into individual subscriptions. For examples of layered {product-title} products, see <link xl:href="https://access.redhat.com/support/policy/updates/openshift/#layered">Layered Offering On OpenShift</link>.</para>
</formalpara>
<simpara>As you perform an EUS-to-EUS update for the clusters of layered products and those of Operators that have been installed through OLM, you must complete the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See "Updating installed Operators" in the "Additional resources" section for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Confirm the cluster version compatibility between the current and intended Operator versions. You can verify which versions your OLM Operators are compatible with by using the <link xl:href="https://access.redhat.com/labs/ocpouic/?operator=logging&amp;&amp;ocp_versions=4.10,4.11,4.12">Red&#160;Hat {product-title} Operator Update Information Checker</link>.</simpara>
</listitem>
</orderedlist>
<simpara>As an example, here are the steps to perform an EUS-to-EUS update from &lt;4.y&gt; to &lt;4.y+2&gt; for OpenShift Data Foundation (ODF). This can be done through the CLI or web console. For information on how to update clusters through your desired interface, see <emphasis>EUS-to-EUS update using the web console</emphasis> and "EUS-to-EUS update using the CLI" in "Additional resources".</simpara>
<orderedlist numeration="arabic">
<title>Example workflow</title>
<listitem>
<simpara>Pause the worker machine pools.</simpara>
</listitem>
<listitem>
<simpara>Update OpenShift &lt;4.y&gt; &#8594; OpenShift &lt;4.y+1&gt;.</simpara>
</listitem>
<listitem>
<simpara>Update ODF &lt;4.y&gt; &#8594; ODF &lt;4.y+1&gt;.</simpara>
</listitem>
<listitem>
<simpara>Update OpenShift &lt;4.y+1&gt; &#8594; OpenShift &lt;4.y+2&gt;.</simpara>
</listitem>
<listitem>
<simpara>Update to ODF &lt;4.y+2&gt;.</simpara>
</listitem>
<listitem>
<simpara>Unpause the worker machine pools.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The update to ODF &lt;4.y+2&gt; can happen before or after worker machine pools have been unpaused.</simpara>
</note>
<itemizedlist xml:id="additional-resources_updating-eus-to-eus-layered-products" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/eus-eus-update.xml#updating-eus-to-eus-upgrade-console_eus-to-eus-update">EUS-to-EUS update using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/eus-eus-update.xml#updating-eus-to-eus-upgrade-cli_eus-to-eus-update">EUS-to-EUS update using the CLI</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="update-using-custom-machine-config-pools">
<title>Performing a canary rollout update</title>

<simpara>There might be some scenarios where you want a more controlled rollout of an update to the worker nodes in order to ensure that mission-critical applications stay available during the whole update, even if the update process causes your applications to fail. Depending on your organizational needs, you might want to update a small subset of worker nodes, evaluate cluster and workload health over a period of time, then update the remaining nodes. This is commonly referred to as a <emphasis>canary</emphasis> update. Or, you might also want to fit worker node updates, which often require a host reboot, into smaller defined maintenance windows when it is not possible to take a large maintenance window to update the entire cluster at one time.</simpara>
<simpara>In these scenarios, you can create multiple custom machine config pools (MCPs) to prevent certain worker nodes from updating when you update the cluster. After the rest of the cluster is updated, you can update those worker nodes in batches at appropriate times.</simpara>
<simpara>For example, if you have a cluster with 100 nodes with 10% excess capacity, maintenance windows that must not exceed 4 hours, and you know that it takes no longer than 8 minutes to drain and reboot a worker node, you can leverage MCPs to meet your goals. For example, you could define four MCPs, named <emphasis role="strong">workerpool-canary</emphasis>, <emphasis role="strong">workerpool-A</emphasis>, <emphasis role="strong">workerpool-B</emphasis>, and <emphasis role="strong">workerpool-C</emphasis>, with 10, 30, 30, and 30 nodes respectively.</simpara>
<simpara>During your first maintenance window, you would pause the MCP for <emphasis role="strong">workerpool-A</emphasis>, <emphasis role="strong">workerpool-B</emphasis>, and <emphasis role="strong">workerpool-C</emphasis>, then initiate the cluster update. This updates components that run on top of {product-title} and the 10 nodes which are members of the <emphasis role="strong">workerpool-canary</emphasis> MCP, because that pool was not paused. The other three MCPs are not updated, because they were paused.  If for some reason, you determine that your cluster or workload health was negatively affected by the <emphasis role="strong">workerpool-canary</emphasis> update, you would then cordon and drain all nodes in that pool while still maintaining sufficient capacity until you have diagnosed the problem. When everything is working as expected, you would then evaluate the cluster and workload health before deciding to unpause, and thus update, <emphasis role="strong">workerpool-A</emphasis>, <emphasis role="strong">workerpool-B</emphasis>, and <emphasis role="strong">workerpool-C</emphasis> in succession during each additional maintenance window.</simpara>
<simpara>While managing worker node updates using custom MCPs provides flexibility, it can be a time-consuming process that requires you execute multiple commands. This complexity can result in errors that can affect the entire cluster. It is recommended that you carefully consider your organizational needs and carefully plan the implemention of the process before you start.</simpara>
<note>
<simpara>It is not recommended to update the MCPs to different {product-title} versions. For example, do not update one MCP from 4.y.10 to 4.y.11 and another to 4.y.12.
This scenario has not been tested and might result in an undefined cluster state.</simpara>
</note>
<important>
<simpara>Pausing a machine config pool prevents the Machine Config Operator from applying any configuration changes on the associated nodes. Pausing an MCP also prevents any automatically rotated certificates from being pushed to the associated nodes, including the automatic CA rotation of the <literal>kube-apiserver-to-kubelet-signer</literal> CA certificate.</simpara>
<simpara>If the MCP is paused when the <literal>kube-apiserver-to-kubelet-signer</literal> CA certificate expires and the MCO attempts to automatically renew the certificate, the MCO cannot push the newly rotated certificates to those nodes. This causes failure in multiple <literal>oc</literal> commands, including <literal>oc debug</literal>, <literal>oc logs</literal>, <literal>oc exec</literal>, and <literal>oc attach</literal>. You receive alerts in the Alerting UI of the {product-title} web console if an MCP is paused when the certificates are rotated.</simpara>
<simpara>Pausing an MCP should be done with careful consideration about the <literal>kube-apiserver-to-kubelet-signer</literal> CA certificate expiration and for short periods of time only.</simpara>
</important>
<section xml:id="update-using-custom-machine-config-pools-about-mcp_update-using-custom-machine-config-pools">
<title>About the canary rollout update process and MCPs</title>
<simpara>In {product-title}, nodes are not considered individually. Nodes are grouped into machine config pools (MCP). There are two MCPs in a default {product-title} cluster: one for the control plane nodes and one for the worker nodes. An {product-title} update affects all MCPs concurrently.</simpara>
<simpara>During the update, the Machine Config Operator (MCO) drains and cordons all nodes within a MCP up to the specified <literal>maxUnavailable</literal> number of nodes (if specified), by default <literal>1</literal>. Draining and cordoning a node deschedules all pods on the node and marks the node as unschedulable. After the node is drained, the Machine Config Daemon applies a new machine configuration, which can include updating the operating system (OS). Updating the OS requires the host to reboot.</simpara>
<simpara>To prevent specific nodes from being updated, and thus, not drained, cordoned, and updated, you can create custom MCPs. Then, pause those MCPs to ensure that the nodes associated with those MCPs are not updated. The MCO does not update any paused MCPs. You can create one or more custom MCPs, which can give you more control over the sequence in which you update those nodes. After you update the nodes in the first MCP, you can verify the application compatibility, and then update the rest of the nodes gradually to the new version.</simpara>
<note>
<simpara>To ensure the stability of the control plane, creating a custom MCP from the control plane nodes is not supported. The Machine Config Operator (MCO) ignores any custom MCP created for the control plane nodes.</simpara>
</note>
<simpara>You should give careful consideration to the number of MCPs you create and the number of nodes in each MCP, based on your workload deployment topology. For example, If you need to fit updates into specific maintenance windows, you need to know how many nodes that {product-title} can update within a window. This number is dependent on your unique cluster and workload characteristics.</simpara>
<simpara>Also, you need to consider how much extra capacity you have available in your cluster. For example, in the case where your applications fail to work as expected on the updated nodes, you can cordon and drain those nodes in the pool, which moves the application pods to other nodes. You need to consider how much extra capacity you have available in order to determine the number of custom MCPs you need and how many nodes are in each MCP. For example, if you use two custom MCPs and 50% of your nodes are in each pool, you need to determine if running 50% of your nodes would provide sufficient quality-of-service (QoS) for your applications.</simpara>
<simpara>You can use this update process with all documented {product-title} update processes. However, the process does not work with Red Hat Enterprise Linux (RHEL) machines, which are updated using Ansible playbooks.</simpara>
</section>
<section xml:id="update-using-custom-machine-config-pools-about_update-using-custom-machine-config-pools">
<title>About performing a canary rollout update</title>
<simpara>This topic describes the general workflow of this canary rollout update process. The steps to perform each task in the workflow are described in the following sections.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create MCPs based on the worker pool. The number of nodes in each MCP depends on a few factors, such as your maintenance window duration for each MCP, and the amount of reserve capacity, meaning extra worker nodes, available in your cluster.</simpara>
<note>
<simpara>You can change the <literal>maxUnavailable</literal> setting in an MCP to specify the percentage or the number of machines that can be updating at any given time. The default is 1.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add a node selector to the custom MCPs. For each node that you do not want to update simultaneously with the rest of the cluster, add a matching label to the nodes. This label associates the node to the MCP.</simpara>
<note>
<simpara>Do not remove the default worker label from the nodes. The nodes <emphasis role="strong">must</emphasis> have a role label to function properly in the cluster.</simpara>
</note>
</listitem>
<listitem>
<simpara>Pause the MCPs you do not want to update as part of the update process.</simpara>
</listitem>
<listitem>
<simpara>Perform the cluster update. The update process updates the MCPs that are not paused, including the control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>Test the applications on the updated nodes to ensure they are working as expected.</simpara>
</listitem>
<listitem>
<simpara>Unpause the remaining MCPs one-by-one and test the applications on those nodes until all worker nodes are updated. Unpausing an MCP starts the update process for the nodes associated with that MCP. You can check the progress of the update from the web console by clicking <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster settings</emphasis>. Or, use the <literal>oc get machineconfigpools</literal> CLI command.</simpara>
</listitem>
<listitem>
<simpara>Optionally, remove the custom label from updated nodes and delete the custom MCPs.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-using-custom-machine-config-pools-mcp_update-using-custom-machine-config-pools">
<title>Creating machine config pools to perform a canary rollout update</title>
<simpara>The first task in performing this canary rollout update is to create one or more machine config pools (MCP).</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create an MCP from a worker node.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List the worker nodes in your cluster.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -l 'node-role.kubernetes.io/master!=' -o 'jsonpath={range .items[*]}{.metadata.name}{"\n"}{end}' nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">ci-ln-pwnll6b-f76d1-s8t9n-worker-a-s75z4
ci-ln-pwnll6b-f76d1-s8t9n-worker-b-dglj2
ci-ln-pwnll6b-f76d1-s8t9n-worker-c-lldbm</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>For the nodes you want to delay, add a custom label to the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node name&gt; node-role.kubernetes.io/&lt;custom-label&gt;=</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node ci-ln-0qv1yp2-f76d1-kl2tq-worker-a-j2ssz node-role.kubernetes.io/workerpool-canary=</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/ci-ln-gtrwm8t-f76d1-spbl7-worker-a-xk76k labeled</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the new MCP:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machineconfiguration.openshift.io/v1
kind: MachineConfigPool
metadata:
  name: workerpool-canary <co xml:id="CO14-1"/>
spec:
  machineConfigSelector:
    matchExpressions: <co xml:id="CO14-2"/>
      - {
         key: machineconfiguration.openshift.io/role,
         operator: In,
         values: [worker,workerpool-canary]
        }
  nodeSelector:
    matchLabels:
      node-role.kubernetes.io/workerpool-canary: "" <co xml:id="CO14-3"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Specify a name for the MCP.</para>
</callout>
<callout arearefs="CO14-2">
<para>Specify the <literal>worker</literal> and custom MCP name.</para>
</callout>
<callout arearefs="CO14-3">
<para>Specify the custom label you added to the nodes that you want in this pool.</para>
</callout>
</calloutlist>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;file_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineconfigpool.machineconfiguration.openshift.io/workerpool-canary created</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>View the list of MCPs in the cluster and their current state:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machineconfigpool</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              CONFIG                                                        UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master            rendered-master-b0bb90c4921860f2a5d8a2f8137c1867              True      False      False      3              3                   3                     0                      97m
workerpool-canary rendered-workerpool-canary-87ba3dec1ad78cb6aecebf7fbb476a36   True      False      False      1              1                   1                     0                      2m42s
worker            rendered-worker-87ba3dec1ad78cb6aecebf7fbb476a36              True      False      False      2              2                   2                     0                      97m</programlisting>
</para>
</formalpara>
<simpara>The new machine config pool, <literal>workerpool-canary</literal>, is created and the number of nodes to which you added the custom label are shown in the machine counts. The worker MCP machine counts are reduced by the same number. It can take several minutes to update the machine counts. In this example, one node was moved from the <literal>worker</literal> MCP to the <literal>workerpool-canary</literal> MCP.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="update-using-custom-machine-config-pools-pause_update-using-custom-machine-config-pools">
<title>Pausing the machine config pools</title>
<simpara>In this canary rollout update process, after you label the nodes that you do not want to update with the rest of your {product-title} cluster and create the machine config pools (MCPs), you pause those MCPs. Pausing an MCP prevents the Machine Config Operator (MCO) from updating the nodes associated with that MCP.</simpara>
<simpara>To pause an MCP:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Patch the MCP that you want paused:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch mcp/&lt;mcp_name&gt; --patch '{"spec":{"paused":true}}' --type=merge</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc patch mcp/workerpool-canary --patch '{"spec":{"paused":true}}' --type=merge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineconfigpool.machineconfiguration.openshift.io/workerpool-canary patched</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-using-custom-machine-config-pools-update_update-using-custom-machine-config-pools">
<title>Performing the cluster update</title>
<simpara>When the MCPs enter ready state, you can perform the cluster update. See one of the following update methods, as appropriate for your cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-web-console.xml#update-upgrading-web_updating-cluster-web-console">Updating a cluster using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-cli.xml#update-upgrading-cli_updating-cluster-cli">Updating a cluster using the CLI</link></simpara>
</listitem>
</itemizedlist>
<simpara>After the update is complete, you can start to unpause the MCPs one-by-one.</simpara>
</section>
<section xml:id="update-using-custom-machine-config-pools-unpause_update-using-custom-machine-config-pools">
<title>Unpausing the machine config pools</title>
<simpara>In this canary rollout update process, after the {product-title} update is complete, unpause your custom MCPs one-by-one. Unpausing an MCP allows the Machine Config Operator (MCO) to update the nodes associated with that MCP.</simpara>
<simpara>To unpause an MCP:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Patch the MCP that you want to unpause:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch mcp/&lt;mcp_name&gt; --patch '{"spec":{"paused":false}}' --type=merge</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$  oc patch mcp/workerpool-canary --patch '{"spec":{"paused":false}}' --type=merge</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">machineconfigpool.machineconfiguration.openshift.io/workerpool-canary patched</programlisting>
</para>
</formalpara>
<simpara>You can check the progress of the update by using the <literal>oc get machineconfigpools</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Test your applications on the updated nodes to ensure that they are working as expected.</simpara>
</listitem>
<listitem>
<simpara>Unpause any other paused MCPs one-by-one and verify that your applications work.</simpara>
</listitem>
</orderedlist>
<section xml:id="update-using-custom-machine-config-pools-fail_update-using-custom-machine-config-pools">
<title>In case of application failure</title>
<simpara>In case of a failure, such as your applications not working on the updated nodes, you can cordon and drain the nodes in the pool, which moves the application pods to other nodes to help maintain the quality-of-service for the applications. This first MCP should be no larger than the excess capacity.</simpara>
</section>
</section>
<section xml:id="update-using-custom-machine-config-pools-mcp-remove_update-using-custom-machine-config-pools">
<title>Moving a node to the original machine config pool</title>
<simpara>In this canary rollout update process, after you have unpaused a custom machine config pool (MCP) and verified that the applications on the nodes associated with that MCP are working as expected, you should move the node back to its original MCP by removing the custom label you added to the node.</simpara>
<important>
<simpara>A node must have a role to be properly functioning in the cluster.</simpara>
</important>
<simpara>To move a node to its original MCP:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Remove the custom label from the node.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node &lt;node_name&gt; node-role.kubernetes.io/&lt;custom-label&gt;-</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label node ci-ln-0qv1yp2-f76d1-kl2tq-worker-a-j2ssz node-role.kubernetes.io/workerpool-canary-</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">node/ci-ln-0qv1yp2-f76d1-kl2tq-worker-a-j2ssz labeled</programlisting>
</para>
</formalpara>
<simpara>The MCO moves the nodes back to the original MCP and reconciles the node to the MCP configuration.</simpara>
</listitem>
<listitem>
<simpara>View the list of MCPs in the cluster and their current state:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$oc get mcp</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">NAME                CONFIG                                                   UPDATED   UPDATING   DEGRADED   MACHINECOUNT   READYMACHINECOUNT   UPDATEDMACHINECOUNT   DEGRADEDMACHINECOUNT   AGE
master              rendered-master-1203f157d053fd987c7cbd91e3fbc0ed         True      False      False      3              3                   3                     0                      61m
workerpool-canary   rendered-mcp-noupdate-5ad4791166c468f3a35cd16e734c9028   True      False      False      0              0                   0                     0                      21m
worker              rendered-worker-5ad4791166c468f3a35cd16e734c9028         True      False      False      3              3                   3                     0                      61m</programlisting>
<simpara>The node is removed from the custom MCP and moved back to the original MCP. It can take several minutes to update the machine counts. In this example, one node was moved from the removed <literal>workerpool-canary</literal> MCP to the `worker`MCP.</simpara>
</listitem>
<listitem>
<simpara>Optional: Delete the custom MCP:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete mcp &lt;mcp_name&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="updating-cluster-rhel-compute">
<title>Updating a cluster that includes RHEL compute machines</title>

<simpara>You can update an {product-title} cluster. If your cluster contains Red Hat Enterprise Linux (RHEL) machines, you must perform more steps to update those machines.</simpara>
<section xml:id="_prerequisites_2">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Have access to the cluster as a user with <literal>admin</literal> privileges.
See <link xl:href="../../authentication/using-rbac.xml#using-rbac">Using RBAC to define and apply permissions</link>.</simpara>
</listitem>
<listitem>
<simpara>Have a recent <link xl:href="../../backup_and_restore/control_plane_backup_and_restore/backing-up-etcd.xml#backup-etcd">etcd backup</link> in case your update fails and you must restore your cluster to a previous state.</simpara>
</listitem>
<listitem>
<simpara>Your RHEL7 workers are replaced with RHEL8 or RHCOS workers. Red&#160;Hat does not support in-place RHEL7 to RHEL8 updates for RHEL workers; those hosts must be replaced with a clean operating system install.</simpara>
</listitem>
<listitem>
<simpara>If your cluster uses manually maintained credentials, update the cloud provider resources for the new release. For more information, including how to determine if this is a requirement for your cluster, see <link xl:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#preparing-manual-creds-update">Preparing to update a cluster with manually maintained credentials</link>.</simpara>
</listitem>
<listitem>
<simpara>If you run an Operator or you have configured any application with the pod disruption budget, you might experience an interruption during the update process. If <literal>minAvailable</literal> is set to 1 in <literal>PodDisruptionBudget</literal>, the nodes are drained to apply pending machine configs which might block the eviction process. If several nodes are rebooted, all the pods might run on only one node, and the <literal>PodDisruptionBudget</literal> field can prevent the node drain.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../architecture/architecture-installation.xml#unmanaged-operators_architecture-installation">Support policy for unmanaged Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-upgrading-web_updating-cluster-rhel-compute">
<title>Updating a cluster by using the web console</title>
<simpara>If updates are available, you can update your cluster from the web console.</simpara>
<simpara>You can find information about available {product-title} advisories and updates
<link xl:href="https://access.redhat.com/downloads/content/290">in the errata section</link> of the Customer Portal.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have access to the web console as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
<listitem>
<simpara>Pause all <literal>MachineHealthCheck</literal> resources.</simpara>
</listitem>
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See "Updating installed Operators" in the "Additional resources" section for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Your machine config pools (MCPs) are running and not paused. Nodes associated with a paused MCP are skipped during the update process. You can pause the MCPs if you are performing a canary rollout update strategy.</simpara>
</listitem>
<listitem>
<simpara>Your RHEL7 workers are replaced with RHEL8 or RHCOS workers. Red&#160;Hat does not support in-place RHEL7 to RHEL8 updates for RHEL workers; those hosts must be replaced with a clean operating system install.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the web console, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> and review the contents of the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>For production clusters, ensure that the <emphasis role="strong">Channel</emphasis> is set to the correct channel for the version that you want to update to, such as <literal>stable-{product-version}</literal>.</simpara>
<important>
<simpara>For production clusters, you must subscribe to a <literal>stable-*</literal>, <literal>eus-*</literal> or <literal>fast-*</literal> channel.</simpara>
</important>
<note>
<simpara>When you are ready to move to the next minor version, choose the channel that corresponds to that minor version.
The sooner the update channel is declared, the more effectively the cluster can recommend update paths to your target version.
The cluster might take some time to evaluate all the possible updates that are available and offer the best update recommendations to choose from.
Update recommendations can change over time, as they are based on what update options are available at the time.</simpara>
<simpara>If you cannot see an update path to your target minor version, keep updating your cluster to the latest patch release for your current version until the next minor version is available in the path.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>If the <emphasis role="strong">Update status</emphasis> is not <emphasis role="strong">Updates available</emphasis>, you cannot update your cluster.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Select channel</emphasis> indicates the cluster version that your cluster is running or is updating to.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Select a version to update to and click <emphasis role="strong">Save</emphasis>.</simpara>
<simpara>The Input channel
<emphasis role="strong">Update status</emphasis> changes to <emphasis role="strong">Update to &lt;product-version&gt; in progress</emphasis>, and you can review the progress of the cluster update by watching the progress bars for the Operators and nodes.</simpara>
<note>
<simpara>If you are updating your cluster to the next minor version, for example from version 4.10 to 4.11, confirm that your nodes are updated before deploying workloads that rely on a new feature. Any pools with worker nodes that are not yet updated are displayed on the <emphasis role="strong">Cluster Settings</emphasis> page.</simpara>
</note>
</listitem>
<listitem>
<simpara>After the update completes and the Cluster Version Operator refreshes the available updates, check if more updates are available in your current channel.</simpara>
<itemizedlist>
<listitem>
<simpara>If updates are available, continue to perform updates in the current channel until you can no longer update.</simpara>
</listitem>
<listitem>
<simpara>If no updates are available, change the <emphasis role="strong">Channel</emphasis> to the <literal>stable-*</literal>, <literal>eus-*</literal> or <literal>fast-*</literal> channel for the next minor version, and update to the version that you want in that channel.</simpara>
</listitem>
</itemizedlist>
<simpara>You might need to perform several intermediate updates until you reach the version that you want.</simpara>
<important>
<simpara>When you update a cluster that contains Red Hat Enterprise Linux (RHEL) worker machines, those workers temporarily become unavailable during the update process. You must run the update playbook against each RHEL machine as it enters the <literal>NotReady</literal> state for the cluster to finish updating.</simpara>
</important>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="updating-cluster-rhel-compute-hooks">
<title>Optional: Adding hooks to perform Ansible tasks on RHEL machines</title>
<simpara>You can use <emphasis>hooks</emphasis> to run Ansible tasks on the RHEL compute machines during
the {product-title} update.</simpara>
<section xml:id="rhel-compute-about-hooks_updating-cluster-rhel-compute">
<title>About Ansible hooks for updates</title>
<simpara>When you update {product-title}, you can run custom tasks on your Red Hat
Enterprise Linux (RHEL) nodes during specific operations by using <emphasis>hooks</emphasis>. Hooks
allow you to provide files that define tasks to run before or after specific
update tasks. You can use hooks to validate or modify custom
infrastructure when you update the RHEL compute nodes in you {product-title}
cluster.</simpara>
<simpara>Because when a hook fails, the operation fails, you must design hooks that are
idempotent, or can run multiple times and provide the same results.</simpara>
<simpara>Hooks have the following important limitations:
- Hooks do not have a defined or versioned interface. They can use internal
<literal>openshift-ansible</literal> variables, but it is possible that the variables will be
modified or removed in future {product-title} releases.
- Hooks do not have error handling, so an error in a hook halts the update
process. If you get an error, you must address the problem and then start the
update again.</simpara>
</section>
<section xml:id="rhel-compute-using-hooks_updating-cluster-rhel-compute">
<title>Configuring the Ansible inventory file to use hooks</title>
<simpara>You define the hooks to use when you update the Red Hat Enterprise Linux (RHEL)
compute machines, which are also known as worker machines, in the <literal>hosts</literal> inventory file under the <literal>all:vars</literal>
section.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the machine that you used to add the RHEL compute machines
cluster. You must have access to the <literal>hosts</literal> Ansible inventory file that defines
your RHEL machines.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>After you design the hook, create a YAML file that defines the Ansible tasks
for it. This file must be a set of tasks and cannot be a playbook, as shown in
the following example:</simpara>
<screen role="yaml" linenumbering="unnumbered">---
# Trivial example forcing an operator to acknowledge the start of an upgrade
# file=/home/user/openshift-ansible/hooks/pre_compute.yml

- name: note the start of a compute machine update
  debug:
      msg: "Compute machine upgrade of {{ inventory_hostname }} is about to start"

- name: require the user agree to start an upgrade
  pause:
      prompt: "Press Enter to start the compute machine update"</screen>
</listitem>
<listitem>
<simpara>Modify the <literal>hosts</literal> Ansible inventory file to specify the hook files. The
hook files are specified as parameter values in the <literal>[all:vars]</literal> section,
as shown:</simpara>
<formalpara>
<title>Example hook definitions in an inventory file</title>
<para>
<screen linenumbering="unnumbered">[all:vars]
openshift_node_pre_upgrade_hook=/home/user/openshift-ansible/hooks/pre_node.yml
openshift_node_post_upgrade_hook=/home/user/openshift-ansible/hooks/post_node.yml</screen>
</para>
</formalpara>
<simpara>To avoid ambiguity in the paths to the hook, use absolute paths instead of a
relative paths in their definitions.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="rhel-compute-available-hooks_updating-cluster-rhel-compute">
<title>Available hooks for RHEL compute machines</title>
<simpara>You can use the following hooks when you update the Red Hat Enterprise Linux (RHEL)
compute machines in your {product-title} cluster.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Hook name</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_node_pre_cordon_hook</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Runs <emphasis role="strong">before</emphasis> each node is cordoned.</simpara>
</listitem>
<listitem>
<simpara>This hook runs against <emphasis role="strong">each node</emphasis> in serial.</simpara>
</listitem>
<listitem>
<simpara>If a task must run against a different host, the task must use
<link xl:href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html"><literal>delegate_to</literal> or <literal>local_action</literal></link>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_node_pre_upgrade_hook</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Runs <emphasis role="strong">after</emphasis> each node is cordoned but <emphasis role="strong">before</emphasis> it is updated.</simpara>
</listitem>
<listitem>
<simpara>This hook runs against <emphasis role="strong">each node</emphasis> in serial.</simpara>
</listitem>
<listitem>
<simpara>If a task must run against a different host, the task must use
<link xl:href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html"><literal>delegate_to</literal> or <literal>local_action</literal></link>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_node_pre_uncordon_hook</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Runs <emphasis role="strong">after</emphasis> each node is updated but <emphasis role="strong">before</emphasis> it is uncordoned.</simpara>
</listitem>
<listitem>
<simpara>This hook runs against <emphasis role="strong">each node</emphasis> in serial.</simpara>
</listitem>
<listitem>
<simpara>If a task must run against a different host, they task must use
<link xl:href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html"><literal>delegate_to</literal> or <literal>local_action</literal></link>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift_node_post_upgrade_hook</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Runs <emphasis role="strong">after</emphasis> each node uncordoned. It is the <emphasis role="strong">last</emphasis> node update action.</simpara>
</listitem>
<listitem>
<simpara>This hook runs against <emphasis role="strong">each node</emphasis> in serial.</simpara>
</listitem>
<listitem>
<simpara>If a task must run against a different host, the task must use
<link xl:href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html"><literal>delegate_to</literal> or <literal>local_action</literal></link>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="rhel-compute-updating-minor_updating-cluster-rhel-compute">
<title>Updating RHEL compute machines in your cluster</title>
<simpara>After you update your cluster, you must update the Red Hat Enterprise Linux (RHEL) compute machines in your cluster.</simpara>
<important>
<simpara>Red Hat Enterprise Linux (RHEL) versions 8.6 and later are supported for RHEL compute machines.</simpara>
</important>
<simpara>You can also update your compute machines to another minor version of {product-title} if you are using RHEL as the operating system. You do not need to exclude any RPM packages from RHEL when performing a minor version update.</simpara>
<important>
<simpara>You cannot update RHEL 7 compute machines to RHEL 8. You must deploy new RHEL 8 hosts, and the old RHEL 7 hosts should be removed.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You updated your cluster.</simpara>
<important>
<simpara>Because the RHEL machines require assets that are generated by the cluster to complete the update process, you must update the cluster before you update the RHEL worker machines in it.</simpara>
</important>
</listitem>
<listitem>
<simpara>You have access to the local machine that you used to add the RHEL compute machines to your cluster. You must have access to the <literal>hosts</literal> Ansible inventory file that defines your RHEL machines and the <literal>upgrade</literal> playbook.</simpara>
</listitem>
<listitem>
<simpara>For updates to a minor version, the RPM repository is using the same version of {product-title} that is running on your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Stop and disable firewalld on the host:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># systemctl disable --now firewalld.service</programlisting>
<note>
<simpara>By default, the base OS RHEL with "Minimal" installation option enables firewalld service.  Having the firewalld service enabled on your host prevents you from accessing {product-title} logs on the worker. Do not enable firewalld later if you wish to continue accessing {product-title} logs on the worker.</simpara>
</note>
</listitem>
<listitem>
<simpara>Enable the repositories that are required for {product-title} {product-version}:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>On the machine that you run the Ansible playbooks, update the required repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos --disable=rhocp-4.14-for-rhel-8-x86_64-rpms \
                             --enable=rhocp-{product-version}-for-rhel-8-x86_64-rpms</programlisting>
<important>
<simpara>As of {product-title} 4.11, the Ansible playbooks are provided only for RHEL 8.  If a RHEL 7 system was used as a host for the {product-title} 4.10 Ansible playbooks, you must either update the Ansible host to RHEL 8, or create a new Ansible host on a RHEL 8 system and copy over the inventories from the old Ansible host.</simpara>
</important>
</listitem>
<listitem>
<simpara>On the machine that you run the Ansible playbooks, update the required packages, including <literal>openshift-ansible</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum update openshift-ansible openshift-clients</programlisting>
</listitem>
<listitem>
<simpara>On each RHEL compute node, update the required repositories:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># subscription-manager repos --disable=rhocp-4.14-for-rhel-8-x86_64-rpms \
                             --enable=rhocp-{product-version}-for-rhel-8-x86_64-rpms</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Update a RHEL worker machine:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Review your Ansible inventory file at <literal>/&lt;path&gt;/inventory/hosts</literal> and update its contents so that the RHEL 8 machines are listed in the <literal>[workers]</literal> section, as shown in the following example:</simpara>
<screen>[all:vars]
ansible_user=root
#ansible_become=True

openshift_kubeconfig_path="~/.kube/config"

[workers]
mycluster-rhel8-0.example.com
mycluster-rhel8-1.example.com
mycluster-rhel8-2.example.com
mycluster-rhel8-3.example.com</screen>
</listitem>
<listitem>
<simpara>Change to the <literal>openshift-ansible</literal> directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd /usr/share/ansible/openshift-ansible</programlisting>
</listitem>
<listitem>
<simpara>Run the <literal>upgrade</literal> playbook:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ansible-playbook -i /&lt;path&gt;/inventory/hosts playbooks/upgrade.yml <co xml:id="CO15-1"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>For <literal>&lt;path&gt;</literal>, specify the path to the Ansible inventory file that you created.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>upgrade</literal> playbook only updates the {product-title} packages. It does not update the operating system packages.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>After you update all of the workers, confirm that all of your cluster nodes have updated to the new version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                        STATUS                        ROLES    AGE    VERSION
mycluster-control-plane-0   Ready                         master   145m   v1.28.5
mycluster-control-plane-1   Ready                         master   145m   v1.28.5
mycluster-control-plane-2   Ready                         master   145m   v1.28.5
mycluster-rhel8-0           Ready                         worker   98m    v1.28.5
mycluster-rhel8-1           Ready                         worker   98m    v1.28.5
mycluster-rhel8-2           Ready                         worker   98m    v1.28.5
mycluster-rhel8-3           Ready                         worker   98m    v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: Update the operating system packages that were not updated by the <literal>upgrade</literal> playbook. To update packages that are not on {product-version}, use the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># yum update</programlisting>
<note>
<simpara>You do not need to exclude RPM packages if you are using the same RPM repository that you used when you installed {product-version}.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="_updating_a_cluster_in_a_disconnected_environment">
<title>Updating a cluster in a disconnected environment</title>
<section xml:id="about-restricted-network-updates">
<title>About cluster updates in a disconnected environment</title>

<simpara>A disconnected environment is one in which your cluster nodes cannot access the internet.
For this reason, you must populate a registry with the installation images.
If your registry host cannot access both the internet and the cluster, you can mirror the images to a file system that is disconnected from that environment and then bring that host or removable media across that gap.
If the local container registry and the cluster are connected to the mirror registry&#8217;s host, you can directly push the release images to the local registry.</simpara>
<simpara>A single container image registry is sufficient to host mirrored images for several clusters in the disconnected network.</simpara>
<section xml:id="about-disconnected-updates-mirroring">
<title>Mirroring {product-title} images</title>
<simpara>To update your cluster in a disconnected environment, your cluster environment must have access to a mirror registry that has the necessary images and resources for your targeted update. The following page has instructions for mirroring images onto a repository in your disconnected cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-ocp-image-repository">Mirroring {product-title} images</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-disconnected-updates-update">
<title>Performing a cluster update in a disconnected environment</title>
<simpara>You can use one of the following procedures to update a disconnected {product-title} cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/disconnected-update-osus.xml#updating-restricted-network-cluster-OSUS">Updating a cluster in a disconnected environment using the OpenShift Update Service</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/disconnected-update.xml#updating-restricted-network-cluster">Updating a cluster in a disconnected environment without the OpenShift Update Service</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-disconnected-updates-uninstalling-osus">
<title>Uninstalling the OpenShift Update Service from a cluster</title>
<simpara>You can use the following procedure to uninstall a local copy of the OpenShift Update Service (OSUS) from your cluster:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/uninstalling-osus.xml#uninstalling-osus">Uninstalling the OpenShift Update Service from a cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="mirroring-ocp-image-repository">
<title>Mirroring {product-title} images</title>

<simpara>You must mirror container images onto a mirror registry before you can update a cluster in a disconnected environment. You can also use this procedure in connected environments to ensure your clusters run only approved container images that have satisfied your organizational controls for external content.</simpara>
<note>
<simpara>Your mirror registry must be running at all times while the cluster is running.</simpara>
</note>
<simpara>The following steps outline the high-level workflow on how to mirror images to a mirror registry:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>) on all devices being used to retrieve and push release images.</simpara>
</listitem>
<listitem>
<simpara>Download the registry pull secret and add it to your cluster.</simpara>
</listitem>
<listitem>
<simpara>If you use the <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-ocp-resources-ocmirror">oc-mirror OpenShift CLI (<literal>oc</literal>) plugin</link>:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Install the oc-mirror plugin on all devices being used to retrieve and push release images.</simpara>
</listitem>
<listitem>
<simpara>Create an image set configuration file for the plugin to use when determining which release images to mirror. You can edit this configuration file later to change which release images that the plugin mirrors.</simpara>
</listitem>
<listitem>
<simpara>Mirror your targeted release images directly to a mirror registry, or to removable media and then to a mirror registry.</simpara>
</listitem>
<listitem>
<simpara>Configure your cluster to use the resources generated by the oc-mirror plugin.</simpara>
</listitem>
<listitem>
<simpara>Repeat these steps as needed to update your mirror registry.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If you use the <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#update-mirror-repository-adm-release-mirror_mirroring-ocp-image-repository"><literal>oc adm release mirror</literal> command</link>:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Set environment variables that correspond to your environment and the release images you want to mirror.</simpara>
</listitem>
<listitem>
<simpara>Mirror your targeted release images directly to a mirror registry, or to removable media and then to a mirror registry.</simpara>
</listitem>
<listitem>
<simpara>Repeat these steps as needed to update your mirror registry.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>Compared to using the <literal>oc adm release mirror</literal> command, the oc-mirror plugin has the following advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>It can mirror content other than container images.</simpara>
</listitem>
<listitem>
<simpara>After mirroring images for the first time, it is easier to update images in the registry.</simpara>
</listitem>
<listitem>
<simpara>The oc-mirror plugin provides an automated way to mirror the release payload from Quay, and also builds the latest graph data image for the OpenShift Update Service running in the disconnected environment.</simpara>
</listitem>
</itemizedlist>
<section xml:id="prerequisites_updating-mirroring-disconnected">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You must have a container image registry that supports <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2">Docker v2-2</link> in the location that will host the {product-title} cluster, such as Red Hat Quay.</simpara>
<note>
<simpara>If you use Red Hat Quay, you must use version 3.6 or later with the oc-mirror plugin. If you have an entitlement to Red Hat Quay, see the documentation on deploying Red Hat Quay <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/deploy_red_hat_quay_for_proof-of-concept_non-production_purposes/">for proof-of-concept purposes</link> or <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/deploying_the_red_hat_quay_operator_on_openshift_container_platform/index">by using the Quay Operator</link>. If you need additional assistance selecting and installing a registry, contact your sales representative or Red Hat Support.</simpara>
</note>
<simpara>If you do not have an existing solution for a container image registry, the <link xl:href="../../../installing/disconnected_install/installing-mirroring-creating-registry.xml#installing-mirroring-creating-registry">mirror registry for Red Hat OpenShift</link> is included in {product-title} subscriptions. The <emphasis>mirror registry for Red Hat OpenShift</emphasis> is a small-scale container registry that you can use to mirror {product-title} container images in disconnected installations and updates.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="updating-restricted-network-mirror-host">
<title>Preparing your mirror host</title>
<simpara>Before you perform the mirror procedure, you must prepare the host to retrieve content and push it to the remote location.</simpara>
<section xml:id="cli-installing-cli_mirroring-ocp-image-repository">
<title>Installing the OpenShift CLI by downloading the binary</title>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) to interact with
{product-title}
from a command-line interface. You can install <literal>oc</literal> on Linux, Windows, or macOS.</simpara>
<important>
<simpara>If you installed an earlier version of <literal>oc</literal>, you cannot use it to complete all of the commands in
{product-title} {product-version}.
Download and install the new version of <literal>oc</literal>.
If you are updating a cluster in a disconnected environment, install the <literal>oc</literal> version that you plan to update to.</simpara>
</important>
<bridgehead xml:id="_installing_the_openshift_cli_on_linux" renderas="sect6">Installing the OpenShift CLI on Linux</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on Linux by using the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the <link xl:href="https://access.redhat.com/downloads/content/290">{product-title} downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the architecture from the <emphasis role="strong">Product Variant</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v{product-version} Linux Client</emphasis> entry and save the file.</simpara>
</listitem>
<listitem>
<simpara>Unpack the archive:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvf &lt;file&gt;</programlisting>
</listitem>
<listitem>
<simpara>Place the <literal>oc</literal> binary in a directory that is on your <literal>PATH</literal>.</simpara>
<simpara>To check your <literal>PATH</literal>, execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
<bridgehead xml:id="_installing_the_openshift_cli_on_windows" renderas="sect6">Installing the OpenShift CLI on Windows</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on Windows by using the following procedure.
.Procedure</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <link xl:href="https://access.redhat.com/downloads/content/290">{product-title} downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v{product-version} Windows Client</emphasis> entry and save the file.</simpara>
</listitem>
<listitem>
<simpara>Unzip the archive with a ZIP program.</simpara>
</listitem>
<listitem>
<simpara>Move the <literal>oc</literal> binary to a directory that is on your <literal>PATH</literal>.</simpara>
<simpara>To check your <literal>PATH</literal>, open the command prompt and execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">C:\&gt; path</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">C:\&gt; oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
<bridgehead xml:id="_installing_the_openshift_cli_on_macos" renderas="sect6">Installing the OpenShift CLI on macOS</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on macOS by using the following procedure.
.Procedure</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <link xl:href="https://access.redhat.com/downloads/content/290">{product-title} downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v{product-version} macOS Client</emphasis> entry and save the file.</simpara>
<note>
<simpara>For macOS arm64, choose the <emphasis role="strong">OpenShift v{product-version} macOS arm64 Client</emphasis> entry.</simpara>
</note>
</listitem>
<listitem>
<simpara>Unpack and unzip the archive.</simpara>
</listitem>
<listitem>
<simpara>Move the <literal>oc</literal> binary to a directory on your PATH.</simpara>
<simpara>To check your <literal>PATH</literal>, open a terminal and execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../cli_reference/openshift_cli/extending-cli-plugins.xml#cli-installing-plugins_cli-extend-plugins">Installing and using CLI plugins</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-adding-registry-pull-secret_mirroring-ocp-image-repository">
<title>Configuring credentials that allow images to be mirrored</title>
<simpara>Create a container image registry credentials file that allows mirroring
images from Red Hat to your mirror.</simpara>
<warning>
<simpara>Do not use this image registry credentials file as the pull secret when you install a cluster. If you provide this file when you install cluster, all of the machines in the cluster will have write access to your mirror registry.</simpara>
</warning>
<warning>
<simpara>This process requires that you have write access to a container image registry on the mirror registry and adds the credentials to a registry pull secret.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You configured a mirror registry to use in your disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>You identified an image repository location on your mirror registry to mirror images into.</simpara>
</listitem>
<listitem>
<simpara>You provisioned a mirror registry account that allows images to be uploaded to that image repository.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Complete the following steps on the installation host:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download your <literal>registry.redhat.io</literal> <link xl:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link>.</simpara>
</listitem>
<listitem>
<simpara>Make a copy of your pull secret in JSON format:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat ./pull-secret | jq . &gt; &lt;path&gt;/&lt;pull_secret_file_in_json&gt; <co xml:id="CO16-1"/></programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Specify the path to the folder to store the pull secret in and a name for the JSON file that you create.</para>
</callout>
</calloutlist>
<simpara>The contents of the file resemble the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "auths": {
    "cloud.openshift.com": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "quay.io": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "registry.connect.redhat.com": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    },
    "registry.redhat.io": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    }
  }
}</programlisting>
</listitem>
<listitem>
<simpara>Optional: If using the oc-mirror plugin, save the file either as <literal>~/.docker/config.json</literal> or <literal>$XDG_RUNTIME_DIR/containers/auth.json</literal>.</simpara>
</listitem>
<listitem>
<simpara>Generate the base64-encoded user name and password or token for your mirror registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo -n '&lt;user_name&gt;:&lt;password&gt;' | base64 -w0 <co xml:id="CO17-1"/>
BGVtbYk3ZHAtqXs=</programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>For <literal>&lt;user_name&gt;</literal> and <literal>&lt;password&gt;</literal>, specify the user name and password that you configured for your registry.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit the JSON
file and add a section that describes your registry to it:</simpara>
<programlisting language="json" linenumbering="unnumbered">  "auths": {
    "&lt;mirror_registry&gt;": { <co xml:id="CO18-1"/>
      "auth": "&lt;credentials&gt;", <co xml:id="CO18-2"/>
      "email": "you@example.com"
    }
  },</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>For <literal>&lt;mirror_registry&gt;</literal>, specify the registry domain name, and optionally the
port, that your mirror registry uses to serve content. For example,
<literal>registry.example.com</literal> or <literal>registry.example.com:8443</literal></para>
</callout>
<callout arearefs="CO18-2">
<para>For <literal>&lt;credentials&gt;</literal>, specify the base64-encoded user name and password for
the mirror registry.</para>
</callout>
</calloutlist>
<simpara>The file resembles the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "auths": {
    "registry.example.com": {
      "auth": "BGVtbYk3ZHAtqXs=",
      "email": "you@example.com"
    },
    "cloud.openshift.com": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "quay.io": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "registry.connect.redhat.com": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    },
    "registry.redhat.io": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    }
  }
}</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="mirroring-ocp-resources-ocmirror">
<title>Mirroring resources using the oc-mirror plugin</title>
<simpara>You can use the oc-mirror OpenShift CLI (<literal>oc</literal>) plugin to mirror images to a mirror registry in your fully or partially disconnected environments. You must run oc-mirror from a system with internet connectivity to download the required images from the official Red Hat registries.</simpara>
<section xml:id="installation-oc-mirror-about_mirroring-ocp-image-repository">
<title>About the oc-mirror plugin</title>
<simpara>You can use the oc-mirror OpenShift CLI (<literal>oc</literal>) plugin to mirror all required {product-title} content and other images to your mirror registry by using a single tool. It provides the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Provides a centralized method to mirror {product-title} releases, Operators, helm charts, and other images.</simpara>
</listitem>
<listitem>
<simpara>Maintains update paths for {product-title} and Operators.</simpara>
</listitem>
<listitem>
<simpara>Uses a declarative image set configuration file to include only the {product-title} releases, Operators, and images that your cluster needs.</simpara>
</listitem>
<listitem>
<simpara>Performs incremental mirroring, which reduces the size of future image sets.</simpara>
</listitem>
<listitem>
<simpara>Prunes images from the target mirror registry that were excluded from the image set configuration since the previous execution.</simpara>
</listitem>
<listitem>
<simpara>Optionally generates supporting artifacts for OpenShift Update Service (OSUS) usage.</simpara>
</listitem>
</itemizedlist>
<simpara>When using the oc-mirror plugin, you specify which content to mirror in an image set configuration file. In this YAML file, you can fine-tune the configuration to only include the {product-title} releases and Operators that your cluster needs. This reduces the amount of data that you need to download and transfer. The oc-mirror plugin can also mirror arbitrary helm charts and additional container images to assist users in seamlessly synchronizing their workloads onto mirror registries.</simpara>
<simpara>The first time you run the oc-mirror plugin, it populates your mirror registry with the required content to perform your disconnected cluster installation or update. In order for your disconnected cluster to continue receiving updates, you must keep your mirror registry updated. To update your mirror registry, you run the oc-mirror plugin using the same configuration as the first time you ran it. The oc-mirror plugin references the metadata from the storage backend and only downloads what has been released since the last time you ran the tool. This provides update paths for {product-title} and Operators and performs dependency resolution as required.</simpara>
<important>
<simpara>When using the oc-mirror CLI plugin to populate a mirror registry, any further updates to the mirror registry must be made using the oc-mirror tool.</simpara>
</important>
</section>
<section xml:id="oc-mirror-support_mirroring-ocp-image-repository">
<title>oc-mirror compatibility and support</title>
<simpara>The oc-mirror plugin supports mirroring {product-title} payload images and Operator catalogs for {product-title} versions 4.10 and later.</simpara>
<note>
<simpara>On <literal>aarch64</literal>, <literal>ppc64le</literal>, and <literal>s390x</literal> architectures the oc-mirror plugin is only supported for {product-title} versions 4.14 and later.</simpara>
</note>
<simpara>Use the latest available version of the oc-mirror plugin regardless of which versions of {product-title} you need to mirror.</simpara>
<important>
<simpara>If you used the Technology Preview OCI local catalogs feature for the oc-mirror plugin for {product-title} 4.12, you can no longer use the OCI local catalogs feature of the oc-mirror plugin to copy a catalog locally and convert it to OCI format as a first step to mirroring to a fully disconnected cluster.</simpara>
</important>
</section>
<section xml:id="installation-about-mirror-registry_mirroring-ocp-image-repository">
<title>About the mirror registry</title>
<simpara>You can mirror the images that are required for {product-title} installation and subsequent product updates to a container mirror registry that supports <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2">Docker v2-2</link>, such as Red Hat Quay. If you do not have access to a large-scale container registry, you can use the <emphasis>mirror registry for Red Hat OpenShift</emphasis>, which is a small-scale container registry included with {product-title} subscriptions.</simpara>
<simpara>Regardless of your chosen registry, the procedure to mirror content from Red Hat hosted sites on the internet to an isolated image registry is the same. After you mirror the content, you configure each cluster to retrieve this content from your mirror registry.</simpara>
<important>
<simpara>The OpenShift image registry cannot be used as the target registry because it does not support pushing without a tag, which is required during the mirroring process.</simpara>
</important>
<simpara>If choosing a container registry that is not the <emphasis>mirror registry for Red Hat OpenShift</emphasis>, it must be reachable by every machine in the clusters that you provision. If the registry is unreachable, installation, updating, or normal operations such as workload relocation might fail. For that reason, you must run mirror registries in a highly available way, and the mirror registries must at least match the production availability of your {product-title} clusters.</simpara>
<simpara>When you populate your mirror registry with {product-title} images, you can follow two scenarios. If you have a host that can access both the internet and your mirror registry, but not your cluster nodes, you can directly mirror the content from that machine. This process is referred to as <emphasis>connected mirroring</emphasis>. If you have no such host, you must mirror the images to a file system and then bring that host or removable media into your restricted environment. This process is referred to as <emphasis>disconnected mirroring</emphasis>.</simpara>
<simpara>For mirrored registries, to view the source of pulled images, you must review the <literal>Trying to access</literal> log entry in the CRI-O logs. Other methods to view the image pull source, such as using the <literal>crictl images</literal> command on a node, show the non-mirrored image name, even though the image is pulled from the mirrored location.</simpara>
<note>
<simpara>Red Hat does not test third party registries with {product-title}.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For information about viewing the CRI-O logs to view the image source, see <link xl:href="../../../installing/validating-an-installation.xml#viewing-the-image-pull-source_validating-an-installation">Viewing the image pull source</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-oc-mirror-installing-plugin_mirroring-ocp-image-repository">
<title>Installing the oc-mirror OpenShift CLI plugin</title>
<simpara>To use the oc-mirror OpenShift CLI plugin to mirror registry images, you must install the plugin. If you are mirroring image sets in a fully disconnected environment, ensure that you install the oc-mirror plugin on the host with internet access and the host in the disconnected environment with access to the mirror registry.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Download the oc-mirror CLI plugin.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to the <link xl:href="https://console.redhat.com/openshift/downloads">Downloads</link> page of the <link xl:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">OpenShift disconnected installation tools</emphasis> section, click <emphasis role="strong">Download</emphasis> for <emphasis role="strong">OpenShift Client (oc) mirror plugin</emphasis> and save the file.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Extract the archive:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvzf oc-mirror.tar.gz</programlisting>
</listitem>
<listitem>
<simpara>If necessary, update the plugin file to be executable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ chmod +x oc-mirror</programlisting>
<note>
<simpara>Do not rename the <literal>oc-mirror</literal> file.</simpara>
</note>
</listitem>
<listitem>
<simpara>Install the oc-mirror CLI plugin by placing the file in your <literal>PATH</literal>, for example, <literal>/usr/local/bin</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo mv oc-mirror /usr/local/bin/.</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Run <literal>oc mirror help</literal> to verify that the plugin was successfully installed:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror help</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="oc-mirror-creating-image-set-config_mirroring-ocp-image-repository">
<title>Creating the image set configuration</title>
<simpara>Before you can use the oc-mirror plugin to mirror image sets, you must create an image set configuration file. This image set configuration file defines which {product-title} releases, Operators, and other images to mirror, along with other configuration settings for the oc-mirror plugin.</simpara>
<simpara>You must specify a storage backend in the image set configuration file. This storage backend can be a local directory or a registry that supports <link xl:href="https://docs.docker.com/registry/spec/manifest-v2-2">Docker v2-2</link>. The oc-mirror plugin stores metadata in this storage backend during image set creation.</simpara>
<important>
<simpara>Do not delete or modify the metadata that is generated by the oc-mirror plugin. You must use the same storage backend every time you run the oc-mirror plugin for the same mirror registry.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created a container image registry credentials file. For instructions, see <emphasis>Configuring credentials that allow images to be mirrored</emphasis>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>oc mirror init</literal> command to create a template for the image set configuration and save it to a file called <literal>imageset-config.yaml</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror init --registry example.com/mirror/oc-mirror-metadata &gt; imageset-config.yaml <co xml:id="CO19-1"/></programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Replace <literal>example.com/mirror/oc-mirror-metadata</literal> with the location of your registry for the storage backend.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit the file and adjust the settings as necessary:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageSetConfiguration
apiVersion: mirror.openshift.io/v1alpha2
archiveSize: 4                                                      <co xml:id="CO20-1"/>
storageConfig:                                                      <co xml:id="CO20-2"/>
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata                 <co xml:id="CO20-3"/>
    skipTLS: false
mirror:
  platform:
    channels:
    - name: stable-{product-version}                                             <co xml:id="CO20-4"/>
      type: ocp
    graph: true                                                     <co xml:id="CO20-5"/>
  operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}  <co xml:id="CO20-6"/>
    packages:
    - name: serverless-operator                                     <co xml:id="CO20-7"/>
      channels:
      - name: stable                                                <co xml:id="CO20-8"/>
  additionalImages:
  - name: registry.redhat.io/ubi9/ubi:latest                        <co xml:id="CO20-9"/>
  helm: {}</programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Add <literal>archiveSize</literal> to set the maximum size, in GiB, of each file within the image set.</para>
</callout>
<callout arearefs="CO20-2">
<para>Set the back-end location to save the image set metadata to. This location can be a registry or local directory. It is required to specify <literal>storageConfig</literal> values.</para>
</callout>
<callout arearefs="CO20-3">
<para>Set the registry URL for the storage backend.</para>
</callout>
<callout arearefs="CO20-4">
<para>Set the channel to retrieve the {product-title} images from.</para>
</callout>
<callout arearefs="CO20-5">
<para>Add <literal>graph: true</literal> to build and push the graph-data image to the mirror registry. The graph-data image is required to create OpenShift Update Service (OSUS). The <literal>graph: true</literal> field also generates the <literal>UpdateService</literal> custom resource manifest. The <literal>oc</literal> command-line interface (CLI) can use the <literal>UpdateService</literal> custom resource manifest to create OSUS. For more information, see <emphasis>About the OpenShift Update Service</emphasis>.</para>
</callout>
<callout arearefs="CO20-6">
<para>Set the Operator catalog to retrieve the {product-title} images from.</para>
</callout>
<callout arearefs="CO20-7">
<para>Specify only certain Operator packages to include in the image set. Remove this field to retrieve all packages in the catalog.</para>
</callout>
<callout arearefs="CO20-8">
<para>Specify only certain channels of the Operator packages to include in the image set. You must always include the default channel for the Operator package even if you do not use the bundles in that channel. You can find the default channel by running the following command: <literal>oc mirror list operators --catalog=&lt;catalog_name&gt; --package=&lt;package_name&gt;</literal>.</para>
</callout>
<callout arearefs="CO20-9">
<para>Specify any additional images to include in image set.</para>
</callout>
</calloutlist>
<note>
<simpara>The <literal>graph: true</literal> field also mirrors the <literal>ubi-micro</literal> image along with other mirrored images.</simpara>
</note>
<simpara>See <emphasis>Image set configuration parameters</emphasis> for the full list of parameters and <emphasis>Image set configuration examples</emphasis> for various mirroring use cases.</simpara>
</listitem>
<listitem>
<simpara>Save the updated file.</simpara>
<simpara>This image set configuration file is required by the <literal>oc mirror</literal> command when mirroring content.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-imageset-config-params_mirroring-ocp-image-repository">Image set configuration parameters</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-image-set-examples_mirroring-ocp-image-repository">Image set configuration examples</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/understanding_updates/intro-to-updates.xml#update-service-about_understanding-openshift-updates">About the OpenShift Update Service</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="mirroring-image-set">
<title>Mirroring an image set to a mirror registry</title>
<simpara>You can use the oc-mirror CLI plugin to mirror images to a mirror registry in a <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-image-set-partial">partially disconnected environment</link> or in a <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-image-set-full">fully disconnected environment</link>.</simpara>
<simpara>The following procedures assume that you already have your mirror registry set up.</simpara>
<section xml:id="mirroring-image-set-partial">
<title>Mirroring an image set in a partially disconnected environment</title>
<simpara>In a partially disconnected environment, you can mirror an image set directly to the target mirror registry.</simpara>
<section xml:id="oc-mirror-mirror-to-mirror_mirroring-ocp-image-repository">
<title>Mirroring from mirror to mirror</title>
<simpara>You can use the oc-mirror plugin to mirror an image set directly to a target mirror registry that is accessible during image set creation.</simpara>
<simpara>You are required to specify a storage backend in the image set configuration file. This storage backend can be a local directory or a Docker v2 registry. The oc-mirror plugin stores metadata in this storage backend during image set creation.</simpara>
<important>
<simpara>Do not delete or modify the metadata that is generated by the oc-mirror plugin. You must use the same storage backend every time you run the oc-mirror plugin for the same mirror registry.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the internet to obtain the necessary container images.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc-mirror</literal> CLI plugin.</simpara>
</listitem>
<listitem>
<simpara>You have created the image set configuration file.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the <literal>oc mirror</literal> command to mirror the images from the specified image set configuration to a specified registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror --config=./imageset-config.yaml \<co xml:id="CO21-1"/>
  docker://registry.example:5000             <co xml:id="CO21-2"/></programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Pass in the image set configuration file that was created. This procedure assumes that it is named <literal>imageset-config.yaml</literal>.</para>
</callout>
<callout arearefs="CO21-2">
<para>Specify the registry to mirror the image set file to. The registry must start with <literal>docker://</literal>. If you specify a top-level namespace for the mirror registry, you must also use this same namespace on subsequent executions.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate into the <literal>oc-mirror-workspace/</literal> directory that was generated.</simpara>
</listitem>
<listitem>
<simpara>Navigate into the results directory, for example, <literal>results-1639608409/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Verify that YAML files are present for the <literal>ImageContentSourcePolicy</literal> and <literal>CatalogSource</literal> resources.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The <literal>repositoryDigestMirrors</literal> section of the <literal>ImageContentSourcePolicy</literal> YAML file is used for the <literal>install-config.yaml</literal> file during installation.</simpara>
</note>
<simpara>+</simpara>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Configure your cluster to use the resources generated by oc-mirror.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Troubleshooting</title>
<listitem>
<simpara><link xl:href="https://access.redhat.com/solutions/7032017">Unable to retrieve source image</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="mirroring-image-set-full">
<title>Mirroring an image set in a fully disconnected environment</title>
<simpara>To mirror an image set in a fully disconnected environment, you must first <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-mirror-to-disk_mirroring-ocp-image-repository">mirror the image set to disk</link>, then <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-disk-to-mirror_mirroring-ocp-image-repository">mirror the image set file on disk to a mirror</link>.</simpara>
<section xml:id="oc-mirror-mirror-to-disk_mirroring-ocp-image-repository">
<title>Mirroring from mirror to disk</title>
<simpara>You can use the oc-mirror plugin to generate an image set and save the contents to disk. The generated image set can then be transferred to the disconnected environment and mirrored to the target registry.</simpara>
<important>
<simpara>Depending on the configuration specified in the image set configuration file, using oc-mirror to mirror images might download several hundreds of gigabytes of data to disk.</simpara>
<simpara>The initial image set download when you populate the mirror registry is often the largest. Because you only download the images that changed since the last time you ran the command, when you run the oc-mirror plugin again, the generated image set is often smaller.</simpara>
</important>
<simpara>You are required to specify a storage backend in the image set configuration file. This storage backend can be a local directory or a docker v2 registry. The oc-mirror plugin stores metadata in this storage backend during image set creation.</simpara>
<important>
<simpara>Do not delete or modify the metadata that is generated by the oc-mirror plugin. You must use the same storage backend every time you run the oc-mirror plugin for the same mirror registry.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the internet to obtain the necessary container images.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc-mirror</literal> CLI plugin.</simpara>
</listitem>
<listitem>
<simpara>You have created the image set configuration file.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the <literal>oc mirror</literal> command to mirror the images from the specified image set configuration to disk:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror --config=./imageset-config.yaml \<co xml:id="CO22-1"/>
  file://&lt;path_to_output_directory&gt;          <co xml:id="CO22-2"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>Pass in the image set configuration file that was created. This procedure assumes that it is named <literal>imageset-config.yaml</literal>.</para>
</callout>
<callout arearefs="CO22-2">
<para>Specify the target directory where you want to output the image set file. The target directory path must start with <literal>file://</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate to your output directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd &lt;path_to_output_directory&gt;</programlisting>
</listitem>
<listitem>
<simpara>Verify that an image set <literal>.tar</literal> file was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">mirror_seq1_000000.tar</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Transfer the image set .tar file to the disconnected environment.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Troubleshooting</title>
<listitem>
<simpara><link xl:href="https://access.redhat.com/solutions/7032017">Unable to retrieve source image</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="oc-mirror-disk-to-mirror_mirroring-ocp-image-repository">
<title>Mirroring from disk to mirror</title>
<simpara>You can use the oc-mirror plugin to mirror the contents of a generated image set to the target mirror registry.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>) in the disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc-mirror</literal> CLI plugin in the disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>You have generated the image set file by using the <literal>oc mirror</literal> command.</simpara>
</listitem>
<listitem>
<simpara>You have transferred the image set file to the disconnected environment.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the <literal>oc mirror</literal> command to process the image set file on disk and mirror the contents to a target mirror registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror --from=./mirror_seq1_000000.tar \<co xml:id="CO23-1"/>
  docker://registry.example:5000             <co xml:id="CO23-2"/></programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>Pass in the image set .tar file to mirror, named <literal>mirror_seq1_000000.tar</literal> in this example. If an <literal>archiveSize</literal> value was specified in the image set configuration file, the image set might be broken up into multiple .tar files. In this situation, you can pass in a directory that contains the image set .tar files.</para>
</callout>
<callout arearefs="CO23-2">
<para>Specify the registry to mirror the image set file to. The registry must start with <literal>docker://</literal>. If you specify a top-level namespace for the mirror registry, you must also use this same namespace on subsequent executions.</para>
</callout>
</calloutlist>
<simpara>This command updates the mirror registry with the image set and generates the <literal>ImageContentSourcePolicy</literal> and <literal>CatalogSource</literal> resources.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Navigate into the <literal>oc-mirror-workspace/</literal> directory that was generated.</simpara>
</listitem>
<listitem>
<simpara>Navigate into the results directory, for example, <literal>results-1639608409/</literal>.</simpara>
</listitem>
<listitem>
<simpara>Verify that YAML files are present for the <literal>ImageContentSourcePolicy</literal> and <literal>CatalogSource</literal> resources.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Configure your cluster to use the resources generated by oc-mirror.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Troubleshooting</title>
<listitem>
<simpara><link xl:href="https://access.redhat.com/solutions/7032017">Unable to retrieve source image</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="oc-mirror-updating-cluster-manifests_mirroring-ocp-image-repository">
<title>Configuring your cluster to use the resources generated by oc-mirror</title>
<simpara>After you have mirrored your image set to the mirror registry, you must apply the generated <literal>ImageContentSourcePolicy</literal>, <literal>CatalogSource</literal>, and release image signature resources into the cluster.</simpara>
<simpara>The <literal>ImageContentSourcePolicy</literal> resource associates the mirror registry with the source registry and redirects image pull requests from the online registries to the mirror registry. The <literal>CatalogSource</literal> resource is used by Operator Lifecycle Manager (OLM) to retrieve information about the available Operators in the mirror registry. The release image signatures are used to verify the mirrored release images.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have mirrored the image set to the registry mirror in the disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift CLI as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Apply the YAML files from the results directory to the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f ./oc-mirror-workspace/results-1639608409/</programlisting>
</listitem>
<listitem>
<simpara>If you mirrored release images, apply the release image signatures to the cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f ./oc-mirror-workspace/results-1639608409/release-signatures/</programlisting>
<note>
<simpara>If you are mirroring Operators instead of clusters, you do not need to run <literal>$ oc apply -f ./oc-mirror-workspace/results-1639608409/release-signatures/</literal>. Running that command will return an error, as there are no release image signatures to apply.</simpara>
</note>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Verify that the <literal>ImageContentSourcePolicy</literal> resources were successfully installed by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get imagecontentsourcepolicy --all-namespaces</programlisting>
</listitem>
<listitem>
<simpara>Verify that the <literal>CatalogSource</literal> resources were successfully installed by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get catalogsource --all-namespaces</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="updating-mirror-registry-content">
<title>Keeping your mirror registry content updated</title>
<simpara>After you populate your target mirror registry with the initial image set, you must update it regularly so that it has the latest content. If possible, you can set up a cron job to update the mirror registry on a regular basis.</simpara>
<simpara>Update your image set configuration to add or remove {product-title} and Operator releases as necessary. Removed images are pruned from the mirror registry.</simpara>
<section xml:id="oc-mirror-updating-registry-about_mirroring-ocp-image-repository">
<title>About updating your mirror registry content</title>
<simpara>When you run the oc-mirror plugin again, it generates an image set that only contains new and updated images since the previous execution. Because it only pulls in the differences since the previous image set was created, the generated image set is often smaller and faster to process than the initial image set.</simpara>
<important>
<simpara>Generated image sets are sequential and must be pushed to the target mirror registry in order. You can derive the sequence number from the file name of the generated image set archive file.</simpara>
</important>
<bridgehead xml:id="_adding_new_and_updated_images" renderas="sect7">Adding new and updated images</bridgehead>
<simpara>Depending on the settings in your image set configuration, future executions of oc-mirror can mirror additional new and updated images. Review the settings in your image set configuration to ensure that you are retrieving new versions as necessary. For example, you can set the minimum and maximum versions of Operators to mirror if you want to restrict to specific versions. Alternatively, you can set the minimum version as a starting point to mirror, but keep the version range open so you keep receiving new Operator versions on future executions of oc-mirror. Omitting any minimum or maximum version gives you the full version history of an Operator in a channel. Omitting explicitly named channels gives you all releases in all channels of the specified Operator. Omitting any named Operator gives you the entire catalog of all Operators and all their versions ever released.</simpara>
<simpara>All these constraints and conditions are evaluated against the publicly released content by Red Hat on every invocation of oc-mirror. This way, it automatically picks up new releases and entirely new Operators. Constraints can be specified by only listing a desired set of Operators, which will not automatically add other newly released Operators into the mirror set. You can also specify a particular release channel, which limits mirroring to just this channel and not any new channels that have been added. This is important for Operator products, such as Red Hat Quay, that use different release channels for their minor releases. Lastly, you can specify a maximum version of a particular Operator, which causes the tool to only mirror the specified version range so that you do not automatically get any newer releases past the maximum version mirrored. In all these cases, you must update the image set configuration file to broaden the scope of the mirroring of Operators to get other Operators, new channels, and newer versions of Operators to be available in your target registry.</simpara>
<simpara>It is recommended to align constraints like channel specification or version ranges with the release strategy that a particular Operator has chosen. For example, when the Operator uses a <literal>stable</literal> channel, you should restrict mirroring to that channel and potentially a minimum version to find the right balance between download volume and getting stable updates regularly. If the Operator chooses a release version channel scheme, for example <literal>stable-3.7</literal>, you should mirror all releases in that channel. This allows you to keep receiving patch versions of the Operator, for example <literal>3.7.1</literal>. You can also regularly adjust the image set configuration to add channels for new product releases, for example <literal>stable-3.8</literal>.</simpara>
<bridgehead xml:id="_pruning_images" renderas="sect7">Pruning images</bridgehead>
<simpara>Images are pruned automatically from the target mirror registry if they are no longer included in the latest image set that was generated and mirrored. This allows you to easily manage and clean up unneeded content and reclaim storage resources.</simpara>
<simpara>If there are {product-title} releases or Operator versions that you no longer need, you can modify your image set configuration to exclude them, and they will be pruned from the mirror registry upon mirroring. This can be done by adjusting a minimum or maximum version range setting per Operator in the image set configuration file or by deleting the Operator from the list of Operators to mirror from the catalog. You can also remove entire Operator catalogs or entire {product-title} releases from the configuration file.</simpara>
<important>
<simpara>If there are no new or updated images to mirror, the excluded images are not pruned from the target mirror registry. Additionally, if an Operator publisher removes an Operator version from a channel, the removed versions are pruned from the target mirror registry.</simpara>
</important>
<simpara>To disable automatic pruning of images from the target mirror registry, pass the <literal>--skip-pruning</literal> flag to the <literal>oc mirror</literal> command.</simpara>
</section>
<section xml:id="oc-mirror-differential-updates_mirroring-ocp-image-repository">
<title>Updating your mirror registry content</title>
<simpara>After you publish the initial image set to the mirror registry, you can use the oc-mirror plugin to keep your disconnected clusters updated.</simpara>
<simpara>Depending on your image set configuration, oc-mirror automatically detects newer releases of {product-title} and your selected Operators that have been released after you completed the inital mirror. It is recommended to run oc-mirror at regular intervals, for example in a nightly cron job, to receive product and security updates on a timely basis.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have used the oc-mirror plugin to mirror the initial image set to your mirror registry.</simpara>
</listitem>
<listitem>
<simpara>You have access to the storage backend that was used for the initial execution of the oc-mirror plugin.</simpara>
<note>
<simpara>You must use the same storage backend as the initial execution of oc-mirror for the same mirror registry. Do not delete or modify the metadata image that is generated by the oc-mirror plugin.</simpara>
</note>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If necessary, update your image set configuration file to pick up new {product-title} and Operator versions. See <emphasis>Image set configuration examples</emphasis> for example mirroring use cases.</simpara>
</listitem>
<listitem>
<simpara>Follow the same steps that you used to mirror your initial image set to the mirror registry. For instructions, see <emphasis>Mirroring an image set in a partially disconnected environment</emphasis> or <emphasis>Mirroring an image set in a fully disconnected environment</emphasis>.</simpara>
<important>
<itemizedlist>
<listitem>
<simpara>You must provide the same storage backend so that only a differential image set is created and mirrored.</simpara>
</listitem>
<listitem>
<simpara>If you specified a top-level namespace for the mirror registry during the initial image set creation, then you must use this same namespace every time you run the oc-mirror plugin for the same mirror registry.</simpara>
</listitem>
</itemizedlist>
</important>
</listitem>
<listitem>
<simpara>Configure your cluster to use the resources generated by oc-mirror.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-image-set-examples_mirroring-ocp-image-repository">Image set configuration examples</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-image-set-partial">Mirroring an image set in a partially disconnected environment</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-image-set-full">Mirroring an image set in a fully disconnected environment</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#oc-mirror-updating-cluster-manifests_mirroring-ocp-image-repository">Configuring your cluster to use the resources generated by oc-mirror</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="oc-mirror-dry-run_mirroring-ocp-image-repository">
<title>Performing a dry run</title>
<simpara>You can use oc-mirror to perform a dry run, without actually mirroring any images. This allows you to review the list of images that would be mirrored, as well as any images that would be pruned from the mirror registry. It also allows you to catch any errors with your image set configuration early or use the generated list of images with other tools to carry out the mirroring operation.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the internet to obtain the necessary container images.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc-mirror</literal> CLI plugin.</simpara>
</listitem>
<listitem>
<simpara>You have created the image set configuration file.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the <literal>oc mirror</literal> command with the <literal>--dry-run</literal> flag to perform a dry run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror --config=./imageset-config.yaml \<co xml:id="CO24-1"/>
  docker://registry.example:5000            \<co xml:id="CO24-2"/>
  --dry-run                                  <co xml:id="CO24-3"/></programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>Pass in the image set configuration file that was created. This procedure assumes that it is named <literal>imageset-config.yaml</literal>.</para>
</callout>
<callout arearefs="CO24-2">
<para>Specify the mirror registry. Nothing is mirrored to this registry as long as you use the <literal>--dry-run</literal> flag.</para>
</callout>
<callout arearefs="CO24-3">
<para>Use the <literal>--dry-run</literal> flag to generate the dry run artifacts and not an actual image set file.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Checking push permissions for registry.example:5000
Creating directory: oc-mirror-workspace/src/publish
Creating directory: oc-mirror-workspace/src/v2
Creating directory: oc-mirror-workspace/src/charts
Creating directory: oc-mirror-workspace/src/release-signatures
No metadata detected, creating new workspace
wrote mirroring manifests to oc-mirror-workspace/operators.1658342351/manifests-redhat-operator-index

...

info: Planning completed in 31.48s
info: Dry run complete
Writing image mapping to oc-mirror-workspace/mapping.txt</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Navigate into the workspace directory that was generated:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd oc-mirror-workspace/</programlisting>
</listitem>
<listitem>
<simpara>Review the <literal>mapping.txt</literal> file that was generated.</simpara>
<simpara>This file contains a list of all images that would be mirrored.</simpara>
</listitem>
<listitem>
<simpara>Review the <literal>pruning-plan.json</literal> file that was generated.</simpara>
<simpara>This file contains a list of all images that would be pruned from the mirror registry when the image set is published.</simpara>
<note>
<simpara>The <literal>pruning-plan.json</literal> file is only generated if your oc-mirror command points to your mirror registry and there are images to be pruned.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="oc-mirror-oci-format_mirroring-ocp-image-repository">
<title>Including local OCI Operator catalogs</title>
<simpara>While mirroring {product-title} releases, Operator catalogs, and additional images from a registry to a partially disconnected cluster, you can include Operator catalog images from a local file-based catalog on disk. The local catalog must be in the Open Container Initiative (OCI) format.</simpara>
<simpara>The local catalog and its contents are mirrored to your target mirror registry based on the filtering information in the image set configuration file.</simpara>
<important>
<simpara>When mirroring local OCI catalogs, any {product-title} releases or additional images that you want to mirror along with the local OCI-formatted catalog must be pulled from a registry.</simpara>
<simpara>You cannot mirror OCI catalogs along with an oc-mirror image set file on disk.</simpara>
</important>
<simpara>One example use case for using the OCI feature is if you have a CI/CD system building an OCI catalog to a location on disk, and you want to mirror that OCI catalog along with an {product-title} release to your mirror registry.</simpara>
<note>
<simpara>If you used the Technology Preview OCI local catalogs feature for the oc-mirror plugin for {product-title} 4.12, you can no longer use the OCI local catalogs feature of the oc-mirror plugin to copy a catalog locally and convert it to OCI format as a first step to mirroring to a fully disconnected cluster.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the internet to obtain the necessary container images.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have installed the <literal>oc-mirror</literal> CLI plugin.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the image set configuration file and adjust the settings as necessary.</simpara>
<simpara>The following example image set configuration mirrors an OCI catalog on disk along with an {product-title} release and a UBI image from <literal>registry.redhat.io</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageSetConfiguration
apiVersion: mirror.openshift.io/v1alpha2
storageConfig:
  local:
    path: /home/user/metadata                                                <co xml:id="CO25-1"/>
mirror:
  platform:
    channels:
    - name: stable-{product-version}                                                      <co xml:id="CO25-2"/>
      type: ocp
    graph: false
  operators:
  - catalog: oci:///home/user/oc-mirror/my-oci-catalog                       <co xml:id="CO25-3"/>
    targetCatalog: my-namespace/redhat-operator-index                        <co xml:id="CO25-4"/>
    packages:
    - name: aws-load-balancer-operator
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}           <co xml:id="CO25-5"/>
    packages:
    - name: rhacs-operator
  additionalImages:
  - name: registry.redhat.io/ubi9/ubi:latest                                 <co xml:id="CO25-6"/></programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>Set the back-end location to save the image set metadata to. This location can be a registry or local directory. It is required to specify <literal>storageConfig</literal> values.</para>
</callout>
<callout arearefs="CO25-2">
<para>Optionally, include an {product-title} release to mirror from <literal>registry.redhat.io</literal>.</para>
</callout>
<callout arearefs="CO25-3">
<para>Specify the absolute path to the location of the OCI catalog on disk. The path must start with <literal>oci://</literal> when using the OCI feature.</para>
</callout>
<callout arearefs="CO25-4">
<para>Optionally, specify an alternative namespace and name to mirror the catalog as.</para>
</callout>
<callout arearefs="CO25-5">
<para>Optionally, specify additional Operator catalogs to pull from a registry.</para>
</callout>
<callout arearefs="CO25-6">
<para>Optionally, specify additional images to pull from a registry.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Run the <literal>oc mirror</literal> command to mirror the OCI catalog to a target mirror registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc mirror --config=./imageset-config.yaml \ <co xml:id="CO26-1"/>
  docker://registry.example:5000              <co xml:id="CO26-2"/></programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para>Pass in the image set configuration file. This procedure assumes that it is named <literal>imageset-config.yaml</literal>.</para>
</callout>
<callout arearefs="CO26-2">
<para>Specify the registry to mirror the content to. The registry must start with <literal>docker://</literal>. If you specify a top-level namespace for the mirror registry, you must also use this same namespace on subsequent executions.</para>
</callout>
</calloutlist>
<simpara>Optionally, you can specify other flags to adjust the behavior of the OCI feature:</simpara>
<variablelist>
<varlistentry>
<term><literal>--oci-insecure-signature-policy</literal></term>
<listitem>
<simpara>Do not push signatures to the target mirror registry.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>--oci-registries-config</literal></term>
<listitem>
<simpara>Specify the path to a TOML-formatted <literal>registries.conf</literal> file. You can use this to mirror from a different registry, such as a pre-production location for testing, without having to change the image set configuration file. This flag only affects local OCI catalogs, not any other mirrored content.</simpara>
<formalpara>
<title>Example registries.conf file</title>
<para>
<programlisting language="toml" linenumbering="unnumbered">[[registry]]
 location = "registry.redhat.io:5000"
 insecure = false
 blocked = false
 mirror-by-digest-only = true
 prefix = ""
 [[registry.mirror]]
    location = "preprod-registry.example.com"
    insecure = false</programlisting>
</para>
</formalpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>Configure your cluster to use the resources generated by oc-mirror.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-managing-custom-catalogs.xml#olm-managing-custom-catalogs-fb">File-based catalogs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="oc-mirror-imageset-config-params_mirroring-ocp-image-repository">
<title>Image set configuration parameters</title>
<simpara>The oc-mirror plugin requires an image set configuration file that defines what images to mirror. The following table lists the available parameters for the <literal>ImageSetConfiguration</literal> resource.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>ImageSetConfiguration</literal> parameters</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Values</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The API version for the <literal>ImageSetConfiguration</literal> content.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>mirror.openshift.io/v1alpha2</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>archiveSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The maximum size, in GiB, of each archive file within the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Integer. For example: <literal>4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.additionalImages</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The additional images configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">additionalImages:
  - name: registry.redhat.io/ubi8/ubi:latest</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.additionalImages.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The tag or digest of the image to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>registry.redhat.io/ubi8/ubi:latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.blockedImages</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The full tag, digest, or pattern of images to block from mirroring.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of strings. For example: <literal>docker.io/library/alpine</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The helm configuration of the image set. Note that the oc-mirror plugin supports only helm charts that do not require user input when rendered.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.local</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The local helm charts to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">local:
  - name: podinfo
    path: /test/podinfo-5.0.0.tar.gz</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.local.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the local helm chart to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>podinfo</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.local.path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The path of the local helm chart to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>/test/podinfo-5.0.0.tar.gz</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The remote helm repositories to mirror from.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">repositories:
  - name: podinfo
    url: https://example.github.io/podinfo
    charts:
      - name: podinfo
        version: 5.0.0</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the helm repository to mirror from.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>podinfo</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories.url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The URL of the helm repository to mirror from.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>https://example.github.io/podinfo</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories.charts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The remote helm charts to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories.charts.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the helm chart to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>podinfo</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.helm.repositories.charts.version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The version of the named helm chart to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>5.0.0</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operators configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
    packages:
      - name: elasticsearch-operator
        minVersion: '2.4.0'</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.catalog</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator catalog to include in the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>registry.redhat.io/redhat/redhat-operator-index:v4.15</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.full</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When <literal>true</literal>, downloads the full catalog, Operator package, or Operator channel.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator packages configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
    packages:
      - name: elasticsearch-operator
        minVersion: '5.2.3-31'</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator package name to include in the image set</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>elasticsearch-operator</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.channels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator package channel configuration.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.channels.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The Operator channel name, unique within a package, to include in the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>fast</literal> or <literal>stable-v4.15</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.channels.maxVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The highest version of the Operator mirror across all channels in which it exists. See the following note for further information.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>5.2.3-31</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.channels.minBundle</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the minimum bundle to include, plus all bundles in the update graph to the channel head. Set this field only if the named bundle has no semantic version metadata.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>bundleName</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.channels.minVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The lowest version of the Operator to mirror across all channels in which it exists. See the following note for further information.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>5.2.3-31</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.maxVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The highest version of the Operator to mirror across all channels in which it exists. See the following note for further information.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>5.2.3-31</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.packages.minVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The lowest version of the Operator to mirror across all channels in which it exists. See the following note for further information.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>5.2.3-31</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.skipDependencies</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, dependencies of bundles are not included.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.targetCatalog</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An alternative name and optional namespace hierarchy to mirror the referenced catalog as.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>my-namespace/my-operator-catalog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.targetName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An alternative name to mirror the referenced catalog as.</simpara>
<simpara>The <literal>targetName</literal> parameter is deprecated. Use the <literal>targetCatalog</literal> parameter instead.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>my-operator-catalog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.operators.targetTag</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An alternative tag to append to the <literal>targetName</literal> or <literal>targetCatalog</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>v1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The platform configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.architectures</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The architecture of the platform release payload to mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of strings. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">architectures:
  - amd64
  - arm64
  - multi
  - ppc64le
  - s390x</programlisting>
<simpara>The default value is <literal>amd64</literal>. The value <literal>multi</literal> ensures that the mirroring is supported for all available architectures, eliminating the need to specify individual architectures.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The platform channel configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Array of objects. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">channels:
  - name: stable-4.10
  - name: stable-{product-version}</programlisting></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.full</literal></simpara></entry>
<entry align="left" valign="top"><simpara>When <literal>true</literal>, sets the <literal>minVersion</literal> to the first release in the channel and the <literal>maxVersion</literal> to the last release in the channel.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name of the release channel.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>stable-4.15</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.minVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The minimum version of the referenced platform to be mirrored.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>4.12.6</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.maxVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The highest version of the referenced platform to be mirrored.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>4.15.1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.shortestPath</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Toggles shortest path mirroring or full range mirroring.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.channels.type</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The type of the platform to be mirrored.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>ocp</literal> or <literal>okd</literal>. The default is <literal>ocp</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mirror.platform.graph</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicates whether the OSUS graph is added to the image set and subsequently published to the mirror.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The back-end configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig.local</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The local back-end configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig.local.path</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The path of the directory to contain the image set metadata.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>./path/to/dir/</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig.registry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The registry back-end configuration of the image set.</simpara></entry>
<entry align="left" valign="top"><simpara>Object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig.registry.imageURL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The back-end registry URI. Can optionally include a namespace reference in the URI.</simpara></entry>
<entry align="left" valign="top"><simpara>String. For example: <literal>quay.io/myuser/imageset:metadata</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>storageConfig.registry.skipTLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optionally skip TLS verification of the referenced back-end registry.</simpara></entry>
<entry align="left" valign="top"><simpara>Boolean. The default value is <literal>false</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<note>
<simpara>Using the <literal>minVersion</literal> and <literal>maxVersion</literal> properties to filter for a specific Operator version range can result in a multiple channel heads error. The error message will state that there are <literal>multiple channel heads</literal>. This is because when the filter is applied, the update graph of the operator is truncated.</simpara>
<simpara>The Operator Lifecycle Manager requires that every operator channel contains versions that form an update graph with exactly one end point, that is, the latest version of the operator. When applying the filter range that graph can turn into two or more separate graphs or a graph that has more than one end point.</simpara>
<simpara>To avoid this error, do not filter out the latest version of an operator. If you still run into the error, depending on the operator, either the <literal>maxVersion</literal> property needs to be increased or the <literal>minVersion</literal> property needs to be decreased. Because every operator graph can be different, you might need to adjust these values, according to the procedure, until the error is gone.</simpara>
</note>
</section>
<section xml:id="oc-mirror-image-set-examples_mirroring-ocp-image-repository">
<title>Image set configuration examples</title>
<simpara>The following <literal>ImageSetConfiguration</literal> file examples show the configuration for various mirroring use cases.</simpara>
<bridgehead xml:id="oc-mirror-image-set-examples-shortest-upgrade-path_mirroring-ocp-image-repository" renderas="sect6">Use case: Including the shortest {product-title} update path</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file uses a local storage backend and includes all {product-title} versions along the shortest update path from the minimum version of <literal>4.11.37</literal> to the maximum version of <literal>4.12.15</literal>.</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  local:
    path: /home/user/metadata
mirror:
  platform:
    channels:
      - name: stable-4.12
        minVersion: 4.11.37
        maxVersion: 4.12.15
        shortestPath: true</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-minimum-to-latest_mirroring-ocp-image-repository" renderas="sect6">Use case: Including all versions of {product-title} from a minimum to the latest version for multi-architecture releases</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file uses a registry storage backend and includes all {product-title} versions starting at a minimum version of <literal>4.13.4</literal> to the latest version in the channel. On every invocation of oc-mirror with this image set configuration, the latest release of the <literal>stable-4.13</literal> channel is evaluated, so running oc-mirror at regular intervals ensures that you automatically receive the latest releases of {product-title} images.</simpara>
<simpara>By setting the value of <literal>platform.architectures</literal> to <literal>multi</literal>, you can ensure that the mirroring is supported for multi-architecture releases.</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata
    skipTLS: false
mirror:
  platform:
    architectures:
      - "multi"
    channels:
      - name: stable-4.13
        minVersion: 4.13.4
        maxVersion: 4.13.6</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-operator-versions_mirroring-ocp-image-repository" renderas="sect6">Use case: Including Operator versions from a minimum to the latest</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file uses a local storage backend and includes only the Red Hat Advanced Cluster Security for Kubernetes Operator, versions starting at 4.0.1 and later in the <literal>stable</literal> channel.</simpara>
<note>
<simpara>When you specify a minimum or maximum version range, you might not receive all Operator versions in that range.</simpara>
<simpara>By default, oc-mirror excludes any versions that are skipped or replaced by a newer version in the Operator Lifecycle Manager (OLM) specification. Operator versions that are skipped might be affected by a CVE or contain bugs. Use a newer version instead. For more information on skipped and replaced versions, see <link xl:href="https://olm.operatorframework.io/docs/concepts/olm-architecture/operator-catalog/creating-an-update-graph/">Creating an update graph with OLM</link>.</simpara>
<simpara>To receive all Operator versions in a specified range, you can set the <literal>mirror.operators.full</literal> field to <literal>true</literal>.</simpara>
</note>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  local:
    path: /home/user/metadata
mirror:
  operators:
    - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
      packages:
        - name: rhacs-operator
          channels:
          - name: stable
            minVersion: 4.0.1</programlisting>
</para>
</formalpara>
<note>
<simpara>To specify a maximum version instead of the latest, set the <literal>mirror.operators.packages.channels.maxVersion</literal> field.</simpara>
</note>
<bridgehead xml:id="oc-mirror-image-set-examples-nutanix-operator_mirroring-ocp-image-repository" renderas="sect6">Use case: Including the Nutanix CSI Operator</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file uses a local storage backend and includes the Nutanix CSI Operator, the OpenShift Update Service (OSUS) graph image, and an additional Red Hat Universal Base Image (UBI).</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageSetConfiguration
apiVersion: mirror.openshift.io/v1alpha2
storageConfig:
  registry:
    imageURL: mylocalregistry/ocp-mirror/openshift4
    skipTLS: false
mirror:
  platform:
    channels:
    - name: stable-4.11
      type: ocp
    graph: true
  operators:
  - catalog: registry.redhat.io/redhat/certified-operator-index:v{product-version}
    packages:
    - name: nutanixcsioperator
      channels:
      - name: stable
  additionalImages:
  - name: registry.redhat.io/ubi9/ubi:latest</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-default-channel_mirroring-ocp-image-repository" renderas="sect6">Use case: Including the default Operator channel</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file includes the <literal>stable-5.7</literal> and <literal>stable</literal> channels for the OpenShift Elasticsearch Operator. Even if only the packages from the <literal>stable-5.7</literal> channel are needed, the <literal>stable</literal> channel must also be included in the <literal>ImageSetConfiguration</literal> file, because it is the default channel for the Operator. You must always include the default channel for the Operator package even if you do not use the bundles in that channel.</simpara>
<tip>
<simpara>You can find the default channel by running the following command: <literal>oc mirror list operators --catalog=&lt;catalog_name&gt; --package=&lt;package_name&gt;</literal>.</simpara>
</tip>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata
    skipTLS: false
mirror:
  operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
    packages:
    - name: elasticsearch-operator
      channels:
      - name: stable-5.7
      - name: stable</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-entire-catalog-full_mirroring-ocp-image-repository" renderas="sect6">Use case: Including an entire catalog (all versions)</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file sets the <literal>mirror.operators.full</literal> field to <literal>true</literal> to include all versions for an entire Operator catalog.</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata
    skipTLS: false
mirror:
  operators:
    - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
      full: true</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-entire-catalog-heads_mirroring-ocp-image-repository" renderas="sect6">Use case: Including an entire catalog (channel heads only)</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file includes the channel heads for an entire Operator catalog.</simpara>
<simpara>By default, for each Operator in the catalog, oc-mirror includes the latest Operator version (channel head) from the default channel. If you want to mirror all Operator versions, and not just the channel heads, you must set the <literal>mirror.operators.full</literal> field to <literal>true</literal>.</simpara>
<simpara>This example also uses the <literal>targetCatalog</literal> field to specify an alternative namespace and name to mirror the catalog as.</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
storageConfig:
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata
    skipTLS: false
mirror:
  operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
    targetCatalog: my-namespace/my-operator-catalog</programlisting>
</para>
</formalpara>
<bridgehead xml:id="oc-mirror-image-set-examples-helm_mirroring-ocp-image-repository" renderas="sect6">Use case: Including arbitrary images and helm charts</bridgehead>
<simpara>The following <literal>ImageSetConfiguration</literal> file uses a registry storage backend and includes helm charts and an additional Red Hat Universal Base Image (UBI).</simpara>
<formalpara>
<title>Example <literal>ImageSetConfiguration</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: mirror.openshift.io/v1alpha2
kind: ImageSetConfiguration
archiveSize: 4
storageConfig:
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata
    skipTLS: false
mirror:
 platform:
   architectures:
     - "s390x"
   channels:
     - name: stable-{product-version}
 operators:
   - catalog: registry.redhat.io/redhat/redhat-operator-index:v{product-version}
 helm:
   repositories:
     - name: redhat-helm-charts
       url: https://raw.githubusercontent.com/redhat-developer/redhat-helm-charts/master
       charts:
         - name: ibm-mongodb-enterprise-helm
           version: 0.2.0
 additionalImages:
   - name: registry.redhat.io/ubi9/ubi:latest</programlisting>
</para>
</formalpara>
</section>
<section xml:id="oc-mirror-command-reference_mirroring-ocp-image-repository">
<title>Command reference for oc-mirror</title>
<simpara>The following tables describe the <literal>oc mirror</literal> subcommands and flags:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>oc mirror subcommands</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Subcommand</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>completion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate the autocompletion script for the specified shell.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>describe</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output the contents of an image set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show help about any subcommand.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>init</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output an initial image set configuration template.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara>List available platform and Operator content and their version.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output the oc-mirror version.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>oc mirror flags</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Flag</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>-c</literal>, <literal>--config</literal> <literal>&lt;string&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify the path to an image set configuration file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--continue-on-error</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If any non image-pull related error occurs, continue and attempt to mirror as much as possible.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--dest-skip-tls</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable TLS validation for the target registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--dest-use-http</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Use plain HTTP for the target registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--dry-run</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print actions without mirroring images. Generates <literal>mapping.txt</literal> and <literal>pruning-plan.json</literal> files.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--from &lt;string&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify the path to an image set archive that was generated by an execution of oc-mirror to load into a target registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-h</literal>, <literal>--help</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show the help.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--ignore-history</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Ignore past mirrors when downloading images and packing layers. Disables incremental mirroring and might download more data.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--manifests-only</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Generate manifests for <literal>ImageContentSourcePolicy</literal> objects to configure a cluster to use the mirror registry, but do not actually mirror any images. To use this flag, you must pass in an image set archive with the <literal>--from</literal> flag.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--max-nested-paths &lt;int&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify the maximum number of nested paths for destination registries that limit nested paths. The default is <literal>0</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--max-per-registry &lt;int&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify the number of concurrent requests allowed per registry. The default is <literal>6</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--oci-insecure-signature-policy</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Do not push signatures when mirroring local OCI catalogs (with <literal>--include-local-oci-catalogs</literal>).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--oci-registries-config</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provide a registries configuration file to specify an alternative registry location to copy from when mirroring local OCI catalogs (with <literal>--include-local-oci-catalogs</literal>).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-cleanup</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Skip removal of artifact directories.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-image-pin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Do not replace image tags with digest pins in Operator catalogs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-metadata-check</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Skip metadata when publishing an image set. This is only recommended when the image set was created with <literal>--ignore-history</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-missing</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If an image is not found, skip it instead of reporting an error and aborting execution. Does not apply to custom images explicitly specified in the image set configuration.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-pruning</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable automatic pruning of images from the target mirror registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--skip-verification</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Skip digest verification.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--source-skip-tls</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disable TLS validation for the source registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>--source-use-http</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Use plain HTTP for the source registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>-v</literal>, <literal>--verbose</literal> <literal>&lt;int&gt;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify the number for the log level verbosity. Valid values are <literal>0</literal> - <literal>9</literal>. The default is <literal>0</literal>.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="update-mirror-repository-adm-release-mirror_mirroring-ocp-image-repository">
<title>Mirroring images using the oc adm release mirror command</title>
<important>
<simpara>To avoid excessive memory usage by the OpenShift Update Service application, you must mirror release images to a separate repository as described in the following procedure.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You configured a mirror registry to use in your disconnected environment and can access the certificate and credentials that you configured.</simpara>
</listitem>
<listitem>
<simpara>You downloaded the <link xl:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link> and modified it to include authentication to your mirror repository.</simpara>
</listitem>
<listitem>
<simpara>If you use self-signed certificates, you have specified a Subject Alternative Name in the certificates.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the <link xl:href="https://access.redhat.com/labs/ocpupgradegraph/update_channel">Red Hat {product-title} Update Graph visualizer and update planner</link> to plan an update from one version to another. The OpenShift Update Graph provides channel graphs and a way to confirm that there is an update path between your current and intended cluster versions.</simpara>
</listitem>
<listitem>
<simpara>Set the required environment variables:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the release version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ export OCP_RELEASE=&lt;release_version&gt;</programlisting>
<simpara>For <literal>&lt;release_version&gt;</literal>, specify the tag that corresponds to the version of {product-title} to which you want to update, such as <literal>4.5.4</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the local registry name and host port:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_REGISTRY='&lt;local_registry_host_name&gt;:&lt;local_registry_host_port&gt;'</programlisting>
<simpara>For <literal>&lt;local_registry_host_name&gt;</literal>, specify the registry domain name for your mirror
repository, and for <literal>&lt;local_registry_host_port&gt;</literal>, specify the port that it
serves content on.</simpara>
</listitem>
<listitem>
<simpara>Export the local repository name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_REPOSITORY='&lt;local_repository_name&gt;'</programlisting>
<simpara>For <literal>&lt;local_repository_name&gt;</literal>, specify the name of the repository to create in your
registry, such as <literal>ocp4/openshift4</literal>.</simpara>
</listitem>
<listitem>
<simpara>If you are using the OpenShift Update Service, export an additional local repository name to contain the release images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_RELEASE_IMAGES_REPOSITORY='&lt;local_release_images_repository_name&gt;'</programlisting>
<simpara>For <literal>&lt;local_release_images_repository_name&gt;</literal>, specify the name of the repository to
create in your registry, such as <literal>ocp4/openshift4-release-images</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the name of the repository to mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ PRODUCT_REPO='openshift-release-dev'</programlisting>
<simpara>For a production release, you must specify <literal>openshift-release-dev</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the path to your registry pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_SECRET_JSON='&lt;path_to_pull_secret&gt;'</programlisting>
<simpara>For <literal>&lt;path_to_pull_secret&gt;</literal>, specify the absolute path to and file name of the pull secret for your mirror registry that you created.</simpara>
<note>
<simpara>If your cluster uses an <literal>ImageContentSourcePolicy</literal> object to configure repository mirroring, you can use only global pull secrets for mirrored registries. You cannot add a pull secret to a project.</simpara>
</note>
</listitem>
<listitem>
<simpara>Export the release mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RELEASE_NAME="ocp-release"</programlisting>
<simpara>For a production release, you must specify <literal>ocp-release</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the type of architecture for your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ARCHITECTURE=&lt;cluster_architecture&gt; <co xml:id="CO27-1"/></programlisting>
<calloutlist>
<callout arearefs="CO27-1">
<para>Specify the architecture of the cluster, such as <literal>x86_64</literal>, <literal>aarch64</literal>, <literal>s390x</literal>, or <literal>ppc64le</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Export the path to the directory to host the mirrored images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ REMOVABLE_MEDIA_PATH=&lt;path&gt; <co xml:id="CO28-1"/></programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>Specify the full path, including the initial forward slash (/) character.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Review the images and configuration manifests to mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON} --to-dir=${REMOVABLE_MEDIA_PATH}/mirror quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE} --dry-run</programlisting>
</listitem>
<listitem>
<simpara>Mirror the version images to the mirror registry.</simpara>
<itemizedlist>
<listitem>
<simpara>If your mirror host does not have internet access, take the following actions:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Connect the removable media to a system that is connected to the internet.</simpara>
</listitem>
<listitem>
<simpara>Mirror the images and configuration manifests to a directory on the removable media:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON} --to-dir=${REMOVABLE_MEDIA_PATH}/mirror quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE}</programlisting>
<note>
<simpara>This command also generates and saves the mirrored release image signature config map onto the removable media.</simpara>
</note>
</listitem>
<listitem>
<simpara>Take the media to the disconnected environment and upload the images to the local container registry.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image mirror  -a ${LOCAL_SECRET_JSON} --from-dir=${REMOVABLE_MEDIA_PATH}/mirror "file://openshift/release:${OCP_RELEASE}*" ${LOCAL_REGISTRY}/${LOCAL_REPOSITORY} <co xml:id="CO29-1"/></programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para>For <literal>REMOVABLE_MEDIA_PATH</literal>, you must use the same path that you specified when you mirrored the images.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Use <literal>oc</literal> command-line interface (CLI) to log in to the cluster that you are updating.</simpara>
</listitem>
<listitem>
<simpara>Apply the mirrored release image signature config map to the connected cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f ${REMOVABLE_MEDIA_PATH}/mirror/config/&lt;image_signature_file&gt; <co xml:id="CO30-1"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>For <literal>&lt;image_signature_file&gt;</literal>, specify the path and name of the file, for example, <literal>signature-sha256-81154f5c03294534.yaml</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>If you are using the OpenShift Update Service, mirror the release image to a separate repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image mirror -a ${LOCAL_SECRET_JSON} ${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE} ${LOCAL_REGISTRY}/${LOCAL_RELEASE_IMAGES_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE}</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If the local container registry and the cluster are connected to the mirror host, take the following actions:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Directly push the release images to the local registry and apply the config map  to the cluster by using following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON} --from=quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE} \
  --to=${LOCAL_REGISTRY}/${LOCAL_REPOSITORY} --apply-release-image-signature</programlisting>
<note>
<simpara>If you include the <literal>--apply-release-image-signature</literal> option, do not create the config map for image signature verification.</simpara>
</note>
</listitem>
<listitem>
<simpara>If you are using the OpenShift Update Service, mirror the release image to a separate repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image mirror -a ${LOCAL_SECRET_JSON} ${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE} ${LOCAL_REGISTRY}/${LOCAL_RELEASE_IMAGES_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE}</programlisting>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="updating-restricted-network-cluster-OSUS">
<title>Updating a cluster in a disconnected environment using the OpenShift Update Service</title>

<simpara>To get an update experience similar to connected clusters, you can use the following procedures to install and configure the OpenShift Update Service (OSUS) in a disconnected environment.</simpara>
<simpara>The following steps outline the high-level workflow on how to update a cluster in a disconnected environment using OSUS:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Configure access to a secured registry.</simpara>
</listitem>
<listitem>
<simpara>Update the global cluster pull secret to access your mirror registry.</simpara>
</listitem>
<listitem>
<simpara>Install the OSUS Operator.</simpara>
</listitem>
<listitem>
<simpara>Create a graph data container image for the OpenShift Update Service.</simpara>
</listitem>
<listitem>
<simpara>Install the OSUS application and configure your clusters to use the local OpenShift Update Service.</simpara>
</listitem>
<listitem>
<simpara>Perform a supported update procedure from the documentation as you would with a connected cluster.</simpara>
</listitem>
</orderedlist>
<section xml:id="update-service-overview_updating-restricted-network-cluster-osus">
<title>Using the OpenShift Update Service in a disconnected environment</title>
<simpara>The OpenShift Update Service (OSUS) provides update recommendations to {product-title} clusters. Red Hat publicly hosts the OpenShift Update Service, and clusters in a connected environment can connect to the service through public APIs to retrieve update recommendations.</simpara>
<simpara>However, clusters in a disconnected environment cannot access these public APIs to retrieve update information. To have a similar update experience in a disconnected environment, you can install and configure the OpenShift Update Service locally so that it is available within the disconnected environment.</simpara>
<simpara>A single OSUS instance is capable of serving recommendations to thousands of clusters.
OSUS can be scaled horizontally to cater to more clusters by changing the replica value.
So for most disconnected use cases, one OSUS instance is enough.
For example, Red Hat hosts just one OSUS instance for the entire fleet of connected clusters.</simpara>
<simpara>If you want to keep update recommendations separate in different environments, you can run one OSUS instance for each environment.
For example, in a case where you have separate test and stage environments, you might not want a cluster in a stage environment to receive update recommendations to version A if that version has not been tested in the test environment yet.</simpara>
<simpara>The following sections describe how to install a local OSUS instance and configure it to provide update recommendations to a cluster.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../updating/understanding_updates/intro-to-updates.xml#update-service-about_understanding-openshift-updates">About the OpenShift Update Service</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="update-service-prereqs">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You must have the <literal>oc</literal> command-line interface (CLI) tool installed.</simpara>
</listitem>
<listitem>
<simpara>You must provision a local container image registry with the container images for your update, as described in <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-ocp-image-repository">Mirroring {product-title} images</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="registry-configuration-for-update-service">
<title>Configuring access to a secured registry for the OpenShift Update Service</title>
<simpara>If the release images are contained in a registry whose HTTPS X.509 certificate is signed by a custom certificate authority, complete the steps in <link xl:href="../../../registry/configuring-registry-operator.xml#images-configuration-cas_configuring-registry-operator">Configuring additional trust stores for image registry access</link> along with following changes for the update service.</simpara>
<simpara>The OpenShift Update Service Operator needs the config map key name <literal>updateservice-registry</literal> in the registry CA cert.</simpara>
<formalpara>
<title>Image registry CA config map example for the update service</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-registry-ca
data:
  updateservice-registry: | <co xml:id="CO31-1"/>
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----
  registry-with-port.example.com..5000: | <co xml:id="CO31-2"/>
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO31-1">
<para>The OpenShift Update Service Operator requires the config map key name updateservice-registry in the registry CA cert.</para>
</callout>
<callout arearefs="CO31-2">
<para>If the registry has the port, such as <literal>registry-with-port.example.com:5000</literal>, <literal>:</literal> should be replaced with <literal>..</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="images-update-global-pull-secret_updating-restricted-network-cluster-osus">
<title>Updating the global cluster pull secret</title>
<simpara>You can update the global pull secret for your cluster by either replacing the current pull secret or appending a new pull secret.</simpara>
<simpara>The procedure is required when users use a separate registry to store images than the registry used during installation.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: To append a new pull secret to the existing pull secret, complete the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter the following command to download the pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret/pull-secret -n openshift-config --template='{{index .data ".dockerconfigjson" | base64decode}}' &gt;&lt;pull_secret_location&gt; <co xml:id="CO32-1"/></programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>Provide the path to the pull secret file.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enter the following command to add the new pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc registry login --registry="&lt;registry&gt;" \ <co xml:id="CO33-1"/>
--auth-basic="&lt;username&gt;:&lt;password&gt;" \ <co xml:id="CO33-2"/>
--to=&lt;pull_secret_location&gt; <co xml:id="CO33-3"/></programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para>Provide the new registry. You can include multiple repositories within the same registry, for example: <literal>--registry="&lt;registry/my-namespace/my-repository&gt;"</literal>.</para>
</callout>
<callout arearefs="CO33-2">
<para>Provide the credentials of the new registry.</para>
</callout>
<callout arearefs="CO33-3">
<para>Provide the path to the pull secret file.</para>
</callout>
</calloutlist>
<simpara>Alternatively, you can perform a manual update to the pull secret file.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enter the following command to update the global pull secret for your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set data secret/pull-secret -n openshift-config --from-file=.dockerconfigjson=&lt;pull_secret_location&gt; <co xml:id="CO34-1"/></programlisting>
<calloutlist>
<callout arearefs="CO34-1">
<para>Provide the path to the new pull secret file.</para>
</callout>
</calloutlist>
<simpara>This update is rolled out to all nodes, which can take some time depending on the size of your cluster.</simpara>
<note>
<simpara>As of {product-title} 4.7.4, changes to the global pull secret no longer trigger a node drain or reboot.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-install">
<title>Installing the OpenShift Update Service Operator</title>
<simpara>To install the OpenShift Update Service, you must first install the OpenShift Update Service Operator by using the {product-title} web console or CLI.</simpara>
<note>
<simpara>For clusters that are installed in disconnected environments, also known as disconnected clusters, Operator Lifecycle Manager by default cannot access the Red Hat-provided OperatorHub sources hosted on remote registries because those remote sources require full internet connectivity. For more information, see <link xl:href="../../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link>.</simpara>
</note>
<section xml:id="update-service-install-web-console_updating-restricted-network-cluster-osus">
<title>Installing the OpenShift Update Service Operator by using the web console</title>
<simpara>You can use the web console to install the OpenShift Update Service Operator.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
<note>
<simpara>Enter <literal>Update Service</literal> into the <emphasis role="strong">Filter by keyword&#8230;&#8203;</emphasis> field to find the Operator faster.</simpara>
</note>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">OpenShift Update Service</emphasis> from the list of available Operators, and click <emphasis role="strong">Install</emphasis>.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select an <emphasis role="strong">Update channel</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a <emphasis role="strong">Version</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">A specific namespace on the cluster</emphasis> under <emphasis role="strong">Installation Mode</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select a namespace for <emphasis role="strong">Installed Namespace</emphasis> or accept the recommended namespace <literal>openshift-update-service</literal>.</simpara>
</listitem>
<listitem>
<simpara>Select an <emphasis role="strong">Update approval</emphasis> strategy:</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis role="strong">Automatic</emphasis> strategy allows Operator Lifecycle Manager (OLM) to automatically update the Operator when a new version is available.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis role="strong">Manual</emphasis> strategy requires a cluster administrator to approve the Operator update.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Go to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> and verify that the OpenShift Update Service Operator is installed.</simpara>
</listitem>
<listitem>
<simpara>Ensure that <emphasis role="strong">OpenShift Update Service</emphasis> is listed in the correct namespace with a <emphasis role="strong">Status</emphasis> of <emphasis role="strong">Succeeded</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-install-cli_updating-restricted-network-cluster-osus">
<title>Installing the OpenShift Update Service Operator by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to install the OpenShift Update Service Operator.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a namespace for the OpenShift Update Service Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a <literal>Namespace</literal> object YAML file, for example, <literal>update-service-namespace.yaml</literal>, for the OpenShift Update Service Operator:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  name: openshift-update-service
  annotations:
    openshift.io/node-selector: ""
  labels:
    openshift.io/cluster-monitoring: "true" <co xml:id="CO35-1"/></programlisting>
<calloutlist>
<callout arearefs="CO35-1">
<para>Set the <literal>openshift.io/cluster-monitoring</literal> label to enable Operator-recommended cluster monitoring on this namespace.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the namespace:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f update-service-namespace.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the OpenShift Update Service Operator by creating the following objects:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object YAML file, for example, <literal>update-service-operator-group.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: update-service-operator-group
spec:
  targetNamespaces:
  - openshift-update-service</programlisting>
</listitem>
<listitem>
<simpara>Create an <literal>OperatorGroup</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-update-service create -f &lt;filename&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-update-service create -f update-service-operator-group.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>Subscription</literal> object YAML file, for example, <literal>update-service-subscription.yaml</literal>:</simpara>
<formalpara>
<title>Example Subscription</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: update-service-subscription
spec:
  channel: v1
  installPlanApproval: "Automatic"
  source: "redhat-operators" <co xml:id="CO36-1"/>
  sourceNamespace: "openshift-marketplace"
  name: "cincinnati-operator"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO36-1">
<para>Specify the name of the catalog source that provides the Operator. For clusters that do not use a custom Operator Lifecycle Manager (OLM), specify <literal>redhat-operators</literal>. If your {product-title} cluster is installed in a disconnected environment, specify the name of the <literal>CatalogSource</literal> object created when you configured Operator Lifecycle Manager (OLM).</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;.yaml</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-update-service create -f update-service-subscription.yaml</programlisting>
<simpara>The OpenShift Update Service Operator is installed to the <literal>openshift-update-service</literal> namespace and targets the <literal>openshift-update-service</literal> namespace.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify the Operator installation:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-update-service get clusterserviceversions</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                             DISPLAY                    VERSION   REPLACES   PHASE
update-service-operator.v4.6.0   OpenShift Update Service   4.6.0                Succeeded
...</programlisting>
</para>
</formalpara>
<simpara>If the OpenShift Update Service Operator is listed, the installation was successful. The version number might be different than shown.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../operators/user/olm-installing-operators-in-namespace.xml#olm-installing-operators-in-namespace">Installing Operators in your namespace</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="update-service-graph-data_updating-restricted-network-cluster-osus">
<title>Creating the OpenShift Update Service graph data container image</title>
<simpara>The OpenShift Update Service requires a graph data container image, from which the OpenShift Update Service retrieves information about channel membership and blocked update edges. Graph data is typically fetched directly from the update graph data repository. In environments where an internet connection is unavailable, loading this information from an init container is another way to make the graph data available to the OpenShift Update Service. The role of the init container is to provide a local copy of the graph data, and during pod initialization, the init container copies the data to a volume that is accessible by the service.</simpara>
<note>
<simpara>The oc-mirror OpenShift CLI (<literal>oc</literal>) plugin creates this graph data container image in addition to mirroring release images. If you used the oc-mirror plugin to mirror your release images, you can skip this procedure.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a Dockerfile, for example, <literal>./Dockerfile</literal>, containing the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM registry.access.redhat.com/ubi9/ubi:latest

RUN curl -L -o cincinnati-graph-data.tar.gz https://api.openshift.com/api/upgrades_info/graph-data

RUN mkdir -p /var/lib/cincinnati-graph-data &amp;&amp; tar xvzf cincinnati-graph-data.tar.gz -C /var/lib/cincinnati-graph-data/ --no-overwrite-dir --no-same-owner

CMD ["/bin/bash", "-c" ,"exec cp -rp /var/lib/cincinnati-graph-data/* /var/lib/cincinnati/graph-data"]</programlisting>
</listitem>
<listitem>
<simpara>Use the docker file created in the above step to build a graph data container image, for example, <literal>registry.example.com/openshift/graph-data:latest</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build -f ./Dockerfile -t registry.example.com/openshift/graph-data:latest</programlisting>
</listitem>
<listitem>
<simpara>Push the graph data container image created in the previous step to a repository that is accessible to the OpenShift Update Service, for example, <literal>registry.example.com/openshift/graph-data:latest</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman push registry.example.com/openshift/graph-data:latest</programlisting>
<note>
<simpara>To push a graph data image to a local registry in a disconnected environment, copy the graph data container image created in the previous step to a repository that is accessible to the OpenShift Update Service. Run <literal>oc image mirror --help</literal> for available options.</simpara>
</note>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-create-service">
<title>Creating an OpenShift Update Service application</title>
<simpara>You can create an OpenShift Update Service application by using the {product-title} web console or CLI.</simpara>
<section xml:id="update-service-create-service-web-console_updating-restricted-network-cluster-osus">
<title>Creating an OpenShift Update Service application by using the web console</title>
<simpara>You can use the {product-title} web console to create an OpenShift Update Service application by using the OpenShift Update Service Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The OpenShift Update Service Operator has been installed.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Update Service graph data container image has been created and pushed to a repository that is accessible to the OpenShift Update Service.</simpara>
</listitem>
<listitem>
<simpara>The current release and update target releases have been mirrored to a locally accessible registry.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">OpenShift Update Service</emphasis> from the list of installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Update Service</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create UpdateService</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a name in the <emphasis role="strong">Name</emphasis> field, for example, <literal>service</literal>.</simpara>
</listitem>
<listitem>
<simpara>Enter the local pullspec in the <emphasis role="strong">Graph Data Image</emphasis> field to the graph data container image created in "Creating the OpenShift Update Service graph data container image", for example, <literal>registry.example.com/openshift/graph-data:latest</literal>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Releases</emphasis> field, enter the local registry and repository created to contain the release images in "Mirroring the OpenShift Container Platform image repository", for example, <literal>registry.example.com/ocp4/openshift4-release-images</literal>.</simpara>
</listitem>
<listitem>
<simpara>Enter <literal>2</literal> in the <emphasis role="strong">Replicas</emphasis> field.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the OpenShift Update Service application.</simpara>
</listitem>
<listitem>
<simpara>Verify the OpenShift Update Service application:</simpara>
<itemizedlist>
<listitem>
<simpara>From the <emphasis role="strong">UpdateServices</emphasis> list in the <emphasis role="strong">Update Service</emphasis> tab, click the Update Service application just created.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Resources</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Verify each application resource has a status of <emphasis role="strong">Created</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-create-service-cli_updating-restricted-network-cluster-osus">
<title>Creating an OpenShift Update Service application by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to create an OpenShift Update Service application.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The OpenShift Update Service Operator has been installed.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Update Service graph data container image has been created and pushed to a repository that is accessible to the OpenShift Update Service.</simpara>
</listitem>
<listitem>
<simpara>The current release and update target releases have been mirrored to a locally accessible registry.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure the OpenShift Update Service target namespace, for example, <literal>openshift-update-service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ NAMESPACE=openshift-update-service</programlisting>
<simpara>The namespace must match the <literal>targetNamespaces</literal> value from the operator group.</simpara>
</listitem>
<listitem>
<simpara>Configure the name of the OpenShift Update Service application, for example, <literal>service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ NAME=service</programlisting>
</listitem>
<listitem>
<simpara>Configure the local registry and repository for the release images as configured in "Mirroring the {product-title} image repository", for example, <literal>registry.example.com/ocp4/openshift4-release-images</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RELEASE_IMAGES=registry.example.com/ocp4/openshift4-release-images</programlisting>
</listitem>
<listitem>
<simpara>Set the local pullspec for the graph data image to the graph data container image created in "Creating the OpenShift Update Service graph data container image", for example, <literal>registry.example.com/openshift/graph-data:latest</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ GRAPH_DATA_IMAGE=registry.example.com/openshift/graph-data:latest</programlisting>
</listitem>
<listitem>
<simpara>Create an OpenShift Update Service application object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n "${NAMESPACE}" create -f - &lt;&lt;EOF
apiVersion: updateservice.operator.openshift.io/v1
kind: UpdateService
metadata:
  name: ${NAME}
spec:
  replicas: 2
  releases: ${RELEASE_IMAGES}
  graphDataImage: ${GRAPH_DATA_IMAGE}
EOF</programlisting>
</listitem>
<listitem>
<simpara>Verify the OpenShift Update Service application:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Use the following command to obtain a policy engine route:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ while sleep 1; do POLICY_ENGINE_GRAPH_URI="$(oc -n "${NAMESPACE}" get -o jsonpath='{.status.policyEngineURI}/api/upgrades_info/v1/graph{"\n"}' updateservice "${NAME}")"; SCHEME="${POLICY_ENGINE_GRAPH_URI%%:*}"; if test "${SCHEME}" = http -o "${SCHEME}" = https; then break; fi; done</programlisting>
<simpara>You might need to poll until the command succeeds.</simpara>
</listitem>
<listitem>
<simpara>Retrieve a graph from the policy engine. Be sure to specify a valid version for <literal>channel</literal>. For example, if running in {product-title} {product-version}, use <literal>stable-{product-version}</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ while sleep 10; do HTTP_CODE="$(curl --header Accept:application/json --output /dev/stderr --write-out "%{http_code}" "${POLICY_ENGINE_GRAPH_URI}?channel=stable-4.6")"; if test "${HTTP_CODE}" -eq 200; then break; fi; echo "${HTTP_CODE}"; done</programlisting>
<simpara>This polls until the graph request succeeds; however, the resulting graph might be empty depending on which release images you have mirrored.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>The policy engine route name must not be more than 63 characters based on RFC-1123. If you see <literal>ReconcileCompleted</literal> status as <literal>false</literal>  with the reason <literal>CreateRouteFailed</literal> caused by <literal>host must conform to DNS 1123 naming convention
and must be no more than 63 characters</literal>, try creating the Update Service with a shorter name.</simpara>
</note>
<section xml:id="update-service-configure-cvo">
<title>Configuring the Cluster Version Operator (CVO)</title>
<simpara>After the OpenShift Update Service Operator has been installed and the OpenShift Update Service application has been created, the Cluster Version Operator (CVO) can be updated to pull graph data from the locally installed OpenShift Update Service.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The OpenShift Update Service Operator has been installed.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Update Service graph data container image has been created and pushed to a repository that is accessible to the OpenShift Update Service.</simpara>
</listitem>
<listitem>
<simpara>The current release and update target releases have been mirrored to a locally accessible registry.</simpara>
</listitem>
<listitem>
<simpara>The OpenShift Update Service application has been created.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Set the OpenShift Update Service target namespace, for example, <literal>openshift-update-service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ NAMESPACE=openshift-update-service</programlisting>
</listitem>
<listitem>
<simpara>Set the name of the OpenShift Update Service application, for example, <literal>service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ NAME=service</programlisting>
</listitem>
<listitem>
<simpara>Obtain the policy engine route:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ POLICY_ENGINE_GRAPH_URI="$(oc -n "${NAMESPACE}" get -o jsonpath='{.status.policyEngineURI}/api/upgrades_info/v1/graph{"\n"}' updateservice "${NAME}")"</programlisting>
</listitem>
<listitem>
<simpara>Set the patch for the pull graph data:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ PATCH="{\"spec\":{\"upstream\":\"${POLICY_ENGINE_GRAPH_URI}\"}}"</programlisting>
</listitem>
<listitem>
<simpara>Patch the CVO to use the local OpenShift Update Service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch clusterversion version -p $PATCH --type merge</programlisting>
</listitem>
</orderedlist>
<note>
<simpara>See <link xl:href="../../../networking/enable-cluster-wide-proxy.xml#enable-cluster-wide-proxy">Configuring the cluster-wide proxy</link> to configure the CA to trust the update server.</simpara>
</note>
</section>
</section>
</section>
<section xml:id="next-steps_updating-restricted-network-cluster-osus">
<title>Next steps</title>
<simpara>Before updating your cluster, confirm that the following conditions are met:</simpara>
<itemizedlist>
<listitem>
<simpara>The Cluster Version Operator (CVO) is configured to use your locally-installed OpenShift Update Service application.</simpara>
</listitem>
<listitem>
<simpara>The release image signature config map for the new release is applied to your cluster.</simpara>
<note>
<simpara>The release image signature config map allows the Cluster Version Operator (CVO) to ensure the integrity of release images by verifying that the actual image signatures match the expected signatures.</simpara>
</note>
</listitem>
<listitem>
<simpara>The current release and update target release images are mirrored to a locally accessible registry.</simpara>
</listitem>
<listitem>
<simpara>A recent graph data container image has been mirrored to your local registry.</simpara>
</listitem>
<listitem>
<simpara>A recent version of the OpenShift Update Service Operator is installed.</simpara>
<note>
<simpara>If you have not recently installed or updated the OpenShift Update Service Operator, there might be a more recent version available.
See <link xl:href="../../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link> for more information about how to update your OLM catalog in a disconnected environment.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>After you configure your cluster to use the locally-installed OpenShift Update Service and local mirror registry, you can use any of the following update methods:</simpara>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating-cluster-web-console.xml#updating-cluster-web-console">Updating a cluster using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating-cluster-cli.xml#updating-cluster-cli">Updating a cluster using the CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/eus-eus-update.xml#eus-eus-update">Performing an EUS-to-EUS update</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/update-using-custom-machine-config-pools.xml#update-using-custom-machine-config-pools">Performing a canary rollout update</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating-cluster-rhel-compute.xml#updating-cluster-rhel-compute">Updating a cluster that includes RHEL compute machines</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="updating-restricted-network-cluster">
<title>Updating a cluster in a disconnected environment without the OpenShift Update Service</title>

<simpara>Use the following procedures to update a cluster in a disconnected environment without access to the OpenShift Update Service.</simpara>
<section xml:id="_prerequisites_3">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>You must have the <literal>oc</literal> command-line interface (CLI) tool installed.</simpara>
</listitem>
<listitem>
<simpara>You must provision a local container image registry with the container images for your update, as described in <link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-ocp-image-repository">Mirroring {product-title} images</link>.</simpara>
</listitem>
<listitem>
<simpara>You must have access to the cluster as a user with <literal>admin</literal> privileges.
See <link xl:href="../../../authentication/using-rbac.xml#using-rbac">Using RBAC to define and apply permissions</link>.</simpara>
</listitem>
<listitem>
<simpara>You must have a recent <link xl:href="../../../backup_and_restore/control_plane_backup_and_restore/backing-up-etcd.xml#backup-etcd">etcd backup</link> in case your update fails and you must <link xl:href="../../../backup_and_restore/control_plane_backup_and_restore/disaster_recovery/scenario-2-restoring-cluster-state.xml#dr-restoring-cluster-state">restore your cluster to a previous state</link>.</simpara>
</listitem>
<listitem>
<simpara>You have updated all Operators previously installed through Operator Lifecycle Manager (OLM) to a version that is compatible with your target release. Updating the Operators ensures they have a valid update path when the default OperatorHub catalogs switch from the current minor version to the next during a cluster update. See <link xl:href="../../../operators/admin/olm-upgrading-operators.xml#olm-upgrading-operators">Updating installed Operators</link> for more information on how to check compatibility and, if necessary, update the installed Operators.</simpara>
</listitem>
<listitem>
<simpara>You must ensure that all machine config pools (MCPs) are running and not paused. Nodes associated with a paused MCP are skipped during the update process. You can pause the MCPs if you are performing a canary rollout update strategy.</simpara>
</listitem>
<listitem>
<simpara>If your cluster uses manually maintained credentials, update the cloud provider resources for the new release. For more information, including how to determine if this is a requirement for your cluster, see <link xl:href="../../../updating/preparing_for_updates/preparing-manual-creds-update.xml#preparing-manual-creds-update">Preparing to update a cluster with manually maintained credentials</link>.</simpara>
</listitem>
<listitem>
<simpara>If you run an Operator or you have configured any application with the pod disruption budget, you might experience an interruption during the update process. If <literal>minAvailable</literal> is set to 1 in <literal>PodDisruptionBudget</literal>, the nodes are drained to apply pending machine configs which might block the eviction process. If several nodes are rebooted, all the pods might run on only one node, and the <literal>PodDisruptionBudget</literal> field can prevent the node drain.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you run an Operator or you have configured any application with the pod disruption budget, you might experience an interruption during the update process. If <literal>minAvailable</literal> is set to 1 in <literal>PodDisruptionBudget</literal>, the nodes are drained to apply pending machine configs which might block the eviction process. If several nodes are rebooted, all the pods might run on only one node, and the <literal>PodDisruptionBudget</literal> field can prevent the node drain.</simpara>
</note>
</section>
<section xml:id="machine-health-checks-pausing_updating-restricted-network-cluster">
<title>Pausing a MachineHealthCheck resource</title>
<simpara>During the update process, nodes in the cluster might become temporarily unavailable. In the case of worker nodes, the machine health check might identify such nodes as unhealthy and reboot them. To avoid rebooting such nodes, pause all the <literal>MachineHealthCheck</literal> resources before updating the cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To list all the available <literal>MachineHealthCheck</literal> resources that you want to pause, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machinehealthcheck -n openshift-machine-api</programlisting>
</listitem>
<listitem>
<simpara>To pause the machine health checks, add the <literal>cluster.x-k8s.io/paused=""</literal> annotation to the <literal>MachineHealthCheck</literal> resource. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api annotate mhc &lt;mhc-name&gt; cluster.x-k8s.io/paused=""</programlisting>
<simpara>The annotated <literal>MachineHealthCheck</literal> resource resembles the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineHealthCheck
metadata:
  name: example
  namespace: openshift-machine-api
  annotations:
    cluster.x-k8s.io/paused: ""
spec:
  selector:
    matchLabels:
      role: worker
  unhealthyConditions:
  - type:    "Ready"
    status:  "Unknown"
    timeout: "300s"
  - type:    "Ready"
    status:  "False"
    timeout: "300s"
  maxUnhealthy: "40%"
status:
  currentHealthy: 5
  expectedMachines: 5</programlisting>
<important>
<simpara>Resume the machine health checks after updating the cluster. To resume the check, remove the pause annotation from the <literal>MachineHealthCheck</literal> resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-machine-api annotate mhc &lt;mhc-name&gt; cluster.x-k8s.io/paused-</programlisting>
</important>
</listitem>
</orderedlist>
</section>
<section xml:id="update-restricted-image-digests_updating-restricted-network-cluster">
<title>Retrieving a release image digest</title>
<simpara>In order to update a cluster in a disconnected environment using the <literal>oc adm upgrade</literal> command with the <literal>--to-image</literal> option, you must reference the sha256 digest that corresponds to your targeted release image.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command on a device that is connected to the internet:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release info -o 'jsonpath={.digest}{"\n"}' quay.io/openshift-release-dev/ocp-release:${OCP_RELEASE_VERSION}-${ARCHITECTURE}</programlisting>
<simpara>For <literal>{OCP_RELEASE_VERSION}</literal>, specify the version of {product-title} to which you want to update, such as <literal>4.10.16</literal>.</simpara>
<simpara>For <literal>{ARCHITECTURE}</literal>, specify the architecture of the cluster, such as <literal>x86_64</literal>, <literal>aarch64</literal>, <literal>s390x</literal>, or <literal>ppc64le</literal>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">sha256:a8bfba3b6dddd1a2fbbead7dac65fe4fb8335089e4e7cae327f3bad334add31d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Copy the sha256 digest for use when updating your cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-restricted_updating-restricted-network-cluster">
<title>Updating the disconnected cluster</title>
<simpara>Update the disconnected cluster to the {product-title} version that you downloaded the release images for.</simpara>
<note>
<simpara>If you have a local OpenShift Update Service, you can update by using the connected web console or CLI instructions instead of this procedure.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You mirrored the images for the new release to your registry.</simpara>
</listitem>
<listitem>
<simpara>You applied the release image signature ConfigMap for the new release to your cluster.</simpara>
<note>
<simpara>The release image signature config map allows the Cluster Version Operator (CVO) to ensure the integrity of release images by verifying that the actual image signatures match the expected signatures.</simpara>
</note>
</listitem>
<listitem>
<simpara>You obtained the sha256 digest for your targeted release image.</simpara>
</listitem>
<listitem>
<simpara>You installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You paused all <literal>MachineHealthCheck</literal> resources.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Update the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --allow-explicit-upgrade --to-image &lt;defined_registry&gt;/&lt;defined_repository&gt;@&lt;digest&gt;</programlisting>
<simpara>Where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;defined_registry&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the mirror registry you mirrored your images to.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;defined_repository&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the image repository you want to use on the mirror registry.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;digest&gt;</literal></term>
<listitem>
<simpara>Specifies the sha256 digest for the targeted release image, for example, <literal>sha256:81154f5c03294534e1eaf0319bef7a601134f891689ccede5d705ef659aa8c92</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<note>
<itemizedlist>
<listitem>
<simpara>See "Mirroring {product-title} images" to review how your mirror registry and repository names are defined.</simpara>
</listitem>
<listitem>
<simpara>If you used an <literal>ImageContentSourcePolicy</literal> or <literal>ImageDigestMirrorSet</literal>, you can use the canonical registry and repository names instead of the names you defined.
The canonical registry name is <literal>quay.io</literal> and the canonical repository name is <literal>openshift-release-dev/ocp-release</literal>.</simpara>
</listitem>
<listitem>
<simpara>You can only configure global pull secrets for clusters that have an <literal>ImageContentSourcePolicy</literal> object. You cannot add a pull secret to a project.</simpara>
</listitem>
</itemizedlist>
</note>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../../updating/updating_a_cluster/updating_disconnected_cluster/mirroring-image-repository.xml#mirroring-ocp-image-repository">Mirroring {product-title} images</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-configuration-registry-mirror_updating-restricted-network-cluster">
<title>Understanding image registry repository mirroring</title>
<simpara>Setting up container registry repository mirroring enables you to perform the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure your {product-title} cluster to redirect requests to pull images from a repository on a source image registry and have it resolved by a repository on a mirrored image registry.</simpara>
</listitem>
<listitem>
<simpara>Identify multiple mirrored repositories for each target repository, to make sure that if one mirror is down, another can be used.</simpara>
</listitem>
</itemizedlist>
<simpara>Repository mirroring in {product-title} includes the following attributes:</simpara>
<itemizedlist>
<listitem>
<simpara>Image pulls are resilient to registry downtimes.</simpara>
</listitem>
<listitem>
<simpara>Clusters in disconnected environments can pull images from critical locations, such as quay.io, and have registries behind a company firewall provide the requested images.</simpara>
</listitem>
<listitem>
<simpara>A particular order of registries is tried when an image pull request is made, with the permanent registry typically being the last one tried.</simpara>
</listitem>
<listitem>
<simpara>The mirror information you enter is added to the <literal>/etc/containers/registries.conf</literal> file on every node in the {product-title} cluster.</simpara>
</listitem>
<listitem>
<simpara>When a node makes a request for an image from the source repository, it tries each mirrored repository in turn until it finds the requested content. If all mirrors fail, the cluster tries the source repository. If successful, the image is pulled to the node.</simpara>
</listitem>
</itemizedlist>
<simpara>Setting up repository mirroring can be done in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>At {product-title} installation:</simpara>
<simpara>By pulling container images needed by {product-title} and then bringing those images behind your company&#8217;s firewall, you can install {product-title} into a datacenter that is in a disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>After {product-title} installation:</simpara>
<simpara>If you did not configure mirroring during {product-title} installation, you can do so postinstallation by using any of the following custom resource (CR) objects:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ImageDigestMirrorSet</literal> (IDMS). This object allows you to pull images from a mirrored registry by using digest specifications. The IDMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageTagMirrorSet</literal> (ITMS). This object allows you to pull images from a mirrored registry by using image tags. The ITMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageContentSourcePolicy</literal> (ICSP). This object allows you to pull images from a mirrored registry by using digest specifications. The ICSP CR always falls back to the source registry if the mirrors do not work.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Using an <literal>ImageContentSourcePolicy</literal> (ICSP) object to configure repository mirroring is a deprecated feature. Deprecated functionality is still included in {product-title} and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments. If you have existing YAML files that you used to create <literal>ImageContentSourcePolicy</literal> objects, you can use the <literal>oc adm migrate icsp</literal> command to convert those files to an <literal>ImageDigestMirrorSet</literal> YAML file. For more information, see "Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring" in the following section.</simpara>
</important>
</listitem>
</itemizedlist>
<simpara>Each of these custom resource objects identify the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>The source of the container image repository you want to mirror.</simpara>
</listitem>
<listitem>
<simpara>A separate entry for each mirror repository you want to offer the content
requested from the source repository.</simpara>
</listitem>
</itemizedlist>
<simpara>For new clusters, you can use IDMS, ITMS, and ICSP CRs objects as desired. However, using IDMS and ITMS is recommended.</simpara>
<simpara>If you upgraded a cluster, any existing ICSP objects remain stable, and both IDMS and ICSP objects are supported. Workloads using ICSP objects continue to function as expected. However, if you want to take advantage of the fallback policies introduced in the IDMS CRs, you can migrate current workloads to IDMS objects by using the <literal>oc adm migrate icsp</literal> command as shown in the <emphasis role="strong">Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring</emphasis> section that follows. Migrating to IDMS objects does not require a cluster reboot.</simpara>
<note>
<simpara>If your cluster uses an <literal>ImageDigestMirrorSet</literal>, <literal>ImageTagMirrorSet</literal>, or <literal>ImageContentSourcePolicy</literal> object to configure repository mirroring, you can use only global pull secrets for mirrored registries. You cannot add a pull secret to a project.</simpara>
</note>
<section xml:id="images-configuration-registry-mirror-configuring_updating-restricted-network-cluster">
<title>Configuring image registry repository mirroring</title>
<simpara>You can create postinstallation mirror configuration custom resources (CR) to redirect image pull requests from a source image registry to a mirrored image registry.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure mirrored repositories, by either:</simpara>
<itemizedlist>
<listitem>
<simpara>Setting up a mirrored repository with Red Hat Quay, as described in <link xl:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/manage_red_hat_quay/repo-mirroring-in-red-hat-quay">Red Hat Quay Repository Mirroring</link>. Using Red Hat Quay allows you to copy images from one repository to another and also automatically sync those repositories repeatedly over time.</simpara>
</listitem>
<listitem>
<simpara>Using a tool such as <literal>skopeo</literal> to copy images manually from the source repository to the mirrored repository.</simpara>
<simpara>For example, after installing the skopeo RPM package on a Red Hat Enterprise Linux (RHEL) 7 or RHEL 8 system, use the <literal>skopeo</literal> command as shown in this example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ skopeo copy \
docker://registry.access.redhat.com/ubi9/ubi-minimal:latest@sha256:5cf... \
docker://example.io/example/ubi-minimal</programlisting>
<simpara>In this example, you have a container image registry that is named <literal>example.io</literal> with an image repository named <literal>example</literal> to which you want to copy the <literal>ubi9/ubi-minimal</literal> image from <literal>registry.access.redhat.com</literal>. After you create the mirrored registry, you can configure your {product-title} cluster to redirect requests made of the source repository to the mirrored repository.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Log in to your {product-title} cluster.</simpara>
</listitem>
<listitem>
<simpara>Create a postinstallation mirror configuration CR, by using one of the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an <literal>ImageDigestMirrorSet</literal> or <literal>ImageTagMirrorSet</literal> CR, as needed, replacing the source and mirrors with your own registry and repository pairs and images:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1 <co xml:id="CO37-1"/>
kind: ImageDigestMirrorSet <co xml:id="CO37-2"/>
metadata:
  name: ubi9repo
spec:
  imageDigestMirrors: <co xml:id="CO37-3"/>
  - mirrors:
    - example.io/example/ubi-minimal <co xml:id="CO37-4"/>
    - example.com/example/ubi-minimal <co xml:id="CO37-5"/>
    source: registry.access.redhat.com/ubi9/ubi-minimal <co xml:id="CO37-6"/>
    mirrorSourcePolicy: AllowContactingSource <co xml:id="CO37-7"/>
  - mirrors:
    - mirror.example.com/redhat
    source: registry.redhat.io/openshift4 <co xml:id="CO37-8"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.com
    source: registry.redhat.io <co xml:id="CO37-9"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/image
    source: registry.example.com/example/myimage <co xml:id="CO37-10"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net
    source: registry.example.com/example <co xml:id="CO37-11"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/registry-example-com
    source: registry.example.com <co xml:id="CO37-12"/>
    mirrorSourcePolicy: AllowContactingSource</programlisting>
<calloutlist>
<callout arearefs="CO37-1">
<para>Indicates the API to use with this CR. This must be <literal>config.openshift.io/v1</literal>.</para>
</callout>
<callout arearefs="CO37-2">
<para>Indicates the kind of object according to the pull type:</para>
<itemizedlist>
<listitem>
<simpara><literal>ImageDigestMirrorSet</literal>: Pulls a digest reference image.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageTagMirrorSet</literal>: Pulls a tag reference image.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO37-3">
<para>Indicates the type of image pull method, either:</para>
<itemizedlist>
<listitem>
<simpara><literal>imageDigestMirrors</literal>: Use for an <literal>ImageDigestMirrorSet</literal> CR.</simpara>
</listitem>
<listitem>
<simpara><literal>imageTagMirrors</literal>: Use for an <literal>ImageTagMirrorSet</literal> CR.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO37-4">
<para>Indicates the name of the mirrored image registry and repository.</para>
</callout>
<callout arearefs="CO37-5">
<para>Optional: Indicates a secondary mirror repository for each target repository. If one mirror is down, the target repository can use another mirror.</para>
</callout>
<callout arearefs="CO37-6">
<para>Indicates the registry and repository source, which is the repository that is referred to in image pull specifications.</para>
</callout>
<callout arearefs="CO37-7">
<para>Optional: Indicates the fallback policy if the image pull fails:</para>
<itemizedlist>
<listitem>
<simpara><literal>AllowContactingSource</literal>: Allows continued attempts to pull the image from the source repository. This is the default.</simpara>
</listitem>
<listitem>
<simpara><literal>NeverContactSource</literal>: Prevents continued attempts to pull the image from the source repository.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO37-8">
<para>Optional: Indicates a namespace inside a registry, which allows you to use any image in that namespace. If you use a registry domain as a source, the object is applied to all repositories from the registry.</para>
</callout>
<callout arearefs="CO37-9">
<para>Optional: Indicates a registry, which allows you to use any image in that registry. If you specify a registry name, the object is applied to all repositories from a source registry to a mirror registry.</para>
</callout>
<callout arearefs="CO37-10">
<para>Pulls the image <literal>registry.example.com/example/myimage@sha256:&#8230;&#8203;</literal> from the mirror <literal>mirror.example.net/image@sha256:..</literal>.</para>
</callout>
<callout arearefs="CO37-11">
<para>Pulls the image <literal>registry.example.com/example/image@sha256:&#8230;&#8203;</literal> in the source registry namespace from the mirror <literal>mirror.example.net/image@sha256:&#8230;&#8203;</literal>.</para>
</callout>
<callout arearefs="CO37-12">
<para>Pulls the image <literal>registry.example.com/myimage@sha256</literal> from the mirror registry <literal>example.net/registry-example-com/myimage@sha256:&#8230;&#8203;</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create an <literal>ImageContentSourcePolicy</literal> custom resource, replacing the source and mirrors with your own registry and repository pairs and images:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: mirror-ocp
spec:
  repositoryDigestMirrors:
  - mirrors:
    - mirror.registry.com:443/ocp/release <co xml:id="CO38-1"/>
    source: quay.io/openshift-release-dev/ocp-release <co xml:id="CO38-2"/>
  - mirrors:
    - mirror.registry.com:443/ocp/release
    source: quay.io/openshift-release-dev/ocp-v4.0-art-dev</programlisting>
<calloutlist>
<callout arearefs="CO38-1">
<para>Specifies the name of the mirror image registry and repository.</para>
</callout>
<callout arearefs="CO38-2">
<para>Specifies the online registry and repository containing the content that is mirrored.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create the new object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f registryrepomirror.yaml</programlisting>
<simpara>After the object is created, the Machine Config Operator (MCO) drains the nodes for <literal>ImageTagMirrorSet</literal> objects only. The MCO does not drain the nodes for <literal>ImageDigestMirrorSet</literal> and <literal>ImageContentSourcePolicy</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>To check that the mirrored configuration settings are applied, do the following on one of the nodes.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS                     ROLES    AGE  VERSION
ip-10-0-137-44.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-138-148.ec2.internal   Ready                      master   11m  v1.28.5
ip-10-0-139-122.ec2.internal   Ready                      master   11m  v1.28.5
ip-10-0-147-35.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-153-12.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-154-10.ec2.internal    Ready                      master   11m  v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Start the debugging process to access the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/ip-10-0-147-35.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/ip-10-0-147-35ec2internal-debug ...
To use host binaries, run `chroot /host`</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Check the <literal>/etc/containers/registries.conf</literal> file to make sure the changes were made:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# cat /etc/containers/registries.conf</programlisting>
<simpara>The following output represents a <literal>registries.conf</literal> file where postinstallation mirror configuration CRs were applied. The final two entries are marked <literal>digest-only</literal> and <literal>tag-only</literal> respectively.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]
short-name-mode = ""

[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal" <co xml:id="CO39-1"/>

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal" <co xml:id="CO39-2"/>
    pull-from-mirror = "digest-only" <co xml:id="CO39-3"/>

  [[registry.mirror]]
    location = "example.com/example/ubi-minimal"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com"

  [[registry.mirror]]
    location = "mirror.example.net/registry-example-com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example"

  [[registry.mirror]]
    location = "mirror.example.net"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example/myimage"

  [[registry.mirror]]
    location = "mirror.example.net/image"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.redhat.io"

  [[registry.mirror]]
    location = "mirror.example.com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.redhat.io/openshift4"

  [[registry.mirror]]
    location = "mirror.example.com/redhat"
    pull-from-mirror = "digest-only"
[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal"
  blocked = true <co xml:id="CO39-4"/>

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal-tag"
    pull-from-mirror = "tag-only" <co xml:id="CO39-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO39-1">
<para>Indicates the repository that is referred to in a pull spec.</para>
</callout>
<callout arearefs="CO39-2">
<para>Indicates the mirror for that repository.</para>
</callout>
<callout arearefs="CO39-3">
<para>Indicates that the image pull from the mirror is a digest reference image.</para>
</callout>
<callout arearefs="CO39-4">
<para>Indicates that the <literal>NeverContactSource</literal> parameter is set for this repository.</para>
</callout>
<callout arearefs="CO39-5">
<para>Indicates that the image pull from the mirror is a tag reference image.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Pull an image to the node from the source and check if it is resolved by the mirror.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# podman pull --log-level=debug registry.access.redhat.com/ubi9/ubi-minimal@sha256:5cf...</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Troubleshooting repository mirroring</title>
<para>If the repository mirroring procedure does not work as described, use the following information about how repository mirroring works to help troubleshoot the problem.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>The first working mirror is used to supply the pulled image.</simpara>
</listitem>
<listitem>
<simpara>The main registry is only used if no other mirror works.</simpara>
</listitem>
<listitem>
<simpara>From the system context, the <literal>Insecure</literal> flags are used as fallback.</simpara>
</listitem>
<listitem>
<simpara>The format of the <literal>/etc/containers/registries.conf</literal> file has changed recently. It is now version 2 and in TOML format.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-configuration-registry-mirror-convert_updating-restricted-network-cluster">
<title>Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring</title>
<simpara>Using an <literal>ImageContentSourcePolicy</literal> (ICSP) object to configure repository mirroring is a deprecated feature. This functionality is still included in {product-title} and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<simpara>ICSP objects are being replaced by <literal>ImageDigestMirrorSet</literal> and <literal>ImageTagMirrorSet</literal> objects to configure repository mirroring. If you have existing YAML files that you used to create <literal>ImageContentSourcePolicy</literal> objects, you can use the <literal>oc adm migrate icsp</literal> command to convert those files to an <literal>ImageDigestMirrorSet</literal> YAML file. The command updates the API to the current version, changes the <literal>kind</literal> value to <literal>ImageDigestMirrorSet</literal>, and changes <literal>spec.repositoryDigestMirrors</literal> to <literal>spec.imageDigestMirrors</literal>. The rest of the file is not changed.</simpara>
<simpara>Because the migration does not change the <literal>registries.conf</literal> file, the cluster does not need to reboot.</simpara>
<simpara>For more information about <literal>ImageDigestMirrorSet</literal> or <literal>ImageTagMirrorSet</literal> objects, see "Configuring image registry repository mirroring" in the previous section.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Ensure that you have <literal>ImageContentSourcePolicy</literal> objects on your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the following command to convert one or more <literal>ImageContentSourcePolicy</literal> YAML files to an <literal>ImageDigestMirrorSet</literal> YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm migrate icsp &lt;file_name&gt;.yaml &lt;file_name&gt;.yaml &lt;file_name&gt;.yaml --dest-dir &lt;path_to_the_directory&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;file_name&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the source <literal>ImageContentSourcePolicy</literal> YAML. You can list multiple file names.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>--dest-dir</literal></term>
<listitem>
<simpara>Optional: Specifies a directory for the output <literal>ImageDigestMirrorSet</literal> YAML. If unset, the file is written to the current directory.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>For example, the following command converts the <literal>icsp.yaml</literal> and <literal>icsp-2.yaml</literal> file and saves the new YAML files to the <literal>idms-files</literal> directory.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm migrate icsp icsp.yaml icsp-2.yaml --dest-dir idms-files</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi8repo.5911620242173376087.yaml
wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi9repo.6456931852378115011.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the CR object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;path_to_the_directory&gt;/&lt;file-name&gt;.yaml</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;path_to_the_directory&gt;</literal></term>
<listitem>
<simpara>Specifies the path to the directory, if you used the <literal>--dest-dir</literal> flag.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;file_name&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the <literal>ImageDigestMirrorSet</literal> YAML.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Remove the ICSP objects after the IDMS objects are rolled out.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="generating-icsp-object-scoped-to-a-registry_updating-restricted-network-cluster">
<title>Widening the scope of the mirror image catalog to reduce the frequency of cluster node reboots</title>
<simpara>You can scope the mirrored image catalog at the repository level or the wider registry level. A widely scoped <literal>ImageContentSourcePolicy</literal> resource reduces the number of times the nodes need to reboot in response to changes to the resource.</simpara>
<simpara>To widen the scope of the mirror image catalog in the <literal>ImageContentSourcePolicy</literal> resource, perform the following procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the {product-title} CLI <literal>oc</literal>.</simpara>
</listitem>
<listitem>
<simpara>Log in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>Configure a mirrored image catalog for use in your disconnected cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run the following command, specifying values for <literal>&lt;local_registry&gt;</literal>, <literal>&lt;pull_spec&gt;</literal>, and <literal>&lt;pull_secret_file&gt;</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm catalog mirror &lt;local_registry&gt;/&lt;pull_spec&gt; &lt;local_registry&gt; -a &lt;pull_secret_file&gt; --icsp-scope=registry</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term>&lt;local_registry&gt;</term>
<listitem>
<simpara>is the local registry you have configured for your disconnected cluster, for example, <literal>local.registry:5000</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;pull_spec&gt;</term>
<listitem>
<simpara>is the pull specification as configured in your disconnected registry, for example, <literal>redhat/redhat-operator-index:v{product-version}</literal></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>&lt;pull_secret_file&gt;</term>
<listitem>
<simpara>is the <literal>registry.redhat.io</literal> pull secret in <literal>.json</literal> file format. You can download the <link xl:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The <literal>oc adm catalog mirror</literal> command creates a <literal>/redhat-operator-index-manifests</literal> directory and generates <literal>imageContentSourcePolicy.yaml</literal>, <literal>catalogSource.yaml</literal>, and <literal>mapping.txt</literal> files.</simpara>
</listitem>
<listitem>
<simpara>Apply the new <literal>ImageContentSourcePolicy</literal> resource to the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f imageContentSourcePolicy.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that <literal>oc apply</literal> successfully applied the change to <literal>ImageContentSourcePolicy</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get ImageContentSourcePolicy -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
items:
- apiVersion: operator.openshift.io/v1alpha1
  kind: ImageContentSourcePolicy
  metadata:
    annotations:
      kubectl.kubernetes.io/last-applied-configuration: |
        {"apiVersion":"operator.openshift.io/v1alpha1","kind":"ImageContentSourcePolicy","metadata":{"annotations":{},"name":"redhat-operator-index"},"spec":{"repositoryDigestMirrors":[{"mirrors":["local.registry:5000"],"source":"registry.redhat.io"}]}}
...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>After you update the <literal>ImageContentSourcePolicy</literal> resource, {product-title} deploys the new settings to each node and the cluster starts using the mirrored repository for requests to the source repository.</simpara>
</section>
<section xml:id="additional-resources_security-container-signature" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xl:href="../../../operators/admin/olm-restricted-networks.xml#olm-restricted-networks">Using Operator Lifecycle Manager on restricted networks</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../../post_installation_configuration/machine-configuration-tasks.xml#machine-config-overview-post-install-machine-configuration-tasks">Machine Config Overview</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="uninstalling-osus">
<title>Uninstalling the OpenShift Update Service from a cluster</title>

<simpara>To remove a local copy of the OpenShift Update Service (OSUS) from your cluster, you must first delete the OSUS application and then uninstall the OSUS Operator.</simpara>
<section xml:id="update-service-delete-service">
<title>Deleting an OpenShift Update Service application</title>
<simpara>You can delete an OpenShift Update Service application by using the {product-title} web console or CLI.</simpara>
<section xml:id="update-service-delete-service-web-console_uninstalling-osus">
<title>Deleting an OpenShift Update Service application by using the web console</title>
<simpara>You can use the {product-title} web console to delete an OpenShift Update Service application by using the OpenShift Update Service Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The OpenShift Update Service Operator has been installed.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">OpenShift Update Service</emphasis> from the list of installed Operators.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Update Service</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>From the list of installed OpenShift Update Service applications, select the application to be deleted and then click <emphasis role="strong">Delete UpdateService</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Delete UpdateService?</emphasis> confirmation dialog, click <emphasis role="strong">Delete</emphasis> to confirm the deletion.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-delete-service-cli_uninstalling-osus">
<title>Deleting an OpenShift Update Service application by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to delete an OpenShift Update Service application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Get the OpenShift Update Service application name using the namespace the OpenShift Update Service application was created in, for example, <literal>openshift-update-service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get updateservice -n openshift-update-service</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      AGE
service   6s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the OpenShift Update Service application using the <literal>NAME</literal> value from the previous step and the namespace the OpenShift Update Service application was created in, for example, <literal>openshift-update-service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete updateservice service -n openshift-update-service</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">updateservice.updateservice.operator.openshift.io "service" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="update-service-uninstall">
<title>Uninstalling the OpenShift Update Service Operator</title>
<simpara>You can uninstall the OpenShift Update Service Operator by using the {product-title} web console or CLI.</simpara>
<section xml:id="update-service-uninstall-web-console_uninstalling-osus">
<title>Uninstalling the OpenShift Update Service Operator by using the web console</title>
<simpara>You can use the {product-title} web console to uninstall the OpenShift Update Service Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All OpenShift Update Service applications have been deleted.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the web console, click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">OpenShift Update Service</emphasis> from the list of installed Operators and click <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Uninstall Operator?</emphasis> confirmation dialog, click <emphasis role="strong">Uninstall</emphasis> to confirm the uninstallation.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-service-uninstall-cli_uninstalling-osus">
<title>Uninstalling the OpenShift Update Service Operator by using the CLI</title>
<simpara>You can use the OpenShift CLI (<literal>oc</literal>) to uninstall the OpenShift Update Service Operator.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>All OpenShift Update Service applications have been deleted.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Change to the project containing the OpenShift Update Service Operator, for example, <literal>openshift-update-service</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project openshift-update-service</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Now using project "openshift-update-service" on server "https://example.com:6443".</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the name of the OpenShift Update Service Operator operator group:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get operatorgroup</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                             AGE
openshift-update-service-fprx2   4m41s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the operator group, for example, <literal>openshift-update-service-fprx2</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete operatorgroup openshift-update-service-fprx2</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">operatorgroup.operators.coreos.com "openshift-update-service-fprx2" deleted</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Get the name of the OpenShift Update Service Operator subscription:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subscription</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                      PACKAGE                   SOURCE                        CHANNEL
update-service-operator   update-service-operator   updateservice-index-catalog   v1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Using the <literal>Name</literal> value from the previous step, check the current version of the subscribed OpenShift Update Service Operator in the <literal>currentCSV</literal> field:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subscription update-service-operator -o yaml | grep " currentCSV"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  currentCSV: update-service-operator.v0.0.1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the subscription, for example, <literal>update-service-operator</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete subscription update-service-operator</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">subscription.operators.coreos.com "update-service-operator" deleted</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete the CSV for the OpenShift Update Service Operator using the <literal>currentCSV</literal> value from the previous step:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete clusterserviceversion update-service-operator.v0.0.1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">clusterserviceversion.operators.coreos.com "update-service-operator.v0.0.1" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
</section>
</section>
<section xml:id="updating-hardware-on-nodes-running-on-vsphere">
<title>Updating hardware on nodes running on vSphere</title>

<simpara>You must ensure that your nodes running in vSphere are running on the hardware version supported by {product-title}. Currently, hardware version 15 or later is supported for vSphere virtual machines in a cluster.</simpara>
<simpara>You can update your virtual hardware immediately or schedule an update in vCenter.</simpara>
<important>
<itemizedlist>
<listitem>
<simpara>Version {product-version} of {product-title} requires VMware virtual hardware version 15 or later.</simpara>
</listitem>
<listitem>
<simpara>Before upgrading OpenShift 4.12 to OpenShift 4.13, you must update vSphere to <emphasis role="strong">v7.0.2 or later</emphasis>; otherwise, the OpenShift 4.12 cluster is marked <emphasis role="strong">un-upgradeable</emphasis>.</simpara>
</listitem>
</itemizedlist>
</important>
<section xml:id="updating-virtual-hardware-on-vsphere_updating-hardware-on-nodes-running-in-vsphere">
<title>Updating virtual hardware on vSphere</title>
<simpara>To update the hardware of your virtual machines (VMs) on VMware vSphere, update your virtual machines separately to reduce the risk of downtime for your cluster.</simpara>
<important>
<simpara>As of {product-title} 4.13, VMware virtual hardware version 13 is no longer supported. You need to update to VMware version 15 or later for supporting functionality.</simpara>
</important>
<section xml:id="update-vsphere-virtual-hardware-on-control-plane-nodes_updating-hardware-on-nodes-running-in-vsphere">
<title>Updating the virtual hardware for control plane nodes on vSphere</title>
<simpara>To reduce the risk of downtime, it is recommended that control plane nodes be updated serially. This ensures that the Kubernetes API remains available and etcd retains quorum.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have cluster administrator permissions to execute the required permissions in the vCenter instance hosting your {product-title} cluster.</simpara>
</listitem>
<listitem>
<simpara>Your vSphere ESXi hosts are version 7.0U2 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the control plane nodes in your cluster.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l node-role.kubernetes.io/master</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    STATUS   ROLES    AGE   VERSION
control-plane-node-0    Ready    master   75m   v1.28.5
control-plane-node-1    Ready    master   75m   v1.28.5
control-plane-node-2    Ready    master   75m   v1.28.5</programlisting>
</para>
</formalpara>
<simpara>Note the names of your control plane nodes.</simpara>
</listitem>
<listitem>
<simpara>Mark the control plane node as unschedulable.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;control_plane_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Shut down the virtual machine (VM) associated with the control plane node. Do this in the vSphere client by right-clicking the VM and selecting <emphasis role="strong">Power</emphasis> &#8594; <emphasis role="strong">Shut Down Guest OS</emphasis>. Do not shut down the VM using <emphasis role="strong">Power Off</emphasis> because it might not shut down safely.</simpara>
</listitem>
<listitem>
<simpara>Update the VM in the vSphere client. Follow <link xl:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-60768C2F-72E1-42E0-8A17-CA76849F2950.html">Upgrade the Compatibility of a Virtual Machine Manually</link> in the VMware documentation for more information.</simpara>
</listitem>
<listitem>
<simpara>Power on the VM associated with the control plane node. Do this in the vSphere client by right-clicking the VM and selecting <emphasis role="strong">Power On</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Wait for the node to report as <literal>Ready</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc wait --for=condition=Ready node/&lt;control_plane_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Mark the control plane node as schedulable again:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm uncordon &lt;control_plane_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Repeat this procedure for each control plane node in your cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-vsphere-virtual-hardware-on-compute-nodes_updating-hardware-on-nodes-running-in-vsphere">
<title>Updating the virtual hardware for compute nodes on vSphere</title>
<simpara>To reduce the risk of downtime, it is recommended that compute nodes be updated serially.</simpara>
<note>
<simpara>Multiple compute nodes can be updated in parallel given workloads are tolerant of having multiple nodes in a <literal>NotReady</literal> state. It is the responsibility of the administrator to ensure that the required compute nodes are available.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have cluster administrator permissions to execute the required permissions in the vCenter instance hosting your {product-title} cluster.</simpara>
</listitem>
<listitem>
<simpara>Your vSphere ESXi hosts are version 7.0U2 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>List the compute nodes in your cluster.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes -l node-role.kubernetes.io/worker</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              STATUS   ROLES    AGE   VERSION
compute-node-0    Ready    worker   30m   v1.28.5
compute-node-1    Ready    worker   30m   v1.28.5
compute-node-2    Ready    worker   30m   v1.28.5</programlisting>
</para>
</formalpara>
<simpara>Note the names of your compute nodes.</simpara>
</listitem>
<listitem>
<simpara>Mark the compute node as unschedulable:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm cordon &lt;compute_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Evacuate the pods from the compute node. There are several ways to do this. For example, you can evacuate all or selected pods on a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm drain &lt;compute_node&gt; [--pod-selector=&lt;pod_selector&gt;]</programlisting>
<simpara>See the "Understanding how to evacuate pods on nodes" section for other options to evacuate pods from a node.</simpara>
</listitem>
<listitem>
<simpara>Shut down the virtual machine (VM) associated with the compute node. Do this in the vSphere client by right-clicking the VM and selecting <emphasis role="strong">Power</emphasis> &#8594; <emphasis role="strong">Shut Down Guest OS</emphasis>. Do not shut down the VM using <emphasis role="strong">Power Off</emphasis> because it might not shut down safely.</simpara>
</listitem>
<listitem>
<simpara>Update the VM in the vSphere client. Follow <link xl:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-60768C2F-72E1-42E0-8A17-CA76849F2950.html">Upgrade the Compatibility of a Virtual Machine Manually</link> in the VMware documentation for more information.</simpara>
</listitem>
<listitem>
<simpara>Power on the VM associated with the compute node. Do this in the vSphere client by right-clicking the VM and selecting <emphasis role="strong">Power On</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Wait for the node to report as <literal>Ready</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc wait --for=condition=Ready node/&lt;compute_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Mark the compute node as schedulable again:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm uncordon &lt;compute_node&gt;</programlisting>
</listitem>
<listitem>
<simpara>Repeat this procedure for each compute node in your cluster.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="update-vsphere-virtual-hardware-on-template_updating-hardware-on-nodes-running-in-vsphere">
<title>Updating the virtual hardware for template on vSphere</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have cluster administrator permissions to execute the required permissions in the vCenter instance hosting your {product-title} cluster.</simpara>
</listitem>
<listitem>
<simpara>Your vSphere ESXi hosts are version 7.0U2 or later.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>If the RHCOS template is configured as a vSphere template follow <link xl:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-D632CAC5-BA5E-4A1E-959B-382D9ACB1DD0_copy.html">Convert a Template to a Virtual Machine</link>
in the VMware documentation prior to the next step.</simpara>
<note>
<simpara>Once converted from a template, do not power on the virtual machine.</simpara>
</note>
</listitem>
<listitem>
<simpara>Update the VM in the vSphere client. Follow <link xl:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-60768C2F-72E1-42E0-8A17-CA76849F2950.html">Upgrade the Compatibility of a Virtual Machine Manually</link> in the VMware documentation for more information.</simpara>
</listitem>
<listitem>
<simpara>Convert the VM in the vSphere client from a VM to template. Follow <link xl:href="https://docs.vmware.com/en/VMware-vSphere/6.0/com.vmware.vsphere.hostclient.doc/GUID-846238E4-A1E3-4A28-B230-33BDD1D57454.html">Convert a Virtual Machine to a Template in the vSphere Client</link> in the VMware documentation for more information.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../nodes/nodes/nodes-nodes-working.xml#nodes-nodes-working-evacuating_nodes-nodes-working">Understanding how to evacuate pods on nodes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="scheduling-virtual-hardware-update-on-vsphere_updating-hardware-on-nodes-running-in-vsphere">
<title>Scheduling an update for virtual hardware on vSphere</title>
<simpara>Virtual hardware updates can be scheduled to occur when a virtual machine is powered on or rebooted. You can schedule your virtual hardware updates exclusively in vCenter by following <link xl:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vm_admin.doc/GUID-96C06236-C271-4CFE-857E-22D1FDEECC95.html">Schedule a Compatibility Upgrade for a Virtual Machine</link> in the VMware documentation.</simpara>
<simpara>When scheduling an update prior to performing an update of {product-title}, the virtual hardware update occurs when the nodes are rebooted during the course of the {product-title} update.</simpara>
</section>
</section>
<section xml:id="migrating-clusters-to-multi-payload">
<title>Migrating to a cluster with multi-architecture compute machines</title>

<simpara>You can migrate your current cluster with single-architecture compute machines to a cluster with multi-architecture compute machines by updating to a multi-architecture, manifest-listed payload. This allows you to add mixed architecture compute nodes to your cluster.</simpara>
<simpara>For information about configuring your multi-architecture compute machines, see <emphasis>Configuring multi-architecture compute machines on an {product-title} cluster</emphasis>.</simpara>
<important>
<simpara>Migration from a multi-architecture payload to a single-architecture payload is not supported. Once a cluster has transitioned to using a multi-architecture payload, it can no longer accept a single-architecture update payload.</simpara>
</important>
<section xml:id="migrating-to-multi-arch-cli_updating-clusters-overview">
<title>Migrating to a cluster with multi-architecture compute machines using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Your {product-title} version is up to date to at least version 4.13.0.</simpara>
<simpara>For more information on how to update your cluster version, see <emphasis>Updating a cluster using the web console</emphasis> or <emphasis>Updating a cluster using the CLI</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>) that matches the version for your current cluster.</simpara>
</listitem>
<listitem>
<simpara>Your <literal>oc</literal> client is updated to at least verion 4.13.0.</simpara>
</listitem>
<listitem>
<simpara>Your {product-title} cluster is installed on AWS, Azure, GCP, bare metal or IBM P/Z platforms.</simpara>
<simpara>For more information on selecting a supported platform for your cluster installation, see <emphasis>Selecting a cluster installation type</emphasis>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Verify that the <literal>RetrievedUpdates</literal> condition is <literal>True</literal> in the Cluster Version Operator (CVO) by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusterversion/version -o=jsonpath="{.status.conditions[?(.type=='RetrievedUpdates')].status}"</programlisting>
<simpara>If the <literal>RetrievedUpates</literal> condition is <literal>False</literal>, you can find supplemental information regarding the failure by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<simpara>For more information about cluster version condition types, see <emphasis>Understanding cluster version condition types</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If the condition <literal>RetrievedUpdates</literal> is <literal>False</literal>, change the channel to <literal>stable-&lt;4.y&gt;</literal> or <literal>fast-&lt;4.y&gt;</literal> with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade channel &lt;channel&gt;</programlisting>
<simpara>After setting the channel, verify if <literal>RetrievedUpdates</literal> is <literal>True</literal>.</simpara>
<simpara>For more information about channels, see <emphasis>Understanding update channels and releases</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Migrate to the multi-architecture payload with following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade --to-multi-arch</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>You can monitor the migration by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm upgrade</programlisting>
<important>
<simpara>Machine launches may fail as the cluster settles into the new state. To notice and recover when machines fail to launch, we recommend deploying machine health checks. For more information about machine health checks and how to deploy them, see <emphasis>About machine health checks</emphasis>.</simpara>
</important>
<simpara>The migrations must be complete and all the cluster operators must be stable before you can add compute machine sets with different architectures to your cluster.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../post_installation_configuration/configuring-multi-arch-compute-machines/multi-architecture-configuration.xml#multi-architecture-configuration">Configuring multi-architecture compute machines on an {product-title} cluster</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-web-console.xml#updating-cluster-web-console">Updating a cluster using the web console</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/updating_a_cluster/updating-cluster-cli.xml#updating-cluster-cli">Updating a cluster using the CLI</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/intro-to-updates.xml#understanding-clusterversion-conditiontypes_understanding-openshift-updates">Understanding cluster version condition types</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../updating/understanding_updates/understanding-update-channels-release.xml#understanding-update-channels-releases">Understanding update channels and releases</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../installing/installing-preparing.xml#installing-preparing-selecting-cluster-type">Selecting a cluster installation type</link></simpara>
</listitem>
<listitem>
<simpara><link xl:href="../../machine_management/deploying-machine-health-checks.xml#machine-health-checks-about_deploying-machine-health-checks">About machine health checks</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="updating-hosted-control-planes">
<title>Updating hosted control planes</title>

<simpara>On hosted control planes for {product-title}, updates are decoupled between the control plane and the nodes. Your service cluster provider, which is the user that hosts the cluster control planes, can manage the updates as needed. The hosted cluster handles control plane updates, and node pools handle node updates.</simpara>
<section xml:id="updates-for-hosted-control-planes_updating-hosted-control-planes">
<title>Updates for hosted control planes</title>
<simpara>Updates for hosted control planes involve updating the hosted cluster and the node pools. For a cluster to remain fully operational during an update process, you must meet the requirements of the <link xl:href="https://kubernetes.io/releases/version-skew-policy/">Kubernetes version skew policy</link> while completing the control plane and node updates.</simpara>
<section xml:id="updates-for-hosted-control-planes-hostedcluster_updating-hosted-control-planes">
<title>Updates for the hosted cluster</title>
<simpara>The <literal>spec.release</literal> value dictates the version of the control plane. The <literal>HostedCluster</literal> object transmits the intended <literal>spec.release</literal> value to the <literal>HostedControlPlane.spec.release</literal> value and runs the appropriate Control Plane Operator version.</simpara>
<simpara>The hosted control plane manages the rollout of the new version of the control plane components along with any {product-title} components through the new version of the Cluster Version Operator (CVO).</simpara>
</section>
<section xml:id="updates-for-hosted-control-planes-nodepools_updating-hosted-control-planes">
<title>Updates for node pools</title>
<simpara>With node pools, you can configure the software that is running in the nodes by exposing the <literal>spec.release</literal> and <literal>spec.config</literal> values. You can start a rolling node pool update in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Changing the <literal>spec.release</literal> or <literal>spec.config</literal> values.</simpara>
</listitem>
<listitem>
<simpara>Changing any platform-specific field, such as the AWS instance type. The result is a set of new instances with the new type.</simpara>
</listitem>
<listitem>
<simpara>Changing the cluster configuration, if the change propagates to the node.</simpara>
</listitem>
</itemizedlist>
<simpara>Node pools support replace updates and in-place updates. The <literal>nodepool.spec.release</literal> value dictates the version of any particular node pool. A <literal>NodePool</literal> object completes a replace or an in-place rolling update according to the <literal>.spec.management.upgradeType</literal> value.</simpara>
<simpara>After you create a node pool, you cannot change the update type. If you want to change the update type, you must create a node pool and delete the other one.</simpara>
<section xml:id="updates-for-nodepools-replace_updating-hosted-control-planes">
<title>Replace updates for node pools</title>
<simpara>A <emphasis>replace</emphasis> update creates instances in the new version while it removes old instances from the previous version. This update type is effective in cloud environments where this level of immutability is cost effective.</simpara>
<simpara>Replace updates do not preserve any manual changes because the node is entirely re-provisioned.</simpara>
</section>
<section xml:id="updates-for-nodepools-inplace_updating-hosted-control-planes">
<title>In place updates for node pools</title>
<simpara>An <emphasis>in-place</emphasis> update directly updates the operating systems of the instances. This type is suitable for environments where the infrastructure constraints are higher, such as bare metal.</simpara>
<simpara>In-place updates can preserve manual changes, but will report errors if you make manual changes to any file system or operating system configuration that the cluster directly manages, such as kubelet certificates.</simpara>
</section>
</section>
</section>
<section xml:id="updating-node-pools-for-hcp_updating-hosted-control-planes">
<title>Updating node pools for hosted control planes</title>
<simpara>On hosted control planes, you update your version of {product-title} by updating the node pools. The node pool version must not surpass the hosted control plane version.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To start the process to update to a new version of {product-title}, change the <literal>spec.release.image</literal> value of the node pool by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n NAMESPACE patch HC HCNAME --patch '{"spec":{"release":{"image": "example"}}}' --type=merge</programlisting>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To verify that the new version was rolled out, check the <literal>.status.version</literal> value and the status conditions.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="configuring-node-pools-for-hcp_updating-hosted-control-planes">
<title>Configuring node pools for hosted control planes</title>
<simpara>On hosted control planes, you can configure node pools by creating a <literal>MachineConfig</literal> object inside of a config map in the management cluster.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To create a <literal>MachineConfig</literal> object inside of a config map in the management cluster, enter the following information:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: &lt;configmap-name&gt;
  namespace: clusters
data:
  config: |
    apiVersion: machineconfiguration.openshift.io/v1
    kind: MachineConfig
    metadata:
      labels:
        machineconfiguration.openshift.io/role: worker
      name: &lt;machineconfig-name&gt;
    spec:
      config:
        ignition:
          version: 3.2.0
        storage:
          files:
          - contents:
              source: data:...
            mode: 420
            overwrite: true
            path: ${PATH} <co xml:id="CO40-1"/></programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>Sets the path on the node where the <literal>MachineConfig</literal> object is stored.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After you add the object to the config map, you can apply the config map to the node pool as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  config:
    - name: ${CONFIGMAP_NAME}</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="_troubleshooting_a_cluster_update">
<title>Troubleshooting a cluster update</title>
<section xml:id="gathering-data-cluster-update">
<title>Gathering data about your cluster update</title>

<simpara>When reaching out to Red Hat support for issues with an update, it is important to provide data for the support team to use for troubleshooting your failed cluster update.</simpara>
<section xml:id="gathering-log-data_troubleshooting_updates">
<title>Gathering log data for a support case</title>
<simpara>To gather data from your cluster, including log data, use the <literal>oc adm must-gather</literal> command. See <emphasis>Gathering data about your cluster</emphasis>.</simpara>
</section>
<section xml:id="gathering-clusterversion-history_troubleshooting_updates">
<title>Gathering ClusterVersion history</title>
<simpara>The Cluster Version Operator (CVO) records updates made to a cluster, known as the ClusterVersion history. The entries can reveal correlation between changes in cluster behavior with potential triggers, although correlation does not imply causation.</simpara>
<note>
<simpara>The initial, minor, and z-stream version updates are stored by the ClusterVersion history. However, the ClusterVersion history has a size limit. If the limit is reached, the oldest z-stream updates in previous minor versions are pruned to accommodate the limit.</simpara>
</note>
<simpara>You can view the ClusterVersion history by using the {product-title} web console or by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<section xml:id="gathering-clusterversion-history-console_troubleshooting_updates">
<title>Gathering ClusterVersion history in the {product-title} web console</title>
<simpara>You can view the ClusterVersion history in the {product-title} web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have access to the {product-title} web console.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>From the web console, click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis> and review the contents of the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="gathering-clusterversion-history-cli_troubleshooting_updates">
<title>Gathering ClusterVersion history using the OpenShift CLI (<literal>oc</literal>)</title>
<simpara>You can view the ClusterVersion history using the OpenShift CLI (<literal>oc</literal>).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>View the cluster update history by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe clusterversions/version</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">  Desired:
    Channels:
      candidate-4.13
      candidate-4.14
      fast-4.13
      fast-4.14
      stable-4.13
    Image:    quay.io/openshift-release-dev/ocp-release@sha256:a148b19231e4634196717c3597001b7d0af91bf3a887c03c444f59d9582864f4
    URL:      https://access.redhat.com/errata/RHSA-2023:6130
    Version:  4.13.19
  History:
    Completion Time:    2023-11-07T20:26:04Z
    Image:              quay.io/openshift-release-dev/ocp-release@sha256:a148b19231e4634196717c3597001b7d0af91bf3a887c03c444f59d9582864f4
    Started Time:       2023-11-07T19:11:36Z
    State:              Completed
    Verified:           true
    Version:            4.13.19
    Completion Time:    2023-10-04T18:53:29Z
    Image:              quay.io/openshift-release-dev/ocp-release@sha256:eac141144d2ecd6cf27d24efe9209358ba516da22becc5f0abc199d25a9cfcec
    Started Time:       2023-10-04T17:26:31Z
    State:              Completed
    Verified:           true
    Version:            4.13.13
    Completion Time:    2023-09-26T14:21:43Z
    Image:              quay.io/openshift-release-dev/ocp-release@sha256:371328736411972e9640a9b24a07be0af16880863e1c1ab8b013f9984b4ef727
    Started Time:       2023-09-26T14:02:33Z
    State:              Completed
    Verified:           false
    Version:            4.13.12
  Observed Generation:  4
  Version Hash:         CMLl3sLq-EA=
Events:                 &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist xml:id="additional-resources_gathering-cluster-data" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xl:href="../../support/gathering-cluster-data.xml#support_gathering_data_gathering-cluster-data">Gathering data about your cluster</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</chapter>
</book>