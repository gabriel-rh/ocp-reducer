<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Images</title>
<date>2024-02-20</date>
</info>
<chapter xml:id="overview-of-images">
<title>Overview of images</title>

<section xml:id="about-containers-images-and-image-streams">
<title>Understanding containers, images, and image streams</title>
<simpara>Containers, images, and image streams are important concepts to understand when you set out to create and manage containerized software.
An image holds a set of software that is ready to run, while a container is a running instance of a container image.
An image stream provides a way of storing different versions of the same basic image.
Those different versions are represented by different tags on the same image name.</simpara>
</section>
<section xml:id="images-about_overview-of-images">
<title>Images</title>
<simpara>Containers in OpenShift Container Platform are based on OCI- or Docker-formatted container <emphasis>images</emphasis>. An image is a binary that includes all of the requirements for running a single container, as well as metadata describing its needs and capabilities.</simpara>
<simpara>You can think of it as a packaging technology. Containers only have access to resources defined in the image unless you give the container additional access when creating it. By deploying the same image in multiple containers across multiple hosts and load balancing between them, OpenShift Container Platform can provide redundancy and horizontal scaling for a service packaged into an image.</simpara>
<simpara>You can use the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/managing_containers/#using_podman_to_work_with_containers">podman</link> or <literal>docker</literal> CLI directly to build images, but OpenShift Container Platform also supplies builder images that assist with creating new images by adding your code or configuration to existing images.</simpara>
<simpara>Because applications develop over time, a single image name can actually refer to many different versions of the same image. Each different image is referred to uniquely by its hash, a long hexadecimal number such as <literal>fd44297e2ddb050ec4f&#8230;&#8203;</literal>, which is usually shortened to 12 characters, such as <literal>fd44297e2ddb</literal>.</simpara>
<simpara>You can <link xlink:href="../openshift_images/create-images.xml#creating-images">create</link>, <link xlink:href="../openshift_images/managing_images/managing-images-overview.xml#managing-images-overview">manage</link>, and <link xlink:href="../openshift_images/using_images/using-images-overview.xml#using-images-overview">use</link> container images.</simpara>
</section>
<section xml:id="images-image-registry-about_overview-of-images">
<title>Image registry</title>
<simpara>An image registry is a content server that can store and serve container images. For example:</simpara>
<programlisting language="text" linenumbering="unnumbered">registry.redhat.io</programlisting>
<simpara>A registry contains a collection of one or more image repositories, which contain one or more tagged images. Red Hat provides a registry at <literal>registry.redhat.io</literal> for subscribers. OpenShift Container Platform can also supply its own OpenShift image registry for managing custom container images.</simpara>
</section>
<section xml:id="images-container-repository-about_overview-of-images">
<title>Image repository</title>
<simpara>An image repository is a collection of related container images and tags identifying them. For example, the OpenShift Container Platform Jenkins images are in the repository:</simpara>
<programlisting language="text" linenumbering="unnumbered">docker.io/openshift/jenkins-2-centos7</programlisting>
</section>
<section xml:id="images-tag_overview-of-images">
<title>Image tags</title>
<simpara>An image tag is a label applied to a container image in a repository that distinguishes a specific image from other images in an image stream. Typically, the tag represents a version number of some sort. For example, here <literal>:v3.11.59-2</literal> is the tag:</simpara>
<programlisting language="text" linenumbering="unnumbered">registry.access.redhat.com/openshift3/jenkins-2-rhel7:v3.11.59-2</programlisting>
<simpara>You can add additional tags to an image. For example, an image might be assigned the tags <literal>:v3.11.59-2</literal> and <literal>:latest</literal>.</simpara>
<simpara>OpenShift Container Platform provides the <literal>oc tag</literal> command, which is similar to the <literal>docker tag</literal> command, but operates on image streams instead of directly on images.</simpara>
</section>
<section xml:id="images-id_overview-of-images">
<title>Image IDs</title>
<simpara>An image ID is a SHA (Secure Hash Algorithm) code that can be used to pull an image. A SHA image ID cannot change. A specific SHA identifier always references the exact same container image content.  For example:</simpara>
<programlisting language="text" linenumbering="unnumbered">docker.io/openshift/jenkins-2-centos7@sha256:ab312bda324</programlisting>
</section>
<section xml:id="containers-about_overview-of-images">
<title>Containers</title>
<simpara>The basic units of OpenShift Container Platform applications are called containers. <link xlink:href="https://www.redhat.com/en/topics/containers#overview">Linux container technologies</link> are lightweight mechanisms for isolating running processes so that they are limited to interacting with only their designated resources. The word container is defined as a specific running or paused instance of a container image.</simpara>
<simpara>Many application instances can be running in containers on a single host without visibility into each others' processes, files, network, and so on. Typically, each container provides a single service, often called a micro-service, such as a web server or a database, though containers can be used for arbitrary workloads.</simpara>
<simpara>The Linux kernel has been incorporating capabilities for container technologies for years. The Docker project developed a convenient management interface for Linux containers on a host. More recently, the <link xlink:href="https://github.com/opencontainers/">Open Container Initiative</link> has developed open standards for container formats and container runtimes. OpenShift Container Platform and Kubernetes add the ability to orchestrate OCI- and Docker-formatted containers across multi-host installations.</simpara>
<simpara>Though you do not directly interact with container runtimes when using OpenShift Container Platform, understanding their capabilities and terminology is important for understanding their role in OpenShift Container Platform and how your applications function inside of containers.</simpara>
<simpara>Tools such as <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html-single/managing_containers/#using_podman_to_work_with_containers">podman</link> can be used to replace <literal>docker</literal> command-line tools for running and managing containers directly. Using <literal>podman</literal>, you can experiment with containers separately from OpenShift Container Platform.</simpara>
</section>
<section xml:id="images-imagestream-use_overview-of-images">
<title>Why use imagestreams</title>
<simpara>An image stream and its associated tags provide an abstraction for referencing container images from within OpenShift Container Platform. The image stream and its tags allow you to see what images are available and ensure that you are using the specific image you need even if the image in the repository changes.</simpara>
<simpara>Image streams do not contain actual image data, but present a single virtual view of related images, similar to an image repository.</simpara>
<simpara>You can configure builds and deployments to watch an image stream for notifications when new images are added and react by performing a build or deployment, respectively.</simpara>
<simpara>For example, if a deployment is using a certain image and a new version of that image is created, a deployment could be automatically performed to pick up the new version of the image.</simpara>
<simpara>However, if the image stream tag used by the deployment or build is not updated, then even if the container image in the container image registry is updated, the build or deployment continues using the previous, presumably known good
image.</simpara>
<simpara>The source images can be stored in any of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform&#8217;s integrated registry.</simpara>
</listitem>
<listitem>
<simpara>An external registry, for example registry.redhat.io or quay.io.</simpara>
</listitem>
<listitem>
<simpara>Other image streams in the OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<simpara>When you define an object that references an image stream tag, such as a build or deployment configuration, you point to an image stream tag and not the repository. When you build or deploy your application, OpenShift Container Platform queries the repository using the image stream tag to locate the associated ID of the image and uses that exact image.</simpara>
<simpara>The image stream metadata is stored in the etcd instance along with other cluster information.</simpara>
<simpara>Using image streams has several significant benefits:</simpara>
<itemizedlist>
<listitem>
<simpara>You can tag, rollback a tag, and quickly deal with images, without having to re-push using the command line.</simpara>
</listitem>
<listitem>
<simpara>You can trigger builds and deployments when a new image is pushed to the registry. Also, OpenShift Container Platform has generic triggers for other resources, such as Kubernetes objects.</simpara>
</listitem>
<listitem>
<simpara>You can mark a tag for periodic re-import. If the source image has changed, that change is picked up and reflected in the image stream, which triggers the build or deployment flow, depending upon the build or deployment configuration.</simpara>
</listitem>
<listitem>
<simpara>You can share images using fine-grained access control and quickly distribute images across your teams.</simpara>
</listitem>
<listitem>
<simpara>If the source image changes, the image stream tag still points to a known-good version of the image, ensuring that your application do not break unexpectedly.</simpara>
</listitem>
<listitem>
<simpara>You can configure security around who can view and use the images through permissions on the image stream objects.</simpara>
</listitem>
<listitem>
<simpara>Users that lack permission to read or list images on the cluster level can still retrieve the images tagged in a project using image streams.</simpara>
</listitem>
</itemizedlist>
<simpara>You can <link xlink:href="../openshift_images/image-streams-manage.xml#managing-image-streams">manage</link> image streams, <link xlink:href="../openshift_images/using-imagestreams-with-kube-resources.xml#using-imagestreams-with-kube-resources">use image streams with Kubernetes resources</link>, and <link xlink:href="../openshift_images/triggering-updates-on-imagestream-changes.xml#triggering-updates-on-imagestream-changes">trigger updates on image stream updates</link>.</simpara>
</section>
<section xml:id="images-imagestream-tag_overview-of-images">
<title>Image stream tags</title>
<simpara>An image stream tag is a named pointer to an image in an image stream. An image stream tag is similar to a container image tag.</simpara>
</section>
<section xml:id="images-imagestream-image_overview-of-images">
<title>Image stream images</title>
<simpara>An image stream image allows you to retrieve a specific container image from a particular image stream where it is tagged. An image stream image is an API resource object that pulls together some metadata about a particular image SHA identifier.</simpara>
</section>
<section xml:id="images-imagestream-trigger_overview-of-images">
<title>Image stream triggers</title>
<simpara>An image stream trigger causes a specific action when an image stream tag changes. For example, importing can cause the value of the tag to change, which causes a trigger to fire when there are deployments, builds, or other resources listening for those.</simpara>
</section>
<section xml:id="how-you-can-use-the-cluster-samples-operator">
<title>How you can use the Cluster Samples Operator</title>
<simpara>During the initial startup, the Operator creates the default samples resource to initiate the creation of the image streams and templates.
You can use the Cluster Samples Operator to manage the sample image streams and templates stored in the <literal>openshift</literal> namespace.</simpara>
<simpara>As a cluster administrator, you can use the Cluster Samples Operator to:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../openshift_images/configuring-samples-operator.xml#configuring-samples-operator">Configure the Operator</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../openshift_images/samples-operator-alt-registry.xml#samples-operator-alt-registry">Use the Operator with an alternate registry</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="about-templates">
<title>About templates</title>
<simpara>A template is a definition of an object to be replicated.
You can use <link xlink:href="../openshift_images/using-templates.xml#using-templates">templates</link> to build and deploy configurations.</simpara>
</section>
<section xml:id="how-you-can-use-ruby-on-rails">
<title>How you can use Ruby on Rails</title>
<simpara>As a developer, you can use <link xlink:href="../openshift_images/templates-using-ruby-on-rails.xml#templates-using-ruby-on-rails">Ruby on Rails</link> to:</simpara>
<itemizedlist>
<listitem>
<simpara>Write your application:</simpara>
<itemizedlist>
<listitem>
<simpara>Set up a database.</simpara>
</listitem>
<listitem>
<simpara>Create a welcome page.</simpara>
</listitem>
<listitem>
<simpara>Configure your application for OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Store your application in Git.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Deploy your application in OpenShift Container Platform:</simpara>
<itemizedlist>
<listitem>
<simpara>Create the database service.</simpara>
</listitem>
<listitem>
<simpara>Create the frontend service.</simpara>
</listitem>
<listitem>
<simpara>Create a route for your application.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="configuring-samples-operator">
<title>Configuring the Cluster Samples Operator</title>

<simpara>The Cluster Samples Operator, which operates in the <literal>openshift</literal> namespace, installs and updates the Red Hat Enterprise Linux (RHEL)-based OpenShift Container Platform image streams and OpenShift Container Platform templates.</simpara>
<important>
<title>Cluster Samples Operator is being downsized</title>
<itemizedlist>
<listitem>
<simpara>Starting from OpenShift Container Platform 4.13, Cluster Samples Operator is downsized. Cluster Samples Operator will stop providing the following updates for non-Source-to-Image (Non-S2I) image streams and templates:</simpara>
<itemizedlist>
<listitem>
<simpara>new image streams and templates</simpara>
</listitem>
<listitem>
<simpara>updates to the existing image streams and templates unless it is a CVE update</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Cluster Samples Operator will provide support for Non-S2I image streams and templates as per the <link xlink:href="https://access.redhat.com/support/policy/updates/openshift#dates">OpenShift Container Platform lifecycle policy dates and support guidelines</link>.</simpara>
</listitem>
<listitem>
<simpara>Cluster Samples Operator will continue to support the S2I builder image streams and templates and accept the updates. S2I image streams and templates include:</simpara>
<itemizedlist>
<listitem>
<simpara>Ruby</simpara>
</listitem>
<listitem>
<simpara>Python</simpara>
</listitem>
<listitem>
<simpara>Node.js</simpara>
</listitem>
<listitem>
<simpara>Perl</simpara>
</listitem>
<listitem>
<simpara>PHP</simpara>
</listitem>
<listitem>
<simpara>HTTPD</simpara>
</listitem>
<listitem>
<simpara>Nginx</simpara>
</listitem>
<listitem>
<simpara>EAP</simpara>
</listitem>
<listitem>
<simpara>Java</simpara>
</listitem>
<listitem>
<simpara>Webserver</simpara>
</listitem>
<listitem>
<simpara>.NET</simpara>
</listitem>
<listitem>
<simpara>Go</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Starting from OpenShift Container Platform 4.16, Cluster Samples Operator will stop managing non-S2I image streams and templates. You can contact the image stream or template owner for any requirements and future plans. In addition, refer to the <link xlink:href="https://github.com/openshift/library/blob/master/official.yaml">list of the repositories hosting the image stream or templates</link>.</simpara>
</listitem>
</itemizedlist>
</important>
<section xml:id="samples-operator-overview_configuring-samples-operator">
<title>Understanding the Cluster Samples Operator</title>
<simpara>During installation, the Operator creates the default configuration object for
itself and then creates the sample image streams and templates, including quick start templates.</simpara>
<note>
<simpara>To facilitate image stream imports from other registries that require credentials, a cluster administrator can create any additional secrets that contain the content of a Docker <literal>config.json</literal> file in the <literal>openshift</literal> namespace needed for image import.</simpara>
</note>
<simpara>The Cluster Samples Operator configuration is a cluster-wide resource, and the deployment is contained within the <literal>openshift-cluster-samples-operator</literal> namespace.</simpara>
<simpara>The image for the Cluster Samples Operator contains image stream and template definitions
for the associated OpenShift Container Platform release. When each sample is created or updated,
the Cluster Samples Operator includes an annotation that denotes the version of
OpenShift Container Platform. The Operator uses this annotation to ensure that each sample
matches the release version. Samples outside of its inventory are ignored, as
are skipped samples. Modifications to any samples that are managed by the
Operator, where that version annotation is modified or deleted, are reverted
automatically.</simpara>
<note>
<simpara>The Jenkins images are part of the image payload from
installation and are tagged into the image streams directly.</simpara>
</note>
<simpara>The Cluster Samples Operator configuration resource includes a finalizer which cleans up
the following upon deletion:</simpara>
<itemizedlist>
<listitem>
<simpara>Operator managed image streams.</simpara>
</listitem>
<listitem>
<simpara>Operator managed templates.</simpara>
</listitem>
<listitem>
<simpara>Operator generated configuration resources.</simpara>
</listitem>
<listitem>
<simpara>Cluster status resources.</simpara>
</listitem>
</itemizedlist>
<simpara>Upon deletion of the samples resource, the Cluster Samples Operator recreates the
resource using the default configuration.</simpara>
<section xml:id="samples-operator-bootstrapped">
<title>Cluster Samples Operator&#8217;s use of management state</title>
<simpara>The Cluster Samples Operator is bootstrapped as <literal>Managed</literal> by default or if global proxy is configured. In the <literal>Managed</literal> state, the Cluster Samples Operator is actively managing its resources and keeping the component active in order to pull sample image streams and images from the registry and ensure that the requisite sample templates are installed.</simpara>
<simpara>Certain circumstances result in the Cluster Samples Operator bootstrapping itself as <literal>Removed</literal> including:</simpara>
<itemizedlist>
<listitem>
<simpara>If the Cluster Samples Operator cannot reach <link xlink:href="https://registry.redhat.io">registry.redhat.io</link> after three minutes on initial startup after a clean installation.</simpara>
</listitem>
<listitem>
<simpara>If the Cluster Samples Operator detects it is on an IPv6 network.</simpara>
</listitem>
<listitem>
<simpara>If the <link xlink:href="../openshift_images/image-configuration.xml#images-configuration-parameters_image-configuration">image controller configuration parameters</link> prevent the creation of image streams by using the default image registry, or by using the image registry specified by the <link xlink:href="../openshift_images/configuring-samples-operator.xml#samples-operator-configuration_configuring-samples-operator"><literal>samplesRegistry</literal> setting</link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For OpenShift Container Platform, the default image registry is
<literal>registry.redhat.io</literal>.</simpara>
</note>
<simpara>However, if the Cluster Samples Operator detects that it is on an IPv6 network and an OpenShift Container Platform global proxy is configured, then IPv6 check supersedes all the checks. As a result, the Cluster Samples Operator bootstraps itself as <literal>Removed</literal>.</simpara>
<important>
<simpara>IPv6 installations are not currently supported by <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>. The Cluster Samples Operator pulls most of the sample image streams and images from <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>.</simpara>
</important>
<section xml:id="samples-operator-restricted-network-install">
<title>Restricted network installation</title>
<simpara>Boostrapping as <literal>Removed</literal> when unable to access <literal>registry.redhat.io</literal> facilitates restricted network installations when the network restriction is already in place. Bootstrapping as <literal>Removed</literal> when network access is restricted allows the cluster administrator more time to decide if samples are desired, because the Cluster Samples Operator does not submit alerts that sample image stream imports are failing when the management state is set to <literal>Removed</literal>. When the Cluster Samples Operator comes up as <literal>Managed</literal> and attempts to install sample image streams, it starts alerting two hours after initial installation if there are failing imports.</simpara>
</section>
<section xml:id="samples-operator-restricted-network-install-with-access">
<title>Restricted network installation with initial network access</title>
<simpara>Conversely, if a cluster that is intended to be a restricted network or disconnected cluster is first installed while network access exists, the Cluster Samples Operator installs the content from <literal>registry.redhat.io</literal> since it can access it. If you want the Cluster Samples Operator to still bootstrap as <literal>Removed</literal> in order to defer samples installation until you have decided which samples are desired, set up image mirrors, and so on, then follow the instructions for using the Samples Operator with an alternate registry and customizing nodes, both linked in the additional resources section, to override the Cluster Samples Operator default configuration and initially come up as <literal>Removed</literal>.</simpara>
<simpara>You must put the following additional YAML file in the <literal>openshift</literal> directory created by <literal>openshift-install create manifest</literal>:</simpara>
<formalpara>
<title>Example Cluster Samples Operator YAML file with <literal>managementState: Removed</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: samples.operator.openshift.io/v1
kind: Config
metadata:
  name: cluster
spec:
  architectures:
  - x86_64
  managementState: Removed</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="samples-operator-retries">
<title>Cluster Samples Operator&#8217;s tracking and error recovery of image stream imports</title>
<simpara>After creation or update of a samples image stream, the Cluster Samples Operator monitors the progress of each image stream tag&#8217;s image import.</simpara>
<simpara>If an import fails, the Cluster Samples Operator retries the import through the image stream image import API, which is the same API used by the <literal>oc import-image</literal> command, approximately every 15 minutes until it sees the import succeed, or if
the Cluster Samples Operator&#8217;s configuration is changed such that either the image stream is added to the <literal>skippedImagestreams</literal> list, or the management state is changed to <literal>Removed</literal>.</simpara>
<bridgehead xml:id="_additional_resources" role="_additional-resources" renderas="sect2">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara>If the Cluster Samples Operator is removed during installation, you can <link xlink:href="../openshift_images/samples-operator-alt-registry.xml#samples-operator-alt-registry">use the Cluster Samples Operator with an alternate registry</link> so content can be imported, and then set the Cluster Samples Operator to <literal>Managed</literal> to get the samples.</simpara>
</listitem>
<listitem>
<simpara>To ensure the Cluster Samples Operator bootstraps as <literal>Removed</literal> in a restricted network installation with initial network access to defer samples installation until you have decided which samples are desired, follow the instructions for <link xlink:href="../installing/install_config/installing-customizing.xml#installing-customizing">customizing nodes</link> to override the Cluster Samples Operator default configuration and initially come up as <literal>Removed</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>To host samples in your disconnected environment, follow the instructions for <link xlink:href="../openshift_images/samples-operator-alt-registry.xml#samples-operator-alt-registry">using the Cluster Samples Operator with an alternate registry</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="installation-images-samples-disconnected-mirroring-assist_configuring-samples-operator">
<title>Cluster Samples Operator assistance for mirroring</title>
<simpara>During installation, OpenShift Container Platform creates a config map named <literal>imagestreamtag-to-image</literal> in the <literal>openshift-cluster-samples-operator</literal> namespace. The <literal>imagestreamtag-to-image</literal> config map contains an entry, the populating image, for each image stream tag.</simpara>
<simpara>The format of the key for each entry in the data field in the config map is <literal>&lt;image_stream_name&gt;_&lt;image_stream_tag_name&gt;</literal>.</simpara>
<simpara>During a disconnected installation of OpenShift Container Platform, the status of the Cluster Samples Operator is set to <literal>Removed</literal>. If you choose to change it to <literal>Managed</literal>, it installs samples.</simpara>
<note>
<simpara>The use of samples in a network-restricted or discontinued environment may require access to services external to your network. Some example services include: Github, Maven Central, npm, RubyGems, PyPi and others. There might be additional steps to take that allow the cluster samples operators&#8217;s objects to reach the services they require.</simpara>
</note>
<simpara>You can use this config map as a reference for which images need to be mirrored for your image streams to import.</simpara>
<itemizedlist>
<listitem>
<simpara>While the Cluster Samples Operator is set to <literal>Removed</literal>, you can create your mirrored registry, or determine which existing mirrored registry you want to use.</simpara>
</listitem>
<listitem>
<simpara>Mirror the samples you want to the mirrored registry using the new config map as your guide.</simpara>
</listitem>
<listitem>
<simpara>Add any of the image streams you did not mirror to the <literal>skippedImagestreams</literal> list of the Cluster Samples Operator configuration object.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>samplesRegistry</literal> of the Cluster Samples Operator configuration object to the mirrored registry.</simpara>
</listitem>
<listitem>
<simpara>Then set the Cluster Samples Operator to <literal>Managed</literal> to install the image streams you have mirrored.</simpara>
</listitem>
</itemizedlist>
<simpara>See <link xlink:href="../openshift_images/samples-operator-alt-registry.xml#installation-restricted-network-samples_samples-operator-alt-registry">Using Cluster Samples Operator image streams with alternate or mirrored registries</link> for a detailed procedure.</simpara>
</section>
</section>
<section xml:id="samples-operator-configuration_configuring-samples-operator">
<title>Cluster Samples Operator configuration parameters</title>
<simpara>The samples resource offers the following configuration fields:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>managementState</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Managed</literal>: The Cluster Samples Operator updates the samples as the configuration dictates.</simpara>
<simpara><literal>Unmanaged</literal>: The Cluster Samples Operator ignores updates to its configuration resource object and any image streams or templates in the <literal>openshift</literal> namespace.</simpara>
<simpara><literal>Removed</literal>: The Cluster Samples Operator removes the set of <literal>Managed</literal> image streams and templates in the <literal>openshift</literal> namespace. It ignores new samples created by the cluster administrator or any samples in the skipped lists. After the removals are complete, the Cluster Samples Operator works like it is in the <literal>Unmanaged</literal> state and ignores any watch events on the sample resources, image streams, or templates.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>samplesRegistry</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows you to specify which registry is accessed by image streams for their image content. <literal>samplesRegistry</literal> defaults to <literal>registry.redhat.io</literal> for OpenShift Container Platform.</simpara>
<note>
<simpara>Creation or update of RHEL content does not commence if the secret for pull access is not in place when either <literal>Samples Registry</literal> is not explicitly set, leaving an empty string, or when it is set to registry.redhat.io. In both cases, image imports work off of registry.redhat.io, which requires credentials.</simpara>
<simpara>Creation or update of RHEL content is not gated by the existence of the pull secret if the <literal>Samples Registry</literal> is overridden to a value other than the empty string or registry.redhat.io.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>architectures</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Placeholder to choose an architecture type.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>skippedImagestreams</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Image streams that are in the Cluster Samples Operator&#8217;s inventory but that the cluster administrator wants the Operator to ignore or not manage. You can add a list of image stream names to this parameter. For example, <literal>["httpd","perl"]</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>skippedTemplates</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Templates that are in the Cluster Samples Operator&#8217;s inventory, but that the cluster administrator wants the Operator to ignore or not manage.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Secret, image stream, and template watch events can come in before the initial samples resource object is created, the Cluster Samples Operator detects and re-queues the event.</simpara>
<section xml:id="_configuration_restrictions">
<title>Configuration restrictions</title>
<simpara>When the Cluster Samples Operator starts supporting multiple architectures, the architecture list is not allowed to be changed while in the <literal>Managed</literal> state.</simpara>
<simpara>To change the architectures values, a cluster administrator must:</simpara>
<itemizedlist>
<listitem>
<simpara>Mark the <literal>Management State</literal> as <literal>Removed</literal>, saving the change.</simpara>
</listitem>
<listitem>
<simpara>In a subsequent change, edit the architecture and change the <literal>Management State</literal> back to <literal>Managed</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The Cluster Samples Operator still processes secrets while in <literal>Removed</literal> state. You can create the secret before switching to <literal>Removed</literal>, while in <literal>Removed</literal> before switching to <literal>Managed</literal>, or after switching to <literal>Managed</literal> state. There are delays in creating the samples until the secret event is processed if you create the secret after switching to <literal>Managed</literal>. This helps facilitate the changing of the registry, where you choose to remove all the samples before switching to insure a clean slate. Removing all samples before switching is not required.</simpara>
</section>
<section xml:id="_conditions">
<title>Conditions</title>
<simpara>The samples resource maintains the following conditions in its status:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Condition</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SamplesExists</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicates the samples are created in the <literal>openshift</literal> namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ImageChangesInProgress</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal> when image streams are created or updated, but not all of the tag spec generations and tag status generations match.</simpara>
<simpara><literal>False</literal> when all of the generations match, or unrecoverable errors occurred during import, the last seen error is in the message field. The list of pending image streams is in the reason field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ConfigurationValid</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal> or <literal>False</literal> based on whether any of the restricted changes noted previously are submitted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RemovePending</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicator that there is a <literal>Management State: Removed</literal> setting pending, but the Cluster Samples Operator is waiting for the deletions to complete.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ImportImageErrorsExist</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicator of which image streams had errors during the image import phase for one of their tags.</simpara>
<simpara><literal>True</literal> when an error has occurred. The list of image streams with an error is in the reason field. The details of each error reported are in the message field.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MigrationInProgress</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>True</literal> when the Cluster Samples Operator detects that the version is different than the Cluster Samples Operator version with which the current samples set are installed.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="samples-operator-crd_configuring-samples-operator">
<title>Accessing the Cluster Samples Operator configuration</title>
<simpara>You can configure the Cluster Samples Operator by editing the file with the provided parameters.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Access the  Cluster Samples Operator configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit configs.samples.operator.openshift.io/cluster -o yaml</programlisting>
<simpara>The Cluster Samples Operator configuration resembles the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: samples.operator.openshift.io/v1
kind: Config
# ...</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-samples-operator-deprecated-image-stream_configuring-samples-operator">
<title>Removing deprecated image stream tags from the Cluster Samples Operator</title>
<simpara>The Cluster Samples Operator leaves deprecated image stream tags in an image stream because users can have deployments that use the deprecated image stream tags.</simpara>
<simpara>You can remove deprecated image stream tags by editing the image stream with the  <literal>oc tag</literal> command.</simpara>
<note>
<simpara>Deprecated image stream tags that the samples providers have removed from their image streams are not included on initial installations.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You installed the <literal>oc</literal> CLI.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Remove deprecated image stream tags by editing the image stream with the  <literal>oc tag</literal> command.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag -d &lt;image_stream_name:tag&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Deleted tag default/&lt;image_stream_name:tag&gt;.</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_additional_resources_2" role="_additional-resources" renderas="sect2">Additional resources</bridgehead>
<itemizedlist>
<listitem>
<simpara>For more information about configuring credentials, see <link xlink:href="../openshift_images/managing_images/using-image-pull-secrets.xml#using-image-pull-secrets">Using image pull secrets</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="samples-operator-alt-registry">
<title>Using the Cluster Samples Operator with an alternate registry</title>

<simpara>You can use the Cluster Samples Operator with an alternate registry by first creating a mirror registry.</simpara>
<important>
<simpara>You must have access to the internet to obtain the necessary container images. In this procedure, you place the mirror registry on a mirror host that has access to both your network and the internet.</simpara>
</important>
<section xml:id="installation-about-mirror-registry_samples-operator-alt-registry">
<title>About the mirror registry</title>
<simpara>You can mirror the images that are required for OpenShift Container Platform installation and subsequent product updates to a container mirror registry such as Red Hat Quay, JFrog Artifactory, Sonatype Nexus Repository, or Harbor. If you do not have access to a large-scale container registry, you can use the <emphasis>mirror registry for Red Hat OpenShift</emphasis>, a small-scale container registry included with OpenShift Container Platform subscriptions.</simpara>
<simpara>You can use any container registry that supports <link xlink:href="https://docs.docker.com/registry/spec/manifest-v2-2">Docker v2-2</link>, such as Red Hat Quay, the <emphasis>mirror registry for Red Hat OpenShift</emphasis>, Artifactory, Sonatype Nexus Repository, or Harbor. Regardless of your chosen registry, the procedure to mirror content from Red Hat hosted sites on the internet to an isolated image registry is the same. After you mirror the content, you configure each cluster to retrieve this content from your mirror registry.</simpara>
<important>
<simpara>The OpenShift image registry cannot be used as the target registry because it does not support pushing without a tag, which is required during the mirroring process.</simpara>
</important>
<simpara>If choosing a container registry that is not the <emphasis>mirror registry for Red Hat OpenShift</emphasis>, it must be reachable by every machine in the clusters that you provision. If the registry is unreachable, installation, updating, or normal operations such as workload relocation might fail. For that reason, you must run mirror registries in a highly available way, and the mirror registries must at least match the production availability of your OpenShift Container Platform clusters.</simpara>
<simpara>When you populate your mirror registry with OpenShift Container Platform images, you can follow two scenarios. If you have a host that can access both the internet and your mirror registry, but not your cluster nodes, you can directly mirror the content from that machine. This process is referred to as <emphasis>connected mirroring</emphasis>. If you have no such host, you must mirror the images to a file system and then bring that host or removable media into your restricted environment. This process is referred to as <emphasis>disconnected mirroring</emphasis>.</simpara>
<simpara>For mirrored registries, to view the source of pulled images, you must review the <literal>Trying to access</literal> log entry in the CRI-O logs. Other methods to view the image pull source, such as using the <literal>crictl images</literal> command on a node, show the non-mirrored image name, even though the image is pulled from the mirrored location.</simpara>
<note>
<simpara>Red Hat does not test third party registries with OpenShift Container Platform.</simpara>
</note>
<formalpara>
<title>Additional information</title>
<para>For information on viewing the CRI-O logs to view the image source, see <link xlink:href="../installing/validating-an-installation.xml#viewing-the-image-pull-source_validating-an-installation">Viewing the image pull source</link>.</para>
</formalpara>
<section xml:id="samples-preparing-bastion">
<title>Preparing the mirror host</title>
<simpara>Before you create the mirror registry, you must prepare the mirror host.</simpara>
</section>
<section xml:id="cli-installing-cli_samples-operator-alt-registry">
<title>Installing the OpenShift CLI by downloading the binary</title>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) to interact with
OpenShift Container Platform
from a command-line interface. You can install <literal>oc</literal> on Linux, Windows, or macOS.</simpara>
<important>
<simpara>If you installed an earlier version of <literal>oc</literal>, you cannot use it to complete all of the commands in
OpenShift Container Platform 4.14.
Download and install the new version of <literal>oc</literal>.</simpara>
</important>
<bridgehead xml:id="_installing_the_openshift_cli_on_linux" renderas="sect4">Installing the OpenShift CLI on Linux</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on Linux by using the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to the <link xlink:href="https://access.redhat.com/downloads/content/290">OpenShift Container Platform downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the architecture from the <emphasis role="strong">Product Variant</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v4.14 Linux Client</emphasis> entry and save the file.</simpara>
</listitem>
<listitem>
<simpara>Unpack the archive:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ tar xvf &lt;file&gt;</programlisting>
</listitem>
<listitem>
<simpara>Place the <literal>oc</literal> binary in a directory that is on your <literal>PATH</literal>.</simpara>
<simpara>To check your <literal>PATH</literal>, execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
<bridgehead xml:id="_installing_the_openshift_cli_on_windows" renderas="sect4">Installing the OpenShift CLI on Windows</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on Windows by using the following procedure.
.Procedure</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <link xlink:href="https://access.redhat.com/downloads/content/290">OpenShift Container Platform downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v4.14 Windows Client</emphasis> entry and save the file.</simpara>
</listitem>
<listitem>
<simpara>Unzip the archive with a ZIP program.</simpara>
</listitem>
<listitem>
<simpara>Move the <literal>oc</literal> binary to a directory that is on your <literal>PATH</literal>.</simpara>
<simpara>To check your <literal>PATH</literal>, open the command prompt and execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">C:\&gt; path</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">C:\&gt; oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
<bridgehead xml:id="_installing_the_openshift_cli_on_macos" renderas="sect4">Installing the OpenShift CLI on macOS</bridgehead>
<simpara>You can install the OpenShift CLI (<literal>oc</literal>) binary on macOS by using the following procedure.
.Procedure</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the <link xlink:href="https://access.redhat.com/downloads/content/290">OpenShift Container Platform downloads page</link> on the Red Hat Customer Portal.</simpara>
</listitem>
<listitem>
<simpara>Select the appropriate version from the <emphasis role="strong">Version</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Download Now</emphasis> next to the <emphasis role="strong">OpenShift v4.14 macOS Client</emphasis> entry and save the file.</simpara>
<note>
<simpara>For macOS arm64, choose the <emphasis role="strong">OpenShift v4.14 macOS arm64 Client</emphasis> entry.</simpara>
</note>
</listitem>
<listitem>
<simpara>Unpack and unzip the archive.</simpara>
</listitem>
<listitem>
<simpara>Move the <literal>oc</literal> binary to a directory on your PATH.</simpara>
<simpara>To check your <literal>PATH</literal>, open a terminal and execute the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo $PATH</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>After you install the OpenShift CLI, it is available using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc &lt;command&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="installation-adding-registry-pull-secret_samples-operator-alt-registry">
<title>Configuring credentials that allow images to be mirrored</title>
<simpara>Create a container image registry credentials file that allows mirroring
images from Red Hat to your mirror.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You configured a mirror registry to use in your disconnected environment.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Complete the following steps on the installation host:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Download your <literal>registry.redhat.io</literal> <link xlink:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link>.</simpara>
</listitem>
<listitem>
<simpara>Make a copy of your pull secret in JSON format:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat ./pull-secret | jq . &gt; &lt;path&gt;/&lt;pull_secret_file_in_json&gt; <co xml:id="CO1-1"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Specify the path to the folder to store the pull secret in and a name for the JSON file that you create.</para>
</callout>
</calloutlist>
<simpara>The contents of the file resemble the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "auths": {
    "cloud.openshift.com": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "quay.io": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "registry.connect.redhat.com": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    },
    "registry.redhat.io": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    }
  }
}</programlisting>
</listitem>
<listitem>
<simpara>Generate the base64-encoded user name and password or token for your mirror registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ echo -n '&lt;user_name&gt;:&lt;password&gt;' | base64 -w0 <co xml:id="CO2-1"/>
BGVtbYk3ZHAtqXs=</programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>For <literal>&lt;user_name&gt;</literal> and <literal>&lt;password&gt;</literal>, specify the user name and password that you configured for your registry.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit the JSON
file and add a section that describes your registry to it:</simpara>
<programlisting language="json" linenumbering="unnumbered">  "auths": {
    "&lt;mirror_registry&gt;": { <co xml:id="CO3-1"/>
      "auth": "&lt;credentials&gt;", <co xml:id="CO3-2"/>
      "email": "you@example.com"
    }
  },</programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>For <literal>&lt;mirror_registry&gt;</literal>, specify the registry domain name, and optionally the
port, that your mirror registry uses to serve content. For example,
<literal>registry.example.com</literal> or <literal>registry.example.com:8443</literal></para>
</callout>
<callout arearefs="CO3-2">
<para>For <literal>&lt;credentials&gt;</literal>, specify the base64-encoded user name and password for
the mirror registry.</para>
</callout>
</calloutlist>
<simpara>The file resembles the following example:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "auths": {
    "registry.example.com": {
      "auth": "BGVtbYk3ZHAtqXs=",
      "email": "you@example.com"
    },
    "cloud.openshift.com": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "quay.io": {
      "auth": "b3BlbnNo...",
      "email": "you@example.com"
    },
    "registry.connect.redhat.com": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    },
    "registry.redhat.io": {
      "auth": "NTE3Njg5Nj...",
      "email": "you@example.com"
    }
  }
}</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-mirror-repository_samples-operator-alt-registry">
<title>Mirroring the OpenShift Container Platform image repository</title>
<simpara>Mirror the OpenShift Container Platform image repository to your registry to use during cluster installation or upgrade.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your mirror host has access to the internet.</simpara>
</listitem>
<listitem>
<simpara>You configured a mirror registry to use in your restricted network and
can access the certificate and credentials that you configured.</simpara>
</listitem>
<listitem>
<simpara>You downloaded the <link xlink:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link> and modified it to include authentication to your mirror repository.</simpara>
</listitem>
<listitem>
<simpara>If you use self-signed certificates, you have specified a Subject Alternative Name in the certificates.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Complete the following steps on the mirror host:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Review the
<link xlink:href="https://access.redhat.com/downloads/content/290/">OpenShift Container Platform downloads page</link>
to determine the version of OpenShift Container Platform that you want to install and determine the corresponding tag on the <link xlink:href="https://quay.io/repository/openshift-release-dev/ocp-release?tab=tags">Repository Tags</link> page.</simpara>
</listitem>
<listitem>
<simpara>Set the required environment variables:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Export the release version:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ OCP_RELEASE=&lt;release_version&gt;</programlisting>
<simpara>For <literal>&lt;release_version&gt;</literal>, specify the tag that corresponds to the version of OpenShift Container Platform to
install, such as <literal>4.5.4</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the local registry name and host port:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_REGISTRY='&lt;local_registry_host_name&gt;:&lt;local_registry_host_port&gt;'</programlisting>
<simpara>For <literal>&lt;local_registry_host_name&gt;</literal>, specify the registry domain name for your mirror
repository, and for <literal>&lt;local_registry_host_port&gt;</literal>, specify the port that it
serves content on.</simpara>
</listitem>
<listitem>
<simpara>Export the local repository name:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_REPOSITORY='&lt;local_repository_name&gt;'</programlisting>
<simpara>For <literal>&lt;local_repository_name&gt;</literal>, specify the name of the repository to create in your
registry, such as <literal>ocp4/openshift4</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the name of the repository to mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ PRODUCT_REPO='openshift-release-dev'</programlisting>
<simpara>For a production release, you must specify <literal>openshift-release-dev</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the path to your registry pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ LOCAL_SECRET_JSON='&lt;path_to_pull_secret&gt;'</programlisting>
<simpara>For <literal>&lt;path_to_pull_secret&gt;</literal>, specify the absolute path to and file name of the pull secret for your mirror registry that you created.</simpara>
</listitem>
<listitem>
<simpara>Export the release mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RELEASE_NAME="ocp-release"</programlisting>
<simpara>For a production release, you must specify <literal>ocp-release</literal>.</simpara>
</listitem>
<listitem>
<simpara>Export the type of architecture for your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ARCHITECTURE=&lt;cluster_architecture&gt; <co xml:id="CO4-1"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>Specify the architecture of the cluster, such as <literal>x86_64</literal>, <literal>aarch64</literal>, <literal>s390x</literal>, or <literal>ppc64le</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Export the path to the directory to host the mirrored images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ REMOVABLE_MEDIA_PATH=&lt;path&gt; <co xml:id="CO5-1"/></programlisting>
<calloutlist>
<callout arearefs="CO5-1">
<para>Specify the full path, including the initial forward slash (/) character.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Mirror the version images to the mirror registry:</simpara>
<itemizedlist>
<listitem>
<simpara>If your mirror host does not have internet access, take the following actions:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Connect the removable media to a system that is connected to the internet.</simpara>
</listitem>
<listitem>
<simpara>Review the images and configuration manifests to mirror:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON}  \
     --from=quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE} \
     --to=${LOCAL_REGISTRY}/${LOCAL_REPOSITORY} \
     --to-release-image=${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE} --dry-run</programlisting>
</listitem>
<listitem>
<simpara>Record the entire <literal>imageContentSources</literal> section from the output of the previous
command. The information about your mirrors is unique to your mirrored repository, and you must add the <literal>imageContentSources</literal> section to the <literal>install-config.yaml</literal> file during installation.</simpara>
</listitem>
<listitem>
<simpara>Mirror the images to a directory on the removable media:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON} --to-dir=${REMOVABLE_MEDIA_PATH}/mirror quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE}</programlisting>
</listitem>
<listitem>
<simpara>Take the media to the restricted network environment and upload the images to the local container registry.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image mirror -a ${LOCAL_SECRET_JSON} --from-dir=${REMOVABLE_MEDIA_PATH}/mirror "file://openshift/release:${OCP_RELEASE}*" ${LOCAL_REGISTRY}/${LOCAL_REPOSITORY} <co xml:id="CO6-1"/></programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>For <literal>REMOVABLE_MEDIA_PATH</literal>, you must use the same path that you specified when you mirrored the images.</para>
</callout>
</calloutlist>
<important>
<simpara>Running <literal>oc image mirror</literal> might result in the following error: <literal>error: unable to retrieve source image</literal>. This error occurs when image indexes include references to images that no longer exist on the image registry. Image indexes might retain older references to allow users running those images an upgrade path to newer points on the upgrade graph. As a temporary workaround, you can use the <literal>--skip-missing</literal> option to bypass the error and continue downloading the image index. For more information, see <link xlink:href="https://access.redhat.com/solutions/6975305">Service Mesh Operator mirroring failed</link>.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>If the local container registry is connected to the mirror host, take the following actions:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Directly push the release images to the local registry by using following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release mirror -a ${LOCAL_SECRET_JSON}  \
     --from=quay.io/${PRODUCT_REPO}/${RELEASE_NAME}:${OCP_RELEASE}-${ARCHITECTURE} \
     --to=${LOCAL_REGISTRY}/${LOCAL_REPOSITORY} \
     --to-release-image=${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE}</programlisting>
<simpara>This command pulls the release information as a digest, and its output includes
the <literal>imageContentSources</literal> data that you require when you install your cluster.</simpara>
</listitem>
<listitem>
<simpara>Record the entire <literal>imageContentSources</literal> section from the output of the previous
command. The information about your mirrors is unique to your mirrored repository, and you must add the <literal>imageContentSources</literal> section to the <literal>install-config.yaml</literal> file during installation.</simpara>
<note>
<simpara>The image name gets patched to Quay.io during the mirroring process, and the podman images will show Quay.io in the registry on the bootstrap virtual machine.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>To create the installation program that is based on the content that you
mirrored, extract it and pin it to the release:</simpara>
<itemizedlist>
<listitem>
<simpara>If your mirror host does not have internet access, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release extract -a ${LOCAL_SECRET_JSON} --icsp-file=&lt;file&gt; \ --command=openshift-install "${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}"</programlisting>
</listitem>
<listitem>
<simpara>If the local container registry is connected to the mirror host, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm release extract -a ${LOCAL_SECRET_JSON} --command=openshift-install "${LOCAL_REGISTRY}/${LOCAL_REPOSITORY}:${OCP_RELEASE}-${ARCHITECTURE}"</programlisting>
<important>
<simpara>To ensure that you use the correct images for the version of OpenShift Container Platform
that you selected, you must extract the installation program from the mirrored
content.</simpara>
<simpara>You must perform this step on a machine with an active internet connection.</simpara>
</important>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>For clusters using installer-provisioned infrastructure, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ openshift-install</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="installation-restricted-network-samples_samples-operator-alt-registry">
<title>Using Cluster Samples Operator image streams with alternate or mirrored registries</title>
<simpara>Most image streams in the <literal>openshift</literal> namespace managed by the Cluster Samples Operator
point to images located in the Red Hat registry at <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>.</simpara>
<note>
<simpara>The <literal>cli</literal>, <literal>installer</literal>, <literal>must-gather</literal>, and <literal>tests</literal> image streams, while
part of the install payload, are not managed by the Cluster Samples Operator. These are
not addressed in this procedure.</simpara>
</note>
<important>
<simpara>The Cluster Samples Operator must be set to <literal>Managed</literal> in a disconnected environment. To install the image streams, you have a mirrored registry.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Create a pull secret for your mirror registry.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Access the images of a specific image stream to mirror, for example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get is &lt;imagestream&gt; -n openshift -o json | jq .spec.tags[].from.name | grep registry.redhat.io</programlisting>
</listitem>
<listitem>
<simpara>Mirror images from <link xlink:href="https://registry.redhat.io">registry.redhat.io</link> associated with any image streams you need</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc image mirror registry.redhat.io/rhscl/ruby-25-rhel7:latest ${MIRROR_ADDR}/rhscl/ruby-25-rhel7:latest</programlisting>
</listitem>
<listitem>
<simpara>Create the cluster&#8217;s image configuration object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap registry-config --from-file=${MIRROR_ADDR_HOSTNAME}..5000=$path/ca.crt -n openshift-config</programlisting>
</listitem>
<listitem>
<simpara>Add the required trusted CAs for the mirror in the cluster&#8217;s image
configuration object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch image.config.openshift.io/cluster --patch '{"spec":{"additionalTrustedCA":{"name":"registry-config"}}}' --type=merge</programlisting>
</listitem>
<listitem>
<simpara>Update the <literal>samplesRegistry</literal> field in the Cluster Samples Operator configuration object
to contain the <literal>hostname</literal> portion of the mirror location defined in the mirror
configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit configs.samples.operator.openshift.io -n openshift-cluster-samples-operator</programlisting>
<note>
<simpara>This is required because the image stream import process does not use the mirror or search mechanism at this time.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add any image streams that are not mirrored into the <literal>skippedImagestreams</literal> field
of the Cluster Samples Operator configuration object. Or if you do not want to support
any of the sample image streams, set the Cluster Samples Operator to <literal>Removed</literal> in the
Cluster Samples Operator configuration object.</simpara>
<note>
<simpara>The Cluster Samples Operator issues alerts if image stream imports are failing but the Cluster Samples Operator is either periodically retrying or does not appear to be retrying them.</simpara>
</note>
<simpara>Many of the templates in the <literal>openshift</literal> namespace
reference the image streams. So using <literal>Removed</literal> to purge both the image streams
and templates will eliminate the possibility of attempts to use them if they
are not functional because of any missing image streams.</simpara>
</listitem>
</orderedlist>
<section xml:id="installation-images-samples-disconnected-mirroring-assist_samples-operator-alt-registry">
<title>Cluster Samples Operator assistance for mirroring</title>
<simpara>During installation, OpenShift Container Platform creates a config map named <literal>imagestreamtag-to-image</literal> in the <literal>openshift-cluster-samples-operator</literal> namespace. The <literal>imagestreamtag-to-image</literal> config map contains an entry, the populating image, for each image stream tag.</simpara>
<simpara>The format of the key for each entry in the data field in the config map is <literal>&lt;image_stream_name&gt;_&lt;image_stream_tag_name&gt;</literal>.</simpara>
<simpara>During a disconnected installation of OpenShift Container Platform, the status of the Cluster Samples Operator is set to <literal>Removed</literal>. If you choose to change it to <literal>Managed</literal>, it installs samples.</simpara>
<note>
<simpara>The use of samples in a network-restricted or discontinued environment may require access to services external to your network. Some example services include: Github, Maven Central, npm, RubyGems, PyPi and others. There might be additional steps to take that allow the cluster samples operators&#8217;s objects to reach the services they require.</simpara>
</note>
<simpara>You can use this config map as a reference for which images need to be mirrored for your image streams to import.</simpara>
<itemizedlist>
<listitem>
<simpara>While the Cluster Samples Operator is set to <literal>Removed</literal>, you can create your mirrored registry, or determine which existing mirrored registry you want to use.</simpara>
</listitem>
<listitem>
<simpara>Mirror the samples you want to the mirrored registry using the new config map as your guide.</simpara>
</listitem>
<listitem>
<simpara>Add any of the image streams you did not mirror to the <literal>skippedImagestreams</literal> list of the Cluster Samples Operator configuration object.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>samplesRegistry</literal> of the Cluster Samples Operator configuration object to the mirrored registry.</simpara>
</listitem>
<listitem>
<simpara>Then set the Cluster Samples Operator to <literal>Managed</literal> to install the image streams you have mirrored.</simpara>
</listitem>
</itemizedlist>
<simpara>See <link xlink:href="../openshift_images/samples-operator-alt-registry.xml#installation-restricted-network-samples_samples-operator-alt-registry">Using Cluster Samples Operator image streams with alternate or mirrored registries</link> for a detailed procedure.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="creating-images">
<title>Creating images</title>

<simpara>Learn how to create your own container images, based on pre-built images that are ready to help you. The process includes learning best practices for writing images, defining metadata for images, testing images, and using a custom builder workflow to create images to use with OpenShift Container Platform.
After you create an image, you can push it to the OpenShift image registry.</simpara>
<section xml:id="images-create-guidelines_create-images">
<title>Learning container best practices</title>
<simpara>When creating container images to run on OpenShift Container Platform there are a number of best practices to consider as an image author to ensure a good experience for consumers of those images. Because images are intended to be immutable and used as-is, the following guidelines help ensure that your images are highly consumable and easy to use on OpenShift Container Platform.</simpara>
<section xml:id="images-create-guide-general_create-images">
<title>General container image guidelines</title>
<simpara>The following guidelines apply when creating a container image in general, and are independent of whether the images are used on OpenShift Container Platform.</simpara>
<bridgehead xml:id="_reuse_images" renderas="sect4">Reuse images</bridgehead>
<simpara>Wherever possible, base your image on an appropriate upstream image using the <literal>FROM</literal> statement. This ensures your image can easily pick up security fixes from an upstream image when it is updated, rather than you having to update your dependencies directly.</simpara>
<simpara>In addition, use tags in the <literal>FROM</literal> instruction, for example, <literal>rhel:rhel7</literal>, to make it clear to users exactly which version of an image your image is based on. Using a tag other than <literal>latest</literal> ensures your image is not subjected to breaking changes that might go into the <literal>latest</literal> version of an upstream image.</simpara>
<bridgehead xml:id="_maintain_compatibility_within_tags" renderas="sect4">Maintain compatibility within tags</bridgehead>
<simpara>When tagging your own images, try to maintain backwards compatibility within a tag. For example, if you provide an image named <literal>image</literal> and it currently includes version <literal>1.0</literal>, you might provide a tag of <literal>image:v1</literal>. When you update the image, as long as it continues to be compatible with the original image, you can continue to tag the new image <literal>image:v1</literal>, and downstream consumers of this tag are able to get updates without being broken.</simpara>
<simpara>If you later release an incompatible update, then switch to a new tag, for example <literal>image:v2</literal>. This allows downstream consumers to move up to the new version at will, but not be inadvertently broken by the new incompatible image. Any downstream consumer using <literal>image:latest</literal> takes on the risk of any incompatible changes being introduced.</simpara>
<bridgehead xml:id="_avoid_multiple_processes" renderas="sect4">Avoid multiple processes</bridgehead>
<simpara>Do not start multiple services, such as a database and <literal>SSHD</literal>, inside one container. This is not necessary because containers are lightweight and can be easily linked together for orchestrating multiple processes. OpenShift Container Platform allows you to easily colocate and co-manage related images by grouping them into a single pod.</simpara>
<simpara>This colocation ensures the containers share a network namespace and storage for communication. Updates are also less disruptive as each image can be updated less frequently and independently. Signal handling flows are also clearer with a single process as you do not have to manage routing signals to spawned processes.</simpara>
<bridgehead xml:id="_use_exec_in_wrapper_scripts" renderas="sect4">Use <literal>exec</literal> in wrapper scripts</bridgehead>
<simpara>Many images use wrapper scripts to do some setup before starting a process for the software being run. If your image uses such a script, that script uses <literal>exec</literal> so that the script&#8217;s process is replaced by your software. If you do not use <literal>exec</literal>, then signals sent by your container runtime go to your wrapper script instead of your software&#8217;s process. This is not what you want.</simpara>
<simpara>If you have a wrapper script that starts a process for some server. You start your container, for example, using <literal>podman run -i</literal>, which runs the wrapper script, which in turn starts your process. If you want to close your container with <literal>CTRL+C</literal>. If your wrapper script used <literal>exec</literal> to start the server process, <literal>podman</literal> sends SIGINT to the server process, and everything works as you expect. If you did not use <literal>exec</literal> in your wrapper script, <literal>podman</literal> sends SIGINT to the process for the wrapper script and your process keeps running like nothing happened.</simpara>
<simpara>Also note that your process runs as <literal>PID 1</literal> when running in a container. This means that if your main process terminates, the entire container is stopped, canceling any child processes you launched from your <literal>PID 1</literal> process.</simpara>
<bridgehead xml:id="_clean_temporary_files" renderas="sect4">Clean temporary files</bridgehead>
<simpara>Remove all temporary files you create during the build process. This also includes any files added with the <literal>ADD</literal> command.  For example, run the <literal>yum clean</literal> command after performing <literal>yum install</literal> operations.</simpara>
<simpara>You can prevent the <literal>yum</literal> cache from ending up in an image layer by creating your <literal>RUN</literal> statement as follows:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">RUN yum -y install mypackage &amp;&amp; yum -y install myotherpackage &amp;&amp; yum clean all -y</programlisting>
<simpara>Note that if you instead write:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">RUN yum -y install mypackage
RUN yum -y install myotherpackage &amp;&amp; yum clean all -y</programlisting>
<simpara>Then the first <literal>yum</literal> invocation leaves extra files in that layer, and these files cannot be removed when the <literal>yum clean</literal> operation is run later. The extra files are not visible in the final image, but they are present in the underlying layers.</simpara>
<simpara>The current container build process does not allow a command run in a later layer to shrink the space used by the image when something was removed in an earlier layer. However, this may change in the future. This means that if you perform an <literal>rm</literal> command in a later layer, although the files are hidden it does not reduce the overall size of the image to be downloaded. Therefore, as with the <literal>yum clean</literal> example, it is best to remove files in the same command that created them, where possible, so they do not end up written to a layer.</simpara>
<simpara>In addition, performing multiple commands in a single <literal>RUN</literal> statement reduces the number of layers in your image, which improves download and extraction time.</simpara>
<bridgehead xml:id="_place_instructions_in_the_proper_order" renderas="sect4">Place instructions in the proper order</bridgehead>
<simpara>The container builder reads the <literal>Dockerfile</literal> and runs the instructions from top to bottom. Every instruction that is successfully executed creates a layer which can be reused the next time this or another image is built. It is very important to place instructions that rarely change at the top of your <literal>Dockerfile</literal>. Doing so ensures the next builds of the same image are very fast because the cache is not invalidated by upper layer changes.</simpara>
<simpara>For example, if you are working on a <literal>Dockerfile</literal> that contains an <literal>ADD</literal> command to install a file you are iterating on, and a <literal>RUN</literal> command to <literal>yum install</literal> a package, it is best to put the <literal>ADD</literal> command last:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM foo
RUN yum -y install mypackage &amp;&amp; yum clean all -y
ADD myfile /test/myfile</programlisting>
<simpara>This way each time you edit <literal>myfile</literal> and rerun <literal>podman build</literal> or <literal>docker build</literal>, the system reuses the cached layer for the <literal>yum</literal> command and only generates the new layer for the <literal>ADD</literal> operation.</simpara>
<simpara>If instead you wrote the <literal>Dockerfile</literal> as:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">FROM foo
ADD myfile /test/myfile
RUN yum -y install mypackage &amp;&amp; yum clean all -y</programlisting>
<simpara>Then each time you changed <literal>myfile</literal> and reran <literal>podman build</literal> or <literal>docker build</literal>, the <literal>ADD</literal> operation would invalidate the <literal>RUN</literal> layer cache, so the <literal>yum</literal> operation must be rerun as well.</simpara>
<bridgehead xml:id="_mark_important_ports" renderas="sect4">Mark important ports</bridgehead>
<simpara>The EXPOSE instruction makes a port in the container available to the host system and other containers. While it is possible to specify that a port should be exposed with a <literal>podman run</literal> invocation, using the EXPOSE instruction in a <literal>Dockerfile</literal> makes it easier for both humans and software to use your image by explicitly declaring the ports your software needs to run:</simpara>
<itemizedlist>
<listitem>
<simpara>Exposed ports show up under <literal>podman ps</literal> associated with containers created from your image.</simpara>
</listitem>
<listitem>
<simpara>Exposed ports are present in the metadata for your image returned by <literal>podman inspect</literal>.</simpara>
</listitem>
<listitem>
<simpara>Exposed ports are linked when you link one container to another.</simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_set_environment_variables" renderas="sect4">Set environment variables</bridgehead>
<simpara>It is good practice to set environment variables with the <literal>ENV</literal> instruction. One example is to set the version of your project. This makes it easy for people to find the version without looking at the <literal>Dockerfile</literal>. Another example is advertising a path on the system that could be used by another process, such as <literal>JAVA_HOME</literal>.</simpara>
<bridgehead xml:id="_avoid_default_passwords" renderas="sect4">Avoid default passwords</bridgehead>
<simpara>Avoid setting default passwords. Many people extend the image and forget to remove or change the default password. This can lead to security issues if a user in production is assigned a well-known password. Passwords are configurable using an environment variable instead.</simpara>
<simpara>If you do choose to set a default password, ensure that an appropriate warning message is displayed when the container is started. The message should inform the user of the value of the default password and explain how to change it, such as what environment variable to set.</simpara>
<bridgehead xml:id="_avoid_sshd" renderas="sect4">Avoid sshd</bridgehead>
<simpara>It is best to avoid running <literal>sshd</literal> in your image. You can use the <literal>podman exec</literal> or <literal>docker exec</literal> command to access containers that are running on the local host. Alternatively, you can use the <literal>oc exec</literal> command or the <literal>oc rsh</literal> command to access containers that are running on the OpenShift Container Platform cluster. Installing and running <literal>sshd</literal> in your image opens up additional vectors for attack and requirements for security patching.</simpara>
<bridgehead xml:id="_use_volumes_for_persistent_data" renderas="sect4">Use volumes for persistent data</bridgehead>
<simpara>Images use a <link xlink:href="https://docs.docker.com/reference/builder/#volume">volume</link> for persistent data. This way OpenShift Container Platform mounts the network storage to the node running the container, and if the container moves to a new node the storage is reattached to that node. By using the volume for all persistent storage needs, the content is preserved even if the container is restarted or moved. If your image writes data to arbitrary locations within the container, that content could not be preserved.</simpara>
<simpara>All data that needs to be preserved even after the container is destroyed must be written to a volume. Container engines support a <literal>readonly</literal> flag for containers, which can be used to strictly enforce good practices about not writing data to ephemeral storage in a container. Designing your image around that capability now makes it easier to take advantage of it later.</simpara>
<simpara>Explicitly defining volumes in your <literal>Dockerfile</literal> makes it easy for consumers of the image to understand what volumes they must define when running your image.</simpara>
<simpara>See the <link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/">Kubernetes
documentation</link> for more information on how volumes are used in OpenShift Container Platform.</simpara>
<note>
<simpara>Even with persistent volumes, each instance of your image has its own volume, and the filesystem is not shared between instances. This means the volume cannot be used to share state in a cluster.</simpara>
</note>
</section>
<section xml:id="images-create-guide-openshift_create-images">
<title>OpenShift Container Platform-specific guidelines</title>
<simpara>The following are guidelines that apply when creating container images specifically
for use on OpenShift Container Platform.</simpara>
<section xml:id="enable-images-for-source-to-image_create-images">
<title>Enable images for source-to-image (S2I)</title>
<simpara>For images that are intended to run application code provided by a third party, such as a Ruby image designed to run Ruby code provided by a developer, you can enable your image to work with the <link xlink:href="https://github.com/openshift/source-to-image">Source-to-Image (S2I)</link> build tool. S2I is a framework that makes it easy to write images that take application source code as an input and produce a new image that runs the assembled application as output.</simpara>
</section>
<section xml:id="use-uid_create-images">
<title>Support arbitrary user ids</title>
<simpara>By default, OpenShift Container Platform runs containers using an arbitrarily assigned user ID. This provides additional security against processes escaping the container due to a container engine vulnerability and thereby achieving escalated permissions on the host node.</simpara>
<simpara>For an image to support running as an arbitrary user, directories and files that are written to by processes in the image must be owned by the root group and be read/writable by that group. Files to be executed must also have group execute permissions.</simpara>
<simpara>Adding the following to your Dockerfile sets the directory and file permissions to allow users in the root group to access them in the built image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">RUN chgrp -R 0 /some/directory &amp;&amp; \
    chmod -R g=u /some/directory</programlisting>
<simpara>Because the container user is always a member of the root group, the container user can read and write these files.</simpara>
<warning>
<simpara>Care must be taken when altering the directories and file permissions of the sensitive areas of a container. If applied to sensitive areas, such as the <literal>/etc/passwd</literal> file, such changes can allow the modification of these files by unintended users, potentially exposing the container or host. CRI-O supports the insertion of arbitrary user IDs into a container&#8217;s <literal>/etc/passwd</literal> file. As such, changing permissions is never required.</simpara>
<simpara>Additionally, the <literal>/etc/passwd</literal> file should not exist in any container image. If it does, the CRI-O container runtime will fail to inject a random UID into the <literal>/etc/passwd</literal> file. In such cases, the container might face challenges in resolving the active UID. Failing to meet this requirement could impact the functionality of certain containerized applications.</simpara>
</warning>
<simpara>In addition, the processes running in the container must not listen on privileged ports, ports below 1024, since they are not running as a privileged user.</simpara>
<important>
<simpara>If your S2I image does not include a <literal>USER</literal> declaration with a numeric user, your builds fail by default. To allow images that use either named users or the root <literal>0</literal> user to build in OpenShift Container Platform, you can add the project&#8217;s builder service account, <literal>system:serviceaccount:&lt;your-project&gt;:builder</literal>, to the <literal>anyuid</literal> security context constraint (SCC). Alternatively, you can allow all images to run as any user.</simpara>
</important>
</section>
<section xml:id="use-services_create-images">
<title>Use services for inter-image communication</title>
<simpara>For cases where your image needs to communicate with a service provided by another image, such as a web front end image that needs to access a database image to store and retrieve data, your image consumes an OpenShift Container Platform service. Services provide a static endpoint for access which does not change as containers are stopped, started, or moved. In addition, services provide load balancing for requests.</simpara>
</section>
<section xml:id="provide-common-libraries_create-images">
<title>Provide common libraries</title>
<simpara>For images that are intended to run application code provided by a third party, ensure that your image contains commonly used libraries for your platform. In particular, provide database drivers for common databases used with your platform. For example, provide JDBC drivers for MySQL and PostgreSQL if you are creating a Java framework image. Doing so prevents the need for common dependencies to be downloaded during application assembly time, speeding up application image builds. It also simplifies the work required by application developers to ensure all of their dependencies are met.</simpara>
</section>
<section xml:id="use-env-vars_create-images">
<title>Use environment variables for configuration</title>
<simpara>Users of your image are able to configure it without having to create a downstream image based on your image. This means that the runtime configuration is handled using environment variables. For a simple configuration, the running process can consume the environment variables directly. For a more complicated configuration or for runtimes which do not support this, configure the runtime by defining a template configuration file that is processed during startup. During this processing, values supplied using environment variables can be substituted into the configuration file or used to make decisions about what options to set in the configuration file.</simpara>
<simpara>It is also possible and recommended to pass secrets such as certificates and keys into the container using environment variables. This ensures that the secret values do not end up committed in an image and leaked into a container image registry.</simpara>
<simpara>Providing environment variables allows consumers of your image to customize behavior, such as database settings, passwords, and performance tuning, without having to introduce a new layer on top of your image. Instead, they can simply define environment variable values when defining a pod and change those settings without rebuilding the image.</simpara>
<simpara>For extremely complex scenarios, configuration can also be supplied using volumes that would be mounted into the container at runtime. However, if you elect to do it this way you must ensure that your image provides clear error messages on startup when the necessary volume or configuration is not present.</simpara>
<simpara>This topic is related to the Using Services for Inter-image Communication topic in that configuration like datasources are defined in terms of environment variables that provide the service endpoint information. This allows an application to dynamically consume a datasource service that is defined in the OpenShift Container Platform environment without modifying the application image.</simpara>
<simpara>In addition, tuning is done by inspecting the <literal>cgroups</literal> settings for the container. This allows the image to tune itself to the available memory, CPU, and other resources. For example, Java-based images tune their heap based on the <literal>cgroup</literal> maximum memory parameter to ensure they do not exceed the limits and get an out-of-memory error.</simpara>
</section>
<section xml:id="set-image-metadata_create-images">
<title>Set image metadata</title>
<simpara>Defining image metadata helps OpenShift Container Platform better consume your container images, allowing OpenShift Container Platform to create a better experience for developers using your image. For example, you can add metadata to provide helpful descriptions of your image, or offer suggestions on other images that are needed.</simpara>
</section>
<section xml:id="clustering_create-images">
<title>Clustering</title>
<simpara>You must fully understand what it means to run multiple instances of your image. In the simplest case, the load balancing function of a service handles routing traffic to all instances of your image. However, many frameworks must share information to perform leader election or failover state; for example, in session replication.</simpara>
<simpara>Consider how your instances accomplish this communication when running in OpenShift Container Platform. Although pods can communicate directly with each other, their IP addresses change anytime the pod starts, stops, or is moved. Therefore, it is important for your clustering scheme to be dynamic.</simpara>
</section>
<section xml:id="logging_create-images">
<title>Logging</title>
<simpara>It is best to send all logging to standard out. OpenShift Container Platform collects standard out from containers and sends it to the centralized logging service where it can be viewed. If you must separate log content, prefix the output with an appropriate keyword, which makes it possible to filter the messages.</simpara>
<simpara>If your image logs to a file, users must use manual operations to enter the running container and retrieve or view the log file.</simpara>
</section>
<section xml:id="liveness-and-readiness-probes_create-images">
<title>Liveness and readiness probes</title>
<simpara>Document example liveness and readiness probes that can be used with your image. These probes allow users to deploy your image with confidence that traffic is not be routed to the container until it is prepared to handle it, and that the container is restarted if the process gets into an unhealthy state.</simpara>
</section>
<section xml:id="templates_create-images">
<title>Templates</title>
<simpara>Consider providing an example template with your image. A template gives users an easy way to quickly get your image deployed with a working configuration. Your template must include the liveness and readiness probes you documented with the image, for completeness.</simpara>
</section>
</section>
</section>
<section xml:id="images-create-metadata_create-images">
<title>Including metadata in images</title>
<simpara>Defining image metadata helps OpenShift Container Platform better consume your container images, allowing OpenShift Container Platform to create a better experience for developers using your image. For example, you can add metadata to provide helpful descriptions of your image, or offer suggestions on other images that may also be needed.</simpara>
<simpara>This topic only defines the metadata needed by the current set of use cases. Additional metadata or use cases may be added in the future.</simpara>
<section xml:id="_defining_image_metadata">
<title>Defining image metadata</title>
<simpara>You can use the <literal>LABEL</literal> instruction in a <literal>Dockerfile</literal> to define image metadata. Labels are similar to environment variables in that they are key value pairs attached to an image or a container. Labels are different from environment variable in that they are not visible to the running application and they can also be used for fast look-up of images and containers.</simpara>
<simpara><link xlink:href="https://docs.docker.com/engine/reference/builder/#label">Docker
documentation</link> for more information on the <literal>LABEL</literal> instruction.</simpara>
<simpara>The label names are typically namespaced. The namespace is set accordingly to reflect the project that is going to pick up the labels and use them. For OpenShift Container Platform the namespace is set to <literal>io.openshift</literal> and for Kubernetes the namespace is <literal>io.k8s</literal>.</simpara>
<simpara>See the <link xlink:href="https://docs.docker.com/engine/userguide/labels-custom-metadata">Docker custom metadata</link> documentation for details about the format.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported Metadata</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Variable</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.tags</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This label contains a list of tags represented as a list of comma-separated string values. The tags are the way to categorize the container images into broad areas of functionality. Tags help UI and generation tools to suggest relevant container images during the application creation process.</simpara>
<screen>LABEL io.openshift.tags   mongodb,mongodb24,nosql</screen></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.wants</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies a list of tags that the generation tools and the UI uses to provide relevant suggestions if you do not have the container images with specified tags already. For example, if the container image wants <literal>mysql</literal> and <literal>redis</literal> and you do not have the container image with <literal>redis</literal> tag, then UI  can suggest you to add this image into your deployment.</simpara>
<screen>LABEL io.openshift.wants   mongodb,redis</screen></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.k8s.description</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This label can be used to give the container image consumers more detailed information about the service or functionality this image provides. The UI can then use this description together with the container image name to provide more human friendly information to end users.</simpara>
<screen>LABEL io.k8s.description The MySQL 5.5 Server with master-slave replication support</screen></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.non-scalable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An image can use this variable to suggest that it does not support scaling. The UI then communicates this to consumers of that image. Being not-scalable means that the value of <literal>replicas</literal> should initially not be set higher than <literal>1</literal>.</simpara>
<screen>LABEL io.openshift.non-scalable     true</screen></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>io.openshift.min-memory</literal> and <literal>io.openshift.min-cpu</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This label suggests how much resources the container image needs to work properly. The UI can warn the user that deploying this container image may exceed their user quota. The values must be compatible with Kubernetes quantity.</simpara>
<screen>LABEL io.openshift.min-memory 16Gi
LABEL io.openshift.min-cpu     4</screen></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="images-create-s2i_create-images">
<title>Creating images from source code with source-to-image</title>
<simpara>Source-to-image (S2I) is a framework that makes it easy to write images that take application source code as an input and produce a new image that runs the assembled application as output.</simpara>
<simpara>The main advantage of using S2I for building reproducible container images is the ease of use for developers. As a builder image author, you must understand two basic concepts in order for your images to provide the best S2I performance, the build process and S2I scripts.</simpara>
<section xml:id="images-create-s2i-build_create-images">
<title>Understanding the source-to-image build process</title>
<simpara>The build process consists of the following three fundamental elements, which are combined into a final container image:</simpara>
<itemizedlist>
<listitem>
<simpara>Sources</simpara>
</listitem>
<listitem>
<simpara>Source-to-image (S2I) scripts</simpara>
</listitem>
<listitem>
<simpara>Builder image</simpara>
</listitem>
</itemizedlist>
<simpara>S2I generates a Dockerfile with the builder image as the first <literal>FROM</literal> instruction. The Dockerfile generated by S2I is then passed to Buildah.</simpara>
</section>
<section xml:id="images-create-s2i-scripts_create-images">
<title>How to write source-to-image scripts</title>
<simpara>You can write source-to-image (S2I) scripts in any programming language, as long as the scripts are executable inside the builder image. S2I supports multiple options providing <literal>assemble</literal>/<literal>run</literal>/<literal>save-artifacts</literal> scripts. All of these locations are checked on each build in the following order:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A script specified in the build configuration.</simpara>
</listitem>
<listitem>
<simpara>A script found in the application source <literal>.s2i/bin</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>A script found at the default image URL with the <literal>io.openshift.s2i.scripts-url</literal> label.</simpara>
</listitem>
</orderedlist>
<simpara>Both the <literal>io.openshift.s2i.scripts-url</literal> label specified in the image and the script specified in a build configuration can take one of the following forms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>image:///path_to_scripts_dir</literal>: absolute path inside the image to a directory where the S2I scripts are located.</simpara>
</listitem>
<listitem>
<simpara><literal>file:///path_to_scripts_dir</literal>: relative or absolute path to a directory on the host where the S2I scripts are located.</simpara>
</listitem>
<listitem>
<simpara><literal>http(s)://path_to_scripts_dir</literal>: URL to a directory where the S2I scripts are located.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>S2I scripts</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Script</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>assemble</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>assemble</literal> script builds the application artifacts from a source and places them into appropriate directories inside the image. This script is required. The workflow for this script is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Optional: Restore build artifacts. If you want to support incremental builds, make sure to define <literal>save-artifacts</literal> as well.</simpara>
</listitem>
<listitem>
<simpara>Place the application source in the desired location.</simpara>
</listitem>
<listitem>
<simpara>Build the application artifacts.</simpara>
</listitem>
<listitem>
<simpara>Install the artifacts into locations appropriate for them to run.</simpara>
</listitem>
</orderedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>run</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>run</literal> script executes your application. This script is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>save-artifacts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>save-artifacts</literal> script gathers all dependencies that can speed up the build processes that follow. This script is optional. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>For Ruby, <literal>gems</literal> installed by Bundler.</simpara>
</listitem>
<listitem>
<simpara>For Java, <literal>.m2</literal> contents.</simpara>
</listitem>
</itemizedlist>
<simpara>These dependencies are gathered into a <literal>tar</literal> file and streamed to the standard output.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>usage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>usage</literal> script allows you to inform the user how to properly use your image. This script is optional.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>test/run</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>test/run</literal> script allows you to create a process to check if the image is working correctly. This script is optional. The proposed flow of that process is:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Build the image.</simpara>
</listitem>
<listitem>
<simpara>Run the image to verify the <literal>usage</literal> script.</simpara>
</listitem>
<listitem>
<simpara>Run <literal>s2i build</literal> to verify the <literal>assemble</literal> script.</simpara>
</listitem>
<listitem>
<simpara>Optional: Run <literal>s2i build</literal> again to verify the <literal>save-artifacts</literal> and <literal>assemble</literal> scripts save and restore artifacts functionality.</simpara>
</listitem>
<listitem>
<simpara>Run the image to verify the test application is working.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The suggested location to put the test application built by your <literal>test/run</literal> script is the <literal>test/test-app</literal> directory in your image repository.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara><emphasis role="strong">Example S2I scripts</emphasis></simpara>
<simpara>The following example S2I scripts are written in Bash. Each example assumes its <literal>tar</literal> contents are unpacked into the <literal>/tmp/s2i</literal> directory.</simpara>
<formalpara>
<title><literal>assemble</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# restore build artifacts
if [ "$(ls /tmp/s2i/artifacts/ 2&gt;/dev/null)" ]; then
    mv /tmp/s2i/artifacts/* $HOME/.
fi

# move the application source
mv /tmp/s2i/src $HOME/src

# build application artifacts
pushd ${HOME}
make all

# install the artifacts
make install
popd</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>run</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# run the application
/opt/application/run.sh</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>save-artifacts</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

pushd ${HOME}
if [ -d deps ]; then
    # all deps contents to tar stream
    tar cf - deps
fi
popd</programlisting>
</para>
</formalpara>
<formalpara>
<title><literal>usage</literal> script:</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash

# inform the user how to use the image
cat &lt;&lt;EOF
This is a S2I sample builder image, to use it, install
https://github.com/openshift/source-to-image
EOF</programlisting>
</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://blog.openshift.com/create-s2i-builder-image/">S2I Image Creation Tutorial</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-test-s2i_create-images">
<title>About testing source-to-image images</title>
<simpara>As an Source-to-Image (S2I) builder image author, you can test your S2I image
locally and use the OpenShift Container Platform build system for automated testing and
continuous integration.</simpara>
<simpara>S2I requires the
<literal>assemble</literal> and <literal>run</literal> scripts to be present to successfully run
the S2I build. Providing the <literal>save-artifacts</literal> script reuses the build
artifacts, and providing the <literal>usage</literal> script ensures that usage information is
printed to console when someone runs the container image outside of the S2I.</simpara>
<simpara>The goal of testing an S2I image is to make sure that all of these described
commands work properly, even if the base container image has changed or the tooling
used by the commands was updated.</simpara>
<section xml:id="images-test-s2i-testing-requirements_create-images">
<title>Understanding testing requirements</title>
<simpara>The standard location for the <literal>test</literal> script is <literal>test/run</literal>. This script is
invoked by the OpenShift Container Platform S2I image builder and it could be a simple Bash
script or a static Go binary.</simpara>
<simpara>The <literal>test/run</literal> script performs the S2I build, so you must have the S2I binary
available in your <literal>$PATH</literal>. If required, follow the installation instructions
in the
<link xlink:href="https://github.com/openshift/source-to-image/blob/master/README.md#installation">S2I
README</link>.</simpara>
<simpara>S2I combines the application source code and builder image, so to test
it you need a sample application source to verify that the source successfully
transforms into a runnable container image. The sample application should be simple,
but it should exercise the crucial steps of <literal>assemble</literal> and <literal>run</literal> scripts.</simpara>
</section>
<section xml:id="images-test-s2i-generating-scripts-and-tools_create-images">
<title>Generating scripts and tools</title>
<simpara>The S2I tooling comes with powerful generation tools to speed up the process of
creating a new S2I image. The <literal>s2i create</literal> command produces all the necessary S2I
scripts and testing tools along with the <literal>Makefile</literal>:</simpara>
<programlisting language="termnal" linenumbering="unnumbered">$ s2i create _&lt;image name&gt;_ _&lt;destination directory&gt;_</programlisting>
<simpara>The generated <literal>test/run</literal> script must be adjusted to be
useful, but it provides a good starting point to begin developing.</simpara>
<note>
<simpara>The <literal>test/run</literal> script produced by the <literal>s2i create</literal> command requires that the sample application sources are inside the <literal>test/test-app</literal> directory.</simpara>
</note>
</section>
<section xml:id="images-test-s21-testing-locally_create-images">
<title>Testing locally</title>
<simpara>The easiest way to run the S2I image tests locally is to use the generated
<literal>Makefile</literal>.</simpara>
<simpara>If you did not use the <literal>s2i create</literal> command, you can copy the
following <literal>Makefile</literal> template and replace the <literal>IMAGE_NAME</literal> parameter with
your image name.</simpara>
<formalpara>
<title>Sample <literal>Makefile</literal></title>
<para>
<screen>IMAGE_NAME = openshift/ruby-20-centos7
CONTAINER_ENGINE := $(shell command -v podman 2&gt; /dev/null | echo docker)

build:
	${CONTAINER_ENGINE} build -t $(IMAGE_NAME) .

.PHONY: test
test:
	${CONTAINER_ENGINE} build -t $(IMAGE_NAME)-candidate .
	IMAGE_NAME=$(IMAGE_NAME)-candidate test/run</screen>
</para>
</formalpara>
</section>
<section xml:id="images-test-s21-basic-testing-workflow_create-images">
<title>Basic testing workflow</title>
<simpara>The <literal>test</literal> script assumes you have already built the image you want to
test. If required, first build the S2I image. Run one of the following commands:</simpara>
<itemizedlist>
<listitem>
<simpara>If you use Podman, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman build -t &lt;builder_image_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you use Docker, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker build -t &lt;builder_image_name&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>The following steps describe the default workflow to test S2I image builders:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Verify the <literal>usage</literal> script is working:</simpara>
<itemizedlist>
<listitem>
<simpara>If you use Podman, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run &lt;builder_image_name&gt; .</programlisting>
</listitem>
<listitem>
<simpara>If you use Docker, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker run &lt;builder_image_name&gt; .</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Build the image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ s2i build file:///path-to-sample-app _&lt;BUILDER_IMAGE_NAME&gt;_ _&lt;OUTPUT_APPLICATION_IMAGE_NAME&gt;_</programlisting>
</listitem>
<listitem>
<simpara>Optional: if you support <literal>save-artifacts</literal>, run step 2 once again to
verify that saving and restoring artifacts works properly.</simpara>
</listitem>
<listitem>
<simpara>Run the container:</simpara>
<itemizedlist>
<listitem>
<simpara>If you use Podman, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman run &lt;output_application_image_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>If you use Docker, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ docker run &lt;output_application_image_name&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Verify the container is running and the application is responding.</simpara>
</listitem>
</orderedlist>
<simpara>Running these steps is generally enough to tell if the builder image is
working as expected.</simpara>
</section>
<section xml:id="images-test-s21-using-openshift-for-building-the-image_create-images">
<title>Using OpenShift Container Platform for building the image</title>
<simpara>Once you have a <literal>Dockerfile</literal> and the other artifacts that make up your new
S2I builder image, you can put them in a git repository and use OpenShift Container Platform
to build and push the image. Define a Docker build that points
to your repository.</simpara>
<simpara>If your OpenShift Container Platform instance is hosted on a public IP address, the build can
be triggered each time you push into your S2I builder image GitHub repository.</simpara>
<simpara>You can also use the <literal>ImageChangeTrigger</literal> to trigger a rebuild of your applications that are
based on the S2I builder image you updated.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="_managing_images">
<title>Managing images</title>
<section xml:id="managing-images-overview">
<title>Managing images overview</title>

<simpara>With OpenShift Container Platform you can interact with images and set up image streams, depending on where the registries of the images are located, any authentication requirements around those registries, and how you want your builds and deployments to behave.</simpara>
<section xml:id="images-managing-overview_managing-images-overview">
<title>Images overview</title>
<simpara>An image stream comprises any number of container images identified by tags. It presents a single virtual view of related images, similar to a container image repository.</simpara>
<simpara>By watching an image stream, builds and deployments can receive notifications when new images are added or modified and react by performing a build or deployment, respectively.</simpara>
</section>
</section>
<section xml:id="tagging-images">
<title>Tagging images</title>

<simpara>The following sections provide an overview and instructions for using image tags in the context of container images for working with OpenShift Container Platform image streams and their tags.</simpara>
<section xml:id="images-tag_tagging-images">
<title>Image tags</title>
<simpara>An image tag is a label applied to a container image in a repository that distinguishes a specific image from other images in an image stream. Typically, the tag represents a version number of some sort. For example, here <literal>:v3.11.59-2</literal> is the tag:</simpara>
<programlisting language="text" linenumbering="unnumbered">registry.access.redhat.com/openshift3/jenkins-2-rhel7:v3.11.59-2</programlisting>
<simpara>You can add additional tags to an image. For example, an image might be assigned the tags <literal>:v3.11.59-2</literal> and <literal>:latest</literal>.</simpara>
<simpara>OpenShift Container Platform provides the <literal>oc tag</literal> command, which is similar to the <literal>docker tag</literal> command, but operates on image streams instead of directly on images.</simpara>
</section>
<section xml:id="images-tagging-conventions_tagging-images">
<title>Image tag conventions</title>
<simpara>Images evolve over time and their tags reflect this. Generally, an image tag always points to the latest image built.</simpara>
<simpara>If there is too much information embedded in a tag name, like <literal>v2.0.1-may-2019</literal>, the tag points to just one revision of an image and is never updated. Using default image pruning options, such an image is never removed.
In very large clusters, the schema of creating new tags for every revised image could eventually fill up the etcd datastore with excess tag metadata for images that are long outdated.</simpara>
<simpara>If the tag is named <literal>v2.0</literal>, image revisions are more likely. This results in longer tag history and, therefore, the image pruner is more likely to remove old and unused images.</simpara>
<simpara>Although tag naming convention is up to you, here are a few examples in the format <literal>&lt;image_name&gt;:&lt;image_tag&gt;</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Image tag naming conventions</title>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="106.25*"/>
<colspec colname="col_2" colwidth="106.25*"/>
<thead>
<row>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Revision</simpara></entry>
<entry align="left" valign="top"><simpara><literal>myimage:v2.0.1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Architecture</simpara></entry>
<entry align="left" valign="top"><simpara><literal>myimage:v2.0-x86_64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Base image</simpara></entry>
<entry align="left" valign="top"><simpara><literal>myimage:v1.2-centos7</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Latest (potentially unstable)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>myimage:latest</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Latest stable</simpara></entry>
<entry align="left" valign="top"><simpara><literal>myimage:stable</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>If you require dates in tag names, periodically inspect old and unsupported images and <literal>istags</literal> and remove them. Otherwise, you can experience increasing resource usage caused by retaining old images.</simpara>
</section>
<section xml:id="images-add-tags-to-imagestreams_tagging-images">
<title>Adding tags to image streams</title>
<simpara>An image stream in OpenShift Container Platform comprises zero or more container images identified by tags.</simpara>
<simpara>There are different types of tags available. The default behavior uses a <literal>permanent</literal> tag, which points to a specific image in time. If the <literal>permanent</literal> tag is in use and the source changes, the tag does not change for the destination.</simpara>
<simpara>A <literal>tracking</literal> tag means the destination tag&#8217;s metadata is updated during the import of the source tag.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>You can add tags to an image stream using the <literal>oc tag</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;source&gt; &lt;destination&gt;</programlisting>
<simpara>For example, to configure the <literal>ruby</literal> image stream <literal>static-2.0</literal> tag to always refer to the current image for the <literal>ruby</literal> image stream <literal>2.0</literal> tag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag ruby:2.0 ruby:static-2.0</programlisting>
<simpara>This creates a new image stream tag named <literal>static-2.0</literal> in the <literal>ruby</literal> image stream. The new tag directly references the image id that the <literal>ruby:2.0</literal> image stream tag pointed to at the time <literal>oc tag</literal> was run, and the image it points to never changes.</simpara>
</listitem>
<listitem>
<simpara>To ensure the destination tag is updated when the source tag changes, use the <literal>--alias=true</literal> flag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag --alias=true &lt;source&gt; &lt;destination&gt;</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>Use a tracking tag for creating permanent aliases, for example, <literal>latest</literal> or <literal>stable</literal>. The tag only works correctly within a single image stream. Trying to create a cross-image stream alias produces an error.</simpara>
</note>
<itemizedlist>
<listitem>
<simpara>You can also add the <literal>--scheduled=true</literal> flag to have the destination tag be
refreshed, or re-imported, periodically. The period is configured globally at
the system level.</simpara>
</listitem>
<listitem>
<simpara>The <literal>--reference</literal> flag creates an image stream tag that is not imported. The tag points to the source location, permanently.</simpara>
<simpara>If you want to instruct OpenShift Container Platform to always fetch the tagged image from the integrated registry, use <literal>--reference-policy=local</literal>. The registry uses the pull-through feature to serve the image to the client. By default, the image blobs are mirrored locally by the registry. As a result, they can be pulled more quickly the next time they are needed. The flag also allows for pulling from insecure registries without a need to supply <literal>--insecure-registry</literal> to the container runtime as long as the image stream has an insecure annotation or the tag has an insecure import policy.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-remove-tag-imagestream_tagging-images">
<title>Removing tags from image streams</title>
<simpara>You can remove tags from an image stream.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To remove a tag completely from an image stream run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete istag/ruby:latest</programlisting>
<simpara>or:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag -d ruby:latest</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-referencing-images-imagestreams_tagging-images">
<title>Referencing images in imagestreams</title>
<simpara>You can use tags to reference images in image streams using the following reference types.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Imagestream reference types</title>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="106.25*"/>
<colspec colname="col_2" colwidth="106.25*"/>
<thead>
<row>
<entry align="left" valign="top">Reference type</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ImageStreamTag</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An <literal>ImageStreamTag</literal> is used to reference or retrieve an image for a given image stream and tag.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ImageStreamImage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An <literal>ImageStreamImage</literal> is used to reference or retrieve an image for a given image stream and image <literal>sha</literal> ID.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DockerImage</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A <literal>DockerImage</literal> is used to reference or retrieve an image for a given external registry. It uses standard Docker <literal>pull specification</literal> for its name.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>When viewing example image stream definitions you may notice they contain definitions of <literal>ImageStreamTag</literal> and references to <literal>DockerImage</literal>, but nothing related to <literal>ImageStreamImage</literal>.</simpara>
<simpara>This is because the <literal>ImageStreamImage</literal> objects are automatically created in OpenShift Container Platform when you import or tag an image into the image stream. You should never have to explicitly define an <literal>ImageStreamImage</literal> object in any image stream definition that you use to create image streams.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To reference an image for a given image stream and tag, use <literal>ImageStreamTag</literal>:</simpara>
<screen>&lt;image_stream_name&gt;:&lt;tag&gt;</screen>
</listitem>
<listitem>
<simpara>To reference an image for a given image stream and image <literal>sha</literal> ID, use <literal>ImageStreamImage</literal>:</simpara>
<screen>&lt;image_stream_name&gt;@&lt;id&gt;</screen>
<simpara>The <literal>&lt;id&gt;</literal> is an immutable identifier for a specific image, also called a
digest.</simpara>
</listitem>
<listitem>
<simpara>To reference or retrieve an image for a given external registry, use <literal>DockerImage</literal>:</simpara>
<screen>openshift/ruby-20-centos7:2.0</screen>
<note>
<simpara>When no tag is specified, it is assumed the <literal>latest</literal> tag is used.</simpara>
</note>
<simpara>You can also reference a third-party registry:</simpara>
<screen>registry.redhat.io/rhel7:latest</screen>
<simpara>Or an image with a digest:</simpara>
<screen>centos/ruby-22-centos7@sha256:3a335d7d8a452970c5b4054ad7118ff134b3a6b50a2bb6d0c07c746e8986b28e</screen>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="image-pull-policy">
<title>Image pull policy</title>

<simpara>Each container in a pod has a container image. After you have created an image and pushed it to a registry, you can then refer to it in the pod.</simpara>
<section xml:id="images-image-pull-policy-overview_image-pull-policy">
<title>Image pull policy overview</title>
<simpara>When OpenShift Container Platform creates containers, it uses the container <literal>imagePullPolicy</literal> to determine if the image should be pulled prior to starting the container. There are three possible values for <literal>imagePullPolicy</literal>:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title><literal>imagePullPolicy</literal> values</title>
<?dbhtml table-width="50%"?>
<?dbfo table-width="50%"?>
<?dblatex table-width="50%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="106.25*"/>
<colspec colname="col_2" colwidth="106.25*"/>
<thead>
<row>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Always</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Always pull the image.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>IfNotPresent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only pull the image if it does not already exist on the node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Never</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Never pull the image.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>If a container <literal>imagePullPolicy</literal> parameter is not specified, OpenShift Container Platform sets it based on the image tag:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If the tag is <literal>latest</literal>, OpenShift Container Platform defaults <literal>imagePullPolicy</literal> to <literal>Always</literal>.</simpara>
</listitem>
<listitem>
<simpara>Otherwise, OpenShift Container Platform defaults <literal>imagePullPolicy</literal> to <literal>IfNotPresent</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="using-image-pull-secrets">
<title>Using image pull secrets</title>

<simpara>If you are using the OpenShift image registry and are pulling from image streams located in the same project, then your pod service account should already have the correct permissions and no additional action should be required.</simpara>
<simpara>However, for other scenarios, such as referencing images across OpenShift Container Platform projects or from secured registries, additional configuration steps are required.</simpara>
<simpara>You can obtain the image <link xlink:href="https://console.redhat.com/openshift/install/pull-secret">pull secret from the Red Hat OpenShift Cluster Manager</link>. This pull secret is called <literal>pullSecret</literal>.</simpara>
<simpara>You use this pull secret to authenticate with the services that are provided by the included authorities, <link xlink:href="https://quay.io/">Quay.io</link> and <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>, which serve the container images for OpenShift Container Platform components.</simpara>
<section xml:id="images-allow-pods-to-reference-images-across-projects_using-image-pull-secrets">
<title>Allowing pods to reference images across projects</title>
<simpara>When using the OpenShift image registry, to allow pods in <literal>project-a</literal> to reference images in <literal>project-b</literal>, a service account in <literal>project-a</literal> must be bound to the <literal>system:image-puller</literal> role in <literal>project-b</literal>.</simpara>
<note>
<simpara>When you create a pod service account or a namespace, wait until the service account is provisioned with a docker pull secret; if you create a pod before its service account is fully provisioned, the pod fails to access the OpenShift image registry.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To allow pods in <literal>project-a</literal> to reference images in <literal>project-b</literal>, bind a service account in <literal>project-a</literal> to the <literal>system:image-puller</literal> role in <literal>project-b</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user \
    system:image-puller system:serviceaccount:project-a:default \
    --namespace=project-b</programlisting>
<simpara>After adding that role, the pods in <literal>project-a</literal> that reference the default service account are able to pull images from <literal>project-b</literal>.</simpara>
</listitem>
<listitem>
<simpara>To allow access for any service account in <literal>project-a</literal>, use the group:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-group \
    system:image-puller system:serviceaccounts:project-a \
    --namespace=project-b</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="images-allow-pods-to-reference-images-from-secure-registries_using-image-pull-secrets">
<title>Allowing pods to reference images from other secured registries</title>
<simpara>The <literal>.dockercfg</literal> <literal>$HOME/.docker/config.json</literal> file for Docker clients is a Docker credentials file that stores your authentication information if you have previously logged into a secured or insecure registry.</simpara>
<simpara>To pull a secured container image that is not from OpenShift image registry, you must create a pull secret from your Docker credentials and add it to your service account.</simpara>
<simpara>The Docker credentials file and the associated pull secret can contain multiple references to the same registry, each with its own set of credentials.</simpara>
<formalpara>
<title>Example <literal>config.json</literal> file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
   "auths":{
      "cloud.openshift.com":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      },
      "quay.io":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      },
      "quay.io/repository-main":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      }
   }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example pull secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  .dockerconfigjson: ewogICAiYXV0aHMiOnsKICAgICAgIm0iOnsKICAgICAgIsKICAgICAgICAgImF1dGgiOiJiM0JsYj0iLAogICAgICAgICAiZW1haWwiOiJ5b3VAZXhhbXBsZS5jb20iCiAgICAgIH0KICAgfQp9Cg==
kind: Secret
metadata:
  creationTimestamp: "2021-09-09T19:10:11Z"
  name: pull-secret
  namespace: default
  resourceVersion: "37676"
  uid: e2851531-01bc-48ba-878c-de96cfe31020
type: Opaque</programlisting>
</para>
</formalpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>If you already have a <literal>.dockercfg</literal> file for the secured registry, you can create a secret from that file by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockercfg=&lt;path/to/.dockercfg&gt; \
    --type=kubernetes.io/dockercfg</programlisting>
</listitem>
<listitem>
<simpara>Or if you have a <literal>$HOME/.docker/config.json</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
</listitem>
<listitem>
<simpara>If you do not already have a Docker credentials file for the secured registry, you can create a secret by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry &lt;pull_secret_name&gt; \
    --docker-server=&lt;registry_server&gt; \
    --docker-username=&lt;user_name&gt; \
    --docker-password=&lt;password&gt; \
    --docker-email=&lt;email&gt;</programlisting>
</listitem>
<listitem>
<simpara>To use a secret for pulling images for pods, you must add the secret to your service account. The name of the service account in this example should match the name of the service account the pod uses. The default service account is <literal>default</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link default &lt;pull_secret_name&gt; --for=pull</programlisting>
</listitem>
</itemizedlist>
<section xml:id="images-pulling-from-private-registries_using-image-pull-secrets">
<title>Pulling from private registries with delegated authentication</title>
<simpara>A private registry can delegate authentication to a separate service. In these cases, image pull secrets must be defined for both the authentication and registry endpoints.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a secret for the delegated authentication server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry \
    --docker-server=sso.redhat.com \
    --docker-username=developer@example.com \
    --docker-password=******** \
    --docker-email=unused \
    redhat-connect-sso

secret/redhat-connect-sso</programlisting>
</listitem>
<listitem>
<simpara>Create a secret for the private registry:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry \
    --docker-server=privateregistry.example.com \
    --docker-username=developer@example.com \
    --docker-password=******** \
    --docker-email=unused \
    private-registry

secret/private-registry</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="images-update-global-pull-secret_using-image-pull-secrets">
<title>Updating the global cluster pull secret</title>
<simpara>You can update the global pull secret for your cluster by either replacing the current pull secret or appending a new pull secret.</simpara>
<important>
<simpara>To transfer your cluster to another owner, you must first initiate the transfer in <link xlink:href="https://console.redhat.com/openshift">OpenShift Cluster Manager Hybrid Cloud Console</link>, and then update the pull secret on the cluster. Updating a cluster&#8217;s pull secret without initiating the transfer in OpenShift Cluster Manager causes the cluster to stop reporting Telemetry metrics in OpenShift Cluster Manager.</simpara>
<simpara>For more information <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_cluster_manager/2023/html-single/managing_clusters/index#transferring-cluster-ownership_downloading-and-updating-pull-secrets">about transferring cluster ownership</link>, see "Transferring cluster ownership" in the Red Hat OpenShift Cluster Manager documentation.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: To append a new pull secret to the existing pull secret, complete the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter the following command to download the pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret/pull-secret -n openshift-config --template='{{index .data ".dockerconfigjson" | base64decode}}' &gt;&lt;pull_secret_location&gt; <co xml:id="CO7-1"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Provide the path to the pull secret file.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enter the following command to add the new pull secret:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc registry login --registry="&lt;registry&gt;" \ <co xml:id="CO8-1"/>
--auth-basic="&lt;username&gt;:&lt;password&gt;" \ <co xml:id="CO8-2"/>
--to=&lt;pull_secret_location&gt; <co xml:id="CO8-3"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>Provide the new registry. You can include multiple repositories within the same registry, for example: <literal>--registry="&lt;registry/my-namespace/my-repository&gt;"</literal>.</para>
</callout>
<callout arearefs="CO8-2">
<para>Provide the credentials of the new registry.</para>
</callout>
<callout arearefs="CO8-3">
<para>Provide the path to the pull secret file.</para>
</callout>
</calloutlist>
<simpara>Alternatively, you can perform a manual update to the pull secret file.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enter the following command to update the global pull secret for your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set data secret/pull-secret -n openshift-config --from-file=.dockerconfigjson=&lt;pull_secret_location&gt; <co xml:id="CO9-1"/></programlisting>
<calloutlist>
<callout arearefs="CO9-1">
<para>Provide the path to the new pull secret file.</para>
</callout>
</calloutlist>
<simpara>This update is rolled out to all nodes, which can take some time depending on the size of your cluster.</simpara>
<note>
<simpara>As of OpenShift Container Platform 4.7.4, changes to the global pull secret no longer trigger a node drain or reboot.</simpara>
</note>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="managing-image-streams">
<title>Managing image streams</title>

<simpara>Image streams provide a means of creating and updating container images in an on-going way. As improvements are made to an image, tags can be used to assign new version numbers and keep track of changes. This document describes how image streams are managed.</simpara>
<section xml:id="images-imagestream-use_image-streams-managing">
<title>Why use imagestreams</title>
<simpara>An image stream and its associated tags provide an abstraction for referencing container images from within OpenShift Container Platform. The image stream and its tags allow you to see what images are available and ensure that you are using the specific image you need even if the image in the repository changes.</simpara>
<simpara>Image streams do not contain actual image data, but present a single virtual view of related images, similar to an image repository.</simpara>
<simpara>You can configure builds and deployments to watch an image stream for notifications when new images are added and react by performing a build or deployment, respectively.</simpara>
<simpara>For example, if a deployment is using a certain image and a new version of that image is created, a deployment could be automatically performed to pick up the new version of the image.</simpara>
<simpara>However, if the image stream tag used by the deployment or build is not updated, then even if the container image in the container image registry is updated, the build or deployment continues using the previous, presumably known good
image.</simpara>
<simpara>The source images can be stored in any of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform&#8217;s integrated registry.</simpara>
</listitem>
<listitem>
<simpara>An external registry, for example registry.redhat.io or quay.io.</simpara>
</listitem>
<listitem>
<simpara>Other image streams in the OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<simpara>When you define an object that references an image stream tag, such as a build or deployment configuration, you point to an image stream tag and not the repository. When you build or deploy your application, OpenShift Container Platform queries the repository using the image stream tag to locate the associated ID of the image and uses that exact image.</simpara>
<simpara>The image stream metadata is stored in the etcd instance along with other cluster information.</simpara>
<simpara>Using image streams has several significant benefits:</simpara>
<itemizedlist>
<listitem>
<simpara>You can tag, rollback a tag, and quickly deal with images, without having to re-push using the command line.</simpara>
</listitem>
<listitem>
<simpara>You can trigger builds and deployments when a new image is pushed to the registry. Also, OpenShift Container Platform has generic triggers for other resources, such as Kubernetes objects.</simpara>
</listitem>
<listitem>
<simpara>You can mark a tag for periodic re-import. If the source image has changed, that change is picked up and reflected in the image stream, which triggers the build or deployment flow, depending upon the build or deployment configuration.</simpara>
</listitem>
<listitem>
<simpara>You can share images using fine-grained access control and quickly distribute images across your teams.</simpara>
</listitem>
<listitem>
<simpara>If the source image changes, the image stream tag still points to a known-good version of the image, ensuring that your application do not break unexpectedly.</simpara>
</listitem>
<listitem>
<simpara>You can configure security around who can view and use the images through permissions on the image stream objects.</simpara>
</listitem>
<listitem>
<simpara>Users that lack permission to read or list images on the cluster level can still retrieve the images tagged in a project using image streams.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-configure_image-streams-managing">
<title>Configuring image streams</title>
<simpara>An <literal>ImageStream</literal> object file contains the following elements.</simpara>
<formalpara xml:id="image-stream-object-definition_image-streams-managing">
<title>Imagestream object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  annotations:
    openshift.io/generated-by: OpenShiftNewApp
  labels:
    app: ruby-sample-build
    template: application-template-stibuild
  name: origin-ruby-sample <co xml:id="CO10-1"/>
  namespace: test
spec: {}
status:
  dockerImageRepository: 172.30.56.218:5000/test/origin-ruby-sample <co xml:id="CO10-2"/>
  tags:
  - items:
    - created: 2017-09-02T10:15:09Z
      dockerImageReference: 172.30.56.218:5000/test/origin-ruby-sample@sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d <co xml:id="CO10-3"/>
      generation: 2
      image: sha256:909de62d1f609a717ec433cc25ca5cf00941545c83a01fb31527771e1fab3fc5 <co xml:id="CO10-4"/>
    - created: 2017-09-01T13:40:11Z
      dockerImageReference: 172.30.56.218:5000/test/origin-ruby-sample@sha256:909de62d1f609a717ec433cc25ca5cf00941545c83a01fb31527771e1fab3fc5
      generation: 1
      image: sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d
    tag: latest <co xml:id="CO10-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>The name of the image stream.</para>
</callout>
<callout arearefs="CO10-2">
<para>Docker repository path where new images can be pushed to add or update them in this image stream.</para>
</callout>
<callout arearefs="CO10-3">
<para>The SHA identifier that this image stream tag currently references. Resources that reference this image stream tag use this identifier.</para>
</callout>
<callout arearefs="CO10-4">
<para>The SHA identifier that this image stream tag previously referenced. Can be used to rollback to an older image.</para>
</callout>
<callout arearefs="CO10-5">
<para>The image stream tag name.</para>
</callout>
</calloutlist>
</section>
<section xml:id="images-using-imagestream-images_image-streams-managing">
<title>Image stream images</title>
<simpara>An image stream image points from within an image stream to a particular image ID.</simpara>
<simpara>Image stream images allow you to retrieve metadata about an image from a particular image stream where it is tagged.</simpara>
<simpara>Image stream image objects are automatically created in OpenShift Container Platform whenever you import or tag an image into the image stream. You should never have to explicitly define an image stream image object in any image stream definition that you use to create image streams.</simpara>
<simpara>The image stream image consists of the image stream name and image ID from the repository, delimited by an <literal>@</literal> sign:</simpara>
<screen>&lt;image-stream-name&gt;@&lt;image-id&gt;</screen>
<simpara>To refer to the image in the <literal>ImageStream</literal> object example, the image stream image looks like:</simpara>
<screen>origin-ruby-sample@sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d</screen>
</section>
<section xml:id="images-using-imagestream-tags_image-streams-managing">
<title>Image stream tags</title>
<simpara>An image stream tag is a named pointer to an image in an image stream. It is abbreviated as <literal>istag</literal>. An image stream tag is used to reference or retrieve an image for a given image stream and tag.</simpara>
<simpara>Image stream tags can reference any local or externally managed image. It contains a history of images represented as a stack of all images the tag ever pointed to. Whenever a new or existing image is tagged under particular image stream tag, it is placed at the first position in the history stack. The image previously occupying the top position is available at the second position. This allows for easy rollbacks to make tags point to historical images again.</simpara>
<simpara>The following image stream tag is from an <literal>ImageStream</literal> object:</simpara>
<formalpara>
<title>Image stream tag with two images in its history</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageStream
apiVersion: image.openshift.io/v1
metadata:
  name: my-image-stream
# ...
  tags:
  - items:
    - created: 2017-09-02T10:15:09Z
      dockerImageReference: 172.30.56.218:5000/test/origin-ruby-sample@sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d
      generation: 2
      image: sha256:909de62d1f609a717ec433cc25ca5cf00941545c83a01fb31527771e1fab3fc5
    - created: 2017-09-01T13:40:11Z
      dockerImageReference: 172.30.56.218:5000/test/origin-ruby-sample@sha256:909de62d1f609a717ec433cc25ca5cf00941545c83a01fb31527771e1fab3fc5
      generation: 1
      image: sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d
    tag: latest
# ...</programlisting>
</para>
</formalpara>
<simpara>Image stream tags can be permanent tags or tracking tags.</simpara>
<itemizedlist>
<listitem>
<simpara>Permanent tags are version-specific tags that point to a particular version of an image, such as Python 3.5.</simpara>
</listitem>
<listitem>
<simpara>Tracking tags are reference tags that follow another image stream tag and can be updated to change which image they follow, like a symlink. These new levels are not guaranteed to be backwards-compatible.</simpara>
<simpara>For example, the <literal>latest</literal> image stream tags that ship with OpenShift Container Platform are tracking tags. This means consumers of the <literal>latest</literal> image stream tag are updated to the newest level of the framework provided by the image when a new level becomes available. A <literal>latest</literal> image stream tag to <literal>v3.10</literal> can be changed to <literal>v3.11</literal> at any time. It is important to be aware that these <literal>latest</literal> image stream tags behave differently than the Docker <literal>latest</literal> tag. The <literal>latest</literal> image stream tag, in this case, does not point to the latest image in the Docker repository. It points to another image stream tag, which might not be the latest version of an image. For example, if the <literal>latest</literal> image stream tag points to <literal>v3.10</literal> of an image, when the <literal>3.11</literal> version is released, the <literal>latest</literal> tag is not automatically updated to <literal>v3.11</literal>, and remains at <literal>v3.10</literal> until it is manually updated to point to a <literal>v3.11</literal> image stream tag.</simpara>
<note>
<simpara>Tracking tags are limited to a single image stream and cannot reference other
image streams.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>You can create your own image stream tags for your own needs.</simpara>
<simpara>The image stream tag is composed of the name of the image stream and a tag,
separated by a colon:</simpara>
<screen>&lt;imagestream name&gt;:&lt;tag&gt;</screen>
<simpara>For example, to refer to the
<literal>sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d</literal> image
in the <literal>ImageStream</literal> object example earlier, the image stream tag
would be:</simpara>
<screen>origin-ruby-sample:latest</screen>
</section>
<section xml:id="images-using-imagestream-change-triggers_image-streams-managing">
<title>Image stream change triggers</title>
<simpara>Image stream triggers allow your builds and deployments to be automatically
invoked when a new version of an upstream image is available.</simpara>
<simpara>For example, builds and deployments can be automatically started when an image
stream tag is modified. This is achieved by monitoring that particular image
stream tag and notifying the build or deployment when a change is detected.</simpara>
</section>
<section xml:id="images-imagestream-mapping_image-streams-managing">
<title>Image stream mapping</title>
<simpara>When the integrated registry receives a new image, it creates and sends an image stream mapping to OpenShift Container Platform, providing the image&#8217;s project, name, tag, and image metadata.</simpara>
<note>
<simpara>Configuring image stream mappings is an advanced feature.</simpara>
</note>
<simpara>This information is used to create a new image, if it does not already exist, and to tag the image into the image stream. OpenShift Container Platform stores complete metadata about each image, such as commands, entry point, and environment variables. Images in OpenShift Container Platform are immutable and the maximum name length is 63 characters.</simpara>
<simpara>The following image stream mapping example results in an image being tagged as <literal>test/origin-ruby-sample:latest</literal>:</simpara>
<formalpara>
<title>Image stream mapping object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: image.openshift.io/v1
kind: ImageStreamMapping
metadata:
  creationTimestamp: null
  name: origin-ruby-sample
  namespace: test
tag: latest
image:
  dockerImageLayers:
  - name: sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef
    size: 0
  - name: sha256:ee1dd2cb6df21971f4af6de0f1d7782b81fb63156801cfde2bb47b4247c23c29
    size: 196634330
  - name: sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef
    size: 0
  - name: sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef
    size: 0
  - name: sha256:ca062656bff07f18bff46be00f40cfbb069687ec124ac0aa038fd676cfaea092
    size: 177723024
  - name: sha256:63d529c59c92843c395befd065de516ee9ed4995549f8218eac6ff088bfa6b6e
    size: 55679776
  - name: sha256:92114219a04977b5563d7dff71ec4caa3a37a15b266ce42ee8f43dba9798c966
    size: 11939149
  dockerImageMetadata:
    Architecture: amd64
    Config:
      Cmd:
      - /usr/libexec/s2i/run
      Entrypoint:
      - container-entrypoint
      Env:
      - RACK_ENV=production
      - OPENSHIFT_BUILD_NAMESPACE=test
      - OPENSHIFT_BUILD_SOURCE=https://github.com/openshift/ruby-hello-world.git
      - EXAMPLE=sample-app
      - OPENSHIFT_BUILD_NAME=ruby-sample-build-1
      - PATH=/opt/app-root/src/bin:/opt/app-root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      - STI_SCRIPTS_URL=image:///usr/libexec/s2i
      - STI_SCRIPTS_PATH=/usr/libexec/s2i
      - HOME=/opt/app-root/src
      - BASH_ENV=/opt/app-root/etc/scl_enable
      - ENV=/opt/app-root/etc/scl_enable
      - PROMPT_COMMAND=. /opt/app-root/etc/scl_enable
      - RUBY_VERSION=2.2
      ExposedPorts:
        8080/tcp: {}
      Labels:
        build-date: 2015-12-23
        io.k8s.description: Platform for building and running Ruby 2.2 applications
        io.k8s.display-name: 172.30.56.218:5000/test/origin-ruby-sample:latest
        io.openshift.build.commit.author: Ben Parees &lt;bparees@users.noreply.github.com&gt;
        io.openshift.build.commit.date: Wed Jan 20 10:14:27 2016 -0500
        io.openshift.build.commit.id: 00cadc392d39d5ef9117cbc8a31db0889eedd442
        io.openshift.build.commit.message: 'Merge pull request #51 from php-coder/fix_url_and_sti'
        io.openshift.build.commit.ref: master
        io.openshift.build.image: centos/ruby-22-centos7@sha256:3a335d7d8a452970c5b4054ad7118ff134b3a6b50a2bb6d0c07c746e8986b28e
        io.openshift.build.source-location: https://github.com/openshift/ruby-hello-world.git
        io.openshift.builder-base-version: 8d95148
        io.openshift.builder-version: 8847438ba06307f86ac877465eadc835201241df
        io.openshift.s2i.scripts-url: image:///usr/libexec/s2i
        io.openshift.tags: builder,ruby,ruby22
        io.s2i.scripts-url: image:///usr/libexec/s2i
        license: GPLv2
        name: CentOS Base Image
        vendor: CentOS
      User: "1001"
      WorkingDir: /opt/app-root/src
    Container: 86e9a4a3c760271671ab913616c51c9f3cea846ca524bf07c04a6f6c9e103a76
    ContainerConfig:
      AttachStdout: true
      Cmd:
      - /bin/sh
      - -c
      - tar -C /tmp -xf - &amp;&amp; /usr/libexec/s2i/assemble
      Entrypoint:
      - container-entrypoint
      Env:
      - RACK_ENV=production
      - OPENSHIFT_BUILD_NAME=ruby-sample-build-1
      - OPENSHIFT_BUILD_NAMESPACE=test
      - OPENSHIFT_BUILD_SOURCE=https://github.com/openshift/ruby-hello-world.git
      - EXAMPLE=sample-app
      - PATH=/opt/app-root/src/bin:/opt/app-root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      - STI_SCRIPTS_URL=image:///usr/libexec/s2i
      - STI_SCRIPTS_PATH=/usr/libexec/s2i
      - HOME=/opt/app-root/src
      - BASH_ENV=/opt/app-root/etc/scl_enable
      - ENV=/opt/app-root/etc/scl_enable
      - PROMPT_COMMAND=. /opt/app-root/etc/scl_enable
      - RUBY_VERSION=2.2
      ExposedPorts:
        8080/tcp: {}
      Hostname: ruby-sample-build-1-build
      Image: centos/ruby-22-centos7@sha256:3a335d7d8a452970c5b4054ad7118ff134b3a6b50a2bb6d0c07c746e8986b28e
      OpenStdin: true
      StdinOnce: true
      User: "1001"
      WorkingDir: /opt/app-root/src
    Created: 2016-01-29T13:40:00Z
    DockerVersion: 1.8.2.fc21
    Id: 9d7fd5e2d15495802028c569d544329f4286dcd1c9c085ff5699218dbaa69b43
    Parent: 57b08d979c86f4500dc8cad639c9518744c8dd39447c055a3517dc9c18d6fccd
    Size: 441976279
    apiVersion: "1.0"
    kind: DockerImage
  dockerImageMetadataVersion: "1.0"
  dockerImageReference: 172.30.56.218:5000/test/origin-ruby-sample@sha256:47463d94eb5c049b2d23b03a9530bf944f8f967a0fe79147dd6b9135bf7dd13d</programlisting>
</para>
</formalpara>
</section>
<section xml:id="_working_with_image_streams">
<title>Working with image streams</title>
<simpara>The following sections describe how to use image streams and image stream tags.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<section xml:id="images-getting-info-about-imagestreams_image-streams-managing">
<title>Getting information about image streams</title>
<simpara>You can get general information about the image stream and detailed information about all the tags it is pointing to.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To get general information about the image stream and detailed information about all the tags it is pointing to, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe is/&lt;image-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe is/python</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:			python
Namespace:		default
Created:		About a minute ago
Labels:			&lt;none&gt;
Annotations:		openshift.io/image.dockerRepositoryCheck=2017-10-02T17:05:11Z
Docker Pull Spec:	docker-registry.default.svc:5000/default/python
Image Lookup:		local=false
Unique Images:		1
Tags:			1

3.5
  tagged from centos/python-35-centos7

  * centos/python-35-centos7@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
      About a minute ago</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To get all of the information available about a particular image stream tag, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe istag/&lt;image-stream&gt;:&lt;tag-name&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe istag/python:latest</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Image Name:	sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
Docker Image:	centos/python-35-centos7@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
Name:		sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
Created:	2 minutes ago
Image Size:	251.2 MB (first layer 2.898 MB, last binary layer 72.26 MB)
Image Created:	2 weeks ago
Author:		&lt;none&gt;
Arch:		amd64
Entrypoint:	container-entrypoint
Command:	/bin/sh -c $STI_SCRIPTS_PATH/usage
Working Dir:	/opt/app-root/src
User:		1001
Exposes Ports:	8080/tcp
Docker Labels:	build-date=20170801</programlisting>
</para>
</formalpara>
<note>
<simpara>More information is output than shown.</simpara>
</note>
</listitem>
<listitem>
<simpara>Enter the following command to discover which architecture or operating system that an image stream tag supports:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get istag &lt;image-stream-tag&gt; -ojsonpath="{range .image.dockerImageManifests[*]}{.os}/{.architecture}{'\n'}{end}"</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get istag busybox:latest -ojsonpath="{range .image.dockerImageManifests[*]}{.os}/{.architecture}{'\n'}{end}"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">linux/amd64
linux/arm
linux/arm64
linux/386
linux/mips64le
linux/ppc64le
linux/riscv64
linux/s390x</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-adding-tags_image-streams-managing">
<title>Adding tags to an image stream</title>
<simpara>You can add additional tags to image streams.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add a tag that points to one of the existing tags by using the `oc tag`command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;image-name:tag1&gt; &lt;image-name:tag2&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag python:3.5 python:latest</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Tag python:latest set to python@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25.</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Confirm the image stream has two tags, one, <literal>3.5</literal>, pointing at the external container image and another tag, <literal>latest</literal>, pointing to the same image because it was created based on the first tag.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe is/python</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:			python
Namespace:		default
Created:		5 minutes ago
Labels:			&lt;none&gt;
Annotations:		openshift.io/image.dockerRepositoryCheck=2017-10-02T17:05:11Z
Docker Pull Spec:	docker-registry.default.svc:5000/default/python
Image Lookup:		local=false
Unique Images:		1
Tags:			2

latest
  tagged from python@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25

  * centos/python-35-centos7@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
      About a minute ago

3.5
  tagged from centos/python-35-centos7

  * centos/python-35-centos7@sha256:49c18358df82f4577386404991c51a9559f243e0b1bdc366df25
      5 minutes ago</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-external-image-tags_image-streams-managing">
<title>Adding tags for an external image</title>
<simpara>You can add tags for external images.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add tags pointing to internal or external images, by using the <literal>oc tag</literal> command for all tag-related operations:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;repository/image&gt; &lt;image-name:tag&gt;</programlisting>
<simpara>For example, this command maps the <literal>docker.io/python:3.6.0</literal> image to the <literal>3.6</literal> tag in the <literal>python</literal> image stream.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag docker.io/python:3.6.0 python:3.6</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Tag python:3.6 set to docker.io/python:3.6.0.</programlisting>
</para>
</formalpara>
<simpara>If the external image is secured, you must create a secret with credentials for accessing that registry.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-update-tag_image-streams-managing">
<title>Updating image stream tags</title>
<simpara>You can update a tag to reflect another tag in an image stream.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Update a tag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;image-name:tag&gt; &lt;image-name:latest&gt;</programlisting>
<simpara>For example, the following updates the <literal>latest</literal> tag to reflect the <literal>3.6</literal> tag in an image stream:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag python:3.6 python:latest</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Tag python:latest set to python@sha256:438208801c4806548460b27bd1fbcb7bb188273d13871ab43f.</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-remove-tag_image-streams-managing">
<title>Removing image stream tags</title>
<simpara>You can remove old tags from an image stream.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Remove old tags from an image stream:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag -d &lt;image-name:tag&gt;</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag -d python:3.6</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Deleted tag default/python:3.6</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>See <link xlink:href="../openshift_images/configuring-samples-operator.xml#images-samples-operator-deprecated-image-stream_configuring-samples-operator">Removing deprecated image stream tags from the Cluster Samples Operator</link> for more information on how the Cluster Samples Operator handles deprecated image stream tags.</simpara>
</section>
<section xml:id="images-imagestream-import_image-streams-managing">
<title>Configuring periodic importing of image stream tags</title>
<simpara>When working with an external container image registry, to periodically re-import an image, for example to get latest security updates, you can use the <literal>--scheduled</literal> flag.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Schedule importing images:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;repository/image&gt; &lt;image-name:tag&gt; --scheduled</programlisting>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag docker.io/python:3.6.0 python:3.6 --scheduled</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Tag python:3.6 set to import docker.io/python:3.6.0 periodically.</programlisting>
</para>
</formalpara>
<simpara>This command causes OpenShift Container Platform to periodically update this particular image stream tag. This period is a cluster-wide setting set to 15 minutes by default.</simpara>
</listitem>
<listitem>
<simpara>Remove the periodic check, re-run above command but omit the <literal>--scheduled</literal> flag. This will reset its behavior to default.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc tag &lt;repositiory/image&gt; &lt;image-name:tag&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="images-imagestream-import-images-image-streams">
<title>Importing and working with images and image streams</title>
<simpara>The following sections describe how to import, and work with, image streams.</simpara>
<section xml:id="images-imagestream-import-images-private-registry_image-streams-managing">
<title>Importing images and image streams from private registries</title>
<simpara>An image stream can be configured to import tag and image metadata from private image registries requiring authentication. This procedures applies if you change the registry that the Cluster Samples Operator uses to pull content from to something other than <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>.</simpara>
<note>
<simpara>When importing from insecure or secure registries, the registry URL defined in the secret must include the <literal>:80</literal> port suffix or the secret is not used when attempting to import from the registry.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>You must create a <literal>secret</literal> object that is used to store your credentials by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=.dockerconfigjson=&lt;file_absolute_path&gt; --type=kubernetes.io/dockerconfigjson</programlisting>
</listitem>
<listitem>
<simpara>After the secret is configured, create the new image stream or enter the <literal>oc import-image</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;imagestreamtag&gt; --from=&lt;image&gt; --confirm</programlisting>
<simpara>During the import process, OpenShift Container Platform picks up the secrets and provides them to the remote party.</simpara>
</listitem>
</orderedlist>
<section xml:id="images-allow-pods-to-reference-images-from-secure-registries_image-streams-managing">
<title>Allowing pods to reference images from other secured registries</title>
<simpara>The <literal>.dockercfg</literal> <literal>$HOME/.docker/config.json</literal> file for Docker clients is a Docker credentials file that stores your authentication information if you have previously logged into a secured or insecure registry.</simpara>
<simpara>To pull a secured container image that is not from OpenShift image registry, you must create a pull secret from your Docker credentials and add it to your service account.</simpara>
<simpara>The Docker credentials file and the associated pull secret can contain multiple references to the same registry, each with its own set of credentials.</simpara>
<formalpara>
<title>Example <literal>config.json</literal> file</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
   "auths":{
      "cloud.openshift.com":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      },
      "quay.io":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      },
      "quay.io/repository-main":{
         "auth":"b3Blb=",
         "email":"you@example.com"
      }
   }
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example pull secret</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
data:
  .dockerconfigjson: ewogICAiYXV0aHMiOnsKICAgICAgIm0iOnsKICAgICAgIsKICAgICAgICAgImF1dGgiOiJiM0JsYj0iLAogICAgICAgICAiZW1haWwiOiJ5b3VAZXhhbXBsZS5jb20iCiAgICAgIH0KICAgfQp9Cg==
kind: Secret
metadata:
  creationTimestamp: "2021-09-09T19:10:11Z"
  name: pull-secret
  namespace: default
  resourceVersion: "37676"
  uid: e2851531-01bc-48ba-878c-de96cfe31020
type: Opaque</programlisting>
</para>
</formalpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>If you already have a <literal>.dockercfg</literal> file for the secured registry, you can create a secret from that file by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockercfg=&lt;path/to/.dockercfg&gt; \
    --type=kubernetes.io/dockercfg</programlisting>
</listitem>
<listitem>
<simpara>Or if you have a <literal>$HOME/.docker/config.json</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;pull_secret_name&gt; \
    --from-file=.dockerconfigjson=&lt;path/to/.docker/config.json&gt; \
    --type=kubernetes.io/dockerconfigjson</programlisting>
</listitem>
<listitem>
<simpara>If you do not already have a Docker credentials file for the secured registry, you can create a secret by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret docker-registry &lt;pull_secret_name&gt; \
    --docker-server=&lt;registry_server&gt; \
    --docker-username=&lt;user_name&gt; \
    --docker-password=&lt;password&gt; \
    --docker-email=&lt;email&gt;</programlisting>
</listitem>
<listitem>
<simpara>To use a secret for pulling images for pods, you must add the secret to your service account. The name of the service account in this example should match the name of the service account the pod uses. The default service account is <literal>default</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc secrets link default &lt;pull_secret_name&gt; --for=pull</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-imagestream-import-import-mode_image-streams-managing">
<title>Working with manifest lists</title>
<simpara>You can import a single sub-manifest, or all manifests, of a manifest list when using <literal>oc import-image</literal> or <literal>oc tag</literal> CLI commands by adding the <literal>--import-mode</literal> flag.</simpara>
<simpara>Refer to the commands below to create an image stream that includes a single sub-manifest or multi-architecture images.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create an image stream that includes multi-architecture images, and sets the import mode to <literal>PreserveOriginal</literal>, by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt;  --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt; \
--import-mode='PreserveOriginal' --reference-policy=local --confirm</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">---
Arch:           &lt;none&gt;
Manifests:      linux/amd64     sha256:6e325b86566fafd3c4683a05a219c30c421fbccbf8d87ab9d20d4ec1131c3451
                linux/arm64     sha256:d8fad562ffa75b96212c4a6dc81faf327d67714ed85475bf642729703a2b5bf6
                linux/ppc64le   sha256:7b7e25338e40d8bdeb1b28e37fef5e64f0afd412530b257f5b02b30851f416e1
---</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Alternatively, enter the following command to import an image with the <literal>Legacy</literal> import mode, which discards manifest lists and imports a single sub-manifest:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt;  --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt; \
--import-mode='Legacy' --confirm</programlisting>
<note>
<simpara>The <literal>--import-mode=</literal> default value is <literal>Legacy</literal>. Excluding this value, or failing to specify either <literal>Legacy</literal> or <literal>PreserveOriginal</literal>, imports a single sub-manifest. An invalid import mode returns the following error: <literal>error: valid ImportMode values are Legacy or PreserveOriginal</literal>.</simpara>
</note>
</listitem>
</itemizedlist>
<bridgehead xml:id="images-imagestream-import-import-mode-limitations" renderas="sect4">Limitations</bridgehead>
<simpara>Working with manifest lists has the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>In some cases, users might want to use sub-manifests directly. When <literal>oc adm prune images</literal> is run, or the <literal>CronJob</literal> pruner runs, they cannot detect when a sub-manifest list is used. As a result, an administrator using <literal>oc adm prune images</literal>, or the <literal>CronJob</literal> pruner, might delete entire manifest lists, including sub-manifests.</simpara>
<simpara>To avoid this limitation, you can use the manifest list by tag or by digest instead.</simpara>
</listitem>
</itemizedlist>
<section xml:id="images-imagestream-periodic-import-list_image-streams-managing">
<title>Configuring periodic importing of manifest lists</title>
<simpara>To periodically re-import a manifest list, you can use the <literal>--scheduled</literal> flag.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set the image stream to periodically update the manifest list by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt;  --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt; \
--import-mode='PreserveOriginal' --scheduled=true</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-imagestream-ssl-import-list_image-streams-managing">
<title>Configuring SSL/TSL when importing manifest lists</title>
<simpara>To configure SSL/TSL when importing a manifest list, you can use the <literal>--insecure</literal> flag.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Set <literal>--insecure=true</literal> so that importing a manifest list skips SSL/TSL verification. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt; --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt; \
--import-mode='PreserveOriginal' --insecure=true</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-imagestream-specify-architecture_image-streams-managing">
<title>Specifying architecture for --import-mode</title>
<simpara>You can swap your imported image stream between multi-architecture and single architecture by excluding or including the <literal>--import-mode=</literal> flag</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the following command to update your image stream from multi-architecture to single architecture by excluding the <literal>--import-mode=</literal> flag:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt; --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the following command to update your image stream from single-architecture to multi-architecture:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc import-image &lt;multiarch-image-stream-tag&gt;  --from=&lt;registry&gt;/&lt;project_name&gt;/&lt;image-name&gt; \
--import-mode='PreserveOriginal'</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="importmode-configuration-fields_image-streams-managing">
<title>Configuration fields for --import-mode</title>
<simpara>The following table describes the options available for the <literal>--import-mode=</literal> flag:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Legacy</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>The default option for <literal>--import-mode</literal>. When specified, the manifest list is discarded, and a single sub-manifest is imported. The platform is chosen in the following order of priority:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Tag annotations</simpara>
</listitem>
<listitem>
<simpara>Control plane architecture</simpara>
</listitem>
<listitem>
<simpara>Linux/AMD64</simpara>
</listitem>
<listitem>
<simpara>The first manifest in the list</simpara>
</listitem>
</orderedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">PreserveOriginal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>When specified, the original manifest is preserved. For manifest lists, the manifest list and all of its sub-manifests are imported.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</chapter>
<chapter xml:id="using-imagestreams-with-kube-resources">
<title>Using image streams with Kubernetes resources</title>

<simpara>Image streams, being OpenShift Container Platform native resources, work with all native resources available in OpenShift Container Platform, such as <literal>Build</literal> or <literal>DeploymentConfigs</literal> resources. It is also possible to make them work with native Kubernetes resources, such as <literal>Job</literal>, <literal>ReplicationController</literal>, <literal>ReplicaSet</literal> or Kubernetes <literal>Deployment</literal> resources.</simpara>
<section xml:id="images-managing-images-enabling-imagestreams-kube_using-imagestreams-with-kube-resources">
<title>Enabling image streams with Kubernetes resources</title>
<simpara>When using image streams with Kubernetes resources, you can only reference image streams that reside in the same project as the resource. The image stream reference must consist of a single segment value, for example <literal>ruby:2.5</literal>, where <literal>ruby</literal> is the name of an image stream that has a tag named <literal>2.5</literal> and resides in the same project as the resource making the reference.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<simpara>There are two ways to enable image streams with Kubernetes resources:</simpara>
<itemizedlist>
<listitem>
<simpara>Enabling image stream resolution on a specific resource. This allows only this resource to use the image stream name in the image field.</simpara>
</listitem>
<listitem>
<simpara>Enabling image stream resolution on an image stream. This allows all resources pointing to this image stream to use it in the image field.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>You can use <literal>oc set image-lookup</literal> to enable image stream resolution on a specific resource or image stream resolution on an image stream.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To allow all resources to reference the image stream named <literal>mysql</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set image-lookup mysql</programlisting>
<simpara>This sets the <literal>Imagestream.spec.lookupPolicy.local</literal> field to true.</simpara>
<formalpara>
<title>Imagestream with image lookup enabled</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: image.openshift.io/v1
kind: ImageStream
metadata:
  annotations:
    openshift.io/display-name: mysql
  name: mysql
  namespace: myproject
spec:
  lookupPolicy:
    local: true</programlisting>
</para>
</formalpara>
<simpara>When enabled, the behavior is enabled for all tags within the image stream.</simpara>
</listitem>
<listitem>
<simpara>Then you can query the image streams and see if the option is set:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set image-lookup imagestream --list</programlisting>
</listitem>
</orderedlist>
<simpara>You can enable image lookup on a specific resource.</simpara>
<itemizedlist>
<listitem>
<simpara>To allow the Kubernetes deployment named <literal>mysql</literal> to use image streams, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set image-lookup deploy/mysql</programlisting>
<simpara>This sets the <literal>alpha.image.policy.openshift.io/resolve-names</literal> annotation
on the deployment.</simpara>
<formalpara>
<title>Deployment with image lookup enabled</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql
  namespace: myproject
spec:
  replicas: 1
  template:
    metadata:
      annotations:
        alpha.image.policy.openshift.io/resolve-names: '*'
    spec:
      containers:
      - image: mysql:latest
        imagePullPolicy: Always
        name: mysql</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<simpara>You can disable image lookup.</simpara>
<itemizedlist>
<listitem>
<simpara>To disable image lookup, pass <literal>--enabled=false</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set image-lookup deploy/mysql --enabled=false</programlisting>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="triggering-updates-on-imagestream-changes">
<title>Triggering updates on image stream changes</title>

<simpara>When an image stream tag is updated to point to a new image, OpenShift Container Platform can automatically take action to roll the new image out to resources that were using the old image. You configure this behavior in different ways depending on the type of resource that references the image stream tag.</simpara>
<section xml:id="openshift-resources">
<title>OpenShift Container Platform resources</title>
<simpara>OpenShift Container Platform deployment configurations and build configurations can be automatically triggered by changes to image stream tags. The triggered action can be run using the new value of the image referenced by the updated image stream tag.</simpara>
</section>
<section xml:id="images-triggering-updates-imagestream-changes-kubernetes-about_triggering-updates-on-imagestream-changes">
<title>Triggering Kubernetes resources</title>
<simpara>Kubernetes resources do not have fields for triggering, unlike deployment and build configurations, which include as part of their API definition a set of fields for controlling triggers. Instead, you can use annotations in OpenShift Container Platform to request triggering.</simpara>
<simpara>The annotation is defined as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  annotations:
    image.openshift.io/triggers:
      [
       {
         "from": {
           "kind": "ImageStreamTag", <co xml:id="CO11-1"/>
           "name": "example:latest", <co xml:id="CO11-2"/>
           "namespace": "myapp" <co xml:id="CO11-3"/>
         },
         "fieldPath": "spec.template.spec.containers[?(@.name==\"web\")].image", <co xml:id="CO11-4"/>
         "paused": false <co xml:id="CO11-5"/>
       },
      # ...
      ]
# ...</programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Required: <literal>kind</literal> is the resource to trigger from must be <literal>ImageStreamTag</literal>.</para>
</callout>
<callout arearefs="CO11-2">
<para>Required: <literal>name</literal> must be the name of an image stream tag.</para>
</callout>
<callout arearefs="CO11-3">
<para>Optional: <literal>namespace</literal> defaults to the namespace of the object.</para>
</callout>
<callout arearefs="CO11-4">
<para>Required: <literal>fieldPath</literal> is the JSON path to change. This field is limited and accepts only a JSON path expression that precisely matches a container by ID or index. For pods, the JSON path is <literal>spec.containers[?(@.name='web')].image</literal>.</para>
</callout>
<callout arearefs="CO11-5">
<para>Optional: <literal>paused</literal> is whether or not the trigger is paused, and the default value is <literal>false</literal>. Set <literal>paused</literal> to <literal>true</literal> to temporarily disable this trigger.</para>
</callout>
</calloutlist>
<simpara>When one of the core Kubernetes resources contains both a pod template and this annotation, OpenShift Container Platform attempts to update the object by using the image currently associated with the image stream tag that is referenced by trigger. The update is performed against the <literal>fieldPath</literal> specified.</simpara>
<simpara>Examples of core Kubernetes resources that can contain both a pod template and annotation include:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>CronJobs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Deployments</literal></simpara>
</listitem>
<listitem>
<simpara><literal>StatefulSets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DaemonSets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Jobs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ReplicationControllers</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Pods</literal></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-triggering-updates-imagestream-changes-kubernetes-cli_triggering-updates-on-imagestream-changes">
<title>Setting the image trigger on Kubernetes resources</title>
<simpara>When adding an image trigger to deployments, you can use the <literal>oc set triggers</literal> command. For example, the sample command in this procedure adds an image change trigger to the deployment named <literal>example</literal> so that when the <literal>example:latest</literal> image stream tag is updated, the <literal>web</literal> container inside the deployment updates with the new image value. This command sets the correct <literal>image.openshift.io/triggers</literal> annotation on the deployment resource.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Trigger Kubernetes resources by entering the <literal>oc set triggers</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc set triggers deploy/example --from-image=example:latest -c web</programlisting>
<formalpara>
<title>Example deployment with trigger annotation</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    image.openshift.io/triggers: '[{"from":{"kind":"ImageStreamTag","name":"example:latest"},"fieldPath":"spec.template.spec.containers[?(@.name==\"container\")].image"}]'
# ...</programlisting>
</para>
</formalpara>
<simpara>Unless the deployment is paused, this pod template update automatically causes a deployment to occur with the new image value.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="image-configuration">
<title>Image configuration resources</title>

<simpara>Use the following procedure to configure image registries.</simpara>
<section xml:id="images-configuration-parameters_image-configuration">
<title>Image controller configuration parameters</title>
<simpara>The <literal>image.config.openshift.io/cluster</literal> resource holds cluster-wide information about how to handle images. The canonical, and only valid name is <literal>cluster</literal>. Its <literal>spec</literal> offers the following configuration parameters.</simpara>
<note>
<simpara>Parameters such as <literal>DisableScheduledImport</literal>, <literal>MaxImagesBulkImportedPerRepository</literal>, <literal>MaxScheduledImportsPerMinute</literal>, <literal>ScheduledImageImportMinimumIntervalSeconds</literal>, <literal>InternalRegistryHostname</literal> are not configurable.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>allowedRegistriesForImport</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Limits the container image registries from which normal users can import images. Set this list to the registries that you trust to contain valid images, and that you want applications to be able to import from. Users with permission to create images or <literal>ImageStreamMappings</literal> from the API are not affected by this policy. Typically only cluster administrators have the appropriate permissions.</simpara>
<simpara>Every element of this list contains a location of the registry specified by the registry domain name.</simpara>
<simpara><literal>domainName</literal>: Specifies a domain name for the registry. If the registry uses a non-standard <literal>80</literal> or <literal>443</literal> port, the port should be included in the domain name as well.</simpara>
<simpara><literal>insecure</literal>: Insecure indicates whether the registry is secure or insecure. By default, if not otherwise specified, the registry is assumed to be secure.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>additionalTrustedCA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A reference to a config map containing additional CAs that should be trusted during <literal>image stream import</literal>, <literal>pod image pull</literal>, <literal>openshift-image-registry pullthrough</literal>, and builds.</simpara>
<simpara>The namespace for this config map is <literal>openshift-config</literal>. The format of the config map is to use the registry hostname as the key, and the PEM-encoded certificate as the value, for each additional registry CA to trust.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>externalRegistryHostnames</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides the hostnames for the default external image registry. The external hostname should be set only when the image registry is exposed externally. The first value is used in <literal>publicDockerImageRepository</literal> field in image streams. The value must be in <literal>hostname[:port]</literal> format.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>registrySources</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Contains configuration that determines how the container runtime should treat individual registries when accessing images for builds and
pods. For instance, whether or not to allow insecure access. It does not contain configuration for the internal cluster registry.</simpara>
<simpara><literal>insecureRegistries</literal>: Registries which do not have a valid TLS certificate or only support HTTP connections. To specify all subdomains, add the asterisk (<literal>*</literal>) wildcard character as a prefix to the domain name. For example, <literal>*.example.com</literal>. You can specify an individual repository within a registry. For example: <literal>reg1.io/myrepo/myapp:latest</literal>.</simpara>
<simpara><literal>blockedRegistries</literal>: Registries for which image pull and push actions are denied. To specify all subdomains, add the asterisk (<literal>*</literal>) wildcard character as a prefix to the domain name. For example, <literal>*.example.com</literal>. You can specify an individual repository within a registry. For example: <literal>reg1.io/myrepo/myapp:latest</literal>. All other registries are allowed.</simpara>
<simpara><literal>allowedRegistries</literal>: Registries for which image pull and push actions are allowed. To specify all subdomains, add the asterisk (<literal>*</literal>) wildcard character as a prefix to the domain name. For example, <literal>*.example.com</literal>. You can specify an individual repository within a registry. For example: <literal>reg1.io/myrepo/myapp:latest</literal>. All other registries are blocked.</simpara>
<simpara><literal>containerRuntimeSearchRegistries</literal>: Registries for which image pull and push actions are allowed using image short names. All other registries are blocked.</simpara>
<simpara>Either <literal>blockedRegistries</literal> or <literal>allowedRegistries</literal> can be set, but not both.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<warning>
<simpara>When the <literal>allowedRegistries</literal> parameter is defined, all registries, including <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the default OpenShift image registry, are blocked unless explicitly listed. When using the parameter, to prevent pod failure, add all registries including the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the <literal>internalRegistryHostname</literal> to the <literal>allowedRegistries</literal> list, as they are required by payload images within your environment. For disconnected clusters, mirror registries should also be added.</simpara>
</warning>
<simpara>The <literal>status</literal> field of the <literal>image.config.openshift.io/cluster</literal> resource holds observed values from the cluster.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="27.2727*"/>
<colspec colname="col_2" colwidth="72.7273*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>internalRegistryHostname</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set by the Image Registry Operator, which controls the <literal>internalRegistryHostname</literal>. It sets the hostname for the default OpenShift image registry. The value must be in <literal>hostname[:port]</literal> format. For backward compatibility, you can still use the <literal>OPENSHIFT_DEFAULT_REGISTRY</literal> environment variable, but this setting overrides the environment variable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>externalRegistryHostnames</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set by the Image Registry Operator, provides the external hostnames for the image registry when it is exposed externally. The first value is used in <literal>publicDockerImageRepository</literal> field in image streams. The values must be in <literal>hostname[:port]</literal> format.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="images-configuration-file_image-configuration">
<title>Configuring image registry settings</title>
<simpara>You can configure image registry settings by editing the <literal>image.config.openshift.io/cluster</literal> custom resource (CR).
When changes to the registry are applied to the <literal>image.config.openshift.io/cluster</literal> CR, the Machine Config Operator (MCO) performs the following sequential actions:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Cordons the node</simpara>
</listitem>
<listitem>
<simpara>Applies changes by restarting CRI-O</simpara>
</listitem>
<listitem>
<simpara>Uncordons the node</simpara>
<note>
<simpara>The MCO does not restart nodes when it detects changes.</simpara>
</note>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>image.config.openshift.io/cluster</literal> custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>image.config.openshift.io/cluster</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image <co xml:id="CO12-1"/>
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  allowedRegistriesForImport: <co xml:id="CO12-2"/>
    - domainName: quay.io
      insecure: false
  additionalTrustedCA: <co xml:id="CO12-3"/>
    name: myconfigmap
  registrySources: <co xml:id="CO12-4"/>
    allowedRegistries:
    - example.com
    - quay.io
    - registry.redhat.io
    - image-registry.openshift-image-registry.svc:5000
    - reg1.io/myrepo/myapp:latest
    insecureRegistries:
    - insecure.com
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para><literal>Image</literal>: Holds cluster-wide information about how to handle images. The canonical, and only valid name is <literal>cluster</literal>.</para>
</callout>
<callout arearefs="CO12-2">
<para><literal>allowedRegistriesForImport</literal>: Limits the container image registries from which normal users may import images. Set this list to the registries that you trust to contain valid images, and that you want applications to be able to import from. Users with permission to create images or <literal>ImageStreamMappings</literal> from the API are not affected by this policy. Typically only cluster administrators have the appropriate permissions.</para>
</callout>
<callout arearefs="CO12-3">
<para><literal>additionalTrustedCA</literal>: A reference to a config map containing additional certificate authorities (CA) that are trusted during image stream import, pod image pull, <literal>openshift-image-registry</literal> pullthrough, and builds. The namespace for this config map is <literal>openshift-config</literal>. The format of the config map is to use the registry hostname as the key, and the PEM certificate as the value, for each additional registry CA to trust.</para>
</callout>
<callout arearefs="CO12-4">
<para><literal>registrySources</literal>: Contains configuration that determines whether the container runtime allows or blocks individual registries when accessing images for builds and pods.  Either the <literal>allowedRegistries</literal> parameter or the <literal>blockedRegistries</literal> parameter can be set, but not both. You can also define whether or not to allow access to insecure registries or registries that allow registries that use image short names. This example uses the <literal>allowedRegistries</literal> parameter, which defines the registries that are allowed to be used. The insecure registry <literal>insecure.com</literal> is also allowed. The <literal>registrySources</literal> parameter does not contain configuration for the internal cluster registry.</para>
</callout>
</calloutlist>
<note>
<simpara>When the <literal>allowedRegistries</literal> parameter is defined, all registries, including the registry.redhat.io and quay.io registries and the default OpenShift image registry, are blocked unless explicitly listed. If you use the parameter, to prevent pod failure, you must add the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the <literal>internalRegistryHostname</literal> to the <literal>allowedRegistries</literal> list, as they are required by payload images within your environment. Do not add the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries to the <literal>blockedRegistries</literal> list.</simpara>
<simpara>When using the <literal>allowedRegistries</literal>, <literal>blockedRegistries</literal>, or <literal>insecureRegistries</literal> parameter, you can specify an individual repository within a registry. For example: <literal>reg1.io/myrepo/myapp:latest</literal>.</simpara>
<simpara>Insecure external registries should be avoided to reduce possible security risks.</simpara>
</note>
</listitem>
<listitem>
<simpara>To check that the changes are applied, list your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         STATUS                     ROLES                  AGE   VERSION
ip-10-0-137-182.us-east-2.compute.internal   Ready,SchedulingDisabled   worker                 65m   v1.28.5
ip-10-0-139-120.us-east-2.compute.internal   Ready,SchedulingDisabled   control-plane          74m   v1.28.5
ip-10-0-176-102.us-east-2.compute.internal   Ready                      control-plane          75m   v1.28.5
ip-10-0-188-96.us-east-2.compute.internal    Ready                      worker                 65m   v1.28.5
ip-10-0-200-59.us-east-2.compute.internal    Ready                      worker                 63m   v1.28.5
ip-10-0-223-123.us-east-2.compute.internal   Ready                      control-plane          73m   v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="images-configuration-allowed_image-configuration">
<title>Adding specific registries</title>
<simpara>You can add a list of registries, and optionally an individual repository within a registry, that are permitted for image pull and push actions by editing the <literal>image.config.openshift.io/cluster</literal> custom resource (CR). OpenShift Container Platform applies the changes to this CR to all nodes in the cluster.</simpara>
<simpara>When pulling or pushing images, the container runtime searches the registries listed under the <literal>registrySources</literal> parameter in the <literal>image.config.openshift.io/cluster</literal> CR. If you created a list of registries under the <literal>allowedRegistries</literal> parameter, the container runtime searches only those registries. Registries not in the list are blocked.</simpara>
<warning>
<simpara>When the <literal>allowedRegistries</literal> parameter is defined, all registries, including the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the default OpenShift image registry, are blocked unless explicitly listed. If you use the parameter, to prevent pod failure, add the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the <literal>internalRegistryHostname</literal> to the <literal>allowedRegistries</literal> list, as they are required by payload images within your environment. For disconnected clusters, mirror registries should also be added.</simpara>
</warning>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>image.config.openshift.io/cluster</literal> custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>image.config.openshift.io/cluster</literal> CR with an allowed list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  registrySources: <co xml:id="CO13-1"/>
    allowedRegistries: <co xml:id="CO13-2"/>
    - example.com
    - quay.io
    - registry.redhat.io
    - reg1.io/myrepo/myapp:latest
    - image-registry.openshift-image-registry.svc:5000
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Contains configurations that determine how the container runtime should treat individual registries when accessing images for builds and pods. It does not contain configuration for the internal cluster registry.</para>
</callout>
<callout arearefs="CO13-2">
<para>Specify registries, and optionally a repository in that registry, to use for image pull and push actions. All other registries are blocked.</para>
</callout>
</calloutlist>
<note>
<simpara>Either the <literal>allowedRegistries</literal> parameter or the <literal>blockedRegistries</literal> parameter can be set, but not both.</simpara>
</note>
<simpara>The Machine Config Operator (MCO) watches the <literal>image.config.openshift.io/cluster</literal> resource for any changes to the registries. When the MCO detects a change, it drains the nodes, applies the change, and uncordons the nodes. After the nodes return to the <literal>Ready</literal> state, the allowed registries list is used to update the image signature policy in the <literal>/etc/containers/policy.json</literal> file on each node.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the following command to obtain a list of your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<simpara>Example output</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME               STATUS   ROLES                  AGE   VERSION
&lt;node_name&gt;        Ready    control-plane,master   37m   v1.27.8+4fab27b</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the following command to enter debug mode on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>When prompted, enter <literal>chroot /host</literal> into the terminal:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command to check that the registries have been added to the policy file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-5.1# cat /etc/containers/policy.json | jq '.'</programlisting>
<simpara>The following policy indicates that only images from the example.com, quay.io, and registry.redhat.io registries are permitted for image pulls and pushes:</simpara>
<example>
<title>Example image signature policy file</title>
<programlisting language="text" linenumbering="unnumbered">{
   "default":[
      {
         "type":"reject"
      }
   ],
   "transports":{
      "atomic":{
         "example.com":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "image-registry.openshift-image-registry.svc:5000":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "insecure.com":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "quay.io":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "reg4.io/myrepo/myapp:latest":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "registry.redhat.io":[
            {
               "type":"insecureAcceptAnything"
            }
         ]
      },
      "docker":{
         "example.com":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "image-registry.openshift-image-registry.svc:5000":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "insecure.com":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "quay.io":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "reg4.io/myrepo/myapp:latest":[
            {
               "type":"insecureAcceptAnything"
            }
         ],
         "registry.redhat.io":[
            {
               "type":"insecureAcceptAnything"
            }
         ]
      },
      "docker-daemon":{
         "":[
            {
               "type":"insecureAcceptAnything"
            }
         ]
      }
   }
}</programlisting>
</example>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<note>
<simpara>If your cluster uses the <literal>registrySources.insecureRegistries</literal> parameter, ensure that any insecure registries are included in the allowed list.</simpara>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  registrySources:
    insecureRegistries:
    - insecure.com
    allowedRegistries:
    - example.com
    - quay.io
    - registry.redhat.io
    - insecure.com
    - image-registry.openshift-image-registry.svc:5000</programlisting>
</note>
</section>
<section xml:id="images-configuration-blocked_image-configuration">
<title>Blocking specific registries</title>
<simpara>You can block any registry, and optionally an individual repository within a registry, by editing the <literal>image.config.openshift.io/cluster</literal> custom resource (CR). OpenShift Container Platform applies the changes to this CR to all nodes in the cluster.</simpara>
<simpara>When pulling or pushing images, the container runtime searches the registries listed under the <literal>registrySources</literal> parameter in the <literal>image.config.openshift.io/cluster</literal> CR. If you created a list of registries under the <literal>blockedRegistries</literal> parameter, the container runtime does not search those registries. All other registries are allowed.</simpara>
<warning>
<simpara>To prevent pod failure, do not add the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries to the <literal>blockedRegistries</literal> list, as they are required by payload images within your environment.</simpara>
</warning>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>image.config.openshift.io/cluster</literal> custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>image.config.openshift.io/cluster</literal> CR with a blocked list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  registrySources: <co xml:id="CO14-1"/>
    blockedRegistries: <co xml:id="CO14-2"/>
    - untrusted.com
    - reg1.io/myrepo/myapp:latest
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Contains configurations that determine how the container runtime should treat individual registries when accessing images for builds and pods. It does not contain configuration for the internal cluster registry.</para>
</callout>
<callout arearefs="CO14-2">
<para>Specify registries, and optionally a repository in that registry, that should not be used for image pull and push actions. All other registries are allowed.</para>
</callout>
</calloutlist>
<note>
<simpara>Either the <literal>blockedRegistries</literal> registry or the <literal>allowedRegistries</literal> registry can be set, but not both.</simpara>
</note>
<simpara>The Machine Config Operator (MCO) watches the <literal>image.config.openshift.io/cluster</literal> resource for any changes to the registries. When the MCO detects a change, it drains the nodes, applies the change, and uncordons the nodes. After the nodes return to the <literal>Ready</literal> state, changes to the blocked registries appear in the <literal>/etc/containers/registries.conf</literal> file on each node.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the following command to obtain a list of your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<simpara>Example output</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                STATUS   ROLES                  AGE   VERSION
&lt;node_name&gt;         Ready    control-plane,master   37m   v1.27.8+4fab27b</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the following command to enter debug mode on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>When prompted, enter <literal>chroot /host</literal> into the terminal:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command to check that the registries have been added to the policy file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-5.1# cat etc/containers/registries.conf</programlisting>
<simpara>The following example indicates that images from the <literal>untrusted.com</literal> registry are prevented for image pulls and pushes:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]

[[registry]]
  prefix = ""
  location = "untrusted.com"
  blocked = true</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<section xml:id="images-configuration-blocked-payload">
<title>Blocking a payload registry</title>
<simpara>In a mirroring configuration, you can block upstream payload registries in a disconnected environment using a <literal>ImageContentSourcePolicy</literal> (ICSP) object. The following example procedure demonstrates how to block the <literal>quay.io/openshift-payload</literal> payload registry.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the mirror configuration using an <literal>ImageContentSourcePolicy</literal> (ICSP) object to mirror the payload to a registry in your instance. The following example ICSP file mirrors the payload <literal>internal-mirror.io/openshift-payload</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: my-icsp
spec:
  repositoryDigestMirrors:
  - mirrors:
    - internal-mirror.io/openshift-payload
    source: quay.io/openshift-payload</programlisting>
</listitem>
<listitem>
<simpara>After the object deploys onto your nodes, verify that the mirror configuration is set by checking the <literal>/etc/containers/registries.conf</literal> file:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[[registry]]
  prefix = ""
  location = "quay.io/openshift-payload"
  mirror-by-digest-only = true

[[registry.mirror]]
  location = "internal-mirror.io/openshift-payload"</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Use the following command to edit the <literal>image.config.openshift.io</literal> custom resource file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>To block the payload registry, add the following configuration to the <literal>image.config.openshift.io</literal> custom resource file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  registrySource:
    blockedRegistries:
     - quay.io/openshift-payload</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the upstream payload registry is blocked by checking the <literal>/etc/containers/registries.conf</literal> file on the node.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">[[registry]]
  prefix = ""
  location = "quay.io/openshift-payload"
  blocked = true
  mirror-by-digest-only = true

[[registry.mirror]]
  location = "internal-mirror.io/openshift-payload"</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-configuration-insecure_image-configuration">
<title>Allowing insecure registries</title>
<simpara>You can add insecure registries, and optionally an individual repository within a registry, by editing the <literal>image.config.openshift.io/cluster</literal> custom resource (CR). OpenShift Container Platform applies the changes to this CR to all nodes in the cluster.</simpara>
<simpara>Registries that do not use valid SSL certificates or do not require HTTPS connections are considered insecure.</simpara>
<warning>
<simpara>Insecure external registries should be avoided to reduce possible security risks.</simpara>
</warning>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>image.config.openshift.io/cluster</literal> custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>image.config.openshift.io/cluster</literal> CR with an insecure registries list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  registrySources: <co xml:id="CO15-1"/>
    insecureRegistries: <co xml:id="CO15-2"/>
    - insecure.com
    - reg4.io/myrepo/myapp:latest
    allowedRegistries:
    - example.com
    - quay.io
    - registry.redhat.io
    - insecure.com <co xml:id="CO15-3"/>
    - reg4.io/myrepo/myapp:latest
    - image-registry.openshift-image-registry.svc:5000
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>Contains configurations that determine how the container runtime should treat individual registries when accessing images for builds and pods. It does not contain configuration for the internal cluster registry.</para>
</callout>
<callout arearefs="CO15-2">
<para>Specify an insecure registry. You can specify a repository in that registry.</para>
</callout>
<callout arearefs="CO15-3">
<para>Ensure that any insecure registries are included in the <literal>allowedRegistries</literal> list.</para>
</callout>
</calloutlist>
<note>
<simpara>When the <literal>allowedRegistries</literal> parameter is defined, all registries, including the registry.redhat.io and quay.io registries and the default OpenShift image registry, are blocked unless explicitly listed. If you use the parameter, to prevent pod failure, add all registries including the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the <literal>internalRegistryHostname</literal> to the <literal>allowedRegistries</literal> list, as they are required by payload images within your environment. For disconnected clusters, mirror registries should also be added.</simpara>
</note>
<simpara>The Machine Config Operator (MCO) watches the <literal>image.config.openshift.io/cluster</literal> CR for any changes to the registries, then drains and uncordons the nodes when it detects changes. After the nodes return to the <literal>Ready</literal> state, changes to the insecure and blocked registries appear in the <literal>/etc/containers/registries.conf</literal> file on each node.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>To check that the registries have been added to the policy file, use the following command on a node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /etc/containers/registries.conf</programlisting>
<simpara>The following example indicates that images from the <literal>insecure.com</literal> registry is insecure and is allowed for image pulls and pushes.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]

[[registry]]
  prefix = ""
  location = "insecure.com"
  insecure = true</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-configuration-shortname_image-configuration">
<title>Adding registries that allow image short names</title>
<simpara>You can add registries to search for an image short name by editing the <literal>image.config.openshift.io/cluster</literal> custom resource (CR). OpenShift Container Platform applies the changes to this CR to all nodes in the cluster.</simpara>
<simpara>An image short name enables you to search for images without including the fully qualified domain name in the pull spec. For example, you could use <literal>rhel7/etcd</literal> instead of <literal>registry.access.redhat.com/rhe7/etcd</literal>.</simpara>
<simpara>You might use short names in situations where using the full path is not practical. For example, if your cluster references multiple internal registries whose DNS changes frequently, you would need to update the fully qualified domain names in your pull specs with each change. In this case, using an image short name might be beneficial.</simpara>
<simpara>When pulling or pushing images, the container runtime searches the registries listed under the <literal>registrySources</literal> parameter in the <literal>image.config.openshift.io/cluster</literal> CR. If you created a list of registries under the <literal>containerRuntimeSearchRegistries</literal> parameter, when pulling an image with a short name, the container runtime searches those registries.</simpara>
<warning>
<simpara>Using image short names with public registries is strongly discouraged because the image might not deploy if the public registry requires authentication. Use fully-qualified image names with public registries.</simpara>
<simpara>Red Hat internal or private registries typically support the use of image short names.</simpara>
<simpara>If you list public registries under the <literal>containerRuntimeSearchRegistries</literal> parameter, you expose your credentials to all the registries on the list and you risk network and registry attacks.</simpara>
<simpara>You cannot list multiple public registries under the <literal>containerRuntimeSearchRegistries</literal> parameter if each public registry requires different credentials and a cluster does not list the public registry in the global pull secret.</simpara>
<simpara>For a public registry that requires authentication, you can use an image short name only if the registry has its credentials stored in the global pull secret.</simpara>
</warning>
<simpara>The Machine Config Operator (MCO) watches the <literal>image.config.openshift.io/cluster</literal> resource for any changes to the registries. When the MCO detects a change, it drains the nodes, applies the change, and uncordons the nodes. After the nodes return to the <literal>Ready</literal> state, if the <literal>containerRuntimeSearchRegistries</literal> parameter is added, the MCO creates a file in the <literal>/etc/containers/registries.conf.d</literal> directory on each node with the listed registries. The file overrides the default list of unqualified search registries in the <literal>/etc/containers/registries.conf</literal> file. There is no way to fall back to the default list of unqualified search registries.</simpara>
<simpara>The <literal>containerRuntimeSearchRegistries</literal> parameter works only with the Podman and CRI-O container engines. The registries in the list can be used only in pod specs, not in builds and image streams.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>image.config.openshift.io/cluster</literal> custom resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io/cluster</programlisting>
<simpara>The following is an example <literal>image.config.openshift.io/cluster</literal> CR:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Image
metadata:
  annotations:
    release.openshift.io/create-only: "true"
  creationTimestamp: "2019-05-17T13:44:26Z"
  generation: 1
  name: cluster
  resourceVersion: "8302"
  selfLink: /apis/config.openshift.io/v1/images/cluster
  uid: e34555da-78a9-11e9-b92b-06d6c7da38dc
spec:
  allowedRegistriesForImport:
    - domainName: quay.io
      insecure: false
  additionalTrustedCA:
    name: myconfigmap
  registrySources:
    containerRuntimeSearchRegistries: <co xml:id="CO16-1"/>
    - reg1.io
    - reg2.io
    - reg3.io
    allowedRegistries: <co xml:id="CO16-2"/>
    - example.com
    - quay.io
    - registry.redhat.io
    - reg1.io
    - reg2.io
    - reg3.io
    - image-registry.openshift-image-registry.svc:5000
...
status:
  internalRegistryHostname: image-registry.openshift-image-registry.svc:5000</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>Specify registries to use with image short names. You should use image short names with only internal or private registries to reduce possible security risks.</para>
</callout>
<callout arearefs="CO16-2">
<para>Ensure that any registries listed under <literal>containerRuntimeSearchRegistries</literal> are included in the <literal>allowedRegistries</literal> list.</para>
</callout>
</calloutlist>
<note>
<simpara>When the <literal>allowedRegistries</literal> parameter is defined, all registries, including the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the default OpenShift image registry, are blocked unless explicitly listed. If you use this parameter, to prevent pod failure, add all registries including the <literal>registry.redhat.io</literal> and <literal>quay.io</literal> registries and the <literal>internalRegistryHostname</literal> to the <literal>allowedRegistries</literal> list, as they are required by payload images within your environment. For disconnected clusters, mirror registries should also be added.</simpara>
</note>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Enter the following command to obtain a list of your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get nodes</programlisting>
<simpara>Example output</simpara>
<programlisting language="terminal" linenumbering="unnumbered">NAME                STATUS   ROLES                  AGE   VERSION
&lt;node_name&gt;         Ready    control-plane,master   37m   v1.27.8+4fab27b</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run the following command to enter debug mode on the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>When prompted, enter <literal>chroot /host</literal> into the terminal:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.4# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Enter the following command to check that the registries have been added to the policy file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-5.1# cat /etc/containers/registries.conf.d/01-image-searchRegistries.conf</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">unqualified-search-registries = ['reg1.io', 'reg2.io', 'reg3.io']</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-configuration-cas_image-configuration">
<title>Configuring additional trust stores for image registry access</title>
<simpara>The <literal>image.config.openshift.io/cluster</literal> custom resource can contain a reference to a config map that contains additional certificate authorities to be trusted during image registry access.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The certificate authorities (CA) must be PEM-encoded.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>You can create a config map in the <literal>openshift-config</literal> namespace and use its name in <literal>AdditionalTrustedCA</literal> in the <literal>image.config.openshift.io</literal> custom resource to provide additional CAs that should be trusted when contacting external registries.</para>
</formalpara>
<simpara>The config map key is the hostname of a registry with the port for which this CA is to be trusted, and the PEM certificate content is the value, for each additional registry CA to trust.</simpara>
<formalpara>
<title>Image registry CA config map example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: my-registry-ca
data:
  registry.example.com: |
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----
  registry-with-port.example.com..5000: | <co xml:id="CO17-1"/>
    -----BEGIN CERTIFICATE-----
    ...
    -----END CERTIFICATE-----</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>If the registry has the port, such as <literal>registry-with-port.example.com:5000</literal>, <literal>:</literal> should be replaced with <literal>..</literal>.</para>
</callout>
</calloutlist>
<simpara>You can configure additional CAs with the following procedure.</simpara>
<itemizedlist>
<listitem>
<simpara>To configure an additional CA:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap registry-config --from-file=&lt;external_registry_address&gt;=ca.crt -n openshift-config</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit image.config.openshift.io cluster</programlisting>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  additionalTrustedCA:
    name: registry-config</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="images-configuration-registry-mirror_image-configuration">
<title>Understanding image registry repository mirroring</title>
<simpara>Setting up container registry repository mirroring enables you to perform the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Configure your OpenShift Container Platform cluster to redirect requests to pull images from a repository on a source image registry and have it resolved by a repository on a mirrored image registry.</simpara>
</listitem>
<listitem>
<simpara>Identify multiple mirrored repositories for each target repository, to make sure that if one mirror is down, another can be used.</simpara>
</listitem>
</itemizedlist>
<simpara>Repository mirroring in OpenShift Container Platform includes the following attributes:</simpara>
<itemizedlist>
<listitem>
<simpara>Image pulls are resilient to registry downtimes.</simpara>
</listitem>
<listitem>
<simpara>Clusters in disconnected environments can pull images from critical locations, such as quay.io, and have registries behind a company firewall provide the requested images.</simpara>
</listitem>
<listitem>
<simpara>A particular order of registries is tried when an image pull request is made, with the permanent registry typically being the last one tried.</simpara>
</listitem>
<listitem>
<simpara>The mirror information you enter is added to the <literal>/etc/containers/registries.conf</literal> file on every node in the OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>When a node makes a request for an image from the source repository, it tries each mirrored repository in turn until it finds the requested content. If all mirrors fail, the cluster tries the source repository. If successful, the image is pulled to the node.</simpara>
</listitem>
</itemizedlist>
<simpara>Setting up repository mirroring can be done in the following ways:</simpara>
<itemizedlist>
<listitem>
<simpara>At OpenShift Container Platform installation:</simpara>
<simpara>By pulling container images needed by OpenShift Container Platform and then bringing those images behind your company&#8217;s firewall, you can install OpenShift Container Platform into a datacenter that is in a disconnected environment.</simpara>
</listitem>
<listitem>
<simpara>After OpenShift Container Platform installation:</simpara>
<simpara>If you did not configure mirroring during OpenShift Container Platform installation, you can do so postinstallation by using any of the following custom resource (CR) objects:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ImageDigestMirrorSet</literal> (IDMS). This object allows you to pull images from a mirrored registry by using digest specifications. The IDMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageTagMirrorSet</literal> (ITMS). This object allows you to pull images from a mirrored registry by using image tags. The ITMS CR enables you to set a fall back policy that allows or stops continued attempts to pull from the source registry if the image pull fails.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageContentSourcePolicy</literal> (ICSP). This object allows you to pull images from a mirrored registry by using digest specifications. The ICSP CR always falls back to the source registry if the mirrors do not work.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Using an <literal>ImageContentSourcePolicy</literal> (ICSP) object to configure repository mirroring is a deprecated feature. Deprecated functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments. If you have existing YAML files that you used to create <literal>ImageContentSourcePolicy</literal> objects, you can use the <literal>oc adm migrate icsp</literal> command to convert those files to an <literal>ImageDigestMirrorSet</literal> YAML file. For more information, see "Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring" in the following section.</simpara>
</important>
</listitem>
</itemizedlist>
<simpara>Each of these custom resource objects identify the following information:</simpara>
<itemizedlist>
<listitem>
<simpara>The source of the container image repository you want to mirror.</simpara>
</listitem>
<listitem>
<simpara>A separate entry for each mirror repository you want to offer the content
requested from the source repository.</simpara>
</listitem>
</itemizedlist>
<simpara>For new clusters, you can use IDMS, ITMS, and ICSP CRs objects as desired. However, using IDMS and ITMS is recommended.</simpara>
<simpara>If you upgraded a cluster, any existing ICSP objects remain stable, and both IDMS and ICSP objects are supported. Workloads using ICSP objects continue to function as expected. However, if you want to take advantage of the fallback policies introduced in the IDMS CRs, you can migrate current workloads to IDMS objects by using the <literal>oc adm migrate icsp</literal> command as shown in the <emphasis role="strong">Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring</emphasis> section that follows. Migrating to IDMS objects does not require a cluster reboot.</simpara>
<note>
<simpara>If your cluster uses an <literal>ImageDigestMirrorSet</literal>, <literal>ImageTagMirrorSet</literal>, or <literal>ImageContentSourcePolicy</literal> object to configure repository mirroring, you can use only global pull secrets for mirrored registries. You cannot add a pull secret to a project.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about global pull secrets, see <link xlink:href="../openshift_images/managing_images/using-image-pull-secrets.xml#images-update-global-pull-secret_using-image-pull-secrets">Updating the global cluster pull secret</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="images-configuration-registry-mirror-configuring_image-configuration">
<title>Configuring image registry repository mirroring</title>
<simpara>You can create postinstallation mirror configuration custom resources (CR) to redirect image pull requests from a source image registry to a mirrored image registry.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Configure mirrored repositories, by either:</simpara>
<itemizedlist>
<listitem>
<simpara>Setting up a mirrored repository with Red Hat Quay, as described in <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_quay/3/html/manage_red_hat_quay/repo-mirroring-in-red-hat-quay">Red Hat Quay Repository Mirroring</link>. Using Red Hat Quay allows you to copy images from one repository to another and also automatically sync those repositories repeatedly over time.</simpara>
</listitem>
<listitem>
<simpara>Using a tool such as <literal>skopeo</literal> to copy images manually from the source repository to the mirrored repository.</simpara>
<simpara>For example, after installing the skopeo RPM package on a Red Hat Enterprise Linux (RHEL) 7 or RHEL 8 system, use the <literal>skopeo</literal> command as shown in this example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ skopeo copy \
docker://registry.access.redhat.com/ubi9/ubi-minimal:latest@sha256:5cf... \
docker://example.io/example/ubi-minimal</programlisting>
<simpara>In this example, you have a container image registry that is named <literal>example.io</literal> with an image repository named <literal>example</literal> to which you want to copy the <literal>ubi9/ubi-minimal</literal> image from <literal>registry.access.redhat.com</literal>. After you create the mirrored registry, you can configure your OpenShift Container Platform cluster to redirect requests made of the source repository to the mirrored repository.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Log in to your OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create a postinstallation mirror configuration CR, by using one of the following examples:</simpara>
<itemizedlist>
<listitem>
<simpara>Create an <literal>ImageDigestMirrorSet</literal> or <literal>ImageTagMirrorSet</literal> CR, as needed, replacing the source and mirrors with your own registry and repository pairs and images:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1 <co xml:id="CO18-1"/>
kind: ImageDigestMirrorSet <co xml:id="CO18-2"/>
metadata:
  name: ubi9repo
spec:
  imageDigestMirrors: <co xml:id="CO18-3"/>
  - mirrors:
    - example.io/example/ubi-minimal <co xml:id="CO18-4"/>
    - example.com/example/ubi-minimal <co xml:id="CO18-5"/>
    source: registry.access.redhat.com/ubi9/ubi-minimal <co xml:id="CO18-6"/>
    mirrorSourcePolicy: AllowContactingSource <co xml:id="CO18-7"/>
  - mirrors:
    - mirror.example.com/redhat
    source: registry.redhat.io/openshift4 <co xml:id="CO18-8"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.com
    source: registry.redhat.io <co xml:id="CO18-9"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/image
    source: registry.example.com/example/myimage <co xml:id="CO18-10"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net
    source: registry.example.com/example <co xml:id="CO18-11"/>
    mirrorSourcePolicy: AllowContactingSource
  - mirrors:
    - mirror.example.net/registry-example-com
    source: registry.example.com <co xml:id="CO18-12"/>
    mirrorSourcePolicy: AllowContactingSource</programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>Indicates the API to use with this CR. This must be <literal>config.openshift.io/v1</literal>.</para>
</callout>
<callout arearefs="CO18-2">
<para>Indicates the kind of object according to the pull type:</para>
<itemizedlist>
<listitem>
<simpara><literal>ImageDigestMirrorSet</literal>: Pulls a digest reference image.</simpara>
</listitem>
<listitem>
<simpara><literal>ImageTagMirrorSet</literal>: Pulls a tag reference image.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO18-3">
<para>Indicates the type of image pull method, either:</para>
<itemizedlist>
<listitem>
<simpara><literal>imageDigestMirrors</literal>: Use for an <literal>ImageDigestMirrorSet</literal> CR.</simpara>
</listitem>
<listitem>
<simpara><literal>imageTagMirrors</literal>: Use for an <literal>ImageTagMirrorSet</literal> CR.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO18-4">
<para>Indicates the name of the mirrored image registry and repository.</para>
</callout>
<callout arearefs="CO18-5">
<para>Optional: Indicates a secondary mirror repository for each target repository. If one mirror is down, the target repository can use another mirror.</para>
</callout>
<callout arearefs="CO18-6">
<para>Indicates the registry and repository source, which is the repository that is referred to in image pull specifications.</para>
</callout>
<callout arearefs="CO18-7">
<para>Optional: Indicates the fallback policy if the image pull fails:</para>
<itemizedlist>
<listitem>
<simpara><literal>AllowContactingSource</literal>: Allows continued attempts to pull the image from the source repository. This is the default.</simpara>
</listitem>
<listitem>
<simpara><literal>NeverContactSource</literal>: Prevents continued attempts to pull the image from the source repository.</simpara>
</listitem>
</itemizedlist>
</callout>
<callout arearefs="CO18-8">
<para>Optional: Indicates a namespace inside a registry, which allows you to use any image in that namespace. If you use a registry domain as a source, the object is applied to all repositories from the registry.</para>
</callout>
<callout arearefs="CO18-9">
<para>Optional: Indicates a registry, which allows you to use any image in that registry. If you specify a registry name, the object is applied to all repositories from a source registry to a mirror registry.</para>
</callout>
<callout arearefs="CO18-10">
<para>Pulls the image <literal>registry.example.com/example/myimage@sha256:&#8230;&#8203;</literal> from the mirror <literal>mirror.example.net/image@sha256:..</literal>.</para>
</callout>
<callout arearefs="CO18-11">
<para>Pulls the image <literal>registry.example.com/example/image@sha256:&#8230;&#8203;</literal> in the source registry namespace from the mirror <literal>mirror.example.net/image@sha256:&#8230;&#8203;</literal>.</para>
</callout>
<callout arearefs="CO18-12">
<para>Pulls the image <literal>registry.example.com/myimage@sha256</literal> from the mirror registry <literal>example.net/registry-example-com/myimage@sha256:&#8230;&#8203;</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create an <literal>ImageContentSourcePolicy</literal> custom resource, replacing the source and mirrors with your own registry and repository pairs and images:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1alpha1
kind: ImageContentSourcePolicy
metadata:
  name: mirror-ocp
spec:
  repositoryDigestMirrors:
  - mirrors:
    - mirror.registry.com:443/ocp/release <co xml:id="CO19-1"/>
    source: quay.io/openshift-release-dev/ocp-release <co xml:id="CO19-2"/>
  - mirrors:
    - mirror.registry.com:443/ocp/release
    source: quay.io/openshift-release-dev/ocp-v4.0-art-dev</programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>Specifies the name of the mirror image registry and repository.</para>
</callout>
<callout arearefs="CO19-2">
<para>Specifies the online registry and repository containing the content that is mirrored.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create the new object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f registryrepomirror.yaml</programlisting>
<simpara>After the object is created, the Machine Config Operator (MCO) drains the nodes for <literal>ImageTagMirrorSet</literal> objects only. The MCO does not drain the nodes for <literal>ImageDigestMirrorSet</literal> and <literal>ImageContentSourcePolicy</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>To check that the mirrored configuration settings are applied, do the following on one of the nodes.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>List your nodes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get node</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                           STATUS                     ROLES    AGE  VERSION
ip-10-0-137-44.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-138-148.ec2.internal   Ready                      master   11m  v1.28.5
ip-10-0-139-122.ec2.internal   Ready                      master   11m  v1.28.5
ip-10-0-147-35.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-153-12.ec2.internal    Ready                      worker   7m   v1.28.5
ip-10-0-154-10.ec2.internal    Ready                      master   11m  v1.28.5</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Start the debugging process to access the node:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/ip-10-0-147-35.ec2.internal</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Starting pod/ip-10-0-147-35ec2internal-debug ...
To use host binaries, run `chroot /host`</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Change your root directory to <literal>/host</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# chroot /host</programlisting>
</listitem>
<listitem>
<simpara>Check the <literal>/etc/containers/registries.conf</literal> file to make sure the changes were made:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# cat /etc/containers/registries.conf</programlisting>
<simpara>The following output represents a <literal>registries.conf</literal> file where postinstallation mirror configuration CRs were applied. The final two entries are marked <literal>digest-only</literal> and <literal>tag-only</literal> respectively.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">unqualified-search-registries = ["registry.access.redhat.com", "docker.io"]
short-name-mode = ""

[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal" <co xml:id="CO20-1"/>

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal" <co xml:id="CO20-2"/>
    pull-from-mirror = "digest-only" <co xml:id="CO20-3"/>

  [[registry.mirror]]
    location = "example.com/example/ubi-minimal"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com"

  [[registry.mirror]]
    location = "mirror.example.net/registry-example-com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example"

  [[registry.mirror]]
    location = "mirror.example.net"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.example.com/example/myimage"

  [[registry.mirror]]
    location = "mirror.example.net/image"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.redhat.io"

  [[registry.mirror]]
    location = "mirror.example.com"
    pull-from-mirror = "digest-only"

[[registry]]
  prefix = ""
  location = "registry.redhat.io/openshift4"

  [[registry.mirror]]
    location = "mirror.example.com/redhat"
    pull-from-mirror = "digest-only"
[[registry]]
  prefix = ""
  location = "registry.access.redhat.com/ubi9/ubi-minimal"
  blocked = true <co xml:id="CO20-4"/>

  [[registry.mirror]]
    location = "example.io/example/ubi-minimal-tag"
    pull-from-mirror = "tag-only" <co xml:id="CO20-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO20-1">
<para>Indicates the repository that is referred to in a pull spec.</para>
</callout>
<callout arearefs="CO20-2">
<para>Indicates the mirror for that repository.</para>
</callout>
<callout arearefs="CO20-3">
<para>Indicates that the image pull from the mirror is a digest reference image.</para>
</callout>
<callout arearefs="CO20-4">
<para>Indicates that the <literal>NeverContactSource</literal> parameter is set for this repository.</para>
</callout>
<callout arearefs="CO20-5">
<para>Indicates that the image pull from the mirror is a tag reference image.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Pull an image to the node from the source and check if it is resolved by the mirror.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">sh-4.2# podman pull --log-level=debug registry.access.redhat.com/ubi9/ubi-minimal@sha256:5cf...</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Troubleshooting repository mirroring</title>
<para>If the repository mirroring procedure does not work as described, use the following information about how repository mirroring works to help troubleshoot the problem.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>The first working mirror is used to supply the pulled image.</simpara>
</listitem>
<listitem>
<simpara>The main registry is only used if no other mirror works.</simpara>
</listitem>
<listitem>
<simpara>From the system context, the <literal>Insecure</literal> flags are used as fallback.</simpara>
</listitem>
<listitem>
<simpara>The format of the <literal>/etc/containers/registries.conf</literal> file has changed recently. It is now version 2 and in TOML format.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="images-configuration-registry-mirror-convert_image-configuration">
<title>Converting ImageContentSourcePolicy (ICSP) files for image registry repository mirroring</title>
<simpara>Using an <literal>ImageContentSourcePolicy</literal> (ICSP) object to configure repository mirroring is a deprecated feature. This functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<simpara>ICSP objects are being replaced by <literal>ImageDigestMirrorSet</literal> and <literal>ImageTagMirrorSet</literal> objects to configure repository mirroring. If you have existing YAML files that you used to create <literal>ImageContentSourcePolicy</literal> objects, you can use the <literal>oc adm migrate icsp</literal> command to convert those files to an <literal>ImageDigestMirrorSet</literal> YAML file. The command updates the API to the current version, changes the <literal>kind</literal> value to <literal>ImageDigestMirrorSet</literal>, and changes <literal>spec.repositoryDigestMirrors</literal> to <literal>spec.imageDigestMirrors</literal>. The rest of the file is not changed.</simpara>
<simpara>Because the migration does not change the <literal>registries.conf</literal> file, the cluster does not need to reboot.</simpara>
<simpara>For more information about <literal>ImageDigestMirrorSet</literal> or <literal>ImageTagMirrorSet</literal> objects, see "Configuring image registry repository mirroring" in the previous section.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Ensure that you have <literal>ImageContentSourcePolicy</literal> objects on your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Use the following command to convert one or more <literal>ImageContentSourcePolicy</literal> YAML files to an <literal>ImageDigestMirrorSet</literal> YAML file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm migrate icsp &lt;file_name&gt;.yaml &lt;file_name&gt;.yaml &lt;file_name&gt;.yaml --dest-dir &lt;path_to_the_directory&gt;</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;file_name&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the source <literal>ImageContentSourcePolicy</literal> YAML. You can list multiple file names.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>--dest-dir</literal></term>
<listitem>
<simpara>Optional: Specifies a directory for the output <literal>ImageDigestMirrorSet</literal> YAML. If unset, the file is written to the current directory.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>For example, the following command converts the <literal>icsp.yaml</literal> and <literal>icsp-2.yaml</literal> file and saves the new YAML files to the <literal>idms-files</literal> directory.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm migrate icsp icsp.yaml icsp-2.yaml --dest-dir idms-files</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi8repo.5911620242173376087.yaml
wrote ImageDigestMirrorSet to idms-files/imagedigestmirrorset_ubi9repo.6456931852378115011.yaml</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the CR object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;path_to_the_directory&gt;/&lt;file-name&gt;.yaml</programlisting>
<simpara>where:</simpara>
<variablelist>
<varlistentry>
<term><literal>&lt;path_to_the_directory&gt;</literal></term>
<listitem>
<simpara>Specifies the path to the directory, if you used the <literal>--dest-dir</literal> flag.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>&lt;file_name&gt;</literal></term>
<listitem>
<simpara>Specifies the name of the <literal>ImageDigestMirrorSet</literal> YAML.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Remove the ICSP objects after the IDMS objects are rolled out.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="using-templates">
<title>Using templates</title>

<simpara>The following sections provide an overview of templates, as well as how to use and create them.</simpara>
<section xml:id="templates-overview_using-templates">
<title>Understanding templates</title>
<simpara>A template describes a set of objects that can be parameterized and processed to produce a list of objects for creation by OpenShift Container Platform. A template can be processed to create anything you have permission to create within a project, for example services, build configurations, and deployment configurations. A template can also define a set of labels to apply to every object defined in the template.</simpara>
<simpara>You can create a list of objects from a template using the CLI or, if a template has been uploaded to your project or the global template library, using the web console.</simpara>
</section>
<section xml:id="templates-uploading_using-templates">
<title>Uploading a template</title>
<simpara>If you have a JSON or YAML file that defines a template, you can upload the template to projects using the CLI. This saves the template to the project for repeated use by any user with appropriate access to that project. Instructions about writing your own templates are provided later in this topic.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Upload a template using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Upload a template to your current project&#8217;s template library, pass the JSON or YAML file with the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt;</programlisting>
</listitem>
<listitem>
<simpara>Upload a template to a different project using the <literal>-n</literal> option with the name of the project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;filename&gt; -n &lt;project&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The template is now available for selection using the web console or the CLI.</simpara>
</section>
<section xml:id="templates-creating-from-console_using-templates">
<title>Creating an application by using the web console</title>
<simpara>You can use the web console to create an application from a template.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Select <emphasis role="strong">Developer</emphasis> from the context selector at the top of the web console
navigation menu.</simpara>
</listitem>
<listitem>
<simpara>While in the desired project, click <emphasis role="strong">+Add</emphasis></simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">All services</emphasis> in the <emphasis role="strong">Developer Catalog</emphasis> tile.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Builder Images</emphasis> under <emphasis role="strong">Type</emphasis> to see the available builder images.</simpara>
<note>
<simpara>Only image stream tags that have the <literal>builder</literal> tag listed in their annotations
appear in this list, as demonstrated here:</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">kind: "ImageStream"
apiVersion: "v1"
metadata:
  name: "ruby"
  creationTimestamp: null
spec:
# ...
  tags:
    - name: "2.6"
      annotations:
        description: "Build and run Ruby 2.6 applications"
        iconClass: "icon-ruby"
        tags: "builder,ruby" <co xml:id="CO21-1"/>
        supports: "ruby:2.6,ruby"
        version: "2.6"
# ...</programlisting>
<calloutlist>
<callout arearefs="CO21-1">
<para>Including <literal>builder</literal> here ensures this image stream tag appears in the
web console as a builder.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Modify the settings in the new application screen to configure the objects
to support your application.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-using-the-cli_using-templates">
<title>Creating objects from templates by using the CLI</title>
<simpara>You can use the CLI to process templates and use the configuration that is generated to create objects.</simpara>
<section xml:id="templates-cli-labels_using-templates">
<title>Adding labels</title>
<simpara>Labels are used to manage and organize generated objects, such as pods. The labels specified in the template are applied to every object that is generated from the template.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Add labels in the template from the command line:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f &lt;filename&gt; -l name=otherLabel</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-cli-parameters_using-templates">
<title>Listing parameters</title>
<simpara>The list of parameters that you can override are listed in the <literal>parameters</literal> section of the template.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>You can list parameters with the CLI by using the following command and specifying the file to be used:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process --parameters -f &lt;filename&gt;</programlisting>
<simpara>Alternatively, if the template is already uploaded:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process --parameters -n &lt;project&gt; &lt;template_name&gt;</programlisting>
<simpara>For example, the following shows the output when listing the parameters for one of the quick start templates in the default <literal>openshift</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process --parameters -n openshift rails-postgresql-example</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                         DESCRIPTION                                                                                              GENERATOR           VALUE
SOURCE_REPOSITORY_URL        The URL of the repository with your application source code                                                                  https://github.com/sclorg/rails-ex.git
SOURCE_REPOSITORY_REF        Set this to a branch name, tag or other ref of your repository if you are not using the default branch
CONTEXT_DIR                  Set this to the relative path to your project if it is not in the root of your repository
APPLICATION_DOMAIN           The exposed hostname that will route to the Rails service                                                                    rails-postgresql-example.openshiftapps.com
GITHUB_WEBHOOK_SECRET        A secret string used to configure the GitHub webhook                                                     expression          [a-zA-Z0-9]{40}
SECRET_KEY_BASE              Your secret key for verifying the integrity of signed cookies                                            expression          [a-z0-9]{127}
APPLICATION_USER             The application user that is used within the sample application to authorize access on pages                                 openshift
APPLICATION_PASSWORD         The application password that is used within the sample application to authorize access on pages                             secret
DATABASE_SERVICE_NAME        Database service name                                                                                                        postgresql
POSTGRESQL_USER              database username                                                                                        expression          user[A-Z0-9]{3}
POSTGRESQL_PASSWORD          database password                                                                                        expression          [a-zA-Z0-9]{8}
POSTGRESQL_DATABASE          database name                                                                                                                root
POSTGRESQL_MAX_CONNECTIONS   database max connections                                                                                                     10
POSTGRESQL_SHARED_BUFFERS    database shared buffers                                                                                                      12MB</programlisting>
</para>
</formalpara>
<simpara>The output identifies several parameters that are generated with a regular expression-like generator when the template is processed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-cli-generating-list-of-objects_using-templates">
<title>Generating a list of objects</title>
<simpara>Using the CLI, you can process a file defining a template to return the list of objects to standard output.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Process a file defining a template to return the list of objects to standard output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f &lt;filename&gt;</programlisting>
<simpara>Alternatively, if the template has already been uploaded to the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process &lt;template_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Create objects from a template by processing the template and piping the output to <literal>oc create</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f &lt;filename&gt; | oc create -f -</programlisting>
<simpara>Alternatively, if the template has already been uploaded to the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process &lt;template&gt; | oc create -f -</programlisting>
</listitem>
<listitem>
<simpara>You can override any parameter values defined in the file by adding the <literal>-p</literal> option for each <literal>&lt;name&gt;=&lt;value&gt;</literal> pair you want to override. A parameter reference appears in any text field inside the template items.</simpara>
<simpara>For example, in the following the <literal>POSTGRESQL_USER</literal> and <literal>POSTGRESQL_DATABASE</literal> parameters of a template are overridden to output a configuration with customized environment variables:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Creating a List of objects from a template</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f my-rails-postgresql \
    -p POSTGRESQL_USER=bob \
    -p POSTGRESQL_DATABASE=mydatabase</programlisting>
</listitem>
<listitem>
<simpara>The JSON file can either be redirected to a file or applied directly without uploading the template by piping the processed output to the <literal>oc create</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f my-rails-postgresql \
    -p POSTGRESQL_USER=bob \
    -p POSTGRESQL_DATABASE=mydatabase \
    | oc create -f -</programlisting>
</listitem>
<listitem>
<simpara>If you have large number of parameters, you can store them in a file and then pass this file to <literal>oc process</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat postgres.env
POSTGRESQL_USER=bob
POSTGRESQL_DATABASE=mydatabase</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc process -f my-rails-postgresql --param-file=postgres.env</programlisting>
</listitem>
<listitem>
<simpara>You can also read the environment from standard input by using <literal>"-"</literal> as the argument to <literal>--param-file</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sed s/bob/alice/ postgres.env | oc process -f my-rails-postgresql --param-file=-</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="templates-modifying-uploaded-template_using-templates">
<title>Modifying uploaded templates</title>
<simpara>You can edit a template that has already been uploaded to your project.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Modify a template that has already been uploaded:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit template &lt;template&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-using-instant-app-quickstart_using-templates">
<title>Using instant app and quick start templates</title>
<simpara>OpenShift Container Platform provides a number of default instant app and quick start templates to make it easy to quickly get started creating a new application for different languages. Templates are provided for Rails (Ruby), Django (Python), Node.js, CakePHP (PHP), and Dancer (Perl). Your cluster administrator must create these templates in the default, global <literal>openshift</literal> project so you have access to them.</simpara>
<simpara>By default, the templates build using a public source repository on GitHub that contains the necessary application code.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>You can list the available default instant app and quick start templates with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get templates -n openshift</programlisting>
</listitem>
<listitem>
<simpara>To modify the source and build your own version of the application:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Fork the repository referenced by the template&#8217;s default
<literal>SOURCE_REPOSITORY_URL</literal> parameter.</simpara>
</listitem>
<listitem>
<simpara>Override the value of the <literal>SOURCE_REPOSITORY_URL</literal> parameter when creating from the template, specifying your fork instead of the default value.</simpara>
<simpara>By doing this, the build configuration created by the template now points to your fork of the application code, and you can modify the code and rebuild the application at will.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>Some of the instant app and quick start templates define a database deployment configuration. The configuration they define uses ephemeral storage for the database content. These templates should be used for demonstration purposes only as all database data is lost if the database pod restarts for any reason.</simpara>
</note>
<section xml:id="templates-quickstart_using-templates">
<title>Quick start templates</title>
<simpara>A quick start template is a basic example of an application running on OpenShift Container Platform. Quick starts come in a variety of languages and frameworks, and are defined in a template, which is constructed from a set of services, build configurations, and deployment configurations. This template references the necessary images and source repositories to build and deploy the application.</simpara>
<simpara>To explore a quick start, create an application from a template. Your administrator must have already installed these templates in your OpenShift Container Platform cluster, in which case you can simply select it from the web console.</simpara>
<simpara>Quick starts refer to a source repository that contains the application source code. To customize the quick start, fork the repository and, when creating an application from the template, substitute the default source repository name with your forked repository. This results in builds that are performed using your source code instead of the provided example source. You can then update the code in your source repository and launch a new build to see the changes reflected in the deployed application.</simpara>
<section xml:id="templates-quickstart-web-framework_using-templates">
<title>Web framework quick start templates</title>
<simpara>These quick start templates provide a basic application of the indicated framework and language:</simpara>
<itemizedlist>
<listitem>
<simpara>CakePHP: a PHP web framework that includes a MySQL database</simpara>
</listitem>
<listitem>
<simpara>Dancer: a Perl web framework that includes a MySQL database</simpara>
</listitem>
<listitem>
<simpara>Django: a Python web framework that includes a PostgreSQL database</simpara>
</listitem>
<listitem>
<simpara>NodeJS: a NodeJS web application that includes a MongoDB database</simpara>
</listitem>
<listitem>
<simpara>Rails: a Ruby web framework that includes a PostgreSQL database</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="templates-writing_using-templates">
<title>Writing templates</title>
<simpara>You can define new templates to make it easy to recreate all the objects of your application. The template defines the objects it creates along with some metadata to guide the creation of those objects.</simpara>
<simpara>The following is an example of a simple template object definition (YAML):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: template.openshift.io/v1
kind: Template
metadata:
  name: redis-template
  annotations:
    description: "Description"
    iconClass: "icon-redis"
    tags: "database,nosql"
objects:
- apiVersion: v1
  kind: Pod
  metadata:
    name: redis-master
  spec:
    containers:
    - env:
      - name: REDIS_PASSWORD
        value: ${REDIS_PASSWORD}
      image: dockerfile/redis
      name: master
      ports:
      - containerPort: 6379
        protocol: TCP
parameters:
- description: Password used for Redis authentication
  from: '[A-Z0-9]{8}'
  generate: expression
  name: REDIS_PASSWORD
labels:
  redis: master</programlisting>
<section xml:id="templates-writing-description_using-templates">
<title>Writing the template description</title>
<simpara>The template description informs you what the template does and helps you find it when searching in the web console. Additional metadata beyond the template name is optional, but useful to have. In addition to general descriptive information, the metadata also includes a set of tags. Useful tags include the name of the language the template is related to for example, Java, PHP, Ruby, and so on.</simpara>
<simpara>The following is an example of template description metadata:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: cakephp-mysql-example <co xml:id="CO22-1"/>
  annotations:
    openshift.io/display-name: "CakePHP MySQL Example (Ephemeral)" <co xml:id="CO22-2"/>
    description: &gt;-
      An example CakePHP application with a MySQL database. For more information
      about using this template, including OpenShift considerations, see
      https://github.com/sclorg/cakephp-ex/blob/master/README.md.


      WARNING: Any data stored will be lost upon pod destruction. Only use this
      template for testing." <co xml:id="CO22-3"/>
    openshift.io/long-description: &gt;-
      This template defines resources needed to develop a CakePHP application,
      including a build configuration, application DeploymentConfig, and
      database DeploymentConfig.  The database is stored in
      non-persistent storage, so this configuration should be used for
      experimental purposes only. <co xml:id="CO22-4"/>
    tags: "quickstart,php,cakephp" <co xml:id="CO22-5"/>
    iconClass: icon-php <co xml:id="CO22-6"/>
    openshift.io/provider-display-name: "Red Hat, Inc." <co xml:id="CO22-7"/>
    openshift.io/documentation-url: "https://github.com/sclorg/cakephp-ex" <co xml:id="CO22-8"/>
    openshift.io/support-url: "https://access.redhat.com" <co xml:id="CO22-9"/>
message: "Your admin credentials are ${ADMIN_USERNAME}:${ADMIN_PASSWORD}" <co xml:id="CO22-10"/></programlisting>
<calloutlist>
<callout arearefs="CO22-1">
<para>The unique name of the template.</para>
</callout>
<callout arearefs="CO22-2">
<para>A brief, user-friendly name, which can be employed by user interfaces.</para>
</callout>
<callout arearefs="CO22-3">
<para>A description of the template. Include enough detail that users understand what is being deployed and any caveats they must know before deploying. It should also provide links to additional information, such as a README file. Newlines can be included to create paragraphs.</para>
</callout>
<callout arearefs="CO22-4">
<para>Additional template description. This may be displayed by the service catalog, for example.</para>
</callout>
<callout arearefs="CO22-5">
<para>Tags to be associated with the template for searching and grouping. Add tags that include it into one of the provided catalog categories. Refer to the <literal>id</literal> and <literal>categoryAliases</literal> in <literal>CATALOG_CATEGORIES</literal> in the console constants file.
The categories can also be customized for the whole cluster.</para>
</callout>
<callout arearefs="CO22-6">
<para>An icon to be displayed with your template in the web console.</para>
<example>
<title>Available icons</title>
<itemizedlist>
<listitem>
<simpara><literal>icon-3scale</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-aerogear</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-amq</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-angularjs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-ansible</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-apache</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-beaker</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-camel</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-capedwarf</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-cassandra</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-catalog-icon</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-clojure</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-codeigniter</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-cordova</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-datagrid</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-datavirt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-debian</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-decisionserver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-django</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-dotnet</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-drupal</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-eap</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-elastic</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-erlang</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-fedora</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-freebsd</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-git</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-github</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-gitlab</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-glassfish</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-go-gopher</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-golang</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-grails</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-hadoop</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-haproxy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-helm</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-infinispan</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-jboss</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-jenkins</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-jetty</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-joomla</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-jruby</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-js</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-knative</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-kubevirt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-laravel</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-load-balancer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-mariadb</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-mediawiki</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-memcached</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-mongodb</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-mssql</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-mysql-database</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-nginx</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-nodejs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-openjdk</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-openliberty</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-openshift</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-openstack</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-other-linux</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-other-unknown</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-perl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-phalcon</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-php</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-play</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iconpostgresql</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-processserver</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-python</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-quarkus</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-rabbitmq</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-rails</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-redhat</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-redis</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-rh-integration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-rh-spring-boot</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-rh-tomcat</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-ruby</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-scala</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-serverlessfx</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-shadowman</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-spring-boot</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-spring</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-sso</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-stackoverflow</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-suse</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-symfony</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-tomcat</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-ubuntu</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-vertx</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-wildfly</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-windows</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-wordpress</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-xamarin</literal></simpara>
</listitem>
<listitem>
<simpara><literal>icon-zend</literal></simpara>
</listitem>
</itemizedlist>
</example>
</callout>
<callout arearefs="CO22-7">
<para>The name of the person or organization providing the template.</para>
</callout>
<callout arearefs="CO22-8">
<para>A URL referencing further documentation for the template.</para>
</callout>
<callout arearefs="CO22-9">
<para>A URL where support can be obtained for the template.</para>
</callout>
<callout arearefs="CO22-10">
<para>An instructional message that is displayed when this template is instantiated. This field should inform the user how to use the newly created resources. Parameter substitution is performed on the message before being displayed so that generated credentials and other parameters can be included in the output. Include links to any next-steps documentation that users should follow.</para>
</callout>
</calloutlist>
</section>
<section xml:id="templates-writing-labels_using-templates">
<title>Writing template labels</title>
<simpara>Templates can include a set of labels. These labels are added to each object created when the template is instantiated. Defining a label in this way makes it easy for users to find and manage all the objects created from a particular template.</simpara>
<simpara>The following is an example of template object labels:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: "Template"
apiVersion: "v1"
...
labels:
  template: "cakephp-mysql-example" <co xml:id="CO23-1"/>
  app: "${NAME}" <co xml:id="CO23-2"/></programlisting>
<calloutlist>
<callout arearefs="CO23-1">
<para>A label that is applied to all objects created from this template.</para>
</callout>
<callout arearefs="CO23-2">
<para>A parameterized label that is also applied to all objects created from
this template. Parameter expansion is carried out on both label keys and
values.</para>
</callout>
</calloutlist>
</section>
<section xml:id="templates-writing-parameters_using-templates">
<title>Writing template parameters</title>
<simpara>Parameters allow a value to be supplied by you or generated when the template is instantiated. Then, that value is substituted wherever the parameter is referenced. References can be defined in any field in the objects list field. This is useful for generating random passwords or allowing you to supply a hostname or other user-specific value that is required to customize the template. Parameters can be referenced in two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>As a string value by placing values in the form <literal>${PARAMETER_NAME}</literal> in any string field in the template.</simpara>
</listitem>
<listitem>
<simpara>As a JSON or YAML value by placing values in the form <literal>${{PARAMETER_NAME}}</literal> in place of any field in the template.</simpara>
</listitem>
</itemizedlist>
<simpara>When using the <literal>${PARAMETER_NAME}</literal> syntax, multiple parameter references can be combined in a single field and the reference can be embedded within fixed data, such as <literal>"http://${PARAMETER_1}${PARAMETER_2}"</literal>. Both parameter values are substituted and the resulting value is a quoted string.</simpara>
<simpara>When using the <literal>${{PARAMETER_NAME}}</literal> syntax only a single parameter reference is allowed and leading and trailing characters are not permitted. The resulting value is unquoted unless, after substitution is performed, the result is not a valid JSON object. If the result is not a valid JSON value, the resulting value is quoted and treated as a standard string.</simpara>
<simpara>A single parameter can be referenced multiple times within a template and it can be referenced using both substitution syntaxes within a single template.</simpara>
<simpara>A default value can be provided, which is used if you do not supply a different value:</simpara>
<simpara>The following is an example of setting an explicit value as the default value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">parameters:
  - name: USERNAME
    description: "The user name for Joe"
    value: joe</programlisting>
<simpara>Parameter values can also be generated based on rules specified in the parameter definition, for example generating a parameter value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">parameters:
  - name: PASSWORD
    description: "The random user password"
    generate: expression
    from: "[a-zA-Z0-9]{12}"</programlisting>
<simpara>In the previous example, processing generates a random password 12 characters long consisting of all upper and lowercase alphabet letters and numbers.</simpara>
<simpara>The syntax available is not a full regular expression syntax. However, you can use <literal>\w</literal>, <literal>\d</literal>, <literal>\a</literal>, and <literal>\A</literal> modifiers:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>[\w]{10}</literal> produces 10 alphabet characters, numbers, and underscores. This
follows the PCRE standard and is equal to <literal>[a-zA-Z0-9_]{10}</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>[\d]{10}</literal> produces 10 numbers. This is equal to <literal>[0-9]{10}</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>[\a]{10}</literal> produces 10 alphabetical characters. This is equal to
<literal>[a-zA-Z]{10}</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>[\A]{10}</literal> produces 10 punctuation or symbol characters. This is equal to <literal>[~!@#$%\^&amp;*()\-_+={}\[\]\\|&lt;,&gt;.?/"';:`]{10}</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Depending on if the template is written in YAML or JSON, and the type of string that the modifier is embedded within, you might need to escape the backslash with a second backslash. The following examples are equivalent:</simpara>
<formalpara>
<title>Example YAML template with a modifier</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">  parameters:
  - name: singlequoted_example
    generate: expression
    from: '[\A]{10}'
  - name: doublequoted_example
    generate: expression
    from: "[\\A]{10}"</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example JSON template with a modifier</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "parameters": [
       {
        "name": "json_example",
        "generate": "expression",
        "from": "[\\A]{10}"
       }
    ]
}</programlisting>
</para>
</formalpara>
</note>
<simpara>Here is an example of a full template with parameter definitions and references:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: my-template
objects:
  - kind: BuildConfig
    apiVersion: build.openshift.io/v1
    metadata:
      name: cakephp-mysql-example
      annotations:
        description: Defines how to build the application
    spec:
      source:
        type: Git
        git:
          uri: "${SOURCE_REPOSITORY_URL}" <co xml:id="CO24-1"/>
          ref: "${SOURCE_REPOSITORY_REF}"
        contextDir: "${CONTEXT_DIR}"
  - kind: DeploymentConfig
    apiVersion: apps.openshift.io/v1
    metadata:
      name: frontend
    spec:
      replicas: "${{REPLICA_COUNT}}" <co xml:id="CO24-2"/>
parameters:
  - name: SOURCE_REPOSITORY_URL <co xml:id="CO24-3"/>
    displayName: Source Repository URL <co xml:id="CO24-4"/>
    description: The URL of the repository with your application source code <co xml:id="CO24-5"/>
    value: https://github.com/sclorg/cakephp-ex.git <co xml:id="CO24-6"/>
    required: true <co xml:id="CO24-7"/>
  - name: GITHUB_WEBHOOK_SECRET
    description: A secret string used to configure the GitHub webhook
    generate: expression <co xml:id="CO24-8"/>
    from: "[a-zA-Z0-9]{40}" <co xml:id="CO24-9"/>
  - name: REPLICA_COUNT
    description: Number of replicas to run
    value: "2"
    required: true
message: "... The GitHub webhook secret is ${GITHUB_WEBHOOK_SECRET} ..." <co xml:id="CO24-10"/></programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>This value is replaced with the value of the <literal>SOURCE_REPOSITORY_URL</literal> parameter when the template is instantiated.</para>
</callout>
<callout arearefs="CO24-2">
<para>This value is replaced with the unquoted value of the <literal>REPLICA_COUNT</literal> parameter when the template is instantiated.</para>
</callout>
<callout arearefs="CO24-3">
<para>The name of the parameter. This value is used to reference the parameter within the template.</para>
</callout>
<callout arearefs="CO24-4">
<para>The user-friendly name for the parameter. This is displayed to users.</para>
</callout>
<callout arearefs="CO24-5">
<para>A description of the parameter. Provide more detailed information for the purpose of the parameter, including any constraints on the expected value. Descriptions should use complete sentences to follow the console&#8217;s text standards. Do not make this a duplicate of the display name.</para>
</callout>
<callout arearefs="CO24-6">
<para>A default value for the parameter which is used if you do not override the value when instantiating the template. Avoid using default values for things like passwords, instead use generated parameters in combination with secrets.</para>
</callout>
<callout arearefs="CO24-7">
<para>Indicates this parameter is required, meaning you cannot override it with an empty value. If the parameter does not provide a default or generated value, you must supply a value.</para>
</callout>
<callout arearefs="CO24-8">
<para>A parameter which has its value generated.</para>
</callout>
<callout arearefs="CO24-9">
<para>The input to the generator. In this case, the generator produces a 40 character alphanumeric value including upper and lowercase characters.</para>
</callout>
<callout arearefs="CO24-10">
<para>Parameters can be included in the template message. This informs you about generated values.</para>
</callout>
</calloutlist>
</section>
<section xml:id="templates-writing-object-list_using-templates">
<title>Writing the template object list</title>
<simpara>The main portion of the template is the list of objects which is created when the template is instantiated. This can be any valid API object, such as a build configuration, deployment configuration, or service. The object is created exactly as defined here, with any parameter values substituted in prior to creation. The definition of these objects can reference parameters defined earlier.</simpara>
<simpara>The following is an example of an object list:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: "Template"
apiVersion: "v1"
metadata:
  name: my-template
objects:
  - kind: "Service" <co xml:id="CO25-1"/>
    apiVersion: "v1"
    metadata:
      name: "cakephp-mysql-example"
      annotations:
        description: "Exposes and load balances the application pods"
    spec:
      ports:
        - name: "web"
          port: 8080
          targetPort: 8080
      selector:
        name: "cakephp-mysql-example"</programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>The definition of a service, which is created by this template.</para>
</callout>
</calloutlist>
<note>
<simpara>If an object definition metadata includes a fixed <literal>namespace</literal> field value, the field is stripped out of the definition during template instantiation. If the <literal>namespace</literal> field contains a parameter reference, normal parameter substitution is performed and the object is created in whatever namespace the parameter substitution resolved the value to, assuming the user has permission to create objects in that namespace.</simpara>
</note>
</section>
<section xml:id="templates-marking-as-bindable_using-templates">
<title>Marking a template as bindable</title>
<simpara>The Template Service Broker advertises one service in its catalog for each template object of which it is aware. By default, each of these services is advertised as being bindable, meaning an end user is permitted to bind against the provisioned service.</simpara>
<formalpara>
<title>Procedure</title>
<para>Template authors can prevent end users from binding against services provisioned from a given template.</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Prevent end user from binding against services provisioned from a given template by adding the annotation <literal>template.openshift.io/bindable: "false"</literal> to the template.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-exposing-object-fields_using-templates">
<title>Exposing template object fields</title>
<simpara>Template authors can indicate that fields of particular objects in a template should be exposed. The Template Service Broker recognizes exposed fields on <literal>ConfigMap</literal>, <literal>Secret</literal>, <literal>Service</literal>, and <literal>Route</literal> objects, and returns the values of the exposed fields when a user binds a service backed by the broker.</simpara>
<simpara>To expose one or more fields of an object, add annotations prefixed by <literal>template.openshift.io/expose-</literal> or <literal>template.openshift.io/base64-expose-</literal> to the object in the template.</simpara>
<simpara>Each annotation key, with its prefix removed, is passed through to become a key in a <literal>bind</literal> response.</simpara>
<simpara>Each annotation value is a Kubernetes JSONPath expression, which is resolved at bind time to indicate the object field whose value should be returned in the <literal>bind</literal> response.</simpara>
<note>
<simpara><literal>Bind</literal> response key-value pairs can be used in other parts of the system as environment variables. Therefore, it is recommended that every annotation key with its prefix removed should be a valid environment variable name&#8201;&#8212;&#8201;beginning with a character <literal>A-Z</literal>, <literal>a-z</literal>, or <literal>_</literal>, and being followed by zero or more characters <literal>A-Z</literal>, <literal>a-z</literal>, <literal>0-9</literal>, or <literal>_</literal>.</simpara>
</note>
<note>
<simpara>Unless escaped with a backslash, Kubernetes' JSONPath implementation interprets characters such as <literal>.</literal>, <literal>@</literal>, and others as metacharacters, regardless of their position in the expression. Therefore, for example, to refer to a <literal>ConfigMap</literal> datum named <literal>my.key</literal>, the required JSONPath expression would be <literal>{.data['my\.key']}</literal>. Depending on how the JSONPath expression is then written in YAML, an additional backslash might be required, for example <literal>"{.data['my\\.key']}"</literal>.</simpara>
</note>
<simpara>The following is an example of different objects' fields being exposed:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: my-template
objects:
- kind: ConfigMap
  apiVersion: v1
  metadata:
    name: my-template-config
    annotations:
      template.openshift.io/expose-username: "{.data['my\\.username']}"
  data:
    my.username: foo
- kind: Secret
  apiVersion: v1
  metadata:
    name: my-template-config-secret
    annotations:
      template.openshift.io/base64-expose-password: "{.data['password']}"
  stringData:
    password: &lt;password&gt;
- kind: Service
  apiVersion: v1
  metadata:
    name: my-template-service
    annotations:
      template.openshift.io/expose-service_ip_port: "{.spec.clusterIP}:{.spec.ports[?(.name==\"web\")].port}"
  spec:
    ports:
    - name: "web"
      port: 8080
- kind: Route
  apiVersion: route.openshift.io/v1
  metadata:
    name: my-template-route
    annotations:
      template.openshift.io/expose-uri: "http://{.spec.host}{.spec.path}"
  spec:
    path: mypath</programlisting>
<simpara>An example response to a <literal>bind</literal> operation given the above partial template follows:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "credentials": {
    "username": "foo",
    "password": "YmFy",
    "service_ip_port": "172.30.12.34:8080",
    "uri": "http://route-test.router.default.svc.cluster.local/mypath"
  }
}</programlisting>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>template.openshift.io/expose-</literal> annotation to return the field value as a string. This is convenient, although it does not handle arbitrary binary data.</simpara>
</listitem>
<listitem>
<simpara>If you want to return binary data, use the <literal>template.openshift.io/base64-expose-</literal> annotation instead to base64 encode the data before it is returned.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-waiting-for-readiness_using-templates">
<title>Waiting for template readiness</title>
<simpara>Template authors can indicate that certain objects within a template should be waited for before a template instantiation by the service catalog, Template Service Broker, or <literal>TemplateInstance</literal> API is considered complete.</simpara>
<simpara>To use this feature, mark one or more objects of kind <literal>Build</literal>, <literal>BuildConfig</literal>, <literal>Deployment</literal>, <literal>DeploymentConfig</literal>, <literal>Job</literal>, or <literal>StatefulSet</literal> in a template with the following annotation:</simpara>
<programlisting language="text" linenumbering="unnumbered">"template.alpha.openshift.io/wait-for-ready": "true"</programlisting>
<simpara>Template instantiation is not complete until all objects marked with the annotation report ready. Similarly, if any of the annotated objects report failed, or if the template fails to become ready within a fixed timeout of one hour, the template instantiation fails.</simpara>
<simpara>For the purposes of instantiation, readiness and failure of each object kind are defined as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Kind</entry>
<entry align="left" valign="top">Readiness</entry>
<entry align="left" valign="top">Failure</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Build</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Object reports phase complete.</simpara></entry>
<entry align="left" valign="top"><simpara>Object reports phase canceled, error, or failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>BuildConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Latest associated build object reports phase complete.</simpara></entry>
<entry align="left" valign="top"><simpara>Latest associated build object reports phase canceled, error, or failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Deployment</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Object reports new replica set and deployment available. This honors readiness probes defined on the object.</simpara></entry>
<entry align="left" valign="top"><simpara>Object reports progressing condition as false.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DeploymentConfig</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Object reports new replication controller and deployment available. This honors readiness probes defined on the object.</simpara></entry>
<entry align="left" valign="top"><simpara>Object reports progressing condition as false.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Job</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Object reports completion.</simpara></entry>
<entry align="left" valign="top"><simpara>Object reports that one or more failures have occurred.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StatefulSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Object reports all replicas ready. This honors readiness probes defined on
the object.</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The following is an example template extract, which uses the <literal>wait-for-ready</literal> annotation. Further examples can be found in the OpenShift Container Platform quick start templates.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Template
apiVersion: template.openshift.io/v1
metadata:
  name: my-template
objects:
- kind: BuildConfig
  apiVersion: build.openshift.io/v1
  metadata:
    name: ...
    annotations:
      # wait-for-ready used on BuildConfig ensures that template instantiation
      # will fail immediately if build fails
      template.alpha.openshift.io/wait-for-ready: "true"
  spec:
    ...
- kind: DeploymentConfig
  apiVersion: apps.openshift.io/v1
  metadata:
    name: ...
    annotations:
      template.alpha.openshift.io/wait-for-ready: "true"
  spec:
    ...
- kind: Service
  apiVersion: v1
  metadata:
    name: ...
  spec:
    ...</programlisting>
<itemizedlist>
<title>Additional recommendations</title>
<listitem>
<simpara>Set memory, CPU, and storage default sizes to make sure your application is given enough resources to run smoothly.</simpara>
</listitem>
<listitem>
<simpara>Avoid referencing the <literal>latest</literal> tag from images if that tag is used across major versions. This can cause running applications to break when new images are pushed to that tag.</simpara>
</listitem>
<listitem>
<simpara>A good template builds and deploys cleanly without requiring modifications after the template is deployed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-create-from-existing-object_using-templates">
<title>Creating a template from existing objects</title>
<simpara>Rather than writing an entire template from scratch, you can export existing objects from your project in YAML form, and then modify the YAML from there by adding parameters and other customizations as template form.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Export objects in a project in YAML form:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get -o yaml all &gt; &lt;yaml_filename&gt;</programlisting>
<simpara>You can also substitute a particular resource type or multiple resources instead of <literal>all</literal>. Run <literal>oc get -h</literal> for more examples.</simpara>
<simpara>The object types included in <literal>oc get -o yaml all</literal> are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>BuildConfig</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Build</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DeploymentConfig</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ImageStream</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Pod</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ReplicationController</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Route</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Service</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>Using the <literal>all</literal> alias is not recommended because the contents might vary across different clusters and versions. Instead, specify all required resources.</simpara>
</note>
</section>
</section>
</chapter>
<chapter xml:id="templates-using-ruby-on-rails">
<title>Using Ruby on Rails</title>

<simpara>Ruby on Rails is a web framework written in Ruby. This guide covers using Rails 4 on OpenShift Container Platform.</simpara>
<warning>
<simpara>Go through the whole tutorial to have an overview of all the steps necessary to run your application on the OpenShift Container Platform. If you experience a problem try reading through the entire tutorial and then going back to your issue. It can also be useful to review your previous steps to ensure that all the steps were run correctly.</simpara>
</warning>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>Basic Ruby and Rails knowledge.</simpara>
</listitem>
<listitem>
<simpara>Locally installed version of Ruby 2.0.0+, Rubygems, Bundler.</simpara>
</listitem>
<listitem>
<simpara>Basic Git knowledge.</simpara>
</listitem>
<listitem>
<simpara>Running instance of OpenShift Container Platform 4.</simpara>
</listitem>
<listitem>
<simpara>Make sure that an instance of OpenShift Container Platform is running and is available. Also make sure that your <literal>oc</literal> CLI client is installed and the command is accessible from your command shell, so you can use it to log in using your email address and password.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-rails-setting-up-database_templates-ruby-on-rails">
<title>Setting up the database</title>
<simpara>Rails applications are almost always used with a database. For local development use the PostgreSQL database.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the database:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo yum install -y postgresql postgresql-server postgresql-devel</programlisting>
</listitem>
<listitem>
<simpara>Initialize the database:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo postgresql-setup initdb</programlisting>
<simpara>This command creates the <literal>/var/lib/pgsql/data</literal> directory, in which the data is stored.</simpara>
</listitem>
<listitem>
<simpara>Start the database:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo systemctl start postgresql.service</programlisting>
</listitem>
<listitem>
<simpara>When the database is running, create your <literal>rails</literal> user:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ sudo -u postgres createuser -s rails</programlisting>
<simpara>Note that the user created has no password.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-rails-writing-application_templates-ruby-on-rails">
<title>Writing your application</title>
<simpara>If you are starting your Rails application from scratch, you must install the Rails gem first. Then you can proceed with writing your application.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Install the Rails gem:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ gem install rails</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Successfully installed rails-4.3.0
1 gem installed</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After you install the Rails gem, create a new application with PostgreSQL as your database:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rails new rails-app --database=postgresql</programlisting>
</listitem>
<listitem>
<simpara>Change into your new application directory:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cd rails-app</programlisting>
</listitem>
<listitem>
<simpara>If you already have an application, make sure the <literal>pg</literal> (postgresql) gem is present in your <literal>Gemfile</literal>. If not, edit your <literal>Gemfile</literal> by adding the gem:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">gem 'pg'</programlisting>
</listitem>
<listitem>
<simpara>Generate a new <literal>Gemfile.lock</literal> with all your dependencies:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ bundle install</programlisting>
</listitem>
<listitem>
<simpara>In addition to using the <literal>postgresql</literal> database with the <literal>pg</literal> gem, you also must ensure that the <literal>config/database.yml</literal> is using the <literal>postgresql</literal> adapter.</simpara>
<simpara>Make sure you updated <literal>default</literal> section in the <literal>config/database.yml</literal> file, so it looks like this:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">default: &amp;default
  adapter: postgresql
  encoding: unicode
  pool: 5
  host: localhost
  username: rails
  password: &lt;password&gt;</programlisting>
</listitem>
<listitem>
<simpara>Create your application&#8217;s development and test databases:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rake db:create</programlisting>
<simpara>This creates <literal>development</literal> and <literal>test</literal> database in your PostgreSQL server.</simpara>
</listitem>
</orderedlist>
<section xml:id="templates-rails-creating-welcome-page_templates-ruby-on-rails">
<title>Creating a welcome page</title>
<simpara>Since Rails 4 no longer serves a static <literal>public/index.html</literal> page in production, you must create a new root page.</simpara>
<simpara>To have a custom welcome page must do following steps:</simpara>
<itemizedlist>
<listitem>
<simpara>Create a controller with an index action.</simpara>
</listitem>
<listitem>
<simpara>Create a view page for the welcome controller index action.</simpara>
</listitem>
<listitem>
<simpara>Create a route that serves applications root page with the created controller and view.</simpara>
</listitem>
</itemizedlist>
<simpara>Rails offers a generator that completes all necessary steps for you.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Run Rails generator:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rails generate controller welcome index</programlisting>
<simpara>All the necessary files are created.</simpara>
</listitem>
<listitem>
<simpara>edit line 2 in <literal>config/routes.rb</literal> file as follows:</simpara>
<screen>root 'welcome#index'</screen>
</listitem>
<listitem>
<simpara>Run the rails server to verify the page is available:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ rails server</programlisting>
<simpara>You should see your page by visiting <link xlink:href="http://localhost:3000">http://localhost:3000</link> in your browser. If you do not see the page, check the logs that are output to your server to debug.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-rails-configuring-application_templates-ruby-on-rails">
<title>Configuring application for OpenShift Container Platform</title>
<simpara>To have your application communicate with the PostgreSQL database service running in OpenShift Container Platform you must edit the <literal>default</literal> section in your <literal>config/database.yml</literal> to use environment variables, which you must define later, upon the database service creation.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>default</literal> section in your <literal>config/database.yml</literal> with pre-defined variables as follows:</simpara>
<formalpara>
<title>Sample <literal>config/database</literal> YAML file</title>
<para>
<programlisting language="eruby" linenumbering="unnumbered">&lt;% user = ENV.key?("POSTGRESQL_ADMIN_PASSWORD") ? "root" : ENV["POSTGRESQL_USER"] %&gt;
&lt;% password = ENV.key?("POSTGRESQL_ADMIN_PASSWORD") ? ENV["POSTGRESQL_ADMIN_PASSWORD"] : ENV["POSTGRESQL_PASSWORD"] %&gt;
&lt;% db_service = ENV.fetch("DATABASE_SERVICE_NAME","").upcase %&gt;

default: &amp;default
  adapter: postgresql
  encoding: unicode
  # For details on connection pooling, see rails configuration guide
  # http://guides.rubyonrails.org/configuring.html#database-pooling
  pool: &lt;%= ENV["POSTGRESQL_MAX_CONNECTIONS"] || 5 %&gt;
  username: &lt;%= user %&gt;
  password: &lt;%= password %&gt;
  host: &lt;%= ENV["#{db_service}_SERVICE_HOST"] %&gt;
  port: &lt;%= ENV["#{db_service}_SERVICE_PORT"] %&gt;
  database: &lt;%= ENV["POSTGRESQL_DATABASE"] %&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="templates-rails-storing-application-in-git_templates-ruby-on-rails">
<title>Storing your application in Git</title>
<simpara>Building an application in OpenShift Container Platform usually requires that the source code be stored in a git repository, so you must install <literal>git</literal> if you do not already have it.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install git.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Make sure you are in your Rails application directory by running the <literal>ls -1</literal> command. The output of the command should look like:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ls -1</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">app
bin
config
config.ru
db
Gemfile
Gemfile.lock
lib
log
public
Rakefile
README.rdoc
test
tmp
vendor</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the following commands in your Rails app directory to initialize and commit your code to git:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ git init</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ git add .</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ git commit -m "initial commit"</programlisting>
<simpara>After your application is committed you must push it to a remote repository. GitHub account, in which you create a new repository.</simpara>
</listitem>
<listitem>
<simpara>Set the remote that points to your <literal>git</literal> repository:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ git remote add origin git@github.com:&lt;namespace/repository-name&gt;.git</programlisting>
</listitem>
<listitem>
<simpara>Push your application to your remote git repository.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ git push</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="templates-rails-deploying-application_templates-ruby-on-rails">
<title>Deploying your application to OpenShift Container Platform</title>
<simpara>You can deploy you application to OpenShift Container Platform.</simpara>
<simpara>After creating the <literal>rails-app</literal> project, you are automatically switched to the new project namespace.</simpara>
<simpara>Deploying your application in OpenShift Container Platform involves three steps:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating a database service from OpenShift Container Platform&#8217;s PostgreSQL image.</simpara>
</listitem>
<listitem>
<simpara>Creating a frontend service from OpenShift Container Platform&#8217;s Ruby 2.0 builder image and
your Ruby on Rails source code, which are wired with the database service.</simpara>
</listitem>
<listitem>
<simpara>Creating a route for your application.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To deploy your Ruby on Rails application, create a new project for the application:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project rails-app --description="My Rails application" --display-name="Rails Application"</programlisting>
</listitem>
</itemizedlist>
<section xml:id="templates-rails-creating-database-service_templates-ruby-on-rails">
<title>Creating the database service</title>
<simpara>Your Rails application expects a running database service. For this service use PostgreSQL database image.</simpara>
<simpara>To create the database service, use the <literal>oc new-app</literal> command. To this command you must pass some necessary environment variables which are used inside the database container. These environment variables are required to set the username, password, and name of the database. You can change the values of these environment variables to anything you would like. The variables are as follows:</simpara>
<itemizedlist>
<listitem>
<simpara>POSTGRESQL_DATABASE</simpara>
</listitem>
<listitem>
<simpara>POSTGRESQL_USER</simpara>
</listitem>
<listitem>
<simpara>POSTGRESQL_PASSWORD</simpara>
</listitem>
</itemizedlist>
<simpara>Setting these variables ensures:</simpara>
<itemizedlist>
<listitem>
<simpara>A database exists with the specified name.</simpara>
</listitem>
<listitem>
<simpara>A user exists with the specified name.</simpara>
</listitem>
<listitem>
<simpara>The user can access the specified database with the specified password.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the database service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-app postgresql -e POSTGRESQL_DATABASE=db_name -e POSTGRESQL_USER=username -e POSTGRESQL_PASSWORD=password</programlisting>
<simpara>To also set the password for the database administrator, append to the previous command with:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">-e POSTGRESQL_ADMIN_PASSWORD=admin_pw</programlisting>
</listitem>
<listitem>
<simpara>Watch the progress:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods --watch</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-rails-creating-frontend-service_templates-ruby-on-rails">
<title>Creating the frontend service</title>
<simpara>To bring your application to OpenShift Container Platform, you must specify a repository in which your application lives.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the frontend service and specify database related environment variables that were setup when creating the database service:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-app path/to/source/code --name=rails-app -e POSTGRESQL_USER=username -e POSTGRESQL_PASSWORD=password -e POSTGRESQL_DATABASE=db_name -e DATABASE_SERVICE_NAME=postgresql</programlisting>
<simpara>With this command, OpenShift Container Platform fetches the source code, sets up the builder, builds your application image, and deploys the newly created image together with the specified environment variables. The application is named <literal>rails-app</literal>.</simpara>
</listitem>
<listitem>
<simpara>Verify the environment variables have been added by viewing the JSON document of the <literal>rails-app</literal> deployment config:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get dc rails-app -o json</programlisting>
<simpara>You should see the following section:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">env": [
    {
        "name": "POSTGRESQL_USER",
        "value": "username"
    },
    {
        "name": "POSTGRESQL_PASSWORD",
        "value": "password"
    },
    {
        "name": "POSTGRESQL_DATABASE",
        "value": "db_name"
    },
    {
        "name": "DATABASE_SERVICE_NAME",
        "value": "postgresql"
    }

],</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the build process:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -f build/rails-app-1</programlisting>
</listitem>
<listitem>
<simpara>After the build is complete, look at the running pods in OpenShift Container Platform:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods</programlisting>
<simpara>You should see a line starting with <literal>myapp-&lt;number&gt;-&lt;hash&gt;</literal>, and that is your application running in OpenShift Container Platform.</simpara>
</listitem>
<listitem>
<simpara>Before your application is functional, you must initialize the database by running the database migration script. There are two ways you can do this:</simpara>
<itemizedlist>
<listitem>
<simpara>Manually from the running frontend container:</simpara>
<itemizedlist>
<listitem>
<simpara>Exec into frontend container with <literal>rsh</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc rsh &lt;frontend_pod_id&gt;</programlisting>
</listitem>
<listitem>
<simpara>Run the migration from inside the container:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ RAILS_ENV=production bundle exec rake db:migrate</programlisting>
<simpara>If you are running your Rails application in a <literal>development</literal> or <literal>test</literal> environment you do not have to specify the <literal>RAILS_ENV</literal> environment variable.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>By adding pre-deployment lifecycle hooks in your template.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="templates-rails-creating-route-for-application_templates-ruby-on-rails">
<title>Creating a route for your application</title>
<simpara>You can expose a service to create a route for your application.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To expose a service by giving it an externally-reachable hostname like <literal>www.example.com</literal> use OpenShift Container Platform route. In your case you need to expose the frontend service by typing:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc expose service rails-app --hostname=www.example.com</programlisting>
</listitem>
</itemizedlist>
<warning>
<simpara>Ensure the hostname you specify resolves into the IP address of the router.</simpara>
</warning>
</section>
</section>
</chapter>
<chapter xml:id="_using_images">
<title>Using images</title>
<section xml:id="using-images-overview">
<title>Using images overview</title>

<simpara>Use the following topics to discover the different Source-to-Image (S2I), database, and other container images that are available for OpenShift Container Platform users.</simpara>
<simpara>Red Hat official container images are provided in the Red Hat Registry at <link xlink:href="https://registry.redhat.io">registry.redhat.io</link>. OpenShift Container Platform&#8217;s supported S2I, database, and Jenkins images are provided in the <literal>openshift4</literal> repository in the Red Hat Quay Registry. For example, <literal>quay.io/openshift-release-dev/ocp-v4.0-&lt;address&gt;</literal> is the name of the OpenShift Application Platform image.</simpara>
<simpara>The xPaaS middleware images are provided in their respective product repositories on the Red Hat Registry but suffixed with a <literal>-openshift</literal>. For example, <literal>registry.redhat.io/jboss-eap-6/eap64-openshift</literal> is the name of the JBoss EAP image.</simpara>
<simpara>All Red Hat supported images covered in this section are described in the <link xlink:href="https://catalog.redhat.com/software/containers/explore">Container images section of the Red Hat Ecosystem Catalog</link>. For every version of each image, you can find details on its contents and usage. Browse or search for the image that interests you.</simpara>
<important>
<simpara>The newer versions of container images are not compatible with earlier versions of OpenShift Container Platform. Verify and use the correct version of container images, based on your version of OpenShift Container Platform.</simpara>
</important>
</section>
<section xml:id="using-s21-images">
<title>Source-to-image</title>

<simpara>You can use the <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_software_collections/3/html-single/using_red_hat_software_collections_container_images/index">Red Hat Software Collections</link> images as a foundation for applications that rely on specific runtime environments such as Node.js, Perl, or Python. You can use the <link xlink:href="https://access.redhat.com/documentation/en-us/openjdk/11/html/using_openjdk_11_source-to-image_for_openshift/index">Red Hat Java Source-to-Image for OpenShift</link> documentation as a reference for runtime environments that use Java. Special versions of some of these runtime base images are referred to as Source-to-Image (S2I) images. With S2I images, you can insert your code into a base image environment that is ready to run that code.</simpara>
<simpara>S2I images include:</simpara>
<itemizedlist>
<listitem>
<simpara>.NET</simpara>
</listitem>
<listitem>
<simpara>Java</simpara>
</listitem>
<listitem>
<simpara>Go</simpara>
</listitem>
<listitem>
<simpara>Node.js</simpara>
</listitem>
<listitem>
<simpara>Perl</simpara>
</listitem>
<listitem>
<simpara>PHP</simpara>
</listitem>
<listitem>
<simpara>Python</simpara>
</listitem>
<listitem>
<simpara>Ruby</simpara>
</listitem>
</itemizedlist>
<simpara>S2I images are available for you to use directly from the OpenShift Container Platform web console by following procedure:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console using your login credentials. The default view for the OpenShift Container Platform web console is the <emphasis role="strong">Administrator</emphasis> perspective.</simpara>
</listitem>
<listitem>
<simpara>Use the perspective switcher to switch to the <emphasis role="strong">Developer</emphasis> perspective.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">+Add</emphasis> view, use the <emphasis role="strong">Project</emphasis> drop-down list to select an existing project or create a new project.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">All services</emphasis> in the <emphasis role="strong">Developer Catalog</emphasis> tile.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Builder Images</emphasis> under <emphasis role="strong">Type</emphasis> to see the available S2I images.</simpara>
</listitem>
</orderedlist>
<simpara>S2I images are also available though the <link xlink:href="../../openshift_images/configuring-samples-operator.xml#configuring-samples-operator">Cluster Samples Operator</link>.</simpara>
<section xml:id="images-s2i-build-process-overview_using-s21-images">
<title>Source-to-image build process overview</title>
<simpara>Source-to-image (S2I) produces ready-to-run images by injecting source code into a container that prepares that source code to be run. It performs the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Runs the <literal>FROM &lt;builder image&gt;</literal> command</simpara>
</listitem>
<listitem>
<simpara>Copies the source code to a defined location in the builder image</simpara>
</listitem>
<listitem>
<simpara>Runs the assemble script in the builder image</simpara>
</listitem>
<listitem>
<simpara>Sets the run script in the builder image as the default command</simpara>
</listitem>
</orderedlist>
<simpara>Buildah then creates the container image.</simpara>
</section>
<section xml:id="additional-resources_using-s21-images" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../openshift_images/configuring-samples-operator.xml#configuring-samples-operator">Configuring the Cluster Samples Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../cicd/builds/build-strategies.xml#builds-strategy-s2i-build_build-strategies">Using build strategies</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../support/troubleshooting/troubleshooting-s2i.xml#troubleshooting-s2i">Troubleshooting the Source-to-Image process</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../openshift_images/create-images.xml#images-create-s2i_create-images">Creating images from source code with source-to-image</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../openshift_images/create-images.xml#images-test-s2i_create-images">About testing source-to-image images</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../openshift_images/create-images.xml#images-create-s2i_create-images">Creating images from source code with source-to-image</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="customizing-s2i-images">
<title>Customizing source-to-image images</title>
<simpara>Source-to-image (S2I) builder images include assemble and run scripts, but the default behavior of those scripts is not suitable for all users. You can customize the behavior of an S2I builder that includes default scripts.</simpara>
<section xml:id="images-using-customizing-s2i-images-scripts-embedded_customizing-s2i-images">
<title>Invoking scripts embedded in an image</title>
<simpara>Builder images provide their own version of the source-to-image (S2I) scripts that cover the most common use-cases. If these scripts do not fulfill your needs, S2I provides a way of overriding them by adding custom ones in the <literal>.s2i/bin</literal> directory. However, by doing this, you are completely replacing the standard scripts. In some cases, replacing the scripts is acceptable, but, in other scenarios, you can run a few commands before or after the scripts while retaining the logic of the script provided in the image. To reuse the standard scripts, you can create a wrapper script that runs custom logic and delegates further work to the default scripts in the image.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Look at the value of the <literal>io.openshift.s2i.scripts-url</literal> label to determine the location of the scripts inside of the builder image:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ podman inspect --format='{{ index .Config.Labels "io.openshift.s2i.scripts-url" }}' wildfly/wildfly-centos7</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">image:///usr/libexec/s2i</programlisting>
</para>
</formalpara>
<simpara>You inspected the <literal>wildfly/wildfly-centos7</literal> builder image and found out that the scripts are in the <literal>/usr/libexec/s2i</literal> directory.</simpara>
</listitem>
<listitem>
<simpara>Create a script that includes an invocation of one of the standard scripts wrapped in other commands:</simpara>
<formalpara>
<title><literal>.s2i/bin/assemble</literal> script</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash
echo "Before assembling"

/usr/libexec/s2i/assemble
rc=$?

if [ $rc -eq 0 ]; then
    echo "After successful assembling"
else
    echo "After failed assembling"
fi

exit $rc</programlisting>
</para>
</formalpara>
<simpara>This example shows a custom assemble script that prints the message, runs the standard assemble script from the image, and prints another message depending on the exit code of the assemble script.</simpara>
<important>
<simpara>When wrapping the run script, you must use <literal>exec</literal> for invoking it to ensure signals are handled properly. The use of <literal>exec</literal> also precludes the ability to run additional commands after invoking the default image run script.</simpara>
</important>
<formalpara>
<title><literal>.s2i/bin/run</literal> script</title>
<para>
<programlisting language="bash" linenumbering="unnumbered">#!/bin/bash
echo "Before running application"
exec /usr/libexec/s2i/run</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
</book>