<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Authentication and authorization</title>
<date>2024-02-20</date>
</info>
<chapter xml:id="overview-of-authentication-authorization">
<title>Overview of authentication and authorization</title>

<section xml:id="openshift-auth-common-terms_overview-of-authentication-authorization">
<title>Glossary of common terms for OpenShift Container Platform authentication and authorization</title>
<simpara>This glossary defines common terms that are used in OpenShift Container Platform authentication and authorization.</simpara>
<variablelist>
<varlistentry>
<term>authentication</term>
<listitem>
<simpara>An authentication determines access to an OpenShift Container Platform cluster and ensures only authenticated users access the OpenShift Container Platform cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>authorization</term>
<listitem>
<simpara>Authorization determines whether the identified user has permissions to perform the requested action.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>bearer token</term>
<listitem>
<simpara>Bearer token is used to authenticate to API with the header <literal>Authorization: Bearer &lt;token&gt;</literal>.</simpara>
</listitem>
</varlistentry>
</variablelist>
<variablelist>
<varlistentry>
<term>Cloud Credential Operator</term>
<listitem>
<simpara>The Cloud Credential Operator (CCO) manages cloud provider credentials as custom resource definitions (CRDs).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>config map</term>
<listitem>
<simpara>A config map provides a way to inject configuration data into the pods. You can reference the data stored in a config map in a volume of type <literal>ConfigMap</literal>. Applications running in a pod can use this data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>containers</term>
<listitem>
<simpara>Lightweight and executable images that consist software and all its dependencies. Because containers virtualize the operating system, you can run containers in a data center, public or private cloud, or your local host.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Custom Resource (CR)</term>
<listitem>
<simpara>A CR is an extension of the Kubernetes API.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>group</term>
<listitem>
<simpara>A group is a set of users. A group is useful for granting permissions to multiple users one time.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>HTPasswd</term>
<listitem>
<simpara>HTPasswd updates the files that store usernames and password for authentication of HTTP users.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Keystone</term>
<listitem>
<simpara>Keystone is an Red Hat OpenStack Platform (RHOSP) project that provides identity, token, catalog, and policy services.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Lightweight directory access protocol (LDAP)</term>
<listitem>
<simpara>LDAP is a protocol that queries user information.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>manual mode</term>
<listitem>
<simpara>In manual mode, a user manages cloud credentials instead of the Cloud Credential Operator (CCO).</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>mint mode</term>
<listitem>
<simpara>Mint mode is the default and recommended best practice setting for the Cloud Credential Operator (CCO) to use on the platforms for which it is supported. In this mode, the CCO uses the provided administrator-level cloud credential to create new credentials for components in the cluster with only the specific permissions that are required.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>namespace</term>
<listitem>
<simpara>A namespace isolates specific system resources that are visible to all processes. Inside a namespace, only processes that are members of that namespace can see those resources.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>node</term>
<listitem>
<simpara>A node is a worker machine in the OpenShift Container Platform cluster. A node is either a virtual machine (VM) or a physical machine.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OAuth client</term>
<listitem>
<simpara>OAuth client is used to get a bearer token.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OAuth server</term>
<listitem>
<simpara>The OpenShift Container Platform control plane includes a built-in OAuth server that determines the userâ€™s identity from the configured identity provider and creates an access token.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenID Connect</term>
<listitem>
<simpara>The OpenID Connect is a protocol to authenticate the users to use single sign-on (SSO) to access sites that use OpenID Providers.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>passthrough mode</term>
<listitem>
<simpara>In passthrough mode, the Cloud Credential Operator (CCO) passes the provided cloud credential to the components that request cloud credentials.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>pod</term>
<listitem>
<simpara>A pod is the smallest logical unit in Kubernetes. A pod is comprised of one or more containers to run in a worker node.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>regular users</term>
<listitem>
<simpara>Users that are created automatically in the cluster upon first login or via the API.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>request header</term>
<listitem>
<simpara>A request header is an HTTP header that is used to provide information about HTTP request context, so that the server can track the response of the request.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>role-based access control (RBAC)</term>
<listitem>
<simpara>A key security control to ensure that cluster users and workloads have access to only the resources required to execute their roles.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>service accounts</term>
<listitem>
<simpara>Service accounts are used by the cluster components or applications.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>system users</term>
<listitem>
<simpara>Users that are created automatically when the cluster is installed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>users</term>
<listitem>
<simpara>Users is an entity that can make requests to API.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="authentication-overview">
<title>About authentication in OpenShift Container Platform</title>
<simpara>To control access to an OpenShift Container Platform cluster,
a cluster administrator
can configure <link xlink:href="../authentication/understanding-authentication.xml#understanding-authentication">user authentication</link> and ensure only approved users access the cluster.</simpara>
<simpara>To interact with an OpenShift Container Platform cluster, users must first authenticate to the OpenShift Container Platform API in some way. You can authenticate by providing an <link xlink:href="../authentication/understanding-authentication.xml#rbac-api-authentication_understanding-authentication">OAuth access token or an X.509 client certificate</link> in your requests to the OpenShift Container Platform API.</simpara>
<note>
<simpara>If you do not present a valid access token or certificate, your request is unauthenticated and you receive an HTTP 401 error.</simpara>
</note>
<simpara>An administrator can configure authentication through the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Configuring an identity provider: You can define any <link xlink:href="../authentication/understanding-identity-provider.xml#supported-identity-providers">supported identity provider in OpenShift Container Platform</link> and add it to your cluster.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/configuring-internal-oauth.xml#configuring-internal-oauth">Configuring the internal OAuth server</link>: The OpenShift Container Platform control plane includes a built-in OAuth server that determines the user&#8217;s identity from the configured identity provider and creates an access token. You can configure the token duration and inactivity timeout, and customize the internal OAuth server URL.</simpara>
<note>
<simpara>Users can <link xlink:href="../authentication/managing-oauth-access-tokens.xml#managing-oauth-access-tokens">view and manage OAuth tokens owned by them</link>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Registering an OAuth client: OpenShift Container Platform includes several <link xlink:href="../authentication/configuring-oauth-clients.xml#oauth-default-clients_configuring-oauth-clients">default OAuth clients</link>. You can <link xlink:href="../authentication/configuring-oauth-clients.xml#oauth-register-additional-client_configuring-oauth-clients">register and configure additional OAuth clients</link>.</simpara>
<note>
<simpara>When users send a request for an OAuth token, they must specify either a default or custom OAuth client that receives and uses the token.</simpara>
</note>
</listitem>
<listitem>
<simpara>Managing cloud provider credentials using the <link xlink:href="../authentication/managing_cloud_provider_credentials/about-cloud-credential-operator.xml#about-cloud-credential-operator">Cloud Credentials Operator</link>: Cluster components use cloud provider credentials to get permissions required to perform cluster-related tasks.</simpara>
</listitem>
<listitem>
<simpara>Impersonating a system admin user: You can grant cluster administrator permissions to a user by <link xlink:href="../authentication/impersonating-system-admin.xml#impersonating-system-admin">impersonating a system admin user</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="authorization-overview">
<title>About authorization in OpenShift Container Platform</title>
<simpara>Authorization involves determining whether the identified user has permissions to perform the requested action.</simpara>
<simpara>Administrators can define permissions and assign them to users using the <link xlink:href="../authentication/using-rbac.xml#authorization-overview_using-rbac">RBAC objects, such as rules, roles, and bindings</link>. To understand how authorization works in OpenShift Container Platform, see <link xlink:href="../authentication/using-rbac.xml#evaluating-authorization_using-rbac">Evaluating authorization</link>.</simpara>
<simpara>You can also control access to an OpenShift Container Platform cluster through <link xlink:href="../authentication/using-rbac.xml#rbac-projects-namespaces_using-rbac">projects and namespaces</link>.</simpara>
<simpara>Along with controlling user access to a cluster, you can also control the actions a pod can perform and the resources it can access using <link xlink:href="../authentication/managing-security-context-constraints.xml#managing-pod-security-policies">security context constraints (SCCs)</link>.</simpara>
<simpara>You can manage authorization for OpenShift Container Platform through the following tasks:</simpara>
<itemizedlist>
<listitem>
<simpara>Viewing <link xlink:href="../authentication/using-rbac.xml#viewing-local-roles_using-rbac">local</link> and <link xlink:href="../authentication/using-rbac.xml#viewing-cluster-roles_using-rbac">cluster</link> roles and bindings.</simpara>
</listitem>
<listitem>
<simpara>Creating a <link xlink:href="../authentication/using-rbac.xml#creating-local-role_using-rbac">local role</link> and assigning it to a user or group.</simpara>
</listitem>
<listitem>
<simpara>Creating a cluster role and assigning it to a user or group: OpenShift Container Platform includes a set of <link xlink:href="../authentication/using-rbac.xml#default-roles_using-rbac">default cluster roles</link>. You can create additional <link xlink:href="../authentication/using-rbac.xml#creating-cluster-role_using-rbac">cluster roles</link> and <link xlink:href="../authentication/using-rbac.xml#adding-roles_using-rbac">add them to a user or group</link>.</simpara>
</listitem>
<listitem>
<simpara>Creating a cluster-admin user: By default, your cluster has only one cluster administrator called <literal>kubeadmin</literal>. You can <link xlink:href="../authentication/using-rbac.xml#creating-cluster-admin_using-rbac">create another cluster administrator</link>. Before creating a cluster administrator, ensure that you have configured an identity provider.</simpara>
<note>
<simpara>After creating the cluster admin user, <link xlink:href="../authentication/remove-kubeadmin.xml#removing-kubeadmin_removing-kubeadmin">delete the existing kubeadmin user</link> to improve cluster security.</simpara>
</note>
</listitem>
<listitem>
<simpara>Creating service accounts: <link xlink:href="../authentication/understanding-and-creating-service-accounts.xml#service-accounts-overview_understanding-service-accounts">Service accounts</link> provide a flexible way to control API access without sharing a regular userâ€™s credentials. A user can <link xlink:href="../authentication/understanding-and-creating-service-accounts.xml#service-accounts-managing_understanding-service-accounts">create and use a service account in applications</link> and also as <link xlink:href="../authentication/using-service-accounts-as-oauth-client.xml#using-service-accounts-as-oauth-client">an OAuth client</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/tokens-scoping.xml#tokens-scoping">Scoping tokens</link>: A scoped token is a token that identifies as a specific user who can perform only specific operations. You can create scoped tokens to delegate some of your permissions to another user or a service account.</simpara>
</listitem>
<listitem>
<simpara>Syncing LDAP groups: You can manage user groups in one place by <link xlink:href="../authentication/ldap-syncing.xml#ldap-syncing">syncing the groups stored in an LDAP server</link> with the OpenShift Container Platform user groups.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="understanding-authentication">
<title>Understanding authentication</title>

<simpara>For users to interact with OpenShift Container Platform, they must first authenticate
to the cluster. The authentication layer identifies the user associated with requests to the
OpenShift Container Platform API. The authorization layer then uses information about the
requesting user to determine if the request is allowed.</simpara>
<simpara>As an administrator, you can configure authentication for OpenShift Container Platform.</simpara>
<section xml:id="rbac-users_understanding-authentication">
<title>Users</title>
<simpara>A <emphasis>user</emphasis> in OpenShift Container Platform is an entity that can make requests to the
OpenShift Container Platform API. An OpenShift Container Platform <literal>User</literal> object represents an actor which
can be granted permissions in the system by adding roles to them or to their
groups. Typically, this represents the account of a developer or
administrator that is interacting with OpenShift Container Platform.</simpara>
<simpara>Several types of users can exist:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">User type</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Regular users</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is the way most interactive OpenShift Container Platform users are
represented. Regular users are created automatically in the system upon
first login or can be created via the API. Regular users are represented
with the <literal>User</literal> object. Examples: <literal>joe</literal> <literal>alice</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>System users</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Many of these are created automatically when the infrastructure
 is defined, mainly for the purpose of enabling the infrastructure to
 interact with the API securely. They include a cluster administrator
 (with access to everything), a per-node user, users for use by routers
 and registries, and various others. Finally, there is an <literal>anonymous</literal>
 system user that is used by default for unauthenticated requests. Examples:
<literal>system:admin</literal> <literal>system:openshift-registry</literal> <literal>system:node:node1.example.com</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Service accounts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These are special system users associated with projects; some are created automatically when
the project is first created, while project administrators can create more
for the purpose of defining access to the contents of each project.
Service accounts are represented with the <literal>ServiceAccount</literal> object. Examples:
<literal>system:serviceaccount:default:deployer</literal> <literal>system:serviceaccount:foo:builder</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Each user must authenticate in
some way to access OpenShift Container Platform. API requests with no authentication
or invalid authentication are authenticated as requests by the <literal>anonymous</literal>
system user. After authentication, policy determines what the user is
authorized to do.</simpara>
</section>
<section xml:id="rbac-groups_understanding-authentication">
<title>Groups</title>
<simpara>A user can be assigned to one or more <emphasis>groups</emphasis>, each of which represent a
certain set of users. Groups are useful when managing authorization policies
to grant permissions to multiple users at once, for example allowing
access to objects within a project, versus granting
them to users individually.</simpara>
<simpara>In addition to explicitly defined groups, there are also
system groups, or <emphasis>virtual groups</emphasis>, that are automatically provisioned by
the cluster.</simpara>
<simpara>The following default virtual groups are most important:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="28.5714*"/>
<colspec colname="col_2" colwidth="71.4286*"/>
<thead>
<row>
<entry align="left" valign="top">Virtual group</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>system:authenticated</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Automatically associated with all authenticated users.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>system:authenticated:oauth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Automatically associated with all users authenticated with an OAuth access token.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>system:unauthenticated</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Automatically associated with all unauthenticated users.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="rbac-api-authentication_understanding-authentication">
<title>API authentication</title>
<simpara>Requests to the OpenShift Container Platform API are authenticated using the following
methods:</simpara>
<variablelist>
<varlistentry>
<term>OAuth access tokens</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Obtained from the OpenShift Container Platform OAuth server using the
<literal><emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal> and <literal><emphasis>&lt;namespace_route&gt;</emphasis>/oauth/token</literal>
endpoints.</simpara>
</listitem>
<listitem>
<simpara>Sent as an <literal>Authorization: Bearer&#8230;&#8203;</literal> header.</simpara>
</listitem>
<listitem>
<simpara>Sent as a websocket subprotocol header in the form
<literal>base64url.bearer.authorization.k8s.io.&lt;base64url-encoded-token&gt;</literal> for websocket
requests.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>X.509 client certificates</term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Requires an HTTPS connection to the API server.</simpara>
</listitem>
<listitem>
<simpara>Verified by the API server against a trusted certificate authority bundle.</simpara>
</listitem>
<listitem>
<simpara>The API server creates and distributes certificates to controllers to authenticate themselves.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara>Any request with an invalid access token or an invalid certificate is rejected
by the authentication layer with a <literal>401</literal> error.</simpara>
<simpara>If no access token or certificate is presented, the authentication layer assigns
the <literal>system:anonymous</literal> virtual user and the <literal>system:unauthenticated</literal> virtual
group to the request. This allows the authorization layer to determine which
requests, if any, an anonymous user is allowed to make.</simpara>
<section xml:id="oauth-server-overview_understanding-authentication">
<title>OpenShift Container Platform OAuth server</title>
<simpara>The OpenShift Container Platform master includes a built-in OAuth server. Users obtain OAuth
access tokens to authenticate themselves to the API.</simpara>
<simpara>When a person requests a new OAuth token, the OAuth server uses the configured
identity provider
to determine the identity of the person making the request.</simpara>
<simpara>It then determines what user that identity maps to, creates an access token for
that user, and returns the token for use.</simpara>
<section xml:id="oauth-token-requests_understanding-authentication">
<title>OAuth token requests</title>
<simpara>Every request for an OAuth token must specify the OAuth client that will
receive and use the token. The following OAuth clients are automatically
created when starting the OpenShift Container Platform API:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">OAuth client</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>openshift-browser-client</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Requests tokens at <literal>&lt;namespace_route&gt;/oauth/token/request</literal> with a user-agent that can handle interactive logins. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift-challenging-client</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Requests tokens with a user-agent that can handle <literal>WWW-Authenticate</literal> challenges.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>&lt;namespace_route&gt;</literal> refers to the namespace route. This is found by
running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route oauth-openshift -n openshift-authentication -o json | jq .spec.host</programlisting>
</listitem>
</orderedlist>
</para>
<simpara>All requests for OAuth tokens involve a request to
<literal>&lt;namespace_route&gt;/oauth/authorize</literal>. Most authentication integrations place an
authenticating proxy in front of this endpoint, or configure
OpenShift Container Platform to validate credentials against a backing identity provider.
Requests to <literal>&lt;namespace_route&gt;/oauth/authorize</literal> can come from user-agents that
cannot display interactive login pages, such as the CLI. Therefore,
OpenShift Container Platform supports authenticating using a <literal>WWW-Authenticate</literal>
challenge in addition to interactive login flows.</simpara>
<simpara>If an authenticating proxy is placed in front of the
<literal>&lt;namespace_route&gt;/oauth/authorize</literal> endpoint, it sends unauthenticated,
non-browser user-agents <literal>WWW-Authenticate</literal> challenges rather than
displaying an interactive login page or redirecting to an interactive
login flow.</simpara>
<note>
<simpara>To prevent cross-site request forgery (CSRF) attacks against browser
clients,  only send Basic authentication challenges with if a
<literal>X-CSRF-Token</literal> header is on the request. Clients that expect
to receive Basic <literal>WWW-Authenticate</literal> challenges must set this header to a
non-empty value.</simpara>
<simpara>If the authenticating proxy cannot support <literal>WWW-Authenticate</literal> challenges,
or if OpenShift Container Platform is configured to use an identity provider that does
not support WWW-Authenticate challenges, you must use a browser to manually
obtain a token from
<literal>&lt;namespace_route&gt;/oauth/token/request</literal>.</simpara>
</note>
</section>
<section xml:id="authentication-api-impersonation_understanding-authentication">
<title>API impersonation</title>
<simpara>You can configure a request to the OpenShift Container Platform API to act as though it originated from another user. For more information, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation">User impersonation</link> in the Kubernetes documentation.</simpara>
</section>
<section xml:id="authentication-prometheus-system-metrics_understanding-authentication">
<title>Authentication metrics for Prometheus</title>
<simpara>OpenShift Container Platform captures the following Prometheus system metrics during authentication attempts:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>openshift_auth_basic_password_count</literal> counts the number of <literal>oc login</literal> user name and password attempts.</simpara>
</listitem>
<listitem>
<simpara><literal>openshift_auth_basic_password_count_result</literal> counts the number of <literal>oc login</literal> user name and password attempts by result, <literal>success</literal> or <literal>error</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>openshift_auth_form_password_count</literal> counts the number of web console login attempts.</simpara>
</listitem>
<listitem>
<simpara><literal>openshift_auth_form_password_count_result</literal> counts the number of web console login attempts by result, <literal>success</literal> or <literal>error</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>openshift_auth_password_total</literal> counts the total number of <literal>oc login</literal> and web console login attempts.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="configuring-internal-oauth">
<title>Configuring the internal OAuth server</title>

<section xml:id="oauth-server-overview_configuring-internal-oauth">
<title>OpenShift Container Platform OAuth server</title>
<simpara>The OpenShift Container Platform master includes a built-in OAuth server. Users obtain OAuth
access tokens to authenticate themselves to the API.</simpara>
<simpara>When a person requests a new OAuth token, the OAuth server uses the configured
identity provider
to determine the identity of the person making the request.</simpara>
<simpara>It then determines what user that identity maps to, creates an access token for
that user, and returns the token for use.</simpara>
</section>
<section xml:id="oauth-token-request-flows_configuring-internal-oauth">
<title>OAuth token request flows and responses</title>
<simpara>The OAuth server supports standard
<link xlink:href="https://tools.ietf.org/html/rfc6749#section-4.1">authorization code grant</link>
and the <link xlink:href="https://tools.ietf.org/html/rfc6749#section-4.2">implicit grant</link>
OAuth authorization flows.</simpara>
<simpara>When requesting an OAuth token using the implicit grant flow
(<literal>response_type=token</literal>) with a client_id configured to request <literal>WWW-Authenticate challenges</literal>
(like <literal>openshift-challenging-client</literal>), these are the possible server
responses from <literal>/oauth/authorize</literal>, and how they should be handled:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="11.1111*"/>
<colspec colname="col_2" colwidth="44.4444*"/>
<colspec colname="col_3" colwidth="44.4445*"/>
<thead>
<row>
<entry align="left" valign="top">Status</entry>
<entry align="left" valign="top">Content</entry>
<entry align="left" valign="top">Client response</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>302</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Location</literal> header containing an <literal>access_token</literal> parameter in the URL fragment (<link xlink:href="https://tools.ietf.org/html/rfc6749#section-4.2.2">RFC 6749 section 4.2.2</link>)</simpara></entry>
<entry align="left" valign="top"><simpara>Use the <literal>access_token</literal> value as the OAuth token.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>302</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Location</literal> header containing an <literal>error</literal> query parameter (<link xlink:href="https://tools.ietf.org/html/rfc6749#section-4.1.2.1">RFC 6749 section 4.1.2.1</link>)</simpara></entry>
<entry align="left" valign="top"><simpara>Fail, optionally surfacing the <literal>error</literal> (and optional <literal>error_description</literal>) query values to the user.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>302</simpara></entry>
<entry align="left" valign="top"><simpara>Other <literal>Location</literal> header</simpara></entry>
<entry align="left" valign="top"><simpara>Follow the redirect, and process the result using these rules.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>401</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WWW-Authenticate</literal> header present</simpara></entry>
<entry align="left" valign="top"><simpara>Respond to challenge if type is recognized (e.g. <literal>Basic</literal>, <literal>Negotiate</literal>, etc), resubmit request, and process the result using these rules.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>401</simpara></entry>
<entry align="left" valign="top"><simpara><literal>WWW-Authenticate</literal> header missing</simpara></entry>
<entry align="left" valign="top"><simpara>No challenge authentication is possible. Fail and show response body (which might contain links or details on alternate methods to obtain an OAuth token).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Other</simpara></entry>
<entry align="left" valign="top"><simpara>Other</simpara></entry>
<entry align="left" valign="top"><simpara>Fail, optionally surfacing response body to the user.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="oauth-internal-options_configuring-internal-oauth">
<title>Options for the internal OAuth server</title>
<simpara>Several configuration options are available for the internal OAuth server.</simpara>
<section xml:id="oauth-token-duration_configuring-internal-oauth">
<title>OAuth token duration options</title>
<simpara>The internal OAuth server generates two kinds of tokens:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Token</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Access tokens</simpara></entry>
<entry align="left" valign="top"><simpara>Longer-lived tokens that grant access to the API.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Authorize codes</simpara></entry>
<entry align="left" valign="top"><simpara>Short-lived tokens whose only use is to be exchanged for
an access token.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>You can configure the default duration for both types of token. If necessary,
you can override the duration of the access token by using an <literal>OAuthClient</literal>
object definition.</simpara>
</section>
<section xml:id="oauth-grant-options_configuring-internal-oauth">
<title>OAuth grant options</title>
<simpara>When the OAuth server receives token requests for a client to which the user
has not previously granted permission, the action that the OAuth server
takes is dependent on the OAuth client&#8217;s grant strategy.</simpara>
<simpara>The OAuth client requesting token must provide its own grant strategy.</simpara>
<simpara>You can apply the following default methods:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Grant option</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>auto</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Auto-approve the grant and retry the request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>prompt</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Prompt the user to approve or deny the grant.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="oauth-configuring-internal-oauth_configuring-internal-oauth">
<title>Configuring the internal OAuth server&#8217;s token duration</title>
<simpara>You can configure default options for the internal OAuth server&#8217;s
token duration.</simpara>
<important>
<simpara>By default, tokens are only valid for 24 hours. Existing sessions
expire after this time elapses.</simpara>
</important>
<simpara>If the default time is insufficient, then this can be modified using
the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a configuration file that contains the token duration options. The
following file sets this to 48 hours, twice the default.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  tokenConfig:
    accessTokenMaxAgeSeconds: 172800 <co xml:id="CO1-1"/></programlisting>
<calloutlist>
<callout arearefs="CO1-1">
<para>Set <literal>accessTokenMaxAgeSeconds</literal> to control the lifetime of access tokens.
The default lifetime is 24 hours, or 86400 seconds. This attribute cannot
be negative. If set to zero, the default lifetime is used.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Apply the new configuration file:</simpara>
<note>
<simpara>Because you update the existing OAuth server, you must use the <literal>oc apply</literal>
command to apply the change.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/file.yaml&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the changes are in effect:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe oauth.config.openshift.io/cluster</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
Spec:
  Token Config:
    Access Token Max Age Seconds:  172800
...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="oauth-token-inactivity-timeout_configuring-internal-oauth">
<title>Configuring token inactivity timeout for the internal OAuth server</title>
<simpara>You can configure OAuth tokens to expire after a set period of inactivity. By default, no token inactivity timeout is set.</simpara>
<note>
<simpara>If the token inactivity timeout is also configured in your OAuth client, that value overrides the timeout that is set in the internal OAuth server configuration.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have configured an identity provider (IDP).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>OAuth</literal> configuration to set a token inactivity timeout.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>OAuth</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit oauth cluster</programlisting>
<simpara>Add the <literal>spec.tokenConfig.accessTokenInactivityTimeout</literal> field and set your timeout value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
...
spec:
  tokenConfig:
    accessTokenInactivityTimeout: 400s <co xml:id="CO2-1"/></programlisting>
<calloutlist>
<callout arearefs="CO2-1">
<para>Set a value with the appropriate units, for example <literal>400s</literal> for 400 seconds, or <literal>30m</literal> for 30 minutes. The minimum allowed timeout value is <literal>300s</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Check that the OAuth server pods have restarted:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperators authentication</programlisting>
<simpara>Do not continue to the next step until <literal>PROGRESSING</literal> is listed as <literal>False</literal>, as shown in the following output:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
authentication   4.14.0    True        False         False      145m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that a new revision of the Kubernetes API server pods has rolled out. This will take several minutes.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clusteroperators kube-apiserver</programlisting>
<simpara>Do not continue to the next step until <literal>PROGRESSING</literal> is listed as <literal>False</literal>, as shown in the following output:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME             VERSION   AVAILABLE   PROGRESSING   DEGRADED   SINCE
kube-apiserver   4.14.0     True        False         False      145m</programlisting>
</para>
</formalpara>
<simpara>If <literal>PROGRESSING</literal> is showing <literal>True</literal>, wait a few minutes and try again.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Log in to the cluster with an identity from your IDP.</simpara>
</listitem>
<listitem>
<simpara>Execute a command and verify that it was successful.</simpara>
</listitem>
<listitem>
<simpara>Wait longer than the configured timeout without using the identity. In this procedure&#8217;s example, wait longer than 400 seconds.</simpara>
</listitem>
<listitem>
<simpara>Try to execute a command from the same identity&#8217;s session.</simpara>
<simpara>This command should fail because the token should have expired due to inactivity longer than the configured timeout.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">error: You must be logged in to the server (Unauthorized)</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="customizing-the-oauth-server-url_configuring-internal-oauth">
<title>Customizing the internal OAuth server URL</title>
<simpara>You can customize the internal OAuth server URL by setting the custom hostname and TLS certificate in the <literal>spec.componentRoutes</literal> field of the cluster <literal>Ingress</literal> configuration.</simpara>
<warning>
<simpara>If you update the internal OAuth server URL, you might break trust from components in the cluster that need to communicate with the OpenShift OAuth server to retrieve OAuth access tokens. Components that need to trust the OAuth server will need to include the proper CA bundle when calling OAuth endpoints. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt; -p &lt;password&gt; --certificate-authority=&lt;path_to_ca.crt&gt; <co xml:id="CO3-1"/></programlisting>
<calloutlist>
<callout arearefs="CO3-1">
<para>For self-signed certificates, the <literal>ca.crt</literal> file must contain the custom CA certificate, otherwise the login will not succeed.</para>
</callout>
</calloutlist>
<simpara>The Cluster Authentication Operator publishes the OAuth server&#8217;s serving certificate in the <literal>oauth-serving-cert</literal> config map in the <literal>openshift-config-managed</literal> namespace. You can find the certificate in the <literal>data.ca-bundle.crt</literal> key of the config map.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have logged in to the cluster as a user with administrative privileges.</simpara>
</listitem>
<listitem>
<simpara>You have created a secret in the <literal>openshift-config</literal> namespace containing the TLS certificate and key. This is required if the domain for the custom hostname suffix does not match the cluster domain suffix. The secret is optional if the suffix matches.</simpara>
<tip>
<simpara>You can create a TLS secret by using the <literal>oc create secret tls</literal> command.</simpara>
</tip>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the cluster <literal>Ingress</literal> configuration:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit ingress.config.openshift.io cluster</programlisting>
</listitem>
<listitem>
<simpara>Set the custom hostname and optionally the serving certificate and key:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Ingress
metadata:
  name: cluster
spec:
  componentRoutes:
    - name: oauth-openshift
      namespace: openshift-authentication
      hostname: &lt;custom_hostname&gt; <co xml:id="CO4-1"/>
      servingCertKeyPairSecret:
        name: &lt;secret_name&gt; <co xml:id="CO4-2"/></programlisting>
<calloutlist>
<callout arearefs="CO4-1">
<para>The custom hostname.</para>
</callout>
<callout arearefs="CO4-2">
<para>Reference to a secret in the <literal>openshift-config</literal> namespace that contains a TLS certificate (<literal>tls.crt</literal>) and key (<literal>tls.key</literal>). This is required if the domain for the custom hostname suffix does not match the cluster domain suffix. The secret is optional if the suffix matches.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="oauth-server-metadata_configuring-internal-oauth">
<title>OAuth server metadata</title>
<simpara>Applications running in OpenShift Container Platform might have to discover information
about the built-in OAuth server. For example, they might have to discover
what the address of the <literal>&lt;namespace_route&gt;</literal> is without manual
configuration.  To aid in this, OpenShift Container Platform implements the IETF
<link xlink:href="https://tools.ietf.org/html/draft-ietf-oauth-discovery-10">OAuth 2.0 Authorization Server Metadata</link> draft specification.</simpara>
<simpara>Thus, any application running inside the cluster can issue a <literal>GET</literal> request
to <emphasis role="strong"><emphasis>https://openshift.default.svc/.well-known/oauth-authorization-server</emphasis></emphasis>
to fetch the following information:</simpara>
<screen>{
  "issuer": "https://&lt;namespace_route&gt;", <co xml:id="CO5-1"/>
  "authorization_endpoint": "https://&lt;namespace_route&gt;/oauth/authorize", <co xml:id="CO5-2"/>
  "token_endpoint": "https://&lt;namespace_route&gt;/oauth/token", <co xml:id="CO5-3"/>
  "scopes_supported": [ <co xml:id="CO5-4"/>
    "user:full",
    "user:info",
    "user:check-access",
    "user:list-scoped-projects",
    "user:list-projects"
  ],
  "response_types_supported": [ <co xml:id="CO5-5"/>
    "code",
    "token"
  ],
  "grant_types_supported": [ <co xml:id="CO5-6"/>
    "authorization_code",
    "implicit"
  ],
  "code_challenge_methods_supported": [ <co xml:id="CO5-7"/>
    "plain",
    "S256"
  ]
}</screen>
<calloutlist>
<callout arearefs="CO5-1">
<para>The authorization server&#8217;s issuer identifier, which is a URL that uses the
<literal>https</literal> scheme and has no query or fragment components. This is the location
where <literal>.well-known</literal> <link xlink:href="https://tools.ietf.org/html/rfc5785">RFC 5785</link> resources
containing information about the authorization server are published.</para>
</callout>
<callout arearefs="CO5-2">
<para>URL of the authorization server&#8217;s authorization endpoint. See
<link xlink:href="https://tools.ietf.org/html/rfc6749">RFC 6749</link>.</para>
</callout>
<callout arearefs="CO5-3">
<para>URL of the authorization server&#8217;s token endpoint. See
<link xlink:href="https://tools.ietf.org/html/rfc6749">RFC 6749</link>.</para>
</callout>
<callout arearefs="CO5-4">
<para>JSON array containing a list of the OAuth 2.0
<link xlink:href="https://tools.ietf.org/html/rfc6749">RFC 6749</link> scope values that this
authorization server supports. Note that not all supported scope values are
advertised.</para>
</callout>
<callout arearefs="CO5-5">
<para>JSON array containing a list of the OAuth 2.0 <literal>response_type</literal> values that this
authorization server supports. The array values used are the same as those used
with the <literal>response_types</literal> parameter defined by "OAuth 2.0 Dynamic Client
Registration Protocol" in <link xlink:href="https://tools.ietf.org/html/rfc7591">RFC 7591</link>.</para>
</callout>
<callout arearefs="CO5-6">
<para>JSON array containing a list of the OAuth 2.0 grant type values that this
authorization server supports. The array values used are the same as those used
with the <literal>grant_types</literal> parameter defined by
<literal>OAuth 2.0 Dynamic Client Registration Protocol</literal> in
<link xlink:href="https://tools.ietf.org/html/rfc7591">RFC 7591</link>.</para>
</callout>
<callout arearefs="CO5-7">
<para>JSON array containing a list of PKCE
<link xlink:href="https://tools.ietf.org/html/rfc7636">RFC 7636</link> code challenge methods
supported by this authorization server. Code challenge method values are used in
the <literal>code_challenge_method</literal> parameter defined in
<link xlink:href="https://tools.ietf.org/html/rfc7636#section-4.3">Section 4.3 of RFC 7636</link>.
The valid code challenge method values are those registered in the IANA
<literal>PKCE Code Challenge Methods</literal> registry.  See
<link xlink:href="http://www.iana.org/assignments/oauth-parameters">IANA OAuth Parameters</link>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="oauth-troubleshooting-api-events_configuring-internal-oauth">
<title>Troubleshooting OAuth API events</title>
<simpara>In some cases the API server returns an <literal>unexpected condition</literal> error message
that is difficult to debug without direct access to the API master log.
The underlying reason for the error is purposely obscured in order
to avoid providing an unauthenticated user with information about the server&#8217;s state.</simpara>
<simpara>A subset of these errors is related to service account OAuth configuration issues.
These issues are captured in events that can be viewed by non-administrator users. When encountering
an <literal>unexpected condition</literal> server error during OAuth, run <literal>oc get events</literal> to view these events under <literal>ServiceAccount</literal>.</simpara>
<simpara>The following example warns of a service account that is missing a proper OAuth redirect URI:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events | grep ServiceAccount</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">1m         1m          1         proxy                    ServiceAccount                                  Warning   NoSAOAuthRedirectURIs   service-account-oauth-client-getter   system:serviceaccount:myproject:proxy has no redirectURIs; set serviceaccounts.openshift.io/oauth-redirecturi.&lt;some-value&gt;=&lt;redirect&gt; or create a dynamic URI using serviceaccounts.openshift.io/oauth-redirectreference.&lt;some-value&gt;=&lt;reference&gt;</programlisting>
</para>
</formalpara>
<simpara>Running <literal>oc describe sa/&lt;service_account_name&gt;</literal> reports any OAuth events associated with the given service account name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe sa/proxy | grep -A5 Events</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Events:
  FirstSeen     LastSeen        Count   From                                    SubObjectPath   Type            Reason                  Message
  ---------     --------        -----   ----                                    -------------   --------        ------                  -------
  3m            3m              1       service-account-oauth-client-getter                     Warning         NoSAOAuthRedirectURIs   system:serviceaccount:myproject:proxy has no redirectURIs; set serviceaccounts.openshift.io/oauth-redirecturi.&lt;some-value&gt;=&lt;redirect&gt; or create a dynamic URI using serviceaccounts.openshift.io/oauth-redirectreference.&lt;some-value&gt;=&lt;reference&gt;</programlisting>
</para>
</formalpara>
<simpara>The following is a list of the possible event errors:</simpara>
<simpara><emphasis role="strong">No redirect URI annotations or an invalid URI is specified</emphasis></simpara>
<programlisting language="terminal" linenumbering="unnumbered">Reason                  Message
NoSAOAuthRedirectURIs   system:serviceaccount:myproject:proxy has no redirectURIs; set serviceaccounts.openshift.io/oauth-redirecturi.&lt;some-value&gt;=&lt;redirect&gt; or create a dynamic URI using serviceaccounts.openshift.io/oauth-redirectreference.&lt;some-value&gt;=&lt;reference&gt;</programlisting>
<simpara><emphasis role="strong">Invalid route specified</emphasis></simpara>
<programlisting language="terminal" linenumbering="unnumbered">Reason                  Message
NoSAOAuthRedirectURIs   [routes.route.openshift.io "&lt;name&gt;" not found, system:serviceaccount:myproject:proxy has no redirectURIs; set serviceaccounts.openshift.io/oauth-redirecturi.&lt;some-value&gt;=&lt;redirect&gt; or create a dynamic URI using serviceaccounts.openshift.io/oauth-redirectreference.&lt;some-value&gt;=&lt;reference&gt;]</programlisting>
<simpara><emphasis role="strong">Invalid reference type specified</emphasis></simpara>
<programlisting language="terminal" linenumbering="unnumbered">Reason                  Message
NoSAOAuthRedirectURIs   [no kind "&lt;name&gt;" is registered for version "v1", system:serviceaccount:myproject:proxy has no redirectURIs; set serviceaccounts.openshift.io/oauth-redirecturi.&lt;some-value&gt;=&lt;redirect&gt; or create a dynamic URI using serviceaccounts.openshift.io/oauth-redirectreference.&lt;some-value&gt;=&lt;reference&gt;]</programlisting>
<simpara><emphasis role="strong">Missing SA tokens</emphasis></simpara>
<programlisting language="terminal" linenumbering="unnumbered">Reason                  Message
NoSAOAuthTokens         system:serviceaccount:myproject:proxy has no tokens</programlisting>
</section>
</chapter>
<chapter xml:id="configuring-oauth-clients">
<title>Configuring OAuth clients</title>

<simpara>Several OAuth clients are created by default in OpenShift Container Platform. You can also register and configure additional OAuth clients.</simpara>
<section xml:id="oauth-default-clients_configuring-oauth-clients">
<title>Default OAuth clients</title>
<simpara>The following OAuth clients are automatically created when starting the OpenShift Container Platform API:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="40*"/>
<colspec colname="col_2" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">OAuth client</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>openshift-browser-client</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Requests tokens at <literal>&lt;namespace_route&gt;/oauth/token/request</literal> with a user-agent that can handle interactive logins. <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift-challenging-client</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Requests tokens with a user-agent that can handle <literal>WWW-Authenticate</literal> challenges.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>openshift-cli-client</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Requests tokens by using a local HTTP server fetching an authorization code grant.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>&lt;namespace_route&gt;</literal> refers to the namespace route. This is found by
running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get route oauth-openshift -n openshift-authentication -o json | jq .spec.host</programlisting>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="oauth-register-additional-client_configuring-oauth-clients">
<title>Registering an additional OAuth client</title>
<simpara>If you need an additional OAuth client to manage authentication for your
OpenShift Container Platform cluster, you can register one.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To register additional OAuth clients:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;(echo '
kind: OAuthClient
apiVersion: oauth.openshift.io/v1
metadata:
 name: demo <co xml:id="CO6-1"/>
secret: "..." <co xml:id="CO6-2"/>
redirectURIs:
 - "http://www.example.com/" <co xml:id="CO6-3"/>
grantMethod: prompt <co xml:id="CO6-4"/>
')</programlisting>
<calloutlist>
<callout arearefs="CO6-1">
<para>The <literal>name</literal> of the OAuth client is used as the <literal>client_id</literal> parameter when
making requests to <literal>&lt;namespace_route&gt;/oauth/authorize</literal> and
<literal>&lt;namespace_route&gt;/oauth/token</literal>.</para>
</callout>
<callout arearefs="CO6-2">
<para>The <literal>secret</literal> is used as the <literal>client_secret</literal> parameter when making requests
to <literal>&lt;namespace_route&gt;/oauth/token</literal>.</para>
</callout>
<callout arearefs="CO6-3">
<para>The <literal>redirect_uri</literal> parameter specified in requests to
<literal>&lt;namespace_route&gt;/oauth/authorize</literal> and <literal>&lt;namespace_route&gt;/oauth/token</literal>
 must be equal to or prefixed by one of the URIs listed in the
<literal>redirectURIs</literal> parameter value.</para>
</callout>
<callout arearefs="CO6-4">
<para>The <literal>grantMethod</literal> is used to determine what action to take when this
client requests tokens and has not yet been granted access by the user.
Specify <literal>auto</literal> to automatically approve the grant and retry the request,
or <literal>prompt</literal> to prompt the user to approve or deny the grant.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="oauth-token-inactivity-timeout_configuring-oauth-clients">
<title>Configuring token inactivity timeout for an OAuth client</title>
<simpara>You can configure OAuth clients to expire OAuth tokens after a set period of inactivity. By default, no token inactivity timeout is set.</simpara>
<note>
<simpara>If the token inactivity timeout is also configured in the internal OAuth server configuration, the timeout that is set in the OAuth client overrides that value.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have configured an identity provider (IDP).</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>OAuthClient</literal> configuration to set a token inactivity timeout.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>OAuthClient</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit oauthclient &lt;oauth_client&gt; <co xml:id="CO7-1"/></programlisting>
<calloutlist>
<callout arearefs="CO7-1">
<para>Replace <literal>&lt;oauth_client&gt;</literal> with the OAuth client to configure, for example, <literal>console</literal>.</para>
</callout>
</calloutlist>
<simpara>Add the <literal>accessTokenInactivityTimeoutSeconds</literal> field and set your timeout value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: oauth.openshift.io/v1
grantMethod: auto
kind: OAuthClient
metadata:
...
accessTokenInactivityTimeoutSeconds: 600 <co xml:id="CO8-1"/></programlisting>
<calloutlist>
<callout arearefs="CO8-1">
<para>The minimum allowed timeout value in seconds is <literal>300</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Log in to the cluster with an identity from your IDP. Be sure to use the OAuth client that you just configured.</simpara>
</listitem>
<listitem>
<simpara>Perform an action and verify that it was successful.</simpara>
</listitem>
<listitem>
<simpara>Wait longer than the configured timeout without using the identity. In this procedure&#8217;s example, wait longer than 600 seconds.</simpara>
</listitem>
<listitem>
<simpara>Try to perform an action from the same identity&#8217;s session.</simpara>
<simpara>This attempt should fail because the token should have expired due to inactivity longer than the configured timeout.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional_resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../rest_api/oauth_apis/oauthclient-oauth-openshift-io-v1.xml#oauthclient-oauth-openshift-io-v1">OAuthClient [oauth.openshift.io/v1</link>]</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="managing-oauth-access-tokens">
<title>Managing user-owned OAuth access tokens</title>

<simpara>Users can review their own OAuth access tokens and delete any that are no longer needed.</simpara>
<section xml:id="oauth-list-tokens_managing-oauth-access-tokens">
<title>Listing user-owned OAuth access tokens</title>
<simpara>You can list your user-owned OAuth access tokens. Token names are not sensitive and cannot be used to log in.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>List all user-owned OAuth access tokens:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get useroauthaccesstokens</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       CLIENT NAME                    CREATED                EXPIRES                         REDIRECT URI                                                       SCOPES
&lt;token1&gt;   openshift-challenging-client   2021-01-11T19:25:35Z   2021-01-12 19:25:35 +0000 UTC   https://oauth-openshift.apps.example.com/oauth/token/implicit      user:full
&lt;token2&gt;   openshift-browser-client       2021-01-11T19:27:06Z   2021-01-12 19:27:06 +0000 UTC   https://oauth-openshift.apps.example.com/oauth/token/display       user:full
&lt;token3&gt;   console                        2021-01-11T19:26:29Z   2021-01-12 19:26:29 +0000 UTC   https://console-openshift-console.apps.example.com/auth/callback   user:full</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>List user-owned OAuth access tokens for a particular OAuth client:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get useroauthaccesstokens --field-selector=clientName="console"</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       CLIENT NAME                    CREATED                EXPIRES                         REDIRECT URI                                                       SCOPES
&lt;token3&gt;   console                        2021-01-11T19:26:29Z   2021-01-12 19:26:29 +0000 UTC   https://console-openshift-console.apps.example.com/auth/callback   user:full</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="oauth-view-details-tokens_managing-oauth-access-tokens">
<title>Viewing the details of a user-owned OAuth access token</title>
<simpara>You can view the details of a user-owned OAuth access token.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Describe the details of a user-owned OAuth access token:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe useroauthaccesstokens &lt;token_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                        &lt;token_name&gt; <co xml:id="CO9-1"/>
Namespace:
Labels:                      &lt;none&gt;
Annotations:                 &lt;none&gt;
API Version:                 oauth.openshift.io/v1
Authorize Token:             sha256~Ksckkug-9Fg_RWn_AUysPoIg-_HqmFI9zUL_CgD8wr8
Client Name:                 openshift-browser-client <co xml:id="CO9-2"/>
Expires In:                  86400 <co xml:id="CO9-3"/>
Inactivity Timeout Seconds:  317 <co xml:id="CO9-4"/>
Kind:                        UserOAuthAccessToken
Metadata:
  Creation Timestamp:  2021-01-11T19:27:06Z
  Managed Fields:
    API Version:  oauth.openshift.io/v1
    Fields Type:  FieldsV1
    fieldsV1:
      f:authorizeToken:
      f:clientName:
      f:expiresIn:
      f:redirectURI:
      f:scopes:
      f:userName:
      f:userUID:
    Manager:         oauth-server
    Operation:       Update
    Time:            2021-01-11T19:27:06Z
  Resource Version:  30535
  Self Link:         /apis/oauth.openshift.io/v1/useroauthaccesstokens/&lt;token_name&gt;
  UID:               f9d00b67-ab65-489b-8080-e427fa3c6181
Redirect URI:        https://oauth-openshift.apps.example.com/oauth/token/display
Scopes:
  user:full <co xml:id="CO9-5"/>
User Name:  &lt;user_name&gt; <co xml:id="CO9-6"/>
User UID:   82356ab0-95f9-4fb3-9bc0-10f1d6a6a345
Events:     &lt;none&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para>The token name, which is the sha256 hash of the token. Token names are not sensitive and cannot be used to log in.</para>
</callout>
<callout arearefs="CO9-2">
<para>The client name, which describes where the token originated from.</para>
</callout>
<callout arearefs="CO9-3">
<para>The value in seconds from the creation time before this token expires.</para>
</callout>
<callout arearefs="CO9-4">
<para>If there is a token inactivity timeout set for the OAuth server, this is the value in seconds from the creation time before this token can no longer be used.</para>
</callout>
<callout arearefs="CO9-5">
<para>The scopes for this token.</para>
</callout>
<callout arearefs="CO9-6">
<para>The user name associated with this token.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="oauth-delete-tokens_managing-oauth-access-tokens">
<title>Deleting user-owned OAuth access tokens</title>
<simpara>The <literal>oc logout</literal> command only invalidates the OAuth token for the active session. You can use the following procedure to delete any user-owned OAuth tokens that are no longer needed.</simpara>
<simpara>Deleting an OAuth access token logs out the user from all sessions that use the token.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Delete the user-owned OAuth access token:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete useroauthaccesstokens &lt;token_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">useroauthaccesstoken.oauth.openshift.io "&lt;token_name&gt;" deleted</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="understanding-identity-provider">
<title>Understanding identity provider configuration</title>

<simpara>The OpenShift Container Platform master includes a built-in OAuth server. Developers and
administrators obtain OAuth access tokens to authenticate themselves to the API.</simpara>
<simpara>As an administrator, you can configure OAuth to specify an identity provider
after you install your cluster.</simpara>
<section xml:id="identity-provider-overview_understanding-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="supported-identity-providers">
<title>Supported identity providers</title>
<simpara>You can configure the following types of identity providers:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Identity provider</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#configuring-htpasswd-identity-provider">htpasswd</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the <literal>htpasswd</literal> identity provider to validate user names and passwords
against a flat file generated using
<link xlink:href="http://httpd.apache.org/docs/2.4/programs/htpasswd.html"><literal>htpasswd</literal></link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-keystone-identity-provider.xml#configuring-keystone-identity-provider">Keystone</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the <literal>keystone</literal> identity provider to integrate
your OpenShift Container Platform cluster with Keystone to enable shared authentication with
an OpenStack Keystone v3 server configured to store users in an internal
database.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-ldap-identity-provider.xml#configuring-ldap-identity-provider">LDAP</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure the <literal>ldap</literal> identity provider to validate user names and passwords
against an LDAPv3 server, using simple bind authentication.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-basic-authentication-identity-provider.xml#configuring-basic-authentication-identity-provider">Basic authentication</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure a <literal>basic-authentication</literal> identity provider for users to log in to
OpenShift Container Platform with credentials validated against a remote identity provider.
Basic authentication is a generic backend integration mechanism.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-request-header-identity-provider.xml#configuring-request-header-identity-provider">Request header</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure a <literal>request-header</literal> identity provider to identify users from request
header values, such as <literal>X-Remote-User</literal>. It is typically used in combination with
an authenticating proxy, which sets the request header value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-github-identity-provider.xml#configuring-github-identity-provider">GitHub or GitHub Enterprise</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure a <literal>github</literal> identity provider to validate user names and passwords
against GitHub or GitHub Enterprise&#8217;s OAuth authentication server.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-gitlab-identity-provider.xml#configuring-gitlab-identity-provider">GitLab</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure a <literal>gitlab</literal> identity provider to use
<link xlink:href="https://gitlab.com/">GitLab.com</link> or any other GitLab instance as an identity
provider.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-google-identity-provider.xml#configuring-google-identity-provider">Google</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure a <literal>google</literal> identity provider using
<link xlink:href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OpenID Connect integration</link>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="../authentication/identity_providers/configuring-oidc-identity-provider.xml#configuring-oidc-identity-provider">OpenID Connect</link></simpara></entry>
<entry align="left" valign="top"><simpara>Configure an <literal>oidc</literal> identity provider to integrate with an OpenID Connect
identity provider using an
<link xlink:href="http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Authorization Code Flow</link>.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Once an identity provider has been defined, you can
<link xlink:href="../authentication/using-rbac.xml#authorization-overview_using-rbac">use RBAC to define and apply permissions</link>.</simpara>
</section>
<section xml:id="removing-kubeadmin_understanding-identity-provider">
<title>Removing the kubeadmin user</title>
<simpara>After you define an identity provider and create a new <literal>cluster-admin</literal>
user, you can remove the <literal>kubeadmin</literal> to improve cluster security.</simpara>
<warning>
<simpara>If you follow this procedure before another user is a <literal>cluster-admin</literal>,
then OpenShift Container Platform must be reinstalled. It is not possible to undo
this command.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have configured at least one identity provider.</simpara>
</listitem>
<listitem>
<simpara>You must have added the <literal>cluster-admin</literal> role to a user.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Remove the <literal>kubeadmin</literal> secrets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secrets kubeadmin -n kube-system</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-parameters_understanding-identity-provider">
<title>Identity provider parameters</title>
<simpara>The following parameters are common to all identity providers:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The provider name is prefixed to provider user names to form an
identity name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mappingMethod</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines how new identities are mapped to users when they log in.
Enter one of the following values:</simpara>
<variablelist>
<varlistentry>
<term>claim</term>
<listitem>
<simpara>The default value. Provisions a user with the identity&#8217;s preferred
user name. Fails if a user with that user name is already mapped to another
identity.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>lookup</term>
<listitem>
<simpara>Looks up an existing identity, user identity mapping, and user,
but does not automatically provision users or identities. This allows cluster
administrators to set up identities and users manually, or using an external
process. Using this method requires you to manually provision users.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>add</term>
<listitem>
<simpara>Provisions a user with the identity&#8217;s preferred user name. If a user
with that user name already exists, the identity is mapped to the existing user,
adding to any existing identity mappings for the user. Required when multiple
identity providers are configured that identify the same set of users and map to
the same user names.</simpara>
</listitem>
</varlistentry>
</variablelist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>When adding or changing identity providers, you can map identities from the new
provider to existing users by setting the <literal>mappingMethod</literal> parameter to
<literal>add</literal>.</simpara>
</note>
</section>
<section xml:id="identity-provider-default-CR_understanding-identity-provider">
<title>Sample identity provider CR</title>
<simpara>The following custom resource (CR) shows the parameters and default
values that you use to configure an identity provider. This example
uses the htpasswd identity provider.</simpara>
<formalpara>
<title>Sample identity provider CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: my_identity_provider <co xml:id="CO10-1"/>
    mappingMethod: claim <co xml:id="CO10-2"/>
    type: HTPasswd
    htpasswd:
      fileData:
        name: htpass-secret <co xml:id="CO10-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO10-1">
<para>This provider name is prefixed to provider user names to form an
identity name.</para>
</callout>
<callout arearefs="CO10-2">
<para>Controls how mappings are established between this provider&#8217;s
identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO10-3">
<para>An existing secret containing a file generated using
<link xlink:href="http://httpd.apache.org/docs/2.4/programs/htpasswd.html"><literal>htpasswd</literal></link>.</para>
</callout>
</calloutlist>
</section>
</chapter>
<chapter xml:id="_configuring_identity_providers">
<title>Configuring identity providers</title>
<section xml:id="configuring-htpasswd-identity-provider">
<title>Configuring an htpasswd identity provider</title>

<simpara>Configure the <literal>htpasswd</literal> identity provider to allow users to log in to OpenShift Container Platform with credentials from an htpasswd file.</simpara>
<simpara>To define an htpasswd identity provider, perform the following tasks:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#creating-htpasswd-file">Create an <literal>htpasswd</literal> file</link> to store the user and password information.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#identity-provider-creating-htpasswd-secret_configuring-htpasswd-identity-provider">Create
a secret</link> to represent the <literal>htpasswd</literal> file.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#identity-provider-htpasswd-CR_configuring-htpasswd-identity-provider">Define an htpasswd identity provider resource</link> that references the secret.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#add-identity-provider_configuring-htpasswd-identity-provider">Apply the resource</link> to
the default OAuth configuration to add the identity provider.</simpara>
</listitem>
</orderedlist>
<section xml:id="identity-provider-overview_configuring-htpasswd-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-htpasswd-about_configuring-htpasswd-identity-provider">
<title>About htpasswd authentication</title>
<simpara>Using htpasswd authentication in OpenShift Container Platform allows you to identify users based on an htpasswd file. An htpasswd file is a flat file that contains the user name and hashed password for each user. You can use the <literal>htpasswd</literal> utility to create this file.</simpara>
</section>
<section xml:id="creating-htpasswd-file">
<title>Creating the htpasswd file</title>
<simpara>See one of the following sections for instructions about how to create the htpasswd file:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#identity-provider-creating-htpasswd-file-linux_configuring-htpasswd-identity-provider">Creating an htpasswd file using Linux</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/identity_providers/configuring-htpasswd-identity-provider.xml#identity-provider-creating-htpasswd-file-windows_configuring-htpasswd-identity-provider">Creating an htpasswd file using Windows</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="identity-provider-creating-htpasswd-file-linux_configuring-htpasswd-identity-provider">
<title>Creating an htpasswd file using Linux</title>
<simpara>To use the htpasswd identity provider, you must generate a flat file that
contains the user names and passwords for your cluster by using
<link xlink:href="http://httpd.apache.org/docs/2.4/programs/htpasswd.html"><literal>htpasswd</literal></link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have access to the <literal>htpasswd</literal> utility. On Red Hat Enterprise Linux
this is available by installing the <literal>httpd-tools</literal> package.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create or update your flat file with a user name and hashed password:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ htpasswd -c -B -b &lt;/path/to/users.htpasswd&gt; &lt;username&gt; &lt;password&gt;</programlisting>
<simpara>The command generates a hashed version of the password.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ htpasswd -c -B -b users.htpasswd &lt;username&gt; &lt;password&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Adding password for user user1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Continue to add or update credentials to the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ htpasswd -B -b &lt;/path/to/users.htpasswd&gt; &lt;user_name&gt; &lt;password&gt;</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="identity-provider-creating-htpasswd-file-windows_configuring-htpasswd-identity-provider">
<title>Creating an htpasswd file using Windows</title>
<simpara>To use the htpasswd identity provider, you must generate a flat file that
contains the user names and passwords for your cluster by using
<link xlink:href="http://httpd.apache.org/docs/2.4/programs/htpasswd.html"><literal>htpasswd</literal></link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have access to <literal>htpasswd.exe</literal>. This file is included in the <literal>\bin</literal>
directory of many Apache httpd distributions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create or update your flat file with a user name and hashed password:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">&gt; htpasswd.exe -c -B -b &lt;\path\to\users.htpasswd&gt; &lt;username&gt; &lt;password&gt;</programlisting>
<simpara>The command generates a hashed version of the password.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">&gt; htpasswd.exe -c -B -b users.htpasswd &lt;username&gt; &lt;password&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Adding password for user user1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Continue to add or update credentials to the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">&gt; htpasswd.exe -b &lt;\path\to\users.htpasswd&gt; &lt;username&gt; &lt;password&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="identity-provider-creating-htpasswd-secret_configuring-htpasswd-identity-provider">
<title>Creating the htpasswd secret</title>
<simpara>To use the htpasswd identity provider, you must define a secret that
contains the htpasswd user file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an htpasswd file.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object that contains the htpasswd users file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic htpass-secret --from-file=htpasswd=&lt;path_to_users.htpasswd&gt; -n openshift-config <co xml:id="CO11-1"/></programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>The secret key containing the users file for the <literal>--from-file</literal> argument must be named <literal>htpasswd</literal>, as shown in the above command.</para>
</callout>
</calloutlist>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: htpass-secret
  namespace: openshift-config
type: Opaque
data:
  htpasswd: &lt;base64_encoded_htpasswd_file_contents&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-htpasswd-CR_configuring-htpasswd-identity-provider">
<title>Sample htpasswd CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for an
htpasswd identity provider.</simpara>
<formalpara>
<title>htpasswd CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: my_htpasswd_provider <co xml:id="CO12-1"/>
    mappingMethod: claim <co xml:id="CO12-2"/>
    type: HTPasswd
    htpasswd:
      fileData:
        name: htpass-secret <co xml:id="CO12-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO12-1">
<para>This provider name is prefixed to provider user names to form an identity
name.</para>
</callout>
<callout arearefs="CO12-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO12-3">
<para>An existing secret containing a file generated using
<link xlink:href="http://httpd.apache.org/docs/2.4/programs/htpasswd.html"><literal>htpasswd</literal></link>.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-htpasswd-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="identity-provider-htpasswd-update-users_configuring-htpasswd-identity-provider">
<title>Updating users for an htpasswd identity provider</title>
<simpara>You can add or remove users from an existing htpasswd identity provider.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created a <literal>Secret</literal> object that contains the htpasswd user file. This procedure assumes that it is named <literal>htpass-secret</literal>.</simpara>
</listitem>
<listitem>
<simpara>You have configured an htpasswd identity provider. This procedure assumes that it is named <literal>my_htpasswd_provider</literal>.</simpara>
</listitem>
<listitem>
<simpara>You have access to the <literal>htpasswd</literal> utility. On Red Hat Enterprise Linux this is available by installing the <literal>httpd-tools</literal> package.</simpara>
</listitem>
<listitem>
<simpara>You have cluster administrator privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Retrieve the htpasswd file from the <literal>htpass-secret</literal> <literal>Secret</literal> object and save the file to your file system:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret htpass-secret -ojsonpath={.data.htpasswd} -n openshift-config | base64 --decode &gt; users.htpasswd</programlisting>
</listitem>
<listitem>
<simpara>Add or remove users from the <literal>users.htpasswd</literal> file.</simpara>
<itemizedlist>
<listitem>
<simpara>To add a new user:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ htpasswd -bB users.htpasswd &lt;username&gt; &lt;password&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Adding password for user &lt;username&gt;</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To remove an existing user:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ htpasswd -D users.htpasswd &lt;username&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Deleting password for user &lt;username&gt;</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Replace the <literal>htpass-secret</literal> <literal>Secret</literal> object with the updated users in the <literal>users.htpasswd</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic htpass-secret --from-file=htpasswd=users.htpasswd --dry-run=client -o yaml -n openshift-config | oc replace -f -</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to replace the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: htpass-secret
  namespace: openshift-config
type: Opaque
data:
  htpasswd: &lt;base64_encoded_htpasswd_file_contents&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>If you removed one or more users, you must additionally remove existing resources for each user.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Delete the <literal>User</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete user &lt;username&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">user.user.openshift.io "&lt;username&gt;" deleted</programlisting>
</para>
</formalpara>
<simpara>Be sure to remove the user, otherwise the user can continue using their token as long as it has not expired.</simpara>
</listitem>
<listitem>
<simpara>Delete the <literal>Identity</literal> object for the user:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete identity my_htpasswd_provider:&lt;username&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">identity.user.openshift.io "my_htpasswd_provider:&lt;username&gt;" deleted</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="identity-provider-configuring-using-the-web-console_configuring-htpasswd-identity-provider">
<title>Configuring identity providers using the web console</title>
<simpara>Configure your identity provider (IDP) through the web console instead of the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must be logged in to the web console as a cluster administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">Configuration</emphasis> tab, click <emphasis role="strong">OAuth</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">Identity Providers</emphasis> section, select your identity provider from the
<emphasis role="strong">Add</emphasis> drop-down menu.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>You can specify multiple IDPs through the web console without overwriting
existing IDPs.</simpara>
</note>
</section>
</section>
<section xml:id="configuring-keystone-identity-provider">
<title>Configuring a Keystone identity provider</title>

<simpara>Configure the <literal>keystone</literal> identity provider to integrate your OpenShift Container Platform cluster with Keystone to enable shared authentication with an OpenStack Keystone v3 server configured to store users in an internal database. This configuration allows users to log in to OpenShift Container Platform with their Keystone credentials.</simpara>
<section xml:id="identity-provider-overview_configuring-keystone-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-keystone-about_configuring-keystone-identity-provider">
<title>About Keystone authentication</title>
<simpara><link xlink:href="http://docs.openstack.org/developer/keystone/">Keystone</link> is an OpenStack project that provides identity, token, catalog, and policy services.</simpara>
<simpara>You can configure the integration with Keystone so that the new OpenShift Container Platform users are based on either the Keystone user names or unique Keystone IDs. With both methods, users log in by entering their Keystone user name and password. Basing the OpenShift Container Platform users on the Keystone ID is more secure because if you delete a Keystone user and create a new Keystone user with that user name, the new user might have access to the old user&#8217;s resources.</simpara>
</section>
<section xml:id="identity-provider-creating-secret-tls_configuring-keystone-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object that contains the key and certificate by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret tls &lt;secret_name&gt; --key=key.pem --cert=cert.pem -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: kubernetes.io/tls
data:
  tls.crt: &lt;base64_encoded_cert&gt;
  tls.key: &lt;base64_encoded_key&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-keystone-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-keystone-CR_configuring-keystone-identity-provider">
<title>Sample Keystone CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for a
Keystone identity provider.</simpara>
<formalpara>
<title>Keystone CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: keystoneidp <co xml:id="CO13-1"/>
    mappingMethod: claim <co xml:id="CO13-2"/>
    type: Keystone
    keystone:
      domainName: default <co xml:id="CO13-3"/>
      url: https://keystone.example.com:5000 <co xml:id="CO13-4"/>
      ca: <co xml:id="CO13-5"/>
        name: ca-config-map
      tlsClientCert: <co xml:id="CO13-6"/>
        name: client-cert-secret
      tlsClientKey: <co xml:id="CO13-7"/>
        name: client-key-secret</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO13-1">
<para>This provider name is prefixed to provider user names to form an identity name.</para>
</callout>
<callout arearefs="CO13-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO13-3">
<para>Keystone domain name. In Keystone, usernames are domain-specific. Only a single domain is supported.</para>
</callout>
<callout arearefs="CO13-4">
<para>The URL to use to connect to the Keystone server (required). This must
use https.</para>
</callout>
<callout arearefs="CO13-5">
<para>Optional: Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
PEM-encoded certificate authority bundle to use in validating server
certificates for the configured URL.</para>
</callout>
<callout arearefs="CO13-6">
<para>Optional: Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client
certificate to present when making requests to the configured URL.</para>
</callout>
<callout arearefs="CO13-7">
<para>Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the key for the
client certificate. Required if <literal>tlsClientCert</literal> is specified.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-keystone-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-ldap-identity-provider">
<title>Configuring an LDAP identity provider</title>

<simpara>Configure the <literal>ldap</literal> identity provider to validate user names and passwords against an LDAPv3 server, using simple bind authentication.</simpara>
<section xml:id="identity-provider-overview_configuring-ldap-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-about-ldap_configuring-ldap-identity-provider">
<title>About LDAP authentication</title>
<simpara>During authentication, the LDAP directory is searched for an entry that matches
the provided user name. If a single unique match is found, a simple bind is
attempted using the distinguished name (DN) of the entry plus the provided
password.</simpara>
<simpara>These are the steps taken:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Generate a search filter by combining the attribute and filter in the
configured <literal>url</literal> with the user-provided user name.</simpara>
</listitem>
<listitem>
<simpara>Search the directory using the generated filter. If the search does not return
exactly one entry, deny access.</simpara>
</listitem>
<listitem>
<simpara>Attempt to bind to the LDAP server using the DN of the entry retrieved from
the search, and the user-provided password.</simpara>
</listitem>
<listitem>
<simpara>If the bind is unsuccessful, deny access.</simpara>
</listitem>
<listitem>
<simpara>If the bind is successful, build an identity using the configured attributes
as the identity, email address, display name, and preferred user name.</simpara>
</listitem>
</orderedlist>
<simpara>The configured <literal>url</literal> is an RFC 2255 URL, which specifies the LDAP host and
search parameters to use. The syntax of the URL is:</simpara>
<screen>ldap://host:port/basedn?attribute?scope?filter</screen>
<simpara>For this URL:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">URL component</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara><literal>ldap</literal></simpara></entry>
<entry align="left" valign="top"><simpara>For regular LDAP, use the string <literal>ldap</literal>. For secure LDAP
(LDAPS), use <literal>ldaps</literal> instead.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>host:port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The name and port of the LDAP server. Defaults to
<literal>localhost:389</literal> for ldap and <literal>localhost:636</literal> for LDAPS.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>basedn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The DN of the branch of the directory where all searches should
start from. At the very least, this must be the top of your directory tree, but
it could also specify a subtree in the directory.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>attribute</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The attribute to search for. Although RFC 2255 allows a
comma-separated list of attributes, only the first attribute will be used, no
matter how many are provided. If no attributes are provided, the default is to
use <literal>uid</literal>. It is recommended to choose an attribute that will be unique across
all entries in the subtree you will be using.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>scope</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The scope of the search. Can be either <literal>one</literal> or <literal>sub</literal>.
If the scope is not provided, the default is to use a scope of <literal>sub</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>filter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A valid LDAP search filter. If not provided, defaults to
<literal>(objectClass=*)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When doing searches, the attribute, filter, and provided user name are combined
to create a search filter that looks like:</simpara>
<screen>(&amp;(&lt;filter&gt;)(&lt;attribute&gt;=&lt;username&gt;))</screen>
<simpara>For example, consider a URL of:</simpara>
<screen>ldap://ldap.example.com/o=Acme?cn?sub?(enabled=true)</screen>
<simpara>When a client attempts to connect using a user name of <literal>bob</literal>, the resulting
search filter will be <literal>(&amp;(enabled=true)(cn=bob))</literal>.</simpara>
<simpara>If the LDAP directory requires authentication to search, specify a <literal>bindDN</literal> and
<literal>bindPassword</literal> to use to perform the entry search.</simpara>
</section>
<section xml:id="identity-provider-creating-ldap-secret_configuring-ldap-identity-provider">
<title>Creating the LDAP secret</title>
<simpara>To use the identity provider, you must define an OpenShift Container Platform <literal>Secret</literal> object that contains the <literal>bindPassword</literal> field.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object that contains the <literal>bindPassword</literal> field:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic ldap-secret --from-literal=bindPassword=&lt;secret&gt; -n openshift-config <co xml:id="CO14-1"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>The secret key containing the bindPassword for the <literal>--from-literal</literal> argument must be called <literal>bindPassword</literal>.</para>
</callout>
</calloutlist>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: ldap-secret
  namespace: openshift-config
type: Opaque
data:
  bindPassword: &lt;base64_encoded_bind_password&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-ldap-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-ldap-CR_configuring-ldap-identity-provider">
<title>Sample LDAP CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for an
LDAP identity provider.</simpara>
<formalpara>
<title>LDAP CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: ldapidp <co xml:id="CO15-1"/>
    mappingMethod: claim <co xml:id="CO15-2"/>
    type: LDAP
    ldap:
      attributes:
        id: <co xml:id="CO15-3"/>
        - dn
        email: <co xml:id="CO15-4"/>
        - mail
        name: <co xml:id="CO15-5"/>
        - cn
        preferredUsername: <co xml:id="CO15-6"/>
        - uid
      bindDN: "" <co xml:id="CO15-7"/>
      bindPassword: <co xml:id="CO15-8"/>
        name: ldap-secret
      ca: <co xml:id="CO15-9"/>
        name: ca-config-map
      insecure: false <co xml:id="CO15-10"/>
      url: "ldaps://ldaps.example.com/ou=users,dc=acme,dc=com?uid" <co xml:id="CO15-11"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO15-1">
<para>This provider name is prefixed to the returned user ID to form an identity
name.</para>
</callout>
<callout arearefs="CO15-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO15-3">
<para>List of attributes to use as the identity. First non-empty attribute is
used. At least one attribute is required. If none of the listed attribute
have a value, authentication fails. Defined attributes are retrieved as raw,
allowing for binary values to be used.</para>
</callout>
<callout arearefs="CO15-4">
<para>List of attributes to use as the email address. First non-empty
attribute is used.</para>
</callout>
<callout arearefs="CO15-5">
<para>List of attributes to use as the display name. First non-empty
attribute is used.</para>
</callout>
<callout arearefs="CO15-6">
<para>List of attributes to use as the preferred user name when provisioning a
user for this identity. First non-empty attribute is used.</para>
</callout>
<callout arearefs="CO15-7">
<para>Optional DN to use to bind during the search phase. Must be set if
<literal>bindPassword</literal> is defined.</para>
</callout>
<callout arearefs="CO15-8">
<para>Optional reference to an OpenShift Container Platform <literal>Secret</literal> object containing the bind
password. Must be set if <literal>bindDN</literal> is defined.</para>
</callout>
<callout arearefs="CO15-9">
<para>Optional: Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
PEM-encoded certificate authority bundle to use in validating server
certificates for the configured URL. Only used when <literal>insecure</literal> is <literal>false</literal>.</para>
</callout>
<callout arearefs="CO15-10">
<para>When <literal>true</literal>, no TLS connection is made to the server. When <literal>false</literal>,
<literal>ldaps://</literal> URLs connect using TLS, and <literal>ldap://</literal> URLs are upgraded to TLS.
This must be set to <literal>false</literal> when <literal>ldaps://</literal> URLs are in use, as these
URLs always attempt to connect using TLS.</para>
</callout>
<callout arearefs="CO15-11">
<para>An RFC 2255 URL which specifies the LDAP host and search parameters to use.</para>
</callout>
</calloutlist>
<note>
<simpara>To whitelist users for an LDAP integration, use the <literal>lookup</literal> mapping method.
Before a login from LDAP would be allowed, a cluster administrator must create
an <literal>Identity</literal> object and a <literal>User</literal> object for each LDAP user.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-ldap-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-basic-authentication-identity-provider">
<title>Configuring a basic authentication identity provider</title>

<simpara>Configure the <literal>basic-authentication</literal> identity provider for users to log in to OpenShift Container Platform with credentials validated against a remote identity provider. Basic authentication is a generic back-end integration mechanism.</simpara>
<section xml:id="identity-provider-overview_configuring-basic-authentication-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-about-basic-authentication_configuring-basic-authentication-identity-provider">
<title>About basic authentication</title>
<simpara>Basic authentication is a generic back-end integration mechanism that allows
users to log in to OpenShift Container Platform with credentials validated against a remote
identity provider.</simpara>
<simpara>Because basic authentication is generic, you can use this identity
provider for advanced authentication configurations.</simpara>
<important>
<simpara>Basic authentication must use an HTTPS connection to the remote server to
prevent potential snooping of the user ID and password and man-in-the-middle
attacks.</simpara>
</important>
<simpara>With basic authentication configured, users send their user name
and password to OpenShift Container Platform, which then validates those credentials against
a remote server by making a server-to-server request, passing the credentials as
a basic authentication header. This requires users to send their credentials to
OpenShift Container Platform during login.</simpara>
<note>
<simpara>This only works for user name/password login mechanisms, and OpenShift Container Platform must
be able to make network requests to the remote authentication server.</simpara>
</note>
<simpara>User names and passwords are validated against a remote URL that is protected
by basic authentication and returns JSON.</simpara>
<simpara>A <literal>401</literal> response indicates failed authentication.</simpara>
<simpara>A non-<literal>200</literal> status, or the presence of a non-empty "error" key, indicates an
error:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"error":"Error message"}</programlisting>
<simpara>A <literal>200</literal> status with a <literal>sub</literal> (subject) key indicates success:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid"} <co xml:id="CO16-1"/></programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>The subject must be unique to the authenticated user and must not be able to
be modified.</para>
</callout>
</calloutlist>
<simpara>A successful response can optionally provide additional data, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>A display name using the <literal>name</literal> key. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid", "name": "User Name", ...}</programlisting>
</listitem>
<listitem>
<simpara>An email address using the <literal>email</literal> key. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid", "email":"user@example.com", ...}</programlisting>
</listitem>
<listitem>
<simpara>A preferred user name using the <literal>preferred_username</literal> key. This is useful when
the unique, unchangeable subject is a database key or UID, and a more
human-readable name exists. This is used as a hint when provisioning the
OpenShift Container Platform user for the authenticated identity. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"014fbff9a07c", "preferred_username":"bob", ...}</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-secret-tls_configuring-basic-authentication-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object that contains the key and certificate by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret tls &lt;secret_name&gt; --key=key.pem --cert=cert.pem -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: kubernetes.io/tls
data:
  tls.crt: &lt;base64_encoded_cert&gt;
  tls.key: &lt;base64_encoded_key&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-basic-authentication-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-basic-authentication-CR_configuring-basic-authentication-identity-provider">
<title>Sample basic authentication CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for a
basic authentication identity provider.</simpara>
<formalpara>
<title>Basic authentication CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: basicidp <co xml:id="CO17-1"/>
    mappingMethod: claim <co xml:id="CO17-2"/>
    type: BasicAuth
    basicAuth:
      url: https://www.example.com/remote-idp <co xml:id="CO17-3"/>
      ca: <co xml:id="CO17-4"/>
        name: ca-config-map
      tlsClientCert: <co xml:id="CO17-5"/>
        name: client-cert-secret
      tlsClientKey: <co xml:id="CO17-6"/>
        name: client-key-secret</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO17-1">
<para>This provider name is prefixed to the returned user ID to form an identity
name.</para>
</callout>
<callout arearefs="CO17-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO17-3">
<para>URL accepting credentials in Basic authentication headers.</para>
</callout>
<callout arearefs="CO17-4">
<para>Optional: Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
PEM-encoded certificate authority bundle to use in validating server
certificates for the configured URL.</para>
</callout>
<callout arearefs="CO17-5">
<para>Optional: Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client
certificate to present when making requests to the configured URL.</para>
</callout>
<callout arearefs="CO17-6">
<para>Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the key for the
client certificate. Required if <literal>tlsClientCert</literal> is specified.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-basic-authentication-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="example-apache-httpd-configuration_configuring-basic-authentication-identity-provider">
<title>Example Apache HTTPD configuration for basic identity providers</title>
<simpara>The basic identify provider (IDP) configuration in OpenShift Container Platform 4 requires
that the IDP server respond with JSON for success and failures. You can use CGI
scripting in Apache HTTPD to accomplish this. This section provides examples.</simpara>
<formalpara>
<title>Example <literal>/etc/httpd/conf.d/login.conf</literal></title>
<para>
<screen>&lt;VirtualHost *:443&gt;
  # CGI Scripts in here
  DocumentRoot /var/www/cgi-bin

  # SSL Directives
  SSLEngine on
  SSLCipherSuite PROFILE=SYSTEM
  SSLProxyCipherSuite PROFILE=SYSTEM
  SSLCertificateFile /etc/pki/tls/certs/localhost.crt
  SSLCertificateKeyFile /etc/pki/tls/private/localhost.key

  # Configure HTTPD to execute scripts
  ScriptAlias /basic /var/www/cgi-bin

  # Handles a failed login attempt
  ErrorDocument 401 /basic/fail.cgi

  # Handles authentication
  &lt;Location /basic/login.cgi&gt;
    AuthType Basic
    AuthName "Please Log In"
    AuthBasicProvider file
    AuthUserFile /etc/httpd/conf/passwords
    Require valid-user
  &lt;/Location&gt;
&lt;/VirtualHost&gt;</screen>
</para>
</formalpara>
<formalpara>
<title>Example <literal>/var/www/cgi-bin/login.cgi</literal></title>
<para>
<screen>#!/bin/bash
echo "Content-Type: application/json"
echo ""
echo '{"sub":"userid", "name":"'$REMOTE_USER'"}'
exit 0</screen>
</para>
</formalpara>
<formalpara>
<title>Example <literal>/var/www/cgi-bin/fail.cgi</literal></title>
<para>
<screen>#!/bin/bash
echo "Content-Type: application/json"
echo ""
echo '{"error": "Login failure"}'
exit 0</screen>
</para>
</formalpara>
<section xml:id="_file_requirements">
<title>File requirements</title>
<simpara>These are the requirements for the files you create on an Apache HTTPD web
server:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>login.cgi</literal> and <literal>fail.cgi</literal> must be executable (<literal>chmod +x</literal>).</simpara>
</listitem>
<listitem>
<simpara><literal>login.cgi</literal> and <literal>fail.cgi</literal> must have proper SELinux contexts if SELinux is
enabled: <literal>restorecon -RFv /var/www/cgi-bin</literal>, or ensure that the context is
<literal>httpd_sys_script_exec_t</literal> using <literal>ls -laZ</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>login.cgi</literal> is only executed if your user successfully logs in per <literal>Require
and Auth</literal> directives.</simpara>
</listitem>
<listitem>
<simpara><literal>fail.cgi</literal> is executed if the user fails to log in, resulting in an <literal>HTTP 401</literal>
response.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="identity-provider-basic-authentication-troubleshooting_configuring-basic-authentication-identity-provider">
<title>Basic authentication troubleshooting</title>
<simpara>The most common issue relates to network connectivity to the backend server. For
simple debugging, run <literal>curl</literal> commands on the master. To test for a successful
login, replace the <literal>&lt;user&gt;</literal> and <literal>&lt;password&gt;</literal> in the following example command
with valid credentials. To test an invalid login, replace them with false
credentials.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ curl --cacert /path/to/ca.crt --cert /path/to/client.crt --key /path/to/client.key -u &lt;user&gt;:&lt;password&gt; -v https://www.example.com/remote-idp</programlisting>
<simpara><emphasis role="strong">Successful responses</emphasis></simpara>
<simpara>A <literal>200</literal> status with a <literal>sub</literal> (subject) key indicates success:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid"}</programlisting>
<simpara>The subject must be unique to the authenticated user, and must not be able to
be modified.</simpara>
<simpara>A successful response can optionally provide additional data, such as:</simpara>
<itemizedlist>
<listitem>
<simpara>A display name using the <literal>name</literal> key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid", "name": "User Name", ...}</programlisting>
</listitem>
<listitem>
<simpara>An email address using the <literal>email</literal> key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"userid", "email":"user@example.com", ...}</programlisting>
</listitem>
<listitem>
<simpara>A preferred user name using the <literal>preferred_username</literal> key:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">{"sub":"014fbff9a07c", "preferred_username":"bob", ...}</programlisting>
<simpara>The <literal>preferred_username</literal> key is useful when
the unique, unchangeable subject is a database key or UID, and a more
human-readable name exists. This is used as a hint when provisioning the
OpenShift Container Platform user for the authenticated identity.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Failed responses</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>401</literal> response indicates failed authentication.</simpara>
</listitem>
<listitem>
<simpara>A non-<literal>200</literal> status or the presence of a non-empty "error" key indicates an
error: <literal>{"error":"Error message"}</literal></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="configuring-request-header-identity-provider">
<title>Configuring a request header identity provider</title>

<simpara>Configure the <literal>request-header</literal> identity provider to identify users from request header values, such as <literal>X-Remote-User</literal>. It is typically used in combination with an authenticating proxy, which sets the request header value.</simpara>
<section xml:id="identity-provider-overview_configuring-request-header-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-about-request-header_configuring-request-header-identity-provider">
<title>About request header authentication</title>
<simpara>A request header identity provider identifies users from request
header values, such as <literal>X-Remote-User</literal>. It is typically used in combination with
an authenticating proxy, which sets the request header value. The
request header identity provider cannot be combined with other identity providers
that use direct password logins, such as htpasswd, Keystone, LDAP or basic authentication.</simpara>
<note>
<simpara>You can also use the request header identity provider for advanced configurations
such as the community-supported <link xlink:href="https://github.com/openshift/request-header-saml-service-provider">SAML authentication</link>.
Note that this solution is not supported by Red Hat.</simpara>
</note>
<simpara>For users to authenticate using this identity provider, they must access
<literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal> (and subpaths) via an authenticating proxy.
To accomplish this, configure the OAuth server to redirect unauthenticated
requests for OAuth tokens to the proxy endpoint that proxies to
<literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal>.</simpara>
<simpara>To redirect unauthenticated requests from clients expecting browser-based login flows:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the <literal>provider.loginURL</literal> parameter to the authenticating proxy URL that
will authenticate interactive clients and then proxy the request to
<literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>To redirect unauthenticated requests from clients expecting <literal>WWW-Authenticate</literal> challenges:</simpara>
<itemizedlist>
<listitem>
<simpara>Set the <literal>provider.challengeURL</literal> parameter to the authenticating proxy URL that
will authenticate clients expecting <literal>WWW-Authenticate</literal> challenges and then proxy
the request to <literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>provider.challengeURL</literal> and <literal>provider.loginURL</literal> parameters can include
the following tokens in the query portion of the URL:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>${url}</literal> is replaced with the current URL, escaped to be safe in a query parameter.</simpara>
<simpara>For example: <literal>https://www.example.com/sso-login?then=${url}</literal></simpara>
</listitem>
<listitem>
<simpara><literal>${query}</literal> is replaced with the current query string, unescaped.</simpara>
<simpara>For example: <literal>https://www.example.com/auth-proxy/oauth/authorize?${query}</literal></simpara>
</listitem>
</itemizedlist>
<important>
<simpara>As of OpenShift Container Platform 4.1, your proxy must support mutual TLS.</simpara>
</important>
<section xml:id="sspi-windows_configuring-request-header-identity-provider">
<title>SSPI connection support on Microsoft Windows</title>
<important>
<simpara>Using SSPI connection support on Microsoft Windows is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>The OpenShift CLI (<literal>oc</literal>) supports the Security Support Provider Interface (SSPI) to allow for SSO
flows on Microsft Windows. If you use the request header identity provider with a
GSSAPI-enabled proxy to connect an Active Directory server to OpenShift Container Platform,
users can automatically authenticate to OpenShift Container Platform by using the <literal>oc</literal>  command
line interface from a domain-joined Microsoft Windows computer.</simpara>
</section>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-request-header-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-request-header-CR_configuring-request-header-identity-provider">
<title>Sample request header CR</title>
<simpara>The following custom resource (CR) shows the parameters and
acceptable values for a request header identity provider.</simpara>
<formalpara>
<title>Request header CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: requestheaderidp <co xml:id="CO18-1"/>
    mappingMethod: claim <co xml:id="CO18-2"/>
    type: RequestHeader
    requestHeader:
      challengeURL: "https://www.example.com/challenging-proxy/oauth/authorize?${query}" <co xml:id="CO18-3"/>
      loginURL: "https://www.example.com/login-proxy/oauth/authorize?${query}" <co xml:id="CO18-4"/>
      ca: <co xml:id="CO18-5"/>
        name: ca-config-map
      clientCommonNames: <co xml:id="CO18-6"/>
      - my-auth-proxy
      headers: <co xml:id="CO18-7"/>
      - X-Remote-User
      - SSO-User
      emailHeaders: <co xml:id="CO18-8"/>
      - X-Remote-User-Email
      nameHeaders: <co xml:id="CO18-9"/>
      - X-Remote-User-Display-Name
      preferredUsernameHeaders: <co xml:id="CO18-10"/>
      - X-Remote-User-Login</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO18-1">
<para>This provider name is prefixed to the user name in the request header to
form an identity name.</para>
</callout>
<callout arearefs="CO18-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO18-3">
<para>Optional: URL to redirect unauthenticated <literal>/oauth/authorize</literal> requests to,
that will authenticate browser-based clients and then proxy their request to
<literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal>.
The URL that proxies to <literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal> must end with <literal>/authorize</literal> (with no trailing slash),
and also proxy subpaths, in order for OAuth approval flows to work properly.
<literal>${url}</literal> is replaced with the current URL, escaped to be safe in a query parameter.
<literal>${query}</literal> is replaced with the current query string.
If this attribute is not defined, then <literal>loginURL</literal> must be used.</para>
</callout>
<callout arearefs="CO18-4">
<para>Optional: URL to redirect unauthenticated <literal>/oauth/authorize</literal> requests to,
that will authenticate clients which expect <literal>WWW-Authenticate</literal> challenges, and
then proxy them to <literal>https://<emphasis>&lt;namespace_route&gt;</emphasis>/oauth/authorize</literal>.
<literal>${url}</literal> is replaced with the current URL, escaped to be safe in a query parameter.
<literal>${query}</literal> is replaced with the current query string.
If this attribute is not defined, then <literal>challengeURL</literal> must be used.</para>
</callout>
<callout arearefs="CO18-5">
<para>Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing a PEM-encoded
certificate bundle. Used as a trust anchor to validate the TLS
certificates presented by the remote server.</para>
<important>
<simpara>As of OpenShift Container Platform 4.1, the <literal>ca</literal> field is required for this identity
provider. This means that your proxy must support mutual TLS.</simpara>
</important>
</callout>
<callout arearefs="CO18-6">
<para>Optional: list of common names (<literal>cn</literal>). If set, a valid client certificate with
a Common Name (<literal>cn</literal>) in the specified list must be presented before the request headers
are checked for user names. If empty, any Common Name is allowed. Can only be used in combination
with <literal>ca</literal>.</para>
</callout>
<callout arearefs="CO18-7">
<para>Header names to check, in order, for the user identity. The first header containing
a value is used as the identity. Required, case-insensitive.</para>
</callout>
<callout arearefs="CO18-8">
<para>Header names to check, in order, for an email address. The first header containing
a value is used as the email address. Optional, case-insensitive.</para>
</callout>
<callout arearefs="CO18-9">
<para>Header names to check, in order, for a display name. The first header containing
a value is used as the display name. Optional, case-insensitive.</para>
</callout>
<callout arearefs="CO18-10">
<para>Header names to check, in order, for a preferred user name, if different than the immutable
identity determined from the headers specified in <literal>headers</literal>. The first header containing
a value is used as the preferred user name when provisioning. Optional, case-insensitive.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-request-header-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="example-apache-auth-config-using-request-header">
<title>Example Apache authentication configuration using request header</title>
<simpara>This example configures an Apache authentication proxy for the OpenShift Container Platform
using the request header identity provider.</simpara>
<bridgehead xml:id="identity-provider-apache-custom-proxy-configuration_configuring-request-header-identity-provider" renderas="sect4">Custom proxy configuration</bridgehead>
<simpara>Using the <literal>mod_auth_gssapi</literal> module is a popular way to configure the Apache
authentication proxy using the request header identity provider; however, it is
not required. Other proxies can easily be used if the following requirements are
met:</simpara>
<itemizedlist>
<listitem>
<simpara>Block the <literal>X-Remote-User</literal> header from client requests to prevent spoofing.</simpara>
</listitem>
<listitem>
<simpara>Enforce client certificate authentication in the <literal>RequestHeaderIdentityProvider</literal>
configuration.</simpara>
</listitem>
<listitem>
<simpara>Require the <literal>X-Csrf-Token</literal> header be set for all authentication requests using
the challenge flow.</simpara>
</listitem>
<listitem>
<simpara>Make sure only the <literal>/oauth/authorize</literal> endpoint and its subpaths are proxied;
redirects must be rewritten to allow the backend server to send the client to
the correct location.</simpara>
</listitem>
<listitem>
<simpara>The URL that proxies to <literal>https://&lt;namespace_route&gt;/oauth/authorize</literal> must end
with <literal>/authorize</literal> with no trailing slash. For example, <literal>https://proxy.example.com/login-proxy/authorize?&#8230;&#8203;</literal>
must proxy to <literal>https://&lt;namespace_route&gt;/oauth/authorize?&#8230;&#8203;</literal>.</simpara>
</listitem>
<listitem>
<simpara>Subpaths of the URL that proxies to <literal>https://&lt;namespace_route&gt;/oauth/authorize</literal>
must proxy to subpaths of <literal>https://&lt;namespace_route&gt;/oauth/authorize</literal>. For
example, <literal>https://proxy.example.com/login-proxy/authorize/approve?&#8230;&#8203;</literal> must
proxy to <literal>https://&lt;namespace_route&gt;/oauth/authorize/approve?&#8230;&#8203;</literal>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>The <literal>https://&lt;namespace_route&gt;</literal> address is the route to the OAuth server and
can be obtained by running <literal>oc get route -n openshift-authentication</literal>.</simpara>
</note>
<bridgehead xml:id="identity-provider-configuring-apache-request-header_configuring-request-header-identity-provider" renderas="sect4">Configuring Apache authentication using request header</bridgehead>
<simpara>This example uses the <literal>mod_auth_gssapi</literal> module to configure an Apache
authentication proxy using the request header identity provider.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Obtain the <literal>mod_auth_gssapi</literal> module from the
<link xlink:href="https://access.redhat.com/solutions/392003">Optional channel</link>.
You must have the following packages installed on your local machine:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>httpd</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mod_ssl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mod_session</literal></simpara>
</listitem>
<listitem>
<simpara><literal>apr-util-openssl</literal></simpara>
</listitem>
<listitem>
<simpara><literal>mod_auth_gssapi</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Generate a CA for validating requests that submit the trusted header. Define
an OpenShift Container Platform <literal>ConfigMap</literal> object containing the CA. This is done by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config <co xml:id="CO19-1"/></programlisting>
<calloutlist>
<callout arearefs="CO19-1">
<para>The CA must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</para>
</callout>
</calloutlist>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Generate a client certificate for the proxy. You can generate this certificate
by using any x509 certificate tooling. The client certificate must be signed by
the CA you generated for validating requests that submit the trusted header.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>This proxy uses a client certificate to connect to the OAuth server, which
is configured to trust the <literal>X-Remote-User</literal> header.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create the certificate for the Apache configuration. The certificate that you
specify as the <literal>SSLProxyMachineCertificateFile</literal> parameter value is the proxy&#8217;s
client certificate that is used to authenticate the proxy to the server. It must
use <literal>TLS Web Client Authentication</literal> as the extended key type.</simpara>
</listitem>
<listitem>
<simpara>Create the Apache configuration. Use the following template to provide your
required settings and values:</simpara>
<important>
<simpara>Carefully review the template and customize its contents to fit your
environment.</simpara>
</important>
<screen>LoadModule request_module modules/mod_request.so
LoadModule auth_gssapi_module modules/mod_auth_gssapi.so
# Some Apache configurations might require these modules.
# LoadModule auth_form_module modules/mod_auth_form.so
# LoadModule session_module modules/mod_session.so

# Nothing needs to be served over HTTP.  This virtual host simply redirects to
# HTTPS.
&lt;VirtualHost *:80&gt;
  DocumentRoot /var/www/html
  RewriteEngine              On
  RewriteRule     ^(.*)$     https://%{HTTP_HOST}$1 [R,L]
&lt;/VirtualHost&gt;

&lt;VirtualHost *:443&gt;
  # This needs to match the certificates you generated.  See the CN and X509v3
  # Subject Alternative Name in the output of:
  # openssl x509 -text -in /etc/pki/tls/certs/localhost.crt
  ServerName www.example.com

  DocumentRoot /var/www/html
  SSLEngine on
  SSLCertificateFile /etc/pki/tls/certs/localhost.crt
  SSLCertificateKeyFile /etc/pki/tls/private/localhost.key
  SSLCACertificateFile /etc/pki/CA/certs/ca.crt

  SSLProxyEngine on
  SSLProxyCACertificateFile /etc/pki/CA/certs/ca.crt
  # It is critical to enforce client certificates. Otherwise, requests can
  # spoof the X-Remote-User header by accessing the /oauth/authorize endpoint
  # directly.
  SSLProxyMachineCertificateFile /etc/pki/tls/certs/authproxy.pem

  # To use the challenging-proxy, an X-Csrf-Token must be present.
  RewriteCond %{REQUEST_URI} ^/challenging-proxy
  RewriteCond %{HTTP:X-Csrf-Token} ^$ [NC]
  RewriteRule ^.* - [F,L]

  &lt;Location /challenging-proxy/oauth/authorize&gt;
      # Insert your backend server name/ip here.
      ProxyPass https://&lt;namespace_route&gt;/oauth/authorize
      AuthName "SSO Login"
      # For Kerberos
      AuthType GSSAPI
      Require valid-user
      RequestHeader set X-Remote-User %{REMOTE_USER}s

      GssapiCredStore keytab:/etc/httpd/protected/auth-proxy.keytab
      # Enable the following if you want to allow users to fallback
      # to password based authentication when they do not have a client
      # configured to perform kerberos authentication.
      GssapiBasicAuth On

      # For ldap:
      # AuthBasicProvider ldap
      # AuthLDAPURL "ldap://ldap.example.com:389/ou=People,dc=my-domain,dc=com?uid?sub?(objectClass=*)"
    &lt;/Location&gt;

    &lt;Location /login-proxy/oauth/authorize&gt;
    # Insert your backend server name/ip here.
    ProxyPass https://&lt;namespace_route&gt;/oauth/authorize

      AuthName "SSO Login"
      AuthType GSSAPI
      Require valid-user
      RequestHeader set X-Remote-User %{REMOTE_USER}s env=REMOTE_USER

      GssapiCredStore keytab:/etc/httpd/protected/auth-proxy.keytab
      # Enable the following if you want to allow users to fallback
      # to password based authentication when they do not have a client
      # configured to perform kerberos authentication.
      GssapiBasicAuth On

      ErrorDocument 401 /login.html
    &lt;/Location&gt;

&lt;/VirtualHost&gt;

RequestHeader unset X-Remote-User</screen>
<note>
<simpara>The <literal>https://&lt;namespace_route&gt;</literal> address is the route to the OAuth server and
can be obtained by running <literal>oc get route -n openshift-authentication</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Update the <literal>identityProviders</literal> stanza in the custom resource (CR):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">identityProviders:
  - name: requestheaderidp
    type: RequestHeader
    requestHeader:
      challengeURL: "https://&lt;namespace_route&gt;/challenging-proxy/oauth/authorize?${query}"
      loginURL: "https://&lt;namespace_route&gt;/login-proxy/oauth/authorize?${query}"
      ca:
        name: ca-config-map
        clientCommonNames:
        - my-auth-proxy
        headers:
        - X-Remote-User</programlisting>
</listitem>
<listitem>
<simpara>Verify the configuration.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Confirm that you can bypass the proxy by requesting a token by supplying the
correct client certificate and header:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># curl -L -k -H "X-Remote-User: joe" \
   --cert /etc/pki/tls/certs/authproxy.pem \
   https://&lt;namespace_route&gt;/oauth/token/request</programlisting>
</listitem>
<listitem>
<simpara>Confirm that requests that do not supply the client certificate fail by
requesting a token without the certificate:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># curl -L -k -H "X-Remote-User: joe" \
   https://&lt;namespace_route&gt;/oauth/token/request</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the <literal>challengeURL</literal> redirect is active:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># curl -k -v -H 'X-Csrf-Token: 1' \
   https://&lt;namespace_route&gt;/oauth/authorize?client_id=openshift-challenging-client&amp;response_type=token</programlisting>
<simpara>Copy the <literal>challengeURL</literal> redirect to use in the next step.</simpara>
</listitem>
<listitem>
<simpara>Run this command to show a <literal>401</literal> response with a <literal>WWW-Authenticate</literal> basic
challenge, a negotiate challenge, or both challenges:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># curl -k -v -H 'X-Csrf-Token: 1' \
   &lt;challengeURL_redirect + query&gt;</programlisting>
</listitem>
<listitem>
<simpara>Test logging in to the OpenShift CLI (<literal>oc</literal>) with and without using a Kerberos
ticket:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>If you generated a Kerberos ticket by using <literal>kinit</literal>, destroy it:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># kdestroy -c cache_name <co xml:id="CO20-1"/></programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>Make sure to provide the name of your Kerberos cache.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Log in to the <literal>oc</literal> tool by using your Kerberos credentials:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc login -u &lt;username&gt;</programlisting>
<simpara>Enter your Kerberos password at the prompt.</simpara>
</listitem>
<listitem>
<simpara>Log out of the <literal>oc</literal> tool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc logout</programlisting>
</listitem>
<listitem>
<simpara>Use your Kerberos credentials to get a ticket:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># kinit</programlisting>
<simpara>Enter your Kerberos user name and password at the prompt.</simpara>
</listitem>
<listitem>
<simpara>Confirm that you can log in to the <literal>oc</literal> tool:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc login</programlisting>
<simpara>If your configuration is correct, you are logged in without entering separate
credentials.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-github-identity-provider">
<title>Configuring a GitHub or GitHub Enterprise identity provider</title>

<simpara>Configure the <literal>github</literal> identity provider to validate user names and passwords against GitHub or GitHub Enterprise&#8217;s OAuth authentication server. OAuth facilitates a token exchange flow between OpenShift Container Platform and GitHub or GitHub Enterprise.</simpara>
<simpara>You can use the GitHub integration to connect to either GitHub or GitHub Enterprise. For GitHub Enterprise integrations, you must provide the <literal>hostname</literal> of your instance and can optionally provide a <literal>ca</literal> certificate bundle to use in requests to the server.</simpara>
<note>
<simpara>The following steps apply to both GitHub and GitHub Enterprise unless noted.</simpara>
</note>
<section xml:id="identity-provider-overview_configuring-github-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-github-about_configuring-github-identity-provider">
<title>About GitHub authentication</title>
<simpara>Configuring <link xlink:href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/authorizing-oauth-apps">GitHub authentication</link> allows users to log in to OpenShift Container Platform with their GitHub credentials. To prevent anyone with any GitHub user ID from logging in to your OpenShift Container Platform cluster, you can restrict access to only those in specific GitHub organizations.</simpara>
</section>
<section xml:id="identity-provider-registering-github_configuring-github-identity-provider">
<title>Registering a GitHub application</title>
<simpara>To use GitHub or GitHub Enterprise as an identity provider, you must register
an application to use.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Register an application on GitHub:</simpara>
<itemizedlist>
<listitem>
<simpara>For GitHub, click <link xlink:href="https://github.com/settings/profile"><emphasis role="strong">Settings</emphasis></link> &#8594;
<link xlink:href="https://github.com/settings/apps"><emphasis role="strong">Developer settings</emphasis></link> &#8594;
<link xlink:href="https://github.com/settings/developers"><emphasis role="strong">OAuth Apps</emphasis></link> &#8594;
<link xlink:href="https://github.com/settings/applications/new"><emphasis role="strong">Register a new OAuth application</emphasis></link>.</simpara>
</listitem>
<listitem>
<simpara>For GitHub Enterprise, go to your GitHub Enterprise home page and then click
<emphasis role="strong">Settings &#8594; Developer settings &#8594; Register a new application</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Enter an application name, for example <literal>My OpenShift Install</literal>.</simpara>
</listitem>
<listitem>
<simpara>Enter a homepage URL, such as
<literal>https://oauth-openshift.apps.&lt;cluster-name&gt;.&lt;cluster-domain&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara>Optional: Enter an application description.</simpara>
</listitem>
<listitem>
<simpara>Enter the authorization callback URL, where the end of the URL contains the
identity provider <literal>name</literal>:</simpara>
<screen>https://oauth-openshift.apps.&lt;cluster-name&gt;.&lt;cluster-domain&gt;/oauth2callback/&lt;idp-provider-name&gt;</screen>
<simpara>For example:</simpara>
<screen>https://oauth-openshift.apps.openshift-cluster.example.com/oauth2callback/github</screen>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Register application</emphasis>. GitHub provides a client ID and a client secret.
You need these values to complete the identity provider configuration.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="identity-provider-creating-secret_configuring-github-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object containing a string by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-literal=clientSecret=&lt;secret&gt; -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: Opaque
data:
  clientSecret: &lt;base64_encoded_client_secret&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>You can define a <literal>Secret</literal> object containing the contents of a file, such as a certificate file, by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=&lt;path_to_file&gt; -n openshift-config</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-github-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<note>
<simpara>This procedure is only required for GitHub Enterprise.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-github-CR_configuring-github-identity-provider">
<title>Sample GitHub CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for a
GitHub identity provider.</simpara>
<formalpara>
<title>GitHub CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: githubidp <co xml:id="CO21-1"/>
    mappingMethod: claim <co xml:id="CO21-2"/>
    type: GitHub
    github:
      ca: <co xml:id="CO21-3"/>
        name: ca-config-map
      clientID: {...} <co xml:id="CO21-4"/>
      clientSecret: <co xml:id="CO21-5"/>
        name: github-secret
      hostname: ... <co xml:id="CO21-6"/>
      organizations: <co xml:id="CO21-7"/>
      - myorganization1
      - myorganization2
      teams: <co xml:id="CO21-8"/>
      - myorganization1/team-a
      - myorganization2/team-b</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>This provider name is prefixed to the GitHub numeric user ID to form an
identity name. It is also used to build the callback URL.</para>
</callout>
<callout arearefs="CO21-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO21-3">
<para>Optional: Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
PEM-encoded certificate authority bundle to use in validating server
certificates for the configured URL. Only for use in GitHub Enterprise
with a non-publicly trusted root certificate.</para>
</callout>
<callout arearefs="CO21-4">
<para>The client ID of a
<link xlink:href="https://github.com/settings/applications/new">registered GitHub OAuth
application</link>. The application must be configured with a callback URL of
<literal>https://oauth-openshift.apps.&lt;cluster-name&gt;.&lt;cluster-domain&gt;/oauth2callback/&lt;idp-provider-name&gt;</literal>.</para>
</callout>
<callout arearefs="CO21-5">
<para>Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client secret
issued by GitHub.</para>
</callout>
<callout arearefs="CO21-6">
<para>For GitHub Enterprise, you must provide the hostname of your instance, such as
<literal>example.com</literal>. This value must match the GitHub Enterprise <literal>hostname</literal> value in
in the <literal>/setup/settings</literal> file and cannot include a port number. If this
value is not set, then either <literal>teams</literal> or <literal>organizations</literal> must be defined.
For GitHub, omit this parameter.</para>
</callout>
<callout arearefs="CO21-7">
<para>The list of organizations. Either the <literal>organizations</literal> or <literal>teams</literal> field must be set unless the <literal>hostname</literal> field is set, or if <literal>mappingMethod</literal> is set to <literal>lookup</literal>. Cannot be used in combination with the <literal>teams</literal> field.</para>
</callout>
<callout arearefs="CO21-8">
<para>The list of teams. Either the <literal>teams</literal> or <literal>organizations</literal> field must be set unless the <literal>hostname</literal> field is set, or if <literal>mappingMethod</literal> is set to <literal>lookup</literal>. Cannot be used in combination with the <literal>organizations</literal> field.</para>
</callout>
</calloutlist>
<note>
<simpara>If <literal>organizations</literal> or <literal>teams</literal> is specified, only GitHub users that are members of
at least one of the listed organizations will be allowed to log in. If the GitHub OAuth
application configured in <literal>clientID</literal> is not owned by the organization, an organization
owner must grant third-party access to use this option. This can be done during
the first GitHub login by the organization&#8217;s administrator, or from the GitHub organization settings.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-github-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Obtain a token from the OAuth server.</simpara>
<simpara>As long as the <literal>kubeadmin</literal> user has been removed, the <literal>oc login</literal> command provides instructions on how to access a web page where you can retrieve the token.</simpara>
<simpara>You can also access this page from the web console by navigating to <emphasis role="strong">(?) Help</emphasis> &#8594; <emphasis role="strong">Command Line Tools</emphasis> &#8594; <emphasis role="strong">Copy Login Command</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster, passing in the token to authenticate.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --token=&lt;token&gt;</programlisting>
<note>
<simpara>This identity provider does not support logging in with a user name and password.</simpara>
</note>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-gitlab-identity-provider">
<title>Configuring a GitLab identity provider</title>

<simpara>Configure the <literal>gitlab</literal> identity provider using <link xlink:href="https://gitlab.com/">GitLab.com</link> or any other GitLab instance as an identity provider.</simpara>
<section xml:id="identity-provider-overview_configuring-gitlab-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-gitlab-about_configuring-gitlab-identity-provider">
<title>About GitLab authentication</title>
<simpara>Configuring GitLab authentication allows users to log in to OpenShift Container Platform with their GitLab credentials.</simpara>
<simpara>If you use GitLab version 7.7.0 to 11.0, you connect using the <link xlink:href="http://doc.gitlab.com/ce/integration/oauth_provider.html">OAuth integration</link>. If you use GitLab version 11.1 or later, you can use <link xlink:href="https://docs.gitlab.com/ce/integration/openid_connect_provider.html">OpenID Connect</link> (OIDC) to connect instead of OAuth.</simpara>
</section>
<section xml:id="identity-provider-creating-secret_configuring-gitlab-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object containing a string by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-literal=clientSecret=&lt;secret&gt; -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: Opaque
data:
  clientSecret: &lt;base64_encoded_client_secret&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>You can define a <literal>Secret</literal> object containing the contents of a file, such as a certificate file, by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=&lt;path_to_file&gt; -n openshift-config</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-gitlab-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<note>
<simpara>This procedure is only required for GitHub Enterprise.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-gitlab-CR_configuring-gitlab-identity-provider">
<title>Sample GitLab CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable values for a
GitLab identity provider.</simpara>
<formalpara>
<title>GitLab CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: gitlabidp <co xml:id="CO22-1"/>
    mappingMethod: claim <co xml:id="CO22-2"/>
    type: GitLab
    gitlab:
      clientID: {...} <co xml:id="CO22-3"/>
      clientSecret: <co xml:id="CO22-4"/>
        name: gitlab-secret
      url: https://gitlab.com <co xml:id="CO22-5"/>
      ca: <co xml:id="CO22-6"/>
        name: ca-config-map</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para>This provider name is prefixed to the GitLab numeric user ID to form an
identity name. It is also used to build the callback URL.</para>
</callout>
<callout arearefs="CO22-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO22-3">
<para>The client ID of a
<link xlink:href="https://docs.gitlab.com/ce/api/oauth2.html">registered GitLab OAuth application</link>.
The application must be configured with a callback URL of
<literal>https://oauth-openshift.apps.&lt;cluster-name&gt;.&lt;cluster-domain&gt;/oauth2callback/&lt;idp-provider-name&gt;</literal>.</para>
</callout>
<callout arearefs="CO22-4">
<para>Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client secret
issued by GitLab.</para>
</callout>
<callout arearefs="CO22-5">
<para>The host URL of a GitLab provider. This could either be <literal>https://gitlab.com/</literal>
or any other self hosted instance of GitLab.</para>
</callout>
<callout arearefs="CO22-6">
<para>Optional: Reference to an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
PEM-encoded certificate authority bundle to use in validating server
certificates for the configured URL.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-gitlab-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user from your identity provider, entering the
password when prompted.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;username&gt;</programlisting>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-google-identity-provider">
<title>Configuring a Google identity provider</title>

<simpara>Configure the <literal>google</literal> identity provider using the <link xlink:href="https://developers.google.com/identity/protocols/OpenIDConnect">Google OpenID Connect integration</link>.</simpara>
<section xml:id="identity-provider-overview_configuring-google-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-google-about_configuring-google-identity-provider">
<title>About Google authentication</title>
<simpara>Using Google as an identity provider allows any Google user to authenticate to your server. You can limit authentication to members of a specific hosted domain with the <literal>hostedDomain</literal> configuration attribute.</simpara>
<note>
<simpara>Using Google as an identity provider requires users to get a token using <literal>&lt;namespace_route&gt;/oauth/token/request</literal> to use with command-line tools.</simpara>
</note>
</section>
<section xml:id="identity-provider-creating-secret_configuring-google-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object containing a string by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-literal=clientSecret=&lt;secret&gt; -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: Opaque
data:
  clientSecret: &lt;base64_encoded_client_secret&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>You can define a <literal>Secret</literal> object containing the contents of a file, such as a certificate file, by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=&lt;path_to_file&gt; -n openshift-config</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-google-CR_configuring-google-identity-provider">
<title>Sample Google CR</title>
<simpara>The following custom resource (CR) shows the parameters and acceptable
values for a Google identity provider.</simpara>
<formalpara>
<title>Google CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: googleidp <co xml:id="CO23-1"/>
    mappingMethod: claim <co xml:id="CO23-2"/>
    type: Google
    google:
      clientID: {...} <co xml:id="CO23-3"/>
      clientSecret: <co xml:id="CO23-4"/>
        name: google-secret
      hostedDomain: "example.com" <co xml:id="CO23-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para>This provider name is prefixed to the Google numeric user ID to form an
identity name. It is also used to build the redirect URL.</para>
</callout>
<callout arearefs="CO23-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO23-3">
<para>The client ID of a <link xlink:href="https://console.developers.google.com/">registered
Google project</link>. The project must be configured with a redirect URI of
<literal>https://oauth-openshift.apps.&lt;cluster-name&gt;.&lt;cluster-domain&gt;/oauth2callback/&lt;idp-provider-name&gt;</literal>.</para>
</callout>
<callout arearefs="CO23-4">
<para>Reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client secret
issued by Google.</para>
</callout>
<callout arearefs="CO23-5">
<para>A
<link xlink:href="https://developers.google.com/identity/protocols/OpenIDConnect#hd-param">hosted domain</link>
used to restrict sign-in accounts. Optional if the <literal>lookup</literal> <literal>mappingMethod</literal>
is used. If empty, any Google account is allowed to authenticate.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-google-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Obtain a token from the OAuth server.</simpara>
<simpara>As long as the <literal>kubeadmin</literal> user has been removed, the <literal>oc login</literal> command provides instructions on how to access a web page where you can retrieve the token.</simpara>
<simpara>You can also access this page from the web console by navigating to <emphasis role="strong">(?) Help</emphasis> &#8594; <emphasis role="strong">Command Line Tools</emphasis> &#8594; <emphasis role="strong">Copy Login Command</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster, passing in the token to authenticate.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --token=&lt;token&gt;</programlisting>
<note>
<simpara>This identity provider does not support logging in with a user name and password.</simpara>
</note>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="configuring-oidc-identity-provider">
<title>Configuring an OpenID Connect identity provider</title>

<simpara>Configure the <literal>oidc</literal> identity provider to integrate with an OpenID Connect identity provider using an <link xlink:href="http://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Authorization Code Flow</link>.</simpara>
<section xml:id="identity-provider-overview_configuring-oidc-identity-provider">
<title>About identity providers in OpenShift Container Platform</title>
<simpara>By default, only a <literal>kubeadmin</literal> user exists on your cluster. To specify an
identity provider, you must create a custom resource (CR) that describes
that identity provider and add it to the cluster.</simpara>
<note>
<simpara>OpenShift Container Platform user names containing <literal>/</literal>, <literal>:</literal>, and <literal>%</literal> are not supported.</simpara>
</note>
</section>
<section xml:id="identity-provider-oidc-about_configuring-oidc-identity-provider">
<title>About OpenID Connect authentication</title>
<simpara>The Authentication Operator in OpenShift Container Platform requires that the configured OpenID Connect identity provider implements the <link xlink:href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery</link> specification.</simpara>
<note>
<simpara><literal>ID Token</literal> and <literal>UserInfo</literal> decryptions are not supported.</simpara>
</note>
<simpara>By default, the <literal>openid</literal> scope is requested. If required, extra scopes can be specified in the <literal>extraScopes</literal> field.</simpara>
<simpara>Claims are read from the JWT <literal>id_token</literal> returned from the OpenID identity provider and, if specified, from the JSON returned by the <literal>UserInfo</literal> URL.</simpara>
<simpara>At least one claim must be configured to use as the user&#8217;s identity. The standard identity claim is <literal>sub</literal>.</simpara>
<simpara>You can also indicate which claims to use as the user&#8217;s preferred user name, display name, and email address. If multiple claims are specified, the first one with a non-empty value is used. The following table lists the standard claims:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Claim</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>sub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Short for "subject identifier." The remote identity for the user at the
issuer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>preferred_username</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The preferred user name when provisioning a user. A shorthand name that the user wants to be referred to as, such as <literal>janedoe</literal>. Typically a value that corresponding to the user&#8217;s login or username in the authentication system, such as username or email.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>email</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Email address.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>name</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Display name.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>See the <link xlink:href="http://openid.net/specs/openid-connect-core-1_0.html#StandardClaims">OpenID claims documentation</link> for more information.</simpara>
<note>
<simpara>Unless your OpenID Connect identity provider supports the resource owner password credentials (ROPC) grant flow, users must get a token from <literal>&lt;namespace_route&gt;/oauth/token/request</literal> to use with command-line tools.</simpara>
</note>
</section>
<section xml:id="identity-provider-oidc-supported_configuring-oidc-identity-provider">
<title>Supported OIDC providers</title>
<simpara>Red Hat tests and supports specific OpenID Connect (OIDC) providers with OpenShift Container Platform. The following OpenID Connect (OIDC) providers are tested and supported with OpenShift Container Platform. Using an OIDC provider that is not on the following list might work with OpenShift Container Platform, but the provider was not tested by Red Hat and therefore is not supported by Red Hat.</simpara>
<itemizedlist>
<listitem>
<simpara>Active Directory Federation Services for Windows Server</simpara>
<note>
<simpara>Currently, it is not supported to use Active Directory Federation Services for Windows Server with OpenShift Container Platform when custom claims are used.</simpara>
</note>
</listitem>
<listitem>
<simpara>GitLab</simpara>
</listitem>
<listitem>
<simpara>Google</simpara>
</listitem>
<listitem>
<simpara>Keycloak</simpara>
</listitem>
<listitem>
<simpara>Microsoft identity platform (Azure Active Directory v2.0)</simpara>
<note>
<simpara>Currently, it is not supported to use Microsoft identity platform when group names are required to be synced.</simpara>
</note>
</listitem>
<listitem>
<simpara>Okta</simpara>
</listitem>
<listitem>
<simpara>Ping Identity</simpara>
</listitem>
<listitem>
<simpara>Red Hat Single Sign-On</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-secret_configuring-oidc-identity-provider">
<title>Creating the secret</title>
<simpara>Identity providers use OpenShift Container Platform <literal>Secret</literal> objects in the <literal>openshift-config</literal> namespace to contain the client secret, client certificates, and keys.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object containing a string by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-literal=clientSecret=&lt;secret&gt; -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the secret:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  name: &lt;secret_name&gt;
  namespace: openshift-config
type: Opaque
data:
  clientSecret: &lt;base64_encoded_client_secret&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>You can define a <literal>Secret</literal> object containing the contents of a file, such as a certificate file, by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret_name&gt; --from-file=&lt;path_to_file&gt; -n openshift-config</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-creating-configmap_configuring-oidc-identity-provider">
<title>Creating a config map</title>
<simpara>Identity providers use OpenShift Container Platform <literal>ConfigMap</literal> objects in the <literal>openshift-config</literal>
namespace to contain the certificate authority bundle. These are primarily
used to contain certificate bundles needed by the identity provider.</simpara>
<note>
<simpara>This procedure is only required for GitHub Enterprise.</simpara>
</note>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define an OpenShift Container Platform <literal>ConfigMap</literal> object containing the
certificate authority by using the following command. The certificate
authority must be stored in the <literal>ca.crt</literal> key of the <literal>ConfigMap</literal> object.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create configmap ca-config-map --from-file=ca.crt=/path/to/ca -n openshift-config</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to create the config map:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ConfigMap
metadata:
  name: ca-config-map
  namespace: openshift-config
data:
  ca.crt: |
    &lt;CA_certificate_PEM&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="identity-provider-oidc-CR_configuring-oidc-identity-provider">
<title>Sample OpenID Connect CRs</title>
<simpara>The following custom resources (CRs) show the parameters and acceptable values for an OpenID Connect identity provider.</simpara>
<simpara>If you must specify a custom certificate bundle, extra scopes, extra authorization request parameters, or a <literal>userInfo</literal> URL, use the full OpenID Connect CR.</simpara>
<formalpara>
<title>Standard OpenID Connect CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: oidcidp <co xml:id="CO24-1"/>
    mappingMethod: claim <co xml:id="CO24-2"/>
    type: OpenID
    openID:
      clientID: ... <co xml:id="CO24-3"/>
      clientSecret: <co xml:id="CO24-4"/>
        name: idp-secret
      claims: <co xml:id="CO24-5"/>
        preferredUsername:
        - preferred_username
        name:
        - name
        email:
        - email
        groups:
        - groups
      issuer: https://www.idp-issuer.com <co xml:id="CO24-6"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO24-1">
<para>This provider name is prefixed to the value of the identity claim to form an identity name. It is also used to build the redirect URL.</para>
</callout>
<callout arearefs="CO24-2">
<para>Controls how mappings are established between this provider&#8217;s identities and <literal>User</literal> objects.</para>
</callout>
<callout arearefs="CO24-3">
<para>The client ID of a client registered with the OpenID provider. The client must be allowed to redirect to <literal>https://oauth-openshift.apps.&lt;cluster_name&gt;.&lt;cluster_domain&gt;/oauth2callback/&lt;idp_provider_name&gt;</literal>.</para>
</callout>
<callout arearefs="CO24-4">
<para>A reference to an OpenShift Container Platform <literal>Secret</literal> object containing the client secret.</para>
</callout>
<callout arearefs="CO24-5">
<para>The list of claims to use as the identity. The first non-empty claim is used.</para>
</callout>
<callout arearefs="CO24-6">
<para>The <link xlink:href="https://openid.net/specs/openid-connect-core-1_0.html#IssuerIdentifier">Issuer Identifier</link> described in the OpenID spec. Must use <literal>https</literal> without query or fragment component.</para>
</callout>
</calloutlist>
<formalpara>
<title>Full OpenID Connect CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: OAuth
metadata:
  name: cluster
spec:
  identityProviders:
  - name: oidcidp
    mappingMethod: claim
    type: OpenID
    openID:
      clientID: ...
      clientSecret:
        name: idp-secret
      ca: <co xml:id="CO25-1"/>
        name: ca-config-map
      extraScopes: <co xml:id="CO25-2"/>
      - email
      - profile
      extraAuthorizeParameters: <co xml:id="CO25-3"/>
        include_granted_scopes: "true"
      claims:
        preferredUsername: <co xml:id="CO25-4"/>
        - preferred_username
        - email
        name: <co xml:id="CO25-5"/>
        - nickname
        - given_name
        - name
        email: <co xml:id="CO25-6"/>
        - custom_email_claim
        - email
        groups: <co xml:id="CO25-7"/>
        - groups
      issuer: https://www.idp-issuer.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO25-1">
<para>Optional: Reference to an OpenShift Container Platform config map containing the PEM-encoded certificate authority bundle to use in validating server certificates for the configured URL.</para>
</callout>
<callout arearefs="CO25-2">
<para>Optional: The list of scopes to request, in addition to the <literal>openid</literal> scope, during the authorization token request.</para>
</callout>
<callout arearefs="CO25-3">
<para>Optional: A map of extra parameters to add to the authorization token request.</para>
</callout>
<callout arearefs="CO25-4">
<para>The list of claims to use as the preferred user name when provisioning a user
for this identity. The first non-empty claim is used.</para>
</callout>
<callout arearefs="CO25-5">
<para>The list of claims to use as the display name. The first non-empty claim is used.</para>
</callout>
<callout arearefs="CO25-6">
<para>The list of claims to use as the email address. The first non-empty claim is used.</para>
</callout>
<callout arearefs="CO25-7">
<para>The list of claims to use to synchronize groups from the OpenID Connect provider to OpenShift Container Platform upon user login. The first non-empty claim is used.</para>
</callout>
</calloutlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>See <link xlink:href="../../authentication/understanding-identity-provider.xml#identity-provider-parameters_understanding-identity-provider">Identity provider parameters</link> for information on parameters, such as <literal>mappingMethod</literal>, that are common to all identity providers.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="add-identity-provider_configuring-oidc-identity-provider">
<title>Adding an identity provider to your cluster</title>
<simpara>After you install your cluster, add an identity provider to it so your
users can authenticate.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Create the custom resource (CR) for your identity providers.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Apply the defined CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f &lt;/path/to/CR&gt;</programlisting>
<note>
<simpara>If a CR does not exist, <literal>oc apply</literal> creates a new CR and might trigger the following warning: <literal>Warning: oc apply should be used on resources created by either oc create --save-config or oc apply</literal>. In this case you can safely ignore this warning.</simpara>
</note>
</listitem>
<listitem>
<simpara>Obtain a token from the OAuth server.</simpara>
<simpara>As long as the <literal>kubeadmin</literal> user has been removed, the <literal>oc login</literal> command provides instructions on how to access a web page where you can retrieve the token.</simpara>
<simpara>You can also access this page from the web console by navigating to <emphasis role="strong">(?) Help</emphasis> &#8594; <emphasis role="strong">Command Line Tools</emphasis> &#8594; <emphasis role="strong">Copy Login Command</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster, passing in the token to authenticate.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login --token=&lt;token&gt;</programlisting>
<note>
<simpara>If your OpenID Connect identity provider supports the resource owner password credentials (ROPC) grant flow, you can log in with a user name and password. You might need to take steps to enable the ROPC grant flow for your identity provider.</simpara>
<simpara>After the OIDC identity provider is configured in OpenShift Container Platform, you can log in by using the following command, which prompts for your user name and password:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc login -u &lt;identity_provider_username&gt; --server=&lt;api_server_url_and_port&gt;</programlisting>
</note>
</listitem>
<listitem>
<simpara>Confirm that the user logged in successfully, and display the user name.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc whoami</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="identity-provider-configuring-using-the-web-console_configuring-oidc-identity-provider">
<title>Configuring identity providers using the web console</title>
<simpara>Configure your identity provider (IDP) through the web console instead of the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must be logged in to the web console as a cluster administrator.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">Configuration</emphasis> tab, click <emphasis role="strong">OAuth</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under the <emphasis role="strong">Identity Providers</emphasis> section, select your identity provider from the
<emphasis role="strong">Add</emphasis> drop-down menu.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>You can specify multiple IDPs through the web console without overwriting
existing IDPs.</simpara>
</note>
</section>
</section>
</chapter>
<chapter xml:id="using-rbac">
<title>Using RBAC to define and apply permissions</title>

<section xml:id="authorization-overview_using-rbac">
<title>RBAC overview</title>
<simpara>Role-based access control (RBAC) objects determine whether a user is allowed to
perform a given action within a project.</simpara>
<simpara>Cluster administrators
can use the cluster roles and bindings to control who has various access levels to the OpenShift Container Platform platform itself and all projects.</simpara>
<simpara>Developers can use local roles and bindings to control who has access
to their projects. Note that authorization is a separate step from
authentication, which is more about determining the identity of who is taking the action.</simpara>
<simpara>Authorization is managed using:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Authorization object</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Rules</simpara></entry>
<entry align="left" valign="top"><simpara>Sets of permitted verbs on a set of objects. For example,
whether a user or service account can <literal>create</literal> pods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Roles</simpara></entry>
<entry align="left" valign="top"><simpara>Collections of rules. You can associate, or bind, users and groups
to multiple roles.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Bindings</simpara></entry>
<entry align="left" valign="top"><simpara>Associations between users and/or groups with a role.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>There are two levels of RBAC roles and bindings that control authorization:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">RBAC level</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Cluster RBAC</simpara></entry>
<entry align="left" valign="top"><simpara>Roles and bindings that are applicable across
all projects. <emphasis>Cluster roles</emphasis> exist cluster-wide, and <emphasis>cluster role bindings</emphasis>
can reference only cluster roles.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local RBAC</simpara></entry>
<entry align="left" valign="top"><simpara>Roles and bindings that are scoped to a given project. While
<emphasis>local roles</emphasis> exist only in a single project, local role bindings can
reference <emphasis>both</emphasis> cluster and local roles.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>A cluster role binding is a binding that exists at the cluster level.
A role binding exists at the project level. The cluster role <emphasis>view</emphasis> must be
bound to a user using a local role binding for that user to view the project.
Create local roles only if a cluster role does not provide the set
of permissions needed for a particular situation.</simpara>
<simpara>This two-level hierarchy allows reuse across multiple projects through the
cluster roles while allowing customization inside of individual projects
through local roles.</simpara>
<simpara>During evaluation, both the cluster role bindings and the local role bindings are used.
For example:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Cluster-wide "allow" rules are checked.</simpara>
</listitem>
<listitem>
<simpara>Locally-bound "allow" rules are checked.</simpara>
</listitem>
<listitem>
<simpara>Deny by default.</simpara>
</listitem>
</orderedlist>
<section xml:id="default-roles_using-rbac">
<title>Default cluster roles</title>
<simpara>OpenShift Container Platform includes a set of default cluster roles that you can bind to users and groups cluster-wide or locally.</simpara>
<important>
<simpara>It is not recommended to manually modify the default cluster roles. Modifications to these system roles can prevent a cluster from functioning properly.</simpara>
</important>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Default cluster role</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>admin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A project manager. If used in a local binding, an <literal>admin</literal> has
rights to view any resource in the project and modify any resource in the
project except for quota.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>basic-user</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user that can get basic information about projects and users.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cluster-admin</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A super-user that can perform any action in any project. When
bound to a user with a local binding, they have full control over quota and
every action on every resource in the project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cluster-status</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user that can get basic cluster status information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>cluster-reader</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user that can get or view most of the objects but
cannot modify them.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>edit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user that can modify most objects in a project but does not have the
power to view or modify roles or bindings.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>self-provisioner</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user that can create their own projects.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>view</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A user who cannot make any modifications, but can see most objects in a
project. They cannot view or modify roles or bindings.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Be mindful of the difference between local and cluster bindings. For example,
if you bind the <literal>cluster-admin</literal> role to a user by using a local role binding,
it might appear that this user has the privileges of a cluster administrator.
This is not the case. Binding the <literal>cluster-admin</literal> to a user in a project
grants super administrator privileges for only that project to the user. That user has the permissions of the cluster role <literal>admin</literal>, plus a few additional permissions like the ability to edit rate limits, for that project. This binding can be confusing via the web console UI, which does not list cluster role bindings that are bound to true cluster administrators. However, it does list local role bindings that you can use to locally bind <literal>cluster-admin</literal>.</simpara>
<simpara>The relationships between cluster roles, local roles, cluster role bindings,
local role bindings, users, groups and service accounts are illustrated below.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/rbac.png"/>
</imageobject>
<textobject><phrase>OpenShift Container Platform RBAC</phrase></textobject>
</mediaobject>
</informalfigure>
<warning>
<simpara>The <literal>get pods/exec</literal>, <literal>get pods/*</literal>, and <literal>get *</literal> rules grant execution privileges when they are applied to a role. Apply the principle of least privilege and assign only the minimal RBAC rights required for users and agents. For more information, see <link xlink:href="https://access.redhat.com/solutions/6989997">RBAC rules allow execution privileges</link>.</simpara>
</warning>
</section>
<section xml:id="evaluating-authorization_using-rbac">
<title>Evaluating authorization</title>
<simpara>OpenShift Container Platform evaluates authorization by using:</simpara>
<variablelist>
<varlistentry>
<term>Identity</term>
<listitem>
<simpara>The user name and list of groups that the user belongs to.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Action</term>
<listitem>
<simpara>The action you perform. In most cases, this consists of:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Project</emphasis>: The project you access. A project is a Kubernetes namespace with
additional annotations that allows a community of users to organize and manage
their content in isolation from other communities.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Verb</emphasis> : The action itself:  <literal>get</literal>, <literal>list</literal>, <literal>create</literal>, <literal>update</literal>, <literal>delete</literal>, <literal>deletecollection</literal>, or <literal>watch</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Resource name</emphasis>: The API endpoint that you access.</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Bindings</term>
<listitem>
<simpara>The full list of bindings, the associations between users or groups
with a role.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>OpenShift Container Platform evaluates authorization by using the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The identity and the project-scoped action is used to find all bindings that
apply to the user or their groups.</simpara>
</listitem>
<listitem>
<simpara>Bindings are used to locate all the roles that apply.</simpara>
</listitem>
<listitem>
<simpara>Roles are used to find all the rules that apply.</simpara>
</listitem>
<listitem>
<simpara>The action is checked against each rule to find a match.</simpara>
</listitem>
<listitem>
<simpara>If no matching rule is found, the action is then denied by default.</simpara>
</listitem>
</orderedlist>
<tip>
<simpara>Remember that users and groups can be associated with, or bound to, multiple
roles at the same time.</simpara>
</tip>
<simpara>Project administrators can use the CLI to
view local roles and bindings,
including a matrix of the verbs and resources each are associated with.</simpara>
<important>
<simpara>The cluster role bound to the project administrator is limited in a project
through a local binding. It is not bound cluster-wide like the cluster roles granted to the <emphasis role="strong">cluster-admin</emphasis> or <emphasis role="strong">system:admin</emphasis>.</simpara>
<simpara>Cluster roles are roles defined at the cluster level but can be bound either at
the cluster level or at the project level.</simpara>
</important>
<section xml:id="cluster-role-aggregations_using-rbac">
<title>Cluster role aggregation</title>
<simpara>The default admin, edit, view, and cluster-reader cluster roles support
<link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/#aggregated-clusterroles">cluster role aggregation</link>, where the cluster rules for each role are dynamically updated as new rules are created. This feature is relevant only if you extend the Kubernetes API by creating custom resources.</simpara>
</section>
</section>
</section>
<section xml:id="rbac-projects-namespaces_using-rbac">
<title>Projects and namespaces</title>
<simpara>A Kubernetes <emphasis>namespace</emphasis> provides a mechanism to scope resources in a cluster.
The
<link xlink:href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces/">Kubernetes documentation</link>
has more information on namespaces.</simpara>
<simpara>Namespaces provide a unique scope for:</simpara>
<itemizedlist>
<listitem>
<simpara>Named resources to avoid basic naming collisions.</simpara>
</listitem>
<listitem>
<simpara>Delegated management authority to trusted users.</simpara>
</listitem>
<listitem>
<simpara>The ability to limit community resource consumption.</simpara>
</listitem>
</itemizedlist>
<simpara>Most objects in the system are scoped by namespace, but some are
excepted and have no namespace, including nodes and users.</simpara>
<simpara>A <emphasis>project</emphasis> is a Kubernetes namespace with additional annotations and is the central vehicle
by which access to resources for regular users is managed.
A project allows a community of users to organize and manage their content in
isolation from other communities. Users must be given access to projects by administrators,
or if allowed to create projects, automatically have access to their own projects.</simpara>
<simpara>Projects can have a separate <literal>name</literal>, <literal>displayName</literal>, and <literal>description</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>The mandatory <literal>name</literal> is a unique identifier for the project and is most visible when using the CLI tools or API. The maximum name length is 63 characters.</simpara>
</listitem>
<listitem>
<simpara>The optional <literal>displayName</literal> is how the project is displayed in the web console (defaults to <literal>name</literal>).</simpara>
</listitem>
<listitem>
<simpara>The optional <literal>description</literal> can be a more detailed description of the project and is also visible in the web console.</simpara>
</listitem>
</itemizedlist>
<simpara>Each project scopes its own set of:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Object</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Objects</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pods, services, replication controllers, etc.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Policies</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rules for which users can or cannot perform actions on objects.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Constraints</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Quotas for each kind of object that can be limited.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Service accounts</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Service accounts act automatically with designated access to objects in the project.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Cluster administrators
can create projects and delegate administrative rights for the project to any member of the user community.
Cluster administrators
can also allow developers to create their own projects.</simpara>
<simpara>Developers and administrators can interact with projects by using the CLI or the
web console.</simpara>
</section>
<section xml:id="rbac-default-projects_using-rbac">
<title>Default projects</title>
<simpara>OpenShift Container Platform comes with a number of default projects, and projects
starting with <literal>openshift-</literal> are the most essential to users.
These projects host master components that run as pods and other infrastructure
components. The pods created in these namespaces that have a
<link xlink:href="https://kubernetes.io/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#rescheduler-guaranteed-scheduling-of-critical-add-ons">critical pod annotation</link>
are considered critical, and the have guaranteed admission by kubelet.
Pods created for master components in these namespaces are already marked as
critical.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
</section>
<section xml:id="viewing-cluster-roles_using-rbac">
<title>Viewing cluster roles and bindings</title>
<simpara>You can use the <literal>oc</literal> CLI to view cluster roles and bindings by using the
<literal>oc describe</literal> command.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the <literal>oc</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>Obtain permission to view the cluster roles and bindings.</simpara>
</listitem>
</itemizedlist>
<simpara>Users with the <literal>cluster-admin</literal> default cluster role bound cluster-wide can
perform any action on any resource, including viewing cluster roles and bindings.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To view the cluster roles and their associated rule sets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe clusterrole.rbac</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         admin
Labels:       kubernetes.io/bootstrapping=rbac-defaults
Annotations:  rbac.authorization.kubernetes.io/autoupdate: true
PolicyRule:
  Resources                                                  Non-Resource URLs  Resource Names  Verbs
  ---------                                                  -----------------  --------------  -----
  .packages.apps.redhat.com                                  []                 []              [* create update patch delete get list watch]
  imagestreams                                               []                 []              [create delete deletecollection get list patch update watch create get list watch]
  imagestreams.image.openshift.io                            []                 []              [create delete deletecollection get list patch update watch create get list watch]
  secrets                                                    []                 []              [create delete deletecollection get list patch update watch get list watch create delete deletecollection patch update]
  buildconfigs/webhooks                                      []                 []              [create delete deletecollection get list patch update watch get list watch]
  buildconfigs                                               []                 []              [create delete deletecollection get list patch update watch get list watch]
  buildlogs                                                  []                 []              [create delete deletecollection get list patch update watch get list watch]
  deploymentconfigs/scale                                    []                 []              [create delete deletecollection get list patch update watch get list watch]
  deploymentconfigs                                          []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreamimages                                          []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreammappings                                        []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreamtags                                            []                 []              [create delete deletecollection get list patch update watch get list watch]
  processedtemplates                                         []                 []              [create delete deletecollection get list patch update watch get list watch]
  routes                                                     []                 []              [create delete deletecollection get list patch update watch get list watch]
  templateconfigs                                            []                 []              [create delete deletecollection get list patch update watch get list watch]
  templateinstances                                          []                 []              [create delete deletecollection get list patch update watch get list watch]
  templates                                                  []                 []              [create delete deletecollection get list patch update watch get list watch]
  deploymentconfigs.apps.openshift.io/scale                  []                 []              [create delete deletecollection get list patch update watch get list watch]
  deploymentconfigs.apps.openshift.io                        []                 []              [create delete deletecollection get list patch update watch get list watch]
  buildconfigs.build.openshift.io/webhooks                   []                 []              [create delete deletecollection get list patch update watch get list watch]
  buildconfigs.build.openshift.io                            []                 []              [create delete deletecollection get list patch update watch get list watch]
  buildlogs.build.openshift.io                               []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreamimages.image.openshift.io                       []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreammappings.image.openshift.io                     []                 []              [create delete deletecollection get list patch update watch get list watch]
  imagestreamtags.image.openshift.io                         []                 []              [create delete deletecollection get list patch update watch get list watch]
  routes.route.openshift.io                                  []                 []              [create delete deletecollection get list patch update watch get list watch]
  processedtemplates.template.openshift.io                   []                 []              [create delete deletecollection get list patch update watch get list watch]
  templateconfigs.template.openshift.io                      []                 []              [create delete deletecollection get list patch update watch get list watch]
  templateinstances.template.openshift.io                    []                 []              [create delete deletecollection get list patch update watch get list watch]
  templates.template.openshift.io                            []                 []              [create delete deletecollection get list patch update watch get list watch]
  serviceaccounts                                            []                 []              [create delete deletecollection get list patch update watch impersonate create delete deletecollection patch update get list watch]
  imagestreams/secrets                                       []                 []              [create delete deletecollection get list patch update watch]
  rolebindings                                               []                 []              [create delete deletecollection get list patch update watch]
  roles                                                      []                 []              [create delete deletecollection get list patch update watch]
  rolebindings.authorization.openshift.io                    []                 []              [create delete deletecollection get list patch update watch]
  roles.authorization.openshift.io                           []                 []              [create delete deletecollection get list patch update watch]
  imagestreams.image.openshift.io/secrets                    []                 []              [create delete deletecollection get list patch update watch]
  rolebindings.rbac.authorization.k8s.io                     []                 []              [create delete deletecollection get list patch update watch]
  roles.rbac.authorization.k8s.io                            []                 []              [create delete deletecollection get list patch update watch]
  networkpolicies.extensions                                 []                 []              [create delete deletecollection patch update create delete deletecollection get list patch update watch get list watch]
  networkpolicies.networking.k8s.io                          []                 []              [create delete deletecollection patch update create delete deletecollection get list patch update watch get list watch]
  configmaps                                                 []                 []              [create delete deletecollection patch update get list watch]
  endpoints                                                  []                 []              [create delete deletecollection patch update get list watch]
  persistentvolumeclaims                                     []                 []              [create delete deletecollection patch update get list watch]
  pods                                                       []                 []              [create delete deletecollection patch update get list watch]
  replicationcontrollers/scale                               []                 []              [create delete deletecollection patch update get list watch]
  replicationcontrollers                                     []                 []              [create delete deletecollection patch update get list watch]
  services                                                   []                 []              [create delete deletecollection patch update get list watch]
  daemonsets.apps                                            []                 []              [create delete deletecollection patch update get list watch]
  deployments.apps/scale                                     []                 []              [create delete deletecollection patch update get list watch]
  deployments.apps                                           []                 []              [create delete deletecollection patch update get list watch]
  replicasets.apps/scale                                     []                 []              [create delete deletecollection patch update get list watch]
  replicasets.apps                                           []                 []              [create delete deletecollection patch update get list watch]
  statefulsets.apps/scale                                    []                 []              [create delete deletecollection patch update get list watch]
  statefulsets.apps                                          []                 []              [create delete deletecollection patch update get list watch]
  horizontalpodautoscalers.autoscaling                       []                 []              [create delete deletecollection patch update get list watch]
  cronjobs.batch                                             []                 []              [create delete deletecollection patch update get list watch]
  jobs.batch                                                 []                 []              [create delete deletecollection patch update get list watch]
  daemonsets.extensions                                      []                 []              [create delete deletecollection patch update get list watch]
  deployments.extensions/scale                               []                 []              [create delete deletecollection patch update get list watch]
  deployments.extensions                                     []                 []              [create delete deletecollection patch update get list watch]
  ingresses.extensions                                       []                 []              [create delete deletecollection patch update get list watch]
  replicasets.extensions/scale                               []                 []              [create delete deletecollection patch update get list watch]
  replicasets.extensions                                     []                 []              [create delete deletecollection patch update get list watch]
  replicationcontrollers.extensions/scale                    []                 []              [create delete deletecollection patch update get list watch]
  poddisruptionbudgets.policy                                []                 []              [create delete deletecollection patch update get list watch]
  deployments.apps/rollback                                  []                 []              [create delete deletecollection patch update]
  deployments.extensions/rollback                            []                 []              [create delete deletecollection patch update]
  catalogsources.operators.coreos.com                        []                 []              [create update patch delete get list watch]
  clusterserviceversions.operators.coreos.com                []                 []              [create update patch delete get list watch]
  installplans.operators.coreos.com                          []                 []              [create update patch delete get list watch]
  packagemanifests.operators.coreos.com                      []                 []              [create update patch delete get list watch]
  subscriptions.operators.coreos.com                         []                 []              [create update patch delete get list watch]
  buildconfigs/instantiate                                   []                 []              [create]
  buildconfigs/instantiatebinary                             []                 []              [create]
  builds/clone                                               []                 []              [create]
  deploymentconfigrollbacks                                  []                 []              [create]
  deploymentconfigs/instantiate                              []                 []              [create]
  deploymentconfigs/rollback                                 []                 []              [create]
  imagestreamimports                                         []                 []              [create]
  localresourceaccessreviews                                 []                 []              [create]
  localsubjectaccessreviews                                  []                 []              [create]
  podsecuritypolicyreviews                                   []                 []              [create]
  podsecuritypolicyselfsubjectreviews                        []                 []              [create]
  podsecuritypolicysubjectreviews                            []                 []              [create]
  resourceaccessreviews                                      []                 []              [create]
  routes/custom-host                                         []                 []              [create]
  subjectaccessreviews                                       []                 []              [create]
  subjectrulesreviews                                        []                 []              [create]
  deploymentconfigrollbacks.apps.openshift.io                []                 []              [create]
  deploymentconfigs.apps.openshift.io/instantiate            []                 []              [create]
  deploymentconfigs.apps.openshift.io/rollback               []                 []              [create]
  localsubjectaccessreviews.authorization.k8s.io             []                 []              [create]
  localresourceaccessreviews.authorization.openshift.io      []                 []              [create]
  localsubjectaccessreviews.authorization.openshift.io       []                 []              [create]
  resourceaccessreviews.authorization.openshift.io           []                 []              [create]
  subjectaccessreviews.authorization.openshift.io            []                 []              [create]
  subjectrulesreviews.authorization.openshift.io             []                 []              [create]
  buildconfigs.build.openshift.io/instantiate                []                 []              [create]
  buildconfigs.build.openshift.io/instantiatebinary          []                 []              [create]
  builds.build.openshift.io/clone                            []                 []              [create]
  imagestreamimports.image.openshift.io                      []                 []              [create]
  routes.route.openshift.io/custom-host                      []                 []              [create]
  podsecuritypolicyreviews.security.openshift.io             []                 []              [create]
  podsecuritypolicyselfsubjectreviews.security.openshift.io  []                 []              [create]
  podsecuritypolicysubjectreviews.security.openshift.io      []                 []              [create]
  jenkins.build.openshift.io                                 []                 []              [edit view view admin edit view]
  builds                                                     []                 []              [get create delete deletecollection get list patch update watch get list watch]
  builds.build.openshift.io                                  []                 []              [get create delete deletecollection get list patch update watch get list watch]
  projects                                                   []                 []              [get delete get delete get patch update]
  projects.project.openshift.io                              []                 []              [get delete get delete get patch update]
  namespaces                                                 []                 []              [get get list watch]
  pods/attach                                                []                 []              [get list watch create delete deletecollection patch update]
  pods/exec                                                  []                 []              [get list watch create delete deletecollection patch update]
  pods/portforward                                           []                 []              [get list watch create delete deletecollection patch update]
  pods/proxy                                                 []                 []              [get list watch create delete deletecollection patch update]
  services/proxy                                             []                 []              [get list watch create delete deletecollection patch update]
  routes/status                                              []                 []              [get list watch update]
  routes.route.openshift.io/status                           []                 []              [get list watch update]
  appliedclusterresourcequotas                               []                 []              [get list watch]
  bindings                                                   []                 []              [get list watch]
  builds/log                                                 []                 []              [get list watch]
  deploymentconfigs/log                                      []                 []              [get list watch]
  deploymentconfigs/status                                   []                 []              [get list watch]
  events                                                     []                 []              [get list watch]
  imagestreams/status                                        []                 []              [get list watch]
  limitranges                                                []                 []              [get list watch]
  namespaces/status                                          []                 []              [get list watch]
  pods/log                                                   []                 []              [get list watch]
  pods/status                                                []                 []              [get list watch]
  replicationcontrollers/status                              []                 []              [get list watch]
  resourcequotas/status                                      []                 []              [get list watch]
  resourcequotas                                             []                 []              [get list watch]
  resourcequotausages                                        []                 []              [get list watch]
  rolebindingrestrictions                                    []                 []              [get list watch]
  deploymentconfigs.apps.openshift.io/log                    []                 []              [get list watch]
  deploymentconfigs.apps.openshift.io/status                 []                 []              [get list watch]
  controllerrevisions.apps                                   []                 []              [get list watch]
  rolebindingrestrictions.authorization.openshift.io         []                 []              [get list watch]
  builds.build.openshift.io/log                              []                 []              [get list watch]
  imagestreams.image.openshift.io/status                     []                 []              [get list watch]
  appliedclusterresourcequotas.quota.openshift.io            []                 []              [get list watch]
  imagestreams/layers                                        []                 []              [get update get]
  imagestreams.image.openshift.io/layers                     []                 []              [get update get]
  builds/details                                             []                 []              [update]
  builds.build.openshift.io/details                          []                 []              [update]


Name:         basic-user
Labels:       &lt;none&gt;
Annotations:  openshift.io/description: A user that can get basic information about projects.
	              rbac.authorization.kubernetes.io/autoupdate: true
PolicyRule:
	Resources                                           Non-Resource URLs  Resource Names  Verbs
	  ---------                                           -----------------  --------------  -----
	  selfsubjectrulesreviews                             []                 []              [create]
	  selfsubjectaccessreviews.authorization.k8s.io       []                 []              [create]
	  selfsubjectrulesreviews.authorization.openshift.io  []                 []              [create]
	  clusterroles.rbac.authorization.k8s.io              []                 []              [get list watch]
	  clusterroles                                        []                 []              [get list]
	  clusterroles.authorization.openshift.io             []                 []              [get list]
	  storageclasses.storage.k8s.io                       []                 []              [get list]
	  users                                               []                 [~]             [get]
	  users.user.openshift.io                             []                 [~]             [get]
	  projects                                            []                 []              [list watch]
	  projects.project.openshift.io                       []                 []              [list watch]
	  projectrequests                                     []                 []              [list]
	  projectrequests.project.openshift.io                []                 []              [list]

Name:         cluster-admin
Labels:       kubernetes.io/bootstrapping=rbac-defaults
Annotations:  rbac.authorization.kubernetes.io/autoupdate: true
PolicyRule:
Resources  Non-Resource URLs  Resource Names  Verbs
---------  -----------------  --------------  -----
*.*        []                 []              [*]
           [*]                []              [*]

...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To view the current set of cluster role bindings, which shows the users and
groups that are bound to various roles:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe clusterrolebinding.rbac</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         alertmanager-main
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  alertmanager-main
Subjects:
  Kind            Name               Namespace
  ----            ----               ---------
  ServiceAccount  alertmanager-main  openshift-monitoring


Name:         basic-users
Labels:       &lt;none&gt;
Annotations:  rbac.authorization.kubernetes.io/autoupdate: true
Role:
  Kind:  ClusterRole
  Name:  basic-user
Subjects:
  Kind   Name                  Namespace
  ----   ----                  ---------
  Group  system:authenticated


Name:         cloud-credential-operator-rolebinding
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  cloud-credential-operator-role
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  default  openshift-cloud-credential-operator


Name:         cluster-admin
Labels:       kubernetes.io/bootstrapping=rbac-defaults
Annotations:  rbac.authorization.kubernetes.io/autoupdate: true
Role:
  Kind:  ClusterRole
  Name:  cluster-admin
Subjects:
  Kind   Name            Namespace
  ----   ----            ---------
  Group  system:masters


Name:         cluster-admins
Labels:       &lt;none&gt;
Annotations:  rbac.authorization.kubernetes.io/autoupdate: true
Role:
  Kind:  ClusterRole
  Name:  cluster-admin
Subjects:
  Kind   Name                   Namespace
  ----   ----                   ---------
  Group  system:cluster-admins
  User   system:admin


Name:         cluster-api-manager-rolebinding
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  cluster-api-manager-role
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  default  openshift-machine-api

...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="viewing-local-roles_using-rbac">
<title>Viewing local roles and bindings</title>
<simpara>You can use the <literal>oc</literal> CLI to view local roles and bindings by using the
<literal>oc describe</literal> command.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the <literal>oc</literal> CLI.</simpara>
</listitem>
<listitem>
<simpara>Obtain permission to view the local roles and bindings:</simpara>
<itemizedlist>
<listitem>
<simpara>Users with the <literal>cluster-admin</literal> default cluster role bound cluster-wide can
perform any action on any resource, including viewing local roles and bindings.</simpara>
</listitem>
<listitem>
<simpara>Users with the <literal>admin</literal> default cluster role bound locally can view and manage
roles and bindings in that project.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To view the current set of local role bindings, which show the users and groups
that are bound to various roles for the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe rolebinding.rbac</programlisting>
</listitem>
<listitem>
<simpara>To view the local role bindings for a different project, add the <literal>-n</literal> flag
to the command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe rolebinding.rbac -n joe-project</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         admin
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name        Namespace
  ----  ----        ---------
  User  kube:admin


Name:         system:deployers
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows deploymentconfigs in this namespace to rollout pods in
                this namespace.  It is auto-managed by a controller; remove
                subjects to disa...
Role:
  Kind:  ClusterRole
  Name:  system:deployer
Subjects:
  Kind            Name      Namespace
  ----            ----      ---------
  ServiceAccount  deployer  joe-project


Name:         system:image-builders
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows builds in this namespace to push images to this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-builder
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  builder  joe-project


Name:         system:image-pullers
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows all pods in this namespace to pull images from this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-puller
Subjects:
  Kind   Name                                Namespace
  ----   ----                                ---------
  Group  system:serviceaccounts:joe-project</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="adding-roles_using-rbac">
<title>Adding roles to users</title>
<simpara>You can use  the <literal>oc adm</literal> administrator CLI to manage the roles and bindings.</simpara>
<simpara>Binding, or adding, a role to users or groups gives the user or group the access
that is granted by the role. You can add and remove roles to and from users and
groups using <literal>oc adm policy</literal> commands.</simpara>
<simpara>You can bind any of the default cluster roles to local users or groups in your
project.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Add a role to a user in a specific project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-role-to-user &lt;role&gt; &lt;user&gt; -n &lt;project&gt;</programlisting>
<simpara>For example, you can add the <literal>admin</literal> role to the <literal>alice</literal> user in <literal>joe</literal> project
by running:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-role-to-user admin alice -n joe</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the role to the user:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: admin-0
  namespace: joe
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: alice</programlisting>
</tip>
</listitem>
<listitem>
<simpara>View the local role bindings and verify the addition in the output:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe rolebinding.rbac -n &lt;project&gt;</programlisting>
<simpara>For example, to view the local role bindings for the <literal>joe</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe rolebinding.rbac -n joe</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:         admin
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name        Namespace
  ----  ----        ---------
  User  kube:admin


Name:         admin-0
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Role:
  Kind:  ClusterRole
  Name:  admin
Subjects:
  Kind  Name   Namespace
  ----  ----   ---------
  User  alice <co xml:id="CO26-1"/>


Name:         system:deployers
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows deploymentconfigs in this namespace to rollout pods in
                this namespace.  It is auto-managed by a controller; remove
                subjects to disa...
Role:
  Kind:  ClusterRole
  Name:  system:deployer
Subjects:
  Kind            Name      Namespace
  ----            ----      ---------
  ServiceAccount  deployer  joe


Name:         system:image-builders
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows builds in this namespace to push images to this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-builder
Subjects:
  Kind            Name     Namespace
  ----            ----     ---------
  ServiceAccount  builder  joe


Name:         system:image-pullers
Labels:       &lt;none&gt;
Annotations:  openshift.io/description:
                Allows all pods in this namespace to pull images from this
                namespace.  It is auto-managed by a controller; remove subjects
                to disable.
Role:
  Kind:  ClusterRole
  Name:  system:image-puller
Subjects:
  Kind   Name                                Namespace
  ----   ----                                ---------
  Group  system:serviceaccounts:joe</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO26-1">
<para>The <literal>alice</literal> user has been added to the <literal>admins</literal> <literal>RoleBinding</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="creating-local-role_using-rbac">
<title>Creating a local role</title>
<simpara>You can create a local role for a project and then bind it to a user.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To create a local role for a project, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create role &lt;name&gt; --verb=&lt;verb&gt; --resource=&lt;resource&gt; -n &lt;project&gt;</programlisting>
<simpara>In this command, specify:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;name&gt;</literal>, the local role&#8217;s name</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;verb&gt;</literal>, a comma-separated list of the verbs to apply to the role</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;resource&gt;</literal>, the resources that the role applies to</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;project&gt;</literal>, the project name</simpara>
</listitem>
</itemizedlist>
<simpara>For example, to create a local role that allows a user to view pods in the
<literal>blue</literal> project, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create role podview --verb=get --resource=pod -n blue</programlisting>
</listitem>
<listitem>
<simpara>To bind the new role to a user, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-role-to-user podview user2 --role-namespace=blue -n blue</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="creating-cluster-role_using-rbac">
<title>Creating a cluster role</title>
<simpara>You can create a cluster role.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To create a cluster role, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create clusterrole &lt;name&gt; --verb=&lt;verb&gt; --resource=&lt;resource&gt;</programlisting>
<simpara>In this command, specify:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>&lt;name&gt;</literal>, the local role&#8217;s name</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;verb&gt;</literal>, a comma-separated list of the verbs to apply to the role</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;resource&gt;</literal>, the resources that the role applies to</simpara>
</listitem>
</itemizedlist>
<simpara>For example, to create a cluster role that allows a user to view pods, run the
following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create clusterrole podviewonly --verb=get --resource=pod</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="local-role-binding-commands_using-rbac">
<title>Local role binding commands</title>
<simpara>When you manage a user or group&#8217;s associated roles for local role bindings using the
following operations, a project may be specified with the <literal>-n</literal> flag. If it is
not specified, then the current project is used.</simpara>
<simpara>You can use the following commands for local RBAC management.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Local role binding operations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy who-can <emphasis>&lt;verb&gt;</emphasis> <emphasis>&lt;resource&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Indicates which users can perform an action on a resource.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy add-role-to-user <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;username&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Binds a specified role to specified users in the current project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-role-from-user <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;username&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes a given role from specified users in the current project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-user <emphasis>&lt;username&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes specified users and all of their roles in the current project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy add-role-to-group <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;groupname&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Binds a given role to specified groups in the current project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-role-from-group <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;groupname&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes a given role from specified groups in the current project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-group <emphasis>&lt;groupname&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes specified groups and all of their roles in the current project.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="cluster-role-binding-commands_using-rbac">
<title>Cluster role binding commands</title>
<simpara>You can also manage cluster role bindings using the following
operations. The <literal>-n</literal> flag is not used for these operations because
cluster role bindings use non-namespaced resources.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Cluster role binding operations</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy add-cluster-role-to-user <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;username&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Binds a given role to specified users for all projects in the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-cluster-role-from-user <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;username&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes a given role from specified users for all projects in the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy add-cluster-role-to-group <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;groupname&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Binds a given role to specified groups for all projects in the cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>$ oc adm policy remove-cluster-role-from-group <emphasis>&lt;role&gt;</emphasis> <emphasis>&lt;groupname&gt;</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes a given role from specified groups for all projects in the cluster.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="creating-cluster-admin_using-rbac">
<title>Creating a cluster admin</title>
<simpara>The <literal>cluster-admin</literal> role is required to perform administrator
level tasks on the OpenShift Container Platform cluster, such as modifying
cluster resources.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have created a user to define as the cluster admin.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Define the user as a cluster admin:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-cluster-role-to-user cluster-admin &lt;user&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="removing-kubeadmin">
<title>Removing the kubeadmin user</title>

<section xml:id="understanding-kubeadmin_removing-kubeadmin">
<title>The kubeadmin user</title>
<simpara>OpenShift Container Platform creates a cluster administrator, <literal>kubeadmin</literal>, after the
installation process completes.</simpara>
<simpara>This user has the <literal>cluster-admin</literal> role automatically applied and is treated
as the root user for the cluster. The password is dynamically generated
and unique to your OpenShift Container Platform environment. After installation
completes the password is provided in the installation program&#8217;s output.
For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">INFO Install complete!
INFO Run 'export KUBECONFIG=&lt;your working directory&gt;/auth/kubeconfig' to manage the cluster with 'oc', the OpenShift CLI.
INFO The cluster is ready when 'oc login -u kubeadmin -p &lt;provided&gt;' succeeds (wait a few minutes).
INFO Access the OpenShift web-console here: https://console-openshift-console.apps.demo1.openshift4-beta-abcorp.com
INFO Login to the console with user: kubeadmin, password: &lt;provided&gt;</programlisting>
</section>
<section xml:id="removing-kubeadmin_removing-kubeadmin">
<title>Removing the kubeadmin user</title>
<simpara>After you define an identity provider and create a new <literal>cluster-admin</literal>
user, you can remove the <literal>kubeadmin</literal> to improve cluster security.</simpara>
<warning>
<simpara>If you follow this procedure before another user is a <literal>cluster-admin</literal>,
then OpenShift Container Platform must be reinstalled. It is not possible to undo
this command.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You must have configured at least one identity provider.</simpara>
</listitem>
<listitem>
<simpara>You must have added the <literal>cluster-admin</literal> role to a user.</simpara>
</listitem>
<listitem>
<simpara>You must be logged in as an administrator.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Remove the <literal>kubeadmin</literal> secrets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secrets kubeadmin -n kube-system</programlisting>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="understanding-and-creating-service-accounts">
<title>Understanding and creating service accounts</title>

<section xml:id="service-accounts-overview_understanding-service-accounts">
<title>Service accounts overview</title>
<simpara>A service account is an OpenShift Container Platform account that allows a component to
directly access the API. Service accounts are API objects that exist within each project.
Service accounts provide a flexible way to control API
access without sharing a regular user&#8217;s credentials.</simpara>
<simpara>When you use the OpenShift Container Platform CLI or web console, your API token
authenticates you to the API. You can associate a component with a service account
so that they can access the API without using a regular user&#8217;s credentials.
For example, service accounts can allow:</simpara>
<itemizedlist>
<listitem>
<simpara>Replication controllers to make API calls to create or delete pods.</simpara>
</listitem>
<listitem>
<simpara>Applications inside containers to make API calls for discovery purposes.</simpara>
</listitem>
<listitem>
<simpara>External applications to make API calls for monitoring or integration purposes.</simpara>
</listitem>
</itemizedlist>
<simpara>Each service account&#8217;s user name is derived from its project and name:</simpara>
<programlisting language="text" linenumbering="unnumbered">system:serviceaccount:&lt;project&gt;:&lt;name&gt;</programlisting>
<simpara>Every service account is also a member of two groups:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Group</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>system:serviceaccounts</simpara></entry>
<entry align="left" valign="top"><simpara>Includes all service accounts in the system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>system:serviceaccounts:&lt;project&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Includes all service accounts in the
specified project.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Each service account automatically contains two secrets:</simpara>
<itemizedlist>
<listitem>
<simpara>An API token</simpara>
</listitem>
<listitem>
<simpara>Credentials for the OpenShift Container Registry</simpara>
</listitem>
</itemizedlist>
<simpara>The generated API token and registry credentials do not expire, but you can
revoke them by deleting the secret. When you delete the secret, a new one is
automatically generated to take its place.</simpara>
</section>
<section xml:id="service-accounts-managing_understanding-service-accounts">
<title>Creating service accounts</title>
<simpara>You can create a service account in a project and grant it permissions by
binding it to a role.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: To view the service accounts in the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sa</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       SECRETS   AGE
builder    2         2d
default    2         2d
deployer   2         2d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To create a new service account in the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create sa &lt;service_account_name&gt; <co xml:id="CO27-1"/></programlisting>
<calloutlist>
<callout arearefs="CO27-1">
<para>To create a service account in a different project, specify <literal>-n &lt;project_name&gt;</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">serviceaccount "robot" created</programlisting>
</para>
</formalpara>
<tip>
<simpara>You can alternatively apply the following YAML to create the service account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  name: &lt;service_account_name&gt;
  namespace: &lt;current_project&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Optional: View the secrets for the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe sa robot</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                robot
Namespace:           project1
Labels:	             &lt;none&gt;
Annotations:	     &lt;none&gt;
Image pull secrets:  robot-dockercfg-qzbhb
Mountable secrets:   robot-dockercfg-qzbhb
Tokens:              robot-token-f4khf
Events:              &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="service-accounts-granting-roles_understanding-service-accounts">
<title>Examples of granting roles to service accounts</title>
<simpara>You can grant roles to service accounts in the same way that you grant roles
to a regular user account.</simpara>
<itemizedlist>
<listitem>
<simpara>You can modify the service accounts for the current project. For example, to add
the <literal>view</literal> role to the <literal>robot</literal> service account in the <literal>top-secret</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user view system:serviceaccount:top-secret:robot</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: view
  namespace: top-secret
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- kind: ServiceAccount
  name: robot
  namespace: top-secret</programlisting>
</tip>
</listitem>
<listitem>
<simpara>You can also grant access to a specific service account in a project. For
example, from the project to which the service account belongs, use
the <literal>-z</literal> flag and specify the <literal>&lt;service_account_name&gt;</literal></simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-user &lt;role_name&gt; -z &lt;service_account_name&gt;</programlisting>
<important>
<simpara>If you want to grant access to a specific service account in a project, use the
<literal>-z</literal> flag. Using this flag helps prevent typos and ensures that access
is granted to only the specified service account.</simpara>
</important>
<tip>
<simpara>You can alternatively apply the following YAML to add the role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: &lt;rolebinding_name&gt;
  namespace: &lt;current_project_name&gt;
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: &lt;role_name&gt;
subjects:
- kind: ServiceAccount
  name: &lt;service_account_name&gt;
  namespace: &lt;current_project_name&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>To modify a different namespace, you can use the <literal>-n</literal> option to indicate the
project namespace it applies to, as shown in the following examples.</simpara>
<itemizedlist>
<listitem>
<simpara>For example, to allow all service accounts in all projects to view resources in
the <literal>my-project</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-group view system:serviceaccounts -n my-project</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: view
  namespace: my-project
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: view
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:serviceaccounts</programlisting>
</tip>
</listitem>
<listitem>
<simpara>To allow all service accounts in the <literal>managers</literal> project to edit resources in the
<literal>my-project</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc policy add-role-to-group edit system:serviceaccounts:managers -n my-project</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to add the role:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: edit
  namespace: my-project
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: edit
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:serviceaccounts:managers</programlisting>
</tip>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="using-service-accounts">
<title>Using service accounts in applications</title>

<section xml:id="service-accounts-overview_using-service-accounts">
<title>Service accounts overview</title>
<simpara>A service account is an OpenShift Container Platform account that allows a component to
directly access the API. Service accounts are API objects that exist within each project.
Service accounts provide a flexible way to control API
access without sharing a regular user&#8217;s credentials.</simpara>
<simpara>When you use the OpenShift Container Platform CLI or web console, your API token
authenticates you to the API. You can associate a component with a service account
so that they can access the API without using a regular user&#8217;s credentials.
For example, service accounts can allow:</simpara>
<itemizedlist>
<listitem>
<simpara>Replication controllers to make API calls to create or delete pods.</simpara>
</listitem>
<listitem>
<simpara>Applications inside containers to make API calls for discovery purposes.</simpara>
</listitem>
<listitem>
<simpara>External applications to make API calls for monitoring or integration purposes.</simpara>
</listitem>
</itemizedlist>
<simpara>Each service account&#8217;s user name is derived from its project and name:</simpara>
<programlisting language="text" linenumbering="unnumbered">system:serviceaccount:&lt;project&gt;:&lt;name&gt;</programlisting>
<simpara>Every service account is also a member of two groups:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Group</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>system:serviceaccounts</simpara></entry>
<entry align="left" valign="top"><simpara>Includes all service accounts in the system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>system:serviceaccounts:&lt;project&gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Includes all service accounts in the
specified project.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Each service account automatically contains two secrets:</simpara>
<itemizedlist>
<listitem>
<simpara>An API token</simpara>
</listitem>
<listitem>
<simpara>Credentials for the OpenShift Container Registry</simpara>
</listitem>
</itemizedlist>
<simpara>The generated API token and registry credentials do not expire, but you can
revoke them by deleting the secret. When you delete the secret, a new one is
automatically generated to take its place.</simpara>
</section>
<section xml:id="service-accounts-default_using-service-accounts">
<title>Default service accounts</title>
<simpara>Your OpenShift Container Platform cluster contains default service accounts for
cluster management and generates more service accounts for each project.</simpara>
<section xml:id="default-cluster-service-accounts_using-service-accounts">
<title>Default cluster service accounts</title>
<simpara>Several infrastructure controllers run using service account credentials. The
following service accounts are created in the OpenShift Container Platform infrastructure
project (<literal>openshift-infra</literal>) at server start, and given the following roles
cluster-wide:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Service Account</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>replication-controller</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Assigned the <literal>system:replication-controller</literal> role</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>deployment-controller</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Assigned the <literal>system:deployment-controller</literal> role</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>build-controller</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Assigned the <literal>system:build-controller</literal> role. Additionally, the
<literal>build-controller</literal> service account is included in the privileged
security context constraint to create privileged
build pods.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="default-service-accounts-and-roles_using-service-accounts">
<title>Default project service accounts and roles</title>
<simpara>Three service accounts are automatically created in each project:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Service Account</entry>
<entry align="left" valign="top">Usage</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>builder</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used by build pods. It is given the <literal>system:image-builder</literal> role, which allows
pushing images to any imagestream in the project using the internal Docker
registry.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>deployer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used by deployment pods and given the <literal>system:deployer</literal> role, which allows
viewing and modifying replication controllers and pods in the project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>default</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used to run all other pods unless they specify a different service account.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All service accounts in a project are given the <literal>system:image-puller</literal> role,
which allows pulling images from any imagestream in the project using the
internal container image registry.</simpara>
</section>
<section xml:id="auto-generated-sa-token-secrets_using-service-accounts">
<title>Automatically generated secrets</title>
<simpara>By default, OpenShift Container Platform creates the following secrets for each service account:</simpara>
<itemizedlist>
<listitem>
<simpara>A dockercfg image pull secret</simpara>
</listitem>
<listitem>
<simpara>A service account token secret</simpara>
<note>
<simpara>Prior to OpenShift Container Platform 4.11, a second service account token secret was generated when a service account was created. This service account token secret was used to access the Kubernetes API.</simpara>
<simpara>Starting with OpenShift Container Platform 4.11, this second service account token secret is no longer created. This is because the <literal>LegacyServiceAccountTokenNoAutoGeneration</literal> upstream Kubernetes feature gate was enabled, which stops the automatic generation of secret-based service account tokens to access the Kubernetes API.</simpara>
<simpara>After upgrading to 4.14, any existing service account token secrets are not deleted and continue to function.</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>This service account token secret and docker configuration image pull secret are necessary to integrate the OpenShift image registry into the cluster&#8217;s user authentication and authorization system.</simpara>
<simpara>However, if you do not enable the <literal>ImageRegistry</literal> capability or if you disable the integrated OpenShift image registry in the Cluster Image Registry Operator&#8217;s configuration, these secrets are not generated for each service account.</simpara>
<warning>
<simpara>Do not rely on these automatically generated secrets for your own use; they might be removed in a future OpenShift Container Platform release.</simpara>
</warning>
<simpara>Workloads are automatically injected with a projected volume to obtain a bound service account token. If your workload needs an additional service account token, add an additional projected volume in your workload manifest. Bound service account tokens are more secure than service account token secrets for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>Bound service account tokens have a bounded lifetime.</simpara>
</listitem>
<listitem>
<simpara>Bound service account tokens contain audiences.</simpara>
</listitem>
<listitem>
<simpara>Bound service account tokens can be bound to pods or secrets and the bound tokens are invalidated when the bound object is removed.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information, see <emphasis>Configuring bound service account tokens using volume projection</emphasis>.</simpara>
<simpara>You can also manually create a service account token secret to obtain a token, if the security exposure of a non-expiring token in a readable API object is acceptable to you. For more information, see <emphasis>Creating a service account token secret</emphasis>.</simpara>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara>For information about requesting bound service account tokens, see <link xlink:href="../authentication/bound-service-account-tokens.xml#bound-sa-tokens-configuring_bound-service-account-tokens">Configuring bound service account tokens using volume projection</link>.</simpara>
</listitem>
<listitem>
<simpara>For information about creating a service account token secret, see <link xlink:href="../nodes/pods/nodes-pods-secrets.xml#nodes-pods-secrets-creating-sa_nodes-pods-secrets">Creating a service account token secret</link>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="service-accounts-managing_using-service-accounts">
<title>Creating service accounts</title>
<simpara>You can create a service account in a project and grant it permissions by
binding it to a role.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: To view the service accounts in the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get sa</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME       SECRETS   AGE
builder    2         2d
default    2         2d
deployer   2         2d</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>To create a new service account in the current project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create sa &lt;service_account_name&gt; <co xml:id="CO28-1"/></programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>To create a service account in a different project, specify <literal>-n &lt;project_name&gt;</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">serviceaccount "robot" created</programlisting>
</para>
</formalpara>
<tip>
<simpara>You can alternatively apply the following YAML to create the service account:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ServiceAccount
metadata:
  name: &lt;service_account_name&gt;
  namespace: &lt;current_project&gt;</programlisting>
</tip>
</listitem>
<listitem>
<simpara>Optional: View the secrets for the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe sa robot</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                robot
Namespace:           project1
Labels:	             &lt;none&gt;
Annotations:	     &lt;none&gt;
Image pull secrets:  robot-dockercfg-qzbhb
Mountable secrets:   robot-dockercfg-qzbhb
Tokens:              robot-token-f4khf
Events:              &lt;none&gt;</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="using-service-accounts-as-oauth-client">
<title>Using a service account as an OAuth client</title>

<section xml:id="service-accounts-as-oauth-clients_using-service-accounts-as-oauth-client">
<title>Service accounts as OAuth clients</title>
<simpara>You can use a service account as a constrained form of OAuth client.
Service accounts can request only a subset of scopes that
allow access to some basic user information
and role-based power inside of the service account&#8217;s own namespace:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>user:info</literal></simpara>
</listitem>
<listitem>
<simpara><literal>user:check-access</literal></simpara>
</listitem>
<listitem>
<simpara><literal>role:&lt;any_role&gt;:&lt;service_account_namespace&gt;</literal></simpara>
</listitem>
<listitem>
<simpara><literal>role:&lt;any_role&gt;:&lt;service_account_namespace&gt;:!</literal></simpara>
</listitem>
</itemizedlist>
<simpara>When using a service account as an OAuth client:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>client_id</literal> is <literal>system:serviceaccount:&lt;service_account_namespace&gt;:&lt;service_account_name&gt;</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>client_secret</literal> can be any of the API tokens for that service account. For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc sa get-token &lt;service_account_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>To get <literal>WWW-Authenticate</literal> challenges, set an
<literal>serviceaccounts.openshift.io/oauth-want-challenges</literal> annotation on the service
account to <literal>true</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>redirect_uri</literal> must match an annotation on the service account.</simpara>
</listitem>
</itemizedlist>
<section xml:id="redirect-uris-for-service-accounts_using-service-accounts-as-oauth-client">
<title>Redirect URIs for service accounts as OAuth clients</title>
<simpara>Annotation keys must have the prefix
<literal>serviceaccounts.openshift.io/oauth-redirecturi.</literal> or
<literal>serviceaccounts.openshift.io/oauth-redirectreference.</literal> such as:</simpara>
<screen>serviceaccounts.openshift.io/oauth-redirecturi.&lt;name&gt;</screen>
<simpara>In its simplest form, the annotation can be used to directly specify valid
redirect URIs. For example:</simpara>
<screen>"serviceaccounts.openshift.io/oauth-redirecturi.first":  "https://example.com"
"serviceaccounts.openshift.io/oauth-redirecturi.second": "https://other.com"</screen>
<simpara>The <literal>first</literal> and <literal>second</literal> postfixes in the above example are used to separate the
two valid redirect URIs.</simpara>
<simpara>In more complex configurations, static redirect URIs may not be enough. For
example, perhaps you want all Ingresses for a route to be considered valid. This
is where dynamic redirect URIs via the
<literal>serviceaccounts.openshift.io/oauth-redirectreference.</literal> prefix come into play.</simpara>
<simpara>For example:</simpara>
<screen>"serviceaccounts.openshift.io/oauth-redirectreference.first": "{\"kind\":\"OAuthRedirectReference\",\"apiVersion\":\"v1\",\"reference\":{\"kind\":\"Route\",\"name\":\"jenkins\"}}"</screen>
<simpara>Since the value for this annotation contains serialized JSON data, it is easier
to see in an expanded format:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "kind": "OAuthRedirectReference",
  "apiVersion": "v1",
  "reference": {
    "kind": "Route",
    "name": "jenkins"
  }
}</programlisting>
<simpara>Now you can see that an <literal>OAuthRedirectReference</literal> allows us to reference the
route named <literal>jenkins</literal>. Thus, all Ingresses for that route will now be considered
valid.  The full specification for an <literal>OAuthRedirectReference</literal> is:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
  "kind": "OAuthRedirectReference",
  "apiVersion": "v1",
  "reference": {
    "kind": ..., <co xml:id="CO29-1"/>
    "name": ..., <co xml:id="CO29-2"/>
    "group": ... <co xml:id="CO29-3"/>
  }
}</programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para><literal>kind</literal> refers to the type of the object being referenced. Currently, only <literal>route</literal> is supported.</para>
</callout>
<callout arearefs="CO29-2">
<para><literal>name</literal> refers to the name of the object. The object must be in the same namespace as the service account.</para>
</callout>
<callout arearefs="CO29-3">
<para><literal>group</literal> refers to the group of the object. Leave this blank, as the group for a route is the empty string.</para>
</callout>
</calloutlist>
<simpara>Both annotation prefixes can be combined to override the data provided by the
reference object. For example:</simpara>
<screen>"serviceaccounts.openshift.io/oauth-redirecturi.first":  "custompath"
"serviceaccounts.openshift.io/oauth-redirectreference.first": "{\"kind\":\"OAuthRedirectReference\",\"apiVersion\":\"v1\",\"reference\":{\"kind\":\"Route\",\"name\":\"jenkins\"}}"</screen>
<simpara>The <literal>first</literal> postfix is used to tie the annotations together. Assuming that the
<literal>jenkins</literal> route had an Ingress of <literal>https://example.com</literal>, now
<literal>https://example.com/custompath</literal> is considered valid, but
<literal>https://example.com</literal> is not.  The format for partially supplying override
data is as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Type</entry>
<entry align="left" valign="top">Syntax</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Scheme</simpara></entry>
<entry align="left" valign="top"><simpara>"https://"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Hostname</simpara></entry>
<entry align="left" valign="top"><simpara>"//website.com"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Port</simpara></entry>
<entry align="left" valign="top"><simpara>"//:8000"</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Path</simpara></entry>
<entry align="left" valign="top"><simpara>"examplepath"</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<note>
<simpara>Specifying a hostname override will replace the hostname data from the
referenced object, which is not likely to be desired behavior.</simpara>
</note>
<simpara>Any combination of the above syntax can be combined using the following format:</simpara>
<simpara><literal>&lt;scheme:&gt;//&lt;hostname&gt;&lt;:port&gt;/&lt;path&gt;</literal></simpara>
<simpara>The same object can be referenced more than once for more flexibility:</simpara>
<screen>"serviceaccounts.openshift.io/oauth-redirecturi.first":  "custompath"
"serviceaccounts.openshift.io/oauth-redirectreference.first": "{\"kind\":\"OAuthRedirectReference\",\"apiVersion\":\"v1\",\"reference\":{\"kind\":\"Route\",\"name\":\"jenkins\"}}"
"serviceaccounts.openshift.io/oauth-redirecturi.second":  "//:8000"
"serviceaccounts.openshift.io/oauth-redirectreference.second": "{\"kind\":\"OAuthRedirectReference\",\"apiVersion\":\"v1\",\"reference\":{\"kind\":\"Route\",\"name\":\"jenkins\"}}"</screen>
<simpara>Assuming that the route named <literal>jenkins</literal> has an Ingress of
<literal>https://example.com</literal>, then both <literal>https://example.com:8000</literal> and
<literal>https://example.com/custompath</literal> are considered valid.</simpara>
<simpara>Static and dynamic annotations can be used at the same time to achieve the
desired behavior:</simpara>
<screen>"serviceaccounts.openshift.io/oauth-redirectreference.first": "{\"kind\":\"OAuthRedirectReference\",\"apiVersion\":\"v1\",\"reference\":{\"kind\":\"Route\",\"name\":\"jenkins\"}}"
"serviceaccounts.openshift.io/oauth-redirecturi.second": "https://other.com"</screen>
</section>
</section>
</chapter>
<chapter xml:id="tokens-scoping">
<title>Scoping tokens</title>

<section xml:id="tokens-scoping-about_configuring-internal-oauth">
<title>About scoping tokens</title>
<simpara>You can create scoped tokens to delegate some of your permissions to another
user or service account.
For example, a project administrator might want to delegate the
power to create pods.</simpara>
<simpara>A scoped token is a token that identifies as a given user but is limited to
certain actions by its scope.
Only a user with the <literal>cluster-admin</literal> role can create scoped tokens.</simpara>
<simpara>Scopes are evaluated by converting the set of scopes for a token into a set of
<literal>PolicyRules</literal>. Then, the request is matched against those rules. The request
attributes must match at least one of the scope rules to be passed to the
"normal" authorizer for further authorization checks.</simpara>
<section xml:id="scoping-tokens-user-scopes_configuring-internal-oauth">
<title>User scopes</title>
<simpara>User scopes are focused on getting information about a given user. They are
intent-based, so the rules are automatically created for you:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>user:full</literal> - Allows full read/write access to the API with all of the user&#8217;s permissions.</simpara>
</listitem>
<listitem>
<simpara><literal>user:info</literal> - Allows read-only access to information about the user, such as name and groups.</simpara>
</listitem>
<listitem>
<simpara><literal>user:check-access</literal> - Allows access to <literal>self-localsubjectaccessreviews</literal> and <literal>self-subjectaccessreviews</literal>.
These are the variables where you pass an empty user and groups in your request object.</simpara>
</listitem>
<listitem>
<simpara><literal>user:list-projects</literal> - Allows read-only access to list the projects the user has access to.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="scoping-tokens-role-scope_configuring-internal-oauth">
<title>Role scope</title>
<simpara>The role scope allows you to have the same level of access as a given role
filtered by namespace.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>role:&lt;cluster-role name&gt;:&lt;namespace or * for all&gt;</literal> - Limits the scope to the
rules specified by the cluster-role, but only in the specified namespace .</simpara>
<note>
<simpara>Caveat: This prevents escalating access. Even if the role allows access to
resources like secrets, rolebindings, and roles, this scope will deny access
to those resources. This helps prevent unexpected escalations. Many people do
not think of a role like <literal>edit</literal> as being an escalating role, but with access to
a secret it is.</simpara>
</note>
</listitem>
<listitem>
<simpara><literal>role:&lt;cluster-role name&gt;:&lt;namespace or * for all&gt;:!</literal> -  This is similar to the
example above, except that including the bang causes this scope to allow
escalating access.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="bound-service-account-tokens">
<title>Using bound service account tokens</title>

<simpara>You can use bound service account tokens, which improves the ability to integrate with cloud provider identity access management (IAM) services, such as AWS IAM.</simpara>
<section xml:id="bound-sa-tokens-about_bound-service-account-tokens">
<title>About bound service account tokens</title>
<simpara>You can use bound service account tokens to limit the scope of permissions for a given service account token. These tokens are audience and time-bound. This facilitates the authentication of a service account to an IAM role and the generation of temporary credentials mounted to a pod. You can request bound service account tokens by using volume projection and the TokenRequest API.</simpara>
</section>
<section xml:id="bound-sa-tokens-configuring_bound-service-account-tokens">
<title>Configuring bound service account tokens using volume projection</title>
<simpara>You can configure pods to request bound service account tokens by using volume projection.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have created a service account. This procedure assumes that the service account is named <literal>build-robot</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Optional: Set the service account issuer.</simpara>
<simpara>This step is typically not required if the bound tokens are used only within the cluster.</simpara>
<important>
<simpara>If you change the service account issuer to a custom one, the previous service account issuer is still trusted for the next 24 hours.</simpara>
<simpara>You can force all holders to request a new bound token either by manually restarting all pods in the cluster or by performing a rolling node restart. Before performing either action, wait for a new revision of the Kubernetes API server pods to roll out with your service account issuer changes.</simpara>
</important>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the <literal>cluster</literal> <literal>Authentication</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit authentications cluster</programlisting>
</listitem>
<listitem>
<simpara>Set the <literal>spec.serviceAccountIssuer</literal> field to the desired service account issuer value:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  serviceAccountIssuer: https://test.default.svc <co xml:id="CO30-1"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>This value should be a URL from which the recipient of a bound token can source the public keys necessary to verify the signature of the token. The default is <literal>https://kubernetes.default.svc</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the file to apply the changes.</simpara>
</listitem>
<listitem>
<simpara>Wait for a new revision of the Kubernetes API server pods to roll out. It can take several minutes for all nodes to update to the new revision. Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get kubeapiserver -o=jsonpath='{range .items[0].status.conditions[?(@.type=="NodeInstallerProgressing")]}{.reason}{"\n"}{.message}{"\n"}'</programlisting>
<simpara>Review the <literal>NodeInstallerProgressing</literal> status condition for the Kubernetes API server to verify that all nodes are at the latest revision. The output shows <literal>AllNodesAtLatestRevision</literal> upon successful update:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">AllNodesAtLatestRevision
3 nodes are at revision 12 <co xml:id="CO31-1"/></programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>In this example, the latest revision number is <literal>12</literal>.</para>
</callout>
</calloutlist>
<simpara>If the output shows a message similar to one of the following messages, the update is still in progress. Wait a few minutes and try again.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>3 nodes are at revision 11; 0 nodes have achieved new revision 12</literal></simpara>
</listitem>
<listitem>
<simpara><literal>2 nodes are at revision 11; 1 nodes are at revision 12</literal></simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Optional: Force the holder to request a new bound token either by performing a rolling node restart or by manually restarting all pods in the cluster.</simpara>
<itemizedlist>
<listitem>
<simpara>Perform a rolling node restart:</simpara>
<warning>
<simpara>It is not recommended to perform a rolling node restart if you have custom workloads running on your cluster, because it can cause a service interruption. Instead, manually restart all pods in the cluster.</simpara>
</warning>
<simpara>Restart nodes sequentially. Wait for the node to become fully available before restarting the next node. See <emphasis>Rebooting a node gracefully</emphasis> for instructions on how to drain, restart, and mark a node as schedulable again.</simpara>
</listitem>
<listitem>
<simpara>Manually restart all pods in the cluster:</simpara>
<warning>
<simpara>Be aware that running this command causes a service interruption, because it deletes every running pod in every namespace. These pods will automatically restart after they are deleted.</simpara>
</warning>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ for I in $(oc get ns -o jsonpath='{range .items[*]} {.metadata.name}{"\n"} {end}'); \
      do oc delete pods --all -n $I; \
      sleep 1; \
      done</programlisting>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Configure a pod to use a bound service account token by using volume projection.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a file called <literal>pod-projected-svc-token.yaml</literal> with the following contents:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
    - mountPath: /var/run/secrets/tokens
      name: vault-token
  serviceAccountName: build-robot <co xml:id="CO32-1"/>
  volumes:
  - name: vault-token
    projected:
      sources:
      - serviceAccountToken:
          path: vault-token <co xml:id="CO32-2"/>
          expirationSeconds: 7200 <co xml:id="CO32-3"/>
          audience: vault <co xml:id="CO32-4"/></programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>A reference to an existing service account.</para>
</callout>
<callout arearefs="CO32-2">
<para>The path relative to the mount point of the file to project the token into.</para>
</callout>
<callout arearefs="CO32-3">
<para>Optionally set the expiration of the service account token, in seconds. The default is 3600 seconds (1 hour) and must be at least 600 seconds (10 minutes). The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.</para>
</callout>
<callout arearefs="CO32-4">
<para>Optionally set the intended audience of the token. The recipient of a token should verify that the recipient identity matches the audience claim of the token, and should otherwise reject the token. The audience defaults to the identifier of the API server.</para>
</callout>
</calloutlist>
<note>
<simpara>In order to prevent unexpected failure, OpenShift Container Platform overrides the <literal>expirationSeconds</literal> value to be one year from the initial token generation with the <literal>--service-account-extend-token-expiration</literal> default of <literal>true</literal>. You cannot change this setting.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pod-projected-svc-token.yaml</programlisting>
<simpara>The kubelet requests and stores the token on behalf of the pod, makes the token available to the pod at a configurable file path, and refreshes the token as it approaches expiration.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>The application that uses the bound token must handle reloading the token when it rotates.</simpara>
<simpara>The kubelet rotates the token if it is older than 80 percent of its time to live, or if the token is older than 24 hours.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="bound-sa-tokens-configuring-externally_bound-service-account-tokens">
<title>Creating bound service account tokens outside the pod</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have created a service account. This procedure assumes that the service account is named <literal>build-robot</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create the bound service account token outside the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create token build-robot</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">eyJhbGciOiJSUzI1NiIsImtpZCI6IkY2M1N4MHRvc2xFNnFSQlA4eG9GYzVPdnN3NkhIV0tRWmFrUDRNcWx4S0kifQ.eyJhdWQiOlsiaHR0cHM6Ly9pc3N1ZXIyLnRlc3QuY29tIiwiaHR0cHM6Ly9pc3N1ZXIxLnRlc3QuY29tIiwiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjIl0sImV4cCI6MTY3OTU0MzgzMCwiaWF0IjoxNjc5NTQwMjMwLCJpc3MiOiJodHRwczovL2lzc3VlcjIudGVzdC5jb20iLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImRlZmF1bHQiLCJzZXJ2aWNlYWNjb3VudCI6eyJuYW1lIjoidGVzdC1zYSIsInVpZCI6ImM3ZjA4MjkwLWIzOTUtNGM4NC04NjI4LTMzMTM1NTVhNWY1OSJ9fSwibmJmIjoxNjc5NTQwMjMwLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDp0ZXN0LXNhIn0.WyAOPvh1BFMUl3LNhBCrQeaB5wSynbnCfojWuNNPSilT4YvFnKibxwREwmzHpV4LO1xOFZHSi6bXBOmG_o-m0XNDYL3FrGHd65mymiFyluztxa2lgHVxjw5reIV5ZLgNSol3Y8bJqQqmNg3rtQQWRML2kpJBXdDHNww0E5XOypmffYkfkadli8lN5QQD-MhsCbiAF8waCYs8bj6V6Y7uUKTcxee8sCjiRMVtXKjQtooERKm-CH_p57wxCljIBeM89VdaR51NJGued4hVV5lxvVrYZFu89lBEAq4oyQN_d6N1vBWGXQMyoihnt_fQjn-NfnlJWk-3NSZDIluDJAv7e-MTEk3geDrHVQKNEzDei2-Un64hSzb-n1g1M0Vn0885wQBQAePC9UlZm8YZlMNk1tq6wIUKQTMv3HPfi5HtBRqVc2eVs0EfMX4-x-PHhPCasJ6qLJWyj6DvyQ08dP4DW_TWZVGvKlmId0hzwpg59TTcLR0iCklSEJgAVEEd13Aa_M0-faD11L3MhUGxw0qxgOsPczdXUsolSISbefs7OKymzFSIkTAn9sDQ8PHMOsuyxsK8vzfrR-E0z7MAeguZ2kaIY7cZqbN6WFy0caWgx46hrKem9vCKALefElRYbCg3hcBmowBcRTOqaFHLNnHghhU1LaRpoFzH7OUarqX9SGQ</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../nodes/nodes/nodes-nodes-rebooting.xml#nodes-nodes-rebooting-gracefully_nodes-nodes-rebooting">Rebooting a node gracefully</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/understanding-and-creating-service-accounts.xml#service-accounts-managing_understanding-service-accounts">Creating service accounts</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="managing-pod-security-policies">
<title>Managing security context constraints</title>

<simpara>In OpenShift Container Platform, you can use security context constraints (SCCs) to control permissions for the pods in your cluster.</simpara>
<simpara>Default SCCs are created during installation and when you install some Operators or other components. As a cluster administrator, you can also create your own SCCs by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<important>
<simpara>Do not modify the default SCCs. Customizing the default SCCs can lead to issues when some of the platform pods deploy or
OpenShift Container Platform
is upgraded. Additionally, the default SCC values are reset to the defaults during some cluster upgrades, which discards all customizations to those SCCs.</simpara>
<simpara>Instead of modifying the default SCCs, create and modify your own SCCs as needed. For detailed steps, see <link xlink:href="../authentication/managing-security-context-constraints.xml#security-context-constraints-creating_configuring-internal-oauth">Creating security context constraints</link>.</simpara>
</important>
<section xml:id="security-context-constraints-about_configuring-internal-oauth">
<title>About security context constraints</title>
<simpara>Similar to the way that RBAC resources control user access, administrators can use security context constraints (SCCs) to control permissions for pods. These permissions determine the actions that a pod can perform and what resources it can access. You can use SCCs to define a set of conditions that a pod must run with to be accepted into the system.</simpara>
<simpara>Security context constraints allow an administrator to control:</simpara>
<itemizedlist>
<listitem>
<simpara>Whether a pod can run privileged containers with the <literal>allowPrivilegedContainer</literal> flag</simpara>
</listitem>
<listitem>
<simpara>Whether a pod is constrained with the <literal>allowPrivilegeEscalation</literal> flag</simpara>
</listitem>
<listitem>
<simpara>The capabilities that a container can request</simpara>
</listitem>
<listitem>
<simpara>The use of host directories as volumes</simpara>
</listitem>
<listitem>
<simpara>The SELinux context of the container</simpara>
</listitem>
<listitem>
<simpara>The container user ID</simpara>
</listitem>
<listitem>
<simpara>The use of host namespaces and networking</simpara>
</listitem>
<listitem>
<simpara>The allocation of an <literal>FSGroup</literal> that owns the pod volumes</simpara>
</listitem>
<listitem>
<simpara>The configuration of allowable supplemental groups</simpara>
</listitem>
<listitem>
<simpara>Whether a container requires write access to its root file system</simpara>
</listitem>
<listitem>
<simpara>The usage of volume types</simpara>
</listitem>
<listitem>
<simpara>The configuration of allowable <literal>seccomp</literal> profiles</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>Do not set the <literal>openshift.io/run-level</literal> label on any namespaces in OpenShift Container Platform. This label is for use by internal OpenShift Container Platform components to manage the startup of major API groups, such as the Kubernetes API server and OpenShift API server. If the <literal>openshift.io/run-level</literal> label is set, no SCCs are applied to pods in that namespace, causing any workloads running in that namespace to be highly privileged.</simpara>
</important>
<section xml:id="default-sccs_configuring-internal-oauth">
<title>Default security context constraints</title>
<simpara>The cluster contains several default security context constraints (SCCs) as described in the table below. Additional SCCs might be installed when you install Operators or other components to OpenShift Container Platform.</simpara>
<important>
<simpara>Do not modify the default SCCs. Customizing the default SCCs can lead to issues when some of the platform pods deploy or
OpenShift Container Platform
is upgraded. Additionally, the default SCC values are reset to the defaults during some cluster upgrades, which discards all customizations to those SCCs.</simpara>
<simpara>Instead of modifying the default SCCs, create and modify your own SCCs as needed. For detailed steps, see <emphasis>Creating security context constraints</emphasis>.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Default security context constraints</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Security context constraint</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>anyuid</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides all features of the <literal>restricted</literal> SCC, but allows users to run with any UID and any GID.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hostaccess</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows access to all host namespaces but still requires pods to be run with a UID and SELinux context that are allocated to the namespace.</simpara>
<warning>
<simpara>This SCC allows host access to namespaces, file systems, and PIDs. It should only be used by trusted pods. Grant with caution.</simpara>
</warning></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hostmount-anyuid</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides all the features of the <literal>restricted</literal> SCC, but allows host mounts and running as any UID and any GID on the system.</simpara>
<warning>
<simpara>This SCC allows host file system access as any UID, including UID 0. Grant with caution.</simpara>
</warning></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hostnetwork</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows using host networking and host ports but still requires pods to be run with a UID and SELinux context that are allocated to the namespace.</simpara>
<warning>
<simpara>If additional workloads are run on control plane hosts, use caution when providing access to <literal>hostnetwork</literal>. A workload that runs <literal>hostnetwork</literal> on a control plane host is effectively root on the cluster and must be trusted accordingly.</simpara>
</warning></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>hostnetwork-v2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Like the <literal>hostnetwork</literal> SCC, but with the following differences:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ALL</literal> capabilities are dropped from containers.</simpara>
</listitem>
<listitem>
<simpara>The <literal>NET_BIND_SERVICE</literal> capability can be added explicitly.</simpara>
</listitem>
<listitem>
<simpara><literal>seccompProfile</literal> is set to <literal>runtime/default</literal> by default.</simpara>
</listitem>
<listitem>
<simpara><literal>allowPrivilegeEscalation</literal> must be unset or set to <literal>false</literal> in security contexts.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>node-exporter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Used for the Prometheus node exporter.</simpara>
<warning>
<simpara>This SCC allows host file system access as any UID, including UID 0. Grant with caution.</simpara>
</warning></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>nonroot</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Provides all features of the <literal>restricted</literal> SCC, but allows users to run with any non-root UID. The user must specify the UID or it must be specified in the manifest of the container runtime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>nonroot-v2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Like the <literal>nonroot</literal> SCC, but with the following differences:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ALL</literal> capabilities are dropped from containers.</simpara>
</listitem>
<listitem>
<simpara>The <literal>NET_BIND_SERVICE</literal> capability can be added explicitly.</simpara>
</listitem>
<listitem>
<simpara><literal>seccompProfile</literal> is set to <literal>runtime/default</literal> by default.</simpara>
</listitem>
<listitem>
<simpara><literal>allowPrivilegeEscalation</literal> must be unset or set to <literal>false</literal> in security contexts.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>privileged</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows access to all privileged and host features and the ability to run as any user, any group, any FSGroup, and with any SELinux context.</simpara>
<warning>
<simpara>This is the most relaxed SCC and should be used only for cluster administration. Grant with caution.</simpara>
</warning>
<simpara>The <literal>privileged</literal> SCC allows:</simpara>
<itemizedlist>
<listitem>
<simpara>Users to run privileged pods</simpara>
</listitem>
<listitem>
<simpara>Pods to mount host directories as volumes</simpara>
</listitem>
<listitem>
<simpara>Pods to run as any user</simpara>
</listitem>
<listitem>
<simpara>Pods to run with any MCS label</simpara>
</listitem>
<listitem>
<simpara>Pods to use the host&#8217;s IPC namespace</simpara>
</listitem>
<listitem>
<simpara>Pods to use the host&#8217;s PID namespace</simpara>
</listitem>
<listitem>
<simpara>Pods to use any FSGroup</simpara>
</listitem>
<listitem>
<simpara>Pods to use any supplemental group</simpara>
</listitem>
<listitem>
<simpara>Pods to use any seccomp profiles</simpara>
</listitem>
<listitem>
<simpara>Pods to request any capabilities</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Setting <literal>privileged: true</literal> in the pod specification does not necessarily select the <literal>privileged</literal> SCC. The SCC that has <literal>allowPrivilegedContainer: true</literal> and has the highest prioritization will be chosen if the user has the permissions to use it.</simpara>
</note></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>restricted</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Denies access to all host features and requires pods to be run with a UID, and SELinux context that are allocated to the namespace.</simpara>
<simpara>The <literal>restricted</literal> SCC:</simpara>
<itemizedlist>
<listitem>
<simpara>Ensures that pods cannot run as privileged</simpara>
</listitem>
<listitem>
<simpara>Ensures that pods cannot mount host directory volumes</simpara>
</listitem>
<listitem>
<simpara>Requires that a pod is run as a user in a pre-allocated range of UIDs</simpara>
</listitem>
<listitem>
<simpara>Requires that a pod is run with a pre-allocated MCS label</simpara>
</listitem>
<listitem>
<simpara>Allows pods to use any FSGroup</simpara>
</listitem>
<listitem>
<simpara>Allows pods to use any supplemental group</simpara>
</listitem>
</itemizedlist>
<simpara>In clusters that were upgraded from OpenShift Container Platform 4.10 or earlier, this SCC is available for use by any authenticated user. The <literal>restricted</literal> SCC is no longer available to users of new OpenShift Container Platform 4.11 or later installations, unless the access is explicitly granted.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>restricted-v2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Like the <literal>restricted</literal> SCC, but with the following differences:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ALL</literal> capabilities are dropped from containers.</simpara>
</listitem>
<listitem>
<simpara>The <literal>NET_BIND_SERVICE</literal> capability can be added explicitly.</simpara>
</listitem>
<listitem>
<simpara><literal>seccompProfile</literal> is set to <literal>runtime/default</literal> by default.</simpara>
</listitem>
<listitem>
<simpara><literal>allowPrivilegeEscalation</literal> must be unset or set to <literal>false</literal> in security contexts.</simpara>
</listitem>
</itemizedlist>
<simpara>This is the most restrictive SCC provided by a new installation and will be used by default for authenticated users.</simpara>
<note>
<simpara>The <literal>restricted-v2</literal> SCC is the most restrictive of the SCCs that is included by default with the system. However, you can create a custom SCC that is even more restrictive. For example, you can create an SCC that restricts <literal>readOnlyRootFilesystem</literal> to <literal>true</literal>.</simpara>
</note></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="scc-settings_configuring-internal-oauth">
<title>Security context constraints settings</title>
<simpara>Security context constraints (SCCs) are composed of settings and strategies that control the security features
a pod has access to. These settings fall into three categories:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Category</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Controlled by a boolean</simpara></entry>
<entry align="left" valign="top"><simpara>Fields of this type default to the most restrictive value. For example,
<literal>AllowPrivilegedContainer</literal> is always set to <literal>false</literal> if unspecified.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Controlled by an allowable set</simpara></entry>
<entry align="left" valign="top"><simpara>Fields of this type are checked against the set to ensure their value is
allowed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Controlled by a strategy</simpara></entry>
<entry align="left" valign="top"><simpara>Items that have a strategy to generate a value provide:</simpara>
<itemizedlist>
<listitem>
<simpara>A mechanism to generate the value, and</simpara>
</listitem>
<listitem>
<simpara>A mechanism to ensure that a specified value falls into the set of allowable
values.</simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>CRI-O has the following default list of capabilities that are allowed for each container of a pod:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>CHOWN</literal></simpara>
</listitem>
<listitem>
<simpara><literal>DAC_OVERRIDE</literal></simpara>
</listitem>
<listitem>
<simpara><literal>FSETID</literal></simpara>
</listitem>
<listitem>
<simpara><literal>FOWNER</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SETGID</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SETUID</literal></simpara>
</listitem>
<listitem>
<simpara><literal>SETPCAP</literal></simpara>
</listitem>
<listitem>
<simpara><literal>NET_BIND_SERVICE</literal></simpara>
</listitem>
<listitem>
<simpara><literal>KILL</literal></simpara>
</listitem>
</itemizedlist>
<simpara>The containers use the capabilities from this default list, but pod manifest authors can alter the list by requesting additional capabilities or removing some of the default behaviors. Use the <literal>allowedCapabilities</literal>, <literal>defaultAddCapabilities</literal>, and <literal>requiredDropCapabilities</literal> parameters to control such requests from the pods. With these parameters you can specify which capabilities can be requested, which ones must be added to each container, and which ones must be forbidden, or dropped, from each container.</simpara>
<note>
<simpara>You can drop all capabilites from containers by setting the <literal>requiredDropCapabilities</literal> parameter to <literal>ALL</literal>. This is what the <literal>restricted-v2</literal> SCC does.</simpara>
</note>
</section>
<section xml:id="authorization-SCC-strategies_configuring-internal-oauth">
<title>Security context constraints strategies</title>
<itemizedlist>
<title>RunAsUser</title>
<listitem>
<simpara><literal>MustRunAs</literal> - Requires a <literal>runAsUser</literal> to be configured. Uses the configured
<literal>runAsUser</literal> as the default. Validates against the configured <literal>runAsUser</literal>.</simpara>
<formalpara>
<title>Example <literal>MustRunAs</literal> snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
runAsUser:
  type: MustRunAs
  uid: &lt;id&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>MustRunAsRange</literal> - Requires minimum and maximum values to be defined if not
using pre-allocated values. Uses the minimum as the default. Validates against
the entire allowable range.</simpara>
<formalpara>
<title>Example <literal>MustRunAsRange</literal> snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
runAsUser:
  type: MustRunAsRange
  uidRangeMax: &lt;maxvalue&gt;
  uidRangeMin: &lt;minvalue&gt;
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>MustRunAsNonRoot</literal> - Requires that the pod be submitted with a non-zero
<literal>runAsUser</literal> or have the <literal>USER</literal> directive defined in the image. No default
provided.</simpara>
<formalpara>
<title>Example <literal>MustRunAsNonRoot</literal> snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
runAsUser:
  type: MustRunAsNonRoot
...</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara><literal>RunAsAny</literal> - No default provided. Allows any <literal>runAsUser</literal> to be specified.</simpara>
<formalpara>
<title>Example <literal>RunAsAny</literal> snippet</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
runAsUser:
  type: RunAsAny
...</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>SELinuxContext</title>
<listitem>
<simpara><literal>MustRunAs</literal> - Requires <literal>seLinuxOptions</literal> to be configured if not using
pre-allocated values. Uses <literal>seLinuxOptions</literal> as the default. Validates against
<literal>seLinuxOptions</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>RunAsAny</literal> - No default provided. Allows any <literal>seLinuxOptions</literal> to be
specified.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>SupplementalGroups</title>
<listitem>
<simpara><literal>MustRunAs</literal> - Requires at least one range to be specified if not using
pre-allocated values. Uses the minimum value of the first range as the default.
Validates against all ranges.</simpara>
</listitem>
<listitem>
<simpara><literal>RunAsAny</literal> - No default provided. Allows any <literal>supplementalGroups</literal> to be
specified.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>FSGroup</title>
<listitem>
<simpara><literal>MustRunAs</literal> - Requires at least one range to be specified if not using
pre-allocated values. Uses the minimum value of the first range as the default.
Validates against the first ID in the first range.</simpara>
</listitem>
<listitem>
<simpara><literal>RunAsAny</literal> - No default provided. Allows any <literal>fsGroup</literal> ID to be specified.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="authorization-controlling-volumes_configuring-internal-oauth">
<title>Controlling volumes</title>
<simpara>The usage of specific volume types
can be controlled by setting the <literal>volumes</literal>
field of the SCC.</simpara>
<simpara>The allowable values of this field correspond to the volume
sources that are defined when creating a volume:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#awselasticblockstore"><literal>awsElasticBlockStore</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#azuredisk"><literal>azureDisk</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#azurefile"><literal>azureFile</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#cephfs"><literal>cephFS</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#cinder"><literal>cinder</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#configmap"><literal>configMap</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes"><literal>csi</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#downwardapi"><literal>downwardAPI</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#emptydir"><literal>emptyDir</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#fc"><literal>fc</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#flexvolume"><literal>flexVolume</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#flocker"><literal>flocker</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#gcepersistentdisk"><literal>gcePersistentDisk</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes"><literal>ephemeral</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#gitrepo"><literal>gitRepo</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#glusterfs"><literal>glusterfs</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#hostpath"><literal>hostPath</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#iscsi"><literal>iscsi</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#nfs"><literal>nfs</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#persistentvolumeclaim"><literal>persistentVolumeClaim</literal></link></simpara>
</listitem>
<listitem>
<simpara><literal>photonPersistentDisk</literal></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#portworxvolume"><literal>portworxVolume</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#projected"><literal>projected</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#quobyte"><literal>quobyte</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#rbd"><literal>rbd</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#scaleio"><literal>scaleIO</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#secret"><literal>secret</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#storageos"><literal>storageos</literal></link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#vspherevolume"><literal>vsphereVolume</literal></link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">*</emphasis> (A special value to allow the use of all volume types.)</simpara>
</listitem>
<listitem>
<simpara><literal>none</literal> (A special value to disallow the use of all volumes types. Exists only for backwards compatibility.)</simpara>
</listitem>
</itemizedlist>
<simpara>The recommended minimum set of allowed volumes for new SCCs are <literal>configMap</literal>,
<literal>downwardAPI</literal>, <literal>emptyDir</literal>, <literal>persistentVolumeClaim</literal>, <literal>secret</literal>, and <literal>projected</literal>.</simpara>
<note>
<simpara>This list of allowable volume types is not exhaustive because new types are
added with each release of OpenShift Container Platform.</simpara>
</note>
<note>
<simpara>For backwards compatibility, the usage of <literal>allowHostDirVolumePlugin</literal> overrides
settings in the <literal>volumes</literal> field. For example, if <literal>allowHostDirVolumePlugin</literal>
is set to false but allowed in the <literal>volumes</literal> field, then the <literal>hostPath</literal>
value will be removed from <literal>volumes</literal>.</simpara>
</note>
</section>
<section xml:id="admission_configuring-internal-oauth">
<title>Admission control</title>
<simpara><emphasis>Admission control</emphasis> with SCCs allows for control over the creation of resources
based on the capabilities granted to a user.</simpara>
<simpara>In terms of the SCCs, this means that an admission controller can inspect the
user information made available in the context to retrieve an appropriate set of
SCCs. Doing so ensures the pod is authorized to make requests about its
operating environment or to generate a set of constraints to apply to the pod.</simpara>
<simpara>The set of SCCs that admission uses to authorize a pod are determined by the
user identity and groups that the user belongs to. Additionally, if the pod
specifies a service account, the set of allowable SCCs includes any constraints
accessible to the service account.</simpara>
<note>
<simpara>When you create a workload resource, such as a deployment, only the service account is used to find the SCCs and is used to admit the pods when they are created.</simpara>
</note>
<important>
<simpara>When creating pods directly, SCCs admission considers SCC permissions of both the caller and the Service Account that runs the pod. When a pod is created by a pod controller such as a deployment or a job, only Service Account SCC permissions are considered.</simpara>
</important>
<simpara>Admission uses the following approach to create the final security context for
the pod:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Retrieve all SCCs available for use.</simpara>
</listitem>
<listitem>
<simpara>Generate field values for security context settings that were not specified
on the request.</simpara>
</listitem>
<listitem>
<simpara>Validate the final settings against the available constraints.</simpara>
</listitem>
</orderedlist>
<simpara>If a matching set of constraints is found, then the pod is accepted. If the
request cannot be matched to an SCC, the pod is rejected.</simpara>
<simpara>A pod must validate every field against the SCC. The following are examples for
just two of the fields that must be validated:</simpara>
<note>
<simpara>These examples are in the context of a strategy using the pre-allocated values.</simpara>
</note>
<simpara><emphasis role="strong">An FSGroup SCC strategy of <literal>MustRunAs</literal></emphasis></simpara>
<simpara>If the pod defines a <literal>fsGroup</literal> ID, then that ID must equal the default
<literal>fsGroup</literal> ID. Otherwise, the pod is not validated by that SCC and the next SCC
is evaluated.</simpara>
<simpara>If the <literal>SecurityContextConstraints.fsGroup</literal> field has value <literal>RunAsAny</literal>
and the pod specification omits the <literal>Pod.spec.securityContext.fsGroup</literal>,
then this field is considered valid. Note that it is possible that during
validation, other SCC settings will reject other pod fields and thus cause the
pod to fail.</simpara>
<simpara><emphasis role="strong">A <literal>SupplementalGroups</literal> SCC strategy of <literal>MustRunAs</literal></emphasis></simpara>
<simpara>If the pod specification defines one or more <literal>supplementalGroups</literal> IDs, then
the pod&#8217;s IDs must equal one of the IDs in the namespace&#8217;s
<literal>openshift.io/sa.scc.supplemental-groups</literal> annotation. Otherwise, the pod is not
validated by that SCC and the next SCC is evaluated.</simpara>
<simpara>If the <literal>SecurityContextConstraints.supplementalGroups</literal> field has value <literal>RunAsAny</literal>
and the pod specification omits the <literal>Pod.spec.securityContext.supplementalGroups</literal>,
then this field is considered valid. Note that it is possible that during
validation, other SCC settings will reject other pod fields and thus cause the
pod to fail.</simpara>
</section>
<section xml:id="scc-prioritization_configuring-internal-oauth">
<title>Security context constraints prioritization</title>
<simpara>Security context constraints (SCCs) have a priority field that affects the ordering when attempting to validate a request by the admission controller.</simpara>
<simpara>A priority value of <literal>0</literal> is the lowest possible priority. A nil priority is considered a <literal>0</literal>, or lowest, priority. Higher priority SCCs are moved to the front of the set when sorting.</simpara>
<simpara>When the complete set of available SCCs is determined, the SCCs are ordered in the following manner:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The highest priority SCCs are ordered first.</simpara>
</listitem>
<listitem>
<simpara>If the priorities are equal, the SCCs are sorted from most restrictive to least restrictive.</simpara>
</listitem>
<listitem>
<simpara>If both the priorities and restrictions are equal, the SCCs are sorted by name.</simpara>
</listitem>
</orderedlist>
<simpara>By default, the <literal>anyuid</literal> SCC granted to cluster administrators is given priority
in their SCC set. This allows cluster administrators to run pods as any
user by specifying <literal>RunAsUser</literal> in the pod&#8217;s <literal>SecurityContext</literal>.</simpara>
</section>
</section>
<section xml:id="security-context-constraints-pre-allocated-values_configuring-internal-oauth">
<title>About pre-allocated security context constraints values</title>
<simpara>The admission controller is aware of certain conditions in the security context
constraints (SCCs) that trigger it to look up pre-allocated values from a namespace and
populate the SCC before processing the pod. Each SCC
strategy is evaluated independently of other strategies, with the pre-allocated
values, where allowed, for each policy aggregated with pod specification values
to make the final values for the various IDs defined in the running pod.</simpara>
<simpara>The following SCCs cause the admission controller to look for pre-allocated
values when no ranges are defined in the pod specification:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A <literal>RunAsUser</literal> strategy of <literal>MustRunAsRange</literal> with no minimum or maximum set.
Admission looks for the <literal>openshift.io/sa.scc.uid-range</literal> annotation to populate
range fields.</simpara>
</listitem>
<listitem>
<simpara>An <literal>SELinuxContext</literal> strategy of <literal>MustRunAs</literal> with no level set. Admission
looks for the <literal>openshift.io/sa.scc.mcs</literal> annotation to populate the level.</simpara>
</listitem>
<listitem>
<simpara>A <literal>FSGroup</literal> strategy of <literal>MustRunAs</literal>. Admission looks for the
<literal>openshift.io/sa.scc.supplemental-groups</literal> annotation.</simpara>
</listitem>
<listitem>
<simpara>A <literal>SupplementalGroups</literal> strategy of <literal>MustRunAs</literal>. Admission looks for the
<literal>openshift.io/sa.scc.supplemental-groups</literal> annotation.</simpara>
</listitem>
</orderedlist>
<simpara>During the generation phase, the security context provider uses default values
for any parameter values that are not specifically set in the pod. Default values
are based on the selected strategy:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><literal>RunAsAny</literal> and <literal>MustRunAsNonRoot</literal> strategies do not provide default
values. If the pod needs a parameter value, such as a group ID, you
must define the value in the pod specification.</simpara>
</listitem>
<listitem>
<simpara><literal>MustRunAs</literal> (single value) strategies provide a default value that is
always used. For example, for group IDs, even if the pod specification defines
its own ID value, the namespace&#8217;s default parameter value also appears in the pod&#8217;s
groups.</simpara>
</listitem>
<listitem>
<simpara><literal>MustRunAsRange</literal> and <literal>MustRunAs</literal> (range-based) strategies provide the
minimum value of the range. As with a single value <literal>MustRunAs</literal> strategy, the
namespace&#8217;s default parameter value appears in the running pod. If a range-based
strategy is configurable with multiple ranges, it provides the minimum value
of the first configured range.</simpara>
</listitem>
</orderedlist>
<note>
<simpara><literal>FSGroup</literal> and <literal>SupplementalGroups</literal> strategies fall back to the
<literal>openshift.io/sa.scc.uid-range</literal> annotation if the
<literal>openshift.io/sa.scc.supplemental-groups</literal> annotation does not exist on the
namespace. If neither exists, the SCC is not created.</simpara>
</note>
<note>
<simpara>By default, the annotation-based <literal>FSGroup</literal> strategy configures itself with a
single range based on the minimum value for the annotation. For example, if your
annotation reads <literal>1/3</literal>, the <literal>FSGroup</literal> strategy configures itself with a
minimum and maximum value of <literal>1</literal>. If you want to allow more groups to be accepted for
the <literal>FSGroup</literal> field, you can configure a custom SCC that does not use the
annotation.</simpara>
</note>
<note>
<simpara>The <literal>openshift.io/sa.scc.supplemental-groups</literal> annotation accepts a comma-delimited
list of blocks in the format of <literal>&lt;start&gt;/&lt;length</literal> or <literal>&lt;start&gt;-&lt;end&gt;</literal>.
The <literal>openshift.io/sa.scc.uid-range</literal> annotation accepts only a single block.</simpara>
</note>
</section>
<section xml:id="security-context-constraints-example_configuring-internal-oauth">
<title>Example security context constraints</title>
<simpara>The following examples show the security context constraints (SCC) format and
annotations:</simpara>
<formalpara>
<title>Annotated <literal>privileged</literal> SCC</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">allowHostDirVolumePlugin: true
allowHostIPC: true
allowHostNetwork: true
allowHostPID: true
allowHostPorts: true
allowPrivilegedContainer: true
allowedCapabilities: <co xml:id="CO33-1"/>
- '*'
apiVersion: security.openshift.io/v1
defaultAddCapabilities: [] <co xml:id="CO33-2"/>
fsGroup: <co xml:id="CO33-3"/>
  type: RunAsAny
groups: <co xml:id="CO33-4"/>
- system:cluster-admins
- system:nodes
kind: SecurityContextConstraints
metadata:
  annotations:
    kubernetes.io/description: 'privileged allows access to all privileged and host
      features and the ability to run as any user, any group, any fsGroup, and with
      any SELinux context.  WARNING: this is the most relaxed SCC and should be used
      only for cluster administration. Grant with caution.'
  creationTimestamp: null
  name: privileged
priority: null
readOnlyRootFilesystem: false
requiredDropCapabilities: <co xml:id="CO33-5"/>
- KILL
- MKNOD
- SETUID
- SETGID
runAsUser: <co xml:id="CO33-6"/>
  type: RunAsAny
seLinuxContext: <co xml:id="CO33-7"/>
  type: RunAsAny
seccompProfiles:
- '*'
supplementalGroups: <co xml:id="CO33-8"/>
  type: RunAsAny
users: <co xml:id="CO33-9"/>
- system:serviceaccount:default:registry
- system:serviceaccount:default:router
- system:serviceaccount:openshift-infra:build-controller
volumes: <co xml:id="CO33-10"/>
- '*'</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO33-1">
<para>A list of capabilities that a pod can request. An empty list means
that none of capabilities can be requested while the special symbol <literal><emphasis role="strong">*</emphasis></literal>
allows any capabilities.</para>
</callout>
<callout arearefs="CO33-2">
<para>A list of additional capabilities that are added to any pod.</para>
</callout>
<callout arearefs="CO33-3">
<para>The <literal>FSGroup</literal> strategy, which dictates the allowable values for the
security context.</para>
</callout>
<callout arearefs="CO33-4">
<para>The groups that can access this SCC.</para>
</callout>
<callout arearefs="CO33-5">
<para>A list of capabilities to drop from a pod. Or, specify <literal>ALL</literal> to drop all
capabilities.</para>
</callout>
<callout arearefs="CO33-6">
<para>The <literal>runAsUser</literal> strategy type, which dictates the allowable values for the
security context.</para>
</callout>
<callout arearefs="CO33-7">
<para>The <literal>seLinuxContext</literal> strategy type, which dictates the allowable values for
the security context.</para>
</callout>
<callout arearefs="CO33-8">
<para>The <literal>supplementalGroups</literal> strategy, which dictates the allowable supplemental
groups for the security context.</para>
</callout>
<callout arearefs="CO33-9">
<para>The users who can access this SCC.</para>
</callout>
<callout arearefs="CO33-10">
<para>The allowable volume types for the security context. In the example, <literal>*</literal> allows the use of all volume types.</para>
</callout>
</calloutlist>
<simpara>The <literal>users</literal> and <literal>groups</literal> fields on the SCC control which users can access the
SCC.
By default, cluster administrators, nodes, and the build controller are granted
access to the privileged SCC. All authenticated users are granted access to the
<literal>restricted-v2</literal> SCC.</simpara>
<formalpara>
<title>Without explicit <literal>runAsUser</literal> setting</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo
spec:
  securityContext: <co xml:id="CO34-1"/>
  containers:
  - name: sec-ctx-demo
    image: gcr.io/google-samples/node-hello:1.0</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>When a container or pod does not request a user ID under which it should be run,
the effective UID depends on the SCC that emits this pod. Because the <literal>restricted-v2</literal> SCC
is granted to all authenticated users by default, it will be available to all
users and service accounts and used in most cases. The <literal>restricted-v2</literal> SCC uses
<literal>MustRunAsRange</literal> strategy for constraining and defaulting the possible values of
the <literal>securityContext.runAsUser</literal> field. The admission plugin will look for the
<literal>openshift.io/sa.scc.uid-range</literal> annotation on the current project to populate
range fields, as it does not provide this range. In the end, a container will
have <literal>runAsUser</literal> equal to the first value of the range that is
hard to predict because every project has different ranges.</para>
</callout>
</calloutlist>
<formalpara>
<title>With explicit <literal>runAsUser</literal> setting</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo
spec:
  securityContext:
    runAsUser: 1000 <co xml:id="CO35-1"/>
  containers:
    - name: sec-ctx-demo
      image: gcr.io/google-samples/node-hello:1.0</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO35-1">
<para>A container or pod that requests a specific user ID will be accepted by
OpenShift Container Platform only when a service account or a user is granted access to a SCC
that allows such a user ID. The SCC can allow arbitrary IDs, an ID that falls
into a range, or the exact user ID specific to the request.</para>
</callout>
</calloutlist>
<simpara>This configuration is valid for SELinux, fsGroup, and Supplemental Groups.</simpara>
</section>
<section xml:id="security-context-constraints-creating_configuring-internal-oauth">
<title>Creating security context constraints</title>
<simpara>You can create security context constraints (SCCs) by using the OpenShift CLI (<literal>oc</literal>).</simpara>
<important>
<simpara>Creating and modifying your own SCCs are advanced operations that might cause instability to your cluster. If you have questions about using your own SCCs, contact Red Hat Support. For information about contacting Red Hat support, see <emphasis>Getting support</emphasis>.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Install the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>Log in to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define the SCC in a YAML file named <literal>scc-admin.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: SecurityContextConstraints
apiVersion: security.openshift.io/v1
metadata:
  name: scc-admin
allowPrivilegedContainer: true
runAsUser:
  type: RunAsAny
seLinuxContext:
  type: RunAsAny
fsGroup:
  type: RunAsAny
supplementalGroups:
  type: RunAsAny
users:
- my-admin-user
groups:
- my-admin-group</programlisting>
<simpara>Optionally, you can drop specific capabilities for an SCC by setting the <literal>requiredDropCapabilities</literal> field with the desired values. Any specified capabilities are dropped from the container. To drop all capabilities, specify <literal>ALL</literal>. For example, to create an SCC that drops the <literal>KILL</literal>, <literal>MKNOD</literal>, and <literal>SYS_CHROOT</literal> capabilities, add the following to the SCC object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">requiredDropCapabilities:
- KILL
- MKNOD
- SYS_CHROOT</programlisting>
<note>
<simpara>You cannot list a capability in both <literal>allowedCapabilities</literal> and <literal>requiredDropCapabilities</literal>.</simpara>
</note>
<simpara>CRI-O supports the same list of capability values that are found in the <link xlink:href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker documentation</link>.</simpara>
</listitem>
<listitem>
<simpara>Create the SCC by passing in the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f scc-admin.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">securitycontextconstraints "scc-admin" created</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the SCC was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scc scc-admin</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        PRIV      CAPS      SELINUX    RUNASUSER   FSGROUP    SUPGROUP   PRIORITY   READONLYROOTFS   VOLUMES
scc-admin   true      []        RunAsAny   RunAsAny    RunAsAny   RunAsAny   &lt;none&gt;     false            [awsElasticBlockStore azureDisk azureFile cephFS cinder configMap downwardAPI emptyDir fc flexVolume flocker gcePersistentDisk gitRepo glusterfs iscsi nfs persistentVolumeClaim photonPersistentDisk quobyte rbd secret vsphere]</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-context-constraints-requiring_configuring-internal-oauth">
<title>Configuring a workload to require a specific SCC</title>
<simpara>You can configure a workload to require a certain security context constraint (SCC). This is useful in scenarios where you want to pin a specific SCC to the workload or if you want to prevent your required SCC from being preempted by another SCC in the cluster.</simpara>
<simpara>To require a specific SCC, set the <literal>openshift.io/required-scc</literal> annotation on your workload. You can set this annotation on any resource that can set a pod manifest template, such as a deployment or daemon set.</simpara>
<simpara>The SCC must exist in the cluster and must be applicable to the workload, otherwise pod admission fails. An SCC is considered applicable to the workload if the user creating the pod or the pod&#8217;s service account has <literal>use</literal> permissions for the SCC in the pod&#8217;s namespace.</simpara>
<warning>
<simpara>Do not change the <literal>openshift.io/required-scc</literal> annotation in the live pod&#8217;s manifest, because doing so causes the pod admission to fail. To change the required SCC, update the annotation in the underlying pod template, which causes the pod to be deleted and re-created.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The SCC must exist in the cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a YAML file for the deployment and specify a required SCC by setting the <literal>openshift.io/required-scc</literal> annotation:</simpara>
<formalpara>
<title>Example <literal>deployment.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: config.openshift.io/v1
kind: Deployment
apiVersion: apps/v1
spec:
# ...
  template:
    metadata:
      annotations:
        openshift.io/required-scc: "my-scc" <co xml:id="CO36-1"/>
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO36-1">
<para>Specify the name of the SCC to require.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f deployment.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify that the deployment used the specified SCC:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>View the value of the pod&#8217;s <literal>openshift.io/scc</literal> annotation by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pod &lt;pod_name&gt; -o jsonpath='{.metadata.annotations.openshift\.io\/scc}{"\n"}' <co xml:id="CO37-1"/></programlisting>
<calloutlist>
<callout arearefs="CO37-1">
<para>Replace <literal>&lt;pod_name&gt;</literal> with the name of your deployment pod.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Examine the output and confirm that the displayed SCC matches the SCC that you defined in the deployment:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">my-scc</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="role-based-access-to-ssc_configuring-internal-oauth">
<title>Role-based access to security context constraints</title>
<simpara>You can specify SCCs as resources that are handled by RBAC. This allows
you to scope access to your SCCs to a certain project or to the entire
cluster. Assigning users, groups, or service accounts directly to an
SCC retains cluster-wide scope.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<simpara>To include access to SCCs for your role, specify the <literal>scc</literal> resource
when creating a role.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create role &lt;role-name&gt; --verb=use --resource=scc --resource-name=&lt;scc-name&gt; -n &lt;namespace&gt;</programlisting>
<simpara>This results in the following role definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
...
  name: role-name <co xml:id="CO38-1"/>
  namespace: namespace <co xml:id="CO38-2"/>
...
rules:
- apiGroups:
  - security.openshift.io <co xml:id="CO38-3"/>
  resourceNames:
  - scc-name <co xml:id="CO38-4"/>
  resources:
  - securitycontextconstraints <co xml:id="CO38-5"/>
  verbs: <co xml:id="CO38-6"/>
  - use</programlisting>
<calloutlist>
<callout arearefs="CO38-1">
<para>The role&#8217;s name.</para>
</callout>
<callout arearefs="CO38-2">
<para>Namespace of the defined role. Defaults to <literal>default</literal> if not specified.</para>
</callout>
<callout arearefs="CO38-3">
<para>The API group that includes the <literal>SecurityContextConstraints</literal> resource.
Automatically defined when <literal>scc</literal> is specified as a resource.</para>
</callout>
<callout arearefs="CO38-4">
<para>An example name for an SCC you want to have access.</para>
</callout>
<callout arearefs="CO38-5">
<para>Name of the resource group that allows users to specify SCC names in
the <literal>resourceNames</literal> field.</para>
</callout>
<callout arearefs="CO38-6">
<para>A list of verbs to apply to the role.</para>
</callout>
</calloutlist>
<simpara>A local or cluster role with such a rule allows the subjects that are
bound to it with a role binding or a cluster role binding to use the
user-defined SCC called <literal>scc-name</literal>.</simpara>
<note>
<simpara>Because RBAC is designed to prevent escalation, even project administrators
are unable to grant access to an SCC. By default, they are not
allowed to use the verb <literal>use</literal> on SCC resources, including the
<literal>restricted-v2</literal> SCC.</simpara>
</note>
</section>
<section xml:id="security-context-constraints-command-reference_configuring-internal-oauth">
<title>Reference of security context constraints commands</title>
<simpara>You can manage security context constraints (SCCs) in your instance as normal API objects using the OpenShift CLI (<literal>oc</literal>).</simpara>
<note>
<simpara>You must have <literal>cluster-admin</literal> privileges to manage SCCs.</simpara>
</note>
<section xml:id="listing-security-context-constraints_configuring-internal-oauth">
<title>Listing security context constraints</title>
<simpara>To get a current list of SCCs:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get scc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                              PRIV    CAPS                   SELINUX     RUNASUSER          FSGROUP     SUPGROUP    PRIORITY     READONLYROOTFS   VOLUMES
anyuid                            false   &lt;no value&gt;             MustRunAs   RunAsAny           RunAsAny    RunAsAny    10           false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
hostaccess                        false   &lt;no value&gt;             MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","hostPath","persistentVolumeClaim","projected","secret"]
hostmount-anyuid                  false   &lt;no value&gt;             MustRunAs   RunAsAny           RunAsAny    RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","hostPath","nfs","persistentVolumeClaim","projected","secret"]
hostnetwork                       false   &lt;no value&gt;             MustRunAs   MustRunAsRange     MustRunAs   MustRunAs   &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
hostnetwork-v2                    false   ["NET_BIND_SERVICE"]   MustRunAs   MustRunAsRange     MustRunAs   MustRunAs   &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
node-exporter                     true    &lt;no value&gt;             RunAsAny    RunAsAny           RunAsAny    RunAsAny    &lt;no value&gt;   false            ["*"]
nonroot                           false   &lt;no value&gt;             MustRunAs   MustRunAsNonRoot   RunAsAny    RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
nonroot-v2                        false   ["NET_BIND_SERVICE"]   MustRunAs   MustRunAsNonRoot   RunAsAny    RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
privileged                        true    ["*"]                  RunAsAny    RunAsAny           RunAsAny    RunAsAny    &lt;no value&gt;   false            ["*"]
restricted                        false   &lt;no value&gt;             MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]
restricted-v2                     false   ["NET_BIND_SERVICE"]   MustRunAs   MustRunAsRange     MustRunAs   RunAsAny    &lt;no value&gt;   false            ["configMap","downwardAPI","emptyDir","persistentVolumeClaim","projected","secret"]</programlisting>
</para>
</formalpara>
</section>
<section xml:id="examining-a-security-context-constraints-object_configuring-internal-oauth">
<title>Examining security context constraints</title>
<simpara>You can view information about a particular SCC, including which users, service accounts, and groups the SCC is applied to.</simpara>
<simpara>For example, to examine the <literal>restricted</literal> SCC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe scc restricted</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                                  restricted
Priority:                              &lt;none&gt;
Access:
  Users:                               &lt;none&gt; <co xml:id="CO39-1"/>
  Groups:                              &lt;none&gt; <co xml:id="CO39-2"/>
Settings:
  Allow Privileged:                    false
  Allow Privilege Escalation:          true
  Default Add Capabilities:            &lt;none&gt;
  Required Drop Capabilities:          KILL,MKNOD,SETUID,SETGID
  Allowed Capabilities:                &lt;none&gt;
  Allowed Seccomp Profiles:            &lt;none&gt;
  Allowed Volume Types:                configMap,downwardAPI,emptyDir,persistentVolumeClaim,projected,secret
  Allowed Flexvolumes:                 &lt;all&gt;
  Allowed Unsafe Sysctls:              &lt;none&gt;
  Forbidden Sysctls:                   &lt;none&gt;
  Allow Host Network:                  false
  Allow Host Ports:                    false
  Allow Host PID:                      false
  Allow Host IPC:                      false
  Read Only Root Filesystem:           false
  Run As User Strategy: MustRunAsRange
    UID:                               &lt;none&gt;
    UID Range Min:                     &lt;none&gt;
    UID Range Max:                     &lt;none&gt;
  SELinux Context Strategy: MustRunAs
    User:                              &lt;none&gt;
    Role:                              &lt;none&gt;
    Type:                              &lt;none&gt;
    Level:                             &lt;none&gt;
  FSGroup Strategy: MustRunAs
    Ranges:                            &lt;none&gt;
  Supplemental Groups Strategy: RunAsAny
    Ranges:                            &lt;none&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO39-1">
<para>Lists which users and service accounts the SCC is applied to.</para>
</callout>
<callout arearefs="CO39-2">
<para>Lists which groups the SCC is applied to.</para>
</callout>
</calloutlist>
<note>
<simpara>To preserve customized SCCs during upgrades, do not edit settings on
the default SCCs.</simpara>
</note>
</section>
<section xml:id="deleting-security-context-constraints_configuring-internal-oauth">
<title>Deleting security context constraints</title>
<simpara>To delete an SCC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete scc &lt;scc_name&gt;</programlisting>
<note>
<simpara>If you delete a default SCC, it will regenerate when you restart the cluster.</simpara>
</note>
</section>
<section xml:id="updating-security-context-constraints_configuring-internal-oauth">
<title>Updating security context constraints</title>
<simpara>To update an existing SCC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit scc &lt;scc_name&gt;</programlisting>
<note>
<simpara>To preserve customized SCCs during upgrades, do not edit settings on
the default SCCs.</simpara>
</note>
</section>
</section>
<section xml:id="additional-resources_configuring-internal-oauth" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../support/getting-support.xml#getting-support">Getting support</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="understanding-and-managing-pod-security-admission">
<title>Understanding and managing pod security admission</title>

<simpara>Pod security admission is an implementation of the <link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Kubernetes pod security standards</link>. Use pod security admission to restrict the behavior of pods.</simpara>
<section xml:id="security-context-constraints-psa-about_understanding-and-managing-pod-security-admission">
<title>About pod security admission</title>
<simpara>OpenShift Container Platform includes <link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-admission">Kubernetes pod security admission</link>. Pods that do not comply with the pod security admission defined globally or at the namespace level are not admitted to the cluster and cannot run.</simpara>
<simpara>Globally, the <literal>privileged</literal> profile is enforced, and the <literal>restricted</literal> profile is used for warnings and audits.</simpara>
<simpara>You can also configure the pod security admission settings at the namespace level.</simpara>
<important>
<simpara>Do not run workloads in or share access to default projects. Default projects are reserved for running core cluster components.</simpara>
<simpara>The following default projects are considered highly privileged: <literal>default</literal>, <literal>kube-public</literal>, <literal>kube-system</literal>, <literal>openshift</literal>, <literal>openshift-infra</literal>, <literal>openshift-node</literal>, and other system-created projects that have the <literal>openshift.io/run-level</literal> label set to <literal>0</literal> or <literal>1</literal>. Functionality that relies on admission plugins, such as pod security admission, security context constraints, cluster resource quotas, and image reference resolution, does not work in highly privileged projects.</simpara>
</important>
<section xml:id="psa-modes_understanding-and-managing-pod-security-admission">
<title>Pod security admission modes</title>
<simpara>You can configure the following pod security admission modes for a namespace:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security admission modes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="50.0001*"/>
<thead>
<row>
<entry align="left" valign="top">Mode</entry>
<entry align="left" valign="top">Label</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>enforce</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/enforce</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rejects a pod from admission if it does not comply with the set profile</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>audit</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/audit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Logs audit events if a pod does not comply with the set profile</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>warn</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pod-security.kubernetes.io/warn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Displays warnings if a pod does not comply with the set profile</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="psa-profiles_understanding-and-managing-pod-security-admission">
<title>Pod security admission profiles</title>
<simpara>You can set each of the pod security admission modes to one of the following profiles:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security admission profiles</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="75*"/>
<thead>
<row>
<entry align="left" valign="top">Profile</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>privileged</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Least restrictive policy; allows for known privilege escalation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>baseline</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Minimally restrictive policy; prevents known privilege escalations</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>restricted</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Most restrictive policy; follows current pod hardening best practices</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="psa-privileged-namespaces_understanding-and-managing-pod-security-admission">
<title>Privileged namespaces</title>
<simpara>The following system namespaces are always set to the <literal>privileged</literal> pod security admission profile:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>default</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-public</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-system</literal></simpara>
</listitem>
</itemizedlist>
<simpara>You cannot change the pod security profile for these privileged namespaces.</simpara>
</section>
</section>
<section xml:id="security-context-constraints-psa-synchronization_understanding-and-managing-pod-security-admission">
<title>About pod security admission synchronization</title>
<simpara>In addition to the global pod security admission control configuration, a controller applies pod security admission control <literal>warn</literal> and <literal>audit</literal> labels to namespaces according to the SCC permissions of the service accounts that are in a given namespace.</simpara>
<simpara>The controller examines <literal>ServiceAccount</literal> object permissions to use security context constraints in each namespace. Security context constraints (SCCs) are mapped to pod security profiles based on their field values; the controller uses these translated profiles. Pod security admission <literal>warn</literal> and <literal>audit</literal> labels are set to the most privileged pod security profile in the namespace to prevent displaying warnings and logging audit events when pods are created.</simpara>
<simpara>Namespace labeling is based on consideration of namespace-local service account privileges.</simpara>
<simpara>Applying pods directly might use the SCC privileges of the user who runs the pod. However, user privileges are not considered during automatic labeling.</simpara>
<section xml:id="security-context-constraints-psa-sync-exclusions_understanding-and-managing-pod-security-admission">
<title>Pod security admission synchronization namespace exclusions</title>
<simpara>Pod security admission synchronization is permanently disabled on most system-created namespaces. Synchronization is also initially disabled on user-created <literal>openshift-*</literal> prefixed namespaces, but you can enable synchronization on them later.</simpara>
<important>
<simpara>If a pod security admission label (<literal>pod-security.kubernetes.io/&lt;mode&gt;</literal>) is manually modified from the automatically labeled value on a label-synchronized namespace, synchronization is disabled for that label.</simpara>
<simpara>If necessary, you can enable synchronization again by using one of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>By removing the modified pod security admission label from the namespace</simpara>
</listitem>
<listitem>
<simpara>By setting the <literal>security.openshift.io/scc.podSecurityLabelSync</literal> label to <literal>true</literal></simpara>
<simpara>If you force synchronization by adding this label, then any modified pod security admission labels will be overwritten.</simpara>
</listitem>
</itemizedlist>
</important>
<bridgehead xml:id="_permanently_disabled_namespaces" renderas="sect4">Permanently disabled namespaces</bridgehead>
<simpara>Namespaces that are defined as part of the cluster payload have pod security admission synchronization disabled permanently. The following namespaces are permanently disabled:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>default</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-node-lease</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-system</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kube-public</literal></simpara>
</listitem>
<listitem>
<simpara><literal>openshift</literal></simpara>
</listitem>
<listitem>
<simpara>All system-created namespaces that are prefixed with <literal>openshift-</literal>
, except for <literal>openshift-operators</literal></simpara>
</listitem>
</itemizedlist>
<bridgehead xml:id="_initially_disabled_namespaces" renderas="sect4">Initially disabled namespaces</bridgehead>
<simpara>By default, all namespaces that have an <literal>openshift-</literal> prefix have pod security admission synchronization disabled initially. You can enable synchronization for user-created <literal>openshift-*</literal> namespaces and for the <literal>openshift-operators</literal> namespace.</simpara>
<note>
<simpara>You cannot enable synchronization for any system-created <literal>openshift-*</literal> namespaces, except for <literal>openshift-operators</literal>.</simpara>
</note>
<simpara>If an Operator is installed in a user-created <literal>openshift-*</literal> namespace, synchronization is enabled automatically after a cluster service version (CSV) is created in the namespace. The synchronized label is derived from the permissions of the service accounts in the namespace.</simpara>
</section>
</section>
<section xml:id="security-context-constraints-psa-opting_understanding-and-managing-pod-security-admission">
<title>Controlling pod security admission synchronization</title>
<simpara>You can enable or disable automatic pod security admission synchronization for most namespaces.</simpara>
<important>
<simpara>You cannot enable pod security admission synchronization on
some
system-created namespaces. For more information, see <emphasis>Pod security admission synchronization namespace exclusions</emphasis>.</simpara>
</important>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>For each namespace that you want to configure, set a value for the <literal>security.openshift.io/scc.podSecurityLabelSync</literal> label:</simpara>
<itemizedlist>
<listitem>
<simpara>To disable pod security admission label synchronization in a namespace, set the value of the <literal>security.openshift.io/scc.podSecurityLabelSync</literal> label to <literal>false</literal>.</simpara>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;namespace&gt; security.openshift.io/scc.podSecurityLabelSync=false</programlisting>
</listitem>
<listitem>
<simpara>To enable pod security admission label synchronization in a namespace, set the value of the <literal>security.openshift.io/scc.podSecurityLabelSync</literal> label to <literal>true</literal>.</simpara>
<simpara>Run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;namespace&gt; security.openshift.io/scc.podSecurityLabelSync=true</programlisting>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../authentication/understanding-and-managing-pod-security-admission.xml#security-context-constraints-psa-sync-exclusions_understanding-and-managing-pod-security-admission">Pod security admission synchronization namespace exclusions</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-context-constraints-psa-label_understanding-and-managing-pod-security-admission">
<title>Configuring pod security admission for a namespace</title>
<simpara>You can configure the pod security admission settings at the namespace level. For each of the pod security admission modes on the namespace, you can set which pod security admission profile to use.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>For each pod security admission mode that you want to set on a namespace, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc label namespace &lt;namespace&gt; \                <co xml:id="CO40-1"/>
    pod-security.kubernetes.io/&lt;mode&gt;=&lt;profile&gt; \ <co xml:id="CO40-2"/>
    --overwrite</programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>Set <literal>&lt;namespace&gt;</literal> to the namespace to configure.</para>
</callout>
<callout arearefs="CO40-2">
<para>Set <literal>&lt;mode&gt;</literal> to <literal>enforce</literal>, <literal>warn</literal>, or <literal>audit</literal>. Set <literal>&lt;profile&gt;</literal> to <literal>restricted</literal>, <literal>baseline</literal>, or <literal>privileged</literal>.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="security-context-constraints-psa-rectifying_understanding-and-managing-pod-security-admission">
<title>About pod security admission alerts</title>
<simpara>A <literal>PodSecurityViolation</literal> alert is triggered when the Kubernetes API server reports that there is a pod denial on the audit level of the pod security admission controller. This alert persists for one day.</simpara>
<simpara>View the Kubernetes API server audit logs to investigate alerts that were triggered. As an example, a workload is likely to fail admission if global enforcement is set to the <literal>restricted</literal> pod security level.</simpara>
<simpara>For assistance in identifying pod security admission violation audit events, see <link xlink:href="https://kubernetes.io/docs/reference/labels-annotations-taints/audit-annotations/#pod-security-kubernetes-io-audit-violations">Audit annotations</link> in the Kubernetes documentation.</simpara>
<section xml:id="security-context-constraints-psa-alert-eval_understanding-and-managing-pod-security-admission">
<title>Identifying pod security violations</title>
<simpara>The <literal>PodSecurityViolation</literal> alert does not provide details on which workloads are causing pod security violations. You can identify the affected workloads by reviewing the Kubernetes API server audit logs. This procedure uses the <literal>must-gather</literal> tool to gather the audit logs and then searches for the <literal>pod-security.kubernetes.io/audit-violations</literal> annotation.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed <literal>jq</literal>.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To gather the audit logs, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather -- /usr/bin/gather_audit_logs</programlisting>
</listitem>
<listitem>
<simpara>To output the affected workload details, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ zgrep -h pod-security.kubernetes.io/audit-violations must-gather.local.&lt;archive_id&gt;/quay*/audit_logs/kube-apiserver/*log.gz \
  | jq -r 'select((.annotations["pod-security.kubernetes.io/audit-violations"] != null) and (.objectRef.resource=="pods")) | .objectRef.namespace + " " + .objectRef.name + " " + .objectRef.resource' \
  | sort | uniq -c</programlisting>
<simpara>Replace <literal>must-gather.local.&lt;archive_id&gt;</literal> with the actual directory name.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="text" linenumbering="unnumbered">15 ci namespace-ttl-controller deployments
 1 ci-op-k5whzrsh rpm-repo-546f98d8b replicasets
 1 ci-op-k5whzrsh rpm-repo deployments</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="additional-resources_managing-pod-security-admission" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../security/audit-log-view.xml#nodes-nodes-audit-log-basic-viewing_audit-log-view">Viewing audit logs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../authentication/managing-security-context-constraints.xml#managing-pod-security-policies">Managing security context constraints</link></simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="impersonating-system-admin">
<title>Impersonating the system:admin user</title>

<section xml:id="authentication-api-impersonation_impersonating-system-admin">
<title>API impersonation</title>
<simpara>You can configure a request to the OpenShift Container Platform API to act as though it originated from another user. For more information, see <link xlink:href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation">User impersonation</link> in the Kubernetes documentation.</simpara>
</section>
<section xml:id="impersonation-system-admin-user_impersonating-system-admin">
<title>Impersonating the system:admin user</title>
<simpara>You can grant a user permission to impersonate <literal>system:admin</literal>, which grants them
cluster administrator permissions.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To grant a user permission to impersonate <literal>system:admin</literal>, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create clusterrolebinding &lt;any_valid_name&gt; --clusterrole=sudoer --user=&lt;username&gt;</programlisting>
<tip>
<simpara>You can alternatively apply the following YAML to grant permission to impersonate <literal>system:admin</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: &lt;any_valid_name&gt;
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: sudoer
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: &lt;username&gt;</programlisting>
</tip>
</listitem>
</itemizedlist>
</section>
<section xml:id="impersonation-system-admin-group_impersonating-system-admin">
<title>Impersonating the system:admin group</title>
<simpara>When a <literal>system:admin</literal> user is granted cluster administration permissions through a group, you must include the
<literal>--as=&lt;user&gt; --as-group=&lt;group1&gt; --as-group=&lt;group2&gt;</literal> parameters in the command to impersonate the associated groups.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To grant a user permission to impersonate a <literal>system:admin</literal> by impersonating the associated cluster administration groups,
run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create clusterrolebinding &lt;any_valid_name&gt; --clusterrole=sudoer --as=&lt;user&gt; \
--as-group=&lt;group1&gt; --as-group=&lt;group2&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="ldap-syncing">
<title>Syncing LDAP groups</title>

<simpara>As an administrator,
you can use groups to manage users, change
their permissions, and enhance collaboration. Your organization may have already
created user groups and stored them in an LDAP server. OpenShift Container Platform can sync
those LDAP records with internal OpenShift Container Platform records, enabling you to manage
your groups in one place. OpenShift Container Platform currently supports group sync with
LDAP servers using three common schemas for defining group membership: RFC 2307,
Active Directory, and augmented Active Directory.</simpara>
<simpara>For more information on configuring LDAP, see
<link xlink:href="../authentication/identity_providers/configuring-ldap-identity-provider.xml#configuring-ldap-identity-provider">Configuring an LDAP identity provider</link>.</simpara>
<note>
<simpara>You must have <literal>cluster-admin</literal> privileges to sync groups.</simpara>
</note>
<section xml:id="ldap-syncing-about_ldap-syncing-groups">
<title>About configuring LDAP sync</title>
<simpara>Before you can run LDAP sync, you need a sync
configuration file. This file contains the following LDAP client configuration details:</simpara>
<itemizedlist>
<listitem>
<simpara>Configuration for connecting to your LDAP server.</simpara>
</listitem>
<listitem>
<simpara>Sync configuration options that are dependent on the schema used in your LDAP
server.</simpara>
</listitem>
<listitem>
<simpara>An administrator-defined list of name mappings that maps OpenShift Container Platform group names to groups in your LDAP server.</simpara>
</listitem>
</itemizedlist>
<simpara>The format of the configuration file depends upon the schema you are using: RFC 2307, Active Directory, or augmented Active Directory.</simpara>
<variablelist xml:id="ldap-client-configuration">
<varlistentry>
<term>LDAP client configuration</term>
<listitem>
<simpara>The LDAP client configuration section of the configuration defines the connections to your LDAP server.</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The LDAP client configuration section of the configuration defines the connections to your LDAP server.</simpara>
<formalpara>
<title>LDAP client configuration</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">url: ldap://10.0.0.0:389 <co xml:id="CO41-1"/>
bindDN: cn=admin,dc=example,dc=com <co xml:id="CO41-2"/>
bindPassword: &lt;password&gt; <co xml:id="CO41-3"/>
insecure: false <co xml:id="CO41-4"/>
ca: my-ldap-ca-bundle.crt <co xml:id="CO41-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO41-1">
<para>The connection protocol, IP address of the LDAP server hosting your
database, and the port to connect to, formatted as <literal>scheme://host:port</literal>.</para>
</callout>
<callout arearefs="CO41-2">
<para>Optional distinguished name (DN) to use as the Bind DN.
OpenShift Container Platform uses this if elevated privilege is required to retrieve entries for
the sync operation.</para>
</callout>
<callout arearefs="CO41-3">
<para>Optional password to use to bind. OpenShift Container Platform uses this if elevated privilege is
necessary to retrieve entries for the sync operation. This value may also be
provided in an environment variable, external file, or encrypted file.</para>
</callout>
<callout arearefs="CO41-4">
<para>When <literal>false</literal>, secure
LDAP (<literal>ldaps://</literal>) URLs connect using TLS, and insecure LDAP (<literal>ldap://</literal>) URLs are
upgraded to TLS. When <literal>true</literal>, no TLS connection is made to the server and you cannot use <literal>ldaps://</literal> URL schemes.</para>
</callout>
<callout arearefs="CO41-5">
<para>The certificate bundle to use for validating server certificates for the
configured URL. If empty, OpenShift Container Platform uses system-trusted roots. This only applies
if <literal>insecure</literal> is set to <literal>false</literal>.</para>
</callout>
</calloutlist>
<variablelist xml:id="ldap-query-definition">
<varlistentry>
<term>LDAP query definition</term>
<listitem>
<simpara>Sync configurations consist of LDAP query definitions for the entries that are
required for synchronization. The specific definition of an LDAP query depends
on the schema used to store membership information in the LDAP server.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>LDAP query definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">baseDN: ou=users,dc=example,dc=com <co xml:id="CO42-1"/>
scope: sub <co xml:id="CO42-2"/>
derefAliases: never <co xml:id="CO42-3"/>
timeout: 0 <co xml:id="CO42-4"/>
filter: (objectClass=person) <co xml:id="CO42-5"/>
pageSize: 0 <co xml:id="CO42-6"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO42-1">
<para>The distinguished name (DN) of the branch of the directory where all
searches will start from. It is required that you specify the top of your
directory tree, but you can also specify a subtree in the directory.</para>
</callout>
<callout arearefs="CO42-2">
<para>The scope of the search. Valid values are <literal>base</literal>, <literal>one</literal>, or <literal>sub</literal>. If this
is left undefined, then a scope of <literal>sub</literal> is assumed. Descriptions of the scope
options can be found in the table below.</para>
</callout>
<callout arearefs="CO42-3">
<para>The behavior of the search with respect to aliases in the LDAP tree. Valid
values are <literal>never</literal>, <literal>search</literal>, <literal>base</literal>, or <literal>always</literal>. If this is left undefined,
then the default is to <literal>always</literal> dereference aliases. Descriptions of the
dereferencing behaviors can be found in the table below.</para>
</callout>
<callout arearefs="CO42-4">
<para>The time limit allowed for the search by the client, in seconds. A value of
<literal>0</literal> imposes no client-side limit.</para>
</callout>
<callout arearefs="CO42-5">
<para>A valid LDAP search filter. If this is left undefined, then the default is
<literal>(objectClass=*)</literal>.</para>
</callout>
<callout arearefs="CO42-6">
<para>The optional maximum size of response pages from the server, measured in LDAP
entries. If set to <literal>0</literal>, no size restrictions will be made on pages of responses.
Setting paging sizes is necessary when queries return more entries than the
client or server allow by default.</para>
</callout>
</calloutlist>
<table xml:id="ldap-search" frame="all" rowsep="1" colsep="1">
<title>LDAP search scope options</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">LDAP search scope</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara><literal>base</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only consider the object specified by the base DN given for the query.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>one</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Consider all of the objects on the same level in the tree as the base DN for
the query.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>sub</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Consider the entire subtree rooted at the base DN given for the query.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table xml:id="deref-aliases" frame="all" rowsep="1" colsep="1">
<title>LDAP dereferencing behaviors</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="80*"/>
<thead>
<row>
<entry align="left" valign="top">Dereferencing behavior</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara><literal>never</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Never dereference any aliases found in the LDAP tree.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>search</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only dereference aliases found while searching.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>base</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Only dereference aliases while finding the base object.</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara><literal>always</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Always dereference all aliases found in the LDAP tree.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<variablelist xml:id="user-defined-name-mapping">
<varlistentry>
<term>User-defined name mapping</term>
<listitem>
<simpara>A user-defined name mapping explicitly maps the names of OpenShift Container Platform groups to
unique identifiers that find groups on your LDAP server. The mapping uses normal
YAML syntax. A user-defined mapping can contain an entry for every group in your
LDAP server or only a subset of those groups. If there are groups on the LDAP
server that do not have a user-defined name mapping, the default behavior during
sync is to use the attribute specified as the OpenShift Container Platform group&#8217;s name.</simpara>
</listitem>
</varlistentry>
</variablelist>
<formalpara>
<title>User-defined name mapping</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">groupUIDNameMapping:
  "cn=group1,ou=groups,dc=example,dc=com": firstgroup
  "cn=group2,ou=groups,dc=example,dc=com": secondgroup
  "cn=group3,ou=groups,dc=example,dc=com": thirdgroup</programlisting>
</para>
</formalpara>
<section xml:id="ldap-syncing-config-rfc2307_ldap-syncing-groups">
<title>About the RFC 2307 configuration file</title>
<simpara>The RFC 2307 schema requires you to provide an LDAP query definition for both user
and group entries, as well as the attributes with which to represent them in the
internal OpenShift Container Platform records.</simpara>
<simpara>For clarity, the group you create in OpenShift Container Platform should use attributes other
than the distinguished name whenever possible for user- or administrator-facing
fields. For example, identify the users of an OpenShift Container Platform group by their e-mail, and use the
name of the group as the common name. The following configuration file creates
these relationships:</simpara>
<note>
<simpara>If using user-defined name mappings, your configuration file will differ.</simpara>
</note>
<formalpara>
<title>LDAP sync configuration that uses RFC 2307 schema: <literal>rfc2307_config.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
url: ldap://LDAP_SERVICE_IP:389 <co xml:id="CO43-1"/>
insecure: false <co xml:id="CO43-2"/>
rfc2307:
    groupsQuery:
        baseDN: "ou=groups,dc=example,dc=com"
        scope: sub
        derefAliases: never
        pageSize: 0
    groupUIDAttribute: dn <co xml:id="CO43-3"/>
    groupNameAttributes: [ cn ] <co xml:id="CO43-4"/>
    groupMembershipAttributes: [ member ] <co xml:id="CO43-5"/>
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
        pageSize: 0
    userUIDAttribute: dn <co xml:id="CO43-6"/>
    userNameAttributes: [ mail ] <co xml:id="CO43-7"/>
    tolerateMemberNotFoundErrors: false
    tolerateMemberOutOfScopeErrors: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO43-1">
<para>The IP address and host of the LDAP server where this group&#8217;s record is
stored.</para>
</callout>
<callout arearefs="CO43-2">
<para>When <literal>false</literal>, secure
LDAP (<literal>ldaps://</literal>) URLs connect using TLS, and insecure LDAP (<literal>ldap://</literal>) URLs are
upgraded to TLS. When <literal>true</literal>, no TLS connection is made to the server and you cannot use <literal>ldaps://</literal> URL schemes.</para>
</callout>
<callout arearefs="CO43-3">
<para>The attribute that uniquely identifies a group on the LDAP server.
You cannot specify <literal>groupsQuery</literal> filters when using DN for <literal>groupUIDAttribute</literal>.
For fine-grained filtering, use the whitelist / blacklist method.</para>
</callout>
<callout arearefs="CO43-4">
<para>The attribute to use as the name of the group.</para>
</callout>
<callout arearefs="CO43-5">
<para>The attribute on the group that stores the membership information.</para>
</callout>
<callout arearefs="CO43-6">
<para>The attribute that uniquely identifies a user on the LDAP server. You
cannot specify <literal>usersQuery</literal> filters when using DN for userUIDAttribute. For
fine-grained  filtering, use the whitelist / blacklist method.</para>
</callout>
<callout arearefs="CO43-7">
<para>The attribute to use as the name of the user in the OpenShift Container Platform group record.</para>
</callout>
</calloutlist>
</section>
<section xml:id="ldap-syncing-config-activedir_ldap-syncing-groups">
<title>About the Active Directory configuration file</title>
<simpara>The Active Directory schema requires you to provide an LDAP query definition for
user entries, as well as the attributes to represent them with in the internal
OpenShift Container Platform group records.</simpara>
<simpara>For clarity, the group you create in OpenShift Container Platform should use attributes other
than the distinguished name whenever possible for user- or administrator-facing
fields. For example, identify the users of an OpenShift Container Platform group by their e-mail, but define
the name of the group by the name of the group on the LDAP server.
The following configuration file creates these relationships:</simpara>
<formalpara>
<title>LDAP sync configuration that uses Active Directory schema: <literal>active_directory_config.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
url: ldap://LDAP_SERVICE_IP:389
activeDirectory:
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
        filter: (objectclass=person)
        pageSize: 0
    userNameAttributes: [ mail ] <co xml:id="CO44-1"/>
    groupMembershipAttributes: [ memberOf ] <co xml:id="CO44-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO44-1">
<para>The attribute to use as the name of the user in the OpenShift Container Platform group record.</para>
</callout>
<callout arearefs="CO44-2">
<para>The attribute on the user that stores the membership information.</para>
</callout>
</calloutlist>
</section>
<section xml:id="ldap-syncing-config-augmented-activedir_ldap-syncing-groups">
<title>About the augmented Active Directory configuration file</title>
<simpara>The augmented Active Directory schema requires you to provide an LDAP query
definition for both user entries and group entries, as well as the attributes
with which to represent them in the internal OpenShift Container Platform group records.</simpara>
<simpara>For clarity, the group you create in OpenShift Container Platform should use attributes other
than the distinguished name whenever possible for user- or administrator-facing
fields. For example, identify the users of an OpenShift Container Platform group by their e-mail,
and use the name of the group as the common name. The following configuration
file creates these relationships.</simpara>
<formalpara>
<title>LDAP sync configuration that uses augmented Active Directory schema: <literal>augmented_active_directory_config.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
url: ldap://LDAP_SERVICE_IP:389
augmentedActiveDirectory:
    groupsQuery:
        baseDN: "ou=groups,dc=example,dc=com"
        scope: sub
        derefAliases: never
        pageSize: 0
    groupUIDAttribute: dn <co xml:id="CO45-1"/>
    groupNameAttributes: [ cn ] <co xml:id="CO45-2"/>
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
        filter: (objectclass=person)
        pageSize: 0
    userNameAttributes: [ mail ] <co xml:id="CO45-3"/>
    groupMembershipAttributes: [ memberOf ] <co xml:id="CO45-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO45-1">
<para>The attribute that uniquely identifies a group on the LDAP server. You
cannot specify <literal>groupsQuery</literal> filters when using DN for groupUIDAttribute. For
fine-grained filtering, use the whitelist / blacklist method.</para>
</callout>
<callout arearefs="CO45-2">
<para>The attribute to use as the name of the group.</para>
</callout>
<callout arearefs="CO45-3">
<para>The attribute to use as the name of the user in the OpenShift Container Platform group record.</para>
</callout>
<callout arearefs="CO45-4">
<para>The attribute on the user that stores the membership information.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="ldap-syncing-running_ldap-syncing-groups">
<title>Running LDAP sync</title>
<simpara>Once you have created a sync configuration file, you can begin to sync. OpenShift Container Platform allows administrators to perform a number of different sync types with the same server.</simpara>
<section xml:id="ldap-syncing-running-all-ldap_ldap-syncing-groups">
<title>Syncing the LDAP server with OpenShift Container Platform</title>
<simpara>You can sync all groups from the LDAP server with OpenShift Container Platform.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a sync configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To sync all groups from the LDAP server with OpenShift Container Platform:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=config.yaml --confirm</programlisting>
<note>
<simpara>By default, all group synchronization operations are dry-run, so you
must set the <literal>--confirm</literal> flag on the <literal>oc adm groups sync</literal> command to make
changes to OpenShift Container Platform group records.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-running-openshift_ldap-syncing-groups">
<title>Syncing OpenShift Container Platform groups with the LDAP server</title>
<simpara>You can sync all groups already in OpenShift Container Platform that correspond to groups in the
LDAP server specified in the configuration file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a sync configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To sync OpenShift Container Platform groups with the LDAP server:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --type=openshift --sync-config=config.yaml --confirm</programlisting>
<note>
<simpara>By default, all group synchronization operations are dry-run, so you
must set the <literal>--confirm</literal> flag on the <literal>oc adm groups sync</literal> command to make
changes to OpenShift Container Platform group records.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-running-subset_ldap-syncing-groups">
<title>Syncing subgroups from the LDAP server with OpenShift Container Platform</title>
<simpara>You can sync a subset of LDAP groups with OpenShift Container Platform using whitelist files,
blacklist files, or both.</simpara>
<note>
<simpara>You can use any combination of blacklist files, whitelist files, or whitelist
literals. Whitelist and blacklist files must contain one unique group identifier
per line, and you can include whitelist literals directly in the command itself.
These guidelines apply to groups found on LDAP servers as well as groups already
present in OpenShift Container Platform.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create a sync configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To sync a subset of LDAP groups with OpenShift Container Platform, use any the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --whitelist=&lt;whitelist_file&gt; \
                   --sync-config=config.yaml      \
                   --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --blacklist=&lt;blacklist_file&gt; \
                   --sync-config=config.yaml      \
                   --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync &lt;group_unique_identifier&gt;    \
                   --sync-config=config.yaml      \
                   --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync &lt;group_unique_identifier&gt;  \
                   --whitelist=&lt;whitelist_file&gt; \
                   --blacklist=&lt;blacklist_file&gt; \
                   --sync-config=config.yaml    \
                   --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --type=openshift           \
                   --whitelist=&lt;whitelist_file&gt; \
                   --sync-config=config.yaml    \
                   --confirm</programlisting>
<note>
<simpara>By default, all group synchronization operations are dry-run, so you
must set the <literal>--confirm</literal> flag on the <literal>oc adm groups sync</literal> command to make
changes to OpenShift Container Platform group records.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ldap-syncing-pruning_ldap-syncing-groups">
<title>Running a group pruning job</title>
<simpara>An administrator can also choose to remove groups from OpenShift Container Platform records
if the records on the LDAP server that created them are no longer present. The
prune job will accept the same sync configuration file and whitelists or blacklists
as used for the sync job.</simpara>
<simpara>For example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm prune groups --sync-config=/path/to/ldap-sync-config.yaml --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm prune groups --whitelist=/path/to/whitelist.txt --sync-config=/path/to/ldap-sync-config.yaml --confirm</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm prune groups --blacklist=/path/to/blacklist.txt --sync-config=/path/to/ldap-sync-config.yaml --confirm</programlisting>
</section>
<section xml:id="ldap-auto-syncing_ldap-syncing-groups">
<title>Automatically syncing LDAP groups</title>
<simpara>You can automatically sync LDAP groups on a periodic basis by configuring a cron job.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>You have configured an LDAP identity provider (IDP).</simpara>
<simpara>This procedure assumes that you created an LDAP secret named <literal>ldap-secret</literal> and a config map named <literal>ca-config-map</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a project where the cron job will run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc new-project ldap-sync <co xml:id="CO46-1"/></programlisting>
<calloutlist>
<callout arearefs="CO46-1">
<para>This procedure uses a project called <literal>ldap-sync</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Locate the secret and config map that you created when configuring the LDAP identity provider and copy them to this new project.</simpara>
<simpara>The secret and config map exist in the <literal>openshift-config</literal> project and must be copied to the new <literal>ldap-sync</literal> project.</simpara>
</listitem>
<listitem>
<simpara>Define a service account:</simpara>
<formalpara>
<title>Example <literal>ldap-sync-service-account.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ServiceAccount
apiVersion: v1
metadata:
  name: ldap-group-syncer
  namespace: ldap-sync</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ldap-sync-service-account.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a cluster role:</simpara>
<formalpara>
<title>Example <literal>ldap-sync-cluster-role.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: ldap-group-syncer
rules:
  - apiGroups:
      - ''
      - user.openshift.io
    resources:
      - groups
    verbs:
      - get
      - list
      - create
      - update</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the cluster role:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ldap-sync-cluster-role.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a cluster role binding to bind the cluster role to the service account:</simpara>
<formalpara>
<title>Example <literal>ldap-sync-cluster-role-binding.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: ldap-group-syncer
subjects:
  - kind: ServiceAccount
    name: ldap-group-syncer              <co xml:id="CO47-1"/>
    namespace: ldap-sync
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: ldap-group-syncer                <co xml:id="CO47-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO47-1">
<para>Reference to the service account created earlier in this procedure.</para>
</callout>
<callout arearefs="CO47-2">
<para>Reference to the cluster role created earlier in this procedure.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the cluster role binding:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ldap-sync-cluster-role-binding.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a config map that specifies the sync configuration file:</simpara>
<formalpara>
<title>Example <literal>ldap-sync-config-map.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ConfigMap
apiVersion: v1
metadata:
  name: ldap-group-syncer
  namespace: ldap-sync
data:
  sync.yaml: |                                 <co xml:id="CO48-1"/>
    kind: LDAPSyncConfig
    apiVersion: v1
    url: ldaps://10.0.0.0:389                  <co xml:id="CO48-2"/>
    insecure: false
    bindDN: cn=admin,dc=example,dc=com         <co xml:id="CO48-3"/>
    bindPassword:
      file: "/etc/secrets/bindPassword"
    ca: /etc/ldap-ca/ca.crt
    rfc2307:                                   <co xml:id="CO48-4"/>
      groupsQuery:
        baseDN: "ou=groups,dc=example,dc=com"  <co xml:id="CO48-5"/>
        scope: sub
        filter: "(objectClass=groupOfMembers)"
        derefAliases: never
        pageSize: 0
      groupUIDAttribute: dn
      groupNameAttributes: [ cn ]
      groupMembershipAttributes: [ member ]
      usersQuery:
        baseDN: "ou=users,dc=example,dc=com"   <co xml:id="CO48-6"/>
        scope: sub
        derefAliases: never
        pageSize: 0
      userUIDAttribute: dn
      userNameAttributes: [ uid ]
      tolerateMemberNotFoundErrors: false
      tolerateMemberOutOfScopeErrors: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO48-1">
<para>Define the sync configuration file.</para>
</callout>
<callout arearefs="CO48-2">
<para>Specify the URL.</para>
</callout>
<callout arearefs="CO48-3">
<para>Specify the <literal>bindDN</literal>.</para>
</callout>
<callout arearefs="CO48-4">
<para>This example uses the RFC2307 schema; adjust values as necessary. You can also use a different schema.</para>
</callout>
<callout arearefs="CO48-5">
<para>Specify the <literal>baseDN</literal> for <literal>groupsQuery</literal>.</para>
</callout>
<callout arearefs="CO48-6">
<para>Specify the <literal>baseDN</literal> for <literal>usersQuery</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the config map:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ldap-sync-config-map.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define a cron job:</simpara>
<formalpara>
<title>Example <literal>ldap-sync-cron-job.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: CronJob
apiVersion: batch/v1
metadata:
  name: ldap-group-syncer
  namespace: ldap-sync
spec:                                                                                <co xml:id="CO49-1"/>
  schedule: "*/30 * * * *"                                                           <co xml:id="CO49-2"/>
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 0
      ttlSecondsAfterFinished: 1800                                                  <co xml:id="CO49-3"/>
      template:
        spec:
          containers:
            - name: ldap-group-sync
              image: "registry.redhat.io/openshift4/ose-cli:latest"
              command:
                - "/bin/bash"
                - "-c"
                - "oc adm groups sync --sync-config=/etc/config/sync.yaml --confirm" <co xml:id="CO49-4"/>
              volumeMounts:
                - mountPath: "/etc/config"
                  name: "ldap-sync-volume"
                - mountPath: "/etc/secrets"
                  name: "ldap-bind-password"
                - mountPath: "/etc/ldap-ca"
                  name: "ldap-ca"
          volumes:
            - name: "ldap-sync-volume"
              configMap:
                name: "ldap-group-syncer"
            - name: "ldap-bind-password"
              secret:
                secretName: "ldap-secret"                                            <co xml:id="CO49-5"/>
            - name: "ldap-ca"
              configMap:
                name: "ca-config-map"                                                <co xml:id="CO49-6"/>
          restartPolicy: "Never"
          terminationGracePeriodSeconds: 30
          activeDeadlineSeconds: 500
          dnsPolicy: "ClusterFirst"
          serviceAccountName: "ldap-group-syncer"</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO49-1">
<para>Configure the settings for the cron job. See "Creating cron jobs" for more information on cron job settings.</para>
</callout>
<callout arearefs="CO49-2">
<para>The schedule for the job specified in <link xlink:href="https://en.wikipedia.org/wiki/Cron">cron format</link>. This example cron job runs every 30 minutes. Adjust the frequency as necessary, making sure to take into account how long the sync takes to run.</para>
</callout>
<callout arearefs="CO49-3">
<para>How long, in seconds, to keep finished jobs. This should match the period of the job schedule in order to clean old failed jobs and prevent unnecessary alerts. For more information, see <link xlink:href="https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished">TTL-after-finished Controller</link> in the Kubernetes documentation.</para>
</callout>
<callout arearefs="CO49-4">
<para>The LDAP sync command for the cron job to run. Passes in the sync configuration file that was defined in the config map.</para>
</callout>
<callout arearefs="CO49-5">
<para>This secret was created when the LDAP IDP was configured.</para>
</callout>
<callout arearefs="CO49-6">
<para>This config map was created when the LDAP IDP was configured.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the cron job:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f ldap-sync-cron-job.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../authentication/identity_providers/configuring-ldap-identity-provider.xml#configuring-ldap-identity-provider">Configuring an LDAP identity provider</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../nodes/jobs/nodes-nodes-jobs.xml#nodes-nodes-jobs-creating-cron_nodes-nodes-jobs">Creating cron jobs</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-examples_ldap-syncing-groups">
<title>LDAP group sync examples</title>
<simpara>This section contains examples for the RFC 2307, Active Directory, and
augmented Active Directory schemas.</simpara>
<note>
<simpara>These examples assume that all users are direct members of their respective
groups. Specifically, no groups have other groups as members. See
the Nested Membership Sync Example for information on
how to sync nested groups.</simpara>
</note>
<section xml:id="ldap-syncing-rfc2307_ldap-syncing-groups">
<title>Syncing groups using the RFC 2307 schema</title>
<simpara>For the RFC 2307 schema, the following examples synchronize a group named <literal>admins</literal> that has two
members: <literal>Jane</literal> and <literal>Jim</literal>. The examples explain:</simpara>
<itemizedlist>
<listitem>
<simpara>How the group and users are added to the LDAP server.</simpara>
</listitem>
<listitem>
<simpara>What the resulting group record in OpenShift Container Platform will be after synchronization.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>These examples assume that all users are direct members of their respective
groups. Specifically, no groups have other groups as members. See
the Nested Membership Sync Example for information on
how to sync nested groups.</simpara>
</note>
<simpara>In the RFC 2307 schema, both users (Jane and Jim) and groups exist on the LDAP
server as first-class entries, and group membership is stored in attributes on
the group. The following snippet of <literal>ldif</literal> defines the users and group for this
schema:</simpara>
<formalpara>
<title>LDAP entries that use RFC 2307 schema: <literal>rfc2307.ldif</literal></title>
<para>
<programlisting language="ldif" linenumbering="unnumbered">  dn: ou=users,dc=example,dc=com
  objectClass: organizationalUnit
  ou: users
  dn: cn=Jane,ou=users,dc=example,dc=com
  objectClass: person
  objectClass: organizationalPerson
  objectClass: inetOrgPerson
  cn: Jane
  sn: Smith
  displayName: Jane Smith
  mail: jane.smith@example.com
  dn: cn=Jim,ou=users,dc=example,dc=com
  objectClass: person
  objectClass: organizationalPerson
  objectClass: inetOrgPerson
  cn: Jim
  sn: Adams
  displayName: Jim Adams
  mail: jim.adams@example.com
  dn: ou=groups,dc=example,dc=com
  objectClass: organizationalUnit
  ou: groups
  dn: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO50-1"/>
  objectClass: groupOfNames
  cn: admins
  owner: cn=admin,dc=example,dc=com
  description: System Administrators
  member: cn=Jane,ou=users,dc=example,dc=com <co xml:id="CO50-2"/>
  member: cn=Jim,ou=users,dc=example,dc=com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO50-1">
<para>The group is a first-class entry in the LDAP server.</para>
</callout>
<callout arearefs="CO50-2">
<para>Members of a group are listed with an identifying reference as attributes on
the group.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>rfc2307_config.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=rfc2307_config.yaml --confirm</programlisting>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>rfc2307_config.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400 <co xml:id="CO51-1"/>
    openshift.io/ldap.uid: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO51-2"/>
    openshift.io/ldap.url: LDAP_SERVER_IP:389 <co xml:id="CO51-3"/>
  creationTimestamp:
  name: admins <co xml:id="CO51-4"/>
users: <co xml:id="CO51-5"/>
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO51-1">
<para>The last time this OpenShift Container Platform group was synchronized with the LDAP server, in ISO 6801
format.</para>
</callout>
<callout arearefs="CO51-2">
<para>The unique identifier for the group on the LDAP server.</para>
</callout>
<callout arearefs="CO51-3">
<para>The IP address and host of the LDAP server where this group&#8217;s record is
stored.</para>
</callout>
<callout arearefs="CO51-4">
<para>The name of the group as specified by the sync file.</para>
</callout>
<callout arearefs="CO51-5">
<para>The users that are members of the group, named as specified by the sync file.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-rfc2307-user-defined_ldap-syncing-groups">
<title>Syncing groups using the RFC2307 schema with user-defined name mappings</title>
<simpara>When syncing groups with user-defined name mappings, the configuration file
changes to contain these mappings as shown below.</simpara>
<formalpara>
<title>LDAP sync configuration that uses RFC 2307 schema with user-defined name mappings: <literal>rfc2307_config_user_defined.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
groupUIDNameMapping:
  "cn=admins,ou=groups,dc=example,dc=com": Administrators <co xml:id="CO52-1"/>
rfc2307:
    groupsQuery:
        baseDN: "ou=groups,dc=example,dc=com"
        scope: sub
        derefAliases: never
        pageSize: 0
    groupUIDAttribute: dn <co xml:id="CO52-2"/>
    groupNameAttributes: [ cn ] <co xml:id="CO52-3"/>
    groupMembershipAttributes: [ member ]
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
        pageSize: 0
    userUIDAttribute: dn <co xml:id="CO52-4"/>
    userNameAttributes: [ mail ]
    tolerateMemberNotFoundErrors: false
    tolerateMemberOutOfScopeErrors: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO52-1">
<para>The user-defined name mapping.</para>
</callout>
<callout arearefs="CO52-2">
<para>The unique identifier attribute that is used for the keys in the
user-defined name mapping. You cannot specify <literal>groupsQuery</literal> filters when using
DN for groupUIDAttribute. For fine-grained filtering, use the whitelist / blacklist method.</para>
</callout>
<callout arearefs="CO52-3">
<para>The attribute to name OpenShift Container Platform groups with if their unique identifier is
not in the user-defined name mapping.</para>
</callout>
<callout arearefs="CO52-4">
<para>The attribute that uniquely identifies a user on the LDAP server. You
cannot specify <literal>usersQuery</literal> filters when using DN for userUIDAttribute. For
fine-grained  filtering, use the whitelist / blacklist method.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>rfc2307_config_user_defined.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=rfc2307_config_user_defined.yaml --confirm</programlisting>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>rfc2307_config_user_defined.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400
    openshift.io/ldap.uid: cn=admins,ou=groups,dc=example,dc=com
    openshift.io/ldap.url: LDAP_SERVER_IP:389
  creationTimestamp:
  name: Administrators <co xml:id="CO53-1"/>
users:
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO53-1">
<para>The name of the group as specified by the user-defined name mapping.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-rfc2307-user-defined-error_ldap-syncing-groups">
<title>Syncing groups using RFC 2307 with user-defined error tolerances</title>
<simpara>By default, if the groups being synced contain members whose entries are outside
of the scope defined in the member query, the group sync fails with an error:</simpara>
<screen>Error determining LDAP group membership for "&lt;group&gt;": membership lookup for user "&lt;user&gt;" in group "&lt;group&gt;" failed because of "search for entry with dn="&lt;user-dn&gt;" would search outside of the base dn specified (dn="&lt;base-dn&gt;")".</screen>
<simpara>This often indicates a misconfigured <literal>baseDN</literal> in the <literal>usersQuery</literal> field.
However, in cases where the <literal>baseDN</literal> intentionally does not contain some of the
members of the group, setting <literal>tolerateMemberOutOfScopeErrors: true</literal> allows
the group sync to continue. Out of scope members will be ignored.</simpara>
<simpara>Similarly, when the group sync process fails to locate a member for a group, it
fails outright with errors:</simpara>
<screen>Error determining LDAP group membership for "&lt;group&gt;": membership lookup for user "&lt;user&gt;" in group "&lt;group&gt;" failed because of "search for entry with base dn="&lt;user-dn&gt;" refers to a non-existent entry".
Error determining LDAP group membership for "&lt;group&gt;": membership lookup for user "&lt;user&gt;" in group "&lt;group&gt;" failed because of "search for entry with base dn="&lt;user-dn&gt;" and filter "&lt;filter&gt;" did not return any results".</screen>
<simpara>This often indicates a misconfigured <literal>usersQuery</literal> field. However, in cases
where the group contains member entries that are known to be missing, setting
<literal>tolerateMemberNotFoundErrors: true</literal> allows the group sync to continue.
Problematic members will be ignored.</simpara>
<warning>
<simpara>Enabling error tolerances for the LDAP group sync causes the sync process to
ignore problematic member entries. If the LDAP group sync is not configured
correctly, this could result in synced OpenShift Container Platform groups missing members.</simpara>
</warning>
<formalpara>
<title>LDAP entries that use RFC 2307 schema with problematic group membership: <literal>rfc2307_problematic_users.ldif</literal></title>
<para>
<programlisting language="ldif" linenumbering="unnumbered">  dn: ou=users,dc=example,dc=com
  objectClass: organizationalUnit
  ou: users
  dn: cn=Jane,ou=users,dc=example,dc=com
  objectClass: person
  objectClass: organizationalPerson
  objectClass: inetOrgPerson
  cn: Jane
  sn: Smith
  displayName: Jane Smith
  mail: jane.smith@example.com
  dn: cn=Jim,ou=users,dc=example,dc=com
  objectClass: person
  objectClass: organizationalPerson
  objectClass: inetOrgPerson
  cn: Jim
  sn: Adams
  displayName: Jim Adams
  mail: jim.adams@example.com
  dn: ou=groups,dc=example,dc=com
  objectClass: organizationalUnit
  ou: groups
  dn: cn=admins,ou=groups,dc=example,dc=com
  objectClass: groupOfNames
  cn: admins
  owner: cn=admin,dc=example,dc=com
  description: System Administrators
  member: cn=Jane,ou=users,dc=example,dc=com
  member: cn=Jim,ou=users,dc=example,dc=com
  member: cn=INVALID,ou=users,dc=example,dc=com <co xml:id="CO54-1"/>
  member: cn=Jim,ou=OUTOFSCOPE,dc=example,dc=com <co xml:id="CO54-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO54-1">
<para>A member that does not exist on the LDAP server.</para>
</callout>
<callout arearefs="CO54-2">
<para>A member that may exist, but is not under the <literal>baseDN</literal> in the
user query for the sync job.</para>
</callout>
</calloutlist>
<simpara>To tolerate the errors in the above example, the following additions to
your sync configuration file must be made:</simpara>
<formalpara>
<title>LDAP sync configuration that uses RFC 2307 schema tolerating errors: <literal>rfc2307_config_tolerating.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
url: ldap://LDAP_SERVICE_IP:389
rfc2307:
    groupsQuery:
        baseDN: "ou=groups,dc=example,dc=com"
        scope: sub
        derefAliases: never
    groupUIDAttribute: dn
    groupNameAttributes: [ cn ]
    groupMembershipAttributes: [ member ]
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
    userUIDAttribute: dn <co xml:id="CO55-1"/>
    userNameAttributes: [ mail ]
    tolerateMemberNotFoundErrors: true <co xml:id="CO55-2"/>
    tolerateMemberOutOfScopeErrors: true <co xml:id="CO55-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO55-1">
<para>The attribute that uniquely identifies a user on the LDAP server. You
cannot specify <literal>usersQuery</literal> filters when using DN for userUIDAttribute. For
fine-grained  filtering, use the whitelist / blacklist method.</para>
</callout>
<callout arearefs="CO55-2">
<para>When <literal>true</literal>, the sync job tolerates groups for which some members were not
found, and members whose LDAP entries are not found are ignored. The
default behavior for the sync job is to fail if a member of a group is not
found.</para>
</callout>
<callout arearefs="CO55-3">
<para>When <literal>true</literal>, the sync job tolerates groups for which some members are outside
the user scope given in the <literal>usersQuery</literal> base DN, and members outside the member
query scope are ignored. The default behavior for the sync job is to fail if a
member of a group is out of scope.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>rfc2307_config_tolerating.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=rfc2307_config_tolerating.yaml --confirm</programlisting>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>rfc2307_config.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400
    openshift.io/ldap.uid: cn=admins,ou=groups,dc=example,dc=com
    openshift.io/ldap.url: LDAP_SERVER_IP:389
  creationTimestamp:
  name: admins
users: <co xml:id="CO56-1"/>
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO56-1">
<para>The users that are members of the group, as specified by the sync file.
Members for which lookup encountered tolerated errors are absent.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-activedir_ldap-syncing-groups">
<title>Syncing groups using the Active Directory schema</title>
<simpara>In the Active Directory schema, both users (Jane and Jim) exist in the LDAP
server as first-class entries, and group membership is stored in attributes on
the user. The following snippet of <literal>ldif</literal> defines the users and group for this
schema:</simpara>
<formalpara>
<title>LDAP entries that use Active Directory schema: <literal>active_directory.ldif</literal></title>
<para>
<programlisting language="ldif" linenumbering="unnumbered">dn: ou=users,dc=example,dc=com
objectClass: organizationalUnit
ou: users

dn: cn=Jane,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jane
sn: Smith
displayName: Jane Smith
mail: jane.smith@example.com
memberOf: admins <co xml:id="CO57-1"/>

dn: cn=Jim,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jim
sn: Adams
displayName: Jim Adams
mail: jim.adams@example.com
memberOf: admins</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO57-1">
<para>The user&#8217;s group memberships are listed as attributes on the user, and the
group does not exist as an entry on the server. The <literal>memberOf</literal> attribute does
not have to be a literal attribute on the user; in some LDAP servers, it is created
during search and returned to the client, but not committed to the database.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>active_directory_config.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=active_directory_config.yaml --confirm</programlisting>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>active_directory_config.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400 <co xml:id="CO58-1"/>
    openshift.io/ldap.uid: admins <co xml:id="CO58-2"/>
    openshift.io/ldap.url: LDAP_SERVER_IP:389 <co xml:id="CO58-3"/>
  creationTimestamp:
  name: admins <co xml:id="CO58-4"/>
users: <co xml:id="CO58-5"/>
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO58-1">
<para>The last time this OpenShift Container Platform group was synchronized with the LDAP server, in ISO 6801
format.</para>
</callout>
<callout arearefs="CO58-2">
<para>The unique identifier for the group on the LDAP server.</para>
</callout>
<callout arearefs="CO58-3">
<para>The IP address and host of the LDAP server where this group&#8217;s record is
stored.</para>
</callout>
<callout arearefs="CO58-4">
<para>The name of the group as listed in the LDAP server.</para>
</callout>
<callout arearefs="CO58-5">
<para>The users that are members of the group, named as specified by the sync
file.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="ldap-syncing-augmented-activedir_ldap-syncing-groups">
<title>Syncing groups using the augmented Active Directory schema</title>
<simpara>In the augmented Active Directory schema, both users (Jane and Jim) and groups
exist in the LDAP server as first-class entries, and group membership is stored
in attributes on the user. The following snippet of <literal>ldif</literal> defines the users and
group for this schema:</simpara>
<formalpara>
<title>LDAP entries that use augmented Active Directory schema: <literal>augmented_active_directory.ldif</literal></title>
<para>
<programlisting language="ldif" linenumbering="unnumbered">dn: ou=users,dc=example,dc=com
objectClass: organizationalUnit
ou: users

dn: cn=Jane,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jane
sn: Smith
displayName: Jane Smith
mail: jane.smith@example.com
memberOf: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO59-1"/>

dn: cn=Jim,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jim
sn: Adams
displayName: Jim Adams
mail: jim.adams@example.com
memberOf: cn=admins,ou=groups,dc=example,dc=com

dn: ou=groups,dc=example,dc=com
objectClass: organizationalUnit
ou: groups

dn: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO59-2"/>
objectClass: groupOfNames
cn: admins
owner: cn=admin,dc=example,dc=com
description: System Administrators
member: cn=Jane,ou=users,dc=example,dc=com
member: cn=Jim,ou=users,dc=example,dc=com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO59-1">
<para>The user&#8217;s group memberships are listed as attributes on the user.</para>
</callout>
<callout arearefs="CO59-2">
<para>The group is a first-class entry on the LDAP server.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>augmented_active_directory_config.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync --sync-config=augmented_active_directory_config.yaml --confirm</programlisting>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>augmented_active_directory_config.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400 <co xml:id="CO60-1"/>
    openshift.io/ldap.uid: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO60-2"/>
    openshift.io/ldap.url: LDAP_SERVER_IP:389 <co xml:id="CO60-3"/>
  creationTimestamp:
  name: admins <co xml:id="CO60-4"/>
users: <co xml:id="CO60-5"/>
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO60-1">
<para>The last time this OpenShift Container Platform group was synchronized with the LDAP server, in ISO 6801 format.</para>
</callout>
<callout arearefs="CO60-2">
<para>The unique identifier for the group on the LDAP server.</para>
</callout>
<callout arearefs="CO60-3">
<para>The IP address and host of the LDAP server where this group&#8217;s record is stored.</para>
</callout>
<callout arearefs="CO60-4">
<para>The name of the group as specified by the sync file.</para>
</callout>
<callout arearefs="CO60-5">
<para>The users that are members of the group, named as specified by the sync file.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<section xml:id="ldap-syncing-nesting_ldap-syncing-groups">
<title>LDAP nested membership sync example</title>
<simpara>Groups in OpenShift Container Platform do not nest. The LDAP server must flatten group
membership before the data can be consumed. Microsoft&#8217;s Active Directory Server
supports this feature via the
<link xlink:href="https://msdn.microsoft.com/en-us/library/aa746475(v=vs.85).aspx"><literal>LDAP_MATCHING_RULE_IN_CHAIN</literal></link>
rule, which has the OID <literal>1.2.840.113556.1.4.1941</literal>. Furthermore, only explicitly
whitelisted groups can be synced when using this matching rule.</simpara>
<simpara>This section has an example for the augmented Active Directory schema, which
synchronizes a group named <literal>admins</literal> that has one user <literal>Jane</literal> and one group
<literal>otheradmins</literal> as members. The <literal>otheradmins</literal> group has one user member: <literal>Jim</literal>.
This example explains:</simpara>
<itemizedlist>
<listitem>
<simpara>How the group and users are added to the LDAP server.</simpara>
</listitem>
<listitem>
<simpara>What the LDAP sync configuration file looks like.</simpara>
</listitem>
<listitem>
<simpara>What the resulting group record in OpenShift Container Platform will be after synchronization.</simpara>
</listitem>
</itemizedlist>
<simpara>In the augmented Active Directory schema, both users (<literal>Jane</literal> and <literal>Jim</literal>) and
groups exist in the LDAP server as first-class entries, and group membership is
stored in attributes on the user or the group. The following snippet of <literal>ldif</literal>
defines the users and groups for this schema:</simpara>
<formalpara>
<title>LDAP entries that use augmented Active Directory schema with nested members: <literal>augmented_active_directory_nested.ldif</literal></title>
<para>
<programlisting language="ldif" linenumbering="unnumbered">dn: ou=users,dc=example,dc=com
objectClass: organizationalUnit
ou: users

dn: cn=Jane,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jane
sn: Smith
displayName: Jane Smith
mail: jane.smith@example.com
memberOf: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO61-1"/>

dn: cn=Jim,ou=users,dc=example,dc=com
objectClass: person
objectClass: organizationalPerson
objectClass: inetOrgPerson
objectClass: testPerson
cn: Jim
sn: Adams
displayName: Jim Adams
mail: jim.adams@example.com
memberOf: cn=otheradmins,ou=groups,dc=example,dc=com <co xml:id="CO61-2"/>

dn: ou=groups,dc=example,dc=com
objectClass: organizationalUnit
ou: groups

dn: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO61-3"/>
objectClass: group
cn: admins
owner: cn=admin,dc=example,dc=com
description: System Administrators
member: cn=Jane,ou=users,dc=example,dc=com
member: cn=otheradmins,ou=groups,dc=example,dc=com

dn: cn=otheradmins,ou=groups,dc=example,dc=com <co xml:id="CO61-4"/>
objectClass: group
cn: otheradmins
owner: cn=admin,dc=example,dc=com
description: Other System Administrators
memberOf: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO61-5"/> <co xml:id="CO61-6"/>
member: cn=Jim,ou=users,dc=example,dc=com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO61-1 CO61-2 CO61-5">
<para>The user&#8217;s and group&#8217;s memberships are listed as attributes on the object.</para>
</callout>
<callout arearefs="CO61-3 CO61-4">
<para>The groups are first-class entries on the LDAP server.</para>
</callout>
<callout arearefs="CO61-6">
<para>The <literal>otheradmins</literal> group is a member of the <literal>admins</literal> group.</para>
</callout>
</calloutlist>
<simpara>When syncing nested groups with Active Directory, you must provide an LDAP query
definition for both user entries and group entries, as well as the attributes
with which to represent them in the internal OpenShift Container Platform group records.
Furthermore, certain changes are required in this configuration:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>oc adm groups sync</literal> command must explicitly whitelist groups.</simpara>
</listitem>
<listitem>
<simpara>The user&#8217;s <literal>groupMembershipAttributes</literal> must include
<literal>"memberOf:1.2.840.113556.1.4.1941:"</literal> to comply with the
<link xlink:href="https://msdn.microsoft.com/en-us/library/aa746475(v=vs.85).aspx"><literal>LDAP_MATCHING_RULE_IN_CHAIN</literal></link>
rule.</simpara>
</listitem>
<listitem>
<simpara>The <literal>groupUIDAttribute</literal> must be set to <literal>dn</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>groupsQuery</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara>Must not set <literal>filter</literal>.</simpara>
</listitem>
<listitem>
<simpara>Must set a valid <literal>derefAliases</literal>.</simpara>
</listitem>
<listitem>
<simpara>Should not set <literal>baseDN</literal> as that value is ignored.</simpara>
</listitem>
<listitem>
<simpara>Should not set <literal>scope</literal> as that value is ignored.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>For clarity, the group you create in OpenShift Container Platform should use attributes other
than the distinguished name whenever possible for user- or administrator-facing
fields. For example, identify the users of an OpenShift Container Platform group by their e-mail, and use the
name of the group as the common name. The following configuration file creates
these relationships:</simpara>
<formalpara>
<title>LDAP sync configuration that uses augmented Active Directory schema with nested members: <literal>augmented_active_directory_config_nested.yaml</literal></title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: LDAPSyncConfig
apiVersion: v1
url: ldap://LDAP_SERVICE_IP:389
augmentedActiveDirectory:
    groupsQuery: <co xml:id="CO62-1"/>
        derefAliases: never
        pageSize: 0
    groupUIDAttribute: dn <co xml:id="CO62-2"/>
    groupNameAttributes: [ cn ] <co xml:id="CO62-3"/>
    usersQuery:
        baseDN: "ou=users,dc=example,dc=com"
        scope: sub
        derefAliases: never
        filter: (objectclass=person)
        pageSize: 0
    userNameAttributes: [ mail ] <co xml:id="CO62-4"/>
    groupMembershipAttributes: [ "memberOf:1.2.840.113556.1.4.1941:" ] <co xml:id="CO62-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO62-1">
<para><literal>groupsQuery</literal> filters cannot be specified. The <literal>groupsQuery</literal> base DN and scope
values are ignored. <literal>groupsQuery</literal> must set a valid <literal>derefAliases</literal>.</para>
</callout>
<callout arearefs="CO62-2">
<para>The attribute that uniquely identifies a group on the LDAP server. It must be set to <literal>dn</literal>.</para>
</callout>
<callout arearefs="CO62-3">
<para>The attribute to use as the name of the group.</para>
</callout>
<callout arearefs="CO62-4">
<para>The attribute to use as the name of the user in the OpenShift Container Platform group
record. <literal>mail</literal> or <literal>sAMAccountName</literal> are preferred choices in most installations.</para>
</callout>
<callout arearefs="CO62-5">
<para>The attribute on the user that stores the membership information. Note the use
of <link xlink:href="https://msdn.microsoft.com/en-us/library/aa746475(v=vs.85).aspx"><literal>LDAP_MATCHING_RULE_IN_CHAIN</literal></link>.</para>
</callout>
</calloutlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Create the configuration file.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Run the sync with the <literal>augmented_active_directory_config_nested.yaml</literal> file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm groups sync \
    'cn=admins,ou=groups,dc=example,dc=com' \
    --sync-config=augmented_active_directory_config_nested.yaml \
    --confirm</programlisting>
<note>
<simpara>You must explicitly whitelist the <literal>cn=admins,ou=groups,dc=example,dc=com</literal> group.</simpara>
</note>
<simpara>OpenShift Container Platform creates the following group record as a result of the above sync
operation:</simpara>
<formalpara>
<title>OpenShift Container Platform group created by using the <literal>augmented_active_directory_config_nested.yaml</literal> file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: user.openshift.io/v1
kind: Group
metadata:
  annotations:
    openshift.io/ldap.sync-time: 2015-10-13T10:08:38-0400 <co xml:id="CO63-1"/>
    openshift.io/ldap.uid: cn=admins,ou=groups,dc=example,dc=com <co xml:id="CO63-2"/>
    openshift.io/ldap.url: LDAP_SERVER_IP:389 <co xml:id="CO63-3"/>
  creationTimestamp:
  name: admins <co xml:id="CO63-4"/>
users: <co xml:id="CO63-5"/>
- jane.smith@example.com
- jim.adams@example.com</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO63-1">
<para>The last time this OpenShift Container Platform group was synchronized with the LDAP server, in ISO 6801 format.</para>
</callout>
<callout arearefs="CO63-2">
<para>The unique identifier for the group on the LDAP server.</para>
</callout>
<callout arearefs="CO63-3">
<para>The IP address and host of the LDAP server where this group&#8217;s record is stored.</para>
</callout>
<callout arearefs="CO63-4">
<para>The name of the group as specified by the sync file.</para>
</callout>
<callout arearefs="CO63-5">
<para>The users that are members of the group, named as specified by the sync file.
Note that members of nested groups are included since the group membership was
flattened by the Microsoft Active Directory Server.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="ldap-syncing-spec_ldap-syncing-groups">
<title>LDAP sync configuration specification</title>
<simpara>The object specification for the configuration file is below.  Note that the different schema
objects have different fields.  For example, v1.ActiveDirectoryConfig has no <literal>groupsQuery</literal>
field whereas v1.RFC2307Config and v1.AugmentedActiveDirectoryConfig both do.</simpara>
<important>
<simpara>There is no support for binary attributes. All attribute data coming from the
LDAP server must be in the format of a UTF-8 encoded string. For example, never
use a binary attribute, such as <literal>objectGUID</literal>, as an ID attribute. You must use
string attributes, such as <literal>sAMAccountName</literal> or <literal>userPrincipalName</literal>, instead.</simpara>
</important>
<section xml:id="sync-ldap-v1-ldapsyncconfig">
<title>v1.LDAPSyncConfig</title>
<simpara><literal>LDAPSyncConfig</literal> holds the necessary configuration options to define an LDAP
group sync.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>kind</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: <link xlink:href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#types-kinds">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#types-kinds</link></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>apiVersion</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: <link xlink:href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#resources">https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#resources</link></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>url</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Host is the scheme, host and port of the LDAP server to connect to: <literal>scheme://host:port</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>bindDN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional DN to bind to the LDAP server with.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>bindPassword</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional password to bind with during the search phase.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.StringSource</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>insecure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If <literal>true</literal>, indicates the connection should not use TLS. If <literal>false</literal>, <literal>ldaps://</literal> URLs connect using TLS, and <literal>ldap://</literal> URLs are upgraded to a TLS connection using StartTLS as specified in <link xlink:href="https://tools.ietf.org/html/rfc2830">https://tools.ietf.org/html/rfc2830</link>. If you set <literal>insecure</literal> to <literal>true</literal>, you cannot use <literal>ldaps://</literal> URL schemes.</simpara></entry>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ca</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional trusted certificate authority bundle to use when making requests to the server. If empty, the default system roots are used.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupUIDNameMapping</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional direct mapping of LDAP group UIDs to OpenShift Container Platform group names.</simpara></entry>
<entry align="left" valign="top"><simpara>object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>rfc2307</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the configuration for extracting data from an LDAP server set up in a fashion similar to RFC2307: first-class group and user entries, with group membership determined by a multi-valued attribute on the group entry listing its members.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.RFC2307Config</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>activeDirectory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the configuration for extracting data from an LDAP server set up in a fashion similar to that used in Active Directory: first-class user entries, with group membership determined by a multi-valued attribute on members listing groups they are a member of.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.ActiveDirectoryConfig</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>augmentedActiveDirectory</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the configuration for extracting data from an LDAP server set up in a fashion similar to that used in Active Directory as described above, with one addition: first-class group entries exist and are used to hold metadata but not group membership.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.AugmentedActiveDirectoryConfig</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sync-ldap-v1-stringsource">
<title>v1.StringSource</title>
<simpara><literal>StringSource</literal> allows specifying a string inline, or externally via environment
variable or file. When it contains only a string value, it marshals to a simple
JSON string.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>value</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the cleartext value, or an encrypted value if <literal>keyFile</literal> is specified.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>env</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies an environment variable containing the cleartext value, or an
encrypted value if the <literal>keyFile</literal> is specified.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>References a file containing the cleartext value, or an encrypted value if a <literal>keyFile</literal> is specified.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>keyFile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>References a file containing the key to use to decrypt the value.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sync-ldap-v1-ldapquery">
<title>v1.LDAPQuery</title>
<simpara><literal>LDAPQuery</literal> holds the options necessary to build an LDAP query.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>baseDN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>DN of the branch of the directory where all searches should start from.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>scope</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The optional scope of the search. Can be <literal>base</literal>: only the base object, <literal>one</literal>:
all objects on the base level, <literal>sub</literal>: the entire subtree. Defaults to <literal>sub</literal>
if not set.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>derefAliases</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The optional behavior of the search with regards to aliases. Can be <literal>never</literal>:
never dereference aliases, <literal>search</literal>: only dereference in searching, <literal>base</literal>:
only dereference in finding the base object, <literal>always</literal>: always dereference.
Defaults to <literal>always</literal> if not set.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>timeout</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the limit of time in seconds that any request to the server can remain outstanding before the wait for a response is given up. If this is <literal>0</literal>, no client-side limit is imposed.</simpara></entry>
<entry align="left" valign="top"><simpara>integer</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>filter</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A valid LDAP search filter that retrieves all relevant entries from the LDAP server with the base DN.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pageSize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Maximum preferred page size, measured in LDAP entries. A page size of <literal>0</literal> means no paging will be done.</simpara></entry>
<entry align="left" valign="top"><simpara>integer</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sync-ldap-v1-rfc2307config">
<title>v1.RFC2307Config</title>
<simpara><literal>RFC2307Config</literal> holds the necessary configuration options to define how an LDAP
group sync interacts with an LDAP server using the RFC2307 schema.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>groupsQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the template for an LDAP query that returns group entries.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.LDAPQuery</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupUIDAttribute</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attribute on an LDAP group entry will be interpreted as its unique identifier. (<literal>ldapGroupUID</literal>)</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupNameAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP group entry will be interpreted as its name to use for an OpenShift Container Platform group.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupMembershipAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP group entry will be interpreted as its members. The values contained in those attributes must be queryable by your <literal>UserUIDAttribute</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>usersQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the template for an LDAP query that returns user entries.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.LDAPQuery</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>userUIDAttribute</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attribute on an LDAP user entry will be interpreted as its unique identifier. It must correspond to values that will be found from the <literal>GroupMembershipAttributes</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>userNameAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP user entry will be used, in order, as its OpenShift Container Platform user name. The first attribute with a non-empty value is used. This should match your <literal>PreferredUsername</literal> setting for your <literal>LDAPPasswordIdentityProvider</literal>. The attribute to use as the name of the user in the OpenShift Container Platform group
record. <literal>mail</literal> or <literal>sAMAccountName</literal> are preferred choices in most installations.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tolerateMemberNotFoundErrors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines the behavior of the LDAP sync job when missing user entries are encountered. If <literal>true</literal>, an LDAP query for users that does not find any will be tolerated and an only and error will be logged. If <literal>false</literal>, the LDAP sync job will fail if a query for users doesn&#8217;t find any. The default value is <literal>false</literal>. Misconfigured LDAP sync jobs with this flag set to <literal>true</literal> can cause group membership to be removed, so it is recommended to use this flag with caution.</simpara></entry>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tolerateMemberOutOfScopeErrors</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Determines the behavior of the LDAP sync job when out-of-scope user entries are encountered. If <literal>true</literal>, an LDAP query for a user that falls outside of the base DN given for the all user query will be tolerated and only an error will be logged. If <literal>false</literal>, the LDAP sync job will fail if a user query would search outside of the base DN specified by the all user query. Misconfigured LDAP sync jobs with this flag set to <literal>true</literal> can result in groups missing users, so it is recommended to use this flag with caution.</simpara></entry>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sync-ldap-v1-activedirectoryconfig">
<title>v1.ActiveDirectoryConfig</title>
<simpara><literal>ActiveDirectoryConfig</literal> holds the necessary configuration options to define how
an LDAP group sync interacts with an LDAP server using the Active Directory
schema.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>usersQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the template for an LDAP query that returns user entries.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.LDAPQuery</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>userNameAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP user entry will be interpreted as its OpenShift Container Platform user name. The attribute to use as the name of the user in the OpenShift Container Platform group
record. <literal>mail</literal> or <literal>sAMAccountName</literal> are preferred choices in most installations.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupMembershipAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP user entry will be interpreted as the groups it is a member of.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="sync-ldap-v1-augmentedactivedirectoryconfig">
<title>v1.AugmentedActiveDirectoryConfig</title>
<simpara><literal>AugmentedActiveDirectoryConfig</literal> holds the necessary configuration options to
define how an LDAP group sync interacts with an LDAP server using the augmented
Active Directory schema.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Name</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Schema</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>usersQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the template for an LDAP query that returns user entries.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.LDAPQuery</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>userNameAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP user entry will be interpreted as its OpenShift Container Platform user name. The attribute to use as the name of the user in the OpenShift Container Platform group
record. <literal>mail</literal> or <literal>sAMAccountName</literal> are preferred choices in most installations.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupMembershipAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP user entry will be interpreted as the groups it is a member of.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupsQuery</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Holds the template for an LDAP query that returns group entries.</simpara></entry>
<entry align="left" valign="top"><simpara>v1.LDAPQuery</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupUIDAttribute</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attribute on an LDAP group entry will be interpreted as its unique identifier. (<literal>ldapGroupUID</literal>)</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groupNameAttributes</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defines which attributes on an LDAP group entry will be interpreted as its name to use for an OpenShift Container Platform group.</simpara></entry>
<entry align="left" valign="top"><simpara>string array</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
</chapter>
<chapter xml:id="_managing_cloud_provider_credentials">
<title>Managing cloud provider credentials</title>
<section xml:id="about-cloud-credential-operator">
<title>About the Cloud Credential Operator</title>

<simpara>The Cloud Credential Operator (CCO) manages cloud provider credentials as  custom resource definitions (CRDs). The CCO syncs on <literal>CredentialsRequest</literal> custom resources (CRs) to allow OpenShift Container Platform components to request cloud provider credentials with the specific permissions that are required for the cluster to run.</simpara>
<simpara>By setting different values for the <literal>credentialsMode</literal> parameter in the <literal>install-config.yaml</literal> file, the CCO can be configured to operate in several different modes. If no mode is specified, or the <literal>credentialsMode</literal> parameter is set to an empty string (<literal>""</literal>), the CCO operates in its default mode.</simpara>
<section xml:id="about-cloud-credential-operator-modes_about-cloud-credential-operator">
<title>Modes</title>
<simpara>By setting different values for the <literal>credentialsMode</literal> parameter in the <literal>install-config.yaml</literal> file, the CCO can be configured to operate in <emphasis>mint</emphasis>, <emphasis>passthrough</emphasis>, or <emphasis>manual</emphasis> mode. These options provide transparency and flexibility in how the CCO uses cloud credentials to process <literal>CredentialsRequest</literal> CRs in the cluster, and allow the CCO to be configured to suit the security requirements of your organization. Not all CCO modes are supported for all cloud providers.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-mode-mint.xml#cco-mode-mint">Mint</link></emphasis>: In mint mode, the CCO uses the provided admin-level cloud credential to create new credentials for components in the cluster with only the specific permissions that are required.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-mode-passthrough.xml#cco-mode-passthrough">Passthrough</link></emphasis>: In passthrough mode, the CCO passes the provided cloud credential to the components that request cloud credentials.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-mode-manual.xml#cco-mode-manual">Manual mode with long-term credentials for components</link></emphasis>: In manual mode, you can manage long-term cloud credentials instead of the CCO.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-short-term-creds.xml#cco-short-term-creds">Manual mode with short-term credentials for components</link></emphasis>: For some providers, you can use the CCO utility (<literal>ccoctl</literal>) during installation to implement short-term credentials for individual components. These credentials are created and managed outside the OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>CCO mode support matrix</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="16.6666*"/>
<colspec colname="col_3" colwidth="16.6666*"/>
<colspec colname="col_4" colwidth="16.6666*"/>
<colspec colname="col_5" colwidth="16.6669*"/>
<thead>
<row>
<entry align="left" valign="middle">Cloud provider</entry>
<entry align="center" valign="middle">Mint</entry>
<entry align="center" valign="middle">Passthrough</entry>
<entry align="center" valign="middle">Manual with long-term credentials</entry>
<entry align="center" valign="middle">Manual with short-term credentials</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle"><simpara>Alibaba Cloud</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[1]</superscript></simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Amazon Web Services (AWS)</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Global Microsoft Azure</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Microsoft Azure Stack Hub</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Google Cloud Platform (GCP)</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>IBM Cloud&#174;</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[1]</superscript></simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Nutanix</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X <superscript>[1]</superscript></simpara></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>Red Hat OpenStack Platform (RHOSP)</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
</row>
<row>
<entry align="left" valign="middle"><simpara>VMware vSphere</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"><simpara>X</simpara></entry>
<entry align="center" valign="middle"></entry>
<entry align="center" valign="middle"></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>This platform uses the <literal>ccoctl</literal> utility during installation to configure long-term credentials.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="cco-determine-mode_about-cloud-credential-operator">
<title>Determining the Cloud Credential Operator mode</title>
<simpara>For platforms that support using the CCO in multiple modes, you can determine what mode the CCO is configured to use by using the web console or the CLI.</simpara>
<figure>
<title>Determining the CCO configuration</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/334_OpenShift_cluster_updating_and_CCO_workflows_0923_4.11_A.png"/>
</imageobject>
<textobject><phrase>Decision tree showing how to determine the configured CCO credentials mode for your cluster.</phrase></textobject>
</mediaobject>
</figure>
<section xml:id="cco-determine-mode-gui_about-cloud-credential-operator">
<title>Determining the Cloud Credential Operator mode by using the web console</title>
<simpara>You can determine what mode the Cloud Credential Operator (CCO) is configured to use by using the web console.</simpara>
<note>
<simpara>Only Amazon Web Services (AWS), global Microsoft Azure, and Google Cloud Platform (GCP) clusters support multiple CCO modes.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an OpenShift Container Platform account with cluster administrator permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform web console as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Cluster Settings</emphasis> page, select the <emphasis role="strong">Configuration</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Configuration resource</emphasis>, select <emphasis role="strong">CloudCredential</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">CloudCredential details</emphasis> page, select the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>In the YAML block, check the value of <literal>spec.credentialsMode</literal>. The following values are possible, though not all are supported on all platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>''</literal>: The CCO is operating in the default mode. In this configuration, the CCO operates in mint or passthrough mode, depending on the credentials provided during installation.</simpara>
</listitem>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Manual</literal>: The CCO is operating in manual mode.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>To determine the specific configuration of an AWS, GCP, or global Microsoft Azure cluster that has a <literal>spec.credentialsMode</literal> of <literal>''</literal>, <literal>Mint</literal>, or <literal>Manual</literal>, you must investigate further.</simpara>
<simpara>AWS and GCP clusters support using mint mode with the root secret deleted.</simpara>
<simpara>An AWS, GCP, or global Microsoft Azure cluster that uses manual mode might be configured to create and manage cloud credentials from outside of the cluster with AWS STS, GCP Workload Identity, or Azure AD Workload Identity. You can determine whether your cluster uses this strategy by examining the cluster <literal>Authentication</literal> object.</simpara>
</important>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use the default (<literal>''</literal>) only: To determine whether the cluster is operating in mint or passthrough mode, inspect the annotations on the cluster root secret:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis> and look for the root secret for your cloud provider.</simpara>
<note>
<simpara>Ensure that the <emphasis role="strong">Project</emphasis> dropdown is set to <emphasis role="strong">All Projects</emphasis>.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Secret name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AWS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-creds</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gcp-credentials</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>To view the CCO mode that the cluster is using, click <literal>1 annotation</literal> under <emphasis role="strong">Annotations</emphasis>, and check the value field. The following values are possible:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
</itemizedlist>
<simpara>If your cluster uses mint mode, you can also determine whether the cluster is operating without the root secret.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use mint mode only: To determine whether the cluster is operating without the root secret, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis> and look for the root secret for your cloud provider.</simpara>
<note>
<simpara>Ensure that the <emphasis role="strong">Project</emphasis> dropdown is set to <emphasis role="strong">All Projects</emphasis>.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Secret name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AWS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-creds</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gcp-credentials</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist>
<listitem>
<simpara>If you see one of these values, your cluster is using mint or passthrough mode with the root secret present.</simpara>
</listitem>
<listitem>
<simpara>If you do not see these values, your cluster is using the CCO in mint mode with the root secret removed.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>AWS, GCP, or global Microsoft Azure clusters that use manual mode only: To determine whether the cluster is configured to create and manage cloud credentials from outside of the cluster, you must check the cluster <literal>Authentication</literal> object YAML values.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">Cluster Settings</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Cluster Settings</emphasis> page, select the <emphasis role="strong">Configuration</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Configuration resource</emphasis>, select <emphasis role="strong">Authentication</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Authentication details</emphasis> page, select the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>In the YAML block, check the value of the <literal>.spec.serviceAccountIssuer</literal> parameter.</simpara>
<itemizedlist>
<listitem>
<simpara>A value that contains a URL that is associated with your cloud provider indicates that the CCO is using manual mode with short-term credentials for components. These clusters are configured using the <literal>ccoctl</literal> utility to create and manage cloud credentials from outside of the cluster.</simpara>
</listitem>
<listitem>
<simpara>An empty value (<literal>''</literal>) indicates that the cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="cco-determine-mode-cli_about-cloud-credential-operator">
<title>Determining the Cloud Credential Operator mode by using the CLI</title>
<simpara>You can determine what mode the Cloud Credential Operator (CCO) is configured to use by using the CLI.</simpara>
<note>
<simpara>Only Amazon Web Services (AWS), global Microsoft Azure, and Google Cloud Platform (GCP) clusters support multiple CCO modes.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to an OpenShift Container Platform account with cluster administrator permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to <literal>oc</literal> on the cluster as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>To determine the mode that the CCO is configured to use, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get cloudcredentials cluster \
  -o=jsonpath={.spec.credentialsMode}</programlisting>
<simpara>The following output values are possible, though not all are supported on all platforms:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>''</literal>: The CCO is operating in the default mode. In this configuration, the CCO operates in mint or passthrough mode, depending on the credentials provided during installation.</simpara>
</listitem>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Manual</literal>: The CCO is operating in manual mode.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>To determine the specific configuration of an AWS, GCP, or global Microsoft Azure cluster that has a <literal>spec.credentialsMode</literal> of <literal>''</literal>, <literal>Mint</literal>, or <literal>Manual</literal>, you must investigate further.</simpara>
<simpara>AWS and GCP clusters support using mint mode with the root secret deleted.</simpara>
<simpara>An AWS, GCP, or global Microsoft Azure cluster that uses manual mode might be configured to create and manage cloud credentials from outside of the cluster with AWS STS, GCP Workload Identity, or Azure AD Workload Identity. You can determine whether your cluster uses this strategy by examining the cluster <literal>Authentication</literal> object.</simpara>
</important>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use the default (<literal>''</literal>) only: To determine whether the cluster is operating in mint or passthrough mode, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;secret_name&gt; \
  -n kube-system \
  -o jsonpath \
  --template '{ .metadata.annotations }'</programlisting>
<simpara>where <literal>&lt;secret_name&gt;</literal> is <literal>aws-creds</literal> for AWS or <literal>gcp-credentials</literal> for GCP.</simpara>
<simpara>This command displays the value of the <literal>.metadata.annotations</literal> parameter in the cluster root secret object. The following output values are possible:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Mint</literal>: The CCO is operating in mint mode.</simpara>
</listitem>
<listitem>
<simpara><literal>Passthrough</literal>: The CCO is operating in passthrough mode.</simpara>
</listitem>
</itemizedlist>
<simpara>If your cluster uses mint mode, you can also determine whether the cluster is operating without the root secret.</simpara>
</listitem>
<listitem>
<simpara>AWS or GCP clusters that use mint mode only: To determine whether the cluster is operating without the root secret, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get secret &lt;secret_name&gt; \
  -n=kube-system</programlisting>
<simpara>where <literal>&lt;secret_name&gt;</literal> is <literal>aws-creds</literal> for AWS or <literal>gcp-credentials</literal> for GCP.</simpara>
<simpara>If the root secret is present, the output of this command returns information about the secret. An error indicates that the root secret is not present on the cluster.</simpara>
</listitem>
<listitem>
<simpara>AWS, GCP, or global Microsoft Azure clusters that use manual mode only: To determine whether the cluster is configured to create and manage cloud credentials from outside of the cluster, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get authentication cluster \
  -o jsonpath \
  --template='{ .spec.serviceAccountIssuer }'</programlisting>
<simpara>This command displays the value of the <literal>.spec.serviceAccountIssuer</literal> parameter in the cluster <literal>Authentication</literal> object.</simpara>
<itemizedlist>
<listitem>
<simpara>An output of a URL that is associated with your cloud provider indicates that the CCO is using manual mode with short-term credentials for components. These clusters are configured using the <literal>ccoctl</literal> utility to create and manage cloud credentials from outside of the cluster.</simpara>
</listitem>
<listitem>
<simpara>An empty output indicates that the cluster is using the CCO in manual mode but was not configured using the <literal>ccoctl</literal> utility.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="about-cloud-credential-operator-default_about-cloud-credential-operator">
<title>Default behavior</title>
<simpara>For platforms on which multiple modes are supported (AWS, Azure, and GCP), when the CCO operates in its default mode, it checks the provided credentials dynamically to determine for which mode they are sufficient to process <literal>CredentialsRequest</literal> CRs.</simpara>
<simpara>By default, the CCO determines whether the credentials are sufficient for mint mode, which is the preferred mode of operation, and uses those credentials to create appropriate credentials for components in the cluster. If the credentials are not sufficient for mint mode, it determines whether they are sufficient for passthrough mode. If the credentials are not sufficient for passthrough mode, the CCO cannot adequately process <literal>CredentialsRequest</literal> CRs.</simpara>
<simpara>If the provided credentials are determined to be insufficient during installation, the installation fails. For AWS, the installation program fails early in the process and indicates which required permissions are missing. Other providers might not provide specific information about the cause of the error until errors are encountered.</simpara>
<simpara>If the credentials are changed after a successful installation and the CCO determines that the new credentials are insufficient, the CCO puts conditions on any new <literal>CredentialsRequest</literal> CRs to indicate that it cannot process them because of the insufficient credentials.</simpara>
<simpara>To resolve insufficient credentials issues, provide a credential with sufficient permissions. If an error occurred during installation, try installing again. For issues with new <literal>CredentialsRequest</literal> CRs, wait for the CCO to try to process the CR again. As an alternative, you can configure your cluster to use a different CCO mode that is supported for your cloud provider.</simpara>
</section>
<section xml:id="additional-resources_about-cloud-credential-operator_about-cloud-credential-operator" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../operators/operator-reference.xml#cloud-credential-operator_cluster-operators-ref">Cluster Operators reference page for the Cloud Credential Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-mode-mint">
<title>The Cloud Credential Operator in mint mode</title>

<simpara>Mint mode is the default Cloud Credential Operator (CCO) credentials mode for OpenShift Container Platform on platforms that support it. Mint mode supports Amazon Web Services (AWS) and Google Cloud Platform (GCP) clusters.</simpara>
<section xml:id="mint-mode-about">
<title>Mint mode credentials management</title>
<simpara>For clusters that use the CCO in mint mode, the administrator-level credential is stored in the <literal>kube-system</literal> namespace. The CCO uses the <literal>admin</literal> credential to process the <literal>CredentialsRequest</literal> objects in the cluster and create users for components with limited permissions.</simpara>
<simpara>With mint mode, each cluster component has only the specific permissions it requires. The automatic, continuous reconciliation of cloud credentials in mint mode allows actions that require additional credentials or permissions, such as upgrading, to proceed.</simpara>
<note>
<simpara>By default, mint mode requires storing the <literal>admin</literal> credential in the cluster <literal>kube-system</literal> namespace. If this approach does not meet the security requirements of your organization, you can <link xlink:href="../../post_installation_configuration/cluster-tasks.xml#manually-removing-cloud-creds_post-install-cluster-tasks">remove the credential after installing the cluster</link>.</simpara>
</note>
<section xml:id="mint-mode-permissions">
<title>Mint mode permissions requirements</title>
<simpara>When using the CCO in mint mode, ensure that the credential you provide meets the requirements of the cloud on which you are running or installing OpenShift Container Platform. If the provided credentials are not sufficient for mint mode, the CCO cannot create an IAM user.</simpara>
<simpara>The credential you provide for mint mode in Amazon Web Services (AWS) must have the following permissions:</simpara>
<example>
<title>Required AWS permissions</title>
<itemizedlist>
<listitem>
<simpara><literal>iam:CreateAccessKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:CreateUser</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:DeleteAccessKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:DeleteUser</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:DeleteUserPolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:GetUser</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:GetUserPolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:ListAccessKeys</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:PutUserPolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:TagUser</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:SimulatePrincipalPolicy</literal></simpara>
</listitem>
</itemizedlist>
</example>
<simpara>The credential you provide for mint mode in Google Cloud Platform (GCP) must have the following permissions:</simpara>
<example>
<title>Required GCP permissions</title>
<itemizedlist>
<listitem>
<simpara><literal>resourcemanager.projects.get</literal></simpara>
</listitem>
<listitem>
<simpara><literal>serviceusage.services.list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccountKeys.create</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccountKeys.delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccountKeys.list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccounts.create</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccounts.delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.serviceAccounts.get</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.roles.create</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.roles.get</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.roles.list</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.roles.undelete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam.roles.update</literal></simpara>
</listitem>
<listitem>
<simpara><literal>resourcemanager.projects.getIamPolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>resourcemanager.projects.setIamPolicy</literal></simpara>
</listitem>
</itemizedlist>
</example>
</section>
<section xml:id="admin-credentials-root-secret-formats_cco-mode-mint">
<title>Admin credentials root secret format</title>
<simpara>Each cloud provider uses a credentials root secret in the <literal>kube-system</literal>
namespace by convention, which is then used to satisfy all credentials requests
and create their respective secrets.
This is done either by minting new credentials with <emphasis>mint mode</emphasis>, or by copying the credentials root secret with <emphasis>passthrough mode</emphasis>.</simpara>
<simpara>The format for the secret varies by cloud, and is also used for each
<literal>CredentialsRequest</literal> secret.</simpara>
<formalpara>
<title>Amazon Web Services (AWS) secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: aws-creds
stringData:
  aws_access_key_id: &lt;base64-encoded_access_key_id&gt;
  aws_secret_access_key: &lt;base64-encoded_secret_access_key&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Google Cloud Platform (GCP) secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: gcp-credentials
stringData:
  service_account.json: &lt;base64-encoded_service_account&gt;</programlisting>
</para>
</formalpara>
</section>
</section>
<section xml:id="manually-rotating-cloud-creds_cco-mode-mint">
<title>Maintaining cloud provider credentials</title>
<simpara>If your cloud provider credentials are changed for any reason, you must manually update the secret that the Cloud Credential Operator (CCO) uses to manage cloud provider credentials.</simpara>
<simpara>The process for rotating cloud credentials depends on the mode that the CCO is configured to use. After you rotate credentials for a cluster that is using mint mode, you must manually remove the component credentials that were created by the removed credential.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster is installed on a platform that supports rotating cloud credentials manually with the CCO mode that you are using:</simpara>
<itemizedlist>
<listitem>
<simpara>For mint mode, Amazon Web Services (AWS) and Google Cloud Platform (GCP) are supported.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>You have changed the credentials that are used to interface with your cloud provider.</simpara>
</listitem>
<listitem>
<simpara>The new credentials have sufficient permissions for the mode CCO is configured to use in your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the table on the <emphasis role="strong">Secrets</emphasis> page, find the root secret for your cloud provider.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Secret name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AWS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-creds</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gcp-credentials</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Options</emphasis> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> in the same row as the secret and select <emphasis role="strong">Edit Secret</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Record the contents of the <emphasis role="strong">Value</emphasis> field or fields. You can use this information to verify that the value is different after updating the credentials.</simpara>
</listitem>
<listitem>
<simpara>Update the text in the <emphasis role="strong">Value</emphasis> field or fields with the new authentication information for your cloud provider, and then click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Delete each component secret that is referenced by the individual <literal>CredentialsRequest</literal> objects.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role.</simpara>
</listitem>
<listitem>
<simpara>Get the names and namespaces of all referenced component secrets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-cloud-credential-operator get CredentialsRequest \
  -o json | jq -r '.items[] | select (.spec.providerSpec.kind=="&lt;provider_spec&gt;") | .spec.secretRef'</programlisting>
<simpara>where <literal>&lt;provider_spec&gt;</literal> is the corresponding value for your cloud provider:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS: <literal>AWSProviderSpec</literal></simpara>
</listitem>
<listitem>
<simpara>GCP: <literal>GCPProviderSpec</literal></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Partial example output for AWS</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
  "name": "ebs-cloud-credentials",
  "namespace": "openshift-cluster-csi-drivers"
}
{
  "name": "cloud-credential-operator-iam-ro-creds",
  "namespace": "openshift-cloud-credential-operator"
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Delete each of the referenced component secrets:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret &lt;secret_name&gt; \<co xml:id="CO64-1"/>
  -n &lt;secret_namespace&gt; <co xml:id="CO64-2"/></programlisting>
<calloutlist>
<callout arearefs="CO64-1">
<para>Specify the name of a secret.</para>
</callout>
<callout arearefs="CO64-2">
<para>Specify the namespace that contains the secret.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example deletion of an AWS secret</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete secret ebs-cloud-credentials -n openshift-cluster-csi-drivers</programlisting>
</para>
</formalpara>
<simpara>You do not need to manually delete the credentials from your provider console. Deleting the referenced component secrets will cause the CCO to delete the existing credentials from the platform and create new ones.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the credentials have changed:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify that the contents of the <emphasis role="strong">Value</emphasis> field or fields have changed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional_resources_2" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../post_installation_configuration/cluster-tasks.xml#manually-removing-cloud-creds_post-install-cluster-tasks">Removing cloud provider credentials</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-mode-passthrough">
<title>The Cloud Credential Operator in passthrough mode</title>

<simpara>Passthrough mode is supported for Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP), Red Hat OpenStack Platform (RHOSP), and VMware vSphere.</simpara>
<simpara>In passthrough mode, the Cloud Credential Operator (CCO) passes the provided cloud credential to the components that request cloud credentials. The credential must have permissions to perform the installation and complete the operations that are required by components in the cluster, but does not need to be able to create new credentials. The CCO does not attempt to create additional limited-scoped credentials in passthrough mode.</simpara>
<note>
<simpara><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-mode-manual.xml#cco-mode-manual">Manual mode</link> is the only supported CCO configuration for Microsoft Azure Stack Hub.</simpara>
</note>
<section xml:id="passthrough-mode-permissions">
<title>Passthrough mode permissions requirements</title>
<simpara>When using the CCO in passthrough mode, ensure that the credential you provide meets the requirements of the cloud on which you are running or installing OpenShift Container Platform. If the provided credentials the CCO passes to a component that creates a <literal>CredentialsRequest</literal> CR are not sufficient, that component will report an error when it tries to call an API that it does not have permissions for.</simpara>
<section xml:id="passthrough-mode-permissions-aws">
<title>Amazon Web Services (AWS) permissions</title>
<simpara>The credential you provide for passthrough mode in AWS must have all the requested permissions for all <literal>CredentialsRequest</literal> CRs that are required by the version of OpenShift Container Platform you are running or installing.</simpara>
<simpara>To locate the <literal>CredentialsRequest</literal> CRs that are required, see <link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">Manually creating long-term credentials for AWS</link>.</simpara>
</section>
<section xml:id="passthrough-mode-permissions-azure">
<title>Microsoft Azure permissions</title>
<simpara>The credential you provide for passthrough mode in Azure must have all the requested permissions for all <literal>CredentialsRequest</literal> CRs that are required by the version of OpenShift Container Platform you are running or installing.</simpara>
<simpara>To locate the <literal>CredentialsRequest</literal> CRs that are required, see <link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Manually creating long-term credentials for Azure</link>.</simpara>
</section>
<section xml:id="passthrough-mode-permissions-gcp">
<title>Google Cloud Platform (GCP) permissions</title>
<simpara>The credential you provide for passthrough mode in GCP must have all the requested permissions for all <literal>CredentialsRequest</literal> CRs that are required by the version of OpenShift Container Platform you are running or installing.</simpara>
<simpara>To locate the <literal>CredentialsRequest</literal> CRs that are required, see <link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">Manually creating long-term credentials for GCP</link>.</simpara>
</section>
<section xml:id="passthrough-mode-permissions-rhosp">
<title>Red Hat OpenStack Platform (RHOSP) permissions</title>
<simpara>To install an OpenShift Container Platform cluster on RHOSP, the CCO requires a credential with the permissions of a <literal>member</literal> user role.</simpara>
</section>
<section xml:id="passthrough-mode-permissions-vsware">
<title>VMware vSphere permissions</title>
<simpara>To install an OpenShift Container Platform cluster on VMware vSphere, the CCO requires a credential with the following vSphere privileges:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Required vSphere privileges</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Category</entry>
<entry align="left" valign="top">Privileges</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Datastore</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Allocate space</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Folder</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Create folder</emphasis>, <emphasis>Delete folder</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vSphere Tagging</simpara></entry>
<entry align="left" valign="top"><simpara>All privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Network</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Assign network</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Resource</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>Assign virtual machine to resource pool</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Profile-driven storage</simpara></entry>
<entry align="left" valign="top"><simpara>All privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>vApp</simpara></entry>
<entry align="left" valign="top"><simpara>All privileges</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Virtual machine</simpara></entry>
<entry align="left" valign="top"><simpara>All privileges</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="admin-credentials-root-secret-formats_cco-mode-passthrough">
<title>Admin credentials root secret format</title>
<simpara>Each cloud provider uses a credentials root secret in the <literal>kube-system</literal>
namespace by convention, which is then used to satisfy all credentials requests
and create their respective secrets.
This is done either by minting new credentials with <emphasis>mint mode</emphasis>, or by copying the credentials root secret with <emphasis>passthrough mode</emphasis>.</simpara>
<simpara>The format for the secret varies by cloud, and is also used for each
<literal>CredentialsRequest</literal> secret.</simpara>
<formalpara>
<title>Amazon Web Services (AWS) secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: aws-creds
stringData:
  aws_access_key_id: &lt;base64-encoded_access_key_id&gt;
  aws_secret_access_key: &lt;base64-encoded_secret_access_key&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Microsoft Azure secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: azure-credentials
stringData:
  azure_subscription_id: &lt;base64-encoded_subscription_id&gt;
  azure_client_id: &lt;base64-encoded_client_id&gt;
  azure_client_secret: &lt;base64-encoded_client_secret&gt;
  azure_tenant_id: &lt;base64-encoded_tenant_id&gt;
  azure_resource_prefix: &lt;base64-encoded_resource_prefix&gt;
  azure_resourcegroup: &lt;base64-encoded_resource_group&gt;
  azure_region: &lt;base64-encoded_region&gt;</programlisting>
</para>
</formalpara>
<simpara>On Microsoft Azure, the credentials secret format includes two properties that must contain the cluster&#8217;s infrastructure ID, generated randomly for each cluster installation. This value can be found after running create manifests:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat .openshift_install_state.json | jq '."*installconfig.ClusterID".InfraID' -r</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">mycluster-2mpcn</programlisting>
</para>
</formalpara>
<simpara>This value would be used in the secret data as follows:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">azure_resource_prefix: mycluster-2mpcn
azure_resourcegroup: mycluster-2mpcn-rg</programlisting>
<formalpara>
<title>Google Cloud Platform (GCP) secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: gcp-credentials
stringData:
  service_account.json: &lt;base64-encoded_service_account&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>Red Hat OpenStack Platform (RHOSP) secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: openstack-credentials
data:
  clouds.yaml: &lt;base64-encoded_cloud_creds&gt;
  clouds.conf: &lt;base64-encoded_cloud_creds_init&gt;</programlisting>
</para>
</formalpara>
<formalpara>
<title>VMware vSphere secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: kube-system
  name: vsphere-creds
data:
 vsphere.openshift.example.com.username: &lt;base64-encoded_username&gt;
 vsphere.openshift.example.com.password: &lt;base64-encoded_password&gt;</programlisting>
</para>
</formalpara>
</section>
<section xml:id="passthrough-mode-maintenance">
<title>Passthrough mode credential maintenance</title>
<simpara>If <literal>CredentialsRequest</literal> CRs change over time as the cluster is upgraded, you must manually update the passthrough mode credential to meet the requirements. To avoid credentials issues during an upgrade, check the <literal>CredentialsRequest</literal> CRs in the release image for the new version of OpenShift Container Platform before upgrading. To locate the <literal>CredentialsRequest</literal> CRs that are required for your cloud provider, see <emphasis>Manually creating long-term credentials</emphasis> for <link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">AWS</link>, <link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Azure</link>, or <link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">GCP</link>.</simpara>
<section xml:id="manually-rotating-cloud-creds_cco-mode-passthrough">
<title>Maintaining cloud provider credentials</title>
<simpara>If your cloud provider credentials are changed for any reason, you must manually update the secret that the Cloud Credential Operator (CCO) uses to manage cloud provider credentials.</simpara>
<simpara>The process for rotating cloud credentials depends on the mode that the CCO is configured to use. After you rotate credentials for a cluster that is using mint mode, you must manually remove the component credentials that were created by the removed credential.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Your cluster is installed on a platform that supports rotating cloud credentials manually with the CCO mode that you are using:</simpara>
<itemizedlist>
<listitem>
<simpara>For passthrough mode, Amazon Web Services (AWS), Microsoft Azure, Google Cloud Platform (GCP), Red Hat OpenStack Platform (RHOSP), and VMware vSphere are supported.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>You have changed the credentials that are used to interface with your cloud provider.</simpara>
</listitem>
<listitem>
<simpara>The new credentials have sufficient permissions for the mode CCO is configured to use in your cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the table on the <emphasis role="strong">Secrets</emphasis> page, find the root secret for your cloud provider.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Secret name</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AWS</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-creds</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure</simpara></entry>
<entry align="left" valign="top"><simpara><literal>azure-credentials</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>gcp-credentials</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RHOSP</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openstack-credentials</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VMware vSphere</simpara></entry>
<entry align="left" valign="top"><simpara><literal>vsphere-creds</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Options</emphasis> menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> in the same row as the secret and select <emphasis role="strong">Edit Secret</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Record the contents of the <emphasis role="strong">Value</emphasis> field or fields. You can use this information to verify that the value is different after updating the credentials.</simpara>
</listitem>
<listitem>
<simpara>Update the text in the <emphasis role="strong">Value</emphasis> field or fields with the new authentication information for your cloud provider, and then click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>If you are updating the credentials for a vSphere cluster that does not have the vSphere CSI Driver Operator enabled, you must force a rollout of the Kubernetes controller manager to apply the updated credentials.</simpara>
<note>
<simpara>If the vSphere CSI Driver Operator is enabled, this step is not required.</simpara>
</note>
<simpara>To apply the updated vSphere credentials, log in to the OpenShift Container Platform CLI as a user with the <literal>cluster-admin</literal> role and run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch kubecontrollermanager cluster \
  -p='{"spec": {"forceRedeploymentReason": "recovery-'"$( date )"'"}}' \
  --type=merge</programlisting>
<simpara>While the credentials are rolling out, the status of the Kubernetes Controller Manager Operator reports <literal>Progressing=true</literal>. To view the status, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get co kube-controller-manager</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>To verify that the credentials have changed:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the <emphasis role="strong">Administrator</emphasis> perspective of the web console, navigate to <emphasis role="strong">Workloads</emphasis> &#8594; <emphasis role="strong">Secrets</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Verify that the contents of the <emphasis role="strong">Value</emphasis> field or fields have changed.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../storage/container_storage_interface/persistent-storage-csi-vsphere.xml">vSphere CSI Driver Operator</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="passthrough-mode-reduce-permissions">
<title>Reducing permissions after installation</title>
<simpara>When using passthrough mode, each component has the same permissions used by all other components. If you do not reduce the permissions after installing, all components have the broad permissions that are required to run the installer.</simpara>
<simpara>After installation, you can reduce the permissions on your credential to only those that are required to run the cluster, as defined by the <literal>CredentialsRequest</literal> CRs in the release image for the version of OpenShift Container Platform that you are using.</simpara>
<simpara>To locate the <literal>CredentialsRequest</literal> CRs that are required for AWS, Azure, or GCP and learn how to change the permissions the CCO uses, see <emphasis>Manually creating long-term credentials</emphasis> for <link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">AWS</link>, <link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Azure</link>, or <link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">GCP</link>.</simpara>
</section>
<section xml:id="_additional_resources_3" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">Manually creating long-term credentials for AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Manually creating long-term credentials for Azure</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">Manually creating long-term credentials for GCP</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-mode-manual">
<title>Manual mode with long-term credentials for components</title>

<simpara>Manual mode is supported for Alibaba Cloud, Amazon Web Services (AWS), global Microsoft Azure, Microsoft Azure Stack Hub, Google Cloud Platform (GCP), IBM Cloud&#174;, and Nutanix.</simpara>
<section xml:id="manual-mode-classic_cco-mode-manual">
<title>User-managed credentials</title>
<simpara>In manual mode, a user manages cloud credentials instead of the Cloud Credential Operator (CCO). To use this mode, you must examine the <literal>CredentialsRequest</literal> CRs in the release image for the version of OpenShift Container Platform that you are running or installing, create corresponding credentials in the underlying cloud provider, and create Kubernetes Secrets in the correct namespaces to satisfy all <literal>CredentialsRequest</literal> CRs for the cluster&#8217;s cloud provider. Some platforms use the CCO utility (<literal>ccoctl</literal>) to facilitate this process during installation and updates.</simpara>
<simpara>Using manual mode with long-term credentials allows each cluster component to have only the permissions it requires, without storing an administrator-level credential in the cluster. This mode also does not require connectivity to services such as the AWS public IAM endpoint. However, you must manually reconcile permissions with new release images for every upgrade.</simpara>
<simpara>For information about configuring your cloud provider to use manual mode, see the manual credentials management options for your cloud provider.</simpara>
<note>
<simpara>An AWS, global Azure, or GCP cluster that uses manual mode might be configured to use short-term credentials for different components. For more information, see <link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-short-term-creds.xml#cco-short-term-creds">Manual mode with short-term credentials for components</link>.</simpara>
</note>
</section>
<section xml:id="additional-resources_cco-mode-manual" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_alibaba/manually-creating-alibaba-ram.xml#manually-creating-alibaba-ram">Manually creating RAM resources for Alibaba Cloud</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#manually-create-iam_installing-aws-customizations">Manually creating long-term credentials for AWS</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#manually-create-iam_installing-azure-customizations">Manually creating long-term credentials for Azure</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#manually-create-iam_installing-gcp-customizations">Manually creating long-term credentials for GCP</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_ibm_cloud_public/configuring-iam-ibm-cloud.xml#configuring-iam-ibm-cloud">Configuring IAM for IBM Cloud&#174;</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_nutanix/installing-nutanix-installer-provisioned.xml#manually-create-iam-nutanix_installing-nutanix-installer-provisioned">Configuring IAM for Nutanix</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../authentication/managing_cloud_provider_credentials/cco-short-term-creds.xml#cco-short-term-creds">Manual mode with short-term credentials for components</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#preparing-manual-creds-update">Preparing to update a cluster with manually maintained credentials</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-short-term-creds">
<title>Manual mode with short-term credentials for components</title>

<simpara>During installation, you can configure the Cloud Credential Operator (CCO) to operate in manual mode and use the CCO utility (<literal>ccoctl</literal>) to implement short-term security credentials for individual components that are created and managed outside the OpenShift Container Platform cluster.</simpara>
<note>
<simpara>This credentials strategy is supported for Amazon Web Services (AWS), Google Cloud Platform (GCP), and global Microsoft Azure only. The strategy must be configured during installation of a new OpenShift Container Platform cluster. You cannot configure an existing cluster that uses a different credentials strategy to use this feature.</simpara>
</note>
<simpara>Cloud providers use different terms for their implementation of this authentication method.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Short-term credentials provider terminology</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Cloud provider</entry>
<entry align="left" valign="top">Provider nomenclature</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Amazon Web Services (AWS)</simpara></entry>
<entry align="left" valign="top"><simpara>AWS Security Token Service (STS)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Google Cloud Platform (GCP)</simpara></entry>
<entry align="left" valign="top"><simpara>GCP Workload Identity</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Global Microsoft Azure</simpara></entry>
<entry align="left" valign="top"><simpara>Azure AD Workload Identity</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="cco-short-term-creds-aws_cco-short-term-creds">
<title>AWS Security Token Service</title>
<simpara>In manual mode with STS, the individual OpenShift Container Platform cluster components use the AWS Security Token Service (STS) to assign components IAM roles that provide short-term, limited-privilege security credentials. These credentials are associated with IAM roles that are specific to each component that makes AWS API calls.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#installing-aws-with-short-term-creds_installing-aws-customizations">Configuring an AWS cluster to use short-term credentials</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="cco-short-term-creds-auth-flow-aws_cco-short-term-creds">
<title>AWS Security Token Service authentication process</title>
<simpara>The AWS Security Token Service (STS) and the <link xlink:href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html"><literal>AssumeRole</literal></link> API action allow pods to retrieve access keys that are defined by an IAM role policy.</simpara>
<simpara>The OpenShift Container Platform cluster includes a Kubernetes service account signing service. This service uses a private key to sign service account JSON web tokens (JWT). A pod that requires a service account token requests one through the pod specification. When the pod is created and assigned to a node, the node retrieves a signed service account from the service account signing service and mounts it onto the pod.</simpara>
<simpara>Clusters that use STS contain an IAM role ID in their Kubernetes configuration secrets. Workloads assume the identity of this IAM role ID. The signed service account token issued to the workload aligns with the configuration in AWS, which allows AWS STS to grant access keys for the specified IAM role to the workload.</simpara>
<simpara>AWS STS grants access keys only for requests that include service account tokens that meet the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>The token name and namespace match the service account name and namespace.</simpara>
</listitem>
<listitem>
<simpara>The token is signed by a key that matches the public key.</simpara>
</listitem>
</itemizedlist>
<simpara>The public key pair for the service account signing key used by the cluster is stored in an AWS S3 bucket. AWS STS federation validates that the service account token signature aligns with the public key stored in the S3 bucket.</simpara>
<section xml:id="cco-short-term-creds-auth-flow-aws-diagram_cco-short-term-creds">
<title>Authentication flow for AWS STS</title>
<simpara>The following diagram illustrates the authentication flow between AWS and the OpenShift Container Platform cluster when using AWS STS.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Token signing</emphasis> is the Kubernetes service account signing service on the OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Kubernetes service account</emphasis> in the pod is the signed service account token.</simpara>
</listitem>
</itemizedlist>
<figure>
<title>AWS Security Token Service authentication flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/347_OpenShift_credentials_with_STS_updates_0623_AWS.png"/>
</imageobject>
<textobject><phrase>Detailed authentication flow between AWS and the cluster when using AWS STS</phrase></textobject>
</mediaobject>
</figure>
<simpara>Requests for new and refreshed credentials are automated by using an appropriately configured AWS IAM OpenID Connect (OIDC) identity provider combined with AWS IAM roles. Service account tokens that are trusted by AWS IAM are signed by OpenShift Container Platform and can be projected into a pod and used for authentication.</simpara>
</section>
<section xml:id="cco-short-term-creds-auth-flow-aws-refresh-policy_cco-short-term-creds">
<title>Token refreshing for AWS STS</title>
<simpara>The signed service account token that a pod uses expires after a period of time. For clusters that use AWS STS, this time period is 3600 seconds, or one hour.</simpara>
<simpara>The kubelet on the node that the pod is assigned to ensures that the token is refreshed. The kubelet attempts to rotate a token when it is older than 80 percent of its time to live.</simpara>
</section>
<section xml:id="cco-short-term-creds-auth-flow-aws-oidc_cco-short-term-creds">
<title>OpenID Connect requirements for AWS STS</title>
<simpara>You can store the public portion of the encryption keys for your OIDC configuration in a public or private S3 bucket.</simpara>
<simpara>The OIDC spec requires the use of HTTPS. AWS services require a public endpoint to expose the OIDC documents in the form of JSON web key set (JWKS) public keys. This allows AWS services to validate the bound tokens signed by Kubernetes and determine whether to trust certificates. As a result, both S3 bucket options require a public HTTPS endpoint and private endpoints are not supported.</simpara>
<simpara>To use AWS STS, the public AWS backbone for the AWS STS service must be able to communicate with a public S3 bucket or a private S3 bucket with a public CloudFront endpoint. You can choose which type of bucket to use when you process <literal>CredentialsRequest</literal> objects during installation:</simpara>
<itemizedlist>
<listitem>
<simpara>By default, the CCO utility (<literal>ccoctl</literal>) stores the OIDC configuration files in a public S3 bucket and uses the S3 URL as the public OIDC endpoint.</simpara>
</listitem>
<listitem>
<simpara>As an alternative, you can have the <literal>ccoctl</literal> utility store the OIDC configuration in a private S3 bucket that is accessed by the IAM identity provider through a public CloudFront distribution URL.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-short-term-creds-format-aws_cco-short-term-creds">
<title>AWS component secret formats</title>
<simpara>Using manual mode with the AWS Security Token Service (STS) changes the content of the AWS credentials that are provided to individual OpenShift Container Platform components. Compare the following secret formats:</simpara>
<formalpara>
<title>AWS secret format using long-term credentials</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: &lt;target_namespace&gt; <co xml:id="CO65-1"/>
  name: &lt;target_secret_name&gt; <co xml:id="CO65-2"/>
data:
  aws_access_key_id: &lt;base64_encoded_access_key_id&gt;
  aws_secret_access_key: &lt;base64_encoded_secret_access_key&gt;</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO65-1">
<para>The namespace for the component.</para>
</callout>
<callout arearefs="CO65-2">
<para>The name of the component secret.</para>
</callout>
</calloutlist>
<formalpara>
<title>AWS secret format using AWS STS</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: &lt;target_namespace&gt; <co xml:id="CO66-1"/>
  name: &lt;target_secret_name&gt; <co xml:id="CO66-2"/>
stringData:
  credentials: |-
    [default]
    sts_regional_endpoints = regional
    role_name: &lt;operator_role_name&gt; <co xml:id="CO66-3"/>
    web_identity_token_file: &lt;path_to_token&gt; <co xml:id="CO66-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO66-1">
<para>The namespace for the component.</para>
</callout>
<callout arearefs="CO66-2">
<para>The name of the component secret.</para>
</callout>
<callout arearefs="CO66-3">
<para>The IAM role for the component.</para>
</callout>
<callout arearefs="CO66-4">
<para>The path to the service account token inside the pod. By convention, this is <literal>/var/run/secrets/openshift/serviceaccount/token</literal> for OpenShift Container Platform components.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cco-short-term-creds-component-permissions-aws_cco-short-term-creds">
<title>AWS component secret permissions requirements</title>
<simpara>OpenShift Container Platform components require the following permissions. These values are in the <literal>CredentialsRequest</literal> custom resource (CR) for each component.</simpara>
<note>
<simpara>These permissions apply to all resources. Unless specified, there are no request conditions on these permissions.</simpara>
</note>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Custom resource</entry>
<entry align="left" valign="top">Required permissions for services</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Cluster CAPI Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-cluster-api-aws</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">EC2</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>ec2:CreateTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeAvailabilityZones</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeDhcpOptions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeImages</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInternetGateways</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSecurityGroups</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSubnets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeVpcs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeNetworkInterfaces</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeNetworkInterfaceAttribute</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:ModifyNetworkInterfaceAttribute</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:RunInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:TerminateInstances</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Elastic load balancing</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeLoadBalancers</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeTargetGroups</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeTargetHealth</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:RegisterInstancesWithLoadBalancer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:RegisterTargets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DeregisterTargets</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Identity and Access Management (IAM)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>iam:PassRole</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:CreateServiceLinkedRole</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Key Management Service (KMS)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>kms:Decrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:Encrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKeyWithoutPlainText</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:DescribeKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:RevokeGrant</literal><superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:CreateGrant</literal> <superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:ListGrants</literal> <superscript>[1]</superscript></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Machine API Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-machine-api-aws</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">EC2</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>ec2:CreateTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeAvailabilityZones</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeDhcpOptions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeImages</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstanceTypes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInternetGateways</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSecurityGroups</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeRegions</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSubnets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeVpcs</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:RunInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:TerminateInstances</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Elastic load balancing</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeLoadBalancers</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeTargetGroups</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeTargetHealth</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:RegisterInstancesWithLoadBalancer</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:RegisterTargets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>elasticloadbalancing:DeregisterTargets</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Identity and Access Management (IAM)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>iam:PassRole</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:CreateServiceLinkedRole</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Key Management Service (KMS)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>kms:Decrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:Encrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKeyWithoutPlainText</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:DescribeKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:RevokeGrant</literal><superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:CreateGrant</literal> <superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:ListGrants</literal> <superscript>[1]</superscript></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cloud Credential Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>cloud-credential-operator-iam-ro</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Identity and Access Management (IAM)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>iam:GetUser</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:GetUserPolicy</literal></simpara>
</listitem>
<listitem>
<simpara><literal>iam:ListAccessKeys</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster Image Registry Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-image-registry</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">S3</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>s3:CreateBucket</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:DeleteBucket</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:PutBucketTagging</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetBucketTagging</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:PutBucketPublicAccessBlock</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetBucketPublicAccessBlock</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:PutEncryptionConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetEncryptionConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:PutLifecycleConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetLifecycleConfiguration</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetBucketLocation</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:ListBucket</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:GetObject</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:PutObject</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:DeleteObject</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:ListBucketMultipartUploads</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:AbortMultipartUpload</literal></simpara>
</listitem>
<listitem>
<simpara><literal>s3:ListMultipartUploadParts</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ingress Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-ingress</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Elastic load balancing</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>elasticloadbalancing:DescribeLoadBalancers</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Route 53</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>route53:ListHostedZones</literal></simpara>
</listitem>
<listitem>
<simpara><literal>route53:ListTagsForResources</literal></simpara>
</listitem>
<listitem>
<simpara><literal>route53:ChangeResourceRecordSets</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Tag</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>tag:GetResources</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Security Token Service (STS)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>sts:AssumeRole</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster Network Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-cloud-network-config-controller-aws</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">EC2</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>ec2:DescribeInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstanceStatus</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstanceTypes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:UnassignPrivateIpAddresses</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:AssignPrivateIpAddresses</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:UnassignIpv6Addresses</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:AssignIpv6Addresses</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSubnets</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeNetworkInterfaces</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AWS Elastic Block Store CSI Driver Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>aws-ebs-csi-driver-operator</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">EC2</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>ec2:AttachVolume</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:CreateSnapshot</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:CreateTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:CreateVolume</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DeleteSnapshot</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DeleteTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DeleteVolume</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeInstances</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeSnapshots</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeTags</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeVolumes</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeVolumesModifications</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DetachVolume</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:ModifyVolume</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:DescribeAvailabilityZones</literal></simpara>
</listitem>
<listitem>
<simpara><literal>ec2:EnableFastSnapshotRestores</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Key Management Service (KMS)</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>kms:ReEncrypt*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:Decrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:Encrypt</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:GenerateDataKeyWithoutPlainText</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:DescribeKey</literal></simpara>
</listitem>
<listitem>
<simpara><literal>kms:RevokeGrant</literal><superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:CreateGrant</literal> <superscript>[1]</superscript></simpara>
</listitem>
<listitem>
<simpara><literal>kms:ListGrants</literal> <superscript>[1]</superscript></simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Request condition: <literal>kms:GrantIsForAWSResource: true</literal></simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="cco-short-term-creds-aws-olm_cco-short-term-creds">
<title>OLM-managed Operator support for authentication with AWS STS</title>
<simpara>In addition to OpenShift Container Platform cluster components, some Operators managed by the Operator Lifecycle Manager (OLM) on AWS clusters can use manual mode with STS. These Operators authenticate with limited-privilege, short-term credentials that are managed outside the cluster. To determine if an Operator supports authentication with AWS STS, see the Operator description in OperatorHub.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../operators/operator_sdk/osdk-token-auth.xml#osdk-cco-aws-sts_osdk-token-auth">CCO-based workflow for OLM-managed Operators with AWS STS</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="cco-short-term-creds-gcp_cco-short-term-creds">
<title>GCP Workload Identity</title>
<simpara>In manual mode with GCP Workload Identity, the individual OpenShift Container Platform cluster components use the GCP workload identity provider to allow components to impersonate GCP service accounts using short-term, limited-privilege credentials.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#installing-gcp-with-short-term-creds_installing-gcp-customizations">Configuring a GCP cluster to use short-term credentials</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="cco-short-term-creds-auth-flow-gcp_cco-short-term-creds">
<title>GCP Workload Identity authentication process</title>
<simpara>Requests for new and refreshed credentials are automated by using an appropriately configured OpenID Connect (OIDC) identity provider combined with IAM service accounts. Service account tokens that are trusted by GCP are signed by OpenShift Container Platform and can be projected into a pod and used for authentication. Tokens are refreshed after one hour.</simpara>
<simpara>The following diagram details the authentication flow between GCP and the OpenShift Container Platform cluster when using GCP Workload Identity.</simpara>
<figure>
<title>GCP Workload Identity authentication flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/347_OpenShift_credentials_with_STS_updates_0623_GCP.png"/>
</imageobject>
<textobject><phrase>Detailed authentication flow between GCP and the cluster when using GCP Workload Identity</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="cco-short-term-creds-format-gcp_cco-short-term-creds">
<title>GCP component secret formats</title>
<simpara>Using manual mode with GCP Workload Identity changes the content of the GCP credentials that are provided to individual OpenShift Container Platform components. Compare the following secret content:</simpara>
<formalpara>
<title>GCP secret format</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: &lt;target_namespace&gt; <co xml:id="CO67-1"/>
  name: &lt;target_secret_name&gt; <co xml:id="CO67-2"/>
data:
  service_account.json: &lt;service_account&gt; <co xml:id="CO67-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO67-1">
<para>The namespace for the component.</para>
</callout>
<callout arearefs="CO67-2">
<para>The name of the component secret.</para>
</callout>
<callout arearefs="CO67-3">
<para>The Base64 encoded service account.</para>
</callout>
</calloutlist>
<formalpara>
<title>Content of the Base64 encoded <literal>service_account.json</literal> file using long-term credentials</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
   "type": "service_account", <co xml:id="CO68-1"/>
   "project_id": "&lt;project_id&gt;",
   "private_key_id": "&lt;private_key_id&gt;",
   "private_key": "&lt;private_key&gt;", <co xml:id="CO68-2"/>
   "client_email": "&lt;client_email_address&gt;",
   "client_id": "&lt;client_id&gt;",
   "auth_uri": "https://accounts.google.com/o/oauth2/auth",
   "token_uri": "https://oauth2.googleapis.com/token",
   "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
   "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/&lt;client_email_address&gt;"
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO68-1">
<para>The credential type is <literal>service_account</literal>.</para>
</callout>
<callout arearefs="CO68-2">
<para>The private RSA key that is used to authenticate to GCP. This key must be kept secure and is not rotated.</para>
</callout>
</calloutlist>
<formalpara>
<title>Content of the Base64 encoded <literal>service_account.json</literal> file using GCP Workload Identity</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
   "type": "external_account", <co xml:id="CO69-1"/>
   "audience": "//iam.googleapis.com/projects/123456789/locations/global/workloadIdentityPools/test-pool/providers/test-provider", <co xml:id="CO69-2"/>
   "subject_token_type": "urn:ietf:params:oauth:token-type:jwt",
   "token_url": "https://sts.googleapis.com/v1/token",
   "service_account_impersonation_url": "https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/&lt;client_email_address&gt;:generateAccessToken", <co xml:id="CO69-3"/>
   "credential_source": {
      "file": "&lt;path_to_token&gt;", <co xml:id="CO69-4"/>
      "format": {
         "type": "text"
      }
   }
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO69-1">
<para>The credential type is <literal>external_account</literal>.</para>
</callout>
<callout arearefs="CO69-2">
<para>The target audience is the GCP Workload Identity provider.</para>
</callout>
<callout arearefs="CO69-3">
<para>The resource URL of the service account that can be impersonated with these credentials.</para>
</callout>
<callout arearefs="CO69-4">
<para>The path to the service account token inside the pod. By convention, this is <literal>/var/run/secrets/openshift/serviceaccount/token</literal> for OpenShift Container Platform components.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="cco-short-term-creds-azure_cco-short-term-creds">
<title>Azure AD Workload Identity</title>
<simpara>In manual mode with Azure AD Workload Identity, the individual OpenShift Container Platform cluster components use the Azure AD workload identity provider to assign components short-term security credentials.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#installing-azure-with-short-term-creds_installing-azure-customizations">Configuring a global Microsoft Azure cluster to use short-term credentials</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="cco-short-term-creds-auth-flow-azure_cco-short-term-creds">
<title>Azure AD Workload Identity authentication process</title>
<simpara>The following diagram details the authentication flow between Azure and the OpenShift Container Platform cluster when using Azure AD Workload Identity.</simpara>
<figure>
<title>Azure AD Workload Identity authentication flow</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/347_OpenShift_credentials_with_STS_updates_1023_Azure.png"/>
</imageobject>
<textobject><phrase>Detailed authentication flow between Azure and the cluster when using Azure AD Workload Identity</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="cco-short-term-creds-format-azure_cco-short-term-creds">
<title>Azure component secret formats</title>
<simpara>Using manual mode with AD Workload Identity changes the content of the Azure credentials that are provided to individual OpenShift Container Platform components. Compare the following secret formats:</simpara>
<formalpara>
<title>Azure secret format using long-term credentials</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: &lt;target_namespace&gt; <co xml:id="CO70-1"/>
  name: &lt;target_secret_name&gt; <co xml:id="CO70-2"/>
data:
  azure_client_id: &lt;client_id&gt; <co xml:id="CO70-3"/>
  azure_client_secret: &lt;client_secret&gt; <co xml:id="CO70-4"/>
  azure_region: &lt;region&gt;
  azure_resource_prefix: &lt;resource_group_prefix&gt; <co xml:id="CO70-5"/>
  azure_resourcegroup: &lt;resource_group_prefix&gt;-rg <co xml:id="CO70-6"/>
  azure_subscription_id: &lt;subscription_id&gt;
  azure_tenant_id: &lt;tenant_id&gt;
type: Opaque</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO70-1">
<para>The namespace for the component.</para>
</callout>
<callout arearefs="CO70-2">
<para>The name of the component secret.</para>
</callout>
<callout arearefs="CO70-3">
<para>The client ID of the Azure AD identity that the component uses to authenticate.</para>
</callout>
<callout arearefs="CO70-4">
<para>The component secret that is used to authenticate with Azure AD for the <literal>&lt;client_id&gt;</literal> identity.</para>
</callout>
<callout arearefs="CO70-5">
<para>The resource group prefix.</para>
</callout>
<callout arearefs="CO70-6">
<para>The resource group. This value is formed by the <literal>&lt;resource_group_prefix&gt;</literal> and the suffix <literal>-rg</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Azure secret format using AD Workload Identity</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Secret
metadata:
  namespace: &lt;target_namespace&gt; <co xml:id="CO71-1"/>
  name: &lt;target_secret_name&gt; <co xml:id="CO71-2"/>
data:
  azure_client_id: &lt;client_id&gt; <co xml:id="CO71-3"/>
  azure_federated_token_file: &lt;path_to_token_file&gt; <co xml:id="CO71-4"/>
  azure_region: &lt;region&gt;
  azure_subscription_id: &lt;subscription_id&gt;
  azure_tenant_id: &lt;tenant_id&gt;
type: Opaque</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO71-1">
<para>The namespace for the component.</para>
</callout>
<callout arearefs="CO71-2">
<para>The name of the component secret.</para>
</callout>
<callout arearefs="CO71-3">
<para>The client ID of the user-assigned managed identity that the component uses to authenticate.</para>
</callout>
<callout arearefs="CO71-4">
<para>The path to the mounted service account token file.</para>
</callout>
</calloutlist>
</section>
<section xml:id="cco-short-term-creds-component-permissions-azure_cco-short-term-creds">
<title>Azure component secret permissions requirements</title>
<simpara>OpenShift Container Platform components require the following permissions. These values are in the <literal>CredentialsRequest</literal> custom resource (CR) for each component.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Custom resource</entry>
<entry align="left" valign="top">Required permissions for services</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Cloud Controller Manager Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-azure-cloud-controller-manager</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkSecurityGroups/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkSecurityGroups/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/write</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster CAPI Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-cluster-api-azure</literal></simpara></entry>
<entry align="left" valign="top"><simpara>role: <literal>Contributor</literal> <superscript>[1]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Machine API Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-machine-api-azure</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Compute/availabilitySets/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/availabilitySets/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/availabilitySets/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/diskEncryptionSets/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/disks/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/galleries/images/versions/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/skus/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/extensions/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/extensions/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/extensions/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.ManagedIdentity/userAssignedIdentities/assign/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/applicationSecurityGroups/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/backendAddressPools/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/loadBalancers/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkSecurityGroups/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkSecurityGroups/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/publicIPAddresses/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/routeTables/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/subnets/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/subnets/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Resources/subscriptions/resourceGroups/read</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster Image Registry Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-image-registry-azure</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Data permissions</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/blobs/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/blobs/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/blobs/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/blobs/add/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/blobs/move/action</literal></simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">General permissions</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/containers/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/blobServices/generateUserDelegationKey/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/listKeys/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Resources/tags/write</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ingress Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-ingress-azure</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Network/dnsZones/A/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/dnsZones/A/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/privateDnsZones/A/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/privateDnsZones/A/write</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cluster Network Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>openshift-cloud-network-config-controller-azure</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/networkInterfaces/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/subnets/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/loadBalancers/backendAddressPools/join/action</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure File CSI Driver Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>azure-file-csi-driver-operator</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Network/networkSecurityGroups/join/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/subnets/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Network/virtualNetworks/subnets/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/fileServices/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/fileServices/shares/delete</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/fileServices/shares/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/fileServices/shares/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/listKeys/action</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Storage/storageAccounts/write</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure Disk CSI Driver Operator</simpara></entry>
<entry align="left" valign="top"><simpara><literal>azure-disk-csi-driver-operator</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><literal>Microsoft.Compute/disks/*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/snapshots/*</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachineScaleSets/*/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachineScaleSets/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachineScaleSets/virtualMachines/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/*/read</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Compute/virtualMachines/write</literal></simpara>
</listitem>
<listitem>
<simpara><literal>Microsoft.Resources/subscriptions/resourceGroups/read</literal></simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>This component requires a role rather than a set of permissions.</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="cco-short-term-creds-azure-olm_cco-short-term-creds">
<title>OLM-managed Operator support for authentication with Azure AD Workload Identity</title>
<simpara>In addition to OpenShift Container Platform cluster components, some Operators managed by the Operator Lifecycle Manager (OLM) on Azure clusters can use manual mode with Azure AD Workload Identity. These Operators authenticate with short-term credentials that are managed outside the cluster. To determine if an Operator supports authentication with Azure AD Workload Identity, see the Operator description in OperatorHub.</simpara>
</section>
</section>
<section xml:id="additional-resources_cco-short-term-creds" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="../../installing/installing_aws/installing-aws-customizations.xml#installing-aws-with-short-term-creds_installing-aws-customizations">Configuring an AWS cluster to use short-term credentials</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_gcp/installing-gcp-customizations.xml#installing-gcp-with-short-term-creds_installing-gcp-customizations">Configuring a GCP cluster to use short-term credentials</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../installing/installing_azure/installing-azure-customizations.xml#installing-azure-with-short-term-creds_installing-azure-customizations">Configuring a global Microsoft Azure cluster to use short-term credentials</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="../../updating/preparing_for_updates/preparing-manual-creds-update.xml#preparing-manual-creds-update">Preparing to update a cluster with manually maintained credentials</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
</book>