<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info>
<title>Storage</title>
<date>2024-02-23</date>
<title>Storage</title>
<productname>OpenShift Container Platform</productname>
<productnumber>4.14</productnumber>
<subtitle>Enter a short description here.</subtitle>
<abstract>
    <para>A short overview and summary of the book's subject and purpose, traditionally no more than one paragraph long.</para>
</abstract>
<authorgroup>
    <orgname>Red Hat OpenShift Documentation Team</orgname>
</authorgroup>
<xi:include href="Common_Content/Legal_Notice.xml" xmlns:xi="http://www.w3.org/2001/XInclude" />
</info>
<chapter xml:id="storage-overview">
<title>OpenShift Container Platform storage overview</title>

<simpara>OpenShift Container Platform supports multiple types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an OpenShift Container Platform cluster.</simpara>
<section xml:id="openshift-storage-common-terms_storage-overview">
<title>Glossary of common terms for OpenShift Container Platform storage</title>
<simpara>This glossary defines common terms that are used in the storage content.</simpara>
<variablelist>
<varlistentry>
<term>Access modes</term>
<listitem>
<simpara>Volume access modes describe volume capabilities. You can use access modes to match persistent volume claim (PVC) and persistent volume (PV). The following are the examples of access modes:</simpara>
<itemizedlist>
<listitem>
<simpara>ReadWriteOnce (RWO)</simpara>
</listitem>
<listitem>
<simpara>ReadOnlyMany (ROX)</simpara>
</listitem>
<listitem>
<simpara>ReadWriteMany (RWX)</simpara>
</listitem>
<listitem>
<simpara>ReadWriteOncePod (RWOP)</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Cinder</term>
<listitem>
<simpara>The Block Storage service for Red Hat OpenStack Platform (RHOSP) which manages the administration, security, and scheduling of all volumes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Config map</term>
<listitem>
<simpara>A config map provides a way to inject configuration data into pods. You can reference the data stored in a config map in a volume of type <literal>ConfigMap</literal>. Applications running in a pod can use this data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Container Storage Interface (CSI)</term>
<listitem>
<simpara>An API specification for the management of container storage across different container orchestration (CO) systems.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Dynamic Provisioning</term>
<listitem>
<simpara>The framework allows you to create storage volumes on-demand, eliminating the need for cluster administrators to pre-provision persistent storage.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Ephemeral storage</term>
<listitem>
<simpara>Pods and containers can require temporary or transient local storage for their operation. The lifetime of this ephemeral storage does not extend beyond the life of the individual pod, and this ephemeral storage cannot be shared across pods.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Fiber channel</term>
<listitem>
<simpara>A networking technology that is used to transfer data among data centers, computer servers, switches and storage.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FlexVolume</term>
<listitem>
<simpara>FlexVolume is an out-of-tree plugin interface that uses an exec-based model to interface with storage drivers. You must install the FlexVolume driver binaries in a pre-defined volume plugin path on each node and in some cases the control plane nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>fsGroup</term>
<listitem>
<simpara>The fsGroup defines a file system group ID of a pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>iSCSI</term>
<listitem>
<simpara>Internet Small Computer Systems Interface (iSCSI) is an Internet Protocol-based storage networking standard for linking data storage facilities.
An iSCSI volume allows an existing iSCSI (SCSI over IP) volume to be mounted into your Pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>hostPath</term>
<listitem>
<simpara>A hostPath volume in an OpenShift Container Platform cluster mounts a file or directory from the host node’s filesystem into your pod.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>KMS key</term>
<listitem>
<simpara>The Key Management Service (KMS) helps you achieve the required level of encryption of your data across different services. you can use the KMS key to encrypt, decrypt, and re-encrypt data.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Local volumes</term>
<listitem>
<simpara>A local volume represents a mounted local storage device such as a disk, partition or directory.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>NFS</term>
<listitem>
<simpara>A Network File System (NFS) that allows remote hosts to mount file systems over a network and interact with those file systems as though they are mounted locally. This enables system administrators to consolidate resources onto centralized servers on the network.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>OpenShift Data Foundation</term>
<listitem>
<simpara>A provider of agnostic persistent storage for OpenShift Container Platform supporting file, block, and object storage, either in-house or in hybrid clouds</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Persistent storage</term>
<listitem>
<simpara>Pods and containers can require permanent storage for their operation. OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use PVC to request PV resources without having specific knowledge of the underlying storage infrastructure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Persistent volumes (PV)</term>
<listitem>
<simpara>OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use PVC to request PV resources without having specific knowledge of the underlying storage infrastructure.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Persistent volume claims (PVCs)</term>
<listitem>
<simpara>You can use a PVC to mount a PersistentVolume into a Pod. You can access the storage without knowing the details of the cloud environment.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Pod</term>
<listitem>
<simpara>One or more containers with shared resources, such as volume and IP addresses, running in your OpenShift Container Platform cluster.
A pod is the smallest compute unit defined, deployed, and managed.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Reclaim policy</term>
<listitem>
<simpara>A policy that tells the cluster what to do with the volume after it is released. A volume’s reclaim policy can be <literal>Retain</literal>, <literal>Recycle</literal>, or <literal>Delete</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Role-based access control (RBAC)</term>
<listitem>
<simpara>Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Stateless applications</term>
<listitem>
<simpara>A stateless application is an application program that does not save client data generated in one session for use in the next session with that client.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Stateful applications</term>
<listitem>
<simpara>A stateful application is an application program that saves data to persistent disk storage. A server, client, and applications can use a persistent disk storage. You can use the <literal>Statefulset</literal> object in OpenShift Container Platform to manage the deployment and scaling of a set of Pods, and provides guarantee about the ordering and uniqueness of these Pods.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Static provisioning</term>
<listitem>
<simpara>A cluster administrator creates a number of PVs. PVs contain the details of storage. PVs exist in the Kubernetes API and are available for consumption.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Storage</term>
<listitem>
<simpara>OpenShift Container Platform supports many types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an OpenShift Container Platform cluster.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Storage class</term>
<listitem>
<simpara>A storage class provides a way for administrators to describe the classes of storage they offer. Different classes might map to quality of service levels, backup policies, arbitrary policies determined by the cluster administrators.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>VMware vSphere’s Virtual Machine Disk (VMDK) volumes</term>
<listitem>
<simpara>Virtual Machine Disk (VMDK) is a file format that describes containers for virtual hard disk drives that is used in virtual machines.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="storage-types">
<title>Storage types</title>
<simpara>OpenShift Container Platform storage is broadly classified into two categories, namely ephemeral storage and persistent storage.</simpara>
<section xml:id="ephemeral-storage">
<title>Ephemeral storage</title>
<simpara>Pods and containers are ephemeral or transient in nature and designed for stateless applications. Ephemeral storage allows administrators and developers to better manage the local storage for some of their operations. For more information about ephemeral storage overview, types, and management, see <link linkend="understanding-ephemeral-storage">Understanding ephemeral storage</link>.</simpara>
</section>
<section xml:id="persistent-storage">
<title>Persistent storage</title>
<simpara>Stateful applications deployed in containers require persistent storage. OpenShift Container Platform uses a pre-provisioned storage framework called persistent volumes (PV) to allow cluster administrators to provision persistent storage. The data inside these volumes can exist beyond the lifecycle of an individual pod. Developers can use persistent volume claims (PVCs) to request storage requirements. For more information about persistent storage overview, configuration, and lifecycle, see <link linkend="understanding-persistent-storage">Understanding persistent storage</link>.</simpara>
</section>
</section>
<section xml:id="container-storage-interface">
<title>Container Storage Interface (CSI)</title>
<simpara>CSI is an API specification for the management of container storage across different container orchestration (CO) systems. You can manage the storage volumes within the container native environments, without having specific knowledge of the underlying storage infrastructure. With the CSI, storage works uniformly across different container orchestration systems, regardless of the storage vendors you are using. For more information about CSI, see <link linkend="persistent-storage-csi">Using Container Storage Interface (CSI)</link>.</simpara>
</section>
<section xml:id="dynamic-provisioning-overview">
<title>Dynamic Provisioning</title>
<simpara>Dynamic Provisioning allows you to create storage volumes on-demand, eliminating the need for cluster administrators to pre-provision storage. For more information about dynamic provisioning, see <link linkend="dynamic-provisioning">Dynamic provisioning</link>.</simpara>
</section>
</chapter>
<chapter xml:id="understanding-ephemeral-storage">
<title>Understanding ephemeral storage</title>

<section xml:id="storage-ephemeral-storage-overview_understanding-ephemeral-storage">
<title>Overview</title>
<simpara>In addition to persistent storage, pods and containers can require ephemeral or transient local storage for their operation. The lifetime of this ephemeral storage does not extend beyond the life of the individual pod, and this ephemeral storage cannot be shared across pods.</simpara>
<simpara>Pods use ephemeral local storage for scratch space, caching, and logs. Issues related to the lack of local storage accounting and isolation include the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Pods cannot detect how much local storage is available to them.</simpara>
</listitem>
<listitem>
<simpara>Pods cannot request guaranteed local storage.</simpara>
</listitem>
<listitem>
<simpara>Local storage is a best-effort resource.</simpara>
</listitem>
<listitem>
<simpara>Pods can be evicted due to other pods filling the local storage, after which new pods are not admitted until sufficient storage is reclaimed.</simpara>
</listitem>
</itemizedlist>
<simpara>Unlike persistent volumes, ephemeral storage is unstructured and the space is shared between all pods running on a node, in addition to other uses by the system, the container runtime, and OpenShift Container Platform. The ephemeral storage framework allows pods to specify their transient local storage needs. It also allows OpenShift Container Platform to schedule pods where appropriate, and to protect the node against excessive use of local storage.</simpara>
<simpara>While the ephemeral storage framework allows administrators and developers to better manage local storage, I/O throughput and latency are not directly effected.</simpara>
</section>
<section xml:id="storage-ephemeral-storage-types_understanding-ephemeral-storage">
<title>Types of ephemeral storage</title>
<simpara>Ephemeral local storage is always made available in the primary
partition. There are two basic ways of creating the primary
partition: root and runtime.</simpara>
<bridgehead xml:id="_root" renderas="sect3">Root</bridgehead>
<simpara>This partition holds the kubelet root directory, <literal>/var/lib/kubelet/</literal> by
default, and <literal>/var/log/</literal> directory. This partition can be shared between user
pods, the OS, and Kubernetes system daemons. This partition can be consumed by pods
through <literal>EmptyDir</literal> volumes, container logs, image layers, and container-writable
layers. Kubelet manages shared access and isolation of this partition. This
partition is ephemeral, and applications cannot expect any performance SLAs,
such as disk IOPS, from this partition.</simpara>
<bridgehead xml:id="_runtime" renderas="sect3">Runtime</bridgehead>
<simpara>This is an optional partition that runtimes can use for overlay
file systems. OpenShift Container Platform attempts to identify and provide
shared access along with isolation to this partition. Container image
layers and writable layers are stored here. If the runtime partition
exists, the <literal>root</literal> partition does not hold any image layer or other writable storage.</simpara>
</section>
<section xml:id="storage-ephemeral-storage-manage_understanding-ephemeral-storage">
<title>Ephemeral storage management</title>
<simpara>Cluster administrators can manage ephemeral storage within a project by setting quotas that define the limit ranges and number of requests for ephemeral storage across all pods in a non-terminal state. Developers can also set requests and limits on this compute resource at the pod and container level.</simpara>
<simpara>You can manage local ephemeral storage by specifying requests and limits. Each container in a pod can specify the following:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>spec.containers[].resources.limits.ephemeral-storage</literal></simpara>
</listitem>
<listitem>
<simpara><literal>spec.containers[].resources.requests.ephemeral-storage</literal></simpara>
</listitem>
</itemizedlist>
<simpara>Limits and requests for ephemeral storage are measured in byte quantities. You can express storage as a plain integer or as a fixed-point number using one of these suffixes: E, P, T, G, M, k. You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi, Mi, Ki. For example, the following quantities all represent approximately the same value: 128974848, 129e6, 129M, and 123Mi. The case of the suffixes is significant. If you specify 400m of ephemeral storage, this requests 0.4 bytes, rather than 400 mebibytes (400Mi) or 400 megabytes (400M), which was probably what was intended.</simpara>
<simpara>The following example shows a pod with two containers. Each container requests 2GiB of local ephemeral storage. Each container has a limit of 4GiB of local ephemeral storage. Therefore, the pod has a request of 4GiB of local ephemeral storage, and a limit of 8GiB of local ephemeral storage.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    resources:
      requests:
        ephemeral-storage: "2Gi" <co xml:id="CO1-1"/>
      limits:
        ephemeral-storage: "4Gi" <co xml:id="CO1-2"/>
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        ephemeral-storage: "2Gi" <co xml:id="CO1-3"/>
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  volumes:
    - name: ephemeral
      emptyDir: {}</programlisting>
<calloutlist>
<callout arearefs="CO1-1 CO1-3">
<para>Request for local ephemeral storage.</para>
</callout>
<callout arearefs="CO1-2">
<para>Limit for local ephemeral storage.</para>
</callout>
</calloutlist>
<simpara>This setting in the pod spec affects how the scheduler makes a decision on scheduling pods, and also how kubelet evict pods. First of all, the scheduler ensures that the sum of the resource requests of the scheduled containers is less than the capacity of the node. In this case, the pod can be assigned to a node only if its available ephemeral storage (allocatable resource) is more than 4GiB.</simpara>
<simpara>Secondly, at the container level, since the first container sets resource limit, kubelet eviction manager measures the disk usage of this container and evicts the pod if the storage usage of this container exceeds its limit (4GiB). At the pod level, kubelet works out an overall pod storage limit by adding up the limits of all the containers in that pod. In this case, the total storage usage at the pod level is the sum of the disk usage from all containers plus the pod&#8217;s <literal>emptyDir</literal> volumes. If this total usage exceeds the overall pod storage limit (4GiB), then the kubelet also marks the pod for eviction.</simpara>
<simpara>For information about defining quotas for projects, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/building_applications/#">Quota setting per project</link>.</simpara>
</section>
<section xml:id="storage-ephemeral-storage-monitoring_understanding-ephemeral-storage">
<title>Monitoring ephemeral storage</title>
<simpara>You can use <literal>/bin/df</literal> as a tool to monitor ephemeral storage usage on the volume where ephemeral container data is located, which is <literal>/var/lib/kubelet</literal> and <literal>/var/lib/containers</literal>. The available space for only <literal>/var/lib/kubelet</literal> is shown when you use the <literal>df</literal> command if <literal>/var/lib/containers</literal> is placed on a separate disk by the cluster administrator.</simpara>
<simpara>To show the human-readable values of used and available space in <literal>/var/lib</literal>, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ df -h /var/lib</programlisting>
<simpara>The output shows the ephemeral storage usage in <literal>/var/lib</literal>:</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Filesystem  Size  Used Avail Use% Mounted on
/dev/disk/by-partuuid/4cd1448a-01    69G   32G   34G  49% /</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="understanding-persistent-storage">
<title>Understanding persistent storage</title>

<section xml:id="persistent-storage-overview_understanding-persistent-storage">
<title>Persistent storage overview</title>
<simpara>Managing storage is a distinct problem from managing compute resources. OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use persistent volume claims (PVCs) to request PV resources without having specific knowledge of the underlying storage infrastructure.</simpara>
<simpara>PVCs are specific to a project, and are created and used by developers as a means to use a PV. PV resources on their own are not scoped to any single project; they can be shared across the entire OpenShift Container Platform cluster and claimed from any project. After a PV is bound to a PVC, that PV can not then be bound to additional PVCs. This has the effect of scoping a bound PV to a single namespace, that of the binding project.</simpara>
<simpara>PVs are defined by a <literal>PersistentVolume</literal> API object, which represents a piece of existing storage in the cluster that was either statically provisioned by the cluster administrator or dynamically provisioned using a <literal>StorageClass</literal> object. It is a resource in the cluster just like a node is a cluster resource.</simpara>
<simpara>PVs are volume plugins like <literal>Volumes</literal> but have a lifecycle that is independent of any individual pod that uses the PV. PV objects capture the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.</simpara>
<important>
<simpara>High availability of storage in the infrastructure is left to the underlying storage provider.</simpara>
</important>
<simpara>PVCs are defined by a <literal>PersistentVolumeClaim</literal> API object, which represents a request for storage by a developer. It is similar to a pod in that pods consume node resources and PVCs consume PV resources. For example, pods can request specific levels of resources, such as CPU and memory, while PVCs can request specific storage capacity and access modes. For example, they can be mounted once read-write or many times read-only.</simpara>
</section>
<section xml:id="lifecycle-volume-claim_understanding-persistent-storage">
<title>Lifecycle of a volume and claim</title>
<simpara>PVs are resources in the cluster. PVCs are requests for those resources
and also act as claim checks to the resource. The interaction between PVs
and PVCs have the following lifecycle.</simpara>
<section xml:id="provisioning_understanding-persistent-storage">
<title>Provision storage</title>
<simpara>In response to requests from a developer defined in a PVC, a cluster
administrator configures one or more dynamic provisioners that provision
storage and a matching PV.</simpara>
<simpara>Alternatively, a cluster administrator can create a number of PVs in advance
that carry the details of the real storage that is available for use. PVs
exist in the API and are available for use.</simpara>
</section>
<section xml:id="binding_understanding-persistent-storage">
<title>Bind claims</title>
<simpara>When you create a PVC, you request a specific amount of storage, specify the
required access mode, and create a storage class to describe and classify
the storage. The control loop in the master watches for new PVCs and binds
the new PVC to an appropriate PV. If an appropriate PV does not exist, a
provisioner for the storage class creates one.</simpara>
<simpara>The size of all PVs might exceed your PVC size. This is especially true
with manually provisioned PVs. To minimize the excess, OpenShift Container Platform
binds to the smallest PV that matches all other criteria.</simpara>
<simpara>Claims remain unbound indefinitely if a matching volume does not exist or
can not be created with any available provisioner servicing a storage
class. Claims are bound as matching volumes become available. For example,
a cluster with many manually provisioned 50Gi volumes would not match a
PVC requesting 100Gi. The PVC can be bound when a 100Gi PV is added to the
cluster.</simpara>
</section>
<section xml:id="using-pods_understanding-persistent-storage">
<title>Use pods and claimed PVs</title>
<simpara>Pods use claims as volumes. The cluster inspects the claim to find the bound
volume and mounts that volume for a pod. For those volumes that support
multiple access modes, you must specify which mode applies when you use
the claim as a volume in a pod.</simpara>
<simpara>Once you have a claim and that claim is bound, the bound PV belongs to you
for as long as you need it. You can schedule pods and access claimed
PVs by including <literal>persistentVolumeClaim</literal> in the pod&#8217;s volumes block.</simpara>
<note>
<simpara>If you attach persistent volumes that have high file counts to pods, those pods can fail or can take a long time to start. For
more information, see <link xlink:href="https://access.redhat.com/solutions/6221251">When using Persistent Volumes with high file counts in OpenShift, why do pods fail to start or take an excessive amount of time to achieve "Ready" state?</link>.</simpara>
</note>
</section>
<section xml:id="pvcprotection_understanding-persistent-storage">
<title>Storage Object in Use Protection</title>
<simpara>The Storage Object in Use Protection feature ensures that PVCs in active use by a pod and PVs that are bound to PVCs are not removed from the system, as this can result in data loss.</simpara>
<simpara>Storage Object in Use Protection is enabled by default.</simpara>
<note>
<simpara>A PVC is in active use by a pod when a <literal>Pod</literal> object exists that uses the PVC.</simpara>
</note>
<simpara>If a user deletes a PVC that is in active use by a pod, the PVC is not removed immediately. PVC removal is postponed until the PVC is no longer actively used by any pods. Also, if a cluster admin deletes a PV that is bound to a PVC, the PV is not removed immediately. PV removal is postponed until the PV is no longer bound to a PVC.</simpara>
</section>
<section xml:id="releasing_understanding-persistent-storage">
<title>Release a persistent volume</title>
<simpara>When you are finished with a volume, you can delete the PVC object from
the API, which allows reclamation of the resource. The volume is
considered released when the claim is deleted, but it is not yet available
for another claim. The previous claimant&#8217;s data remains on the volume and
must be handled according to policy.</simpara>
</section>
<section xml:id="reclaiming_understanding-persistent-storage">
<title>Reclaim policy for persistent volumes</title>
<simpara>The reclaim policy of a persistent volume tells the cluster what to do with the volume after it is released. A volume&#8217;s reclaim policy can be
<literal>Retain</literal>, <literal>Recycle</literal>, or <literal>Delete</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Retain</literal> reclaim policy allows manual reclamation of the resource for
those volume plugins that support it.</simpara>
</listitem>
<listitem>
<simpara><literal>Recycle</literal> reclaim policy recycles the volume back into the pool of
unbound persistent volumes once it is released from its claim.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>The <literal>Recycle</literal> reclaim policy is deprecated in OpenShift Container Platform 4. Dynamic provisioning is recommended for equivalent and better
functionality.</simpara>
</important>
<itemizedlist>
<listitem>
<simpara><literal>Delete</literal> reclaim policy deletes  both the <literal>PersistentVolume</literal> object
from OpenShift Container Platform and the associated storage asset in external
infrastructure, such as Amazon Elastic Block Store (Amazon EBS) or VMware vSphere.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Dynamically provisioned volumes are always deleted.</simpara>
</note>
</section>
<section xml:id="reclaim-manual_understanding-persistent-storage">
<title>Reclaiming a persistent volume manually</title>
<simpara>When a persistent volume claim (PVC) is deleted, the persistent volume (PV) still exists and is considered "released". However, the PV is not yet available for another claim because the data of the previous claimant remains on the volume.</simpara>
<formalpara>
<title>Procedure</title>
<para>To manually reclaim the PV as a cluster administrator:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Delete the PV.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pv &lt;pv-name&gt;</programlisting>
<simpara>The associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume, still exists after the PV is deleted.</simpara>
</listitem>
<listitem>
<simpara>Clean up the data on the associated storage asset.</simpara>
</listitem>
<listitem>
<simpara>Delete the associated storage asset. Alternately, to reuse the same storage asset, create a new PV with the storage asset definition.</simpara>
</listitem>
</orderedlist>
<simpara>The reclaimed PV is now available for use by another PVC.</simpara>
</section>
<section xml:id="reclaim-policy_understanding-persistent-storage">
<title>Changing the reclaim policy of a persistent volume</title>
<simpara>To change the reclaim policy of a persistent volume:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the persistent volumes in your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
 pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
 pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
 pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3    manual                     3s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Choose one of your persistent volumes and change its reclaim policy:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch pv &lt;your-pv-name&gt; -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'</programlisting>
</listitem>
<listitem>
<simpara>Verify that your chosen persistent volume has the right policy:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
 pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
 pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
 pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3    manual                     3s</programlisting>
</para>
</formalpara>
<simpara>In the preceding output, the volume bound to claim <literal>default/claim3</literal> now has a <literal>Retain</literal> reclaim policy. The volume will not be automatically deleted when a user deletes claim <literal>default/claim3</literal>.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-volumes_understanding-persistent-storage">
<title>Persistent volumes</title>
<simpara>Each PV contains a <literal>spec</literal> and <literal>status</literal>, which is the specification and status of the volume, for example:</simpara>
<formalpara>
<title><literal>PersistentVolume</literal> object definition example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <co xml:id="CO2-1"/>
spec:
  capacity:
    storage: 5Gi <co xml:id="CO2-2"/>
  accessModes:
    - ReadWriteOnce <co xml:id="CO2-3"/>
  persistentVolumeReclaimPolicy: Retain <co xml:id="CO2-4"/>
  ...
status:
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO2-1">
<para>Name of the persistent volume.</para>
</callout>
<callout arearefs="CO2-2">
<para>The amount of storage available to the volume.</para>
</callout>
<callout arearefs="CO2-3">
<para>The access mode, defining the read-write and mount permissions.</para>
</callout>
<callout arearefs="CO2-4">
<para>The reclaim policy, indicating how the resource should be handled once it is released.</para>
</callout>
</calloutlist>
<section xml:id="types-of-persistent-volumes_understanding-persistent-storage">
<title>Types of PVs</title>
<simpara>OpenShift Container Platform supports the following persistent volume plugins:</simpara>
<itemizedlist>
<listitem>
<simpara>AliCloud Disk</simpara>
</listitem>
<listitem>
<simpara>AWS Elastic Block Store (EBS)</simpara>
</listitem>
<listitem>
<simpara>AWS Elastic File Store (EFS)</simpara>
</listitem>
<listitem>
<simpara>Azure Disk</simpara>
</listitem>
<listitem>
<simpara>Azure File</simpara>
</listitem>
<listitem>
<simpara>Cinder</simpara>
</listitem>
<listitem>
<simpara>Fibre Channel</simpara>
</listitem>
<listitem>
<simpara>GCP Persistent Disk</simpara>
</listitem>
<listitem>
<simpara>GCP Filestore</simpara>
</listitem>
<listitem>
<simpara>IBM Power Virtual Server Block</simpara>
</listitem>
<listitem>
<simpara>IBM&#174; VPC Block</simpara>
</listitem>
<listitem>
<simpara>HostPath</simpara>
</listitem>
<listitem>
<simpara>iSCSI</simpara>
</listitem>
<listitem>
<simpara>Local volume</simpara>
</listitem>
<listitem>
<simpara>NFS</simpara>
</listitem>
<listitem>
<simpara>OpenStack Manila</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Data Foundation</simpara>
</listitem>
<listitem>
<simpara>VMware vSphere</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="pv-capacity_understanding-persistent-storage">
<title>Capacity</title>
<simpara>Generally, a persistent volume (PV) has a specific storage capacity. This is set by using the <literal>capacity</literal> attribute of the PV.</simpara>
<simpara>Currently, storage capacity is the only resource that can be set or requested. Future attributes may include IOPS, throughput, and so on.</simpara>
</section>
<section xml:id="pv-access-modes_understanding-persistent-storage">
<title>Access modes</title>
<simpara>A persistent volume can be mounted on a host in any way supported by the resource provider. Providers have different capabilities and each PV&#8217;s access modes are set to the specific modes supported by that particular volume. For example, NFS can support multiple read-write clients, but a specific NFS PV might be exported on the server as read-only. Each PV gets its own set of access modes describing that specific PV&#8217;s capabilities.</simpara>
<simpara>Claims are matched to volumes with similar access modes. The only two matching criteria are access modes and size. A claim&#8217;s access modes represent a request. Therefore, you might be granted more, but never less. For example, if a claim requests RWO, but the only volume available is an NFS PV (RWO+ROX+RWX), the claim would then match NFS because it supports RWO.</simpara>
<simpara>Direct matches are always attempted first. The volume&#8217;s modes must match or contain more modes than you requested. The size must be greater than or equal to what is expected. If two types of volumes, such as NFS and iSCSI, have the same set of access modes, either of them can match a claim with those modes. There is no ordering between types of volumes and no way to choose one type over another.</simpara>
<simpara>All volumes with the same modes are grouped, and then sorted by size, smallest to largest. The binder gets the group with matching modes and iterates over each, in size order, until one size matches.</simpara>
<important>
<simpara>Volume access modes describe volume capabilities. They are not enforced constraints. The storage provider is responsible for runtime errors resulting from invalid use of the resource. Errors in the provider show up at runtime as mount errors.</simpara>
<simpara>For example, NFS offers <literal>ReadWriteOnce</literal> access mode. If you want to use the volume&#8217;s ROX capability, mark the claims as <literal>ReadOnlyMany</literal>.</simpara>
<simpara>iSCSI and Fibre Channel volumes do not currently have any fencing mechanisms. You must ensure the volumes are only used by one node at a time. In certain situations, such as draining a node, the volumes can be used simultaneously by two nodes. Before draining the node, delete the pods that use the volumes.</simpara>
</important>
<simpara>The following table lists the access modes:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Access modes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="60*"/>
<thead>
<row>
<entry align="left" valign="top">Access Mode</entry>
<entry align="left" valign="top">CLI abbreviation</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ReadWriteOnce</simpara></entry>
<entry align="left" valign="top"><simpara><literal>RWO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The volume can be mounted as read-write by a single node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReadWriteOncePod <superscript>[1]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara><literal>RWOP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The volume can be mounted as read-write by a single pod on a single node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReadOnlyMany</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ROX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The volume can be mounted as read-only by many nodes.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReadWriteMany</simpara></entry>
<entry align="left" valign="top"><simpara><literal>RWX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The volume can be mounted as read-write by many nodes.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<orderedlist numeration="arabic">
<listitem>
<simpara>ReadWriteOncePod access mode for persistent volumes is a Technology Preview feature.</simpara>
</listitem>
</orderedlist>
<important>
<simpara>ReadWriteOncePod access mode for persistent volumes is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<table frame="all" rowsep="1" colsep="1">
<title>Supported access modes for persistent volumes</title>
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="5">
<colspec colname="col_1" colwidth="85*"/>
<colspec colname="col_2" colwidth="85*"/>
<colspec colname="col_3" colwidth="85*"/>
<colspec colname="col_4" colwidth="85*"/>
<colspec colname="col_5" colwidth="85*"/>
<thead>
<row>
<entry align="left" valign="top">Volume plugin</entry>
<entry align="center" valign="top">ReadWriteOnce <superscript>[1]</superscript></entry>
<entry align="center" valign="top">ReadWriteOncePod <superscript>[2]</superscript></entry>
<entry align="center" valign="top">ReadOnlyMany</entry>
<entry align="center" valign="top">ReadWriteMany</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AliCloud Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AWS EBS <superscript>[3]</superscript></simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AWS EFS</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure File</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cinder</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Fibre Channel</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅ <superscript>[4]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP Persistent Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP Filestore</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HostPath</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Power Virtual Server  Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM&#174; VPC Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>iSCSI</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅ <superscript>[4]</superscript></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local volume</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NFS</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenStack Manila</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Red Hat OpenShift Data Foundation</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VMware vSphere</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅ <superscript>[5]</superscript></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>ReadWriteOnce (RWO) volumes cannot be mounted on multiple nodes. If a node fails, the system does not allow the attached RWO volume to be mounted on a new node because it is already assigned to the failed node. If you encounter a multi-attach error message as a result, force delete the pod on a shutdown or crashed node to avoid data loss in critical workloads, such as when dynamic persistent volumes are attached.</simpara>
</listitem>
<listitem>
<simpara>ReadWriteOncePod is a Technology Preview feature.</simpara>
</listitem>
<listitem>
<simpara>Use a recreate deployment strategy for pods that rely on AWS EBS.</simpara>
</listitem>
<listitem>
<simpara>Only raw block volumes support the ReadWriteMany (RWX) access mode for Fibre Channel and iSCSI. For more information, see "Block volume support".</simpara>
</listitem>
<listitem>
<simpara>If the underlying vSphere environment supports the vSAN file service, then the vSphere Container Storage Interface (CSI) Driver Operator installed by
OpenShift Container Platform supports provisioning of ReadWriteMany (RWX) volumes. If you do not have vSAN file service configured, and you request RWX, the volume fails to get created and an error is logged. For more information, see "Using Container Storage Interface" &#8594; "VMware vSphere CSI Driver Operator".</simpara>
</listitem>
</orderedlist>
</para>
</section>
<section xml:id="pv-phase_understanding-persistent-storage">
<title>Phase</title>
<simpara>Volumes can be found in one of the following phases:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Volume phases</title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Phase</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Available</simpara></entry>
<entry align="left" valign="top"><simpara>A free resource not yet bound to a claim.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Bound</simpara></entry>
<entry align="left" valign="top"><simpara>The volume is bound to a claim.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Released</simpara></entry>
<entry align="left" valign="top"><simpara>The claim was deleted, but the resource is not yet reclaimed by the
cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Failed</simpara></entry>
<entry align="left" valign="top"><simpara>The volume has failed its automatic reclamation.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>You can view the name of the PVC that is bound to the PV by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv &lt;pv-claim&gt;</programlisting>
<section xml:id="pv-mount-options_understanding-persistent-storage">
<title>Mount options</title>
<simpara>You can specify mount options while mounting a PV by using the attribute <literal>mountOptions</literal>.</simpara>
<simpara>For example:</simpara>
<formalpara>
<title>Mount options example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  mountOptions: <co xml:id="CO3-1"/>
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
  persistentVolumeReclaimPolicy: Retain
  claimRef:
    name: claim1
    namespace: default</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO3-1">
<para>Specified mount options are used while mounting the PV to the disk.</para>
</callout>
</calloutlist>
<simpara>The following PV types support mount options:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS Elastic Block Store (EBS)</simpara>
</listitem>
<listitem>
<simpara>Azure Disk</simpara>
</listitem>
<listitem>
<simpara>Azure File</simpara>
</listitem>
<listitem>
<simpara>Cinder</simpara>
</listitem>
<listitem>
<simpara>GCE Persistent Disk</simpara>
</listitem>
<listitem>
<simpara>iSCSI</simpara>
</listitem>
<listitem>
<simpara>Local volume</simpara>
</listitem>
<listitem>
<simpara>NFS</simpara>
</listitem>
<listitem>
<simpara>Red Hat OpenShift Data Foundation (Ceph RBD only)</simpara>
</listitem>
<listitem>
<simpara>VMware vSphere</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Fibre Channel and HostPath PVs do not support mount options.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi-vsphere-rwx_persistent-storage-csi-vsphere">ReadWriteMany vSphere volume support</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="persistent-volume-claims_understanding-persistent-storage">
<title>Persistent volume claims</title>
<simpara>Each <literal>PersistentVolumeClaim</literal> object contains a <literal>spec</literal> and <literal>status</literal>, which
is the specification and status of the persistent volume claim (PVC), for example:</simpara>
<formalpara>
<title><literal>PersistentVolumeClaim</literal> object definition example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim <co xml:id="CO4-1"/>
spec:
  accessModes:
    - ReadWriteOnce <co xml:id="CO4-2"/>
  resources:
    requests:
      storage: 8Gi <co xml:id="CO4-3"/>
  storageClassName: gold <co xml:id="CO4-4"/>
status:
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO4-1">
<para>Name of the PVC.</para>
</callout>
<callout arearefs="CO4-2">
<para>The access mode, defining the read-write and mount permissions.</para>
</callout>
<callout arearefs="CO4-3">
<para>The amount of storage available to the PVC.</para>
</callout>
<callout arearefs="CO4-4">
<para>Name of the <literal>StorageClass</literal> required by the claim.</para>
</callout>
</calloutlist>
<section xml:id="pvc-storage-class_understanding-persistent-storage">
<title>Storage classes</title>
<simpara>Claims can optionally request a specific storage class by specifying the
storage class&#8217;s name in the <literal>storageClassName</literal> attribute. Only PVs of the
requested class, ones with the same <literal>storageClassName</literal> as the PVC, can be
bound to the PVC. The cluster administrator can configure dynamic
provisioners to service one or more storage classes. The cluster
administrator can create a PV on demand that matches the specifications
in the PVC.</simpara>
<important>
<simpara>The Cluster Storage Operator might install a default storage class depending
on the platform in use. This storage class is owned and controlled by the
Operator. It cannot be deleted or modified beyond defining annotations
and labels. If different behavior is desired, you must define a custom
storage class.</simpara>
</important>
<simpara>The cluster administrator can also set a default storage class for all PVCs.
When a default storage class is configured, the PVC must explicitly ask for
<literal>StorageClass</literal> or <literal>storageClassName</literal> annotations set to <literal>""</literal> to be bound
to a PV without a storage class.</simpara>
<note>
<simpara>If more than one storage class is marked as default, a PVC can only be created if the <literal>storageClassName</literal> is explicitly specified. Therefore, only one storage class should be set as the default.</simpara>
</note>
</section>
<section xml:id="pvc-access-modes_understanding-persistent-storage">
<title>Access modes</title>
<simpara>Claims use the same conventions as volumes when requesting storage with
specific access modes.</simpara>
</section>
<section xml:id="pvc-resources_understanding-persistent-storage">
<title>Resources</title>
<simpara>Claims, such as pods, can request specific quantities of a resource. In
this case, the request is for storage. The same resource model applies to
volumes and claims.</simpara>
</section>
<section xml:id="pvc-claims-as-volumes_understanding-persistent-storage">
<title>Claims as volumes</title>
<simpara>Pods access storage by using the claim as a volume. Claims must exist in the
same namespace as the pod using the claim. The cluster finds the claim
in the pod&#8217;s namespace and uses it to get the <literal>PersistentVolume</literal> backing
the claim. The volume is mounted to the host and into the pod, for example:</simpara>
<formalpara>
<title>Mount volume to the host and into the pod example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: dockerfile/nginx
      volumeMounts:
      - mountPath: "/var/www/html" <co xml:id="CO5-1"/>
        name: mypd <co xml:id="CO5-2"/>
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim <co xml:id="CO5-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO5-1">
<para>Path to mount the volume inside the pod.</para>
</callout>
<callout arearefs="CO5-2">
<para>Name of the volume to mount. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
<callout arearefs="CO5-3">
<para>Name of the PVC, that exists in the same namespace, to use.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="block-volume-support_understanding-persistent-storage">
<title>Block volume support</title>
<simpara>OpenShift Container Platform can statically provision raw block volumes. These volumes
do not have a file system, and can provide performance benefits for
applications that either write to the disk directly or implement their own
storage service.</simpara>
<simpara>Raw block volumes are provisioned by specifying <literal>volumeMode: Block</literal> in the
PV and PVC specification.</simpara>
<important>
<simpara>Pods using raw block volumes must be configured to allow privileged containers.</simpara>
</important>
<simpara>The following table displays which volume plugins support block volumes.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Block volume support</title>
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="4">
<colspec colname="col_1" colwidth="106.25*"/>
<colspec colname="col_2" colwidth="106.25*"/>
<colspec colname="col_3" colwidth="106.25*"/>
<colspec colname="col_4" colwidth="106.25*"/>
<thead>
<row>
<entry align="left" valign="top">Volume Plugin</entry>
<entry align="left" valign="top">Manually provisioned</entry>
<entry align="left" valign="top">Dynamically provisioned</entry>
<entry align="left" valign="top">Fully supported</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Amazon Elastic Block Store (Amazon EBS)</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Amazon Elastic File Storage (Amazon EFS)</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AliCloud Disk</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure Disk</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure File</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Cinder</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Fibre Channel</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HostPath</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM VPC Disk</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>iSCSI</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Local volume</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NFS</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Red Hat OpenShift Data Foundation</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VMware vSphere</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
<entry align="left" valign="top"><simpara>✅</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<important>
<simpara>Using any of the block volumes that can be provisioned manually, but are not provided as fully supported, is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<section xml:id="block-volume-examples_understanding-persistent-storage">
<title>Block volume examples</title>
<formalpara>
<title>PV example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: block-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  volumeMode: Block <co xml:id="CO6-1"/>
  persistentVolumeReclaimPolicy: Retain
  fc:
    targetWWNs: ["50060e801049cfd1"]
    lun: 0
    readOnly: false</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO6-1">
<para><literal>volumeMode</literal> must be set to <literal>Block</literal> to indicate that this PV is a raw
block volume.</para>
</callout>
</calloutlist>
<formalpara>
<title>PVC example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: block-pvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block <co xml:id="CO7-1"/>
  resources:
    requests:
      storage: 10Gi</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO7-1">
<para><literal>volumeMode</literal> must be set to <literal>Block</literal> to indicate that a raw block PVC
is requested.</para>
</callout>
</calloutlist>
<formalpara>
<title><literal>Pod</literal> specification example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-with-block-volume
spec:
  containers:
    - name: fc-container
      image: fedora:26
      command: ["/bin/sh", "-c"]
      args: [ "tail -f /dev/null" ]
      volumeDevices:  <co xml:id="CO8-1"/>
        - name: data
          devicePath: /dev/xvda <co xml:id="CO8-2"/>
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: block-pvc <co xml:id="CO8-3"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO8-1">
<para><literal>volumeDevices</literal>, instead of <literal>volumeMounts</literal>, is used for block
devices. Only <literal>PersistentVolumeClaim</literal> sources can be used with
raw block volumes.</para>
</callout>
<callout arearefs="CO8-2">
<para><literal>devicePath</literal>, instead of <literal>mountPath</literal>, represents the path to the
physical device where the raw block is mapped to the system.</para>
</callout>
<callout arearefs="CO8-3">
<para>The volume source must be of type <literal>persistentVolumeClaim</literal> and must
match the name of the PVC as expected.</para>
</callout>
</calloutlist>
<table frame="all" rowsep="1" colsep="1">
<title>Accepted values for <literal>volumeMode</literal></title>
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<thead>
<row>
<entry align="left" valign="top">Value</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" rowsep="1" colsep="1">
<title>Binding scenarios for block volumes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="16.6666*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="50.0001*"/>
<thead>
<row>
<entry align="left" valign="top">PV <literal>volumeMode</literal></entry>
<entry align="left" valign="top">PVC <literal>volumeMode</literal></entry>
<entry align="left" valign="top">Binding result</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>No Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>Unspecified</simpara></entry>
<entry align="left" valign="top"><simpara>No Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>No Bind</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Block</simpara></entry>
<entry align="left" valign="top"><simpara>Filesystem</simpara></entry>
<entry align="left" valign="top"><simpara>No Bind</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<important>
<simpara>Unspecified values result in the default value of <literal>Filesystem</literal>.</simpara>
</important>
</section>
</section>
<section xml:id="using_fsGroup_understanding-persistent-storage">
<title>Using fsGroup to reduce pod timeouts</title>
<simpara>If a storage volume contains many files (~1,000,000 or greater), you may experience pod timeouts.</simpara>
<simpara>This can occur because, by default, OpenShift Container Platform recursively changes ownership and permissions for the contents of each volume to match the <literal>fsGroup</literal> specified in a pod&#8217;s <literal>securityContext</literal> when that volume is mounted. For large volumes, checking and changing ownership and permissions can be time consuming, slowing pod startup. You can use the <literal>fsGroupChangePolicy</literal> field inside a <literal>securityContext</literal> to control the way that OpenShift Container Platform checks and manages ownership and permissions for a volume.</simpara>
<simpara><literal>fsGroupChangePolicy</literal> defines behavior for changing ownership and permission of the volume before being exposed inside a pod. This field only applies to volume types that support <literal>fsGroup</literal>-controlled ownership and permissions. This field has two possible values:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>OnRootMismatch</literal>: Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This can help shorten the time it takes to change ownership and permission of a volume to reduce pod timeouts.</simpara>
</listitem>
<listitem>
<simpara><literal>Always</literal>: Always change permission and ownership of the volume when a volume is mounted.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title><literal>fsGroupChangePolicy</literal> example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">securityContext:
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000
  fsGroupChangePolicy: "OnRootMismatch" <co xml:id="CO9-1"/>
  ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO9-1">
<para><literal>OnRootMismatch</literal> specifies skipping recursive permission change, thus helping to avoid pod timeout problems.</para>
</callout>
</calloutlist>
<note>
<simpara>The fsGroupChangePolicyfield has no effect on ephemeral volume types, such as secret, configMap, and emptydir.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="_configuring-persistent-storage">
<title>Configuring persistent storage</title>
<section xml:id="persistent-storage-aws">
<title>Persistent storage using AWS Elastic Block Store</title>

<simpara>OpenShift Container Platform supports Amazon Elastic Block Store (EBS) volumes.
You can provision your OpenShift Container Platform cluster with persistent storage by using <link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2</link>.</simpara>
<simpara>The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure.
You can dynamically provision Amazon EBS volumes.
Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be requested by users.
You can define a KMS key to encrypt container-persistent volumes on AWS.
By default, newly created clusters using OpenShift Container Platform version 4.10 and later use gp3 storage and the <link xlink:href="https://github.com/openshift/aws-ebs-csi-driver">AWS EBS CSI driver</link>.</simpara>
<important>
<simpara>High-availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<simpara>For OpenShift Container Platform, automatic migration from AWS EBS in-tree to the Container Storage Interface (CSI) driver is available as a Technology Preview (TP) feature.
With migration enabled, volumes provisioned using the existing in-tree driver are automatically migrated to use the AWS EBS CSI driver. For more information, see <link linkend="persistent-storage-csi-migration">CSI automatic migration feature</link>.</simpara>
<section xml:id="storage-create-storage-class_persistent-storage-aws">
<title>Creating the EBS storage class</title>
<simpara>Storage classes are used to differentiate and delineate storage levels and
usages. By defining a storage class, users can obtain dynamically provisioned
persistent volumes.</simpara>
</section>
<section xml:id="_creating-the-persistent-volume-claim">
<title>Creating the persistent volume claim</title>
<formalpara>
<title>Prerequisites</title>
<para>Storage must exist in the underlying infrastructure before it can be mounted as
a volume in OpenShift Container Platform.</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">Persistent Volume Claims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the persistent volume claims overview, click <emphasis role="strong">Create Persistent Volume
Claim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the desired options on the page that appears.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the previously-created storage class from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique name for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Select the access mode. This selection determines the read and write access for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Define the size of the storage claim.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the persistent volume claim and generate a persistent
volume.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="volume-format-AWS_persistent-storage-aws">
<title>Volume format</title>
<simpara>Before OpenShift Container Platform mounts the volume and passes it to a container, it
checks that the volume contains a file system as specified by the <literal>fsType</literal>
parameter in the persistent volume definition. If the device is not
formatted with the file system, all data from the device is erased and the
device is automatically formatted with the given file system.</simpara>
<simpara>This verification enables you to use unformatted AWS volumes as persistent volumes,
because OpenShift Container Platform formats them before the first use.</simpara>
</section>
<section xml:id="maximum-number-of-ebs-volumes-on-a-node_persistent-storage-aws">
<title>Maximum number of EBS volumes on a node</title>
<simpara>By default, OpenShift Container Platform supports a maximum of 39 EBS volumes attached to one
node. This limit is consistent with the
<link xlink:href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html#linux-specific-volume-limits">AWS volume limits</link>. The volume limit depends on the instance type.</simpara>
<important>
<simpara>As a cluster administrator, you must use either in-tree or Container Storage Interface (CSI) volumes and their respective storage classes, but never both volume types at the same time. The maximum attached EBS volume number is counted separately for in-tree and CSI volumes, which means you could have up to 39 EBS volumes of each type.</simpara>
</important>
<simpara>For information about accessing additional storage options, such as volume snapshots, that are not possible with in-tree volume plug-ins, see <link linkend="persistent-storage-csi-ebs">AWS Elastic Block Store CSI Driver Operator</link>.</simpara>
</section>
<section xml:id="aws-container-persistent-volumes-encrypt_persistent-storage-aws">
<title>Encrypting container persistent volumes on AWS with a KMS key</title>
<simpara>Defining a KMS key to encrypt container-persistent volumes on AWS is useful when you have explicit compliance and security guidelines when deploying to AWS.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Underlying infrastructure must contain storage.</simpara>
</listitem>
<listitem>
<simpara>You must create a customer KMS key on AWS.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a storage class:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ cat &lt;&lt; EOF | oc create -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO10-1"/>
parameters:
  fsType: ext4 <co xml:id="CO10-2"/>
  encrypted: "true"
  kmsKeyId: keyvalue <co xml:id="CO10-3"/>
provisioner: ebs.csi.aws.com
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
EOF</programlisting>
<calloutlist>
<callout arearefs="CO10-1">
<para>Specifies the name of the storage class.</para>
</callout>
<callout arearefs="CO10-2">
<para>File system that is created on provisioned volumes.</para>
</callout>
<callout arearefs="CO10-3">
<para>Specifies the full Amazon Resource Name (ARN) of the key to use when encrypting the container-persistent volume. If you do not provide any key, but the <literal>encrypted</literal> field is set to <literal>true</literal>, then the default KMS key is used. See <link xlink:href="https://docs.aws.amazon.com/kms/latest/developerguide/find-cmk-id-arn.html">Finding the key ID and key ARN on AWS</link> in the AWS documentation.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a persistent volume claim (PVC) with the storage class specifying the KMS key:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ cat &lt;&lt; EOF | oc create -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  storageClassName: &lt;storage-class-name&gt;
  resources:
    requests:
      storage: 1Gi
EOF</programlisting>
</listitem>
<listitem>
<simpara>Create workload containers to consume the PVC:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">$ cat &lt;&lt; EOF | oc create -f -
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: httpd
      image: quay.io/centos7/httpd-24-centos7
      ports:
        - containerPort: 80
      volumeMounts:
        - mountPath: /mnt/storage
          name: data
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: mypvc
EOF</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_persistent-storage-aws" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara>See <link linkend="persistent-storage-csi-ebs">AWS Elastic Block Store CSI Driver Operator</link> for information about accessing additional storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-using-azure">
<title>Persistent storage using Azure</title>

<simpara>OpenShift Container Platform supports Microsoft Azure Disk volumes. You can
provision your OpenShift Container Platform cluster with persistent storage using Azure.
Some familiarity with Kubernetes and Azure is assumed.
The Kubernetes persistent volume framework allows administrators to provision a
cluster with persistent storage and gives users a way to request those
resources without having any knowledge of the underlying infrastructure.
Azure Disk volumes can be provisioned dynamically.
Persistent volumes are not bound to a single project or namespace; they can be
shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be
requested by users.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision Azure Disk storage.</simpara>
<simpara>In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.</simpara>
</important>
<important>
<simpara>High availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://azure.microsoft.com/en-us/services/storage/disks">Microsoft Azure Disk</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="storage-create-azure-storage-class_persistent-storage-azure">
<title>Creating the Azure storage class</title>
<simpara>Storage classes are used to differentiate and delineate storage levels and
usages. By defining a storage class, users can obtain dynamically provisioned
persistent volumes.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">Storage Classes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the storage class overview, click <emphasis role="strong">Create Storage Class</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the desired options on the page that appears.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter a name to reference the storage class.</simpara>
</listitem>
<listitem>
<simpara>Enter an optional description.</simpara>
</listitem>
<listitem>
<simpara>Select the reclaim policy.</simpara>
</listitem>
<listitem>
<simpara>Select <literal>kubernetes.io/azure-disk</literal> from the drop down list.</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Enter the storage account type. This corresponds to your Azure
storage account SKU tier. Valid options are <literal>Premium_LRS</literal>, <literal>PremiumV2_LRS</literal>, <literal>Standard_LRS</literal>,
<literal>StandardSSD_LRS</literal>, and <literal>UltraSSD_LRS</literal>.</simpara>
<important>
<simpara>The skuname <literal>PremiumV2_LRS</literal> is not supported in all regions, and in some supported regions, not all of the availability zones are supported. For more information, see <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-premium-v2">Azure doc</link>.</simpara>
</important>
</listitem>
<listitem>
<simpara>Enter the kind of account. Valid options are <literal>shared</literal>, <literal>dedicated,</literal>
and <literal>managed</literal>.</simpara>
<important>
<simpara>Red Hat only supports the use of <literal>kind: Managed</literal> in the storage class.</simpara>
<simpara>With <literal>Shared</literal> and <literal>Dedicated</literal>, Azure creates unmanaged disks, while OpenShift Container Platform creates a managed disk for machine OS (root) disks. But because Azure Disk does not allow the use of both managed and unmanaged disks on a node, unmanaged disks created with <literal>Shared</literal> or <literal>Dedicated</literal> cannot be attached to OpenShift Container Platform nodes.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Enter additional parameters for the storage class as desired.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the storage class.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/storage/storage-classes/#new-azure-disk-storage-class-starting-from-v1-7-2">Azure Disk Storage Class</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_creating-the-persistent-volume-claim-2">
<title>Creating the persistent volume claim</title>
<formalpara>
<title>Prerequisites</title>
<para>Storage must exist in the underlying infrastructure before it can be mounted as
a volume in OpenShift Container Platform.</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">Persistent Volume Claims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the persistent volume claims overview, click <emphasis role="strong">Create Persistent Volume
Claim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the desired options on the page that appears.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the previously-created storage class from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique name for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Select the access mode. This selection determines the read and write access for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Define the size of the storage claim.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the persistent volume claim and generate a persistent
volume.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="volume-format-azure_persistent-storage-azure">
<title>Volume format</title>
<simpara>Before OpenShift Container Platform mounts the volume and passes it to a container, it checks
that it contains a file system as specified by the <literal>fsType</literal> parameter in the
persistent volume definition. If the device is not formatted with the file
system, all data from the device is erased and the device is automatically
formatted with the given file system.</simpara>
<simpara>This allows using unformatted Azure volumes as persistent volumes, because
OpenShift Container Platform formats them before the first use.</simpara>
</section>
<section xml:id="machineset-azure-ultra-disk_persistent-storage-azure">
<title>Machine sets that deploy machines with ultra disks using PVCs</title>
<simpara>You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.</simpara>
<simpara>Both the in-tree plugin and CSI driver support using PVCs to enable ultra disks. You can also deploy machines with ultra disks as data disks without creating a PVC.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="machineset-azure-ultra-disk_persistent-storage-csi-azure">Machine sets that deploy machines on ultra disks using CSI PVCs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#machineset-azure-ultra-disk_creating-machineset-azure">Machine sets that deploy machines on ultra disks as data disks</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-creating-azure-ultra-disk_persistent-storage-azure">
<title>Creating machines with ultra disks by using machine sets</title>
<simpara>You can deploy machines with ultra disks on Azure by editing your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Copy an existing Azure <literal>MachineSet</literal> custom resource (CR) and edit it by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine-set-name&gt;</programlisting>
<simpara>where <literal>&lt;machine-set-name&gt;</literal> is the machine set that you want to provision machines with ultra disks.</simpara>
</listitem>
<listitem>
<simpara>Add the following lines in the positions indicated:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <co xml:id="CO11-1"/>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <co xml:id="CO11-2"/></programlisting>
<calloutlist>
<callout arearefs="CO11-1">
<para>Specify a label to use to select a node that is created by this machine set. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO11-2">
<para>These lines enable the use of ultra disks.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a machine set using the updated configuration by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine-set-name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a storage class that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ultra-disk-sc <co xml:id="CO12-1"/>
parameters:
  cachingMode: None
  diskIopsReadWrite: "2000" <co xml:id="CO12-2"/>
  diskMbpsReadWrite: "320" <co xml:id="CO12-3"/>
  kind: managed
  skuname: UltraSSD_LRS
provisioner: disk.csi.azure.com <co xml:id="CO12-4"/>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer <co xml:id="CO12-5"/></programlisting>
<calloutlist>
<callout arearefs="CO12-1">
<para>Specify the name of the storage class. This procedure uses <literal>ultra-disk-sc</literal> for this value.</para>
</callout>
<callout arearefs="CO12-2">
<para>Specify the number of IOPS for the storage class.</para>
</callout>
<callout arearefs="CO12-3">
<para>Specify the throughput in MBps for the storage class.</para>
</callout>
<callout arearefs="CO12-4">
<para>For Azure Kubernetes Service (AKS) version 1.21 or later, use <literal>disk.csi.azure.com</literal>. For earlier versions of AKS, use <literal>kubernetes.io/azure-disk</literal>.</para>
</callout>
<callout arearefs="CO12-5">
<para>Optional: Specify this parameter to wait for the creation of the pod that will use the disk.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a persistent volume claim (PVC) to reference the <literal>ultra-disk-sc</literal> storage class that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ultra-disk <co xml:id="CO13-1"/>
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: ultra-disk-sc <co xml:id="CO13-2"/>
  resources:
    requests:
      storage: 4Gi <co xml:id="CO13-3"/></programlisting>
<calloutlist>
<callout arearefs="CO13-1">
<para>Specify the name of the PVC. This procedure uses <literal>ultra-disk</literal> for this value.</para>
</callout>
<callout arearefs="CO13-2">
<para>This PVC references the <literal>ultra-disk-sc</literal> storage class.</para>
</callout>
<callout arearefs="CO13-3">
<para>Specify the size for the storage class. The minimum value is <literal>4Gi</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a pod that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx-ultra
spec:
  nodeSelector:
    disk: ultrassd <co xml:id="CO14-1"/>
  containers:
  - name: nginx-ultra
    image: alpine:latest
    command:
      - "sleep"
      - "infinity"
    volumeMounts:
    - mountPath: "/mnt/azure"
      name: volume
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: ultra-disk <co xml:id="CO14-2"/></programlisting>
<calloutlist>
<callout arearefs="CO14-1">
<para>Specify the label of the machine set that enables the use of ultra disks. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO14-2">
<para>This pod references the <literal>ultra-disk</literal> PVC.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Validate that the machines are created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines</programlisting>
<simpara>The machines should be in the <literal>Running</literal> state.</simpara>
</listitem>
<listitem>
<simpara>For a machine that is running and has a node attached, validate the partition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</programlisting>
<simpara>In this command, <literal>oc debug node/&lt;node-name&gt;</literal> starts a debugging shell on the node <literal>&lt;node-name&gt;</literal> and passes a command with <literal>--</literal>. The passed command <literal>chroot /host</literal> provides access to the underlying host OS binaries, and <literal>lsblk</literal> shows the block devices that are attached to the host OS machine.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>To use an ultra disk from within a pod, create a workload that uses the mount point. Create a YAML file similar to the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: ssd-benchmark1
spec:
  containers:
  - name: ssd-benchmark1
    image: nginx
    ports:
      - containerPort: 80
        name: "http-server"
    volumeMounts:
    - name: lun0p1
      mountPath: "/tmp"
  volumes:
    - name: lun0p1
      hostPath:
        path: /var/lib/lun0p1
        type: DirectoryOrCreate
  nodeSelector:
    disktype: ultrassd</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-troubleshooting-azure-ultra-disk_persistent-storage-azure">
<title>Troubleshooting resources for machine sets that enable ultra disks</title>
<simpara>Use the information in this section to understand and recover from issues you might encounter.</simpara>
<section xml:id="ts-pvc-mounting-ultra_persistent-storage-azure">
<title>Unable to mount a persistent volume claim backed by an ultra disk</title>
<simpara>If there is an issue mounting a persistent volume claim backed by an ultra disk, the pod becomes stuck in the <literal>ContainerCreating</literal> state and an alert is triggered.</simpara>
<simpara>For example, if the <literal>additionalCapabilities.ultraSSDEnabled</literal> parameter is not set on the machine that backs the node that hosts the pod, the following error message appears:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, describe the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n &lt;stuck_pod_namespace&gt; describe pod &lt;stuck_pod_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
</section>
<section xml:id="persistent-storage-using-azure-file">
<title>Persistent storage using Azure File</title>

<simpara>OpenShift Container Platform supports Microsoft Azure File volumes. You can
provision your OpenShift Container Platform cluster with persistent storage using Azure.
Some familiarity with Kubernetes and Azure is assumed.</simpara>
<simpara>The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure.
You can provision Azure File volumes dynamically.</simpara>
<simpara>Persistent volumes are not bound to a single project or namespace, and you can share them across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace, and can be requested by users for use in applications.</simpara>
<important>
<simpara>High availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<important>
<simpara>Azure File volumes use Server Message Block.</simpara>
</important>
<important>
<simpara>In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://azure.microsoft.com/en-us/services/storage/files/">Azure Files</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="create-azure-file-secret_persistent-storage-azure-file">
<title>Create the Azure File share persistent volume claim</title>
<simpara>To create the persistent volume claim, you must first define a <literal>Secret</literal> object that contains the Azure account and key. This secret is used in the <literal>PersistentVolume</literal> definition, and will be referenced by the persistent volume claim for use in applications.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An Azure File share exists.</simpara>
</listitem>
<listitem>
<simpara>The credentials to access this share, specifically the storage account and
key, are available.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>Secret</literal> object that contains the Azure File credentials:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create secret generic &lt;secret-name&gt; --from-literal=azurestorageaccountname=&lt;storage-account&gt; \ <co xml:id="CO15-1"/>
  --from-literal=azurestorageaccountkey=&lt;storage-account-key&gt; <co xml:id="CO15-2"/></programlisting>
<calloutlist>
<callout arearefs="CO15-1">
<para>The Azure File storage account name.</para>
</callout>
<callout arearefs="CO15-2">
<para>The Azure File storage account key.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>PersistentVolume</literal> object that references the <literal>Secret</literal> object you created:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "PersistentVolume"
metadata:
  name: "pv0001" <co xml:id="CO16-1"/>
spec:
  capacity:
    storage: "5Gi" <co xml:id="CO16-2"/>
  accessModes:
    - "ReadWriteOnce"
  storageClassName: azure-file-sc
  azureFile:
    secretName: &lt;secret-name&gt; <co xml:id="CO16-3"/>
    shareName: share-1 <co xml:id="CO16-4"/>
    readOnly: false</programlisting>
<calloutlist>
<callout arearefs="CO16-1">
<para>The name of the persistent volume.</para>
</callout>
<callout arearefs="CO16-2">
<para>The size of this persistent volume.</para>
</callout>
<callout arearefs="CO16-3">
<para>The name of the secret that contains the Azure File share credentials.</para>
</callout>
<callout arearefs="CO16-4">
<para>The name of the Azure File share.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a <literal>PersistentVolumeClaim</literal> object that maps to the persistent volume you created:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "PersistentVolumeClaim"
metadata:
  name: "claim1" <co xml:id="CO17-1"/>
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "5Gi" <co xml:id="CO17-2"/>
  storageClassName: azure-file-sc <co xml:id="CO17-3"/>
  volumeName: "pv0001" <co xml:id="CO17-4"/></programlisting>
<calloutlist>
<callout arearefs="CO17-1">
<para>The name of the persistent volume claim.</para>
</callout>
<callout arearefs="CO17-2">
<para>The size of this persistent volume claim.</para>
</callout>
<callout arearefs="CO17-3">
<para>The name of the storage class that is used to provision the persistent volume.
Specify the storage class used in the <literal>PersistentVolume</literal> definition.</para>
</callout>
<callout arearefs="CO17-4">
<para>The name of the existing <literal>PersistentVolume</literal> object that references the
Azure File share.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="create-azure-file-pod_persistent-storage-azure-file">
<title>Mount the Azure File share in a pod</title>
<simpara>After the persistent volume claim has been created, it can be used inside by an application. The following example demonstrates mounting this share inside of a pod.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A persistent volume claim exists that is mapped to the underlying Azure File share.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a pod that mounts the existing persistent volume claim:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-name <co xml:id="CO18-1"/>
spec:
  containers:
    ...
    volumeMounts:
    - mountPath: "/data" <co xml:id="CO18-2"/>
      name: azure-file-share
  volumes:
    - name: azure-file-share
      persistentVolumeClaim:
        claimName: claim1 <co xml:id="CO18-3"/></programlisting>
<calloutlist>
<callout arearefs="CO18-1">
<para>The name of the pod.</para>
</callout>
<callout arearefs="CO18-2">
<para>The path to mount the Azure File share inside the pod. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
<callout arearefs="CO18-3">
<para>The name of the <literal>PersistentVolumeClaim</literal> object that has been previously created.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-cinder">
<title>Persistent storage using Cinder</title>

<simpara>OpenShift Container Platform supports OpenStack Cinder.  Some familiarity with Kubernetes and OpenStack is assumed.</simpara>
<simpara>Cinder volumes can be provisioned dynamically.
Persistent volumes are not bound to a single project or namespace; they can be
shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be
requested by users.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision Cinder storage.</simpara>
<simpara>In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>For more information about how OpenStack Block Storage provides persistent block storage management for virtual hard drives, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/8/html-single/architecture_guide/index#comp-cinder">OpenStack Cinder</link>.</simpara>
</listitem>
</itemizedlist>
<section xml:id="persistent-storage-cinder-provisioning_persistent-storage-cinder">
<title>Manual provisioning with Cinder</title>
<simpara>Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>OpenShift Container Platform configured for Red Hat OpenStack Platform (RHOSP)</simpara>
</listitem>
<listitem>
<simpara>Cinder volume ID</simpara>
</listitem>
</itemizedlist>
<section xml:id="persistent-storage-cinder-creating-pv_persistent-storage-cinder">
<title>Creating the persistent volume</title>
<simpara>You must define your persistent volume (PV) in an object definition before creating
it in OpenShift Container Platform:</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Save your object definition to a file.</simpara>
<formalpara>
<title>cinder-persistentvolume.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "v1"
kind: "PersistentVolume"
metadata:
  name: "pv0001" <co xml:id="CO19-1"/>
spec:
  capacity:
    storage: "5Gi" <co xml:id="CO19-2"/>
  accessModes:
    - "ReadWriteOnce"
  cinder: <co xml:id="CO19-3"/>
    fsType: "ext3" <co xml:id="CO19-4"/>
    volumeID: "f37a03aa-6212-4c62-a805-9ce139fab180" <co xml:id="CO19-5"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO19-1">
<para>The name of the volume that is used by persistent volume claims or pods.</para>
</callout>
<callout arearefs="CO19-2">
<para>The amount of storage allocated to this volume.</para>
</callout>
<callout arearefs="CO19-3">
<para>Indicates <literal>cinder</literal> for Red Hat OpenStack Platform (RHOSP) Cinder volumes.</para>
</callout>
<callout arearefs="CO19-4">
<para>The file system that is created when the volume is mounted for the first time.</para>
</callout>
<callout arearefs="CO19-5">
<para>The Cinder volume to use.</para>
</callout>
</calloutlist>
<important>
<simpara>Do not change the <literal>fstype</literal> parameter value after the volume is formatted and
provisioned. Changing this value can result in data loss and pod failure.</simpara>
</important>
</listitem>
<listitem>
<simpara>Create the object definition file you saved in the previous step.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cinder-persistentvolume.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-cinder-pv-format_persistent-storage-cinder">
<title>Persistent volume formatting</title>
<simpara>You can use unformatted Cinder volumes as PVs because
OpenShift Container Platform formats them before the first use.</simpara>
<simpara>Before OpenShift Container Platform mounts the volume and passes it to a container, the system checks that it contains a file system as specified by the <literal>fsType</literal> parameter in the
PV definition. If the device is not formatted with the file system, all data from the device is erased and the device is automatically formatted with the given file system.</simpara>
</section>
<section xml:id="persistent-storage-cinder-volume-security_persistent-storage-cinder">
<title>Cinder volume security</title>
<simpara>If you use Cinder PVs in your application, configure security for their
deployment configurations.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>An SCC must be created that uses the appropriate <literal>fsGroup</literal> strategy.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a service account and add it to the SCC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create serviceaccount &lt;service_account&gt;</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-scc-to-user &lt;new_scc&gt; -z &lt;service_account&gt; -n &lt;project&gt;</programlisting>
</listitem>
<listitem>
<simpara>In your application&#8217;s deployment configuration, provide the service account
name and <literal>securityContext</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: ReplicationController
metadata:
  name: frontend-1
spec:
  replicas: 1  <co xml:id="CO20-1"/>
  selector:    <co xml:id="CO20-2"/>
    name: frontend
  template:    <co xml:id="CO20-3"/>
    metadata:
      labels:  <co xml:id="CO20-4"/>
        name: frontend <co xml:id="CO20-5"/>
    spec:
      containers:
      - image: openshift/hello-openshift
        name: helloworld
        ports:
        - containerPort: 8080
          protocol: TCP
      restartPolicy: Always
      serviceAccountName: &lt;service_account&gt; <co xml:id="CO20-6"/>
      securityContext:
        fsGroup: 7777 <co xml:id="CO20-7"/></programlisting>
<calloutlist>
<callout arearefs="CO20-1">
<para>The number of copies of the pod to run.</para>
</callout>
<callout arearefs="CO20-2">
<para>The label selector of the pod to run.</para>
</callout>
<callout arearefs="CO20-3">
<para>A template for the pod that the controller creates.</para>
</callout>
<callout arearefs="CO20-4">
<para>The labels on the pod. They must include labels from the label selector.</para>
</callout>
<callout arearefs="CO20-5">
<para>The maximum name length after expanding any parameters is 63 characters.</para>
</callout>
<callout arearefs="CO20-6">
<para>Specifies the service account you created.</para>
</callout>
<callout arearefs="CO20-7">
<para>Specifies an <literal>fsGroup</literal> for the pods.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="persistent-storage-using-fibre">
<title>Persistent storage using Fibre Channel</title>

<simpara>OpenShift Container Platform supports Fibre Channel, allowing you to provision your
OpenShift Container Platform cluster with persistent storage using Fibre channel volumes.
Some familiarity with Kubernetes and Fibre Channel is assumed.</simpara>
<important>
<simpara>Persistent storage using Fibre Channel is not supported on ARM architecture based infrastructures.</simpara>
</important>
<simpara>The Kubernetes persistent volume framework allows administrators to provision a
cluster with persistent storage and gives users a way to request those
resources without having any knowledge of the underlying infrastructure.
Persistent volumes are not bound to a single project or namespace; they can be
shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be
requested by users.</simpara>
<important>
<simpara>High availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_storage_devices/using-fibre-channel-devices_managing-storage-devices">Using Fibre Channel devices</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="provisioning-fibre_persistent-storage-fibre">
<title>Provisioning</title>
<simpara>To provision Fibre Channel volumes using the <literal>PersistentVolume</literal> API
the following must be available:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>targetWWNs</literal> (array of Fibre Channel target&#8217;s World Wide
Names).</simpara>
</listitem>
<listitem>
<simpara>A valid LUN number.</simpara>
</listitem>
<listitem>
<simpara>The filesystem type.</simpara>
</listitem>
</itemizedlist>
<simpara>A persistent volume and a LUN have a one-to-one mapping between them.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Fibre Channel LUNs must exist in the underlying infrastructure.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title><literal>PersistentVolume</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  fc:
    wwids: [scsi-3600508b400105e210000900000490000] <co xml:id="CO21-1"/>
    targetWWNs: ['500a0981891b8dc5', '500a0981991b8dc5'] <co xml:id="CO21-2"/>
    lun: 2 <co xml:id="CO21-3"/>
    fsType: ext4</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO21-1">
<para>World wide identifiers (WWIDs). Either FC <literal><emphasis role="strong">wwids</emphasis></literal> or a combination of FC <literal><emphasis role="strong">targetWWNs</emphasis></literal> and <literal><emphasis role="strong">lun</emphasis></literal> must be set, but not both simultaneously. The FC WWID identifier is recommended over the WWNs target because it is guaranteed to be unique for every storage device, and independent of the path that is used to access the device. The WWID identifier can be obtained by issuing a SCSI Inquiry to retrieve the Device Identification Vital Product Data (<literal><emphasis role="strong">page 0x83</emphasis></literal>) or Unit Serial Number (<literal><emphasis role="strong">page 0x80</emphasis></literal>). FC WWIDs are identified as <literal><emphasis role="strong">/dev/disk/by-id/</emphasis></literal> to reference the data on the disk, even if the path to the device changes and even when accessing the device from different systems.</para>
</callout>
<callout arearefs="CO21-2 CO21-3">
<para>Fibre Channel WWNs are identified as
<literal>/dev/disk/by-path/pci-&lt;IDENTIFIER&gt;-fc-0x&lt;WWN&gt;-lun-&lt;LUN#&gt;</literal>,
but you do not need to provide any part of the path leading up to the <literal>WWN</literal>,
including the <literal>0x</literal>, and anything after, including the <literal>-</literal> (hyphen).</para>
</callout>
</calloutlist>
<important>
<simpara>Changing the value of the <literal>fstype</literal> parameter after the volume has been
formatted and provisioned can result in data loss and pod failure.</simpara>
</important>
<section xml:id="enforcing-disk-quota_persistent-storage-fibre">
<title>Enforcing disk quotas</title>
<simpara>Use LUN partitions to enforce disk quotas and size constraints.
Each LUN is mapped to a single persistent volume, and unique
names must be used for persistent volumes.</simpara>
<simpara>Enforcing quotas in this way allows the end user to request persistent storage
by a specific amount, such as 10Gi, and be matched with a corresponding volume
of equal or greater capacity.</simpara>
</section>
<section xml:id="fibre-volume-security_persistent-storage-fibre">
<title>Fibre Channel volume security</title>
<simpara>Users request storage with a persistent volume claim. This claim only lives in
the user&#8217;s namespace, and can only be referenced by a pod within that same
namespace. Any attempt to access a persistent volume across a namespace causes
the pod to fail.</simpara>
<simpara>Each Fibre Channel LUN must be accessible by all nodes in the cluster.</simpara>
</section>
</section>
</section>
<section xml:id="persistent-storage-using-flexvolume">
<title>Persistent storage using FlexVolume</title>

<important>
<simpara>FlexVolume is a deprecated feature. Deprecated functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.</simpara>
<simpara>Out-of-tree Container Storage Interface (CSI) driver is the recommended way to write volume drivers in OpenShift Container Platform. Maintainers of FlexVolume drivers should implement a CSI driver and move users of FlexVolume to CSI. Users of FlexVolume should move their workloads to CSI driver.</simpara>
<simpara>For the most recent list of major functionality that has been deprecated or removed within OpenShift Container Platform, refer to the <emphasis>Deprecated and removed features</emphasis> section of the OpenShift Container Platform release notes.</simpara>
</important>
<simpara>OpenShift Container Platform supports FlexVolume, an out-of-tree plugin that uses an executable model to interface with drivers.</simpara>
<simpara>To use storage from a back-end that does not have a built-in plugin, you can extend OpenShift Container Platform through FlexVolume drivers and provide persistent storage to applications.</simpara>
<simpara>Pods interact with FlexVolume drivers through the <literal>flexvolume</literal> in-tree plugin.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="expanding-persistent-volumes">Expanding persistent volumes</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="flexvolume-drivers_persistent-storage-flexvolume">
<title>About FlexVolume drivers</title>
<simpara>A FlexVolume driver is an executable file that resides in a well-defined directory on all nodes in the cluster. OpenShift Container Platform calls the FlexVolume driver whenever it needs to mount or unmount a volume represented by a <literal>PersistentVolume</literal> object with <literal>flexVolume</literal> as the source.</simpara>
<important>
<simpara>Attach and detach operations are not supported in OpenShift Container Platform for FlexVolume.</simpara>
</important>
</section>
<section xml:id="flexvolume-driver-example_persistent-storage-flexvolume">
<title>FlexVolume driver example</title>
<simpara>The first command-line argument of the FlexVolume driver is always an operation name. Other parameters are specific to each operation. Most of the operations take a JavaScript Object Notation (JSON) string as a parameter. This parameter is a complete JSON string, and not the name of a file with the JSON data.</simpara>
<simpara>The FlexVolume driver contains:</simpara>
<itemizedlist>
<listitem>
<simpara>All <literal>flexVolume.options</literal>.</simpara>
</listitem>
<listitem>
<simpara>Some options from <literal>flexVolume</literal> prefixed by <literal>kubernetes.io/</literal>, such as <literal>fsType</literal> and <literal>readwrite</literal>.</simpara>
</listitem>
<listitem>
<simpara>The content of the referenced secret, if specified, prefixed by <literal>kubernetes.io/secret/</literal>.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>FlexVolume driver JSON input example</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
	"fooServer": "192.168.0.1:1234", <co xml:id="CO22-1"/>
        "fooVolumeName": "bar",
	"kubernetes.io/fsType": "ext4", <co xml:id="CO22-2"/>
	"kubernetes.io/readwrite": "ro", <co xml:id="CO22-3"/>
	"kubernetes.io/secret/&lt;key name&gt;": "&lt;key value&gt;", <co xml:id="CO22-4"/>
	"kubernetes.io/secret/&lt;another key name&gt;": "&lt;another key value&gt;",
}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO22-1">
<para>All options from <literal>flexVolume.options</literal>.</para>
</callout>
<callout arearefs="CO22-2">
<para>The value of <literal>flexVolume.fsType</literal>.</para>
</callout>
<callout arearefs="CO22-3">
<para><literal>ro</literal>/<literal>rw</literal> based on <literal>flexVolume.readOnly</literal>.</para>
</callout>
<callout arearefs="CO22-4">
<para>All keys and their values from the secret referenced by <literal>flexVolume.secretRef</literal>.</para>
</callout>
</calloutlist>
<simpara>OpenShift Container Platform expects JSON data on standard output of the driver. When not
specified, the output describes the result of the operation.</simpara>
<formalpara>
<title>FlexVolume driver default output example</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
	"status": "&lt;Success/Failure/Not supported&gt;",
	"message": "&lt;Reason for success/failure&gt;"
}</programlisting>
</para>
</formalpara>
<simpara>Exit code of the driver should be <literal>0</literal> for success and <literal>1</literal> for error.</simpara>
<simpara>Operations should be idempotent, which means that the mounting of an already mounted volume should result in a successful operation.</simpara>
</section>
<section xml:id="flexvolume-installing_persistent-storage-flexvolume">
<title>Installing FlexVolume drivers</title>
<simpara>FlexVolume drivers that are used to extend OpenShift Container Platform are executed only on the node. To implement FlexVolumes, a list of operations to call and the installation path are all that is required.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>FlexVolume drivers must implement these operations:</simpara>
<variablelist>
<varlistentry>
<term><literal>init</literal></term>
<listitem>
<simpara>Initializes the driver. It is called during initialization of all nodes.</simpara>
<itemizedlist>
<listitem>
<simpara>Arguments: none</simpara>
</listitem>
<listitem>
<simpara>Executed on: node</simpara>
</listitem>
<listitem>
<simpara>Expected output: default JSON</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>mount</literal></term>
<listitem>
<simpara>Mounts a volume to directory. This can include anything that is necessary to mount the volume, including finding the device and then mounting the device.</simpara>
<itemizedlist>
<listitem>
<simpara>Arguments: <literal>&lt;mount-dir&gt;</literal> <literal>&lt;json&gt;</literal></simpara>
</listitem>
<listitem>
<simpara>Executed on: node</simpara>
</listitem>
<listitem>
<simpara>Expected output: default JSON</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>unmount</literal></term>
<listitem>
<simpara>Unmounts a volume from a directory. This can include anything that is necessary to clean up the volume after unmounting.</simpara>
<itemizedlist>
<listitem>
<simpara>Arguments: <literal>&lt;mount-dir&gt;</literal></simpara>
</listitem>
<listitem>
<simpara>Executed on: node</simpara>
</listitem>
<listitem>
<simpara>Expected output: default JSON</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>mountdevice</literal></term>
<listitem>
<simpara>Mounts a volume&#8217;s device to a directory where individual pods can then bind mount.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
<simpara>This call-out does not pass "secrets" specified in the FlexVolume spec. If your driver requires secrets, do not implement this call-out.</simpara>
<itemizedlist>
<listitem>
<simpara>Arguments: <literal>&lt;mount-dir&gt;</literal> <literal>&lt;json&gt;</literal></simpara>
</listitem>
<listitem>
<simpara>Executed on: node</simpara>
</listitem>
<listitem>
<simpara>Expected output: default JSON</simpara>
<variablelist>
<varlistentry>
<term><literal>unmountdevice</literal></term>
<listitem>
<simpara>Unmounts a volume&#8217;s device from a directory.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
<listitem>
<simpara>Arguments: <literal>&lt;mount-dir&gt;</literal></simpara>
</listitem>
<listitem>
<simpara>Executed on: node</simpara>
</listitem>
<listitem>
<simpara>Expected output: default JSON</simpara>
<itemizedlist>
<listitem>
<simpara>All other operations should return JSON with <literal>{"status": "Not supported"}</literal> and exit code <literal>1</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the FlexVolume driver:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Ensure that the executable file exists on all nodes in the cluster.</simpara>
</listitem>
<listitem>
<simpara>Place the executable file at the volume plugin path:
<literal>/etc/kubernetes/kubelet-plugins/volume/exec/&lt;vendor&gt;~&lt;driver&gt;/&lt;driver&gt;</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>For example, to install the FlexVolume driver for the storage <literal>foo</literal>, place the
executable file at:
<literal>/etc/kubernetes/kubelet-plugins/volume/exec/openshift.com~foo/foo</literal>.</simpara>
</section>
<section xml:id="flexvolume-driver-consuming_persistent-storage-flexvolume">
<title>Consuming storage using FlexVolume drivers</title>
<simpara>Each <literal>PersistentVolume</literal> object in OpenShift Container Platform represents one storage asset in the storage back-end, such as a volume.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Use the <literal>PersistentVolume</literal> object to reference the installed storage.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Persistent volume object definition using FlexVolume drivers example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <co xml:id="CO23-1"/>
spec:
  capacity:
    storage: 1Gi <co xml:id="CO23-2"/>
  accessModes:
    - ReadWriteOnce
  flexVolume:
    driver: openshift.com/foo <co xml:id="CO23-3"/>
    fsType: "ext4" <co xml:id="CO23-4"/>
    secretRef: foo-secret <co xml:id="CO23-5"/>
    readOnly: true <co xml:id="CO23-6"/>
    options: <co xml:id="CO23-7"/>
      fooServer: 192.168.0.1:1234
      fooVolumeName: bar</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO23-1">
<para>The name of the volume. This is how it is identified through persistent volume claims or from pods. This name can be different from the name of the volume on
back-end storage.</para>
</callout>
<callout arearefs="CO23-2">
<para>The amount of storage allocated to this volume.</para>
</callout>
<callout arearefs="CO23-3">
<para>The name of the driver. This field is mandatory.</para>
</callout>
<callout arearefs="CO23-4">
<para>The file system that is present on the volume. This field is optional.</para>
</callout>
<callout arearefs="CO23-5">
<para>The reference to a secret. Keys and values from this secret are
provided to the FlexVolume driver on invocation. This field is optional.</para>
</callout>
<callout arearefs="CO23-6">
<para>The read-only flag. This field is optional.</para>
</callout>
<callout arearefs="CO23-7">
<para>The additional options for the FlexVolume driver. In addition to the flags specified by the user in the <literal>options</literal> field, the following flags are also passed to the executable:</para>
<literallayout class="monospaced">"fsType":"&lt;FS type&gt;",
"readwrite":"&lt;rw&gt;",
"secret/key1":"&lt;secret1&gt;"
...
"secret/keyN":"&lt;secretN&gt;"</literallayout>
</callout>
</calloutlist>
<note>
<simpara>Secrets are passed only to mount or unmount call-outs.</simpara>
</note>
</section>
</section>
<section xml:id="persistent-storage-using-gce">
<title>Persistent storage using GCE Persistent Disk</title>

<simpara>OpenShift Container Platform supports GCE Persistent Disk volumes (gcePD).
You can provision your OpenShift Container Platform cluster with persistent storage
using GCE.
Some familiarity with Kubernetes and GCE is assumed.</simpara>
<simpara>The Kubernetes persistent volume framework allows administrators to
provision a cluster with persistent storage and gives users a way to
request those resources without having any knowledge of the underlying
infrastructure.</simpara>
<simpara>GCE Persistent Disk volumes can be provisioned dynamically.</simpara>
<simpara>Persistent volumes are not bound to a single project or namespace;
they can be shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be
requested by users.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision gcePD storage.</simpara>
<simpara>In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plug-ins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes.
For more information about migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.</simpara>
</important>
<important>
<simpara>High availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/compute/docs/disks/">GCE Persistent Disk</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="storage-create-storage-class_persistent-storage-gce">
<title>Creating the GCE storage class</title>
<simpara>Storage classes are used to differentiate and delineate storage levels and
usages. By defining a storage class, users can obtain dynamically provisioned
persistent volumes.</simpara>
</section>
<section xml:id="_creating-the-persistent-volume-claim-3">
<title>Creating the persistent volume claim</title>
<formalpara>
<title>Prerequisites</title>
<para>Storage must exist in the underlying infrastructure before it can be mounted as
a volume in OpenShift Container Platform.</para>
</formalpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">Persistent Volume Claims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the persistent volume claims overview, click <emphasis role="strong">Create Persistent Volume
Claim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the desired options on the page that appears.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the previously-created storage class from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique name for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Select the access mode. This selection determines the read and write access for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Define the size of the storage claim.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the persistent volume claim and generate a persistent
volume.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="volume-format-GCE_persistent-storage-gce">
<title>Volume format</title>
<simpara>Before OpenShift Container Platform mounts the volume and passes it to a container, it
checks that the volume contains a file system as specified by the <literal>fsType</literal>
parameter in the persistent volume definition. If the device is not
formatted with the file system, all data from the device is erased and the
device is automatically formatted with the given file system.</simpara>
<simpara>This verification enables you to use unformatted GCE volumes as persistent volumes,
because OpenShift Container Platform formats them before the first use.</simpara>
</section>
</section>
<section xml:id="persistent-storage-using-iscsi">
<title>Persistent storage using iSCSI</title>

<simpara>You can provision your OpenShift Container Platform cluster with
persistent storage using
<link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/managing_storage_devices/index#getting-started-with-iscsi_managing-storage-devices">iSCSI</link>.
Some familiarity with Kubernetes and iSCSI is assumed.</simpara>
<simpara>The Kubernetes persistent volume framework allows administrators to
provision a cluster with persistent storage and gives users a way to
request those resources without having any knowledge of the
underlying infrastructure.</simpara>
<important>
<simpara>High-availability of storage in the infrastructure is left to the underlying
storage provider.</simpara>
</important>
<important>
<simpara>When you use iSCSI on Amazon Web Services, you must update the default
security policy to include TCP traffic between nodes on the iSCSI ports.
By default, they are ports <literal>860</literal> and <literal>3260</literal>.</simpara>
</important>
<important>
<simpara>Users must ensure that the iSCSI initiator is already configured on all
OpenShift Container Platform nodes by installing the <literal>iscsi-initiator-utils</literal>
package and configuring their initiator name in <literal>/etc/iscsi/initiatorname.iscsi</literal>.
The <literal>iscsi-initiator-utils</literal> package is already installed on deployments
that use Red Hat Enterprise Linux CoreOS (RHCOS).</simpara>
<simpara>For more information, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html-single/managing_storage_devices/index#configuring-an-iscsi-initiator_managing-storage-devices">Managing Storage Devices</link>.</simpara>
</important>
<section xml:id="persistent-storage-iscsi-provisioning_persistent-storage-iscsi">
<title>Provisioning</title>
<simpara>Verify that the storage exists in the underlying infrastructure before
mounting it as a volume in OpenShift Container Platform. All that is required for the
iSCSI is the iSCSI target portal, a valid iSCSI Qualified Name (IQN),
a valid LUN number, the filesystem type, and the <literal>PersistentVolume</literal> API.</simpara>
<formalpara>
<title><literal>PersistentVolume</literal> object definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
     targetPortal: 10.16.154.81:3260
     iqn: iqn.2014-12.example.server:storage.target00
     lun: 0
     fsType: 'ext4'</programlisting>
</para>
</formalpara>
</section>
<section xml:id="enforcing-disk-quotas-iscsi_persistent-storage-iscsi">
<title>Enforcing disk quotas</title>
<simpara>Use LUN partitions to enforce disk quotas and size constraints. Each LUN
is one persistent volume. Kubernetes enforces unique names for persistent
volumes.</simpara>
<simpara>Enforcing quotas in this way allows the end user to request persistent
storage by a specific amount (for example, <literal>10Gi</literal>) and be matched with a
corresponding volume of equal or greater capacity.</simpara>
</section>
<section xml:id="volume-security-iscsi_persistent-storage-iscsi">
<title>iSCSI volume security</title>
<simpara>Users request storage with a <literal>PersistentVolumeClaim</literal> object. This claim only
lives in the user&#8217;s namespace and can only be referenced by a pod within
that same namespace. Any attempt to access a persistent volume claim across a
namespace causes the pod to fail.</simpara>
<simpara>Each iSCSI LUN must be accessible by all nodes in the cluster.</simpara>
<section xml:id="_challenge-handshake-authentication-protocol-chap-configuration">
<title>Challenge Handshake Authentication Protocol (CHAP) configuration</title>
<simpara>Optionally, OpenShift Container Platform can use CHAP to authenticate itself to iSCSI targets:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    fsType: ext4
    chapAuthDiscovery: true <co xml:id="CO24-1"/>
    chapAuthSession: true <co xml:id="CO24-2"/>
    secretRef:
      name: chap-secret <co xml:id="CO24-3"/></programlisting>
<calloutlist>
<callout arearefs="CO24-1">
<para>Enable CHAP authentication of iSCSI discovery.</para>
</callout>
<callout arearefs="CO24-2">
<para>Enable CHAP authentication of iSCSI session.</para>
</callout>
<callout arearefs="CO24-3">
<para>Specify name of Secrets object with user name + password. This <literal>Secret</literal>
object must be available in all namespaces that can use the referenced volume.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="iscsi-multipath_persistent-storage-iscsi">
<title>iSCSI multipathing</title>
<simpara>For iSCSI-based storage, you can configure multiple paths by using the
same IQN for more than one target portal IP address. Multipathing ensures
access to the persistent volume when one or more of the components in a
path fail.</simpara>
<simpara>To specify multi-paths in the pod specification, use the <literal>portals</literal> field.
For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    portals: ['10.0.2.16:3260', '10.0.2.17:3260', '10.0.2.18:3260'] <co xml:id="CO25-1"/>
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    fsType: ext4
    readOnly: false</programlisting>
<calloutlist>
<callout arearefs="CO25-1">
<para>Add additional target portals using the <literal>portals</literal> field.</para>
</callout>
</calloutlist>
</section>
<section xml:id="iscsi-custom-iqn_persistent-storage-iscsi">
<title>iSCSI custom initiator IQN</title>
<simpara>Configure the custom initiator iSCSI Qualified Name (IQN) if the iSCSI
targets are restricted to certain IQNs, but the nodes that the iSCSI PVs
are attached to are not guaranteed to have these IQNs.</simpara>
<simpara>To specify a custom initiator IQN, use <literal>initiatorName</literal> field.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    portals: ['10.0.2.16:3260', '10.0.2.17:3260', '10.0.2.18:3260']
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    initiatorName: iqn.2016-04.test.com:custom.iqn <co xml:id="CO26-1"/>
    fsType: ext4
    readOnly: false</programlisting>
<calloutlist>
<callout arearefs="CO26-1">
<para>Specify the name of the initiator.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="persistent-storage-using-nfs">
<title>Persistent storage using NFS</title>

<simpara>OpenShift Container Platform clusters can be provisioned with persistent storage
using NFS. Persistent volumes (PVs) and persistent volume claims (PVCs)
provide a convenient method for sharing a volume across a project. While the
NFS-specific information contained in a PV definition could also be defined
directly in a <literal>Pod</literal> definition, doing so does not create the volume as a
distinct cluster resource, making the volume more susceptible to conflicts.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/managing_file_systems/mounting-nfs-shares_managing-file-systems">Mounting NFS shares</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="persistent-storage-nfs-provisioning_persistent-storage-nfs">
<title>Provisioning</title>
<simpara>Storage must exist in the underlying infrastructure before it can be
mounted as a volume in OpenShift Container Platform. To provision NFS volumes,
a list of NFS servers and export paths are all that is required.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create an object definition for the PV:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <co xml:id="CO27-1"/>
spec:
  capacity:
    storage: 5Gi <co xml:id="CO27-2"/>
  accessModes:
  - ReadWriteOnce <co xml:id="CO27-3"/>
  nfs: <co xml:id="CO27-4"/>
    path: /tmp <co xml:id="CO27-5"/>
    server: 172.17.0.2 <co xml:id="CO27-6"/>
  persistentVolumeReclaimPolicy: Retain <co xml:id="CO27-7"/></programlisting>
<calloutlist>
<callout arearefs="CO27-1">
<para>The name of the volume. This is the PV identity in various <literal>oc &lt;command&gt;
pod</literal> commands.</para>
</callout>
<callout arearefs="CO27-2">
<para>The amount of storage allocated to this volume.</para>
</callout>
<callout arearefs="CO27-3">
<para>Though this appears to be related to controlling access to the volume,
it is actually used similarly to labels and used to match a PVC to a PV.
Currently, no access rules are enforced based on the <literal>accessModes</literal>.</para>
</callout>
<callout arearefs="CO27-4">
<para>The volume type being used, in this case the <literal>nfs</literal> plugin.</para>
</callout>
<callout arearefs="CO27-5">
<para>The path that is exported by the NFS server.</para>
</callout>
<callout arearefs="CO27-6">
<para>The hostname or IP address of the NFS server.</para>
</callout>
<callout arearefs="CO27-7">
<para>The reclaim policy for the PV. This defines what happens to a volume
when released.</para>
</callout>
</calloutlist>
<note>
<simpara>Each NFS volume must be mountable by all schedulable nodes in the cluster.</simpara>
</note>
</listitem>
<listitem>
<simpara>Verify that the PV was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME     LABELS    CAPACITY     ACCESSMODES   STATUS      CLAIM  REASON    AGE
pv0001   &lt;none&gt;    5Gi          RWO           Available                    31s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a persistent volume claim that binds to the new PV:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-claim1
spec:
  accessModes:
    - ReadWriteOnce <co xml:id="CO28-1"/>
  resources:
    requests:
      storage: 5Gi <co xml:id="CO28-2"/>
  volumeName: pv0001
  storageClassName: ""</programlisting>
<calloutlist>
<callout arearefs="CO28-1">
<para>The access modes do not enforce security, but rather act as labels to match a PV to a PVC.</para>
</callout>
<callout arearefs="CO28-2">
<para>This claim looks for PVs offering <emphasis role="strong">5Gi</emphasis> or greater capacity.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Verify that the persistent volume claim was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME         STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
nfs-claim1   Bound    pv0001   5Gi        RWO                           2m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="nfs-enforcing-disk-quota_persistent-storage-nfs">
<title>Enforcing disk quotas</title>
<simpara>You can use disk partitions to enforce disk quotas and size constraints.
Each partition can be its own export. Each export is one PV.
OpenShift Container Platform enforces unique names for PVs, but the uniqueness of the
NFS volume&#8217;s server and path is up to the administrator.</simpara>
<simpara>Enforcing quotas in this way allows the developer to request persistent
storage by a specific amount, such as 10Gi, and be matched with a
corresponding volume of equal or greater capacity.</simpara>
</section>
<section xml:id="nfs-volume-security_persistent-storage-nfs">
<title>NFS volume security</title>
<simpara>This section covers NFS volume security, including matching permissions and
SELinux considerations. The user is expected to understand the basics of
POSIX permissions, process UIDs, supplemental groups, and SELinux.</simpara>
<simpara>Developers request NFS storage by referencing either a PVC by name or the
NFS volume plugin directly in the <literal>volumes</literal> section of their <literal>Pod</literal>
definition.</simpara>
<simpara>The <literal>/etc/exports</literal> file on the NFS server contains the accessible NFS
directories. The target NFS directory has POSIX owner and group IDs. The
OpenShift Container Platform NFS plugin mounts the container&#8217;s NFS directory with the
same POSIX ownership and permissions found on the exported NFS directory.
However, the container is not run with its effective UID equal to the
owner of the NFS mount, which is the desired behavior.</simpara>
<simpara>As an example, if the target NFS directory appears on the NFS server as:</simpara>
<programlisting xml:id="nfs-export" language="terminal" linenumbering="unnumbered">$ ls -lZ /opt/nfs -d</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">drwxrws---. nfsnobody 5555 unconfined_u:object_r:usr_t:s0   /opt/nfs</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">$ id nfsnobody</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">uid=65534(nfsnobody) gid=65534(nfsnobody) groups=65534(nfsnobody)</programlisting>
</para>
</formalpara>
<simpara>Then the container must match SELinux labels, and either run with a UID of
<literal>65534</literal>, the <literal>nfsnobody</literal> owner, or with <literal>5555</literal> in its supplemental groups to access the directory.</simpara>
<note>
<simpara>The owner ID of <literal>65534</literal> is used as an example. Even though NFS&#8217;s
<literal>root_squash</literal> maps <literal>root</literal>, uid <literal>0</literal>, to <literal>nfsnobody</literal>, uid <literal>65534</literal>, NFS
exports can have arbitrary owner IDs. Owner <literal>65534</literal> is not required
for NFS exports.</simpara>
</note>
<section xml:id="storage-persistent-storage-nfs-group-ids_persistent-storage-nfs">
<title>Group IDs</title>
<simpara>The recommended way to handle NFS access, assuming it is not an option to
change permissions on the NFS export, is to use supplemental groups.
Supplemental groups in OpenShift Container Platform are used for shared storage, of
which NFS is an example. In contrast, block storage such as
iSCSI uses the <literal>fsGroup</literal> SCC strategy and the <literal>fsGroup</literal> value in the <literal>securityContext</literal> of the pod.</simpara>
<note>
<simpara>To gain access to persistent storage, it is generally preferable to use supplemental group IDs versus user IDs.</simpara>
</note>
<simpara>Because the group ID on the example target NFS directory
is <literal>5555</literal>, the pod can define that group ID using <literal>supplementalGroups</literal>
under the <literal>securityContext</literal> definition of the pod. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers:
    - name:
    ...
  securityContext: <co xml:id="CO29-1"/>
    supplementalGroups: [5555] <co xml:id="CO29-2"/></programlisting>
<calloutlist>
<callout arearefs="CO29-1">
<para><literal>securityContext</literal> must be defined at the pod level, not under a
specific container.</para>
</callout>
<callout arearefs="CO29-2">
<para>An array of GIDs defined for the pod. In this case, there is
one element in the array. Additional GIDs would be comma-separated.</para>
</callout>
</calloutlist>
<simpara>Assuming there are no custom SCCs that might satisfy the pod
requirements, the pod likely matches the <literal>restricted</literal> SCC. This SCC has
the <literal>supplementalGroups</literal> strategy set to <literal>RunAsAny</literal>, meaning that any
supplied group ID is accepted without range checking.</simpara>
<simpara>As a result, the above pod passes admissions and is launched. However,
if group ID range checking is desired, a custom SCC is the preferred
solution. A custom SCC can be created such that minimum
and maximum group IDs are defined, group ID range checking is enforced,
and a group ID of <literal>5555</literal> is allowed.</simpara>
<note>
<simpara>To use a custom SCC, you must first add it to the appropriate service
account. For example, use the <literal>default</literal> service account in the given project
unless another has been specified on the <literal>Pod</literal> specification.</simpara>
</note>
</section>
<section xml:id="nfs-user-id_persistent-storage-nfs">
<title>User IDs</title>
<simpara>User IDs can be defined in the container image or in the <literal>Pod</literal> definition.</simpara>
<note>
<simpara>It is generally preferable to use supplemental group IDs to gain access to
persistent storage versus using user IDs.</simpara>
</note>
<simpara>In the example target NFS directory shown above, the container
needs its UID set to <literal>65534</literal>, ignoring group IDs for the moment, so the
following can be added to the <literal>Pod</literal> definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  containers: <co xml:id="CO30-1"/>
  - name:
  ...
    securityContext:
      runAsUser: 65534 <co xml:id="CO30-2"/></programlisting>
<calloutlist>
<callout arearefs="CO30-1">
<para>Pods contain a <literal>securityContext</literal> definition specific to each container and
a pod&#8217;s <literal>securityContext</literal> which applies to all containers defined in
the pod.</para>
</callout>
<callout arearefs="CO30-2">
<para><literal>65534</literal> is the <literal>nfsnobody</literal> user.</para>
</callout>
</calloutlist>
<simpara>Assuming that the project is <literal>default</literal> and the SCC is <literal>restricted</literal>, the user ID of <literal>65534</literal> as requested by the pod is not allowed. Therefore, the pod fails for the following reasons:</simpara>
<itemizedlist>
<listitem>
<simpara>It requests <literal>65534</literal> as its user ID.</simpara>
</listitem>
<listitem>
<simpara>All SCCs available to the pod are examined to see which SCC allows a
user ID of <literal>65534</literal>. While all policies of the SCCs are checked, the focus
here is on user ID.</simpara>
</listitem>
<listitem>
<simpara>Because all available SCCs use <literal>MustRunAsRange</literal> for their <literal>runAsUser</literal>
strategy, UID range checking is required.</simpara>
</listitem>
<listitem>
<simpara><literal>65534</literal> is not included in the SCC or project&#8217;s user ID range.</simpara>
</listitem>
</itemizedlist>
<simpara>It is generally considered a good practice not to modify the predefined
SCCs. The preferred way to fix this situation is to create a custom SCC
A custom SCC can be created such that minimum and maximum user IDs
are defined, UID range checking is still enforced, and the UID of <literal>65534</literal>
 is allowed.</simpara>
<note>
<simpara>To use a custom SCC, you must first add it to the appropriate service
account. For example, use the <literal>default</literal> service account in the given project
unless another has been specified on the <literal>Pod</literal> specification.</simpara>
</note>
</section>
<section xml:id="nfs-selinux_persistent-storage-nfs">
<title>SELinux</title>
<simpara>Red Hat Enterprise Linux (RHEL) and Red Hat Enterprise Linux CoreOS (RHCOS) systems are configured to use SELinux on remote NFS servers by default.</simpara>
<simpara>For non-RHEL and non-RHCOS systems, SELinux does not allow writing from a pod to a remote NFS server. The NFS volume mounts correctly but it is read-only. You will need to enable the correct SELinux permissions by using the following procedure.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The <literal>container-selinux</literal> package must be installed. This package provides the <literal>virt_use_nfs</literal> SELinux boolean.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Enable the <literal>virt_use_nfs</literal> boolean using the following command. The <literal>-P</literal> option makes this boolean persistent across reboots.</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># setsebool -P virt_use_nfs 1</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="_export-settings">
<title>Export settings</title>
<simpara>To enable arbitrary container users to read and write the volume,
each exported volume on the NFS server should conform to the following
conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>Every export must be exported using the following format:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">/&lt;example_fs&gt; *(rw,root_squash)</programlisting>
</listitem>
<listitem>
<simpara>The firewall must be configured to allow traffic to the mount point.</simpara>
<itemizedlist>
<listitem>
<simpara>For NFSv4, configure the default port <literal>2049</literal> (<emphasis role="strong">nfs</emphasis>).</simpara>
<formalpara>
<title>NFSv4</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># iptables -I INPUT 1 -p tcp --dport 2049 -j ACCEPT</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>For NFSv3, there are three ports to configure:
<literal>2049</literal> (<emphasis role="strong">nfs</emphasis>), <literal>20048</literal> (<emphasis role="strong">mountd</emphasis>), and <literal>111</literal> (<emphasis role="strong">portmapper</emphasis>).</simpara>
<formalpara>
<title>NFSv3</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered"># iptables -I INPUT 1 -p tcp --dport 2049 -j ACCEPT</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered"># iptables -I INPUT 1 -p tcp --dport 20048 -j ACCEPT</programlisting>
<programlisting language="terminal" linenumbering="unnumbered"># iptables -I INPUT 1 -p tcp --dport 111 -j ACCEPT</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The NFS export and directory must be set up so that they are accessible
by the target pods. Either set the export to be owned by the container&#8217;s
primary UID, or supply the pod group access using <literal>supplementalGroups</literal>,
as shown in the group IDs above.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="nfs-reclaiming-resources_persistent-storage-nfs">
<title>Reclaiming resources</title>
<simpara>NFS implements the OpenShift Container Platform <literal>Recyclable</literal> plugin interface. Automatic
processes handle reclamation tasks based on policies set on each persistent
volume.</simpara>
<simpara>By default, PVs are set to <literal>Retain</literal>.</simpara>
<simpara>Once claim to a PVC is deleted, and the PV is released, the PV object
should not be reused. Instead, a new PV should be created with the same
basic volume details as the original.</simpara>
<simpara>For example, the administrator creates a PV named <literal>nfs1</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs1
spec:
  capacity:
    storage: 1Mi
  accessModes:
    - ReadWriteMany
  nfs:
    server: 192.168.1.1
    path: "/"</programlisting>
<simpara>The user creates <literal>PVC1</literal>, which binds to <literal>nfs1</literal>. The user then deletes
<literal>PVC1</literal>, releasing claim to <literal>nfs1</literal>. This results in <literal>nfs1</literal> being <literal>Released</literal>.
If the administrator wants to make the same NFS share available,
they should create a new PV with the same NFS server details, but a
different PV name:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs2
spec:
  capacity:
    storage: 1Mi
  accessModes:
    - ReadWriteMany
  nfs:
    server: 192.168.1.1
    path: "/"</programlisting>
<simpara>Deleting the original PV and re-creating it with the same name is
discouraged. Attempting to manually change the status of a PV
from <literal>Released</literal> to <literal>Available</literal> causes errors and potential data loss.</simpara>
</section>
<section xml:id="_additional-configuration-and-troubleshooting">
<title>Additional configuration and troubleshooting</title>
<simpara>Depending on what version of NFS is being used and how it is configured,
there may be additional configuration steps needed for proper export and
security mapping. The following are some that may apply:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="66.6667*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>NFSv4 mount incorrectly shows all files with ownership of <literal>nobody:nobody</literal></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Could be attributed to the ID mapping settings, found in <literal>/etc/idmapd.conf</literal> on your NFS.</simpara>
</listitem>
<listitem>
<simpara>See <link xlink:href="https://access.redhat.com/solutions/33455">this Red Hat Solution</link>.</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Disabling ID mapping on NFSv4</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>On both the NFS client and server, run:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># echo 'Y' &gt; /sys/module/nfsd/parameters/nfs4_disable_idmapping</programlisting>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section xml:id="red-hat-openshift-data-foundation">
<title>Red Hat OpenShift Data Foundation</title>

<simpara>Red Hat OpenShift Data Foundation is a provider of agnostic persistent storage for OpenShift Container Platform supporting file, block, and object storage, either in-house or in hybrid clouds. As a Red Hat storage solution, Red Hat OpenShift Data Foundation is completely integrated with OpenShift Container Platform for deployment, management, and monitoring.</simpara>
<simpara>Red Hat OpenShift Data Foundation provides its own documentation library. The complete set of Red Hat OpenShift Data Foundation documentation is available at <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_openshift_data_foundation">https://access.redhat.com/documentation/en-us/red_hat_openshift_data_foundation</link>.</simpara>
<important>
<simpara>OpenShift Data Foundation on top of Red Hat Hyperconverged Infrastructure (RHHI) for Virtualization, which uses hyperconverged nodes that host virtual machines installed with OpenShift Container Platform, is not a supported configuration. For more information about supported platforms, see the <link xlink:href="https://access.redhat.com/articles/4731161">Red Hat OpenShift Data Foundation Supportability and Interoperability Guide</link>.</simpara>
</important>
</section>
<section xml:id="persistent-storage-using-vsphere">
<title>Persistent storage using VMware vSphere volumes</title>

<simpara>OpenShift Container Platform allows use of VMware vSphere&#8217;s Virtual Machine Disk (VMDK) volumes. You can provision your OpenShift Container Platform cluster with persistent storage using VMware vSphere. Some familiarity with Kubernetes and VMware vSphere is assumed.</simpara>
<simpara>VMware vSphere volumes can be provisioned dynamically. OpenShift Container Platform creates the disk in vSphere and attaches this disk to the correct image.</simpara>
<note>
<simpara>OpenShift Container Platform provisions new volumes as independent persistent disks that can freely attach and detach the volume on any node in the cluster. Consequently, you cannot back up volumes that use snapshots, or restore volumes from snapshots. See <link xlink:href="https://docs.vmware.com/en/VMware-vSphere/6.7/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html">Snapshot Limitations</link> for more information.</simpara>
</note>
<simpara>The Kubernetes persistent volume framework allows administrators to provision a
cluster with persistent storage and gives users a way to request those
resources without having any knowledge of the underlying infrastructure.</simpara>
<simpara>Persistent volumes are not bound to a single project or namespace; they can be
shared across the OpenShift Container Platform cluster.
Persistent volume claims are specific to a project or namespace and can be
requested by users.</simpara>
<important>
<simpara>For new installations, OpenShift Container Platform 4.13 and later provides automatic migration for the vSphere in-tree volume plugin to its equivalent CSI driver. Updating to OpenShift Container Platform 4.15 and later also provides automatic migration. For more information about updating and migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes.</simpara>
</important>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://www.vmware.com/au/products/vsphere.html">VMware vSphere</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="_dynamically-provisioning-vmware-vsphere-volumes">
<title>Dynamically provisioning VMware vSphere volumes</title>
<simpara>Dynamically provisioning VMware vSphere volumes is the recommended method.</simpara>
</section>
<section xml:id="_prerequisites">
<title>Prerequisites</title>
<itemizedlist>
<listitem>
<simpara>An OpenShift Container Platform cluster installed on a VMware vSphere version that meets the requirements for the components that you use. See <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#">Installing a cluster on vSphere</link> for information about vSphere version support.</simpara>
</listitem>
</itemizedlist>
<simpara>You can use either of the following procedures to dynamically provision these volumes using the default storage class.</simpara>
<section xml:id="vsphere-dynamic-provisioning_persistent-storage-efs">
<title>Dynamically provisioning VMware vSphere volumes using the UI</title>
<simpara>OpenShift Container Platform installs a default storage class, named <literal>thin</literal>, that uses the <literal>thin</literal> disk format for provisioning volumes.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> → <emphasis role="strong">Persistent Volume Claims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the persistent volume claims overview, click <emphasis role="strong">Create Persistent Volume Claim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the required options on the resulting page.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the <literal>thin</literal> storage class.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique name for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Select the access mode to determine the read and write access for the created storage claim.</simpara>
</listitem>
<listitem>
<simpara>Define the size of the storage claim.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the persistent volume claim and generate a persistent volume.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="vsphere-dynamic-provisioning-cli_persistent-storage-efs">
<title>Dynamically provisioning VMware vSphere volumes using the CLI</title>
<simpara>OpenShift Container Platform installs a default StorageClass, named <literal>thin</literal>, that uses the <literal>thin</literal> disk format for provisioning volumes.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure (CLI)</title>
<listitem>
<simpara>You can define a VMware vSphere PersistentVolumeClaim by creating a file, <literal>pvc.yaml</literal>, with the following contents:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pvc <co xml:id="CO31-1"/>
spec:
  accessModes:
  - ReadWriteOnce <co xml:id="CO31-2"/>
  resources:
    requests:
      storage: 1Gi <co xml:id="CO31-3"/></programlisting>
<calloutlist>
<callout arearefs="CO31-1">
<para>A unique name that represents the persistent volume claim.</para>
</callout>
<callout arearefs="CO31-2">
<para>The access mode of the persistent volume claim. With <literal>ReadWriteOnce</literal>, the volume can be mounted with read and write permissions by a single node.</para>
</callout>
<callout arearefs="CO31-3">
<para>The size of the persistent volume claim.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Enter the following command to create the <literal>PersistentVolumeClaim</literal> object from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc.yaml</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="vsphere-static-provisioning_persistent-storage-efs">
<title>Statically provisioning VMware vSphere volumes</title>
<simpara>To statically provision VMware vSphere volumes you must create the virtual machine disks for reference by the persistent volume framework.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the virtual machine disks. Virtual machine disks (VMDKs) must be created manually before statically provisioning VMware vSphere volumes. Use either of the following methods:</simpara>
<itemizedlist>
<listitem>
<simpara>Create using <literal>vmkfstools</literal>. Access ESX through Secure Shell (SSH) and then use following command to create a VMDK volume:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ vmkfstools -c &lt;size&gt; /vmfs/volumes/&lt;datastore-name&gt;/volumes/&lt;disk-name&gt;.vmdk</programlisting>
</listitem>
<listitem>
<simpara>Create using <literal>vmware-diskmanager</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ shell vmware-vdiskmanager -c -t 0 -s &lt;size&gt; -a lsilogic &lt;disk-name&gt;.vmdk</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Create a persistent volume that references the VMDKs. Create a file, <literal>pv1.yaml</literal>, with the <literal>PersistentVolume</literal> object definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv1 <co xml:id="CO32-1"/>
spec:
  capacity:
    storage: 1Gi <co xml:id="CO32-2"/>
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  vsphereVolume: <co xml:id="CO32-3"/>
    volumePath: "[datastore1] volumes/myDisk"  <co xml:id="CO32-4"/>
    fsType: ext4  <co xml:id="CO32-5"/></programlisting>
<calloutlist>
<callout arearefs="CO32-1">
<para>The name of the volume. This name is how it is identified by persistent volume claims or pods.</para>
</callout>
<callout arearefs="CO32-2">
<para>The amount of storage allocated to this volume.</para>
</callout>
<callout arearefs="CO32-3">
<para>The volume type used, with <literal>vsphereVolume</literal> for vSphere volumes. The label is used to mount a vSphere VMDK volume into pods. The contents of a volume are preserved when it is unmounted. The volume type supports VMFS and VSAN datastore.</para>
</callout>
<callout arearefs="CO32-4">
<para>The existing VMDK volume to use. If you used <literal>vmkfstools</literal>, you must enclose the datastore name in square brackets, <literal>[]</literal>, in the volume definition, as shown previously.</para>
</callout>
<callout arearefs="CO32-5">
<para>The file system type to mount. For example, ext4, xfs, or other file systems.</para>
</callout>
</calloutlist>
<important>
<simpara>Changing the value of the fsType parameter after the volume is formatted and provisioned can result in data loss and pod failure.</simpara>
</important>
</listitem>
<listitem>
<simpara>Create the <literal>PersistentVolume</literal> object from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pv1.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a persistent volume claim that maps to the persistent volume you created in the previous step.  Create a file, <literal>pvc1.yaml</literal>, with the <literal>PersistentVolumeClaim</literal> object definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc1 <co xml:id="CO33-1"/>
spec:
  accessModes:
    - ReadWriteOnce <co xml:id="CO33-2"/>
  resources:
   requests:
     storage: "1Gi" <co xml:id="CO33-3"/>
  volumeName: pv1 <co xml:id="CO33-4"/></programlisting>
<calloutlist>
<callout arearefs="CO33-1">
<para>A unique name that represents the persistent volume claim.</para>
</callout>
<callout arearefs="CO33-2">
<para>The access mode of the persistent volume claim. With ReadWriteOnce, the volume can be mounted with read and write permissions by a single node.</para>
</callout>
<callout arearefs="CO33-3">
<para>The size of the persistent volume claim.</para>
</callout>
<callout arearefs="CO33-4">
<para>The name of the existing persistent volume.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>PersistentVolumeClaim</literal> object from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc1.yaml</programlisting>
</listitem>
</orderedlist>
<section xml:id="vsphere-formatting-volumes_persistent-storage-efs">
<title>Formatting VMware vSphere volumes</title>
<simpara>Before OpenShift Container Platform mounts the volume and passes it to a container, it checks that the volume contains a file system that is specified by the <literal>fsType</literal> parameter value in the <literal>PersistentVolume</literal> (PV) definition. If the device is not formatted with the file system, all data from the device is erased, and the device is automatically formatted with the specified file system.</simpara>
<simpara>Because OpenShift Container Platform formats them before the first use, you can use unformatted vSphere volumes as PVs.</simpara>
</section>
</section>
</section>
<section xml:id="_persistent-storage-using-local-storage">
<title>Persistent storage using local storage</title>
<section xml:id="persistent-storage-using-local-volume">
<title>Persistent storage using local volumes</title>

<simpara>OpenShift Container Platform can be provisioned with persistent storage by using
local volumes. Local persistent volumes allow you to access local storage
devices, such as a disk or partition, by using the standard
persistent volume claim interface.</simpara>
<simpara>Local volumes can be used without manually scheduling pods to nodes
because the system is aware of the volume node constraints. However,
local volumes are still subject to the availability of the underlying node
and are not suitable for all applications.</simpara>
<note>
<simpara>Local volumes can only be used as a statically created persistent volume.</simpara>
</note>
<section xml:id="local-storage-install_persistent-storage-local">
<title>Installing the Local Storage Operator</title>
<simpara>The Local Storage Operator is not installed in OpenShift Container Platform by default. Use the following procedure to install and configure this Operator to enable local volumes in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console or command-line interface (CLI).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>openshift-local-storage</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm new-project openshift-local-storage</programlisting>
</listitem>
<listitem>
<simpara>Optional: Allow local storage creation on infrastructure nodes.</simpara>
<simpara>You might want to use the Local Storage Operator to create volumes on infrastructure nodes in support of components such as logging and monitoring.</simpara>
<simpara>You must adjust the default node selector so that the Local Storage Operator includes the infrastructure nodes, and not just worker nodes.</simpara>
<simpara>To block the Local Storage Operator from inheriting the cluster-wide default selector, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate namespace openshift-local-storage openshift.io/node-selector=''</programlisting>
</listitem>
<listitem>
<simpara>Optional: Allow local storage to run on the management pool of CPUs in single-node deployment.</simpara>
<simpara>Use the Local Storage Operator in single-node deployments and allow the use of CPUs that belong to the <literal>management</literal> pool. Perform this step on single-node installations that use management workload partitioning.</simpara>
<simpara>To allow Local Storage Operator to run on the management CPU pool, run following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc annotate namespace openshift-local-storage workload.openshift.io/allowed='management'</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>From the UI</title>
<para>To install the Local Storage Operator from the web console, follow these steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">Local Storage</emphasis> into the filter box to locate the Local Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, select <emphasis role="strong">A specific namespace on the cluster</emphasis>. Select <emphasis role="strong">openshift-local-storage</emphasis> from the drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Adjust the values for <emphasis role="strong">Update Channel</emphasis> and <emphasis role="strong">Approval Strategy</emphasis> to the values that you want.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<simpara>Once finished, the Local Storage Operator will be listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
<orderedlist numeration="arabic">
<title>From the CLI</title>
<listitem>
<simpara>Install the Local Storage Operator from the CLI.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an object YAML file to define an Operator group and subscription for the Local Storage Operator,
such as <literal>openshift-local-storage.yaml</literal>:</simpara>
<formalpara>
<title>Example openshift-local-storage.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: local-operator-group
  namespace: openshift-local-storage
spec:
  targetNamespaces:
    - openshift-local-storage
---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: local-storage-operator
  namespace: openshift-local-storage
spec:
  channel: stable
  installPlanApproval: Automatic <co xml:id="CO34-1"/>
  name: local-storage-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO34-1">
<para>The user approval policy for an install plan.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the Local Storage Operator object by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f openshift-local-storage.yaml</programlisting>
<simpara>At this point, the Operator Lifecycle Manager (OLM) is now aware of the Local Storage Operator. A ClusterServiceVersion (CSV) for the Operator should appear in the target namespace, and APIs provided by the Operator should be available for creation.</simpara>
</listitem>
<listitem>
<simpara>Verify local storage installation by checking that all pods and the Local Storage Operator have been created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Check that all the required pods have been created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n openshift-local-storage get pods</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                      READY   STATUS    RESTARTS   AGE
local-storage-operator-746bf599c9-vlt5t   1/1     Running   0          19m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check the ClusterServiceVersion (CSV) YAML manifest to see that the Local Storage Operator is available in the <literal>openshift-local-storage</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csvs -n openshift-local-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                         DISPLAY         VERSION               REPLACES   PHASE
local-storage-operator.4.2.26-202003230335   Local Storage   4.2.26-202003230335              Succeeded</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>After all checks have passed, the Local Storage Operator is installed successfully.</simpara>
</section>
<section xml:id="local-volume-cr_persistent-storage-local">
<title>Provisioning local volumes by using the Local Storage Operator</title>
<simpara>Local volumes cannot be created by dynamic provisioning. Instead, persistent volumes can be created by the Local Storage Operator. The local volume provisioner looks for any file system or block volume devices at the paths specified in the defined resource.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Local Storage Operator is installed.</simpara>
</listitem>
<listitem>
<simpara>You have a local disk that meets the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>It is attached to a node.</simpara>
</listitem>
<listitem>
<simpara>It is not mounted.</simpara>
</listitem>
<listitem>
<simpara>It does not contain partitions.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the local volume resource. This resource must define the nodes and paths to the local volumes.</simpara>
<note>
<simpara>Do not use different storage class names for the same device. Doing so will create multiple persistent volumes (PVs).</simpara>
</note>
<formalpara>
<title>Example: Filesystem</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "local.storage.openshift.io/v1"
kind: "LocalVolume"
metadata:
  name: "local-disks"
  namespace: "openshift-local-storage" <co xml:id="CO35-1"/>
spec:
  nodeSelector: <co xml:id="CO35-2"/>
    nodeSelectorTerms:
    - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - ip-10-0-140-183
          - ip-10-0-158-139
          - ip-10-0-164-33
  storageClassDevices:
    - storageClassName: "local-sc" <co xml:id="CO35-3"/>
      forceWipeDevicesAndDestroyAllData: false <co xml:id="CO35-4"/>
      volumeMode: Filesystem <co xml:id="CO35-5"/>
      fsType: xfs <co xml:id="CO35-6"/>
      devicePaths: <co xml:id="CO35-7"/>
        - /path/to/device <co xml:id="CO35-8"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO35-1">
<para>The namespace where the Local Storage Operator is installed.</para>
</callout>
<callout arearefs="CO35-2">
<para>Optional: A node selector containing a list of nodes where the local storage volumes are attached. This example uses the node hostnames, obtained from <literal>oc get node</literal>. If a value is not defined, then the Local Storage Operator will attempt to find matching disks on all available nodes.</para>
</callout>
<callout arearefs="CO35-3">
<para>The name of the storage class to use when creating persistent volume objects. The Local Storage Operator automatically creates the storage class if it does not exist. Be sure to use a storage class that uniquely identifies this set of local volumes.</para>
</callout>
<callout arearefs="CO35-4">
<para>This setting defines whether or not to call <literal>wipefs</literal>, which removes partition table signatures (magic strings) making the disk ready to use for Local Storage Operator (LSO) provisioning. No other data besides signatures is erased. The default is "false" (<literal>wipefs</literal> is not invoked). Setting <literal>forceWipeDevicesAndDestroyAllData</literal> to "true" can be useful in scenarios where previous data can remain on disks that need to be re-used. In these scenarios, setting this field to true eliminates the need for administrators to erase the disks manually. Such cases can include single-node OpenShift (SNO) cluster environments where a node can be redeployed multiple times or when using OpenShift Data Foundation (ODF), where previous data can remain on the disks planned to be consumed as object storage devices (OSDs).</para>
</callout>
<callout arearefs="CO35-5">
<para>The volume mode, either <literal>Filesystem</literal> or <literal>Block</literal>, that defines the type of local volumes.</para>
<note>
<simpara>A raw block volume (<literal>volumeMode: Block</literal>) is not formatted with a file system. Use this mode only if any application running on the pod can use raw block devices.</simpara>
</note>
</callout>
<callout arearefs="CO35-6">
<para>The file system that is created when the local volume is mounted for the first time.</para>
</callout>
<callout arearefs="CO35-7">
<para>The path containing a list of local storage devices to choose from.</para>
</callout>
<callout arearefs="CO35-8">
<para>Replace this value with your actual local disks filepath to the <literal>LocalVolume</literal> resource <literal>by-id</literal>, such as <literal>/dev/disk/by-id/wwn</literal>. PVs are created for these local disks when the provisioner is deployed successfully.</para>
<note>
<simpara>If you are running OpenShift Container Platform with RHEL KVM, you must assign a serial number to your VM disk. Otherwise, the VM disk can not be identified after reboot. You can use the <literal>virsh edit &lt;VM&gt;</literal> command to add the <literal>&lt;serial&gt;mydisk&lt;/serial&gt;</literal> definition.</simpara>
</note>
</callout>
</calloutlist>
<formalpara>
<title>Example: Block</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: "local.storage.openshift.io/v1"
kind: "LocalVolume"
metadata:
  name: "local-disks"
  namespace: "openshift-local-storage" <co xml:id="CO36-1"/>
spec:
  nodeSelector: <co xml:id="CO36-2"/>
    nodeSelectorTerms:
    - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - ip-10-0-136-143
          - ip-10-0-140-255
          - ip-10-0-144-180
  storageClassDevices:
    - storageClassName: "localblock-sc" <co xml:id="CO36-3"/>
      forceWipeDevicesAndDestroyAllData: false <co xml:id="CO36-4"/>
      volumeMode: Block <co xml:id="CO36-5"/>
      devicePaths: <co xml:id="CO36-6"/>
        - /path/to/device <co xml:id="CO36-7"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO36-1">
<para>The namespace where the Local Storage Operator is installed.</para>
</callout>
<callout arearefs="CO36-2">
<para>Optional: A node selector containing a list of nodes where the local storage volumes are attached. This example uses the node hostnames, obtained from <literal>oc get node</literal>. If a value is not defined, then the Local Storage Operator will attempt to find matching disks on all available nodes.</para>
</callout>
<callout arearefs="CO36-3">
<para>The name of the storage class to use when creating persistent volume objects.</para>
</callout>
<callout arearefs="CO36-4">
<para>This setting defines whether or not to call <literal>wipefs</literal>, which removes partition table signatures (magic strings) making the disk ready to use for Local Storage Operator (LSO) provisioning. No other data besides signatures is erased. The default is "false" (<literal>wipefs</literal> is not invoked). Setting <literal>forceWipeDevicesAndDestroyAllData</literal> to "true" can be useful in scenarios where previous data can remain on disks that need to be re-used. In these scenarios, setting this field to true eliminates the need for administrators to erase the disks manually. Such cases can include single-node OpenShift (SNO) cluster environments where a node can be redeployed multiple times or when using OpenShift Data Foundation (ODF), where previous data can remain on the disks planned to be consumed as object storage devices (OSDs).</para>
</callout>
<callout arearefs="CO36-5">
<para>The volume mode, either <literal>Filesystem</literal> or <literal>Block</literal>, that defines the type of local volumes.</para>
</callout>
<callout arearefs="CO36-6">
<para>The path containing a list of local storage devices to choose from.</para>
</callout>
<callout arearefs="CO36-7">
<para>Replace this value with your actual local disks filepath to the <literal>LocalVolume</literal> resource <literal>by-id</literal>, such as <literal>dev/disk/by-id/wwn</literal>. PVs are created for these local disks when the provisioner is deployed successfully.</para>
</callout>
</calloutlist>
<note>
<simpara>If you are running OpenShift Container Platform with RHEL KVM, you must assign a serial number to your VM disk. Otherwise, the VM disk can not be identified after reboot. You can use the <literal>virsh edit &lt;VM&gt;</literal> command to add the <literal>&lt;serial&gt;mydisk&lt;/serial&gt;</literal> definition.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the local volume resource in your OpenShift Container Platform cluster. Specify the file you just created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;local-volume&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the provisioner was created and that the corresponding daemon sets were created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get all -n openshift-local-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                          READY   STATUS    RESTARTS   AGE
pod/diskmaker-manager-9wzms                   1/1     Running   0          5m43s
pod/diskmaker-manager-jgvjp                   1/1     Running   0          5m43s
pod/diskmaker-manager-tbdsj                   1/1     Running   0          5m43s
pod/local-storage-operator-7db4bd9f79-t6k87   1/1     Running   0          14m

NAME                                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/local-storage-operator-metrics   ClusterIP   172.30.135.36   &lt;none&gt;        8383/TCP,8686/TCP   14m

NAME                               DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
daemonset.apps/diskmaker-manager   3         3         3       3            3           &lt;none&gt;          5m43s

NAME                                     READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/local-storage-operator   1/1     1            1           14m

NAME                                                DESIRED   CURRENT   READY   AGE
replicaset.apps/local-storage-operator-7db4bd9f79   1         1         1       14m</programlisting>
</para>
</formalpara>
<simpara>Note the desired and current number of daemon set processes. A desired count of <literal>0</literal> indicates that the label selectors were invalid.</simpara>
</listitem>
<listitem>
<simpara>Verify that the persistent volumes were created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
local-pv-1cec77cf   100Gi      RWO            Delete           Available           local-sc                88m
local-pv-2ef7cd2a   100Gi      RWO            Delete           Available           local-sc                82m
local-pv-3fa1c73    100Gi      RWO            Delete           Available           local-sc                48m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<important>
<simpara>Editing the <literal>LocalVolume</literal> object does not change the <literal>fsType</literal> or <literal>volumeMode</literal> of existing persistent volumes because doing so might result in a destructive operation.</simpara>
</important>
</section>
<section xml:id="local-create-cr-manual_persistent-storage-local">
<title>Provisioning local volumes without the Local Storage Operator</title>
<simpara>Local volumes cannot be created by dynamic provisioning. Instead, persistent volumes can be created by defining the persistent volume (PV) in an object definition. The local volume provisioner looks for any file system or block volume devices at the paths specified in the defined resource.</simpara>
<important>
<simpara>Manual provisioning of PVs includes the risk of potential data leaks across PV reuse when PVCs are deleted.
The Local Storage Operator is recommended for automating the life cycle of devices when provisioning local PVs.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Local disks are attached to the OpenShift Container Platform nodes.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define the PV. Create a file, such as <literal>example-pv-filesystem.yaml</literal> or <literal>example-pv-block.yaml</literal>, with the <literal>PersistentVolume</literal> object definition. This resource must define the nodes and paths to the local volumes.</simpara>
<note>
<simpara>Do not use different storage class names for the same device. Doing so will create multiple PVs.</simpara>
</note>
<formalpara>
<title>example-pv-filesystem.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv-filesystem
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem <co xml:id="CO37-1"/>
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage <co xml:id="CO37-2"/>
  local:
    path: /dev/xvdf <co xml:id="CO37-3"/>
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO37-1">
<para>The volume mode, either <literal>Filesystem</literal> or <literal>Block</literal>, that defines the type of PVs.</para>
</callout>
<callout arearefs="CO37-2">
<para>The name of the storage class to use when creating PV resources. Use a storage class that uniquely identifies this set of PVs.</para>
</callout>
<callout arearefs="CO37-3">
<para>The path containing a list of local storage devices to choose from, or a directory. You can only specify a directory with <literal>Filesystem</literal> <literal>volumeMode</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>A raw block volume (<literal>volumeMode: block</literal>) is not formatted with a file system. Use this mode only if any application running on the pod can use raw block devices.</simpara>
</note>
<formalpara>
<title>example-pv-block.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv-block
spec:
  capacity:
    storage: 100Gi
  volumeMode: Block <co xml:id="CO38-1"/>
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage <co xml:id="CO38-2"/>
  local:
    path: /dev/xvdf <co xml:id="CO38-3"/>
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO38-1">
<para>The volume mode, either <literal>Filesystem</literal> or <literal>Block</literal>, that defines the type of PVs.</para>
</callout>
<callout arearefs="CO38-2">
<para>The name of the storage class to use when creating PV resources. Be sure to use a storage class that uniquely identifies this set of PVs.</para>
</callout>
<callout arearefs="CO38-3">
<para>The path containing a list of local storage devices to choose from.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the PV resource in your OpenShift Container Platform cluster. Specify the file you just created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;example-pv&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the local PV was created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                STORAGECLASS    REASON   AGE
example-pv-filesystem   100Gi      RWO            Delete           Available                        local-storage            3m47s
example-pv1             1Gi        RWO            Delete           Bound       local-storage/pvc1   local-storage            12h
example-pv2             1Gi        RWO            Delete           Bound       local-storage/pvc2   local-storage            12h
example-pv3             1Gi        RWO            Delete           Bound       local-storage/pvc3   local-storage            12h</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="create-local-pvc_persistent-storage-local">
<title>Creating the local volume persistent volume claim</title>
<simpara>Local volumes must be statically created as a persistent volume claim (PVC)
to be accessed by the pod.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Persistent volumes have been created using the local volume provisioner.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the PVC using the corresponding storage class:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-pvc-name <co xml:id="CO39-1"/>
spec:
  accessModes:
  - ReadWriteOnce
  volumeMode: Filesystem <co xml:id="CO39-2"/>
  resources:
    requests:
      storage: 100Gi <co xml:id="CO39-3"/>
  storageClassName: local-sc <co xml:id="CO39-4"/></programlisting>
<calloutlist>
<callout arearefs="CO39-1">
<para>Name of the PVC.</para>
</callout>
<callout arearefs="CO39-2">
<para>The type of the PVC. Defaults to <literal>Filesystem</literal>.</para>
</callout>
<callout arearefs="CO39-3">
<para>The amount of storage available to the PVC.</para>
</callout>
<callout arearefs="CO39-4">
<para>Name of the storage class required by the claim.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the PVC in the OpenShift Container Platform cluster, specifying the file
you just created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;local-pvc&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="local-pod_persistent-storage-local">
<title>Attach the local claim</title>
<simpara>After a local volume has been mapped to a persistent volume claim
it can be specified inside of a resource.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A persistent volume claim exists in the same namespace.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Include the defined claim in the resource spec. The following example
declares the persistent volume claim inside a pod:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
spec:
# ...
  containers:
    volumeMounts:
    - name: local-disks <co xml:id="CO40-1"/>
      mountPath: /data <co xml:id="CO40-2"/>
  volumes:
  - name: local-disks
    persistentVolumeClaim:
      claimName: local-pvc-name <co xml:id="CO40-3"/>
# ...</programlisting>
<calloutlist>
<callout arearefs="CO40-1">
<para>The name of the volume to mount.</para>
</callout>
<callout arearefs="CO40-2">
<para>The path inside the pod where the volume is mounted. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
<callout arearefs="CO40-3">
<para>The name of the existing persistent volume claim to use.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the resource in the OpenShift Container Platform cluster, specifying the file
you just created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;local-pod&gt;.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="local-storage-discovery_persistent-storage-local">
<title>Automating discovery and provisioning for local storage devices</title>
<simpara>The Local Storage Operator automates local storage discovery and provisioning. With this feature, you can simplify installation when dynamic provisioning is not available during deployment, such as with bare metal, VMware, or AWS store instances with attached devices.</simpara>
<important>
<simpara>Automatic discovery and provisioning is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<important>
<simpara>Automatic discovery and provisioning is fully supported when used to deploy Red Hat OpenShift Data Foundation on-premise or with platform-agnostic deployment.</simpara>
</important>
<simpara>Use the following procedure to automatically discover local devices, and to automatically provision local volumes for selected devices.</simpara>
<warning>
<simpara>Use the <literal>LocalVolumeSet</literal> object with caution. When you automatically provision persistent volumes (PVs) from local disks, the local PVs might claim all devices that match. If you are using a <literal>LocalVolumeSet</literal> object, make sure the Local Storage Operator is the only entity managing local devices on the node. Creating multiple instances of a <literal>LocalVolumeSet</literal> that target a node more than once is not supported.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have cluster administrator permissions.</simpara>
</listitem>
<listitem>
<simpara>You have installed the Local Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>You have attached local disks to OpenShift Container Platform nodes.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform web console and the <literal>oc</literal> command-line interface (CLI).</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>To enable automatic discovery of local devices from the web console:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In the <emphasis>Administrator</emphasis> perspective, navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> and click on the <emphasis role="strong">Local Volume Discovery</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create Local Volume Discovery</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select either <emphasis role="strong">All nodes</emphasis> or <emphasis role="strong">Select nodes</emphasis>, depending on whether you want to discover available disks on all or specific nodes.</simpara>
<note>
<simpara>Only worker nodes are available, regardless of whether you filter using <emphasis role="strong">All nodes</emphasis> or <emphasis role="strong">Select nodes</emphasis>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>A local volume discovery instance named <literal>auto-discover-devices</literal> is displayed.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To display a continuous list of available devices on a node:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Compute</emphasis> &#8594; <emphasis role="strong">Nodes</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the node name that you want to open. The "Node Details" page is displayed.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Disks</emphasis> tab to display the list of the selected devices.</simpara>
<simpara>The device list updates continuously as local disks are added or removed. You can filter the devices by name, status, type, model, capacity, and mode.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To automatically provision local volumes for the discovered devices from the web console:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> and select <emphasis role="strong">Local Storage</emphasis> from the list of Operators.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Local Volume Set</emphasis> &#8594; <emphasis role="strong">Create Local Volume Set</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Enter a volume set name and a storage class name.</simpara>
</listitem>
<listitem>
<simpara>Choose <emphasis role="strong">All nodes</emphasis> or <emphasis role="strong">Select nodes</emphasis> to apply filters accordingly.</simpara>
<note>
<simpara>Only worker nodes are available, regardless of whether you filter using <emphasis role="strong">All nodes</emphasis> or <emphasis role="strong">Select nodes</emphasis>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Select the disk type, mode, size, and limit you want to apply to the local volume set, and click <emphasis role="strong">Create</emphasis>.</simpara>
<simpara>A message displays after several minutes, indicating that the "Operator reconciled successfully."</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic" startingnumber="3">
<listitem>
<simpara>Alternatively, to provision local volumes for the discovered devices from the CLI:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create an object YAML file to define the local volume set, such as <literal>local-volume-set.yaml</literal>, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: local.storage.openshift.io/v1alpha1
kind: LocalVolumeSet
metadata:
  name: example-autodetect
spec:
  nodeSelector:
    nodeSelectorTerms:
      - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
              - worker-0
              - worker-1
  storageClassName: example-storageclass <co xml:id="CO41-1"/>
  volumeMode: Filesystem
  fsType: ext4
  maxDeviceCount: 10
  deviceInclusionSpec:
    deviceTypes: <co xml:id="CO41-2"/>
      - disk
      - part
    deviceMechanicalProperties:
      - NonRotational
    minSize: 10G
    maxSize: 100G
    models:
      - SAMSUNG
      - Crucial_CT525MX3
    vendors:
      - ATA
      - ST2000LM</programlisting>
<calloutlist>
<callout arearefs="CO41-1">
<para>Determines the storage class that is created for persistent volumes that are provisioned from discovered devices. The Local Storage Operator automatically creates the storage class if it does not exist. Be sure to use a storage class that uniquely identifies this set of local volumes.</para>
</callout>
<callout arearefs="CO41-2">
<para>When using the local volume set feature, the Local Storage Operator does not support the use of logical volume management (LVM) devices.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the local volume set object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f local-volume-set.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the local persistent volumes were dynamically provisioned based on the storage class:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pv</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS           REASON   AGE
local-pv-1cec77cf   100Gi      RWO            Delete           Available           example-storageclass            88m
local-pv-2ef7cd2a   100Gi      RWO            Delete           Available           example-storageclass            82m
local-pv-3fa1c73    100Gi      RWO            Delete           Available           example-storageclass            48m</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>Results are deleted after they are removed from the node. Symlinks must be manually removed.</simpara>
</note>
</section>
<section xml:id="local-tolerations_persistent-storage-local">
<title>Using tolerations with Local Storage Operator pods</title>
<simpara>Taints can be applied to nodes to prevent them from running general workloads. To allow the Local Storage Operator to use tainted nodes, you must add tolerations to the <literal>Pod</literal> or <literal>DaemonSet</literal> definition. This allows the created resources to run on these tainted nodes.</simpara>
<simpara>You apply tolerations to the Local Storage Operator pod through the <literal>LocalVolume</literal> resource
and apply taints to a node through the node specification. A taint on a node instructs the node to repel all pods that do not tolerate the taint. Using a specific taint that is not on other pods ensures that the Local Storage Operator pod can also run on that node.</simpara>
<important>
<simpara>Taints and tolerations consist of a key, value, and effect. As an argument, it is expressed as <literal>key=value:effect</literal>. An operator allows you to leave one of these parameters empty.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The Local Storage Operator is installed.</simpara>
</listitem>
<listitem>
<simpara>Local disks are attached to OpenShift Container Platform nodes with a taint.</simpara>
</listitem>
<listitem>
<simpara>Tainted nodes are expected to provision local storage.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To configure local volumes for scheduling on tainted nodes:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Modify the YAML file that defines the <literal>Pod</literal> and add the <literal>LocalVolume</literal> spec, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: "local.storage.openshift.io/v1"
  kind: "LocalVolume"
  metadata:
    name: "local-disks"
    namespace: "openshift-local-storage"
  spec:
    tolerations:
      - key: localstorage <co xml:id="CO42-1"/>
        operator: Equal <co xml:id="CO42-2"/>
        value: "localstorage" <co xml:id="CO42-3"/>
    storageClassDevices:
        - storageClassName: "localblock-sc"
          volumeMode: Block <co xml:id="CO42-4"/>
          devicePaths: <co xml:id="CO42-5"/>
            - /dev/xvdg</programlisting>
<calloutlist>
<callout arearefs="CO42-1">
<para>Specify the key that you added to the node.</para>
</callout>
<callout arearefs="CO42-2">
<para>Specify the <literal>Equal</literal> operator to require the <literal>key</literal>/<literal>value</literal> parameters to match. If operator is <literal>Exists</literal>, the system checks that the key exists and ignores the value. If operator is <literal>Equal</literal>, then the key and value must match.</para>
</callout>
<callout arearefs="CO42-3">
<para>Specify the value <literal>local</literal> of the tainted node.</para>
</callout>
<callout arearefs="CO42-4">
<para>The volume mode, either <literal>Filesystem</literal> or <literal>Block</literal>, defining the type of the local volumes.</para>
</callout>
<callout arearefs="CO42-5">
<para>The path containing a list of local storage devices to choose from.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Optional: To create local persistent volumes on only tainted nodes, modify the YAML file and add the <literal>LocalVolume</literal> spec, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  tolerations:
    - key: node-role.kubernetes.io/master
      operator: Exists</programlisting>
</listitem>
</orderedlist>
<simpara>The defined tolerations will be passed to the resulting daemon sets, allowing the diskmaker and provisioner pods to be created for nodes that contain the specified taints.</simpara>
</section>
<section xml:id="local-storage-metrics_persistent-storage-local">
<title>Local Storage Operator Metrics</title>
<simpara>OpenShift Container Platform provides the following metrics for the Local Storage Operator:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>lso_discovery_disk_count</literal>: total number of discovered devices on each node</simpara>
</listitem>
<listitem>
<simpara><literal>lso_lvset_provisioned_PV_count</literal>: total number of PVs created by <literal>LocalVolumeSet</literal> objects</simpara>
</listitem>
<listitem>
<simpara><literal>lso_lvset_unmatched_disk_count</literal>: total number of disks that Local Storage Operator did not select for provisioning because of mismatching criteria</simpara>
</listitem>
<listitem>
<simpara><literal>lso_lvset_orphaned_symlink_count</literal>: number of devices with PVs that no longer match <literal>LocalVolumeSet</literal> object criteria</simpara>
</listitem>
<listitem>
<simpara><literal>lso_lv_orphaned_symlink_count</literal>: number of devices with PVs that no longer match <literal>LocalVolume</literal> object criteria</simpara>
</listitem>
<listitem>
<simpara><literal>lso_lv_provisioned_PV_count</literal>: total number of provisioned PVs for <literal>LocalVolume</literal></simpara>
</listitem>
</itemizedlist>
<simpara>To use these metrics, be sure to:</simpara>
<itemizedlist>
<listitem>
<simpara>Enable support for monitoring when installing the Local Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>When upgrading to OpenShift Container Platform 4.9 or later, enable metric support manually by adding the <literal>operator-metering=true</literal> label to the namespace.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information about metrics, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/monitoring/#managing-metric">Managing metrics</link>.</simpara>
</section>
<section xml:id="_deleting-the-local-storage-operator-resources">
<title>Deleting the Local Storage Operator resources</title>
<section xml:id="local-removing-device_persistent-storage-local">
<title>Removing a local volume or local volume set</title>
<simpara>Occasionally, local volumes and local volume sets must be deleted. While removing the entry in the resource and deleting the persistent volume is typically enough, if you want to reuse the same device path or have it managed by a different storage class, then additional steps are needed.</simpara>
<note>
<simpara>The following procedure outlines an example for removing a local volume. The same procedure can also be used to remove symlinks for a local volume set custom resource.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The persistent volume must be in a <literal>Released</literal> or <literal>Available</literal> state.</simpara>
<warning>
<simpara>Deleting a persistent volume that is still in use can result in data loss or corruption.</simpara>
</warning>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the previously created local volume to remove any unwanted disks.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Edit the cluster resource:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit localvolume &lt;name&gt; -n openshift-local-storage</programlisting>
</listitem>
<listitem>
<simpara>Navigate to the lines under <literal>devicePaths</literal>, and delete any representing unwanted disks.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Delete any persistent volumes created.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pv &lt;pv-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Delete directory and included symlinks on the node.</simpara>
<warning>
<simpara>The following step involves accessing a node as the root user. Modifying the state of the node beyond the steps in this procedure could result in cluster instability.</simpara>
</warning>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt; -- chroot /host rm -rf /mnt/local-storage/&lt;sc-name&gt; <co xml:id="CO43-1"/></programlisting>
<calloutlist>
<callout arearefs="CO43-1">
<para>The name of the storage class used to create the local volumes.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="local-storage-uninstall_persistent-storage-local">
<title>Uninstalling the Local Storage Operator</title>
<simpara>To uninstall the Local Storage Operator, you must remove the Operator and all created resources in the <literal>openshift-local-storage</literal> project.</simpara>
<warning>
<simpara>Uninstalling the Local Storage Operator while local storage PVs are still in use is not recommended. While the PVs will remain after the Operator&#8217;s removal,
there might be indeterminate behavior if the Operator is uninstalled and reinstalled without removing the PVs and local storage resources.</simpara>
</warning>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Delete any local volume resources installed in the project, such as <literal>localvolume</literal>, <literal>localvolumeset</literal>, and <literal>localvolumediscovery</literal>:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete localvolume --all --all-namespaces
$ oc delete localvolumeset --all --all-namespaces
$ oc delete localvolumediscovery --all --all-namespaces</programlisting>
</listitem>
<listitem>
<simpara>Uninstall the Local Storage Operator from the web console.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Navigate to <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type <emphasis role="strong">Local Storage</emphasis> into the filter box to locate the Local Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>Click the Options menu <inlinemediaobject>
<imageobject>
<imagedata fileref="images/kebab.png"/>
</imageobject>
<textobject><phrase>kebab</phrase></textobject>
</inlinemediaobject> at the end of the Local Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Remove</emphasis> in the window that appears.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>The PVs created by the Local Storage Operator will remain in the cluster until deleted. After these volumes are no longer in use, delete them by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete pv &lt;pv-name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Delete the <literal>openshift-local-storage</literal> project:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete project openshift-local-storage</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
<section xml:id="persistent-storage-using-hostpath">
<title>Persistent storage using hostPath</title>

<simpara>A hostPath volume in an OpenShift Container Platform cluster mounts a file or directory from the host node&#8217;s filesystem into your pod. Most pods will not need a hostPath volume, but it does offer a quick option for testing should an application require it.</simpara>
<important>
<simpara>The cluster administrator must configure pods to run as privileged. This grants access to pods in the same node.</simpara>
</important>
<section xml:id="persistent-storage-hostpath-about_persistent-storage-hostpath">
<title>Overview</title>
<simpara>OpenShift Container Platform supports hostPath mounting for development and testing on a single-node cluster.</simpara>
<simpara>In a production cluster, you would not use hostPath. Instead, a cluster administrator would provision a network resource, such as a GCE Persistent Disk volume, an NFS share, or an Amazon EBS volume. Network resources support the use of storage classes to set up dynamic provisioning.</simpara>
<simpara>A hostPath volume must be provisioned statically.</simpara>
<important>
<simpara>Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged. It is safe to mount the host by using <literal>/host</literal>. The following example shows the <literal>/</literal> directory from the host being mounted into the container at <literal>/host</literal>.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: test-host-mount
spec:
  containers:
  - image: registry.access.redhat.com/ubi9/ubi
    name: test-container
    command: ['sh', '-c', 'sleep 3600']
    volumeMounts:
    - mountPath: /host
      name: host-slash
  volumes:
   - name: host-slash
     hostPath:
       path: /
       type: ''</programlisting>
</important>
</section>
<section xml:id="hostpath-static-provisioning_persistent-storage-hostpath">
<title>Statically provisioning hostPath volumes</title>
<simpara>A pod that uses a hostPath volume must be referenced by manual (static) provisioning.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define the persistent volume (PV). Create a file, <literal>pv.yaml</literal>, with the <literal>PersistentVolume</literal> object definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">  apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: task-pv-volume <co xml:id="CO44-1"/>
    labels:
      type: local
  spec:
    storageClassName: manual <co xml:id="CO44-2"/>
    capacity:
      storage: 5Gi
    accessModes:
      - ReadWriteOnce <co xml:id="CO44-3"/>
    persistentVolumeReclaimPolicy: Retain
    hostPath:
      path: "/mnt/data" <co xml:id="CO44-4"/></programlisting>
<calloutlist>
<callout arearefs="CO44-1">
<para>The name of the volume. This name is how it is identified by persistent volume claims or pods.</para>
</callout>
<callout arearefs="CO44-2">
<para>Used to bind persistent volume claim requests to this persistent volume.</para>
</callout>
<callout arearefs="CO44-3">
<para>The volume can be mounted as <literal>read-write</literal> by a single node.</para>
</callout>
<callout arearefs="CO44-4">
<para>The configuration file specifies that the volume is at <literal>/mnt/data</literal> on the cluster&#8217;s node. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the PV from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pv.yaml</programlisting>
</listitem>
<listitem>
<simpara>Define the persistent volume claim (PVC). Create a file, <literal>pvc.yaml</literal>, with the <literal>PersistentVolumeClaim</literal> object definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: task-pvc-volume
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: manual</programlisting>
</listitem>
<listitem>
<simpara>Create the PVC from the file:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-hostpath-pod_persistent-storage-hostpath">
<title>Mounting the hostPath share in a privileged pod</title>
<simpara>After the persistent volume claim has been created, it can be used inside by an application. The following example demonstrates mounting this share inside of a pod.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>A persistent volume claim exists that is mapped to the underlying hostPath share.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a privileged pod that mounts the existing persistent volume claim:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: pod-name <co xml:id="CO45-1"/>
spec:
  containers:
    ...
    securityContext:
      privileged: true <co xml:id="CO45-2"/>
    volumeMounts:
    - mountPath: /data <co xml:id="CO45-3"/>
      name: hostpath-privileged
  ...
  securityContext: {}
  volumes:
    - name: hostpath-privileged
      persistentVolumeClaim:
        claimName: task-pvc-volume <co xml:id="CO45-4"/></programlisting>
<calloutlist>
<callout arearefs="CO45-1">
<para>The name of the pod.</para>
</callout>
<callout arearefs="CO45-2">
<para>The pod must run as privileged to access the node&#8217;s storage.</para>
</callout>
<callout arearefs="CO45-3">
<para>The path to mount the host path share inside the privileged pod. Do not mount to the container root, <literal>/</literal>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <literal>/dev/pts</literal> files. It is safe to mount the host by using <literal>/host</literal>.</para>
</callout>
<callout arearefs="CO45-4">
<para>The name of the <literal>PersistentVolumeClaim</literal> object that has been previously created.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-using-lvms">
<title>Persistent storage using logical volume manager storage</title>

<simpara>Logical volume manager storage (LVM Storage) uses the TopoLVM CSI driver to dynamically provision local storage on the clusters.</simpara>
<simpara>LVM Storage creates thin-provisioned volumes using Logical Volume Manager and provides dynamic provisioning of block storage on a limited resources cluster.</simpara>
<section xml:id="lvms-preface-sno-ran_logical-volume-manager-storage">
<title>Deploying LVM Storage</title>
<simpara>You can deploy LVM Storage on a bare-metal or user-provisioned infrastructure cluster and configure it to dynamically provision storage for your workloads.</simpara>
<simpara>LVM Storage creates a volume group using all the available unused disks and creates a single thin pool with a size of 90% of the volume group.
The remaining 10% of the volume group is left free to enable data recovery by expanding the thin pool when required.
You might need to manually perform such recovery.</simpara>
<simpara>You can use persistent volume claims (PVCs) and volume snapshots provisioned by LVM Storage to request storage and create volume snapshots.</simpara>
<simpara>LVM Storage configures a default overprovisioning limit of 10 to take advantage of the thin-provisioning feature.
The total size of the volumes and volume snapshots that can be created on the clusters is 10 times the size of the thin pool.</simpara>
<simpara>You can deploy LVM Storage using one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Red Hat Advanced Cluster Management (RHACM)</simpara>
</listitem>
<listitem>
<simpara>OpenShift Container Platform Web Console</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>LVM Storage only supports provisioning local storage on multi-node clusters. It does not support storage data replication mechanism across nodes. When you are using LVM Storage on multi-node clusters, you must ensure storage data replication through active or passive replication mechanism to avoid a single point of failure.</simpara>
</warning>
<section xml:id="lvms-deployment-requirements-for-sno-ran_logical-volume-manager-storage">
<title>Requirements</title>
<simpara>Before deploying LVM Storage on single-node OpenShift clusters, ensure that the following requirements are met:</simpara>
<itemizedlist>
<listitem>
<simpara>You have installed Red Hat Advanced Cluster Management (RHACM) on an OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Every managed cluster has dedicated disks that are used to provision storage.</simpara>
</listitem>
</itemizedlist>
<simpara>Before deploying LVM Storage in a private CI environment where you can reuse the virtual machines and storage devices, ensure that you have wiped the disks that are not in use.</simpara>
<note>
<simpara>You cannot wipe the disks that are in use.</simpara>
</note>
</section>
<section xml:id="lvms-deployment-limitations-for-sno-ran_logical-volume-manager-storage">
<title>Limitations</title>
<simpara>For deploying OpenShift Container Platform, LVM Storage has the following limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The total storage size is limited by the size of the underlying Logical Volume Manager (LVM) thin pool and the overprovisioning factor.</simpara>
</listitem>
<listitem>
<simpara>The size of the logical volume depends on the size of the Physical Extent (PE) and the Logical Extent (LE).</simpara>
<itemizedlist>
<listitem>
<simpara>It is possible to define the size of PE and LE during the physical and logical device creation.</simpara>
</listitem>
<listitem>
<simpara>The default PE and LE size is 4 MB.</simpara>
</listitem>
<listitem>
<simpara>If the size of the PE is increased, the maximum size of the LVM is determined by the kernel limits and your disk space.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<table frame="all" rowsep="1" colsep="1">
<title>Size limits for different architectures using the default PE and LE size</title>
<?dbhtml table-width="100%"?>
<?dbfo table-width="100%"?>
<?dblatex table-width="100%"?>
<tgroup cols="5">
<colspec colname="col_1" colwidth="85*"/>
<colspec colname="col_2" colwidth="85*"/>
<colspec colname="col_3" colwidth="85*"/>
<colspec colname="col_4" colwidth="85*"/>
<colspec colname="col_5" colwidth="85*"/>
<thead>
<row>
<entry align="left" valign="top">Architecture</entry>
<entry align="left" valign="top">RHEL 6</entry>
<entry align="left" valign="top">RHEL 7</entry>
<entry align="left" valign="top">RHEL 8</entry>
<entry align="left" valign="top">RHEL 9</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>32-bit</simpara></entry>
<entry align="left" valign="top"><simpara>16 TB</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>64-bit</simpara></entry>
<entry align="left" valign="top"><simpara>8 EB <superscript>[1]</superscript></simpara><simpara>100 TB <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>8 EB <superscript>[1]</superscript></simpara><simpara>500 TB <superscript>[2]</superscript></simpara></entry>
<entry align="left" valign="top"><simpara>8 EB</simpara></entry>
<entry align="left" valign="top"><simpara>8 EB</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<para role="small">
<orderedlist numeration="arabic">
<listitem>
<simpara>Theoretical size.</simpara>
</listitem>
<listitem>
<simpara>Tested size.</simpara>
</listitem>
</orderedlist>
</para>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="install-lvms-operator-cli_logical-volume-manager-storage">
<title>Installing LVM Storage with the CLI</title>
<simpara>As a cluster administrator, you can install Logical volume manager storage (LVM Storage) by using the CLI.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a namespace for the LVM Storage Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>lvms-namespace.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Namespace
metadata:
  labels:
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: privileged
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/warn: privileged
  name: openshift-storage</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Namespace</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f lvms-namespace.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an Operator group for the LVM Storage Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>lvms-operatorgroup.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: openshift-storage-operatorgroup
  namespace: openshift-storage
spec:
  targetNamespaces:
  - openshift-storage</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>OperatorGroup</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f lvms-operatorgroup.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Subscribe to the LVM Storage Operator.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>lvms-sub.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: lvms
  namespace: openshift-storage
spec:
  installPlanApproval: Automatic
  name: lvms-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>Subscription</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f lvms-sub.yaml</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>To verify that the Operator is installed, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get csv -n openshift-storage -o custom-columns=Name:.metadata.name,Phase:.status.phase</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name                         Phase
4.13.0-202301261535          Succeeded</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="lvms-installing-lvms-with-web-console_logical-volume-manager-storage">
<title>Installing LVM Storage with the web console</title>
<simpara>You can install Logical volume manager storage (LVM Storage) by using the Red Hat OpenShift Container Platform OperatorHub.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the cluster.</simpara>
</listitem>
<listitem>
<simpara>You are using an account with the <literal>cluster-admin</literal> and Operator installation permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform Web Console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators &#8594; OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Scroll or type <literal>LVM Storage</literal> into the <emphasis role="strong">Filter by keyword</emphasis> box to find LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Set the following options on the <emphasis role="strong">Install Operator</emphasis> page:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><emphasis role="strong">Update Channel</emphasis> as <emphasis role="strong">stable-4.14</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installation Mode</emphasis> as <emphasis role="strong">A specific namespace on the cluster</emphasis>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installed Namespace</emphasis> as <emphasis role="strong">Operator recommended namespace openshift-storage</emphasis>.
If the <literal>openshift-storage</literal> namespace does not exist, it is created during the operator installation.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Approval Strategy</emphasis> as <emphasis role="strong">Automatic</emphasis> or <emphasis role="strong">Manual</emphasis>.</simpara>
<simpara>If you select <emphasis role="strong">Automatic</emphasis> updates, then the Operator Lifecycle Manager (OLM) automatically updates the running instance of your Operator without any intervention.</simpara>
<simpara>If you select <emphasis role="strong">Manual</emphasis> updates, then the OLM creates an update request.
As a cluster administrator, you must then manually approve that update request to update the Operator to a newer version.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification steps</title>
<listitem>
<simpara>Verify that LVM Storage shows a green tick, indicating successful installation.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-unstalling-lvms-with-web-console_logical-volume-manager-storage">
<title>Uninstalling LVM Storage using the web console</title>
<simpara>You can uninstall LVM Storage using the OpenShift Container Platform web console.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You deleted all the applications on the clusters that are using the storage provisioned by LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>You deleted the persistent volume claims (PVCs) and persistent volumes (PVs) provisioned using LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>You deleted all volume snapshots provisioned by LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>You verified that no logical volume resources exist by using the <literal>oc get logicalvolume</literal> command.</simpara>
</listitem>
<listitem>
<simpara>You have access to the cluster using an account with <literal>cluster-admin</literal> permissions.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis> page, scroll to <emphasis role="strong">LVM Storage</emphasis> or type <literal>LVM Storage</literal> into the <emphasis role="strong">Filter by name</emphasis> to find and click on it.</simpara>
</listitem>
<listitem>
<simpara>Click on the <emphasis role="strong">LVMCluster</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>On the right-hand side of the <emphasis role="strong">LVMCluster</emphasis> page, select <emphasis role="strong">Delete LVMCluster</emphasis> from the <emphasis role="strong">Actions</emphasis> drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Click on the <emphasis role="strong">Details</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>On the right-hand side of the <emphasis role="strong">Operator Details</emphasis> page, select <emphasis role="strong">Uninstall Operator</emphasis> from the <emphasis role="strong">Actions</emphasis> drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Remove</emphasis>. LVM Storage stops running and is completely removed.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="lvms-installing-lvms-disconnected-env_logical-volume-manager-storage">
<title>Installing LVM Storage in a disconnected environment</title>
<simpara>You can install LVM Storage on OpenShift Container Platform 4.14 in a disconnected environment. All sections referenced in this procedure are linked in <emphasis>Additional resources</emphasis>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You read the <emphasis>About disconnected installation mirroring</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>You have access to the OpenShift Container Platform image repository.</simpara>
</listitem>
<listitem>
<simpara>You created a mirror registry.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Follow the steps in the <emphasis>Creating the image set configuration</emphasis> procedure. To create an <literal>ImageSetConfiguration</literal> resource for LVM Storage, you can use the following example YAML file:</simpara>
<formalpara>
<title>Example ImageSetConfiguration file for LVM Storage</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: ImageSetConfiguration
apiVersion: mirror.openshift.io/v1alpha2
archiveSize: 4 <co xml:id="CO46-1"/>
storageConfig: <co xml:id="CO46-2"/>
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata <co xml:id="CO46-3"/>
    skipTLS: false
mirror:
  platform:
    channels:
    - name: stable-4.14 <co xml:id="CO46-4"/>
      type: ocp
    graph: true <co xml:id="CO46-5"/>
  operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v4.14 <co xml:id="CO46-6"/>
    packages:
    - name: lvms-operator <co xml:id="CO46-7"/>
      channels:
      - name: stable <co xml:id="CO46-8"/>
  additionalImages:
  - name: registry.redhat.io/ubi9/ubi:latest <co xml:id="CO46-9"/>
  helm: {}</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO46-1">
<para>Add <literal>archiveSize</literal> to set the maximum size, in GiB, of each file within the image set.</para>
</callout>
<callout arearefs="CO46-2">
<para>Set the back-end location to save the image set metadata to. This location can be a registry or local directory. It is required to specify <literal>storageConfig</literal> values, unless you are using the Technology Preview OCI feature.</para>
</callout>
<callout arearefs="CO46-3">
<para>Set the registry URL for the storage backend.</para>
</callout>
<callout arearefs="CO46-4">
<para>Set the channel to retrieve the OpenShift Container Platform images from.</para>
</callout>
<callout arearefs="CO46-5">
<para>Add <literal>graph: true</literal> to generate the OpenShift Update Service (OSUS) graph image to allow for an improved cluster update experience when using the web console. For more information, see <emphasis>About the OpenShift Update Service</emphasis>.</para>
</callout>
<callout arearefs="CO46-6">
<para>Set the Operator catalog to retrieve the OpenShift Container Platform images from.</para>
</callout>
<callout arearefs="CO46-7">
<para>Specify only certain Operator packages to include in the image set. Remove this field to retrieve all packages in the catalog.</para>
</callout>
<callout arearefs="CO46-8">
<para>Specify only certain channels of the Operator packages to include in the image set. You must always include the default channel for the Operator package even if you do not use the bundles in that channel. You can find the default channel by running the following command: <literal>oc mirror list operators --catalog=&lt;catalog_name&gt; --package=&lt;package_name&gt;</literal>.</para>
</callout>
<callout arearefs="CO46-9">
<para>Specify any additional images to include in image set.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Follow the procedure in the <emphasis>Mirroring an image set to a mirror registry</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Follow the procedure in the <emphasis>Configuring image registry repository mirroring</emphasis> section.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-mirroring-disconnected-about">About disconnected installation mirroring</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installing-mirroring-creating-registry">Creating a mirror registry with mirror registry for Red Hat OpenShift</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-mirror-repository_installing-mirroring-installation-images">Mirroring the OpenShift Container Platform image repository</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#oc-mirror-creating-image-set-config_installing-mirroring-disconnected">Creating the image set configuration</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#mirroring-image-set">Mirroring an image set to a mirror registry</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/images/#images-configuration-registry-mirror_image-configuration">Configuring image registry repository mirroring</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-installing-odf-logical-volume-manager-operator-using-rhacm_logical-volume-manager-storage">
<title>Installing LVM Storage using RHACM</title>
<simpara>LVM Storage is deployed on the clusters using Red Hat Advanced Cluster Management (RHACM).
You create a <literal>Policy</literal> object on RHACM that deploys and configures the Operator when it is applied to managed clusters which match the selector specified in the <literal>PlacementRule</literal> resource.
The policy is also applied to clusters that are imported later and satisfy the placement rule.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the RHACM cluster using an account with <literal>cluster-admin</literal> and Operator installation permissions.</simpara>
</listitem>
<listitem>
<simpara>Dedicated disks on each cluster to be used by LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>The cluster needs to be managed by RHACM, either imported or created.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the RHACM CLI using your OpenShift Container Platform credentials.</simpara>
</listitem>
<listitem>
<simpara>Create a namespace in which you will create policies.</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create ns lvms-policy-ns</programlisting>
</listitem>
<listitem>
<simpara>To create a policy, save the following YAML to a file with a name such as <literal>policy-lvms-operator.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-install-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector: <co xml:id="CO47-1"/>
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-install-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-install-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: install-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: install-lvms
spec:
  disabled: false
  remediationAction: enforce
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: install-lvms
      spec:
        object-templates:
        - complianceType: musthave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                openshift.io/cluster-monitoring: "true"
                pod-security.kubernetes.io/enforce: privileged
                pod-security.kubernetes.io/audit: privileged
                pod-security.kubernetes.io/warn: privileged
              name: openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms
              namespace: openshift-storage
            spec:
              installPlanApproval: Automatic
              name: lvms-operator
              source: redhat-operators
              sourceNamespace: openshift-marketplace
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: lvms
      spec:
        object-templates:
           - complianceType: musthave
             objectDefinition:
               apiVersion: lvm.topolvm.io/v1alpha1
               kind: LVMCluster
               metadata:
                 name: my-lvmcluster
                 namespace: openshift-storage
               spec:
                 storage:
                   deviceClasses:
                   - name: vg1
                     default: true
                     deviceSelector: <co xml:id="CO47-2"/>
                       paths:
                       - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
                       optionalPaths:
                       - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:90:00.0-nvme-1
                     thinPoolConfig:
                       name: thin-pool-1
                       sizePercent: 90
                       overprovisionRatio: 10
                     nodeSelector: <co xml:id="CO47-3"/>
                       nodeSelectorTerms:
                       - matchExpressions:
                           - key: app
                             operator: In
                             values:
                             - test1
        remediationAction: enforce
        severity: low</programlisting>
<calloutlist>
<callout arearefs="CO47-1">
<para>Replace the key and value in <literal>PlacementRule.spec.clusterSelector</literal> to match the labels set on the clusters on which you want to install LVM Storage.</para>
</callout>
<callout arearefs="CO47-2">
<para>Optional. To control or restrict the volume group to your preferred devices, you can manually specify the local paths of the devices in the <literal>deviceSelector</literal> section of the <literal>LVMCluster</literal> YAML. The <literal>paths</literal> section refers to devices the <literal>LVMCluster</literal> adds, which means those paths must exist. The <literal>optionalPaths</literal> section refers to devices the <literal>LVMCluster</literal> might add. You must specify at least one of <literal>paths</literal> or <literal>optionalPaths</literal> when specifying the <literal>deviceSelector</literal> section. If you specify <literal>paths</literal>, it is not mandatory to specify <literal>optionalPaths</literal>. If you specify <literal>optionalPaths</literal>, it is not mandatory to specify <literal>paths</literal> but at least one optional path must be present on the node. If you do not specify any paths, it will add all unused devices on the node.</para>
</callout>
<callout arearefs="CO47-3">
<para>To add a node filter, which is a subset of the additional worker nodes, specify the required filter in the <literal>nodeSelector</literal> section. LVM Storage detects and uses the additional worker nodes when the new nodes show up.</para>
</callout>
</calloutlist>
<important>
<simpara>This <literal>nodeSelector</literal> node filter matching is not the same as the pod label matching.</simpara>
</important>
</listitem>
<listitem>
<simpara>Create the policy in the namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f policy-lvms-operator.yaml -n lvms-policy-ns <co xml:id="CO48-1"/></programlisting>
<calloutlist>
<callout arearefs="CO48-1">
<para>The <literal>policy-lvms-operator.yaml</literal> is the name of the file to which the policy is saved.</para>
</callout>
</calloutlist>
<simpara>This creates a <literal>Policy</literal>, a <literal>PlacementRule</literal>, and a <literal>PlacementBinding</literal> object in the <literal>lvms-policy-ns</literal> namespace.
The policy creates a <literal>Namespace</literal>, <literal>OperatorGroup</literal>, <literal>Subscription</literal>, and <literal>LVMCluster</literal> resource on the clusters that match the placement rule.
This deploys the Operator on the clusters which match the selection criteria and configures it to set up the required resources to provision storage.
The Operator uses all the disks specified in the <literal>LVMCluster</literal> CR.
If no disks are specified, the Operator uses all the unused disks on the node.</simpara>
<important>
<simpara>After a device is added to the <literal>LVMCluster</literal>, it cannot be removed.</simpara>
</important>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-uninstalling-lvms-rhacm_logical-volume-manager-storage">
<title>Uninstalling LVM Storage installed using RHACM</title>
<simpara>To uninstall LVM Storage that you installed using RHACM, you need to delete the RHACM policy that you created for deploying and configuring the Operator.</simpara>
<simpara>When you delete the RHACM policy, the resources that the policy has created are not removed.
You need to create additional policies to remove the resources.</simpara>
<simpara>As the created resources are not removed when you delete the policy, you need to perform the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Remove all the Persistent volume claims (PVCs) and volume snapshots provisioned by LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>Remove the <literal>LVMCluster</literal> resources to clean up Logical Volume Manager resources created on the disks.</simpara>
</listitem>
<listitem>
<simpara>Create an additional policy to uninstall the Operator.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Ensure that the following are deleted before deleting the policy:</simpara>
<itemizedlist>
<listitem>
<simpara>All the applications on the managed clusters that are using the storage provisioned by LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>PVCs and persistent volumes (PVs) provisioned using LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>All volume snapshots provisioned by LVM Storage.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Ensure you have access to the RHACM cluster using an account with a <literal>cluster-admin</literal> role.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift CLI (<literal>oc</literal>), delete the RHACM policy that you created for deploying and configuring LVM Storage on the hub cluster by using the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc delete -f policy-lvms-operator.yaml -n lvms-policy-ns <co xml:id="CO49-1"/></programlisting>
<calloutlist>
<callout arearefs="CO49-1">
<para>The <literal>policy-lvms-operator.yaml</literal> is the name of the file to which the policy was saved.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To create a policy for removing the <literal>LVMCluster</literal> resource, save the following YAML to a file with a name such as <literal>lvms-remove-policy.yaml</literal>.
This enables the Operator to clean up all Logical Volume Manager resources that it created on the cluster.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: policy-lvmcluster-delete
  annotations:
    policy.open-cluster-management.io/standards: NIST SP 800-53
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
spec:
  remediationAction: enforce
  disabled: false
  policy-templates:
    - objectDefinition:
        apiVersion: policy.open-cluster-management.io/v1
        kind: ConfigurationPolicy
        metadata:
          name: policy-lvmcluster-removal
        spec:
          remediationAction: enforce <co xml:id="CO50-1"/>
          severity: low
          object-templates:
            - complianceType: mustnothave
              objectDefinition:
                kind: LVMCluster
                apiVersion: lvm.topolvm.io/v1alpha1
                metadata:
                  name: my-lvmcluster
                  namespace: openshift-storage <co xml:id="CO50-2"/>
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-policy-lvmcluster-delete
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-policy-lvmcluster-delete
subjects:
  - apiGroup: policy.open-cluster-management.io
    kind: Policy
    name: policy-lvmcluster-delete
---
apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-policy-lvmcluster-delete
spec:
  clusterConditions:
    - status: "True"
      type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
      - key: mykey
        operator: In
        values:
          - myvalue</programlisting>
<calloutlist>
<callout arearefs="CO50-1">
<para>The <literal>policy-template</literal> <literal>spec.remediationAction</literal> is overridden by the preceding parameter value for <literal>spec.remediationAction</literal>.</para>
</callout>
<callout arearefs="CO50-2">
<para>This <literal>namespace</literal> field must have the <literal>openshift-storage</literal> value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Set the value of the <literal>PlacementRule.spec.clusterSelector</literal> field to select the clusters from which to uninstall LVM Storage.</simpara>
</listitem>
<listitem>
<simpara>Create the policy by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f lvms-remove-policy.yaml -n lvms-policy-ns</programlisting>
</listitem>
<listitem>
<simpara>To create a policy to check if the <literal>LVMCluster</literal> CR has been removed, save the following YAML to a file with a name such as <literal>check-lvms-remove-policy.yaml</literal>:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: policy-lvmcluster-inform
  annotations:
    policy.open-cluster-management.io/standards: NIST SP 800-53
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
spec:
  remediationAction: inform
  disabled: false
  policy-templates:
    - objectDefinition:
        apiVersion: policy.open-cluster-management.io/v1
        kind: ConfigurationPolicy
        metadata:
          name: policy-lvmcluster-removal-inform
        spec:
          remediationAction: inform <co xml:id="CO51-1"/>
          severity: low
          object-templates:
            - complianceType: mustnothave
              objectDefinition:
                kind: LVMCluster
                apiVersion: lvm.topolvm.io/v1alpha1
                metadata:
                  name: my-lvmcluster
                  namespace: openshift-storage <co xml:id="CO51-2"/>
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-policy-lvmcluster-check
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-policy-lvmcluster-check
subjects:
  - apiGroup: policy.open-cluster-management.io
    kind: Policy
    name: policy-lvmcluster-inform
---
apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-policy-lvmcluster-check
spec:
  clusterConditions:
    - status: "True"
      type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
      - key: mykey
        operator: In
        values:
          - myvalue</programlisting>
<calloutlist>
<callout arearefs="CO51-1">
<para>The <literal>policy-template</literal> <literal>spec.remediationAction</literal> is overridden by the preceding parameter value for <literal>spec.remediationAction</literal>.</para>
</callout>
<callout arearefs="CO51-2">
<para>The <literal>namespace</literal> field must have the <literal>openshift-storage</literal> value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the policy by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f check-lvms-remove-policy.yaml -n lvms-policy-ns</programlisting>
</listitem>
<listitem>
<simpara>Check the policy status by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get policy -n lvms-policy-ns</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                       REMEDIATION ACTION   COMPLIANCE STATE   AGE
policy-lvmcluster-delete   enforce              Compliant          15m
policy-lvmcluster-inform   inform               Compliant          15m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>After both the policies are compliant, save the following YAML to a file with a name such as <literal>lvms-uninstall-policy.yaml</literal> to create a policy to uninstall LVM Storage.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-uninstall-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-uninstall-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-uninstall-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: uninstall-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: uninstall-lvms
spec:
  disabled: false
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: uninstall-lvms
      spec:
        object-templates:
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              name: openshift-storage
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms-operator
              namespace: openshift-storage
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: policy-remove-lvms-crds
      spec:
        object-templates:
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: logicalvolumes.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmclusters.lvm.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmvolumegroupnodestatuses.lvm.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmvolumegroups.lvm.topolvm.io
        remediationAction: enforce
        severity: high</programlisting>
</listitem>
<listitem>
<simpara>Create the policy by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f lvms-uninstall-policy.yaml -ns lvms-policy-ns</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="lvms-creating-lvms-cluster_logical-volume-manager-storage">
<title>Creating a Logical Volume Manager cluster on a worker node</title>
<simpara>You can configure a worker node as a Logical Volume Manager cluster.
On the control-plane node, LVM Storage detects and uses the additional worker nodes when the new nodes become active in the cluster.</simpara>
<note>
<simpara>When you create a Logical Volume Manager cluster, <literal>StorageClass</literal> and <literal>LVMVolumeGroup</literal> resources work together to provide dynamic provisioning of storage.
<literal>StorageClass</literal> CRs define the properties of the storage that you can dynamically provision.
<literal>LVMVolumeGroup</literal> is a specific type of persistent volume (PV) that is backed by an LVM Volume Group.
<literal>LVMVolumeGroup</literal> CRs provide the back-end storage for the persistent volumes that you create.</simpara>
</note>
<simpara>Perform the following procedure to create a Logical Volume Manager cluster on a worker node.</simpara>
<note>
<simpara>You also can perform the same task by using the OpenShift Container Platform web console.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You installed LVM Storage in a cluster and have installed a worker node for use in the cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>LVMCluster</literal> custom resource (CR).</simpara>
<important>
<simpara>You can only create a single instance of the <literal>LVMCluster</literal> custom resource (CR) on an OpenShift Container Platform cluster.</simpara>
</important>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Save the following YAML in the <literal>lvmcluster.yaml</literal> file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: lvmcluster
spec:
  storage:
    deviceClasses:  <co xml:id="CO52-1"/>
      - name: vg1 <co xml:id="CO52-2"/>
        fstype: ext4 <co xml:id="CO52-3"/>
        default: true <co xml:id="CO52-4"/>
        deviceSelector: <co xml:id="CO52-5"/>
          paths:
          - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
          - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
          - /dev/md/md-var
          optionalPaths:
          - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
          - /dev/disk/by-path/pci-0000:90:00.0-nvme-1
          forceWipeDevicesAndDestroyAllData: true <co xml:id="CO52-6"/>
        thinPoolConfig:
          name: thin-pool-1
          sizePercent: 90
          overprovisionRatio: 10
        nodeSelector: <co xml:id="CO52-7"/>
          nodeSelectorTerms:
            - matchExpressions:
              - key: app
                operator: In
                values:
                - test1</programlisting>
<calloutlist>
<callout arearefs="CO52-1">
<para>To create multiple device storage classes in the cluster, create a YAML array under <literal>deviceClasses</literal> for each required storage class.
If you add or remove a <literal>deviceClass</literal>, then the update reflects in the cluster only after deleting and recreating the <literal>TopoLVM-Node</literal> pod.
Configure the local device paths of the disks as an array of values in the <literal>deviceSelector</literal> field.
When configuring multiple device classes, you must specify the device path for each device.</para>
</callout>
<callout arearefs="CO52-2">
<para>Specify a name for the LVM volume group (VG). To recover VGs from the previous LVM Storage installation, you must set this field to the name of the VG that you want to recover.
You can only recover the VGs but not the logical volume associated with the VG.</para>
</callout>
<callout arearefs="CO52-3">
<para>Set <literal>fstype</literal> to <literal>ext4</literal> or <literal>xfs</literal>. By default, it is set to <literal>xfs</literal> if the setting is not specified.</para>
</callout>
<callout arearefs="CO52-4">
<para>Mandatory: The <literal>LVMCluster</literal> resource must contain a single default storage class. Set <literal>default: false</literal> for secondary device storage classes.
If you are updating the <literal>LVMCluster</literal> resource from a previous version, you must specify a single default device class.</para>
</callout>
<callout arearefs="CO52-5">
<para>Optional. To control or restrict the volume group to your preferred devices, you can manually specify the local paths of the devices in the <literal>deviceSelector</literal> section of the <literal>LVMCluster</literal> YAML. The <literal>paths</literal> section refers to devices the <literal>LVMCluster</literal> adds, which means those paths must exist. The <literal>optionalPaths</literal> section refers to devices the <literal>LVMCluster</literal> might add. You must specify at least one of <literal>paths</literal> or <literal>optionalPaths</literal> when specifying the <literal>deviceSelector</literal> section. If you specify <literal>paths</literal>, it is not mandatory to specify <literal>optionalPaths</literal>. If you specify <literal>optionalPaths</literal>, it is not mandatory to specify <literal>paths</literal> but at least one optional path must be present on the node. If you do not specify any paths, then the <literal>LVMCluster</literal> adds the unused devices on the node. After a device is added to the <literal>LVMCluster</literal>, it cannot be removed.</para>
</callout>
<callout arearefs="CO52-6">
<para>Optional: To force wipe the selected disks, set <literal>forceWipeDevicesAndDestroyAllData</literal> to <literal>true</literal>. This parameter is set to <literal>false</literal> by default.</para>
</callout>
<callout arearefs="CO52-7">
<para>Optional: To control what worker nodes the <literal>LVMCluster</literal> CR is applied to, specify a set of node selector labels.
The specified labels must be present on the node in order for the <literal>LVMCluster</literal> to be scheduled on that node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the <literal>LVMCluster</literal> CR:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f lvmcluster.yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">lvmcluster/lvmcluster created</programlisting>
</para>
</formalpara>
<simpara>The <literal>LVMCluster</literal> resource creates the following system-managed CRs:</simpara>
<variablelist>
<varlistentry>
<term><literal>LVMVolumeGroup</literal></term>
<listitem>
<simpara>Tracks individual volume groups across multiple nodes.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>LVMVolumeGroupNodeStatus</literal></term>
<listitem>
<simpara>Tracks the status of the volume groups on a node.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>To recover VGs from the previous LVM Storage installation, ensure that the following conditions are met:</simpara>
<itemizedlist>
<listitem>
<simpara>VGs must not be corrupted.</simpara>
</listitem>
<listitem>
<simpara>VGs must have the <literal>lvms</literal> tag. For more information on adding tags to LVMS objects, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/configuring_and_managing_logical_volumes/grouping-lvm-objects-with-tags_configuring-and-managing-logical-volumes#doc-wrapper">Grouping LVM objects with tags</link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Wiping the disk can lead to inconsistencies in data integrity if any of the following conditions is met:</simpara>
<itemizedlist>
<listitem>
<simpara>The disk is being used as swap space.</simpara>
</listitem>
<listitem>
<simpara>The disk is part of the Redundant Array of Independent Disks (RAID).</simpara>
</listitem>
<listitem>
<simpara>The disk is mounted.</simpara>
</listitem>
</itemizedlist>
<simpara>In this case, you must manually wipe the disk.</simpara>
</note>
<formalpara>
<title>Verification</title>
<para>Verify that the <literal>LVMCluster</literal> resource has created the <literal>StorageClass</literal>, <literal>LVMVolumeGroup</literal>, and <literal>LVMVolumeGroupNodeStatus</literal> CRs.</para>
</formalpara>
<important>
<simpara><literal>LVMVolumeGroup</literal> and <literal>LVMVolumeGroupNodeStatus</literal> are managed by LVM Storage. Do not edit these CRs directly.</simpara>
</important>
<orderedlist numeration="arabic">
<listitem>
<simpara>Check that the <literal>LVMCluster</literal> CR is in a <literal>ready</literal> state by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get lvmclusters.lvm.topolvm.io -o jsonpath='{.items[*].status.deviceClassStatuses[*]}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="json" linenumbering="unnumbered">{
    "name": "vg1",
    "nodeStatus": [
        {
            "devices": [
                "/dev/nvme0n1",
                "/dev/nvme1n1",
                "/dev/nvme2n1"
            ],
            "node": "kube-node",
            "status": "Ready"
        }
    ]
}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the storage class is created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME          PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
lvms-vg1      topolvm.io           Delete          WaitForFirstConsumer   true                   31m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the volume snapshot class is created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get volumesnapshotclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME          DRIVER               DELETIONPOLICY   AGE
lvms-vg1      topolvm.io           Delete           24h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the <literal>LVMVolumeGroup</literal> resource is created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get lvmvolumegroup vg1 -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMVolumeGroup
metadata:
  creationTimestamp: "2022-02-02T05:16:42Z"
  generation: 1
  name: vg1
  namespace: lvm-operator-system
  resourceVersion: "17242461"
  uid: 88e8ad7d-1544-41fb-9a8e-12b1a66ab157
spec: {}</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that the <literal>LVMVolumeGroupNodeStatus</literal> resource is created:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get lvmvolumegroupnodestatuses.lvm.topolvm.io kube-node -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMVolumeGroupNodeStatus
metadata:
  creationTimestamp: "2022-02-02T05:17:59Z"
  generation: 1
  name: kube-node
  namespace: lvm-operator-system
  resourceVersion: "17242882"
  uid: 292de9bb-3a9b-4ee8-946a-9b587986dafd
spec:
  nodeStatus:
    - devices:
        - /dev/nvme0n1
        - /dev/nvme1n1
        - /dev/nvme2n1
      name: vg1
      status: Ready</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<section xml:id="lvms-unsupported-devices_logical-volume-manager-storage">
<title>Devices not supported by LVM Storage</title>
<simpara>When you are adding the device paths in the <literal>deviceSelector</literal> field of the <literal>LVMCluster</literal> custom resource (CR), ensure that the devices are supported by LVM Storage. If you add paths to the unsupported devices, LVM Storage excludes the devices to avoid complexity in managing logical volumes.</simpara>
<simpara>If you do not specify any device path in the <literal>deviceSelector</literal> field, LVM Storage adds only the unused devices that it supports.</simpara>
<note>
<simpara>To get information about the devices, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ lsblk --paths --json -o \
NAME,ROTA,TYPE,SIZE,MODEL,VENDOR,RO,STATE,KNAME,SERIAL,PARTLABEL,FSTYPE</programlisting>
</note>
<simpara>LVM Storage does not support the following devices:</simpara>
<variablelist>
<varlistentry>
<term>Read-only devices</term>
<listitem>
<simpara>Devices with the <literal>ro</literal> parameter set to <literal>true</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Suspended devices</term>
<listitem>
<simpara>Devices with the <literal>state</literal> parameter set to <literal>suspended</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>ROM devices</term>
<listitem>
<simpara>Devices with the <literal>type</literal> parameter set to <literal>rom</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>LVM partition devices</term>
<listitem>
<simpara>Devices with the <literal>type</literal> parameter set to <literal>lvm</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Devices with invalid partition labels</term>
<listitem>
<simpara>Devices with the <literal>partlabel</literal> parameter set to <literal>bios</literal>, <literal>boot</literal>, or <literal>reserved</literal>.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Devices with an invalid filesystem</term>
<listitem>
<simpara>Devices with the <literal>fstype</literal> parameter set to any value other than <literal>null</literal> or <literal>LVM2_member</literal>.</simpara>
<important>
<simpara>LVM Storage supports devices with <literal>fstype</literal> parameter set to <literal>LVM2_member</literal> only if the devices do not contain children devices.</simpara>
</important>
</listitem>
</varlistentry>
<varlistentry>
<term>Devices that are part of another volume group</term>
<listitem>
<simpara>To get the information about the volume groups of the device, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ pvs &lt;device-name&gt; <co xml:id="CO53-1"/></programlisting>
<calloutlist>
<callout arearefs="CO53-1">
<para>Replace <literal>&lt;device-name&gt;</literal> with the device name.</para>
</callout>
</calloutlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Devices with bind mounts</term>
<listitem>
<simpara>To get the mount points of a device, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ cat /proc/1/mountinfo | grep &lt;device-name&gt; <co xml:id="CO54-1"/></programlisting>
<calloutlist>
<callout arearefs="CO54-1">
<para>Replace <literal>&lt;device-name&gt;</literal> with the device name.</para>
</callout>
</calloutlist>
</listitem>
</varlistentry>
<varlistentry>
<term>Devices that contain children devices</term>
<listitem>
</listitem>
</varlistentry>
</variablelist>
<note>
<simpara>It is recommended to wipe the device before using it in LVM Storage to prevent unexpected behavior.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="lvms-integrating-software-raid-arrays_logical-volume-manager-storage">Integrating software RAID arrays with LVM Storage</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#">Adding worker nodes to single-node OpenShift clusters</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="lvms-integrating-software-raid-arrays_logical-volume-manager-storage">
<title>Integrating software RAID arrays with LVM Storage</title>
<simpara>You can create the Redundant Array of Independent Disks (RAID) array by using the <literal>mdadm</literal> utility, and integrate the RAID array with LVM Storage. Logical Volume Manager (LVM) does not support creating a software RAID.</simpara>
<simpara>You can integrate the RAID array with LVM Storage while creating the <literal>LVMCluster</literal> custom resource (CR).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You created a software RAID during the OpenShift Container Platform installation.</simpara>
<important>
<simpara>You can only create the RAID array during the installation of OpenShift Container Platform.</simpara>
</important>
</listitem>
<listitem>
<simpara>You have installed LVM Storage.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Open the <literal>LVMCluster</literal> CR YAML file.</simpara>
<note>
<simpara>If you have created the <literal>LVMCluster</literal> CR, edit the existing <literal>LVMCluster</literal> CR YAML file.</simpara>
</note>
</listitem>
<listitem>
<simpara>Add the path to the RAID array in the <literal>deviceSelector</literal> field of the <literal>LVMCluster</literal> CR YAML file.</simpara>
<formalpara>
<title>Example of RAID array paths in deviceSelector field</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  storage:
    deviceClasses:
# ...
      deviceSelector:  <co xml:id="CO55-1"/>
        paths:
        - /dev/md/md-var  <co xml:id="CO55-2"/>
        - /dev/md0  <co xml:id="CO55-3"/>
        optionalPaths:
# ...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO55-1">
<para>Contains the paths to the devices that are used to create the LVM volume group. You can specify the device paths in the <literal>paths</literal> field, the <literal>optionalPaths</literal> field, or both. You cannot remove or replace a device after adding it to the LVM volume group.</para>
</callout>
<callout arearefs="CO55-2">
<para>Example of a path to the RAID array that was created by using the <literal>mdadm</literal> utility. In this example, <literal>md-var</literal> is the RAID array.</para>
</callout>
<callout arearefs="CO55-3">
<para>In this device path example, <literal>md0</literal> is the RAID array</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Save the <literal>LVMCluster</literal> CR YAML file.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>If you do not add the path to the RAID array in the <literal>deviceSelector</literal> field, the LVM Storage Operator does not recognize the RAID array.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-special-config-raid_installing-customizing">Configuring a RAID-enabled data volume</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/managing_storage_devices/managing-raid_managing-storage-devices#creating-a-software-raid-on-an-installed-system_managing-raid">Creating a software RAID on an installed system</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/managing_storage_devices/managing-raid_managing-storage-devices#replacing-a-failed-disk-in-raid_managing-raid">Replacing a failed disk in RAID</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html/managing_storage_devices/managing-raid_managing-storage-devices#repairing-raid-disks_managing-raid">Repairing RAID disks</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-provisioning-storage-using-lvms_logical-volume-manager-storage">
<title>Provisioning storage using LVM Storage</title>
<simpara>You can provision persistent volume claims (PVCs) using the storage class that is created during the Operator installation. You can provision block and file PVCs, however, the storage is allocated only when a pod that uses the PVC is created.</simpara>
<note>
<simpara>LVM Storage provisions PVCs in units of 1 GiB. The requested storage is rounded up to the nearest GiB.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Identify the <literal>StorageClass</literal> that is created when LVM Storage is deployed.</simpara>
<simpara>The <literal>StorageClass</literal> name is in the format, <literal>lvms-&lt;device-class-name&gt;</literal>.
The <literal>device-class-name</literal> is the name of the device class that you provided in the <literal>LVMCluster</literal> of the <literal>Policy</literal> YAML.
For example, if the <literal>deviceClass</literal> is called <literal>vg1</literal>, then the <literal>storageClass</literal> name is <literal>lvms-vg1</literal>.</simpara>
<simpara>The <literal>volumeBindingMode</literal> of the storage class is set to <literal>WaitForFirstConsumer</literal>.</simpara>
</listitem>
<listitem>
<simpara>To create a PVC where the application requires storage, save the following YAML to a file with a name such as <literal>pvc.yaml</literal>.</simpara>
<formalpara>
<title>Example YAML to create a PVC</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered"># block pvc
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: lvm-block-1
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  resources:
    requests:
      storage: 10Gi
  storageClassName: lvms-vg1
---
# file pvc
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: lvm-file-1
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 10Gi
  storageClassName: lvms-vg1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the PVC by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f pvc.yaml -ns &lt;application_namespace&gt;</programlisting>
<simpara>The created PVCs remain in <literal>pending</literal> state until you deploy the pods that use them.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="lvms-monitoring-using-lvms_logical-volume-manager-storage">
<title>Monitoring LVM Storage</title>
<simpara>When you use RHACM to install LVM Storage, you must configure RHACM Observability to monitor all the clusters from one place.</simpara>
<section xml:id="lvms-monitoring-using-lvms-metrics_logical-volume-manager-storage">
<title>Metrics</title>
<simpara>You can monitor LVM Storage by viewing the metrics exported by the Operator on the RHACM dashboards and the alerts that are triggered.</simpara>
<itemizedlist>
<listitem>
<simpara>Add the following <literal>topolvm</literal> metrics to the <literal>allow</literal> list:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">topolvm_thinpool_data_percent
topolvm_thinpool_metadata_percent
topolvm_thinpool_size_bytes</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>Metrics are updated every 10 minutes or when there is a change in the thin pool, such as a new logical volume creation.</simpara>
</note>
</section>
<section xml:id="lvms-monitoring-using-lvms-alerts_logical-volume-manager-storage">
<title>Alerts</title>
<simpara>When the thin pool and volume group are filled up, further operations fail and might lead to data loss.
LVM Storage sends the following alerts about the usage of the thin pool and volume group when utilization crosses a certain value:</simpara>
<formalpara>
<title>Alerts for Logical Volume Manager cluster in RHACM</title>
<para><anchor xml:id="alerts_for_LVMCluster_in_RHACM" xreflabel="[alerts_for_LVMCluster_in_RHACM]"/></para>
</formalpara>
<informaltable frame="topbot" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Alert</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeGroupUsageAtThresholdNearFull</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when both the volume group and thin pool utilization cross 75% on nodes. Data deletion or volume group expansion is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>VolumeGroupUsageAtThresholdCritical</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when both the volume group and thin pool utilization cross 85% on nodes. <literal>VolumeGroup</literal> is critically full. Data deletion or volume group expansion is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ThinPoolDataUsageAtThresholdNearFull</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when the thin pool data utilization in the volume group crosses 75% on nodes. Data deletion or thin pool expansion is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ThinPoolDataUsageAtThresholdCritical</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when  the thin pool data utilization in the volume group crosses 85% on nodes. Data deletion or thin pool expansion is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ThinPoolMetaDataUsageAtThresholdNearFull</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when the thin pool metadata utilization in the volume group crosses 75% on nodes. Data deletion or thin pool expansion is required.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ThinPoolMetaDataUsageAtThresholdCritical</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This alert is triggered when the thin pool metadata utilization in the volume group crosses 85% on nodes. Data deletion or thin pool expansion is required.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html-single/observability/index">Observability</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html-single/observability/index#adding-custom-metrics">Adding custom metrics</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="lvms-scaling-storage-of-single-node-openshift-cluster-con_logical-volume-manager-storage">
<title>Scaling storage of clusters</title>
<simpara>The OpenShift Container Platform supports additional worker nodes for clusters on bare-metal user-provisioned infrastructure.
LVM Storage detects and uses the new additional worker nodes when the nodes show up.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#">Adding worker nodes to single-node OpenShift clusters</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="lvms-scaling-storage-of-single-node-openshift-cluster_logical-volume-manager-storage">
<title>Scaling up storage by adding capacity to your cluster</title>
<simpara>To scale the storage capacity of your configured worker nodes on a cluster, you can increase the capacity by adding disks.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have additional unused disks on each cluster to be used by LVM Storage.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to OpenShift Container Platform console of the cluster.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis> page, click on the <emphasis role="strong">LVM Storage Operator</emphasis> in the <literal>openshift-storage</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>Click on the <emphasis role="strong">LVMCluster</emphasis> tab to list the <literal>LVMCluster</literal> CR created on the cluster.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Edit LVMCluster</emphasis> from the <emphasis role="strong">Actions</emphasis> drop-down menu.</simpara>
</listitem>
<listitem>
<simpara>Click on the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Edit the <literal>LVMCluster</literal> CR YAML to add the new device path in the <literal>deviceSelector</literal> section:</simpara>
<note>
<simpara>In case the <literal>deviceSelector</literal> field is not included during the <literal>LVMCluster</literal> creation, it is not possible to add the <literal>deviceSelector</literal> section to the CR.
You need to remove the <literal>LVMCluster</literal> and then create a new CR.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  storage:
    deviceClasses:
    - name: vg1
      default: true
      deviceSelector: <co xml:id="CO56-1"/>
        paths:
        - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
        optionalPaths:
        - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:90:00.0-nvme-1
      thinPoolConfig:
        name: thin-pool-1
        sizePercent: 90
        overprovisionRatio: 10</programlisting>
<calloutlist>
<callout arearefs="CO56-1">
<para>Optional. To control or restrict the volume group to your preferred devices, you can manually specify the local paths of the devices in the <literal>deviceSelector</literal> section of the <literal>LVMCluster</literal> YAML. The <literal>paths</literal> section refers to devices the <literal>LVMCluster</literal> adds, which means those paths must exist. The <literal>optionalPaths</literal> section refers to devices the <literal>LVMCluster</literal> might add. You must specify at least one of <literal>paths</literal> or <literal>optionalPaths</literal> when specifying the <literal>deviceSelector</literal> section. If you specify <literal>paths</literal>, it is not mandatory to specify <literal>optionalPaths</literal>. If you specify <literal>optionalPaths</literal>, it is not mandatory to specify <literal>paths</literal> but at least one optional path must be present on the node. If you do not specify any paths, it will add all unused devices on the node.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-scaling-storage-of-single-node-openshift-cluster-using-rhacm_logical-volume-manager-storage">
<title>Scaling up storage by adding capacity to your cluster using RHACM</title>
<simpara>You can scale the storage capacity of your configured worker nodes on a cluster using RHACM.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have access to the RHACM cluster using an account with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
<listitem>
<simpara>You have additional unused devices on each cluster that LVM Storage can use.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the RHACM CLI using your OpenShift Container Platform credentials.</simpara>
</listitem>
<listitem>
<simpara>Find the device that you want to add. The device to be added needs to match with the device name and path of the existing devices.</simpara>
</listitem>
<listitem>
<simpara>To add capacity to the cluster, edit the <literal>deviceSelector</literal> section of the existing policy YAML, for example, <literal>policy-lvms-operator.yaml</literal>.</simpara>
<note>
<simpara>In case the <literal>deviceSelector</literal> field is not included during the <literal>LVMCluster</literal> creation, it is not possible to add the <literal>deviceSelector</literal> section to the CR. You need to remove the <literal>LVMCluster</literal> and then recreate it from the new CR.</simpara>
</note>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-install-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-install-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-install-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: install-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: install-lvms
spec:
  disabled: false
  remediationAction: enforce
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: install-lvms
      spec:
        object-templates:
        - complianceType: musthave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                openshift.io/cluster-monitoring: "true"
                pod-security.kubernetes.io/enforce: privileged
                pod-security.kubernetes.io/audit: privileged
                pod-security.kubernetes.io/warn: privileged
              name: openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms
              namespace: openshift-storage
            spec:
              installPlanApproval: Automatic
              name: lvms-operator
              source: redhat-operators
              sourceNamespace: openshift-marketplace
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: lvms
      spec:
        object-templates:
           - complianceType: musthave
             objectDefinition:
               apiVersion: lvm.topolvm.io/v1alpha1
               kind: LVMCluster
               metadata:
                 name: my-lvmcluster
                 namespace: openshift-storage
               spec:
                 storage:
                   deviceClasses:
                   - name: vg1
                     default: true
                     deviceSelector: <co xml:id="CO57-1"/>
                       paths:
                       - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
                       optionalPaths:
                       - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:90:00.0-nvme-1
                     thinPoolConfig:
                       name: thin-pool-1
                       sizePercent: 90
                       overprovisionRatio: 10
                     nodeSelector:
                       nodeSelectorTerms:
                       - matchExpressions:
                           - key: app
                             operator: In
                             values:
                             - test1
        remediationAction: enforce
        severity: low</programlisting>
<calloutlist>
<callout arearefs="CO57-1">
<para>Optional. To control or restrict the volume group to your preferred devices, you can manually specify the local paths of the devices in the <literal>deviceSelector</literal> section of the <literal>LVMCluster</literal> YAML. The <literal>paths</literal> section refers to devices the <literal>LVMCluster</literal> adds, which means those paths must exist. The <literal>optionalPaths</literal> section refers to devices the <literal>LVMCluster</literal> might add. You must specify at least one of <literal>paths</literal> or <literal>optionalPaths</literal> when specifying the <literal>deviceSelector</literal> section. If you specify <literal>paths</literal>, it is not mandatory to specify <literal>optionalPaths</literal>. If you specify <literal>optionalPaths</literal>, it is not mandatory to specify <literal>paths</literal> but at least one optional path must be present on the node. If you do not specify any paths, it will add all unused devices on the node.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Edit the policy by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc edit -f policy-lvms-operator.yaml -ns lvms-policy-ns <co xml:id="CO58-1"/></programlisting>
<calloutlist>
<callout arearefs="CO58-1">
<para>The <literal>policy-lvms-operator.yaml</literal> is the name of the existing policy.</para>
</callout>
</calloutlist>
<simpara>This uses the new disk specified in the <literal>LVMCluster</literal> CR to provision storage.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.9/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-scaling-expand-pvc_logical-volume-manager-storage">
<title>Expanding PVCs</title>
<simpara>To leverage the new storage after adding additional capacity, you can expand existing persistent volume claims (PVCs) with LVM Storage.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Dynamic provisioning is used.</simpara>
</listitem>
<listitem>
<simpara>The controlling <literal>StorageClass</literal> object has <literal>allowVolumeExpansion</literal> set to <literal>true</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Modify the <literal>.spec.resources.requests.storage</literal> field in the desired PVC resource to the new size by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc patch &lt;pvc_name&gt; -n &lt;application_namespace&gt; -p '{ "spec": { "resources": { "requests": { "storage": "&lt;desired_size&gt;" }}}}'</programlisting>
</listitem>
<listitem>
<simpara>Watch the <literal>status.conditions</literal> field of the PVC to see if the resize has completed. OpenShift Container Platform adds the <literal>Resizing</literal> condition to the PVC during expansion, which is removed after the expansion completes.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="lvms-scaling-storage-of-single-node-openshift-cluster_logical-volume-manager-storage">Scaling up storage by adding capacity to your cluster</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="lvms-scaling-storage-of-single-node-openshift-cluster-using-rhacm_logical-volume-manager-storage">Scaling up storage by adding capacity to your cluster using RHACM</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="add-volume-expansion_expanding-persistent-volumes">Enabling volume expansion support</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="lvms-upgrading-lvms-on-sno_logical-volume-manager-storage">
<title>Updating LVM Storage on clusters</title>
<simpara>You can update the Logical volume manager storage (LVM Storage) Operator to ensure compatibility with your OpenShift Container Platform version.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have updated your cluster.</simpara>
</listitem>
<listitem>
<simpara>You have installed a previous version of the LVM Storage Operator.</simpara>
</listitem>
<listitem>
<simpara>You have installed the OpenShift CLI (<literal>oc</literal>).</simpara>
</listitem>
<listitem>
<simpara>You have logged in as a user with <literal>cluster-admin</literal> privileges.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Update the <literal>Subscription</literal> resource for the LVM Storage Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch subscription lvms-operator -n openshift-storage --type merge --patch '{"spec":{"channel":"&lt;update-channel&gt;"}}' <co xml:id="CO59-1"/></programlisting>
<calloutlist>
<callout arearefs="CO59-1">
<para>Replace <literal>&lt;update-channel&gt;</literal> with the version of the LVM Storage Operator that you want to install, for example <literal>stable-4.14</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>View the update events to check that the installation is complete by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get events -n openshift-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
8m13s       Normal    RequirementsUnknown   clusterserviceversion/lvms-operator.v4.14   requirements not yet checked
8m11s       Normal    RequirementsNotMet    clusterserviceversion/lvms-operator.v4.14   one or more requirements couldn't be found
7m50s       Normal    AllRequirementsMet    clusterserviceversion/lvms-operator.v4.14   all requirements found, attempting install
7m50s       Normal    InstallSucceeded      clusterserviceversion/lvms-operator.v4.14   waiting for install components to report healthy
7m49s       Normal    InstallWaiting        clusterserviceversion/lvms-operator.v4.14   installing: waiting for deployment lvms-operator to become ready: deployment "lvms-operator" waiting for 1 outdated replica(s) to be terminated
7m39s       Normal    InstallSucceeded      clusterserviceversion/lvms-operator.v4.14   install strategy completed with no errors
...</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Verification</title>
<listitem>
<simpara>Verify the version of the LVM Storage Operator by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get subscription lvms-operator -n openshift-storage -o jsonpath='{.status.installedCSV}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">lvms-operator.v4.14</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-volume-snapsot-for-sno_logical-volume-manager-storage">
<title>Volume snapshots</title>
<simpara>You can take volume snapshots of persistent volumes (PVs) that are provisioned by LVM Storage.
You can also create volume snapshots of the cloned volumes. Volume snapshots help you to do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Back up your application data.</simpara>
<important>
<simpara>Volume snapshots are located on the same devices as the original data. To use the volume snapshots as backups, you need to move the snapshots to a secure location. You can use OpenShift API for Data Protection backup and restore solutions.</simpara>
</important>
</listitem>
<listitem>
<simpara>Revert to a state at which the volume snapshot was taken.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Before creating volume snapshots, you must be aware of the limitations. For information about the limitations, see <link linkend="lvms-limitations-for-creating-snapshots-and-clones_logical-volume-manager-storage">Limitations for creating volume snapshots and volume clones</link>.</simpara>
</note>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/backup_and_restore/#oadp-features_oadp-features-plugins">OADP features</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="lvms-creating-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage">
<title>Creating volume snapshots</title>
<simpara>You can create volume snapshots based on the available capacity of the thin pool and the overprovisioning limits.
LVM Storage creates a <literal>VolumeSnapshotClass</literal> with the <literal>lvms-&lt;deviceclass-name&gt;</literal> name.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You ensured that the persistent volume claim (PVC) is in <literal>Bound</literal> state. This is required for a consistent snapshot.</simpara>
</listitem>
<listitem>
<simpara>You stopped all the I/O to the PVC before taking the snapshot.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Log in to the OpenShift Container Platform by running the <literal>oc</literal> command.</simpara>
</listitem>
<listitem>
<simpara>Save the following YAML to a file with a name such as <literal>lvms-vol-snapshot.yaml</literal>.</simpara>
<formalpara>
<title>Example YAML to create a volume snapshot</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
    name: lvm-block-1-snap
spec:
    volumeSnapshotClassName: lvms-vg1
    source:
        persistentVolumeClaimName: lvm-block-1</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the snapshot by running the following command in the same namespace as the PVC:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f lvms-vol-snapshot.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>A read-only copy of the PVC is created as a volume snapshot.</simpara>
</section>
<section xml:id="lvms-restoring-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage">
<title>Restoring volume snapshots</title>
<simpara>When you restore a volume snapshot, a new persistent volume claim (PVC) is created.
The restored PVC is independent of the volume snapshot and the source PVC.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The storage class must be the same as that of the source PVC.</simpara>
</listitem>
<listitem>
<simpara>The size of the requested PVC must be the same as that of the source volume of the snapshot.</simpara>
<important>
<simpara>A snapshot must be restored to a PVC of the same size as the source volume of the snapshot. If a larger PVC is required, you can resize the PVC after the snapshot is restored successfully.</simpara>
</important>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Identify the storage class name of the source PVC and volume snapshot name.</simpara>
</listitem>
<listitem>
<simpara>Save the following YAML to a file with a name such as <literal>lvms-vol-restore.yaml</literal> to restore the snapshot.</simpara>
<formalpara>
<title>Example YAML to restore a PVC.</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: lvm-block-1-restore
spec:
  accessModes:
  - ReadWriteOnce
  volumeMode: Block
  Resources:
    Requests:
      storage: 2Gi
  storageClassName: lvms-vg1
  dataSource:
    name: lvm-block-1-snap
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the policy by running the following command in the same namespace as the snapshot:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f lvms-vol-restore.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="lvms-deleting-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage">
<title>Deleting volume snapshots</title>
<simpara>You can delete volume snapshots resources and persistent volume claims (PVCs).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Delete the volume snapshot resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc delete volumesnapshot &lt;volume_snapshot_name&gt; -n &lt;namespace&gt;</programlisting>
<note>
<simpara>When you delete a persistent volume claim (PVC), the snapshots of the PVC are not deleted.</simpara>
</note>
</listitem>
<listitem>
<simpara>To delete the restored volume snapshot, delete the PVC that was created to restore the volume snapshot by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc delete pvc &lt;pvc_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="lvms-volume-cloning-for-single-node-openshift-cluster_logical-volume-manager-storage">
<title>Volume cloning</title>
<simpara>A clone is a duplicate of an existing storage volume that can be used like any standard volume.</simpara>
<note>
<simpara>Before creating volume clones, you must be aware of the limitations. For information about limitations, see <link linkend="lvms-limitations-for-creating-snapshots-and-clones_logical-volume-manager-storage">Limitations for creating volume snapshots and volume clones</link>.</simpara>
</note>
<section xml:id="lvms-creating-volume-clones-in-single-node-openshift_logical-volume-manager-storage">
<title>Creating volume clones</title>
<simpara>You create a clone of a volume to make a point-in-time copy of the data.
A persistent volume claim (PVC) cannot be cloned with a different size.</simpara>
<important>
<simpara>The cloned PVC has write access.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You ensured that the PVC is in <literal>Bound</literal> state. This is required for a consistent snapshot.</simpara>
</listitem>
<listitem>
<simpara>You ensured that the <literal>StorageClass</literal> is the same as that of the source PVC.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Identify the storage class of the source PVC.</simpara>
</listitem>
<listitem>
<simpara>To create a volume clone, save the following YAML to a file with a name such as <literal>lvms-vol-clone.yaml</literal>:</simpara>
<formalpara>
<title>Example YAML to clone a volume</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
Metadata:
  name: lvm-block-1-clone
Spec:
  storageClassName: lvms-vg1
  dataSource:
    name: lvm-block-1
    kind: PersistentVolumeClaim
  accessModes:
   - ReadWriteOnce
  volumeMode: Block
  Resources:
    Requests:
      storage: 2Gi</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create the policy in the same namespace as the source PVC by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc create -f lvms-vol-clone.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="lvms-deleting-cloned-volumes-in-single-node-openshift_logical-volume-manager-storage">
<title>Deleting cloned volumes</title>
<simpara>You can delete cloned volumes.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To delete the cloned volume, delete the cloned PVC by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc delete pvc &lt;clone_pvc_name&gt; -n &lt;namespace&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="lvms-limitations-for-creating-snapshots-and-clones_logical-volume-manager-storage">
<title>Limitations for creating volume snapshots and volume clones</title>
<simpara>LVM Storage has the following limitations for creating volume snapshots and volume clones in multi-node topology:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating volume snapshots and volume clones is based on the LVM thin pool capabilities.</simpara>
</listitem>
<listitem>
<simpara>The node must have additional storage after creating a volume snapshot and volume clone for further updating the original data source.</simpara>
</listitem>
<listitem>
<simpara>You can create volume snapshots and volume clones only on the node where you have deployed the original data source.</simpara>
</listitem>
<listitem>
<simpara>Pods relying on the persistent volume claim (PVC) that uses the snapshot data and clone data can be scheduled only on the node where you have deployed the original data source.</simpara>
</listitem>
<listitem>
<simpara>If the PVC is not present and available before creating a volume snapshot or volume clone, then the scheduler in multi-node OpenShift Container Platform clusters does not provision the volume snapshots and volume clones on the node where you have deployed the original data source.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-dowloading-log-files-and-diagnostics_logical-volume-manager-storage">
<title>Downloading log files and diagnostic information using must-gather</title>
<simpara>When LVM Storage is unable to automatically resolve a problem, use the must-gather tool to collect the log files and diagnostic information so that you or the Red Hat Support can review the problem and determine a solution.</simpara>
<itemizedlist>
<listitem>
<simpara>Run the must-gather command from the client connected to LVM Storage cluster by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather --image=registry.redhat.io/lvms4/lvms-must-gather-rhel9:v4.14 --dest-dir=&lt;directory-name&gt;</programlisting>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/support/#about-must-gather_gathering-cluster-data">About the must-gather tool</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="lvms-reference-file_logical-volume-manager-storage">
<title>LVM Storage reference YAML file</title>
<simpara>The sample <literal>LVMCluster</literal> custom resource (CR) describes all the fields in the YAML file.</simpara>
<formalpara>
<title>Example LVMCluster CR</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  tolerations:
  - effect: NoSchedule
    key: xyz
    operator: Equal
    value: "true"
  storage:
    deviceClasses:    <co xml:id="CO60-1"/>
    - name: vg1    <co xml:id="CO60-2"/>
      default: true
      nodeSelector: <co xml:id="CO60-3"/>
        nodeSelectorTerms: <co xml:id="CO60-4"/>
        - matchExpressions:
          - key: mykey
            operator: In
            values:
            - ssd
      deviceSelector: <co xml:id="CO60-5"/>
        paths:
        - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
        optionalPaths:
        - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:90:00.0-nvme-1
        forceWipeDevicesAndDestroyAllData: true <co xml:id="CO60-6"/>
      thinPoolConfig: <co xml:id="CO60-7"/>
        name: thin-pool-1 <co xml:id="CO60-8"/>
        sizePercent: 90 <co xml:id="CO60-9"/>
        overprovisionRatio: 10 <co xml:id="CO60-10"/>
status:
    deviceClassStatuses: <co xml:id="CO60-11"/>
    - name: vg1
      nodeStatus: <co xml:id="CO60-12"/>
      - devices: <co xml:id="CO60-13"/>
        - /dev/nvme0n1
        - /dev/nvme1n1
        - /dev/nvme2n1
        node: my-node.example.com <co xml:id="CO60-14"/>
        status: Ready <co xml:id="CO60-15"/>
    ready: true <co xml:id="CO60-16"/>
    state: Ready <co xml:id="CO60-17"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO60-1">
<para>The LVM volume groups to be created on the cluster. Currently, only a single <literal>deviceClass</literal> is supported.</para>
</callout>
<callout arearefs="CO60-2">
<para>The name of the LVM volume group to be created on the nodes.</para>
</callout>
<callout arearefs="CO60-3">
<para>The nodes on which to create the LVM volume group. If the field is empty, all nodes are considered.</para>
</callout>
<callout arearefs="CO60-4">
<para>A list of node selector requirements.</para>
</callout>
<callout arearefs="CO60-5">
<para>A list of device paths which is used to create the LVM volume group. If this field is empty, all unused disks on the node will be used.</para>
</callout>
<callout arearefs="CO60-6">
<para>To force wipe the selected disks, set this parameter to <literal>true</literal>. This parameter is set to <literal>false</literal> by default.</para>
</callout>
<callout arearefs="CO60-7">
<para>The LVM thin pool configuration.</para>
</callout>
<callout arearefs="CO60-8">
<para>The name of the thin pool to be created in the LVM volume group.</para>
</callout>
<callout arearefs="CO60-9">
<para>The percentage of remaining space in the LVM volume group that should be used for creating the thin pool.</para>
</callout>
<callout arearefs="CO60-10">
<para>The factor by which additional storage can be provisioned compared to the available storage in the thin pool.</para>
</callout>
<callout arearefs="CO60-11">
<para>The status of the <literal>deviceClass</literal>.</para>
</callout>
<callout arearefs="CO60-12">
<para>The status of the LVM volume group on each node.</para>
</callout>
<callout arearefs="CO60-13">
<para>The list of devices used to create the LVM volume group.</para>
</callout>
<callout arearefs="CO60-14">
<para>The node on which the <literal>deviceClass</literal> was created.</para>
</callout>
<callout arearefs="CO60-15">
<para>The status of the LVM volume group on the node.</para>
</callout>
<callout arearefs="CO60-16">
<para>This field is deprecated.</para>
</callout>
<callout arearefs="CO60-17">
<para>The status of the <literal>LVMCluster</literal>.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="troubleshooting-local-persistent-storage">
<title>Troubleshooting local persistent storage using LVMS</title>

<simpara>Because OpenShift Container Platform does not scope a persistent volume (PV) to a single project, it can be shared across the cluster and claimed by any project using a persistent volume claim (PVC). This can lead to a number of issues that require troubleshooting.</simpara>
<section xml:id="investigating-a-pvc-stuck-in-the-pending-state_troubleshooting-local-persistent-storage-using-lvms">
<title>Investigating a PVC stuck in the Pending state</title>
<simpara>A persistent volume claim (PVC) can get stuck in a <literal>Pending</literal> state for a number of reasons. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Insufficient computing resources</simpara>
</listitem>
<listitem>
<simpara>Network problems</simpara>
</listitem>
<listitem>
<simpara>Mismatched storage class or node selector</simpara>
</listitem>
<listitem>
<simpara>No available volumes</simpara>
</listitem>
<listitem>
<simpara>The node with the persistent volume (PV) is in a <literal>Not Ready</literal> state</simpara>
</listitem>
</itemizedlist>
<simpara>Identify the cause by using the <literal>oc describe</literal> command to review details about the stuck PVC.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Retrieve the list of PVCs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME        STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
lvms-test   Pending                                      lvms-vg1       11s</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Inspect the events associated with a PVC stuck in the <literal>Pending</literal> state by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pvc &lt;pvc_name&gt; <co xml:id="CO61-1"/></programlisting>
<calloutlist>
<callout arearefs="CO61-1">
<para>Replace <literal>&lt;pvc_name&gt;</literal> with the name of the PVC. For example, <literal>lvms-vg1</literal>.</para>
</callout>
</calloutlist>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Type     Reason              Age               From                         Message
----     ------              ----              ----                         -------
Warning  ProvisioningFailed  4s (x2 over 17s)  persistentvolume-controller  storageclass.storage.k8s.io "lvms-vg1" not found</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
<section xml:id="recovering-from-missing-lvms-or-operator-components_troubleshooting-local-persistent-storage-using-lvms">
<title>Recovering from missing LVMS or Operator components</title>
<simpara>If you encounter a storage class "not found" error, check the <literal>LVMCluster</literal> resource and ensure that all the logical volume manager storage (LVMS) pods are running. You can create an <literal>LVMCluster</literal> resource if it does not exist.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Verify the presence of the LVMCluster resource by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get lvmcluster -n openshift-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME            AGE
my-lvmcluster   65m</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the cluster doesn&#8217;t have an <literal>LVMCluster</literal> resource, create one by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -n openshift-storage -f &lt;custom_resource&gt; <co xml:id="CO62-1"/></programlisting>
<calloutlist>
<callout arearefs="CO62-1">
<para>Replace <literal>&lt;custom_resource&gt;</literal> with a custom resource URL or file tailored to your requirements.</para>
</callout>
</calloutlist>
<formalpara role="white-space-pre">
<title>Example custom resource</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  storage:
    deviceClasses:
    - name: vg1
      default: true
      thinPoolConfig:
        name: thin-pool-1
        sizePercent: 90
        overprovisionRatio: 10</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Check that all the pods from LVMS are in the <literal>Running</literal> state in the <literal>openshift-storage</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY   STATUS    RESTARTS      AGE
lvms-operator-7b9fb858cb-6nsml        3/3     Running   0             70m
topolvm-controller-5dd9cf78b5-7wwr2   5/5     Running   0             66m
topolvm-node-dr26h                    4/4     Running   0             66m
vg-manager-r6zdv                      1/1     Running   0             66m</programlisting>
</para>
</formalpara>
<simpara>The expected output is one running instance of <literal>lvms-operator</literal> and <literal>vg-manager</literal>. One instance of <literal>topolvm-controller</literal> and <literal>topolvm-node</literal> is expected for each node.</simpara>
<simpara>If <literal>topolvm-node</literal> is stuck in the <literal>Init</literal> state, there is a failure to locate an available disk for LVMS to use. To retrieve the information necessary to troubleshoot, review the logs of the <literal>vg-manager</literal> pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc logs -l app.kubernetes.io/component=vg-manager -n openshift-storage</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="recovering-from-node-failure_troubleshooting-local-persistent-storage-using-lvms">
<title>Recovering from node failure</title>
<simpara>Sometimes a persistent volume claim (PVC) is stuck in a <literal>Pending</literal> state because a particular node in the cluster has failed. To identify the failed node, you can examine the restart count of the <literal>topolvm-node</literal> pod. An increased restart count indicates potential problems with the underlying node, which may require further investigation and troubleshooting.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Examine the restart count of the <literal>topolvm-node</literal> pod instances by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pods -n openshift-storage</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                                  READY   STATUS    RESTARTS      AGE
lvms-operator-7b9fb858cb-6nsml        3/3     Running   0             70m
topolvm-controller-5dd9cf78b5-7wwr2   5/5     Running   0             66m
topolvm-node-dr26h                    4/4     Running   0             66m
topolvm-node-54as8                    4/4     Running   0             66m
topolvm-node-78fft                    4/4     Running   17 (8s ago)   66m
vg-manager-r6zdv                      1/1     Running   0             66m
vg-manager-990ut                      1/1     Running   0             66m
vg-manager-an118                      1/1     Running   0             66m</programlisting>
</para>
</formalpara>
<simpara>After you resolve any issues with the node, you might need to perform the forced cleanup procedure if the PVC is still stuck in a <literal>Pending</literal> state.</simpara>
</listitem>
</itemizedlist>
<itemizedlist xml:id="additional-resources-forced-cleanup-1" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/null/#performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms">Performing a forced cleanup</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="recovering-from-disk-failure_troubleshooting-local-persistent-storage-using-lvms">
<title>Recovering from disk failure</title>
<simpara>If you see a failure message while inspecting the events associated with the persistent volume claim (PVC), there might be a problem with the underlying volume or disk. Disk and volume provisioning issues often result with a generic error first, such as <literal>Failed to provision volume with StorageClass &lt;storage_class_name&gt;</literal>. A second, more specific error message usually follows.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Inspect the events associated with a PVC by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pvc &lt;pvc_name&gt; <co xml:id="CO63-1"/></programlisting>
<calloutlist>
<callout arearefs="CO63-1">
<para>Replace <literal>&lt;pvc_name&gt;</literal> with the name of the PVC. Here are some examples of disk or volume failure error messages and their causes:</para>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Failed to check volume existence:</emphasis> Indicates a problem in verifying whether the volume already exists. Volume verification failure can be caused by network connectivity problems or other failures.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Failed to bind volume:</emphasis> Failure to bind a volume can happen if the persistent volume (PV) that is available does not match the requirements of the PVC.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">FailedMount or FailedUnMount:</emphasis> This error indicates problems when trying to mount the volume to a node or unmount a volume from a node. If the disk has failed, this error might appear when a pod tries to use the PVC.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Volume is already exclusively attached to one node and can&#8217;t be attached to another:</emphasis> This error can appear with storage solutions that do not support <literal>ReadWriteMany</literal> access modes.</simpara>
</listitem>
</itemizedlist>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Establish a direct connection to the host where the problem is occurring.</simpara>
</listitem>
<listitem>
<simpara>Resolve the disk issue.</simpara>
</listitem>
</orderedlist>
<simpara>After you have resolved the issue with the disk, you might need to perform the forced cleanup procedure if failure messages persist or reoccur.</simpara>
<itemizedlist xml:id="additional-resources-forced-cleanup-2" role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/null/#performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms">Performing a forced cleanup</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms">
<title>Performing a forced cleanup</title>
<simpara>If disk- or node-related problems persist after you complete the troubleshooting procedures, it might be necessary to perform a forced cleanup procedure. A forced cleanup is used to comprehensively address persistent issues and ensure the proper functioning of the LVMS.</simpara>
<orderedlist numeration="arabic">
<title>Prerequisites</title>
<listitem>
<simpara>All of the persistent volume claims (PVCs) created using the logical volume manager storage (LVMS) driver have been removed.</simpara>
</listitem>
<listitem>
<simpara>The pods using those PVCs have been stopped.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Switch to the <literal>openshift-storage</literal> namespace by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc project openshift-storage</programlisting>
</listitem>
<listitem>
<simpara>Ensure there is no <literal>Logical Volume</literal> custom resource (CR) remaining by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get logicalvolume</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">No resources found</programlisting>
</para>
</formalpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If there are any <literal>LogicalVolume</literal> CRs remaining, remove their finalizers by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch logicalvolume &lt;name&gt; -p '{"metadata":{"finalizers":[]}}' --type=merge <co xml:id="CO64-1"/></programlisting>
<calloutlist>
<callout arearefs="CO64-1">
<para>Replace <literal>&lt;name&gt;</literal> with the name of the CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After removing their finalizers, delete the CRs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete logicalvolume &lt;name&gt; <co xml:id="CO65-1"/></programlisting>
<calloutlist>
<callout arearefs="CO65-1">
<para>Replace <literal>&lt;name&gt;</literal> with the name of the CR.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Make sure there are no <literal>LVMVolumeGroup</literal> CRs left by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get lvmvolumegroup</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">No resources found</programlisting>
</para>
</formalpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If there are any <literal>LVMVolumeGroup</literal> CRs left, remove their finalizers by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch lvmvolumegroup &lt;name&gt; -p '{"metadata":{"finalizers":[]}}' --type=merge <co xml:id="CO66-1"/></programlisting>
<calloutlist>
<callout arearefs="CO66-1">
<para>Replace <literal>&lt;name&gt;</literal> with the name of the CR.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After removing their finalizers, delete the CRs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete lvmvolumegroup &lt;name&gt; <co xml:id="CO67-1"/></programlisting>
<calloutlist>
<callout arearefs="CO67-1">
<para>Replace <literal>&lt;name&gt;</literal> with the name of the CR.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Remove any <literal>LVMVolumeGroupNodeStatus</literal> CRs by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete lvmvolumegroupnodestatus --all</programlisting>
</listitem>
<listitem>
<simpara>Remove the <literal>LVMCluster</literal> CR by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete lvmcluster --all</programlisting>
</listitem>
</orderedlist>
</section>
</section>
</section>
</chapter>
<chapter xml:id="_using-container-storage-interface-csi">
<title>Using Container Storage Interface (CSI)</title>
<section xml:id="persistent-storage-csi">
<title>Configuring CSI volumes</title>

<simpara>The Container Storage Interface (CSI) allows OpenShift Container Platform to consume
storage from storage back ends that implement the
<link xlink:href="https://github.com/container-storage-interface/spec">CSI interface</link>
as persistent storage.</simpara>
<note>
<simpara>OpenShift Container Platform 4.14 supports version 1.6.0 of the <link xlink:href="https://github.com/container-storage-interface/spec">CSI specification</link>.</simpara>
</note>
<section xml:id="persistent-storage-csi-architecture_persistent-storage-csi">
<title>CSI architecture</title>
<simpara>CSI drivers are typically shipped as container images. These containers
are not aware of OpenShift Container Platform where they run. To use CSI-compatible
storage back end in OpenShift Container Platform, the cluster administrator must deploy
several components that serve as a bridge between OpenShift Container Platform and the
storage driver.</simpara>
<simpara>The following diagram provides a high-level overview about the components
running in pods in the OpenShift Container Platform cluster.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/csi-arch-rev1.png"/>
</imageobject>
<textobject><phrase>Architecture of CSI components</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It is possible to run multiple CSI drivers for different storage back ends.
Each driver needs its own external controllers deployment and daemon set
with the driver and CSI registrar.</simpara>
<section xml:id="external-csi-contollers_persistent-storage-csi">
<title>External CSI controllers</title>
<simpara>External CSI controllers is a deployment that deploys one or more pods
with five containers:</simpara>
<itemizedlist>
<listitem>
<simpara>The snapshotter container watches <literal>VolumeSnapshot</literal> and <literal>VolumeSnapshotContent</literal> objects and is responsible for the creation and deletion of <literal>VolumeSnapshotContent</literal> object.</simpara>
</listitem>
<listitem>
<simpara>The resizer container is a sidecar container that watches for <literal>PersistentVolumeClaim</literal> updates and triggers <literal>ControllerExpandVolume</literal> operations against a CSI endpoint if you request more storage on <literal>PersistentVolumeClaim</literal> object.</simpara>
</listitem>
<listitem>
<simpara>An external CSI attacher container translates <literal>attach</literal> and <literal>detach</literal>
calls from OpenShift Container Platform to respective <literal>ControllerPublish</literal> and
<literal>ControllerUnpublish</literal> calls to the CSI driver.</simpara>
</listitem>
<listitem>
<simpara>An external CSI provisioner container that translates <literal>provision</literal> and
<literal>delete</literal> calls from OpenShift Container Platform to respective <literal>CreateVolume</literal> and
<literal>DeleteVolume</literal> calls to the CSI driver.</simpara>
</listitem>
<listitem>
<simpara>A CSI driver container.</simpara>
</listitem>
</itemizedlist>
<simpara>The CSI attacher and CSI provisioner containers communicate with the CSI
driver container using UNIX Domain Sockets, ensuring that no CSI
communication leaves the pod. The CSI driver is not accessible from
outside of the pod.</simpara>
<note>
<simpara>The <literal>attach</literal>, <literal>detach</literal>, <literal>provision</literal>, and <literal>delete</literal> operations typically require
the CSI driver to use credentials to the storage backend. Run the CSI
controller pods on infrastructure nodes so the credentials are never leaked
to user processes, even in the event of a catastrophic security breach
on a compute node.</simpara>
</note>
<note>
<simpara>The external attacher must also run for CSI drivers that do not support
third-party <literal>attach</literal> or <literal>detach</literal> operations. The external attacher will
not issue any <literal>ControllerPublish</literal> or <literal>ControllerUnpublish</literal> operations to
the CSI driver. However, it still must run to implement the necessary
OpenShift Container Platform attachment API.</simpara>
</note>
</section>
<section xml:id="csi-driver-daemonset_persistent-storage-csi">
<title>CSI driver daemon set</title>
<simpara>The CSI driver daemon set runs a pod on every node that allows
OpenShift Container Platform to mount storage provided by the CSI driver to the node
and use it in user workloads (pods) as persistent volumes (PVs). The pod
with the CSI driver installed contains the following containers:</simpara>
<itemizedlist>
<listitem>
<simpara>A CSI driver registrar, which registers the CSI driver into the
<literal>openshift-node</literal> service running on the node. The <literal>openshift-node</literal> process
running on the node then directly connects with the CSI driver using the
UNIX Domain Socket available on the node.</simpara>
</listitem>
<listitem>
<simpara>A CSI driver.</simpara>
</listitem>
</itemizedlist>
<simpara>The CSI driver deployed on the node should have as few credentials to the
storage back end as possible. OpenShift Container Platform will only use the node plugin
set of CSI calls such as <literal>NodePublish</literal>/<literal>NodeUnpublish</literal> and
<literal>NodeStage</literal>/<literal>NodeUnstage</literal>, if these calls are implemented.</simpara>
</section>
</section>
<section xml:id="csi-drivers-supported_persistent-storage-csi">
<title>CSI drivers supported by OpenShift Container Platform</title>
<simpara>OpenShift Container Platform installs certain CSI drivers by default, giving users storage options that are not possible with in-tree volume plugins.</simpara>
<simpara>To create CSI-provisioned persistent volumes that mount to these supported storage assets, OpenShift Container Platform installs the necessary CSI driver Operator, the CSI driver, and the required storage class by default. For more details about the default namespace of the Operator and driver, see the documentation for the specific CSI Driver Operator.</simpara>
<important>
<simpara>The AWS EFS and GCP Filestore CSI drivers are not installed by default, and must be installed manually. For instructions on installing the AWS EFS CSI driver, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_dedicated/4/html/storage/using-container-storage-interface-csi#osd-persistent-storage-aws-efs-csi">Setting up AWS Elastic File Service CSI Driver Operator</link>. For instructions on installing the GCP Filestore CSI driver, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html/storage/using-container-storage-interface-csi#persistent-storage-csi-google-cloud-file-overview">Google Compute Platform Filestore CSI Driver Operator</link>.</simpara>
</important>
<simpara>The following table describes the CSI drivers that are
installed with OpenShift Container Platform
supported by OpenShift Container Platform
and which CSI features they support, such as volume snapshots and resize.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Supported CSI drivers and features in OpenShift Container Platform</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">CSI driver</entry>
<entry align="center" valign="top">CSI volume snapshots</entry>
<entry align="center" valign="top">CSI cloning</entry>
<entry align="center" valign="top">CSI resize</entry>
<entry align="center" valign="top">Inline ephemeral volumes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AliCloud Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AWS EBS</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AWS EFS</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Google Compute Platform (GCP) persistent disk (PD)</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCP Filestore</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Power&#174; Virtual Server Block</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Cloud&#174; Block</simpara></entry>
<entry align="center" valign="top"><simpara>✅<superscript>[3]</superscript></simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅<superscript>[3]</superscript></simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Microsoft Azure Disk</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Microsoft Azure Stack Hub</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Microsoft Azure File</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenStack Cinder</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenShift Data Foundation</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenStack Manila</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Shared Resource</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>VMware vSphere</simpara></entry>
<entry align="center" valign="top"><simpara>✅<superscript>[1]</superscript></simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
<entry align="center" valign="top"><simpara>✅<superscript>[2]</superscript></simpara></entry>
<entry align="center" valign="top"><simpara>-</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>1.</simpara>
<itemizedlist>
<listitem>
<simpara>Requires vSphere version 7.0 Update 3 or later for both vCenter Server and ESXi.</simpara>
</listitem>
<listitem>
<simpara>Does not support fileshare volumes.</simpara>
</listitem>
</itemizedlist>
<simpara>2.</simpara>
<itemizedlist>
<listitem>
<simpara>Offline volume expansion: minimum required vSphere version is 6.7 Update 3 P06</simpara>
</listitem>
<listitem>
<simpara>Online volume expansion: minimum required vSphere version is 7.0 Update 2.</simpara>
</listitem>
</itemizedlist>
<simpara>3.</simpara>
<itemizedlist>
<listitem>
<simpara>Does not support offline snapshots or resize. Volume must be attached to a running pod.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>If your CSI driver is not listed in the preceding table, you must follow the installation instructions provided by your CSI storage vendor to use their supported CSI features.</simpara>
</important>
</section>
<section xml:id="csi-dynamic-provisioning_persistent-storage-csi">
<title>Dynamic provisioning</title>
<simpara>Dynamic provisioning of persistent storage depends on the capabilities of
the CSI driver and underlying storage back end. The provider of the CSI
driver should document how to create a storage class in OpenShift Container Platform and
the parameters available for configuration.</simpara>
<simpara>The created storage class can be configured to enable dynamic provisioning.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a default storage class that ensures all PVCs that do not require
any special storage class are provisioned by the installed CSI driver.</simpara>
<programlisting language="shell" linenumbering="unnumbered"># oc create -f - &lt;&lt; EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class&gt; <co xml:id="CO68-1"/>
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: &lt;provisioner-name&gt; <co xml:id="CO68-2"/>
parameters:
EOF</programlisting>
<calloutlist>
<callout arearefs="CO68-1">
<para>The name of the storage class that will be created.</para>
</callout>
<callout arearefs="CO68-2">
<para>The name of the CSI driver that has been installed.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-example-usage_persistent-storage-csi">
<title>Example using the CSI driver</title>
<simpara>The following example installs a default MySQL template without any
changes to the template.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The CSI driver has been deployed.</simpara>
</listitem>
<listitem>
<simpara>A storage class has been created for dynamic provisioning.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create the MySQL template:</simpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc new-app mysql-persistent</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">--&gt; Deploying template "openshift/mysql-persistent" to project default
...</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered"># oc get pvc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME              STATUS    VOLUME                                   CAPACITY
ACCESS MODES   STORAGECLASS   AGE
mysql             Bound     kubernetes-dynamic-pv-3271ffcb4e1811e8   1Gi
RWO            cinder         3s</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-vol-populator_persistent-storage-csi">
<title>Volume populators</title>
<simpara>Volume populators use the <literal>datasource</literal> field in a persistent volume claim (PVC) spec to create pre-populated volumes.</simpara>
<simpara>Volume population is currently enabled, and supported as a Technology Preview feature. However, OpenShift Container Platform does not ship with any volume populators.</simpara>
<important>
<simpara>Volume populators is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>For more information about volume populators, see <link xlink:href="https://kubernetes.io/blog/2022/05/16/volume-populators-beta/">Kubernetes volume populators</link>.</simpara>
</section>
</section>
<section xml:id="ephemeral-storage-csi-inline">
<title>CSI inline ephemeral volumes</title>

<simpara>Container Storage Interface (CSI) inline ephemeral volumes allow you to define a <literal>Pod</literal> spec that creates inline ephemeral volumes when a pod is deployed and delete them when a pod is destroyed.</simpara>
<simpara>This feature is only available with supported Container Storage Interface (CSI) drivers:</simpara>
<itemizedlist>
<listitem>
<simpara>Shared Resource CSI driver</simpara>
</listitem>
<listitem>
<simpara>Azure File CSI driver</simpara>
</listitem>
<listitem>
<simpara>Secrets Store CSI driver</simpara>
</listitem>
</itemizedlist>
<section xml:id="ephemeral-storage-csi-inline-overview_ephemeral-storage-csi-inline">
<title>Overview of CSI inline ephemeral volumes</title>
<simpara>Traditionally, volumes that are backed by Container Storage Interface (CSI) drivers can only be used with a <literal>PersistentVolume</literal> and <literal>PersistentVolumeClaim</literal> object combination.</simpara>
<simpara>This feature allows you to specify CSI volumes directly in the <literal>Pod</literal> specification, rather than in a <literal>PersistentVolume</literal> object. Inline volumes are ephemeral and do not persist across pod restarts.</simpara>
<section xml:id="_support-limitations">
<title>Support limitations</title>
<simpara>By default, OpenShift Container Platform supports CSI inline ephemeral volumes with these limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.</simpara>
</listitem>
<listitem>
<simpara>The Shared Resource CSI Driver supports using inline ephemeral volumes only to access <literal>Secrets</literal> or <literal>ConfigMaps</literal> across multiple namespaces as a Technology Preview feature.</simpara>
</listitem>
<listitem>
<simpara>Community or storage vendors provide other CSI drivers that support these volumes. Follow the installation instructions provided by the CSI driver provider.</simpara>
</listitem>
</itemizedlist>
<simpara>CSI drivers might not have implemented the inline volume functionality, including <literal>Ephemeral</literal> capacity. For details, see the CSI driver documentation.</simpara>
<important>
<simpara>Shared Resource CSI Driver is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
</section>
</section>
<section xml:id="ephemeral-storage-csi-overview-admin-plugin_ephemeral-storage-csi-inline">
<title>CSI Volume Admission plugin</title>
<simpara>The Container Storage Interface (CSI) Volume Admission plugin allows you to restrict the use of an individual CSI driver capable of provisioning CSI ephemeral volumes on pod admission. Administrators can add a <literal>csi-ephemeral-volume-profile</literal> label, and this label is then inspected by the Admission plugin and used in enforcement, warning, and audit decisions.</simpara>
<section xml:id="overview-admission-plugin">
<title>Overview</title>
<simpara>To use the CSI Volume Admission plugin, administrators add the <literal>security.openshift.io/csi-ephemeral-volume-profile</literal> label to a <literal>CSIDriver</literal> object, which declares the CSI driver’s effective pod security profile when it is used to provide CSI ephemeral volumes, as shown in the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: CSIDriver
metadata:
  name: csi.mydriver.company.org
  labels:
    security.openshift.io/csi-ephemeral-volume-profile: restricted <co xml:id="CO69-1"/></programlisting>
<calloutlist>
<callout arearefs="CO69-1">
<para>CSI driver object YAML file with the <literal>csi-ephemeral-volume-profile</literal> label set to "restricted"</para>
</callout>
</calloutlist>
<simpara>This “effective profile” communicates that a pod can use the CSI driver to mount CSI ephemeral volumes when the pod’s namespace is governed by a pod security standard.</simpara>
<simpara>The CSI Volume Admission plugin inspects pod volumes when pods are created; existing pods that use CSI volumes are not affected. If a pod uses a container storage interface (CSI) volume, the plugin looks up the <literal>CSIDriver</literal> object and inspects the <literal>csi-ephemeral-volume-profile</literal> label, and then use the label’s value in its enforcement, warning, and audit decisions.</simpara>
</section>
<section xml:id="security-profile-enforcement">
<title>Pod security profile enforcement</title>
<simpara>When a CSI driver has the <literal>csi-ephemeral-volume-profile</literal> label, pods using the CSI driver to mount CSI ephemeral volumes must run in a namespace that enforces a pod security standard of equal or greater permission. If the namespace enforces a more restrictive standard, the CSI Volume Admission plugin denies admission. The following table describes the enforcement behavior for different pod security profiles for given label values.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security profile enforcement</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Pod security profile</entry>
<entry align="center" valign="top">Driver label: restricted</entry>
<entry align="center" valign="top">Driver label: baseline</entry>
<entry align="center" valign="top">Driver label: privileged</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Restricted</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
<entry align="center" valign="top"><simpara>Denied</simpara></entry>
<entry align="center" valign="top"><simpara>Denied</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Baseline</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
<entry align="center" valign="top"><simpara>Denied</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Privileged</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
<entry align="center" valign="top"><simpara>Allowed</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="security-profile-warning">
<title>Pod security profile warning</title>
<simpara>The CSI Volume Admission plugin can warn you if the CSI driver’s effective profile is more permissive than the pod security warning profile for the pod namespace. The following table shows when a warning occurs for different pod security profiles for given label values.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security profile warning</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Pod security profile</entry>
<entry align="center" valign="top">Driver label: restricted</entry>
<entry align="center" valign="top">Driver label: baseline</entry>
<entry align="center" valign="top">Driver label: privileged</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Restricted</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
<entry align="center" valign="top"><simpara>Warning</simpara></entry>
<entry align="center" valign="top"><simpara>Warning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Baseline</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
<entry align="center" valign="top"><simpara>Warning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Privileged</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
<entry align="center" valign="top"><simpara>No warning</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="security-profile-audit">
<title>Pod security profile audit</title>
<simpara>The CSI Volume Admission plugin can apply audit annotations to the pod if the CSI driver’s effective profile is more permissive than the pod security audit profile for the pod namespace. The following table shows the audit annotation applied for different pod security profiles for given label values.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Pod security profile audit</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Pod security profile</entry>
<entry align="center" valign="top">Driver label: restricted</entry>
<entry align="center" valign="top">Driver label: baseline</entry>
<entry align="center" valign="top">Driver label: privileged</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Restricted</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
<entry align="center" valign="top"><simpara>Audit</simpara></entry>
<entry align="center" valign="top"><simpara>Audit</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Baseline</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
<entry align="center" valign="top"><simpara>Audit</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Privileged</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
<entry align="center" valign="top"><simpara>No audit</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="admission-plugin-default-behavior">
<title>Default behavior for the CSI Volume Admission plugin</title>
<simpara>If the referenced CSI driver for a CSI ephemeral volume does not have the <literal>csi-ephemeral-volume-profile</literal> label, the CSI Volume Admission plugin considers the driver to have the privileged profile for enforcement, warning, and audit behaviors. Likewise, if the pod’s namespace does not have the pod security admission label set, the Admission plugin assumes the restricted profile is allowed for enforcement, warning, and audit decisions. Therefore, if no labels are set, CSI ephemeral volumes using that CSI driver are only usable in privileged namespaces by default.</simpara>
<simpara>The CSI drivers that ship with OpenShift Container Platform and support ephemeral volumes have a reasonable default set for the <literal>csi-ephemeral-volume-profile</literal> label:</simpara>
<itemizedlist>
<listitem>
<simpara>Shared Resource CSI driver: restricted</simpara>
</listitem>
<listitem>
<simpara>Azure File CSI driver: privileged</simpara>
</listitem>
</itemizedlist>
<simpara>An admin can change the default value of the label if desired.</simpara>
</section>
</section>
<section xml:id="ephemeral-storage-csi-inline-pod_ephemeral-storage-csi-inline">
<title>Embedding a CSI inline ephemeral volume in the pod specification</title>
<simpara>You can embed a CSI inline ephemeral volume in the <literal>Pod</literal> specification in OpenShift Container Platform. At runtime, nested inline volumes follow the ephemeral lifecycle of their associated pods so that the CSI driver handles all phases of volume operations as pods are created and destroyed.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>Pod</literal> object definition and save it to a file.</simpara>
</listitem>
<listitem>
<simpara>Embed the CSI inline ephemeral volume in the file.</simpara>
<formalpara>
<title>my-csi-app.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app
spec:
  containers:
    - name: my-frontend
      image: busybox
      volumeMounts:
      - mountPath: "/data"
        name: my-csi-inline-vol
      command: [ "sleep", "1000000" ]
  volumes: <co xml:id="CO70-1"/>
    - name: my-csi-inline-vol
      csi:
        driver: inline.storage.kubernetes.io
        volumeAttributes:
          foo: bar</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO70-1">
<para>The name of the volume that is used by pods.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object definition file that you saved in the previous step.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f my-csi-app.yaml</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="additional-resources_ephemeral-storage-csi-inline" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ephemeral-storage-shared-resource-csi-driver-operator">
<title>Shared Resource CSI Driver Operator</title>

<simpara role="_abstract">As a cluster administrator, you can use the Shared Resource CSI Driver in OpenShift Container Platform to provision inline ephemeral volumes that contain the contents of <literal>Secret</literal> or <literal>ConfigMap</literal> objects. This way, pods and other Kubernetes types that expose volume mounts, and OpenShift Container Platform Builds can securely use the contents of those objects across potentially any namespace in the cluster. To accomplish this, there are currently two types of shared resources: a <literal>SharedSecret</literal> custom resource for <literal>Secret</literal> objects, and a <literal>SharedConfigMap</literal> custom resource for <literal>ConfigMap</literal> objects.</simpara>
<important>
<simpara>The Shared Resource CSI Driver is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<note>
<simpara>To enable the Shared Resource CSI Driver, you must <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#nodes-cluster-enabling">enable features using feature gates</link>.</simpara>
</note>
<section xml:id="csi-about_ephemeral-storage-shared-resource-csi-driver-operator">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="ephemeral-storage-sharing-secrets-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Sharing secrets across namespaces</title>
<simpara role="_abstract">To share a secret across namespaces in a cluster, you create a <literal>SharedSecret</literal> custom resource (CR) instance for the <literal>Secret</literal> object that you want to share.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>You must have permission to perform the following actions:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Create instances of the <literal>sharedsecrets.sharedresource.openshift.io</literal> custom resource definition (CRD) at a cluster-scoped level.</simpara>
</listitem>
<listitem>
<simpara>Manage roles and role bindings across the namespaces in the cluster to control which users can get, list, and watch those instances.</simpara>
</listitem>
<listitem>
<simpara>Manage roles and role bindings to control whether the service account specified by a pod can mount a Container Storage Interface (CSI) volume that references the <literal>SharedSecret</literal> CR instance you want to use.</simpara>
</listitem>
<listitem>
<simpara>Access the namespaces that contain the Secrets you want to share.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>SharedSecret</literal> CR instance for the <literal>Secret</literal> object you want to share across namespaces in the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: sharedresource.openshift.io/v1alpha1
kind: SharedSecret
metadata:
  name: my-share
spec:
  secretRef:
    name: &lt;name of secret&gt;
    namespace: &lt;namespace of secret&gt;
EOF</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="ephemeral-storage-using-a-sharedsecrets-resource-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Using a SharedSecret instance in a pod</title>
<simpara role="_abstract">To access a <literal>SharedSecret</literal> custom resource (CR) instance from a pod, you grant a given service account RBAC permissions to use that <literal>SharedSecret</literal> CR instance.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created a <literal>SharedSecret</literal> CR instance for the secret you want to share across namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You must have permission to perform the following actions</simpara>
<itemizedlist>
<listitem>
<simpara>Discover which <literal>SharedSecret</literal> CR instances are available by entering the <literal>oc get sharedsecrets</literal> command and getting a non-empty list back.</simpara>
</listitem>
<listitem>
<simpara>Determine if the service account your pod specifies is allowed to use the given <literal>SharedSecret</literal> CR instance. That is, you can run <literal>oc adm policy who-can use &lt;identifier of specific SharedSecret&gt;</literal> to see if the service account in your namespace is listed.</simpara>
</listitem>
<listitem>
<simpara>Determine if the service account your pod specifies is allowed to use <literal>csi</literal> volumes, or if you, as the requesting user who created the pod directly, are allowed to use <literal>csi</literal> volumes.  See "Understanding and managing pod security admission" for details.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>If neither of the last two prerequisites in this list are met, create, or ask someone to create, the necessary role-based access control (RBAC) so that you can discover <literal>SharedSecret</literal> CR instances and enable service accounts to use <literal>SharedSecret</literal> CR instances.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Grant a given service account RBAC permissions to use the <literal>SharedSecret</literal> CR instance in its pod by using <literal>oc apply</literal> with YAML content:</simpara>
<note>
<simpara>Currently, <literal>kubectl</literal> and <literal>oc</literal> have hard-coded special case logic restricting the <literal>use</literal> verb to roles centered around pod security. Therefore, you cannot use <literal>oc create role &#8230;&#8203;</literal> to create the role needed for consuming <literal>SharedSecret</literal> CR instances.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: shared-resource-my-share
  namespace: my-namespace
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedsecrets
    resourceNames:
      - my-share
    verbs:
      - use
EOF</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>RoleBinding</literal> associated with the role by using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create rolebinding shared-resource-my-share --role=shared-resource-my-share --serviceaccount=my-namespace:builder</programlisting>
</listitem>
<listitem>
<simpara>Access the <literal>SharedSecret</literal> CR instance from a pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
kind: Pod
apiVersion: v1
metadata:
  name: my-app
  namespace: my-namespace
spec:
  serviceAccountName: default

# containers omitted …. Follow standard use of ‘volumeMounts’ for referencing your shared resource volume

    volumes:
    - name: my-csi-volume
      csi:
        readOnly: true
        driver: csi.sharedresource.openshift.io
        volumeAttributes:
          sharedSecret: my-share

EOF</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ephemeral-storage-sharing-configmaps-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Sharing a config map across namespaces</title>
<simpara role="_abstract">To share a config map across namespaces in a cluster, you create a <literal>SharedConfigMap</literal> custom resource (CR) instance for that config map.</simpara>
<formalpara>
<title>Prerequisites</title>
<para>You must have permission to perform the following actions:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Create instances of the <literal>sharedconfigmaps.sharedresource.openshift.io</literal> custom resource definition (CRD) at a cluster-scoped level.</simpara>
</listitem>
<listitem>
<simpara>Manage roles and role bindings across the namespaces in the cluster to control which users can get, list, and watch those instances.</simpara>
</listitem>
<listitem>
<simpara>Manage roles and role bindings across the namespaces in the cluster to control which service accounts in pods that mount your Container Storage Interface (CSI) volume can use those instances.</simpara>
</listitem>
<listitem>
<simpara>Access the namespaces that contain the Secrets you want to share.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>SharedConfigMap</literal> CR instance for the config map that you want to share across namespaces in the cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: sharedresource.openshift.io/v1alpha1
kind: SharedConfigMap
metadata:
  name: my-share
spec:
  configMapRef:
    name: &lt;name of configmap&gt;
    namespace: &lt;namespace of configmap&gt;
EOF</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ephemeral-storage-using-a-sharedconfigmap-object-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Using a SharedConfigMap instance in a pod</title>
<formalpara role="_abstract">
<title>Next steps</title>
<para>To access a <literal>SharedConfigMap</literal> custom resource (CR) instance from a pod, you grant a given service account RBAC permissions to use that <literal>SharedConfigMap</literal> CR instance.</para>
</formalpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created a <literal>SharedConfigMap</literal> CR instance for the config map that you want to share across namespaces in the cluster.</simpara>
</listitem>
<listitem>
<simpara>You must have permission to perform the following actions:</simpara>
<itemizedlist>
<listitem>
<simpara>Discover which <literal>SharedConfigMap</literal> CR instances are available by entering the <literal>oc get sharedconfigmaps</literal> command and getting a non-empty list back.</simpara>
</listitem>
<listitem>
<simpara>Determine if the service account your pod specifies is allowed to use the given <literal>SharedSecret</literal> CR instance. That is, you can run <literal>oc adm policy who-can use &lt;identifier of specific SharedSecret&gt;</literal> to see if the service account in your namespace is listed.</simpara>
</listitem>
<listitem>
<simpara>Determine if the service account your pod specifies is allowed to use <literal>csi</literal> volumes, or if you, as the requesting user who created the pod directly, are allowed to use <literal>csi</literal> volumes.  See "Understanding and managing pod security admission" for details.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<note>
<simpara>If neither of the last two prerequisites in this list are met, create, or ask someone to create, the necessary role-based access control (RBAC) so that you can discover <literal>SharedConfigMap</literal> CR instances and enable service accounts to use <literal>SharedConfigMap</literal> CR instances.</simpara>
</note>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Grant a given service account RBAC permissions to use the <literal>SharedConfigMap</literal> CR instance in its pod by using <literal>oc apply</literal> with YAML content.</simpara>
<note>
<simpara>Currently, <literal>kubectl</literal> and <literal>oc</literal> have hard-coded special case logic restricting the <literal>use</literal> verb to roles centered around pod security. Therefore, you cannot use <literal>oc create role &#8230;&#8203;</literal> to create the role needed for consuming a <literal>SharedConfigMap</literal> CR instance.</simpara>
</note>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: shared-resource-my-share
  namespace: my-namespace
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedconfigmaps
    resourceNames:
      - my-share
    verbs:
      - use
EOF</programlisting>
</listitem>
<listitem>
<simpara>Create the <literal>RoleBinding</literal> associated with the role by using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc create rolebinding shared-resource-my-share --role=shared-resource-my-share --serviceaccount=my-namespace:builder</programlisting>
</listitem>
<listitem>
<simpara>Access the <literal>SharedConfigMap</literal> CR instance from a pod:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f - &lt;&lt;EOF
kind: Pod
apiVersion: v1
metadata:
  name: my-app
  namespace: my-namespace
spec:
  serviceAccountName: default

# containers omitted …. Follow standard use of ‘volumeMounts’ for referencing your shared resource volume

    volumes:
    - name: my-csi-volume
      csi:
        readOnly: true
        driver: csi.sharedresource.openshift.io
        volumeAttributes:
          sharedConfigMap: my-share

EOF</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="ephemeral-storage-additional-support-limitations-for-shared-resource-csi-driver_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Additional support limitations for the Shared Resource CSI Driver</title>
<simpara role="_abstract">The Shared Resource CSI Driver has the following noteworthy limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The driver is subject to the limitations of Container Storage Interface (CSI) inline ephemeral volumes.</simpara>
</listitem>
<listitem>
<simpara>The value of the <literal>readOnly</literal> field must be <literal>true</literal>. On <literal>Pod</literal> creation, a validating admission webhook rejects the pod creation if <literal>readOnly</literal> is <literal>false</literal>. If for some reason the validating admission webhook cannot be contacted, on volume provisioning during pod startup, the driver returns an error to the kubelet. Requiring <literal>readOnly</literal> is <literal>true</literal> is in keeping with proposed best practices for the upstream Kubernetes CSI Driver to apply SELinux labels to associated volumes.</simpara>
</listitem>
<listitem>
<simpara>The driver ignores the <literal>FSType</literal> field because it only supports <literal>tmpfs</literal> volumes.</simpara>
</listitem>
<listitem>
<simpara>The driver ignores the <literal>NodePublishSecretRef</literal> field. Instead, it uses <literal>SubjectAccessReviews</literal> with the <literal>use</literal> verb to evaluate whether a pod can obtain a volume that contains <literal>SharedSecret</literal> or <literal>SharedConfigMap</literal> custom resource (CR) instances.</simpara>
</listitem>
<listitem>
<simpara>You cannot create <literal>SharedSecret</literal> or <literal>SharedConfigMap</literal> custom resource (CR) instances whose names start with <literal>openshift</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="ephemeral-storage-additional-details-about-volumeattributes-on-shared-resource-pod-volumes_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Additional details about VolumeAttributes on shared resource pod volumes</title>
<simpara role="_abstract">The following attributes affect shared resource pod volumes in various ways:</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>refreshResource</literal> attribute in the <literal>volumeAttributes</literal> properties.</simpara>
</listitem>
<listitem>
<simpara>The <literal>refreshResources</literal> attribute in the Shared Resource CSI Driver configuration.</simpara>
</listitem>
<listitem>
<simpara>The <literal>sharedSecret</literal> and <literal>sharedConfigMap</literal> attributes in the <literal>volumeAttributes</literal> properties.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_the-refreshresource-attribute">
<title>The <literal>refreshResource</literal> attribute</title>
<simpara>The Shared Resource CSI Driver honors the <literal>refreshResource</literal> attribute in <literal>volumeAttributes</literal> properties of the volume. This attribute controls whether updates to the contents of the underlying <literal>Secret</literal> or <literal>ConfigMap</literal> object are copied to the volume <emphasis role="strong">after</emphasis> the volume is initially provisioned as part of pod startup. The default value of <literal>refreshResource</literal> is <literal>true</literal>, which means that the contents are updated.</simpara>
<important>
<simpara>If the Shared Resource CSI Driver configuration has disabled the refreshing of both the shared <literal>SharedSecret</literal> and <literal>SharedConfigMap</literal> custom resource (CR) instances, then the <literal>refreshResource</literal> attribute in the <literal>volumeAttribute</literal> properties has no effect. The intent of this attribute is to disable refresh for specific volume mounts when refresh is generally allowed.</simpara>
</important>
</section>
<section xml:id="_the-refreshresources-attribute">
<title>The <literal>refreshResources</literal> attribute</title>
<simpara>You can use a global switch to enable or disable refreshing of shared resources. This switch is the <literal>refreshResources</literal> attribute in the <literal>csi-driver-shared-resource-config</literal> config map for the Shared Resource CSI Driver, which you can find in the <literal>openshift-cluster-csi-drivers</literal> namespace. If you set this <literal>refreshResources</literal> attribute to <literal>false</literal>, none of the <literal>Secret</literal> or <literal>ConfigMap</literal> object-related content stored in the volume is updated after the initial provisioning of the volume.</simpara>
<important>
<simpara>Using this Shared Resource CSI Driver configuration to disable refreshing affects all the cluster&#8217;s volume mounts that use the Shared Resource CSI Driver, regardless of the <literal>refreshResource</literal> attribute in the <literal>volumeAttributes</literal> properties of any of those volumes.</simpara>
</important>
</section>
<section xml:id="_validation-of-volumeattributes-before-provisioning-a-shared-resource-volume-for-a-pod">
<title>Validation of volumeAttributes before provisioning a shared resource volume for a pod</title>
<simpara>In the <literal>volumeAttributes</literal> of a single volume, you must set either a <literal>sharedSecret</literal> or a <literal>sharedConfigMap</literal> attribute to the value of a <literal>SharedSecret</literal> or a <literal>SharedConfigMap</literal> CS instance. Otherwise, when the volume is provisioned during pod startup, a validation checks the <literal>volumeAttributes</literal> of that volume and returns an error to the kubelet under the following conditions:</simpara>
<itemizedlist>
<listitem>
<simpara>Both <literal>sharedSecret</literal> and <literal>sharedConfigMap</literal> attributes have specified values.</simpara>
</listitem>
<listitem>
<simpara>Neither <literal>sharedSecret</literal> nor <literal>sharedConfigMap</literal> attributes have specified values.</simpara>
</listitem>
<listitem>
<simpara>The value of the <literal>sharedSecret</literal> or <literal>sharedConfigMap</literal> attribute does not correspond to the name of a <literal>SharedSecret</literal> or <literal>SharedConfigMap</literal> CR instance on the cluster.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="ephemeral-storage-integration-between-shared-resources-insights-operator-and-openshift-builds_ephemeral-storage-shared-resource-csi-driver-operator">
<title>Integration between shared resources, Insights Operator, and OpenShift Container Platform Builds</title>
<simpara role="_abstract">Integration between shared resources, Insights Operator, and OpenShift Container Platform Builds makes using Red Hat subscriptions (RHEL entitlements) easier in OpenShift Container Platform Builds.</simpara>
<simpara>Previously, in OpenShift Container Platform 4.9.x and earlier, you manually imported your credentials and copied them to each project or namespace where you were running builds.</simpara>
<simpara>Now, in OpenShift Container Platform 4.10 and later, OpenShift Container Platform Builds can use Red Hat subscriptions (RHEL entitlements) by referencing shared resources and the simple content access feature provided by Insights Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>The simple content access feature imports your subscription credentials to a well-known <literal>Secret</literal> object. See the links in the following "Additional resources" section.</simpara>
</listitem>
<listitem>
<simpara>The cluster administrator creates a <literal>SharedSecret</literal> custom resource (CR) instance around that <literal>Secret</literal> object and grants permission to particular projects or namespaces. In particular, the cluster administrator gives the <literal>builder</literal> service account permission to use that <literal>SharedSecret</literal> CR instance.</simpara>
</listitem>
<listitem>
<simpara>Builds that run within those projects or namespaces can mount a CSI Volume that references the <literal>SharedSecret</literal> CR instance and its entitled RHEL content.</simpara>
</listitem>
</itemizedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/support/#insights-operator-simple-access">Importing simple content access certificates with Insights Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/cicd/#builds-source-secrets-entitlements_running-entitled-builds">Adding subscription entitlements as a build secret</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-snapshots">
<title>CSI volume snapshots</title>

<simpara>This document describes how to use volume snapshots with supported Container Storage Interface (CSI) drivers to help protect against data loss in OpenShift Container Platform. Familiarity with <link linkend="persistent-volumes_understanding-persistent-storage">persistent volumes</link> is suggested.</simpara>
<section xml:id="persistent-storage-csi-snapshots-overview_persistent-storage-csi-snapshots">
<title>Overview of CSI volume snapshots</title>
<simpara>A <emphasis>snapshot</emphasis> represents the state of the storage volume in a cluster at a particular point in time. Volume snapshots can be used to provision a new volume.</simpara>
<simpara>OpenShift Container Platform supports Container Storage Interface (CSI) volume snapshots by default. However, a specific CSI driver is required.</simpara>
<simpara>With CSI volume snapshots, a cluster administrator can:</simpara>
<itemizedlist>
<listitem>
<simpara>Deploy a third-party CSI driver that supports snapshots.</simpara>
</listitem>
<listitem>
<simpara>Create a new persistent volume claim (PVC) from an existing volume snapshot.</simpara>
</listitem>
<listitem>
<simpara>Take a snapshot of an existing PVC.</simpara>
</listitem>
<listitem>
<simpara>Restore a snapshot as a different PVC.</simpara>
</listitem>
<listitem>
<simpara>Delete an existing volume snapshot.</simpara>
</listitem>
</itemizedlist>
<simpara>With CSI volume snapshots, an app developer can:</simpara>
<itemizedlist>
<listitem>
<simpara>Use volume snapshots as building blocks for developing application- or cluster-level storage backup solutions.</simpara>
</listitem>
<listitem>
<simpara>Rapidly rollback to a previous development version.</simpara>
</listitem>
<listitem>
<simpara>Use storage more efficiently by not having to make a full copy each time.</simpara>
</listitem>
</itemizedlist>
<simpara>Be aware of the following when using volume snapshots:</simpara>
<itemizedlist>
<listitem>
<simpara>Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.</simpara>
</listitem>
<listitem>
<simpara>OpenShift Container Platform only ships with select CSI drivers. For CSI drivers that are not provided by an OpenShift Container Platform Driver Operator, it is recommended to use the CSI drivers provided by
<link xlink:href="https://kubernetes-csi.github.io/docs/drivers.html">community or storage vendors</link>. Follow the installation instructions furnished by the CSI driver provider.</simpara>
</listitem>
<listitem>
<simpara>CSI drivers may or may not have implemented the volume snapshot functionality. CSI drivers that have provided support for volume snapshots will likely use the <literal>csi-external-snapshotter</literal> sidecar. See documentation provided by the CSI driver for details.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-snapshots-controller-sidecar_persistent-storage-csi-snapshots">
<title>CSI snapshot controller and sidecar</title>
<simpara>OpenShift Container Platform provides a snapshot controller that is deployed into the control plane. In addition, your CSI driver vendor provides the CSI snapshot sidecar as a helper container that is installed during the CSI driver installation.</simpara>
<simpara>The CSI snapshot controller and sidecar provide volume snapshotting through the OpenShift Container Platform API. These external components run in the cluster.</simpara>
<simpara>The external controller is deployed by the CSI Snapshot Controller Operator.</simpara>
<section xml:id="_external-controller">
<title>External controller</title>
<simpara>The CSI snapshot controller binds <literal>VolumeSnapshot</literal> and <literal>VolumeSnapshotContent</literal> objects. The controller manages dynamic provisioning by creating and deleting <literal>VolumeSnapshotContent</literal> objects.</simpara>
</section>
<section xml:id="_external-sidecar">
<title>External sidecar</title>
<simpara>Your CSI driver vendor provides the <literal>csi-external-snapshotter</literal> sidecar. This is a separate helper container that is deployed with the CSI driver. The sidecar manages snapshots by triggering <literal>CreateSnapshot</literal> and <literal>DeleteSnapshot</literal> operations. Follow the installation instructions provided by your vendor.</simpara>
</section>
</section>
<section xml:id="persistent-storage-csi-snapshots-operator_persistent-storage-csi-snapshots">
<title>About the CSI Snapshot Controller Operator</title>
<simpara>The CSI Snapshot Controller Operator runs in the <literal>openshift-cluster-storage-operator</literal> namespace. It is installed by the Cluster Version Operator (CVO) in all clusters by default.</simpara>
<simpara>The CSI Snapshot Controller Operator installs the CSI snapshot controller, which runs in the <literal>openshift-cluster-storage-operator</literal> namespace.</simpara>
<section xml:id="_volume-snapshot-crds">
<title>Volume snapshot CRDs</title>
<simpara>During OpenShift Container Platform installation, the CSI Snapshot Controller Operator creates the following snapshot custom resource definitions (CRDs) in the <literal>snapshot.storage.k8s.io/v1</literal> API group:</simpara>
<variablelist>
<varlistentry>
<term><literal>VolumeSnapshotContent</literal></term>
<listitem>
<simpara>A snapshot taken of a volume in the cluster that has been provisioned by a cluster administrator.</simpara>
<simpara>Similar to the <literal>PersistentVolume</literal> object, the <literal>VolumeSnapshotContent</literal> CRD is a cluster resource that points to a real snapshot in the storage back end.</simpara>
<simpara>For manually pre-provisioned snapshots, a cluster administrator creates a number of <literal>VolumeSnapshotContent</literal> CRDs. These carry the details of the real volume snapshot in the storage system.</simpara>
<simpara>The <literal>VolumeSnapshotContent</literal> CRD is not namespaced and is for use by a cluster administrator.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>VolumeSnapshot</literal></term>
<listitem>
<simpara>Similar to the <literal>PersistentVolumeClaim</literal> object, the <literal>VolumeSnapshot</literal> CRD defines a developer request for a snapshot. The CSI Snapshot Controller Operator runs the CSI snapshot controller, which handles the binding of a <literal>VolumeSnapshot</literal> CRD with an appropriate <literal>VolumeSnapshotContent</literal> CRD. The binding is a one-to-one mapping.</simpara>
<simpara>The <literal>VolumeSnapshot</literal> CRD is namespaced. A developer uses the CRD as a distinct request for a snapshot.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>VolumeSnapshotClass</literal></term>
<listitem>
<simpara>Allows a cluster administrator to specify different attributes belonging to a <literal>VolumeSnapshot</literal> object. These attributes may differ among snapshots taken of the same volume on the storage system, in which case they would not be expressed by using the same storage class of a persistent volume claim.</simpara>
<simpara>The <literal>VolumeSnapshotClass</literal> CRD defines the parameters for the <literal>csi-external-snapshotter</literal> sidecar to use when creating a snapshot. This allows the storage back end to know what kind of snapshot to dynamically create if multiple options are supported.</simpara>
<simpara>Dynamically provisioned snapshots use the <literal>VolumeSnapshotClass</literal> CRD to specify storage-provider-specific parameters to use when creating a snapshot.</simpara>
<simpara>The <literal>VolumeSnapshotContentClass</literal> CRD is not namespaced and is for use by a cluster administrator to enable global configuration options for their storage back end.</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section xml:id="persistent-storage-csi-snapshots-provision_persistent-storage-csi-snapshots">
<title>Volume snapshot provisioning</title>
<simpara>There are two ways to provision snapshots: dynamically and manually.</simpara>
<section xml:id="snapshots-dynamic-provisioning_persistent-storage-csi-snapshots">
<title>Dynamic provisioning</title>
<simpara>Instead of using a preexisting snapshot, you can request that a snapshot be taken dynamically from a persistent volume claim. Parameters are specified using a <literal>VolumeSnapshotClass</literal> CRD.</simpara>
</section>
<section xml:id="snapshots-manual-provisioning_persistent-storage-csi-snapshots">
<title>Manual provisioning</title>
<simpara>As a cluster administrator, you can manually pre-provision a number of <literal>VolumeSnapshotContent</literal> objects. These carry the real volume snapshot details available to cluster users.</simpara>
</section>
</section>
<section xml:id="persistent-storage-csi-snapshots-create_persistent-storage-csi-snapshots">
<title>Creating a volume snapshot</title>
<simpara>When you create a <literal>VolumeSnapshot</literal> object, OpenShift Container Platform creates a volume snapshot.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Logged in to a running OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>A PVC created using a CSI driver that supports <literal>VolumeSnapshot</literal> objects.</simpara>
</listitem>
<listitem>
<simpara>A storage class to provision the storage back end.</simpara>
</listitem>
<listitem>
<simpara>No pods are using the persistent volume claim (PVC) that you want to take a snapshot of.</simpara>
<note>
<simpara>Do not create a volume snapshot of a PVC if a pod is using it. Doing so might cause data corruption because the PVC is not quiesced (paused). Be sure to first tear down a running pod to ensure consistent snapshots.</simpara>
</note>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To dynamically create a volume snapshot:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a file with the <literal>VolumeSnapshotClass</literal> object described by the following YAML:</simpara>
<formalpara>
<title>volumesnapshotclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snap
driver: hostpath.csi.k8s.io <co xml:id="CO71-1"/>
deletionPolicy: Delete</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO71-1">
<para>The name of the CSI driver that is used to create snapshots of this <literal>VolumeSnapshotClass</literal> object. The name must be the same as the <literal>Provisioner</literal> field of the storage class that is responsible for the PVC that is being snapshotted.</para>
</callout>
</calloutlist>
<note>
<simpara>Depending on the driver that you used to configure persistent storage, additional parameters might be required. You can also use an existing <literal>VolumeSnapshotClass</literal> object.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create the object you saved in the previous step by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f volumesnapshotclass.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>VolumeSnapshot</literal> object:</simpara>
<formalpara>
<title>volumesnapshot-dynamic.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: mysnap
spec:
  volumeSnapshotClassName: csi-hostpath-snap <co xml:id="CO72-1"/>
  source:
    persistentVolumeClaimName: myclaim <co xml:id="CO72-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO72-1">
<para>The request for a particular class by the volume snapshot. If the <literal>volumeSnapshotClassName</literal> setting is absent and there is a default volume snapshot class, a snapshot is created with the default volume snapshot class name. But if the field is absent and no default volume snapshot class exists, then no snapshot is created.</para>
</callout>
<callout arearefs="CO72-2">
<para>The name of the <literal>PersistentVolumeClaim</literal> object bound to a persistent volume. This defines what you want to create a snapshot of. Required for dynamically provisioning a snapshot.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object you saved in the previous step by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f volumesnapshot-dynamic.yaml</programlisting>
</listitem>
</orderedlist>
<simpara>To manually provision a snapshot:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Provide a value for the <literal>volumeSnapshotContentName</literal> parameter as the source for the snapshot, in addition to defining volume snapshot class as shown above.</simpara>
<formalpara>
<title>volumesnapshot-manual.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: snapshot-demo
spec:
  source:
    volumeSnapshotContentName: mycontent <co xml:id="CO73-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO73-1">
<para>The <literal>volumeSnapshotContentName</literal> parameter is required for pre-provisioned snapshots.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object you saved in the previous step by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f volumesnapshot-manual.yaml</programlisting>
</listitem>
</orderedlist>
<formalpara>
<title>Verification</title>
<para>After the snapshot has been created in the cluster, additional details about the snapshot are available.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To display details about the volume snapshot that was created, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe volumesnapshot mysnap</programlisting>
<simpara>The following example displays details about the <literal>mysnap</literal> volume snapshot:</simpara>
<formalpara>
<title>volumesnapshot.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: mysnap
spec:
  source:
    persistentVolumeClaimName: myclaim
  volumeSnapshotClassName: csi-hostpath-snap
status:
  boundVolumeSnapshotContentName: snapcontent-1af4989e-a365-4286-96f8-d5dcd65d78d6 <co xml:id="CO74-1"/>
  creationTime: "2020-01-29T12:24:30Z" <co xml:id="CO74-2"/>
  readyToUse: true <co xml:id="CO74-3"/>
  restoreSize: 500Mi</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO74-1">
<para>The pointer to the actual storage content that was created by the controller.</para>
</callout>
<callout arearefs="CO74-2">
<para>The time when the snapshot was created. The snapshot contains the volume content that was available at this indicated time.</para>
</callout>
<callout arearefs="CO74-3">
<para>If the value is set to <literal>true</literal>, the snapshot can be used to restore as a new PVC.
 <?asciidoc-br?>
If the value is set to <literal>false</literal>, the snapshot was created. However, the storage back end needs to perform additional tasks to make the snapshot usable so that it can be restored as a new volume. For example, Amazon Elastic Block Store data might be moved to a different, less expensive location, which can take several minutes.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>To verify that the volume snapshot was created, enter the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get volumesnapshotcontent</programlisting>
<simpara>The pointer to the actual content is displayed. If the <literal>boundVolumeSnapshotContentName</literal> field is populated, a <literal>VolumeSnapshotContent</literal> object exists and the snapshot was created.</simpara>
</listitem>
<listitem>
<simpara>To verify that the snapshot is ready, confirm that the <literal>VolumeSnapshot</literal> object has <literal>readyToUse: true</literal>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-csi-snapshots-delete_persistent-storage-csi-snapshots">
<title>Deleting a volume snapshot</title>
<simpara>You can configure how OpenShift Container Platform deletes volume snapshots.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Specify the deletion policy that you require in the <literal>VolumeSnapshotClass</literal> object, as shown in the following example:</simpara>
<formalpara>
<title>volumesnapshotclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snap
driver: hostpath.csi.k8s.io
deletionPolicy: Delete <co xml:id="CO75-1"/></programlisting>
</para>
</formalpara>
<calloutlist role="small">
<callout arearefs="CO75-1">
<para>When deleting the volume snapshot, if the <literal>Delete</literal> value is set, the underlying snapshot is deleted along with the <literal>VolumeSnapshotContent</literal> object. If the <literal>Retain</literal> value is set, both the underlying snapshot and <literal>VolumeSnapshotContent</literal> object remain.
 <?asciidoc-br?>
If the <literal>Retain</literal> value is set and the <literal>VolumeSnapshot</literal> object is deleted without deleting the corresponding <literal>VolumeSnapshotContent</literal> object, the content remains. The snapshot itself is also retained in the storage back end.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Delete the volume snapshot by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete volumesnapshot &lt;volumesnapshot_name&gt;</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">volumesnapshot.snapshot.storage.k8s.io "mysnapshot" deleted</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>If the deletion policy is set to <literal>Retain</literal>, delete the volume snapshot content by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc delete volumesnapshotcontent &lt;volumesnapshotcontent_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>Optional: If the <literal>VolumeSnapshot</literal> object is not successfully deleted, enter the following command to remove any finalizers for the leftover resource so that the delete operation can continue:</simpara>
<important>
<simpara>Only remove the finalizers if you are confident that there are no existing references from either persistent volume claims or volume snapshot contents to the <literal>VolumeSnapshot</literal> object.
Even with the <literal>--force</literal> option, the delete operation does not delete snapshot objects until all finalizers are removed.</simpara>
</important>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch -n $PROJECT volumesnapshot/$NAME --type=merge -p '{"metadata": {"finalizers":null}}'</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">volumesnapshotclass.snapshot.storage.k8s.io "csi-ocs-rbd-snapclass" deleted</programlisting>
</para>
</formalpara>
<simpara>The finalizers are removed and the volume snapshot is deleted.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-csi-snapshots-restore_persistent-storage-csi-snapshots">
<title>Restoring a volume snapshot</title>
<simpara>The <literal>VolumeSnapshot</literal> CRD content can be used to restore the existing volume to a previous state.</simpara>
<simpara>After your <literal>VolumeSnapshot</literal> CRD is bound and the <literal>readyToUse</literal> value is set to <literal>true</literal>, you can use that resource to provision a new volume that is pre-populated with data from the snapshot.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Logged in to a running OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>A persistent volume claim (PVC) created using a Container Storage Interface (CSI) driver that supports volume snapshots.</simpara>
</listitem>
<listitem>
<simpara>A storage class to provision the storage back end.</simpara>
</listitem>
<listitem>
<simpara>A volume snapshot has been created and is ready to use.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Specify a <literal>VolumeSnapshot</literal> data source on a PVC as shown in the following:</simpara>
<formalpara>
<title>pvc-restore.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim-restore
spec:
  storageClassName: csi-hostpath-sc
  dataSource:
    name: mysnap <co xml:id="CO76-1"/>
    kind: VolumeSnapshot <co xml:id="CO76-2"/>
    apiGroup: snapshot.storage.k8s.io <co xml:id="CO76-3"/>
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO76-1">
<para>Name of the <literal>VolumeSnapshot</literal> object representing the snapshot to use as source.</para>
</callout>
<callout arearefs="CO76-2">
<para>Must be set to the <literal>VolumeSnapshot</literal> value.</para>
</callout>
<callout arearefs="CO76-3">
<para>Must be set to the <literal>snapshot.storage.k8s.io</literal> value.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a PVC by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc-restore.yaml</programlisting>
</listitem>
<listitem>
<simpara>Verify that the restored PVC has been created by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc</programlisting>
<simpara>A new PVC such as <literal>myclaim-restore</literal> is displayed.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-cloning">
<title>CSI volume cloning</title>

<simpara>Volume cloning duplicates an existing persistent volume to help protect against data loss in OpenShift Container Platform. This feature is only available with supported Container Storage Interface (CSI) drivers. You should be familiar with <link linkend="persistent-volumes_understanding-persistent-storage">persistent volumes</link> before you provision a CSI volume clone.</simpara>
<section xml:id="persistent-storage-csi-cloning-overview_persistent-storage-csi-cloning">
<title>Overview of CSI volume cloning</title>
<simpara>A Container Storage Interface (CSI) volume clone is a duplicate of an existing persistent volume at a particular point in time.</simpara>
<simpara>Volume cloning is similar to volume snapshots, although it is more efficient. For example, a cluster administrator can duplicate a cluster volume by creating another instance of the existing cluster volume.</simpara>
<simpara>Cloning creates an exact duplicate of the specified volume on the back-end device, rather than creating a new empty volume. After dynamic provisioning, you can use a volume clone just as you would use any standard volume.</simpara>
<simpara>No new API objects are required for cloning. The existing <literal>dataSource</literal> field in the <literal>PersistentVolumeClaim</literal> object is expanded so that it can accept the name of an existing PersistentVolumeClaim in the same namespace.</simpara>
<section xml:id="_support-limitations-2">
<title>Support limitations</title>
<simpara>By default, OpenShift Container Platform supports CSI volume cloning with these limitations:</simpara>
<itemizedlist>
<listitem>
<simpara>The destination persistent volume claim (PVC) must exist in the same namespace as the source PVC.</simpara>
</listitem>
<listitem>
<simpara>Cloning is supported with a different Storage Class.</simpara>
<itemizedlist>
<listitem>
<simpara>Destination volume can be the same for a different storage class as the source.</simpara>
</listitem>
<listitem>
<simpara>You can use the default storage class and omit <literal>storageClassName</literal> in the <literal>spec</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.</simpara>
</listitem>
<listitem>
<simpara>CSI drivers might not have implemented the volume cloning functionality. For details, see the CSI driver documentation.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-cloning-provisioning_persistent-storage-csi-cloning">
<title>Provisioning a CSI volume clone</title>
<simpara>When you create a cloned persistent volume claim (PVC) API object, you trigger the provisioning of a CSI volume clone. The clone pre-populates with the contents of another PVC, adhering to the same rules as any other persistent volume. The one exception is that you must add a <literal>dataSource</literal> that references an existing PVC in the same namespace.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to a running OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>Your PVC is created using a CSI driver that supports volume cloning.</simpara>
</listitem>
<listitem>
<simpara>Your storage back end is configured for dynamic provisioning. Cloning support is not available for static provisioners.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To clone a PVC from an existing PVC:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create and save a file with the <literal>PersistentVolumeClaim</literal> object described by the following YAML:</simpara>
<formalpara>
<title>pvc-clone.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-1-clone
  namespace: mynamespace
spec:
  storageClassName: csi-cloning <co xml:id="CO77-1"/>
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  dataSource:
    kind: PersistentVolumeClaim
    name: pvc-1</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO77-1">
<para>The name of the storage class that provisions the storage back end. The default storage class can be used and <literal>storageClassName</literal> can be omitted in the spec.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object you saved in the previous step by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc-clone.yaml</programlisting>
<simpara>A new PVC <literal>pvc-1-clone</literal> is created.</simpara>
</listitem>
<listitem>
<simpara>Verify that the volume clone was created and is ready by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc pvc-1-clone</programlisting>
<simpara>The <literal>pvc-1-clone</literal> shows that it is <literal>Bound</literal>.</simpara>
<simpara>You are now ready to use the newly cloned PVC to configure a pod.</simpara>
</listitem>
<listitem>
<simpara>Create and save a file with the <literal>Pod</literal> object described by the YAML. For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: dockerfile/nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: pvc-1-clone <co xml:id="CO78-1"/></programlisting>
<calloutlist>
<callout arearefs="CO78-1">
<para>The cloned PVC created during the CSI volume cloning operation.</para>
</callout>
</calloutlist>
<simpara>The created <literal>Pod</literal> object is now ready to consume, clone, snapshot, or delete your cloned PVC independently of its original <literal>dataSource</literal> PVC.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-sc-manage">
<title>Managing the default storage class</title>

<section xml:id="_overview">
<title>Overview</title>
<simpara>Managing the default storage class allows you to accomplish several different objectives:</simpara>
<itemizedlist>
<listitem>
<simpara>Enforcing static provisioning by disabling dynamic provisioning.</simpara>
</listitem>
<listitem>
<simpara>When you have other preferred storage classes, preventing the storage operator from re-creating the initial default storage class.</simpara>
</listitem>
<listitem>
<simpara>Renaming, or otherwise changing, the default storage class</simpara>
</listitem>
</itemizedlist>
<simpara>To accomplish these objectives, you change the setting for the <literal>spec.storageClassState</literal> field in the <literal>ClusterCSIDriver</literal> object. The possible settings for this field are:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Managed</emphasis>: (Default) The Container Storage Interface (CSI) operator is actively managing its default storage class, so that most manual changes made by a cluster administrator to the default storage class are removed, and the default storage class is continuously re-created if you attempt to manually delete it.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Unmanaged</emphasis>: You can modify the default storage class. The CSI operator is not actively managing storage classes, so that it is not reconciling the default storage class it creates automatically.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Removed</emphasis>: The CSI operators deletes the default storage class.</simpara>
</listitem>
</itemizedlist>
<simpara>Managing the default storage classes is supported by the following Container Storage Interface (CSI) driver operators:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi-alicloud-disk">AliCloud Disk</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-ebs">Amazon Web Services (AWS) Elastic Block Storage (EBS)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-azure-disk">Azure Disk</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-azure-file">Azure File</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-gcp-pd">Google Cloud Platform (GCP) Persistent Disk (PD)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-ibm-vpc-block">IBM&#174; VPC Block</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-cinder">OpenStack Cinder</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-vsphere">VMware vSphere</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-sc-managing_persistent-storage-csi-sc-manage">
<title>Managing the default storage class using the web console</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Access to the cluster with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To manage the default storage class using the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> &gt; <emphasis role="strong">CustomResourceDefinitions</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">CustomResourceDefinitions</emphasis> page, type <literal>clustercsidriver</literal> to find the <literal>ClusterCSIDriver</literal> object.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">ClusterCSIDriver</emphasis>, and then click the <emphasis role="strong">Instances</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Click the name of the desired instance, and then click the <emphasis role="strong">YAML</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Add the <literal>spec.storageClassState</literal> field with a value of <literal>Managed</literal>, <literal>Unmanaged</literal>, or <literal>Removed</literal>.</simpara>
<formalpara>
<title>Example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">...
spec:
  driverConfig:
    driverType: ''
  logLevel: Normal
  managementState: Managed
  observedConfig: null
  operatorLogLevel: Normal
  storageClassState: Unmanaged <co xml:id="CO79-1"/>
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO79-1">
<para><literal>spec.storageClassState</literal> field set to "Unmanaged"</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Save</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-csi-sc-managing-cli_persistent-storage-csi-sc-manage">
<title>Managing the default storage class using the CLI</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To manage the storage class using the CLI, run the following command:</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">oc patch clustercsidriver $DRIVERNAME --type=merge -p "{\"spec\":{\"storageClassState\":\"${STATE}\"}}" <co xml:id="CO80-1"/></programlisting>
<calloutlist>
<callout arearefs="CO80-1">
<para>Where <literal>${STATE}</literal> is "Removed" or "Managed" or "Unmanaged".</para>
<simpara>Where <literal>$DRIVERNAME</literal> is the provisioner name. You can find the provisioner name by running the command <literal>oc get sc</literal>.</simpara>
</callout>
</calloutlist>
</section>
<section xml:id="persistent-storage-csi-sc-multiple-none_persistent-storage-csi-sc-manage">
<title>Absent or multiple default storage classes</title>
<section xml:id="_multiple-default-storage-classes">
<title>Multiple default storage classes</title>
<simpara>Multiple default storage classes can occur if you mark a non-default storage class as default and do not unset the existing default storage class, or you create a default storage class when a default storage class is already present. With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<literal>pvc.spec.storageClassName</literal>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <literal>MultipleDefaultStorageClasses</literal>.</simpara>
</section>
<section xml:id="_absent-default-storage-class">
<title>Absent default storage class</title>
<simpara>There are two possible scenarios where PVCs can attempt to use a non-existent default storage class:</simpara>
<itemizedlist>
<listitem>
<simpara>An administrator removes the default storage class or marks it as non-default, and then a user creates a PVC requesting the default storage class.</simpara>
</listitem>
<listitem>
<simpara>During installation, the installer creates a PVC requesting the default storage class, which has not yet been created.</simpara>
</listitem>
</itemizedlist>
<simpara>In the preceding scenarios, PVCs remain in the pending state indefinitely. To resolve this situation, create a default storage class or declare one of the existing storage classes as the default. As soon as the default storage class is created or declared, the PVCs get the new default storage class. If possible, the PVCs eventually bind to statically or dynamically provisioned PVs as usual, and move out of the pending state.</simpara>
</section>
</section>
<section xml:id="change-default-storage-class_persistent-storage-csi-sc-manage">
<title>Changing the default storage class</title>
<simpara>Use the following procedure to change the default storage class.</simpara>
<simpara>For example, if you have two defined storage classes, <literal>gp3</literal> and <literal>standard</literal>, and you want to change the default storage class from <literal>gp3</literal> to <literal>standard</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To change the default storage class:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the storage classes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 TYPE
gp3 (default)        kubernetes.io/aws-ebs <co xml:id="CO81-1"/>
standard             kubernetes.io/aws-ebs</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO81-1">
<para><literal>(default)</literal> indicates the default storage class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Make the desired storage class the default.</simpara>
<simpara>For the desired storage class, set the <literal>storageclass.kubernetes.io/is-default-class</literal> annotation to <literal>true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</programlisting>
<note>
<simpara>You can have multiple default storage classes for a short time. However, you should ensure that only one default storage class exists eventually.</simpara>
<simpara>With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<literal>pvc.spec.storageClassName</literal>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <literal>MultipleDefaultStorageClasses</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Remove the default storage class setting from the old default storage class.</simpara>
<simpara>For the old default storage class, change the value of the <literal>storageclass.kubernetes.io/is-default-class</literal> annotation to <literal>false</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass gp3 -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Verify the changes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 TYPE
gp3                  kubernetes.io/aws-ebs
standard (default)   kubernetes.io/aws-ebs</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-migration">
<title>CSI automatic migration</title>

<simpara>In-tree storage drivers that are traditionally shipped with OpenShift Container Platform are being deprecated and replaced by their equivalent Container Storage Interface (CSI) drivers. OpenShift Container Platform provides automatic migration for in-tree volume plugins to their equivalent CSI drivers.</simpara>
<section xml:id="persistent-storage-csi-migration-overview_persistent-storage-csi-migration">
<title>Overview</title>
<simpara>This feature automatically migrates volumes that were provisioned using in-tree storage plugins to their counterpart Container Storage Interface (CSI) drivers.</simpara>
<simpara>This process does not perform any data migration; OpenShift Container Platform only translates the persistent volume object in memory. As a result, the translated persistent volume object is not stored on disk, nor is its contents changed. CSI automatic migration should be seamless. This feature does not change how you use all existing API objects: for example, <literal>PersistentVolumes</literal>, <literal>PersistentVolumeClaims</literal>, and <literal>StorageClasses</literal>.</simpara>
<simpara>The following in-tree to CSI drivers are automatically migrated:</simpara>
<itemizedlist>
<listitem>
<simpara>Azure Disk</simpara>
</listitem>
<listitem>
<simpara>OpenStack Cinder</simpara>
</listitem>
<listitem>
<simpara>Amazon Web Services (AWS) Elastic Block Storage (EBS)</simpara>
</listitem>
<listitem>
<simpara>Google Compute Engine Persistent Disk (GCP PD)</simpara>
</listitem>
<listitem>
<simpara>Azure File</simpara>
</listitem>
<listitem>
<simpara>VMware vSphere</simpara>
</listitem>
</itemizedlist>
<simpara>CSI migration for these volume types is considered generally available (GA), and requires no manual intervention.</simpara>
<simpara>CSI automatic migration of in-tree persistent volumes (PVs) or persistent volume claims (PVCs) does not enable any new CSI driver features, such as snapshots or expansion, if the original in-tree storage plugin did not support it.</simpara>
</section>
<section xml:id="persistent-storage-csi-migration-sc-implications_persistent-storage-csi-migration">
<title>Storage class implications</title>
<simpara>For new OpenShift Container Platform 4.13, and later, installations, the default storage class is the CSI storage class. All volumes provisioned using this storage class are CSI persistent volumes (PVs).</simpara>
<simpara>For clusters upgraded from 4.12, and earlier, to 4.13, and later, the CSI storage class is created, and is set as the default if no default storage class was set prior to the upgrade. In the very unlikely case that there is a storage class with the same name, the existing storage class remains unchanged. Any existing in-tree storage classes remain, and might be necessary for certain features, such as volume expansion to work for existing in-tree PVs. While storage class referencing to the in-tree storage plugin will continue working, we recommend that you switch the default storage class to the CSI storage class.</simpara>
<simpara>To change the default storage class, see <link linkend="change-default-storage-class_persistent-storage-csi-sc-manage">Changing the default storage class</link>.</simpara>
</section>
</section>
<section xml:id="ephemeral-storage-csi-vol-detach-non-graceful-shutdown">
<title>Detach CSI volumes after non-graceful node shutdown</title>

<simpara>This feature allows Container Storage Interface (CSI) drivers to automatically detach volumes when a node goes down non-gracefully.</simpara>
<section xml:id="persistent-storage-csi-vol-detach-non-graceful-overview_ephemeral-storage-csi-vol-detach-non-graceful-shutdown">
<title>Overview</title>
<simpara>A graceful node shutdown occurs when the kubelet&#8217;s node shutdown manager detects the upcoming node shutdown action. Non-graceful shutdowns occur when the kubelet does not detect a node shutdown action, which can occur because of system or hardware failures. Also, the kubelet may not detect a node shutdown action when the shutdown command does not trigger the Inhibitor Locks mechanism used by the kubelet on Linux, or because of a user error, for example, if the shutdownGracePeriod and shutdownGracePeriodCriticalPods details are not configured correctly for that node.</simpara>
<simpara>With this feature, when a non-graceful node shutdown occurs, you can manually add an <literal>out-of-service</literal> taint on the node to allow volumes to automatically detach from the node.</simpara>
</section>
<section xml:id="persistent-storage-csi-vol-detach-non-graceful-shutdown-procedure_ephemeral-storage-csi-vol-detach-non-graceful-shutdown">
<title>Adding an out-of-service taint manually for automatic volume detachment</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To allow volumes to detach automatically from a node after a non-graceful node shutdown:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>After a node is detected as unhealthy, shut down the worker node.</simpara>
</listitem>
<listitem>
<simpara>Ensure that the node is shutdown by running the following command and checking the status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc get node &lt;node name&gt; <co xml:id="CO82-1"/></programlisting>
<calloutlist>
<callout arearefs="CO82-1">
<para>&lt;node name&gt; = name of the non-gracefully shutdown node</para>
</callout>
</calloutlist>
<important>
<simpara>If the node is not completely shut down, do not proceed with tainting the node. If the node is still up and the taint is applied, filesystem corruption can occur.</simpara>
</important>
</listitem>
<listitem>
<simpara>Taint the corresponding node object by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">oc adm taint node &lt;node name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoExecute <co xml:id="CO83-1"/></programlisting>
<calloutlist>
<callout arearefs="CO83-1">
<para>&lt;node name&gt; = name of the non-gracefully shutdown node</para>
</callout>
</calloutlist>
<simpara>After the taint is applied, the volumes detach from the shutdown node allowing their disks to be attached to a different node.</simpara>
<formalpara>
<title>Example</title>
<para>The resulting YAML file resembles the following:</para>
</formalpara>
<programlisting language="yaml" linenumbering="unnumbered">spec:
  taints:
  - effect: NoExecute
    key: node.kubernetes.io/out-of-service
    value: nodeshutdown</programlisting>
</listitem>
<listitem>
<simpara>Restart the node.</simpara>
</listitem>
<listitem>
<simpara>Remove the taint.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-alicloud-disk">
<title>AliCloud Disk CSI Driver Operator</title>

<section xml:id="persistent-storage-csi-alicloud-disk-overview">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Alibaba AliCloud Disk Storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to AliCloud Disk storage assets, OpenShift Container Platform installs the AliCloud Disk CSI Driver Operator and the AliCloud Disk CSI driver, by default, in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>AliCloud Disk CSI Driver Operator</emphasis> provides a storage class (<literal>alicloud-disk</literal>) that you can use to create persistent volume claims (PVCs). The AliCloud Disk CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>AliCloud Disk CSI driver</emphasis> enables you to create and mount AliCloud Disk PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-alicloud-disk">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-ebs">
<title>AWS Elastic Block Store CSI Driver Operator</title>

<section xml:id="_overview-2">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the <link xlink:href="https://github.com/openshift/aws-ebs-csi-driver">AWS EBS CSI driver</link>.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a Container Storage Interface (CSI) Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to AWS EBS storage assets, OpenShift Container Platform installs the <link xlink:href="https://github.com/openshift/aws-ebs-csi-driver-operator">AWS EBS CSI Driver Operator</link> (a Red Hat operator) and the AWS EBS CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>AWS EBS CSI Driver Operator</emphasis> provides a StorageClass by default that you can use to create PVCs. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>). You also have the option to create the AWS EBS StorageClass as described in <link linkend="persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</link>.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>AWS EBS CSI driver</emphasis> enables you to create and mount AWS EBS PVs.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If you installed the AWS EBS CSI Operator and driver on an OpenShift Container Platform 4.5 cluster, you must uninstall the 4.5 Operator and driver before you update to OpenShift Container Platform 4.14.</simpara>
</note>
</section>
<section xml:id="csi-about_persistent-storage-csi-ebs">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using the CSI plugin to provision Amazon Elastic Block Store (Amazon EBS) storage.</simpara>
</important>
<simpara>For information about dynamically provisioning AWS EBS persistent volumes in OpenShift Container Platform, see <link linkend="persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</link>.</simpara>
</section>
<section xml:id="byok_persistent-storage-csi-ebs">
<title>User-managed encryption</title>
<simpara>The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <literal>platform.&lt;cloud_type&gt;.defaultMachinePlatform</literal> field in the install-config YAML file.</simpara>
<simpara>This features supports the following storage types:</simpara>
<itemizedlist>
<listitem>
<simpara>Amazon Web Services (AWS) Elastic Block storage (EBS)</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure Disk storage</simpara>
</listitem>
<listitem>
<simpara>Google Cloud Platform (GCP) persistent disk (PD) storage</simpara>
</listitem>
<listitem>
<simpara>IBM Virtual Private Cloud (VPC) Block storage</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If there is no encrypted key defined in the storage class, only set <literal>encrypted: "true"</literal> in the storage class. The AWS EBS CSI driver uses the AWS managed alias/aws/ebs, which is created by Amazon EBS automatically in each region by default to encrypt provisioned storage volumes. In addition, the managed storage classes all have the <literal>encrypted: "true"</literal> setting.</simpara>
</note>
<simpara>For information about installing with user-managed encryption for Amazon EBS, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-configuration-parameters_installing-aws-customizations">Installation configuration parameters</link>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-aws-efs">
<title>AWS Elastic File Service CSI Driver Operator</title>

<section xml:id="_overview-3">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for AWS Elastic File Service (EFS).</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>After installing the AWS EFS CSI Driver Operator, OpenShift Container Platform installs the AWS EFS CSI Operator and the AWS EFS CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace. This allows the AWS EFS CSI Driver Operator to create CSI-provisioned PVs that mount to AWS EFS assets.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>AWS EFS CSI Driver Operator</emphasis>, after being installed, does not create a storage class by default to use to create persistent volume claims (PVCs). However, you can manually create the AWS EFS <literal>StorageClass</literal>.
The AWS EFS CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand.
This eliminates the need for cluster administrators to pre-provision storage.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>AWS EFS CSI driver</emphasis> enables you to create and mount AWS EFS PVs.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>AWS EFS only supports regional volumes, not zonal volumes.</simpara>
</note>
</section>
<section xml:id="csi-about_persistent-storage-csi-aws-efs">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-efs-csi-driver-operator-setup_persistent-storage-csi-aws-efs">
<title>Setting up the AWS EFS CSI Driver Operator</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the <link xlink:href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</link> (a Red Hat operator).</simpara>
</listitem>
<listitem>
<simpara>If you are using AWS EFS with AWS Secure Token Service (STS), obtain a role Amazon Resource Name (ARN) for STS. This is required for installing the AWS EFS CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>Install the AWS EFS CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>Install the AWS EFS CSI Driver.</simpara>
</listitem>
</orderedlist>
<section xml:id="efs-sts_persistent-storage-csi-aws-efs">
<title>Obtaining a role Amazon Resource Name for Security Token Service</title>
<simpara>This procedure explains how to obtain a role Amazon Resource Name (ARN) to configure the AWS EFS CSI Driver Operator with OpenShift Container Platform on AWS Security Token Service (STS).</simpara>
<important>
<simpara>Perform this procedure before you install the AWS EFS CSI Driver Operator (see <emphasis>Installing the AWS EFS CSI Driver Operator</emphasis> procedure).</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster as a user with the cluster-admin role.</simpara>
</listitem>
<listitem>
<simpara>AWS account credentials</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>You can obtain the ARN role in multiple ways. The following procedure shows one method that uses the same concept and CCO utility (<literal>ccoctl</literal>) binary tool as cluster installation.</para>
</formalpara>
<simpara>To obtain a role ARN for configuring AWS EFS CSI Driver Operator using STS:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Extract the <literal>ccoctl</literal> from the OpenShift Container Platform release image, which you used to install the cluster with STS. For more information, see "Configuring the Cloud Credential Operator utility".</simpara>
</listitem>
<listitem>
<simpara>Create and save an EFS <literal>CredentialsRequest</literal> YAML file, such as shown in the following example, and then place it in the <literal>credrequests</literal> directory:</simpara>
<formalpara>
<title>Example</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: openshift-aws-efs-csi-driver
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - elasticfilesystem:*
      effect: Allow
      resource: '*'
  secretRef:
    name: aws-efs-cloud-credentials
    namespace: openshift-cluster-csi-drivers
  serviceAccountNames:
  - aws-efs-csi-driver-operator
  - aws-efs-csi-driver-controller-sa</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Run the <literal>ccoctl</literal> tool to generate a new IAM role in AWS, and create a YAML file for it in the local file system (<literal>&lt;path_to_ccoctl_output_dir&gt;/manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml</literal>).</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-iam-roles --name=&lt;name&gt; --region=&lt;aws_region&gt; --credentials-requests-dir=&lt;path_to_directory_with_list_of_credentials_requests&gt;/credrequests --identity-provider-arn=arn:aws:iam::&lt;aws_account_id&gt;:oidc-provider/&lt;name&gt;-oidc.s3.&lt;aws_region&gt;.amazonaws.com</programlisting>
<itemizedlist>
<listitem>
<simpara><literal>name=&lt;name&gt;</literal> is the name used to tag any cloud resources that are created for tracking.</simpara>
</listitem>
<listitem>
<simpara><literal>region=&lt;aws_region&gt;</literal> is the AWS region where cloud resources are created.</simpara>
</listitem>
<listitem>
<simpara><literal>dir=&lt;path_to_directory_with_list_of_credentials_requests&gt;/credrequests</literal> is the directory containing the EFS CredentialsRequest file in previous step.</simpara>
</listitem>
<listitem>
<simpara><literal>&lt;aws_account_id&gt;</literal> is the AWS account ID.</simpara>
<formalpara>
<title>Example</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ ccoctl aws create-iam-roles --name my-aws-efs --credentials-requests-dir credrequests --identity-provider-arn arn:aws:iam::123456789012:oidc-provider/my-aws-efs-oidc.s3.us-east-2.amazonaws.com</programlisting>
</para>
</formalpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">2022/03/21 06:24:44 Role arn:aws:iam::123456789012:role/my-aws-efs -openshift-cluster-csi-drivers-aws-efs-cloud- created
2022/03/21 06:24:44 Saved credentials configuration to: /manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml
2022/03/21 06:24:45 Updated Role policy for Role my-aws-efs-openshift-cluster-csi-drivers-aws-efs-cloud-</programlisting>
</para>
</formalpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Copy the role ARN from the first line of the <emphasis>Example output</emphasis> in the preceding step. The role ARN is between "Role" and "created". In this example, the role ARN is "arn:aws:iam::123456789012:role/my-aws-efs -openshift-cluster-csi-drivers-aws-efs-cloud".</simpara>
<simpara>You will need the role ARN when you install the AWS EFS CSI Driver Operator.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Next steps</title>
<para><link linkend="persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs">Install the AWS EFS CSI Driver Operator</link>.</para>
</formalpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs">Installing the AWS EFS CSI Driver Operator</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#cco-ccoctl-configuring_installing-aws-customizations">Configuring the Cloud Credential Operator utility</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs">Installing the AWS EFS CSI Driver</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs">
<title>Installing the AWS EFS CSI Driver Operator</title>
<simpara>The <link xlink:href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</link> (a Red Hat operator) is not installed in OpenShift Container Platform by default. Use the following procedure to install and configure the AWS EFS CSI Driver Operator in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the AWS EFS CSI Driver Operator from the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Install the AWS EFS CSI Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Locate the AWS EFS CSI Operator by typing <emphasis role="strong">AWS EFS CSI</emphasis> in the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">AWS EFS CSI Driver Operator</emphasis> button.</simpara>
<important>
<simpara>Be sure to select the <emphasis role="strong">AWS EFS CSI Driver Operator</emphasis> and not the <emphasis role="strong">AWS EFS Operator</emphasis>. The <emphasis role="strong">AWS EFS Operator</emphasis> is a community Operator and is not supported by Red Hat.</simpara>
</important>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">AWS EFS CSI Driver Operator</emphasis> page, click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that:</simpara>
<itemizedlist>
<listitem>
<simpara>If you are using AWS EFS with AWS Secure Token Service (STS), in the <emphasis role="strong">role ARN</emphasis> field, enter the ARN role copied from the last step of the <emphasis>Obtaining a role Amazon Resource Name for Security Token Service</emphasis> procedure.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">All namespaces on the cluster (default)</emphasis> is selected.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installed Namespace</emphasis> is set to <emphasis role="strong">openshift-cluster-csi-drivers</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
<simpara>After the installation finishes, the AWS EFS CSI Operator is listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<formalpara>
<title>Next steps</title>
<para><link linkend="persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs">Install the AWS EFS CSI Driver</link>.</para>
</formalpara>
</section>
<section xml:id="persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs">
<title>Installing the AWS EFS CSI Driver</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis> &#8594; <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, click <emphasis role="strong">Create ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Use the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: efs.csi.aws.com
spec:
  managementState: Managed</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Wait for the following Conditions to change to a "True" status:</simpara>
<itemizedlist>
<listitem>
<simpara>AWSEFSDriverNodeServiceControllerAvailable</simpara>
</listitem>
<listitem>
<simpara>AWSEFSDriverControllerServiceControllerAvailable</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="storage-create-storage-class_persistent-storage-csi-aws-efs">
<title>Creating the AWS EFS storage class</title>
<simpara>Storage classes are used to differentiate and delineate storage levels and
usages. By defining a storage class, users can obtain dynamically provisioned
persistent volumes.</simpara>
<simpara>The <emphasis><link xlink:href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</link> (a Red Hat operator)</emphasis>, after being installed, does not create a storage class by default. However, you can manually create the AWS EFS storage class.</simpara>
<section xml:id="storage-create-storage-class-console_persistent-storage-csi-aws-efs">
<title>Creating the AWS EFS storage class using the console</title>
<orderedlist role="_abstract" numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">StorageClasses</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">StorageClasses</emphasis> page, click <emphasis role="strong">Create StorageClass</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">StorageClass</emphasis> page, perform the following steps:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Enter a name to reference the storage class.</simpara>
</listitem>
<listitem>
<simpara>Optional: Enter the description.</simpara>
</listitem>
<listitem>
<simpara>Select the reclaim policy.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong"><literal>efs.csi.aws.com</literal></emphasis> from the <emphasis role="strong">Provisioner</emphasis> drop-down list.</simpara>
</listitem>
<listitem>
<simpara>Optional: Set the configuration parameters for the selected provisioner.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="storage-create-storage-class-cli_persistent-storage-csi-aws-efs">
<title>Creating the AWS EFS storage class using the CLI</title>
<itemizedlist role="_abstract">
<title>Procedure</title>
<listitem>
<simpara>Create a <literal>StorageClass</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: efs-sc
provisioner: efs.csi.aws.com
parameters:
  provisioningMode: efs-ap <co xml:id="CO84-1"/>
  fileSystemId: fs-a5324911 <co xml:id="CO84-2"/>
  directoryPerms: "700" <co xml:id="CO84-3"/>
  gidRangeStart: "1000" <co xml:id="CO84-4"/>
  gidRangeEnd: "2000" <co xml:id="CO84-5"/>
  basePath: "/dynamic_provisioning" <co xml:id="CO84-6"/></programlisting>
<calloutlist>
<callout arearefs="CO84-1">
<para><literal>provisioningMode</literal> must be <literal>efs-ap</literal> to enable dynamic provisioning.</para>
</callout>
<callout arearefs="CO84-2">
<para><literal>fileSystemId</literal> must be the ID of the EFS volume created manually.</para>
</callout>
<callout arearefs="CO84-3">
<para><literal>directoryPerms</literal> is the default permission of the root directory of the volume. In this example, the volume is accessible only by the owner.</para>
</callout>
<callout arearefs="CO84-4 CO84-5">
<para><literal>gidRangeStart</literal> and <literal>gidRangeEnd</literal> set the range of POSIX Group IDs (GIDs) that are used to set the GID of the AWS access point. If not specified, the default range is 50000-7000000. Each provisioned volume, and thus AWS access point, is assigned a unique GID from this range.</para>
</callout>
<callout arearefs="CO84-6">
<para><literal>basePath</literal> is the directory on the EFS volume that is used to create dynamically provisioned volumes. In this case, a PV is provisioned as “/dynamic_provisioning/&lt;random uuid&gt;” on the EFS volume. Only the subdirectory is mounted to pods that use the PV.</para>
</callout>
</calloutlist>
<note>
<simpara>A cluster admin can create several <literal>StorageClass</literal> objects, each using a different EFS volume.</simpara>
</note>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-efs-cross-account_persistent-storage-csi-aws-efs">
<title>AWS EFS CSI cross account support</title>
<simpara>Cross account support allows you to have an OpenShift Container Platform cluster in one AWS account and mount your file system in another AWS account using the AWS Elastic File System (EFS) Container Storage Interface (CSI) driver.</simpara>
<note>
<simpara>Both the OpenShift Container Platform cluster and EFS file system must be in the same region.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an OpenShift Container Platform cluster with administrator rights</simpara>
</listitem>
<listitem>
<simpara>Two valid AWS accounts</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>The following procedure demonstrates how to set up:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>OpenShift Container Platform cluster in AWS account A</simpara>
</listitem>
<listitem>
<simpara>Mount an AWS EFS file system in account B</simpara>
</listitem>
</itemizedlist>
<simpara>To use AWS EFS across accounts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install OpenShift Container Platform cluster with AWS account A and install the EFS CSI Driver Operator.</simpara>
</listitem>
<listitem>
<simpara>Create an EFS volume in AWS account B:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a virtual private cloud (VPC) called, for example, "my-efs-vpc” with CIDR, for example, “172.20.0.0/16” and subnet for the AWS EFS volume.</simpara>
</listitem>
<listitem>
<simpara>On the AWS console, go to <link xlink:href="https://console.aws.amazon.com/efs">https://console.aws.amazon.com/efs</link>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create new filesystem</emphasis>:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Create a filesystem named, for example, "my-filesystem”.</simpara>
</listitem>
<listitem>
<simpara>Select the VPC created earlier (“my-efs-vpc”).</simpara>
</listitem>
<listitem>
<simpara>Accept the default for the remaining settings.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Ensure that the volume and Mount Targets have been created:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>Check <link xlink:href="https://console.aws.amazon.com/efs#/file-systems">https://console.aws.amazon.com/efs#/file-systems</link>.</simpara>
</listitem>
<listitem>
<simpara>Click your volume, and on the <emphasis role="strong">Network</emphasis> tab wait for all Mount Targets to be available (approximately 1-2 minutes).</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Network</emphasis> tab, copy the Security Group ID. You will need it for the next step.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Configure networking access to the AWS EFS volume on AWS account B:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Go to <link xlink:href="https://console.aws.amazon.com/ec2/v2/home#SecurityGroups">https://console.aws.amazon.com/ec2/v2/home#SecurityGroups</link>.</simpara>
</listitem>
<listitem>
<simpara>Find the Security Group used by the AWS EFS volume by filtering for the group ID copied earlier.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Inbound rules</emphasis> tab, click  <emphasis role="strong">Edit inbound rules</emphasis>, and then add a new rule to allow OpenShift Container Platform nodes to access the AWS EFS volumes (that is, use NFS ports from the cluster):</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: NFS</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Protocol</emphasis>: TCP</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Port range</emphasis>: 2049</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Source</emphasis>: Custom/IP address range of your OpenShift Container Platform cluster nodes (for example, “10.0.0.0/16”)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Save the rule.</simpara>
<note>
<simpara>If you encounter mounting issues, re-check the port number, IP address range, and verify that the AWS EFS volume uses the expected security group.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create VPC peering between the OpenShift Container Platform cluster VPC in AWS account A and the AWS EFS VPC in AWS account B:</simpara>
<simpara>Ensure the two VPCs are using different network CIDRs, and after creating the VPC peering, add routes in each VPC to connect the two VPC networks.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Create a peering connection called, for example, “my-efs-crossaccount-peering-connection” in account B. For the local VPC ID, use the EFS-located VPC. To peer with the VPC for account A, for the VPC ID use the OpenShift Container Platform cluster VPC ID.</simpara>
</listitem>
<listitem>
<simpara>Accept the peer connection in AWS account A.</simpara>
</listitem>
<listitem>
<simpara>Modify the route table of each subnet (EFS-volume used subnets) in AWS account B:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>On the left pane, under <emphasis role="strong">Virtual private cloud</emphasis>, click the down arrow to expand the available options.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Virtual private cloud</emphasis>, click <emphasis role="strong">Route tables"</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Routes</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Destination</emphasis>, enter 10.0.0.0/16.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Target</emphasis>, use the peer connection type point from the created peer connection.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Modify the route table of each subnet (OpenShift Container Platform cluster nodes used subnets) in AWS account A:</simpara>
<orderedlist numeration="lowerroman">
<listitem>
<simpara>On the left pane, under <emphasis role="strong">Virtual private cloud</emphasis>, click the down arrow to expand the available options.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Virtual private cloud</emphasis>, click <emphasis role="strong">Route tables"</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Routes</emphasis> tab.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Destination</emphasis>, enter the CIDR for the VPC in account B, which for this example is 172.20.0.0/16.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Target</emphasis>, use the peer connection type point from the created peer connection.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create an IAM role, for example, “my-efs-acrossaccount-role” in AWS account B, which has a trust relationship with AWS account A, and add an inline AWS EFS policy with permissions to call “my-efs-acrossaccount-driver-policy”.</simpara>
<simpara>This role is used by the CSI driver&#8217;s controller service running on the OpenShift Container Platform cluster in AWS account A to determine the mount targets for your file system in AWS account B.</simpara>
<programlisting language="json" linenumbering="unnumbered"># Trust relationships trusted entity trusted account A configuration on my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::301721915996:root"
            },
            "Action": "sts:AssumeRole",
            "Condition": {}
        }
    ]
}

# my-cross-account-assume-policy policy attached to my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": {
        "Effect": "Allow",
        "Action": "sts:AssumeRole",
        "Resource": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
    }
}

# my-efs-acrossaccount-driver-policy attached to my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "ec2:DescribeNetworkInterfaces",
                "ec2:DescribeSubnets"
            ],
            "Resource": "*"
        },
        {
            "Sid": "VisualEditor1",
            "Effect": "Allow",
            "Action": [
                "elasticfilesystem:DescribeMountTargets",
                "elasticfilesystem:DeleteAccessPoint",
                "elasticfilesystem:ClientMount",
                "elasticfilesystem:DescribeAccessPoints",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:DescribeFileSystems",
                "elasticfilesystem:CreateAccessPoint"
            ],
            "Resource": [
                "arn:aws:elasticfilesystem:*:589722580343:access-point/*",
                "arn:aws:elasticfilesystem:*:589722580343:file-system/*"
            ]
        }
    ]
}</programlisting>
</listitem>
<listitem>
<simpara>In AWS account A, attach an inline policy to the IAM role of the AWS EFS CSI driver&#8217;s controller service account with the necessary permissions to perform Security Token Service (STS) assume role on the IAM role created earlier.</simpara>
<programlisting language="json" linenumbering="unnumbered"># my-cross-account-assume-policy policy attached to Openshift cluster efs csi driver user in account A

{
    "Version": "2012-10-17",
    "Statement": {
        "Effect": "Allow",
        "Action": "sts:AssumeRole",
        "Resource": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
    }
}</programlisting>
</listitem>
<listitem>
<simpara>In AWS account A, attach the AWS-managed policy “AmazonElasticFileSystemClientFullAccess” to OpenShift Container Platform cluster master role. The role name is in the form <literal>&lt;clusterID&gt;-master-role</literal> (for example, <literal>my-0120ef-czjrl-master-role</literal>).</simpara>
</listitem>
<listitem>
<simpara>Create a Kubernetes secret with <literal>awsRoleArn</literal> as the key and the role created earlier as the value:</simpara>
<programlisting language="cli" linenumbering="unnumbered">$ oc -n openshift-cluster-csi-drivers create secret generic my-efs-cross-account --from-literal=awsRoleArn='arn:aws:iam::589722580343:role/my-efs-acrossaccount-role'</programlisting>
<simpara>Since the driver controller needs to get the cross account role information from the secret, you need to add the secret role binding to the AWS EFS CSI driver controller ServiceAccount (SA):</simpara>
<programlisting language="cli" linenumbering="unnumbered">$ oc -n openshift-cluster-csi-drivers create role access-secrets --verb=get,list,watch --resource=secrets

$ oc -n openshift-cluster-csi-drivers create rolebinding --role=access-secrets default-to-secrets --serviceaccount=openshift-cluster-csi-drivers:aws-efs-csi-driver-controller-sa</programlisting>
</listitem>
<listitem>
<simpara>Create a <literal>filesystem</literal> policy for the file system (AWS EFS volume) in account B, which allows AWS account A to perform a mount on it.</simpara>
<screen>This step is not mandatory, but can be safer for AWS EFS volume usage.</screen>
<programlisting language="json" linenumbering="unnumbered"># EFS volume filesystem policy in account B
{
    "Version": "2012-10-17",
    "Id": "efs-policy-wizard-8089bf4a-9787-40f0-958e-bc2363012ace",
    "Statement": [
        {
            "Sid": "efs-statement-bd285549-cfa2-4f8b-861e-c372399fd238",
            "Effect": "Allow",
            "Principal": {
                "AWS": "*"
            },
            "Action": [
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientMount"
            ],
            "Resource": "arn:aws:elasticfilesystem:us-east-2:589722580343:file-system/fs-091066a9bf9becbd5",
            "Condition": {
                "Bool": {
                    "elasticfilesystem:AccessedViaMountTarget": "true"
                }
            }
        },
        {
            "Sid": "efs-statement-03646e39-d80f-4daf-b396-281be1e43bab",
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
            },
            "Action": [
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientMount"
            ],
            "Resource": "arn:aws:elasticfilesystem:us-east-2:589722580343:file-system/fs-091066a9bf9becbd5"
        }
    ]
}</programlisting>
</listitem>
<listitem>
<simpara>Create an AWS EFS volume storage class using a similar configuration to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered"># The cross account efs volume storageClass
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: efs-cross-account-mount-sc
provisioner: efs.csi.aws.com
mountOptions:
  - tls
parameters:
  provisioningMode: efs-ap
  fileSystemId: fs-00f6c3ae6f06388bb
  directoryPerms: "700"
  gidRangeStart: "1000"
  gidRangeEnd: "2000"
  basePath: "/account-a-data"
  csi.storage.k8s.io/provisioner-secret-name: my-efs-cross-account
  csi.storage.k8s.io/provisioner-secret-namespace: openshift-cluster-csi-drivers
volumeBindingMode: Immediate</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="efs-create-volume_persistent-storage-csi-aws-efs">
<title>Creating and configuring access to EFS volumes in AWS</title>
<simpara>This procedure explains how to create and configure EFS volumes in AWS so that you can use them in OpenShift Container Platform.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>AWS account credentials</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To create and configure access to an EFS volume in AWS:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>On the AWS console, open <link xlink:href="https://console.aws.amazon.com/efs">https://console.aws.amazon.com/efs</link>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create file system</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>Enter a name for the file system.</simpara>
</listitem>
<listitem>
<simpara>For <emphasis role="strong">Virtual Private Cloud (VPC)</emphasis>, select your OpenShift Container Platform&#8217;s' virtual private cloud (VPC).</simpara>
</listitem>
<listitem>
<simpara>Accept default settings for all other selections.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Wait for the volume and mount targets to finish being fully created:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Go to <link xlink:href="https://console.aws.amazon.com/efs#/file-systems">https://console.aws.amazon.com/efs#/file-systems</link>.</simpara>
</listitem>
<listitem>
<simpara>Click your volume, and on the <emphasis role="strong">Network</emphasis> tab wait for all mount targets to become available (~1-2 minutes).</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Network</emphasis> tab, copy the Security Group ID (you will need this in the next step).</simpara>
</listitem>
<listitem>
<simpara>Go to <link xlink:href="https://console.aws.amazon.com/ec2/v2/home#SecurityGroups">https://console.aws.amazon.com/ec2/v2/home#SecurityGroups</link>, and find the Security Group used by the EFS volume.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Inbound rules</emphasis> tab, click <emphasis role="strong">Edit inbound rules</emphasis>, and then add a new rule with the following settings to allow OpenShift Container Platform nodes to access EFS volumes :</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Type</emphasis>: NFS</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Protocol</emphasis>: TCP</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Port range</emphasis>: 2049</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Source</emphasis>: Custom/IP address range of your nodes (for example: “10.0.0.0/16”)</simpara>
<simpara>This step allows OpenShift Container Platform to use NFS ports from the cluster.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Save the rule.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="csi-dynamic-provisioning-aws-efs_persistent-storage-csi-aws-efs">
<title>Dynamic provisioning for Amazon Elastic File Storage</title>
<simpara role="_abstract">The <link xlink:href="https://github.com/openshift/aws-efs-csi-driver">AWS EFS CSI driver</link> supports a different form of dynamic provisioning than other CSI drivers. It provisions new PVs as subdirectories of a pre-existing EFS volume. The PVs are independent of each other. However, they all share the same EFS volume. When the volume is deleted, all PVs provisioned out of it are deleted too.
The EFS CSI driver creates an AWS Access Point for each such subdirectory. Due to AWS AccessPoint limits, you can only dynamically provision 1000 PVs from a single <literal>StorageClass</literal>/EFS volume.</simpara>
<important>
<simpara>Note that <literal>PVC.spec.resources</literal> is not enforced by EFS.</simpara>
<simpara>In the example below, you request 5 GiB of space. However, the created PV is limitless and can store any amount of data (like petabytes). A broken application, or even a rogue application, can cause significant expenses when it stores too much data on the volume.</simpara>
<simpara>Using monitoring of EFS volume sizes in AWS is strongly recommended.</simpara>
</important>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created Amazon Elastic File Storage (Amazon EFS) volumes.</simpara>
</listitem>
<listitem>
<simpara>You have created the AWS EFS storage class.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To enable dynamic provisioning:</para>
</formalpara>
<itemizedlist>
<listitem>
<simpara>Create a PVC (or StatefulSet or Template) as usual, referring to the <literal>StorageClass</literal> created previously.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test
spec:
  storageClassName: efs-sc
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi</programlisting>
</listitem>
</itemizedlist>
<simpara>If you have problems setting up dynamic provisioning, see <link linkend="efs-troubleshooting_persistent-storage-csi-aws-efs">AWS EFS troubleshooting</link>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="efs-create-volume_persistent-storage-csi-aws-efs">Creating and configuring access to AWS EFS volume(s)</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="storage-create-storage-class_persistent-storage-csi-aws-efs">Creating the AWS EFS storage class</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="efs-create-static-pv_persistent-storage-csi-aws-efs">
<title>Creating static PVs with Amazon Elastic File Storage</title>
<simpara>It is possible to use an Amazon Elastic File Storage (Amazon EFS) volume as a single PV without any dynamic provisioning. The whole volume is mounted to pods.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You have created Amazon EFS volumes.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Create the PV using the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolume
metadata:
  name: efs-pv
spec:
  capacity: <co xml:id="CO85-1"/>
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteMany
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  csi:
    driver: efs.csi.aws.com
    volumeHandle: fs-ae66151a <co xml:id="CO85-2"/>
    volumeAttributes:
      encryptInTransit: "false" <co xml:id="CO85-3"/></programlisting>
<calloutlist>
<callout arearefs="CO85-1">
<para><literal>spec.capacity</literal> does not have any meaning and is ignored by the CSI driver. It is used only when binding to a PVC. Applications can store any amount of data to the volume.</para>
</callout>
<callout arearefs="CO85-2">
<para><literal>volumeHandle</literal> must be the same ID as the EFS volume you created in AWS. If you are providing your own access point, <literal>volumeHandle</literal> should be <literal>&lt;EFS volume ID&gt;::&lt;access point ID&gt;</literal>. For example: <literal>fs-6e633ada::fsap-081a1d293f0004630</literal>.</para>
</callout>
<callout arearefs="CO85-3">
<para>If desired, you can disable encryption in transit. Encryption is enabled by default.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
<simpara>If you have problems setting up static PVs, see <link linkend="efs-troubleshooting_persistent-storage-csi-aws-efs">AWS EFS troubleshooting</link>.</simpara>
</section>
<section xml:id="efs-security_persistent-storage-csi-aws-efs">
<title>Amazon Elastic File Storage security</title>
<simpara>The following information is important for Amazon Elastic File Storage (Amazon EFS) security.</simpara>
<simpara>When using access points, for example, by using dynamic provisioning as described earlier, Amazon automatically replaces GIDs on files with the GID of the access point. In addition, EFS considers the user ID, group ID, and secondary group IDs of the access point when evaluating file system permissions. EFS ignores the NFS client&#8217;s IDs. For more information about access points, see <link xlink:href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html</link>.</simpara>
<simpara>As a consequence, EFS volumes silently ignore FSGroup; OpenShift Container Platform is not able to replace the GIDs of files on the volume with FSGroup. Any pod that can access a mounted EFS access point can access any file on it.</simpara>
<simpara>Unrelated to this, encryption in transit is enabled by default. For more information, see <link xlink:href="https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html">https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html</link>.</simpara>
</section>
<section xml:id="efs-troubleshooting_persistent-storage-csi-aws-efs">
<title>Amazon Elastic File Storage troubleshooting</title>
<simpara>The following information provides guidance on how to troubleshoot issues with Amazon Elastic File Storage (Amazon EFS):</simpara>
<itemizedlist>
<listitem>
<simpara>The AWS EFS Operator and CSI driver run in namespace <literal>openshift-cluster-csi-drivers</literal>.</simpara>
</listitem>
<listitem>
<simpara>To initiate gathering of logs of the AWS EFS Operator and CSI driver, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm must-gather
[must-gather      ] OUT Using must-gather plugin-in image: quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:125f183d13601537ff15b3239df95d47f0a604da2847b561151fedd699f5e3a5
[must-gather      ] OUT namespace/openshift-must-gather-xm4wq created
[must-gather      ] OUT clusterrolebinding.rbac.authorization.k8s.io/must-gather-2bd8x created
[must-gather      ] OUT pod for plug-in image quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:125f183d13601537ff15b3239df95d47f0a604da2847b561151fedd699f5e3a5 created</programlisting>
</listitem>
<listitem>
<simpara>To show AWS EFS Operator errors, view the <literal>ClusterCSIDriver</literal> status:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get clustercsidriver efs.csi.aws.com -o yaml</programlisting>
</listitem>
<listitem>
<simpara>If a volume cannot be mounted to a pod (as shown in the output of the following command):</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pod
...
  Type     Reason       Age    From               Message
  ----     ------       ----   ----               -------
  Normal   Scheduled    2m13s  default-scheduler  Successfully assigned default/efs-app to ip-10-0-135-94.ec2.internal
  Warning  FailedMount  13s    kubelet            MountVolume.SetUp failed for volume "pvc-d7c097e6-67ec-4fae-b968-7e7056796449" : rpc error: code = DeadlineExceeded desc = context deadline exceeded <co xml:id="CO86-1"/>
  Warning  FailedMount  10s    kubelet            Unable to attach or mount volumes: unmounted volumes=[persistent-storage], unattached volumes=[persistent-storage kube-api-access-9j477]: timed out waiting for the condition</programlisting>
<calloutlist>
<callout arearefs="CO86-1">
<para>Warning message indicating volume not mounted.</para>
</callout>
</calloutlist>
<simpara>This error is frequently caused by AWS dropping packets between an OpenShift Container Platform node and Amazon EFS.</simpara>
<simpara>Check that the following are correct:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS firewall and Security Groups</simpara>
</listitem>
<listitem>
<simpara>Networking: port number and IP addresses</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-olm-operator-uninstall_persistent-storage-csi-aws-efs">
<title>Uninstalling the AWS EFS CSI Driver Operator</title>
<simpara>All EFS PVs are inaccessible after uninstalling the <link xlink:href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</link> (a Red Hat operator).</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To uninstall the AWS EFS CSI Driver Operator from the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Stop all applications that use AWS EFS PVs.</simpara>
</listitem>
<listitem>
<simpara>Delete all AWS EFS PVs:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Storage</emphasis> &#8594; <emphasis role="strong">PersistentVolumeClaims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select each PVC that is in use by the AWS EFS CSI Driver Operator, click the drop-down menu on the far right of the PVC, and then click <emphasis role="strong">Delete PersistentVolumeClaims</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Uninstall the <link xlink:href="https://github.com/openshift/aws-efs-csi-driver">AWS EFS CSI driver</link>:</simpara>
<note>
<simpara>Before you can uninstall the Operator, you must remove the CSI driver first.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis> &#8594; <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, for <emphasis role="strong">efs.csi.aws.com</emphasis>, on the far left side, click the drop-down menu, and then click <emphasis role="strong">Delete ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Uninstall the AWS EFS CSI Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, scroll or type AWS EFS CSI into the <emphasis role="strong">Search by name</emphasis> box to find the Operator, and then click it.</simpara>
</listitem>
<listitem>
<simpara>On the upper, right of the <emphasis role="strong">Installed Operators &gt; Operator details</emphasis> page, click <emphasis role="strong">Actions</emphasis> &#8594; <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted on the <emphasis role="strong">Uninstall Operator</emphasis> window, click the <emphasis role="strong">Uninstall</emphasis> button to remove the Operator from the namespace. Any applications deployed by the Operator on the cluster need to be cleaned up manually.</simpara>
<simpara>After uninstalling, the AWS EFS CSI Driver Operator is no longer listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<note>
<simpara>Before you can destroy a cluster (<literal>openshift-install destroy cluster</literal>), you must delete the EFS volume in AWS. An OpenShift Container Platform cluster cannot be destroyed when there is an EFS volume that uses the cluster&#8217;s VPC. Amazon does not allow deletion of such a VPC.</simpara>
</note>
</section>
<section xml:id="_additional-resources" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-azure-disk">
<title>Azure Disk CSI Driver Operator</title>

<section xml:id="_overview-4">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Microsoft Azure Disk Storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to Azure Disk storage assets, OpenShift Container Platform installs the Azure Disk CSI Driver Operator and the Azure Disk CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Azure Disk CSI Driver Operator</emphasis> provides a storage class named <literal>managed-csi</literal> that you can use to create persistent volume claims (PVCs). The Azure Disk CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Azure Disk CSI driver</emphasis> enables you to create and mount Azure Disk PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-azure">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using the CSI plugin to provision Azure Disk storage.</simpara>
</important>
</section>
<section xml:id="persistent-storage-csi-azure-disk-sc-zrs_persistent-storage-csi-azure">
<title>Creating a storage class with storage account type</title>
<simpara>Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, you can obtain dynamically provisioned persistent volumes.</simpara>
<simpara>When creating a storage class, you can designate the storage account type. This corresponds to your Azure storage account SKU tier. Valid options are <literal>Standard_LRS</literal>, <literal>Premium_LRS</literal>, <literal>StandardSSD_LRS</literal>, <literal>UltraSSD_LRS</literal>, <literal>Premium_ZRS</literal>, and <literal>StandardSSD_ZRS</literal>. For information about finding your Azure SKU tier, see <link xlink:href="https://learn.microsoft.com/en-us/rest/api/storagerp/srp_sku_types">SKU Types</link>.</simpara>
<simpara>ZRS has some region limitations. For information about these limitations, see <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-zrs?tabs=portal#limitations">ZRS limitations</link>.</simpara>
<simpara>Both ZRS and PremiumV2_LRS have some region limitations. For information about these limitations, see <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-zrs?tabs=portal#limitations">ZRS limitations</link> and <link xlink:href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-premium-v2?tabs=azure-cli#limitations">Premium_LRS limitations</link>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to an OpenShift Container Platform cluster with administrator rights</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>Use the following steps to create a storage class with a storage account type.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a storage class designating the storage account type using a YAML file similar to the following:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f - &lt;&lt; EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class&gt; <co xml:id="CO87-1"/>
provisioner: disk.csi.azure.com
parameters:
  skuName: &lt;storage-class-account-type&gt; <co xml:id="CO87-2"/>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
EOF</programlisting>
<calloutlist>
<callout arearefs="CO87-1">
<para>Storage class name.</para>
</callout>
<callout arearefs="CO87-2">
<para>Storage account type. This corresponds to your Azure storage account SKU tier:`Standard_LRS`, <literal>Premium_LRS</literal>, <literal>StandardSSD_LRS</literal>, <literal>UltraSSD_LRS</literal>, <literal>Premium_ZRS</literal>, <literal>StandardSSD_ZRS</literal>, <literal>PremiumV2_LRS</literal>.</para>
</callout>
</calloutlist>
<note>
<simpara>For PremiumV2_LRS, specify <literal>cachingMode: None</literal> in <literal>storageclass.parameters</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Ensure that the storage class was created by listing the storage classes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass
NAME                    PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
azurefile-csi           file.csi.azure.com   Delete          Immediate              true                   68m
managed-csi (default)   disk.csi.azure.com   Delete          WaitForFirstConsumer   true                   68m
sc-prem-zrs             disk.csi.azure.com   Delete          WaitForFirstConsumer   true                   4m25s <co xml:id="CO88-1"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO88-1">
<para>New storage class with storage account type.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="byok_persistent-storage-csi-azure">
<title>User-managed encryption</title>
<simpara>The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <literal>platform.&lt;cloud_type&gt;.defaultMachinePlatform</literal> field in the install-config YAML file.</simpara>
<simpara>This features supports the following storage types:</simpara>
<itemizedlist>
<listitem>
<simpara>Amazon Web Services (AWS) Elastic Block storage (EBS)</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure Disk storage</simpara>
</listitem>
<listitem>
<simpara>Google Cloud Platform (GCP) persistent disk (PD) storage</simpara>
</listitem>
<listitem>
<simpara>IBM Virtual Private Cloud (VPC) Block storage</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>If the OS (root) disk is encrypted, and there is no encrypted key defined in the storage class, Azure Disk CSI driver uses the OS disk encryption key by default to encrypt provisioned storage volumes.</simpara>
</note>
<simpara>For information about installing with user-managed encryption for Azure, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#">Enabling user-managed encryption for Azure</link>.</simpara>
</section>
<section xml:id="machineset-azure-ultra-disk_persistent-storage-csi-azure">
<title>Machine sets that deploy machines with ultra disks using PVCs</title>
<simpara>You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.</simpara>
<simpara>Both the in-tree plugin and CSI driver support using PVCs to enable ultra disks. You can also deploy machines with ultra disks as data disks without creating a PVC.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="machineset-azure-ultra-disk_persistent-storage-azure">Machine sets that deploy machines on ultra disks using in-tree PVCs</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/machine_management/#machineset-azure-ultra-disk_creating-machineset-azure">Machine sets that deploy machines on ultra disks as data disks</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="machineset-creating-azure-ultra-disk_persistent-storage-csi-azure">
<title>Creating machines with ultra disks by using machine sets</title>
<simpara>You can deploy machines with ultra disks on Azure by editing your machine set YAML file.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Have an existing Microsoft Azure cluster.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Copy an existing Azure <literal>MachineSet</literal> custom resource (CR) and edit it by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit machineset &lt;machine-set-name&gt;</programlisting>
<simpara>where <literal>&lt;machine-set-name&gt;</literal> is the machine set that you want to provision machines with ultra disks.</simpara>
</listitem>
<listitem>
<simpara>Add the following lines in the positions indicated:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <co xml:id="CO89-1"/>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <co xml:id="CO89-2"/></programlisting>
<calloutlist>
<callout arearefs="CO89-1">
<para>Specify a label to use to select a node that is created by this machine set. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO89-2">
<para>These lines enable the use of ultra disks.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a machine set using the updated configuration by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f &lt;machine-set-name&gt;.yaml</programlisting>
</listitem>
<listitem>
<simpara>Create a storage class that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ultra-disk-sc <co xml:id="CO90-1"/>
parameters:
  cachingMode: None
  diskIopsReadWrite: "2000" <co xml:id="CO90-2"/>
  diskMbpsReadWrite: "320" <co xml:id="CO90-3"/>
  kind: managed
  skuname: UltraSSD_LRS
provisioner: disk.csi.azure.com <co xml:id="CO90-4"/>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer <co xml:id="CO90-5"/></programlisting>
<calloutlist>
<callout arearefs="CO90-1">
<para>Specify the name of the storage class. This procedure uses <literal>ultra-disk-sc</literal> for this value.</para>
</callout>
<callout arearefs="CO90-2">
<para>Specify the number of IOPS for the storage class.</para>
</callout>
<callout arearefs="CO90-3">
<para>Specify the throughput in MBps for the storage class.</para>
</callout>
<callout arearefs="CO90-4">
<para>For Azure Kubernetes Service (AKS) version 1.21 or later, use <literal>disk.csi.azure.com</literal>. For earlier versions of AKS, use <literal>kubernetes.io/azure-disk</literal>.</para>
</callout>
<callout arearefs="CO90-5">
<para>Optional: Specify this parameter to wait for the creation of the pod that will use the disk.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a persistent volume claim (PVC) to reference the <literal>ultra-disk-sc</literal> storage class that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ultra-disk <co xml:id="CO91-1"/>
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: ultra-disk-sc <co xml:id="CO91-2"/>
  resources:
    requests:
      storage: 4Gi <co xml:id="CO91-3"/></programlisting>
<calloutlist>
<callout arearefs="CO91-1">
<para>Specify the name of the PVC. This procedure uses <literal>ultra-disk</literal> for this value.</para>
</callout>
<callout arearefs="CO91-2">
<para>This PVC references the <literal>ultra-disk-sc</literal> storage class.</para>
</callout>
<callout arearefs="CO91-3">
<para>Specify the size for the storage class. The minimum value is <literal>4Gi</literal>.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create a pod that contains the following YAML definition:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: nginx-ultra
spec:
  nodeSelector:
    disk: ultrassd <co xml:id="CO92-1"/>
  containers:
  - name: nginx-ultra
    image: alpine:latest
    command:
      - "sleep"
      - "infinity"
    volumeMounts:
    - mountPath: "/mnt/azure"
      name: volume
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: ultra-disk <co xml:id="CO92-2"/></programlisting>
<calloutlist>
<callout arearefs="CO92-1">
<para>Specify the label of the machine set that enables the use of ultra disks. This procedure uses <literal>disk.ultrassd</literal> for this value.</para>
</callout>
<callout arearefs="CO92-2">
<para>This pod references the <literal>ultra-disk</literal> PVC.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Verification</title>
<listitem>
<simpara>Validate that the machines are created by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get machines</programlisting>
<simpara>The machines should be in the <literal>Running</literal> state.</simpara>
</listitem>
<listitem>
<simpara>For a machine that is running and has a node attached, validate the partition by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</programlisting>
<simpara>In this command, <literal>oc debug node/&lt;node-name&gt;</literal> starts a debugging shell on the node <literal>&lt;node-name&gt;</literal> and passes a command with <literal>--</literal>. The passed command <literal>chroot /host</literal> provides access to the underlying host OS binaries, and <literal>lsblk</literal> shows the block devices that are attached to the host OS machine.</simpara>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara>To use an ultra disk from within a pod, create a workload that uses the mount point. Create a YAML file similar to the following example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: Pod
metadata:
  name: ssd-benchmark1
spec:
  containers:
  - name: ssd-benchmark1
    image: nginx
    ports:
      - containerPort: 80
        name: "http-server"
    volumeMounts:
    - name: lun0p1
      mountPath: "/tmp"
  volumes:
    - name: lun0p1
      hostPath:
        path: /var/lib/lun0p1
        type: DirectoryOrCreate
  nodeSelector:
    disktype: ultrassd</programlisting>
</listitem>
</itemizedlist>
</section>
<section xml:id="machineset-troubleshooting-azure-ultra-disk_persistent-storage-csi-azure">
<title>Troubleshooting resources for machine sets that enable ultra disks</title>
<simpara>Use the information in this section to understand and recover from issues you might encounter.</simpara>
<section xml:id="ts-pvc-mounting-ultra_persistent-storage-csi-azure">
<title>Unable to mount a persistent volume claim backed by an ultra disk</title>
<simpara>If there is an issue mounting a persistent volume claim backed by an ultra disk, the pod becomes stuck in the <literal>ContainerCreating</literal> state and an alert is triggered.</simpara>
<simpara>For example, if the <literal>additionalCapabilities.ultraSSDEnabled</literal> parameter is not set on the machine that backs the node that hosts the pod, the following error message appears:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</programlisting>
<itemizedlist>
<listitem>
<simpara>To resolve this issue, describe the pod by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc -n &lt;stuck_pod_namespace&gt; describe pod &lt;stuck_pod_name&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="additional-resources_persistent-storage-csi-azure" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-using-azure">Persistent storage using Azure Disk</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-azure-file">
<title>Azure File CSI Driver Operator</title>

<section xml:id="_overview-5">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) by using the Container Storage Interface (CSI) driver for Microsoft Azure File Storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to Azure File storage assets, OpenShift Container Platform installs the Azure File CSI Driver Operator and the Azure File CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Azure File CSI Driver Operator</emphasis> provides a storage class that is named <literal>azurefile-csi</literal> that you can use to create persistent volume claims (PVCs). You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Azure File CSI driver</emphasis> enables you to create and mount Azure File PVs. The Azure File CSI driver supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage.</simpara>
</listitem>
</itemizedlist>
<simpara>Azure File CSI Driver Operator does <emphasis>not</emphasis> support:</simpara>
<itemizedlist>
<listitem>
<simpara>Virtual hard disks (VHD)</simpara>
</listitem>
<listitem>
<simpara>Running on nodes with Federal Information Processing Standard (FIPS) mode enabled for Server Message Block (SMB) file share. However, Network File System (NFS) does support FIPS mode.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information about supported features, see <link linkend="csi-drivers-supported_persistent-storage-csi">Supported CSI drivers and features</link>.</simpara>
</section>
<section xml:id="persistent-storage-csi-azure-file-nfs_persistent-storage-csi-azure-file">
<title>NFS support</title>
<simpara>OpenShift Container Platform supports the Azure File Container Storage Interface (CSI) Driver Operator with Network File System (NFS) with the following restrictions:</simpara>
<itemizedlist>
<listitem>
<simpara>Creating pods with Azure File NFS volumes that are scheduled to the control plane node causes the mount to be denied.</simpara>
<simpara>To work around this issue: If your control plane nodes are schedulable, and the pods can run on worker nodes, use <literal>nodeSelector</literal> or Affinity to schedule the pod in worker nodes.</simpara>
</listitem>
<listitem>
<simpara>FS Group policy behavior:</simpara>
<important>
<simpara>Azure File CSI with NFS does not honor the <literal>fsGroupChangePolicy</literal> requested by pods. Azure File CSI with NFS applies a default <literal>OnRootMismatch</literal> FS Group policy regardless of the policy requested by the pod.</simpara>
</important>
</listitem>
<listitem>
<simpara>The Azure File CSI Operator does not automatically create a storage class for NFS. You must create it manually. Use a file similar to the following:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO93-1"/>
provisioner: file.csi.azure.com <co xml:id="CO93-2"/>
parameters:
  protocol: nfs <co xml:id="CO93-3"/>
  skuName: Premium_LRS  # available values: Premium_LRS, Premium_ZRS
mountOptions:
  - nconnect=4</programlisting>
<calloutlist>
<callout arearefs="CO93-1">
<para>Storage class name.</para>
</callout>
<callout arearefs="CO93-2">
<para>Specifies the Azure File CSI provider.</para>
</callout>
<callout arearefs="CO93-3">
<para>Specifies NFS as the storage backend protocol.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-azure-file">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-using-azure-file">Persistent storage using Azure File</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-azure-stack-hub">
<title>Azure Stack Hub CSI Driver Operator</title>

<section xml:id="_overview-6">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Azure Stack Hub Storage. Azure Stack Hub, which is part of the Azure Stack portfolio, allows you to run apps in an on-premises environment and deliver Azure services in your datacenter.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to Azure Stack Hub storage assets, OpenShift Container Platform installs the Azure Stack Hub CSI Driver Operator and the Azure Stack Hub CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Azure Stack Hub CSI Driver Operator</emphasis> provides a storage class (<literal>managed-csi</literal>), with "Standard_LRS" as the default storage account type, that you can use to create persistent volume claims (PVCs). The Azure Stack Hub CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Azure Stack Hub CSI driver</emphasis> enables you to create and mount Azure Stack Hub PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-azure-stack-hub">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="_additional-resources-2" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-gcp-pd">
<title>GCP PD CSI Driver Operator</title>

<section xml:id="_overview-7">
<title>Overview</title>
<simpara>OpenShift Container Platform can provision persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Google Cloud Platform (GCP) persistent disk (PD) storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a Container Storage Interface (CSI) Operator and driver.</simpara>
<simpara>To create CSI-provisioned persistent volumes (PVs) that mount to GCP PD storage assets, OpenShift Container Platform installs the GCP PD CSI Driver Operator and the GCP PD CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">GCP PD CSI Driver Operator</emphasis>: By default, the Operator provides a storage class that you can use to create PVCs. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>). You also have the option to create the GCP PD storage class as described in <link linkend="persistent-storage-using-gce">Persistent storage using GCE Persistent Disk</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">GCP PD driver</emphasis>: The driver enables you to create and mount GCP PD PVs.</simpara>
</listitem>
</itemizedlist>
<important>
<simpara>OpenShift Container Platform defaults to using the CSI plugin to provision GCP PD storage.</simpara>
</important>
</section>
<section xml:id="csi-about_persistent-storage-csi-gcp-pd">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-csi-gcp-pd-storage-class-ref_persistent-storage-csi-gcp-pd">
<title>GCP PD CSI driver storage class parameters</title>
<simpara>The Google Cloud Platform (GCP) persistent disk (PD) Container Storage Interface (CSI) driver uses the CSI <literal>external-provisioner</literal> sidecar as a controller. This is a separate helper container that is deployed with the CSI driver. The sidecar manages persistent volumes (PVs) by triggering the <literal>CreateVolume</literal> operation.</simpara>
<simpara>The GCP PD CSI driver uses the <literal>csi.storage.k8s.io/fstype</literal> parameter key to support dynamic provisioning. The following table describes all the GCP PD CSI storage class parameters that are supported by OpenShift Container Platform.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>CreateVolume Parameters</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="18.1818*"/>
<colspec colname="col_2" colwidth="27.2727*"/>
<colspec colname="col_3" colwidth="18.1818*"/>
<colspec colname="col_4" colwidth="36.3637*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Values</entry>
<entry align="left" valign="top">Default</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>type</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pd-ssd</literal> or <literal>pd-standard</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>pd-standard</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows you to choose between standard PVs or solid-state-drive PVs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>replication-type</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal> or <literal>regional-pd</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows you to choose between zonal or regional PVs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>disk-encryption-kms-key</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Fully qualified resource identifier for the key to use to encrypt new disks.</simpara></entry>
<entry align="left" valign="top"><simpara>Empty string</simpara></entry>
<entry align="left" valign="top"><simpara>Uses customer-managed encryption keys (CMEK) to encrypt new disks.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="persistent-storage-csi-gcp-pd-encrypted-pv_persistent-storage-csi-gcp-pd">
<title>Creating a custom-encrypted persistent volume</title>
<simpara>When you create a <literal>PersistentVolumeClaim</literal> object, OpenShift Container Platform provisions a new persistent volume (PV) and creates a <literal>PersistentVolume</literal> object. You can add a custom encryption key in Google Cloud Platform (GCP) to protect a PV in your cluster by encrypting the newly created PV.</simpara>
<simpara>For encryption, the newly attached PV that you create uses customer-managed encryption keys (CMEK) on a cluster by using a new or existing Google Cloud Key Management Service (KMS) key.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to a running OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>You have created a Cloud KMS key ring and key version.</simpara>
</listitem>
</itemizedlist>
<simpara>For more information about CMEK and Cloud KMS resources, see <link xlink:href="https://cloud.google.com/kubernetes-engine/docs/how-to/using-cmek">Using customer-managed encryption keys (CMEK)</link>.</simpara>
<formalpara>
<title>Procedure</title>
<para>To create a custom-encrypted PV, complete the following steps:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a storage class with the Cloud KMS key. The following example enables dynamic provisioning of encrypted volumes:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: csi-gce-pd-cmek
provisioner: pd.csi.storage.gke.io
volumeBindingMode: "WaitForFirstConsumer"
allowVolumeExpansion: true
parameters:
  type: pd-standard
  disk-encryption-kms-key: projects/&lt;key-project-id&gt;/locations/&lt;location&gt;/keyRings/&lt;key-ring&gt;/cryptoKeys/&lt;key&gt; <co xml:id="CO94-1"/></programlisting>
<calloutlist>
<callout arearefs="CO94-1">
<para>This field must be the resource identifier for the key that will be used to encrypt new disks. Values are case-sensitive. For more information about providing key ID values, see <link xlink:href="https://cloud.google.com/kms/docs/resource-hierarchy#retrieve_resource_id">Retrieving a resource&#8217;s ID</link> and <link xlink:href="https://cloud.google.com/kms/docs/getting-resource-ids">Getting a Cloud KMS resource ID</link>.</para>
</callout>
</calloutlist>
<note>
<simpara>You cannot add the <literal>disk-encryption-kms-key</literal> parameter to an existing storage class. However, you can delete the storage class and recreate it with the same name and a different set of parameters. If you do this, the provisioner of the existing class must be <literal>pd.csi.storage.gke.io</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Deploy the storage class on your OpenShift Container Platform cluster using the <literal>oc</literal> command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe storageclass csi-gce-pd-cmek</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">Name:                  csi-gce-pd-cmek
IsDefaultClass:        No
Annotations:           None
Provisioner:           pd.csi.storage.gke.io
Parameters:            disk-encryption-kms-key=projects/key-project-id/locations/location/keyRings/ring-name/cryptoKeys/key-name,type=pd-standard
AllowVolumeExpansion:  true
MountOptions:          none
ReclaimPolicy:         Delete
VolumeBindingMode:     WaitForFirstConsumer
Events:                none</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Create a file named <literal>pvc.yaml</literal> that matches the name of your storage class object that you created in the previous step:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: podpvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: csi-gce-pd-cmek
  resources:
    requests:
      storage: 6Gi</programlisting>
<note>
<simpara>If you marked the new storage class as default, you can omit the <literal>storageClassName</literal> field.</simpara>
</note>
</listitem>
<listitem>
<simpara>Apply the PVC on your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc apply -f pvc.yaml</programlisting>
</listitem>
<listitem>
<simpara>Get the status of your PVC and verify that it is created and bound to a newly provisioned PV:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME      STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS     AGE
podpvc    Bound     pvc-e36abf50-84f3-11e8-8538-42010a800002   10Gi       RWO            csi-gce-pd-cmek  9s</programlisting>
</para>
</formalpara>
<note>
<simpara>If your storage class has the <literal>volumeBindingMode</literal> field set to <literal>WaitForFirstConsumer</literal>, you must create a pod to use the PVC before you can verify it.</simpara>
</note>
</listitem>
</orderedlist>
<simpara>Your CMEK-protected PV is now ready to use with your OpenShift Container Platform cluster.</simpara>
</section>
<section xml:id="byok_persistent-storage-csi-gcp-pd">
<title>User-managed encryption</title>
<simpara>The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <literal>platform.&lt;cloud_type&gt;.defaultMachinePlatform</literal> field in the install-config YAML file.</simpara>
<simpara>This features supports the following storage types:</simpara>
<itemizedlist>
<listitem>
<simpara>Amazon Web Services (AWS) Elastic Block storage (EBS)</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure Disk storage</simpara>
</listitem>
<listitem>
<simpara>Google Cloud Platform (GCP) persistent disk (PD) storage</simpara>
</listitem>
<listitem>
<simpara>IBM Virtual Private Cloud (VPC) Block storage</simpara>
</listitem>
</itemizedlist>
<simpara>For information about installing with user-managed encryption for GCP PD, see <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-configuration-parameters_installing-gcp-customizations">Installation configuration parameters</link>.</simpara>
</section>
<section xml:id="_additional-resources-3" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-using-gce">Persistent storage using GCE Persistent Disk</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-google-cloud-file">
<title>Google Compute Platform Filestore CSI Driver Operator</title>

<section xml:id="persistent-storage-csi-google-cloud-file-overview">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Google Compute Platform (GCP) Filestore Storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to GCP Filestore Storage assets, you install the GCP Filestore CSI Driver Operator and the GCP Filestore CSI driver in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>GCP Filestore CSI Driver Operator</emphasis> does not provide a storage class by default, but <link linkend="persistent-storage-csi-google-cloud-file-create-sc_persistent-storage-csi-google-cloud-file">you can create one if needed</link>. The GCP Filestore CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>GCP Filestore CSI driver</emphasis> enables you to create and mount GCP Filestore PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-google-cloud-file">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-csi-olm-operator-install_persistent-storage-csi-google-cloud-file">
<title>Installing the GCP Filestore CSI Driver Operator</title>
<simpara>The Google Compute Platform (GCP) Filestore Container Storage Interface (CSI) Driver Operator is not installed in OpenShift Container Platform by default. Use the following procedure to install the GCP Filestore CSI Driver Operator in your cluster.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the GCP Filestore CSI Driver Operator from the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Enable the Filestore API in the GCE project by running the following command:</simpara>
<programlisting language="command" linenumbering="unnumbered">$ gcloud services enable file.googleapis.com  --project &lt;my_gce_project&gt; <co xml:id="CO95-1"/></programlisting>
<calloutlist>
<callout arearefs="CO95-1">
<para>Replace <literal>&lt;my_gce_project&gt;</literal> with your Google Cloud project.</para>
</callout>
</calloutlist>
<simpara>You can also do this using Google Cloud web console.</simpara>
</listitem>
<listitem>
<simpara>Install the GCP Filestore CSI Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> &#8594; <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Locate the GCP Filestore CSI Operator by typing <emphasis role="strong">GCP Filestore</emphasis> in the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">GCP Filestore CSI Driver Operator</emphasis> button.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">GCP Filestore CSI Driver Operator</emphasis> page, click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">All namespaces on the cluster (default)</emphasis> is selected.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installed Namespace</emphasis> is set to <emphasis role="strong">openshift-cluster-csi-drivers</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
<simpara>After the installation finishes, the GCP Filestore CSI Operator is listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Install the GCP Filestore CSI Driver:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">administration</emphasis> → <emphasis role="strong">CustomResourceDefinitions</emphasis> → <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, click <emphasis role="strong">Create ClusterCSIDriver</emphasis>.</simpara>
<simpara>Use the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: filestore.csi.storage.gke.io
spec:
  managementState: Managed</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Wait for the following Conditions to change to a "true" status:</simpara>
<itemizedlist>
<listitem>
<simpara>GCPFilestoreDriverCredentialsRequestControllerAvailable</simpara>
</listitem>
<listitem>
<simpara>GCPFilestoreDriverNodeServiceControllerAvailable</simpara>
</listitem>
<listitem>
<simpara>GCPFilestoreDriverControllerServiceControllerAvailable</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://cloud.google.com/endpoints/docs/openapi/enable-api">Enabling an API in your Google Cloud</link>.</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://support.google.com/googleapi/answer/6158841?hl=en">Enabling an API using the Google Cloud web console</link>.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-google-cloud-file-create-sc_persistent-storage-csi-google-cloud-file">
<title>Creating a storage class for GCP Filestore Storage</title>
<simpara>After installing the Operator, you should create a storage class for dynamic provisioning of Google Compute Platform (GCP) Filestore volumes.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>You are logged in to the running OpenShift Container Platform cluster.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To create a storage class:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create a storage class using the following example YAML file:</simpara>
<formalpara>
<title>Example YAML file</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: filestore-csi
provisioner: filestore.csi.storage.gke.io
parameters:
  connect-mode: DIRECT_PEERING <co xml:id="CO96-1"/>
  network: network-name <co xml:id="CO96-2"/>
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO96-1">
<para>For a shared VPC, use the <literal>connect-mode</literal> parameter set to <literal>PRIVATE_SERVICE_ACCESS</literal>. For a non-shared VPC, the value is <literal>DIRECT_PEERING</literal>, which is the default setting.</para>
</callout>
<callout arearefs="CO96-2">
<para>Specify the name of the GCP virtual private cloud (VPC) network where Filestore instances should be created in.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Specify the name of the VPC network where Filestore instances should be created in.</simpara>
<simpara>It is recommended to specify the VPC network that the Filestore instances should be created in. If no VPC network is specified, the Container Storage Interface (CSI) driver tries to create the instances in the default VPC network of the project.</simpara>
<simpara>On IPI installations, the VPC network name is typically the cluster name with the suffix "-network". However, on UPI installations, the VPC network name can be any value chosen by the user.</simpara>
<simpara>For a shared VPC (<literal>connect-mode</literal> = <literal>PRIVATE_SERVICE_ACCESS</literal>), the network needs to be the full VPC name. For example: <literal>projects/shared-vpc-name/global/networks/gcp-filestore-network</literal>.</simpara>
<simpara>You can find out the VPC network name by inspecting the <literal>MachineSets</literal> objects with the following command:</simpara>
<programlisting language="command" linenumbering="unnumbered">$ oc -n openshift-machine-api get machinesets -o yaml | grep "network:"
            - network: gcp-filestore-network
(...)</programlisting>
<simpara>In this example, the VPC network name in this cluster is "gcp-filestore-network".</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-csi-gcp-cloud-file-delete-instances_persistent-storage-csi-google-cloud-file">
<title>Destroying clusters and GCP Filestore</title>
<simpara>Typically, if you destroy a cluster, the OpenShift Container Platform installer deletes all of the cloud resources that belong to that cluster. However, when a cluster is destroyed, Google Compute Platform (GCP) Filestore instances are not automatically deleted, so you must manually delete all persistent volume claims (PVCs) that use the Filestore storage class before destroying the cluster.</simpara>
<formalpara>
<title>Procedure</title>
<para>To delete all GCP Filestore PVCs:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List all PVCs that were created using the storage class <literal>filestore-csi</literal>:</simpara>
<programlisting language="command" linenumbering="unnumbered">$ oc get pvc -o json -A | jq -r '.items[] | select(.spec.storageClassName == "filestore-csi")</programlisting>
</listitem>
<listitem>
<simpara>Delete all of the PVCs listed by the previous command:</simpara>
<programlisting language="command" linenumbering="unnumbered">$ oc delete &lt;pvc-name&gt; <co xml:id="CO97-1"/></programlisting>
<calloutlist>
<callout arearefs="CO97-1">
<para>Replace &lt;pvc-name&gt; with the name of any PVC that you need to delete.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional-resources-4" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-ibm-vpc-block">
<title>IBM VPC Block CSI Driver Operator</title>

<section xml:id="_overview-8">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for IBM&#174; Virtual Private Cloud (VPC) Block Storage.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to IBM&#174; VPC Block storage assets, OpenShift Container Platform installs the IBM&#174; VPC Block CSI Driver Operator and the IBM&#174; VPC Block CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>IBM&#174; VPC Block CSI Driver Operator</emphasis> provides three storage classes named <literal>ibmc-vpc-block-10iops-tier</literal> (default), <literal>ibmc-vpc-block-5iops-tier</literal>, and <literal>ibmc-vpc-block-custom</literal> for different tiers that you can use to create persistent volume claims (PVCs). The IBM&#174; VPC Block CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>IBM&#174; VPC Block CSI driver</emphasis> enables you to create and mount IBM&#174; VPC Block PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-ibm-vpc-block">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="byok_persistent-storage-csi-ibm-vpc-block">
<title>User-managed encryption</title>
<simpara>The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <literal>platform.&lt;cloud_type&gt;.defaultMachinePlatform</literal> field in the install-config YAML file.</simpara>
<simpara>This features supports the following storage types:</simpara>
<itemizedlist>
<listitem>
<simpara>Amazon Web Services (AWS) Elastic Block storage (EBS)</simpara>
</listitem>
<listitem>
<simpara>Microsoft Azure Disk storage</simpara>
</listitem>
<listitem>
<simpara>Google Cloud Platform (GCP) persistent disk (PD) storage</simpara>
</listitem>
<listitem>
<simpara>IBM Virtual Private Cloud (VPC) Block storage</simpara>
</listitem>
</itemizedlist>
<simpara>For information about installing with user-managed encryption for IBM VPC, see link:https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/<emphasis role="marked">[User-managed encryption for IBM Cloud] and <link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/</emphasis>">Preparing to install on IBM Cloud</link>.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-ibm-powervs-block">
<title>IBM Power Virtual Server Block CSI Driver Operator</title>

<section xml:id="persistent-storage-csi-ibm-powervs-block-introduction_persistent-storage-csi-ibm-powervs-block">
<title>Introduction</title>
<simpara>The IBM Power&#174; Virtual Server Block CSI Driver will be installed through IBM Power&#174; Virtual Server Block CSI Driver Operator and the operator is based on libarary-go. The OpenShift library-go is a collection of functions that allow us to build OpenShift operators easily. Most of the functionality of a CSI driver operator is already available there. The IBM Power&#174; Virtual Server Block CSI Driver Operator is installed by the cluster-storage-operator. The Cluster-storage-operator installs the IBM Power&#174; Virtual Server Block CSI Driver Operator if the Platform type is Power Virtual Servers.</simpara>
</section>
<section xml:id="persistent-storage-csi-ibm-powervs-block-overview_persistent-storage-csi-ibm-powervs-block">
<title>Overview</title>
<simpara>OpenShift Container Platform can provision persistent volumes (PVs) by using the Container Storage Interface (CSI) driver for IBM Power&#174; Virtual Server Block Storage.</simpara>
<important>
<simpara>IBM Power Virtual Server Block CSI Driver Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is helpful when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to IBM Power&#174; Virtual Server Block storage assets, OpenShift Container Platform installs the IBM Power&#174; Virtual Server Block CSI Driver Operator and the IBM Power&#174; Virtual Server Block CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>IBM Power&#174; Virtual Server Block CSI Driver Operator</emphasis> provides two storage classes named <literal>ibm-powervs-tier1</literal> (default), and <literal>ibm-powervs-tier3</literal> for different tiers that you can use to create persistent volume claims (PVCs). The IBM Power&#174; Virtual Server Block CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>IBM Power&#174; Virtual Server Block CSI driver</emphasis> allows you to create and mount IBM Power&#174; Virtual Server Block PVs.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-ibm-powervs-block">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-cinder">
<title>OpenStack Cinder CSI Driver Operator</title>

<section xml:id="_overview-9">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for OpenStack Cinder.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a Container Storage Interface (CSI) Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to OpenStack Cinder storage assets, OpenShift Container Platform installs the OpenStack Cinder CSI Driver Operator and the OpenStack Cinder CSI driver in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>OpenStack Cinder CSI Driver Operator</emphasis> provides a CSI storage class that you can use to create PVCs. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>OpenStack Cinder CSI driver</emphasis> enables you to create and mount OpenStack Cinder PVs.</simpara>
</listitem>
</itemizedlist>
<simpara>For OpenShift Container Platform, automatic migration from OpenStack Cinder in-tree to the CSI driver is available as a Technology Preview (TP) feature.
With migration enabled, volumes provisioned using the existing in-tree plugin are automatically migrated to use the OpenStack Cinder CSI driver. For more information, see <link linkend="persistent-storage-csi-migration">CSI automatic migration feature</link>.</simpara>
</section>
<section xml:id="csi-about_persistent-storage-csi-cinder">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
<important>
<simpara>OpenShift Container Platform defaults to using the CSI plugin to provision Cinder storage.</simpara>
</important>
</section>
<section xml:id="persistent-storage-csi-cinder_persistent-storage-csi-cinder">
<title>Making OpenStack Cinder CSI the default storage class</title>
<simpara>The OpenStack Cinder CSI driver uses the <literal>cinder.csi.openstack.org</literal> parameter key to support dynamic provisioning.</simpara>
<simpara>To enable OpenStack Cinder CSI provisioning in OpenShift Container Platform, it is recommended that you overwrite the default in-tree storage class with <literal>standard-csi</literal>. Alternatively, you can create the persistent volume claim (PVC) and specify the storage class as "standard-csi".</simpara>
<simpara>In OpenShift Container Platform, the default storage class references the in-tree Cinder driver. However, with CSI automatic migration enabled, volumes created using the default storage class actually use the CSI driver.</simpara>
<formalpara>
<title>Procedure</title>
<para>Use the following steps to apply the <literal>standard-csi</literal> storage class by overwriting the default in-tree storage class.</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the storage class:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
standard(default)      cinder.csi.openstack.org   Delete          WaitForFirstConsumer   true                   46h
standard-csi           kubernetes.io/cinder       Delete          WaitForFirstConsumer   true                   46h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Change the value of the annotation <literal>storageclass.kubernetes.io/is-default-class</literal> to <literal>false</literal> for the default storage class, as shown in the following example:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Make another storage class the default by adding or modifying the annotation as <literal>storageclass.kubernetes.io/is-default-class=true</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass standard-csi -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Verify that the PVC is now referencing the CSI storage class by default:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                   PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
standard               kubernetes.io/cinder       Delete          WaitForFirstConsumer   true                   46h
standard-csi(default)  cinder.csi.openstack.org   Delete          WaitForFirstConsumer   true                   46h</programlisting>
</para>
</formalpara>
</listitem>
<listitem>
<simpara>Optional: You can define a new PVC without having to specify the storage class:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: cinder-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi</programlisting>
<simpara>A PVC that does not specify a specific storage class is automatically provisioned by using the default storage class.</simpara>
</listitem>
<listitem>
<simpara>Optional: After the new file has been configured, create it in your cluster:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f cinder-claim.yaml</programlisting>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-manila">
<title>OpenStack Manila CSI Driver Operator</title>

<section xml:id="_overview-10">
<title>Overview</title>
<simpara>OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for the <link xlink:href="https://wiki.openstack.org/wiki/Manila">OpenStack Manila</link> shared file system service.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a Container Storage Interface (CSI) Operator and driver.</simpara>
<simpara>To create CSI-provisioned PVs that mount to Manila storage assets, OpenShift Container Platform installs the Manila CSI Driver Operator and the Manila CSI driver by default on any OpenStack cluster that has the Manila service enabled.</simpara>
<itemizedlist>
<listitem>
<simpara>The <emphasis>Manila CSI Driver Operator</emphasis> creates the required storage class that is needed to create PVCs for all available Manila share types. The Operator is installed in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
</listitem>
<listitem>
<simpara>The <emphasis>Manila CSI driver</emphasis> enables you to create and mount Manila PVs. The driver is installed in the <literal>openshift-manila-csi-driver</literal> namespace.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="csi-about_persistent-storage-csi-manila">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-csi-manila-limitations_persistent-storage-csi-manila">
<title>Manila CSI Driver Operator limitations</title>
<simpara>The following limitations apply to the Manila Container Storage Interface (CSI) Driver Operator:</simpara>
<variablelist>
<varlistentry>
<term>Only NFS is supported</term>
<listitem>
<simpara>OpenStack Manila supports many network-attached storage protocols, such as NFS, CIFS, and CEPHFS, and these can be selectively enabled in the OpenStack cloud. The Manila CSI Driver Operator in OpenShift Container Platform only supports using the NFS protocol. If NFS is not available and enabled in the underlying OpenStack cloud, you cannot use the Manila CSI Driver Operator to provision storage for OpenShift Container Platform.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>Snapshots are not supported if the back end is CephFS-NFS</term>
<listitem>
<simpara>To take snapshots of persistent volumes (PVs) and revert volumes to snapshots, you must ensure that the Manila share type that you are using supports these features. A Red Hat OpenStack administrator must enable support for snapshots (<literal>share type extra-spec snapshot_support</literal>) and for creating shares from snapshots (<literal>share type extra-spec create_share_from_snapshot_support</literal>) in the share type associated with the storage class you intend to use.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>FSGroups are not supported</term>
<listitem>
<simpara>Since Manila CSI provides shared file systems for access by multiple readers and multiple writers, it does not support the use of FSGroups. This is true even for persistent volumes created with the ReadWriteOnce access mode. It is therefore important not to specify the <literal>fsType</literal> attribute in any storage class that you manually create for use with Manila CSI Driver.</simpara>
</listitem>
</varlistentry>
</variablelist>
<important>
<simpara>In Red Hat OpenStack Platform 16.x and 17.x, the Shared File Systems service (Manila) with CephFS through NFS fully supports serving shares to OpenShift Container Platform through the Manila CSI. However, this solution is not intended for massive scale. Be sure to review important recommendations in <link xlink:href="https://access.redhat.com/articles/6667651">CephFS NFS Manila-CSI Workload Recommendations for Red Hat OpenStack Platform</link>.</simpara>
</important>
</section>
<section xml:id="persistent-storage-csi-manila-dynamic-provisioning_persistent-storage-csi-manila">
<title>Dynamically provisioning Manila CSI volumes</title>
<simpara>OpenShift Container Platform installs a storage class for each available Manila share type.</simpara>
<simpara>The YAML files that are created are completely decoupled from Manila and from its Container Storage Interface (CSI) plugin. As an application developer, you can dynamically provision ReadWriteMany (RWX) storage and deploy pods with applications that safely consume the storage using YAML manifests.</simpara>
<simpara>You can use the same pod and persistent volume claim (PVC) definitions on-premise that you use with OpenShift Container Platform on AWS, GCP, Azure, and other platforms, with the exception of the storage class reference in the PVC definition.</simpara>
<note>
<simpara>Manila service is optional. If the service is not enabled in Red Hat OpenStack Platform (RHOSP), the Manila CSI driver is not installed and the storage classes for Manila are not created.</simpara>
</note>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>RHOSP is deployed with appropriate Manila share infrastructure so that it can be used to dynamically provision and mount volumes in OpenShift Container Platform.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure (UI)</title>
<para>To dynamically create a Manila CSI volume using the web console:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the OpenShift Container Platform console, click <emphasis role="strong">Storage</emphasis> → <emphasis role="strong">Persistent Volume Claims</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the persistent volume claims overview, click <emphasis role="strong">Create Persistent Volume Claim</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Define the required options on the resulting page.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select the appropriate storage class.</simpara>
</listitem>
<listitem>
<simpara>Enter a unique name for the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Select the access mode to specify read and write access for the PVC you are creating.</simpara>
<important>
<simpara>Use RWX if you want the persistent volume (PV) that fulfills this PVC to be mounted to multiple pods on multiple nodes in the cluster.</simpara>
</important>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Define the size of the storage claim.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis> to create the persistent volume claim and generate a persistent volume.</simpara>
</listitem>
</orderedlist>
<formalpara>
<title>Procedure (CLI)</title>
<para>To dynamically create a Manila CSI volume using the command-line interface (CLI):</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create and save a file with the <literal>PersistentVolumeClaim</literal> object described by the following YAML:</simpara>
<formalpara>
<title>pvc-manila.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-manila
spec:
  accessModes: <co xml:id="CO98-1"/>
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
  storageClassName: csi-manila-gold <co xml:id="CO98-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO98-1">
<para>Use RWX if you want the persistent volume (PV) that fulfills this PVC to be mounted to multiple pods on multiple nodes in the cluster.</para>
</callout>
<callout arearefs="CO98-2">
<para>The name of the storage class that provisions the storage back end. Manila storage classes are provisioned by the Operator and have the <literal>csi-manila-</literal> prefix.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Create the object you saved in the previous step by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc create -f pvc-manila.yaml</programlisting>
<simpara>A new PVC is created.</simpara>
</listitem>
<listitem>
<simpara>To verify that the volume was created and is ready, run the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get pvc pvc-manila</programlisting>
<simpara>The <literal>pvc-manila</literal> shows that it is <literal>Bound</literal>.</simpara>
</listitem>
</orderedlist>
<simpara>You can now use the new PVC to configure a pod.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-secrets-store">
<title>Secrets Store CSI driver</title>

<section xml:id="persistent-storage-csi-secrets-store-driver-overview_persistent-storage-csi-secrets-store">
<title>Overview</title>
<simpara>Kubernetes secrets are stored with Base64 encoding. etcd provides encryption at rest for these secrets, but when secrets are retrieved, they are decrypted and presented to the user. If role-based access control is not configured properly on your cluster, anyone with API or etcd access can retrieve or modify a secret. Additionally, anyone who is authorized to create a pod in a namespace can use that access to read any secret in that namespace.</simpara>
<simpara>To store and manage your secrets securely, you can configure the OpenShift Container Platform Secrets Store Container Storage Interface (CSI) Driver Operator to mount secrets from an external secret management system, such as Azure Key Vault, by using a provider plugin. Applications can then use the secret, but the secret does not persist on the system after the application pod is destroyed.</simpara>
<simpara>The Secrets Store CSI Driver Operator, <literal>secrets-store.csi.k8s.io</literal>, enables OpenShift Container Platform to mount multiple secrets, keys, and certificates stored in enterprise-grade external secrets stores into pods as a volume. The Secrets Store CSI Driver Operator communicates with the provider using gRPC to fetch the mount contents from the specified external secrets store. After the volume is attached, the data in it is mounted into the container&#8217;s file system. Secrets store volumes are mounted in-line.</simpara>
<simpara>For more information about CSI inline volumes, see <link linkend="ephemeral-storage-csi-inline">CSI inline ephemeral volumes</link>.</simpara>
<important>
<simpara>The Secrets Store CSI Driver Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.</simpara>
<simpara>For more information about the support scope of Red Hat Technology Preview features, see <link xlink:href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</link>.</simpara>
</important>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI driver.</simpara>
<section xml:id="secrets-store-providers_persistent-storage-csi-secrets-store">
<title>Secrets store providers</title>
<simpara>The following secrets store providers are available for use with the Secrets Store CSI Driver Operator:</simpara>
<itemizedlist>
<listitem>
<simpara>AWS Secrets Manager</simpara>
</listitem>
<listitem>
<simpara>AWS Systems Manager Parameter Store</simpara>
</listitem>
<listitem>
<simpara>Azure Key Vault</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="csi-about_persistent-storage-csi-secrets-store">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-csi-secrets-store-driver-install_persistent-storage-csi-secrets-store">
<title>Installing the Secrets Store CSI driver</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Administrator access to the cluster.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To install the Secrets Store CSI driver:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Install the Secrets Store CSI Driver Operator:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Log in to the web console.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">OperatorHub</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Locate the Secrets Store CSI Driver Operator by typing "Secrets Store CSI" in the filter box.</simpara>
</listitem>
<listitem>
<simpara>Click the <emphasis role="strong">Secrets Store CSI Driver Operator</emphasis> button.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Secrets Store CSI Driver Operator</emphasis> page, click <emphasis role="strong">Install</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Install Operator</emphasis> page, ensure that:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">All namespaces on the cluster (default)</emphasis> is selected.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Installed Namespace</emphasis> is set to <emphasis role="strong">openshift-cluster-csi-drivers</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Install</emphasis>.</simpara>
<simpara>After the installation finishes, the Secrets Store CSI Driver Operator is listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the <literal>ClusterCSIDriver</literal> instance for the driver (<literal>secrets-store.csi.k8s.io</literal>):</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> &#8594; <emphasis role="strong">CustomResourceDefinitions</emphasis> &#8594; <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, click <emphasis role="strong">Create ClusterCSIDriver</emphasis>.</simpara>
<simpara>Use the following YAML file:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: secrets-store.csi.k8s.io
spec:
  managementState: Managed</programlisting>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist>
<title>Next steps</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/nodes/#mounting-secrets-external-secrets-store">Mounting secrets from an external secrets store to a CSI volume</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="persistent-storage-csi-secrets-store-driver-uninstall_persistent-storage-csi-secrets-store">
<title>Uninstalling the Secrets Store CSI Driver Operator</title>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the OpenShift Container Platform web console.</simpara>
</listitem>
<listitem>
<simpara>Administrator access to the cluster.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To uninstall the Secrets Store CSI Driver Operator:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Stop all application pods that use the <literal>secrets-store.csi.k8s.io</literal> provider.</simpara>
</listitem>
<listitem>
<simpara>Remove any third-party provider plug-in for your chosen secret store.</simpara>
</listitem>
<listitem>
<simpara>Remove the Container Storage Interface (CSI) driver and associated manifests:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Administration</emphasis> → <emphasis role="strong">CustomResourceDefinitions</emphasis> → <emphasis role="strong">ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Instances</emphasis> tab, for <emphasis role="strong">secrets-store.csi.k8s.io</emphasis>, on the far left side, click the drop-down menu, and then click <emphasis role="strong">Delete ClusterCSIDriver</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted, click <emphasis role="strong">Delete</emphasis>.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Verify that the CSI driver pods are no longer running.</simpara>
</listitem>
<listitem>
<simpara>Uninstall the Secrets Store CSI Driver Operator:</simpara>
<note>
<simpara>Before you can uninstall the Operator, you must remove the CSI driver first.</simpara>
</note>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Operators</emphasis> → <emphasis role="strong">Installed Operators</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Installed Operators</emphasis> page, scroll or type "Secrets Store CSI" into the <emphasis role="strong">Search by name</emphasis> box to find the Operator, and then click it.</simpara>
</listitem>
<listitem>
<simpara>On the upper, right of the <emphasis role="strong">Installed Operators</emphasis> &gt; <emphasis role="strong">Operator details</emphasis> page, click <emphasis role="strong">Actions</emphasis> → <emphasis role="strong">Uninstall Operator</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>When prompted on the <emphasis role="strong">Uninstall Operator</emphasis> window, click the <emphasis role="strong">Uninstall</emphasis> button to remove the Operator from the namespace. Any applications deployed by the Operator on the cluster need to be cleaned up manually.</simpara>
<simpara>After uninstalling, the Secrets Store CSI Driver Operator is no longer listed in the <emphasis role="strong">Installed Operators</emphasis> section of the web console.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
<section xml:id="_additional-resources-5" role="_additional-resources">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-vsphere">
<title>VMware vSphere CSI Driver Operator</title>

<section xml:id="_overview-11">
<title>Overview</title>
<simpara>OpenShift Container Platform can provision persistent volumes (PVs) using the Container Storage Interface (CSI) VMware vSphere driver for Virtual Machine Disk (VMDK) volumes.</simpara>
<simpara>Familiarity with <link linkend="understanding-persistent-storage">persistent storage</link> and <link linkend="persistent-storage-csi">configuring CSI volumes</link> is recommended when working with a CSI Operator and driver.</simpara>
<simpara>To create CSI-provisioned persistent volumes (PVs) that mount to vSphere storage assets, OpenShift Container Platform installs the vSphere CSI Driver Operator and the vSphere CSI driver by default in the <literal>openshift-cluster-csi-drivers</literal> namespace.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">vSphere CSI Driver Operator</emphasis>: The Operator provides a storage class, called <literal>thin-csi</literal>, that you can use to create persistent volumes claims (PVCs). The vSphere CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <link linkend="persistent-storage-csi-sc-manage">Managing the default storage class</link>).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">vSphere CSI driver</emphasis>: The driver enables you to create and mount vSphere PVs. In OpenShift Container Platform 4.15, the driver version is 3.0.2. The vSphere CSI driver supports all of the file systems supported by the underlying Red Hat Core OS release, including XFS and Ext4. For more information about supported file systems, see <link xlink:href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_file_systems/assembly_overview-of-available-file-systems_managing-file-systems">Overview of available file systems</link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>For new installations, OpenShift Container Platform 4.13 and later provides automatic migration for the vSphere in-tree volume plugin to its equivalent CSI driver. Updating to OpenShift Container Platform 4.15 and later also provides automatic migration. For more information about updating and migration, see <link linkend="persistent-storage-csi-migration">CSI automatic migration</link>.</simpara>
<simpara>CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes.</simpara>
</note>
<note>
<simpara>The vSphere CSI Driver supports dynamic and static provisioning. When using static provisioning in the PV specifications, do not use the key <literal>storage.kubernetes.io/csiProvisionerIdentity</literal> in <literal>csi.volumeAttributes</literal> because this key indicates dynamically provisioned PVs.</simpara>
</note>
</section>
<section xml:id="csi-about_persistent-storage-csi-vsphere">
<title>About CSI</title>
<simpara>Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.</simpara>
<simpara>CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.</simpara>
</section>
<section xml:id="persistent-storage-csi-vsphere-stor-policy_persistent-storage-csi-vsphere">
<title>vSphere storage policy</title>
<simpara>The vSphere CSI Driver Operator storage class uses vSphere&#8217;s storage policy. OpenShift Container Platform automatically creates a storage policy that targets datastore configured in cloud configuration:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: thin-csi
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: "$openshift-storage-policy-xxxx"
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: false
reclaimPolicy: Delete</programlisting>
</section>
<section xml:id="persistent-storage-csi-vsphere-rwx_persistent-storage-csi-vsphere">
<title>ReadWriteMany vSphere volume support</title>
<simpara>If the underlying vSphere environment supports the vSAN file service, then vSphere Container Storage Interface (CSI) Driver Operator installed by
OpenShift Container Platform supports provisioning of ReadWriteMany (RWX) volumes. If vSAN file service is not configured, then ReadWriteOnce (RWO) is the only access mode available. If you do not have vSAN file service configured, and you request RWX, the volume fails to get created and an error is logged.</simpara>
<simpara>For more information about configuring the vSAN file service in your environment, see <link xlink:href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vsan.doc/GUID-82565B82-C911-42F7-85B1-E9EF973EE90C.html">vSAN File Service</link>.</simpara>
<simpara>You can request RWX volumes by making the following persistent volume claim (PVC):</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  resources:
    requests:
      storage: 1Gi
  accessModes:
     - ReadWriteMany
  storageClassName: thin-csi</programlisting>
<simpara>Requesting a PVC of the RWX volume type should result in provisioning of persistent volumes (PVs) backed by the vSAN file service.</simpara>
</section>
<section xml:id="vsphere-csi-driver-reqs_persistent-storage-csi-vsphere">
<title>VMware vSphere CSI Driver Operator requirements</title>
<simpara>To install the vSphere Container Storage Interface (CSI) Driver Operator, the following requirements must be met:</simpara>
<itemizedlist>
<listitem>
<simpara>VMware vSphere version 7.0 Update 2 or later</simpara>
</listitem>
<listitem>
<simpara>vCenter 7.0 Update 2 or later</simpara>
</listitem>
<listitem>
<simpara>Virtual machines of hardware version 15 or later</simpara>
</listitem>
<listitem>
<simpara>No third-party vSphere CSI driver already installed in the cluster</simpara>
</listitem>
</itemizedlist>
<simpara>If a third-party vSphere CSI driver is present in the cluster, OpenShift Container Platform does not overwrite it. The presence of a third-party vSphere CSI driver prevents OpenShift Container Platform from updating to OpenShift Container Platform 4.13 or later.</simpara>
<note>
<simpara>The VMware vSphere CSI Driver Operator is supported only on clusters deployed with <literal>platform: vsphere</literal> in the installation manifest.</simpara>
</note>
<simpara>You can create a custom role for the Container Storage Interface (CSI) driver, the vSphere CSI Driver Operator, and the vSphere Problem Detector Operator. The custom role can include privilege sets that assign a minimum set of permissions to each vSphere object. This means that the CSI driver, the vSphere CSI Driver Operator, and the vSphere Problem Detector Operator can establish a basic interaction with these objects.</simpara>
<important>
<simpara>Installing an OpenShift Container Platform cluster in a vCenter is tested against a full list of privileges as described in the "Required vCenter account privileges" section. By adhering to the full list of privileges, you can reduce the possibility of unexpected and unsupported behaviors that might occur when creating a custom role with a set of restricted privileges.</simpara>
</important>
<simpara>To remove a third-party CSI driver, see <link linkend="persistent-storage-csi-vsphere-install-issues_persistent-storage-csi-vsphere">Removing a third-party vSphere CSI Driver</link>.</simpara>
</section>
<section xml:id="persistent-storage-csi-vsphere-install-issues_persistent-storage-csi-vsphere">
<title>Removing a third-party vSphere CSI Driver Operator</title>
<simpara>OpenShift Container Platform 4.10, and later, includes a built-in version of the vSphere Container Storage Interface (CSI) Operator Driver that is supported by Red Hat. If you have installed a vSphere CSI driver provided by the community or another vendor, updates to the next major version of OpenShift Container Platform, such as 4.13, or later, might be disabled for your cluster.</simpara>
<simpara>OpenShift Container Platform 4.12, and later, clusters are still fully supported, and updates to z-stream releases of 4.12, such as 4.12.z, are not blocked, but you must correct this state by removing the third-party vSphere CSI Driver before updates to next major version of OpenShift Container Platform can occur. Removing the third-party vSphere CSI driver does not require deletion of associated persistent volume (PV) objects, and no data loss should occur.</simpara>
<note>
<simpara>These instructions may not be complete, so consult the vendor or community provider uninstall guide to ensure removal of the driver and components.</simpara>
</note>
<simpara>To uninstall the third-party vSphere CSI Driver:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Delete the third-party vSphere CSI Driver (VMware vSphere Container Storage Plugin) Deployment and Daemonset objects.</simpara>
</listitem>
<listitem>
<simpara>Delete the configmap and secret objects that were installed previously with the third-party vSphere CSI Driver.</simpara>
</listitem>
<listitem>
<simpara>Delete the third-party vSphere CSI driver <literal>CSIDriver</literal> object:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">~ $ oc delete CSIDriver csi.vsphere.vmware.com</programlisting>
<programlisting language="terminal" linenumbering="unnumbered">csidriver.storage.k8s.io "csi.vsphere.vmware.com" deleted</programlisting>
</listitem>
</orderedlist>
<simpara>After you have removed the third-party vSphere CSI Driver from the OpenShift Container Platform cluster, installation of Red Hat&#8217;s vSphere CSI Driver Operator automatically resumes, and any conditions that could block upgrades to OpenShift Container Platform 4.11, or later, are automatically removed. If you had existing vSphere CSI PV objects, their lifecycle is now managed by Red Hat&#8217;s vSphere CSI Driver Operator.</simpara>
</section>
<section xml:id="vsphere-pv-encryption">
<title>vSphere persistent disks encryption</title>
<simpara>You can encrypt virtual machines (VMs) and dynamically provisioned persistent volumes (PVs) on OpenShift Container Platform running on top of vSphere.</simpara>
<note>
<simpara>OpenShift Container Platform does not support RWX-encrypted PVs. You cannot request RWX PVs out of a storage class that uses an encrypted storage policy.</simpara>
</note>
<simpara>You must encrypt VMs before you can encrypt PVs, which you can do during installation or postinstallation.</simpara>
<simpara>For information about encrypting VMs, see:</simpara>
<itemizedlist>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-vsphere-encrypted-vms_upi-vsphere-installation-reqs">Requirements for encrypting virtual machines</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#installation-vsphere-machines_installing-vsphere">During installation: Step 7 of Installing RHCOS and starting the OpenShift Container Platform bootstrap process</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/postinstallation_configuration/#">Postinstallation enabling encryption on a vSphere cluster</link></simpara>
</listitem>
</itemizedlist>
<simpara>After encrypting VMs, you can configure a storage class that supports dynamic encryption volume provisioning using the vSphere Container Storage Interface (CSI) driver. This can be accomplished in one of two ways using:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi-vsphere-encryption-datastore-url_persistent-storage-csi-vsphere">Datastore URL</link>: This approach is not very flexible, and forces you to use a single datastore. It also does not support topology-aware provisioning.</simpara>
</listitem>
<listitem>
<simpara><link linkend="persistent-storage-csi-vsphere-encryption-tag-based_persistent-storage-csi-vsphere">Tag-based placement</link>: Encrypts the provisioned volumes and uses tag-based placement to target specific datastores.</simpara>
</listitem>
</itemizedlist>
<section xml:id="persistent-storage-csi-vsphere-encryption-datastore-url_persistent-storage-csi-vsphere">
<title>Using datastore URL</title>
<formalpara>
<title>Procedure</title>
<para>To encrypt using the datastore URL:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Find out the name of the default storage policy in your datastore that supports encryption.</simpara>
<simpara>This is same policy that was used for encrypting your VMs.</simpara>
</listitem>
<listitem>
<simpara>Create a storage class that uses this storage policy:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
 name: encryption
provisioner: csi.vsphere.vmware.com
parameters:
 storagePolicyName: &lt;storage-policy-name&gt; <co xml:id="CO99-1"/>
 datastoreurl: "ds:///vmfs/volumes/vsan:522e875627d-b090c96b526bb79c/"</programlisting>
<calloutlist>
<callout arearefs="CO99-1">
<para>Name of default storage policy in your datastore that supports encryption</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
<section xml:id="persistent-storage-csi-vsphere-encryption-tag-based_persistent-storage-csi-vsphere">
<title>Using tag-based placement</title>
<formalpara>
<title>Procedure</title>
<para>To encrypt using tag-based placement:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>In vCenter create a category for tagging datastores that will be made available to this storage class. Also, ensure that <emphasis role="strong">StoragePod(Datastore clusters)</emphasis>, <emphasis role="strong">Datastore</emphasis>, and <emphasis role="strong">Folder</emphasis> are selected as Associable Entities for the created category.</simpara>
</listitem>
<listitem>
<simpara>In vCenter, create a tag that uses the category created earlier.</simpara>
</listitem>
<listitem>
<simpara>Assign the previously created tag to each datastore that will be made available to the storage class. Make sure that datastores are shared with hosts participating in the OpenShift Container Platform cluster.</simpara>
</listitem>
<listitem>
<simpara>In vCenter, from the main menu, click <emphasis role="strong">Policies and Profiles</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Policies and Profiles</emphasis> page, in the navigation pane, click <emphasis role="strong">VM Storage Policies</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">CREATE</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type a name for the storage policy.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Enable host based rules</emphasis> and <emphasis role="strong">Enable tag based placement rules</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>In the <emphasis role="strong">Next</emphasis> tab:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Select <emphasis role="strong">Encryption</emphasis> and <emphasis role="strong">Default Encryption Properties</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the tag category created earlier, and select tag selected. Verify that the policy is selecting matching datastores.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create the storage policy.</simpara>
</listitem>
<listitem>
<simpara>Create a storage class that uses the storage policy:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
 name:  csi-encrypted
provisioner: csi.vsphere.vmware.com
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
parameters:
 storagePolicyName: &lt;storage-policy-name&gt; <co xml:id="CO100-1"/></programlisting>
<calloutlist>
<callout arearefs="CO100-1">
<para>Name of the storage policy that you created for encryption</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-vsphere-top-aware-overview_persistent-storage-csi-vsphere">
<title>vSphere CSI topology overview</title>
<simpara>OpenShift Container Platform provides the ability to deploy OpenShift Container Platform for vSphere on different zones and regions, which allows you to deploy over multiple compute clusters and datacenters, thus helping to avoid a single point of failure.</simpara>
<simpara>This is accomplished by defining zone and region categories in vCenter, and then assigning these categories to different failure domains, such as a compute cluster, by creating tags for these zone and region categories. After you have created the appropriate categories, and assigned tags to vCenter objects, you can create additional machinesets that create virtual machines (VMs) that are responsible for scheduling pods in those failure domains.</simpara>
<simpara>The following example defines two failure domains with one region and two zones:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>vSphere storage topology with one region and two zones</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Compute cluster</entry>
<entry align="left" valign="top">Failure domain</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Compute cluster: ocp1,
Datacenter: Atlanta</simpara></entry>
<entry align="left" valign="top"><simpara>openshift-region: us-east-1 (tag), openshift-zone: us-east-1a (tag)</simpara></entry>
<entry align="left" valign="top"><simpara>This defines a failure domain in region us-east-1 with zone us-east-1a.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Computer cluster: ocp2,
Datacenter: Atlanta</simpara></entry>
<entry align="left" valign="top"><simpara>openshift-region: us-east-1 (tag), openshift-zone: us-east-1b (tag)</simpara></entry>
<entry align="left" valign="top"><simpara>This defines a different failure domain within the same region called us-east-1b.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section xml:id="persistent-storage-csi-vsphere-top-aware-during-install_persistent-storage-csi-vsphere">
<title>Creating vSphere storage topology during installation</title>
<section xml:id="_procedure">
<title>Procedure</title>
<itemizedlist>
<listitem>
<simpara>Specify the topology during installation. See the <emphasis>Configuring regions and zones for a VMware vCenter</emphasis> section.</simpara>
</listitem>
</itemizedlist>
<simpara>No additional action is necessary and the default storage class that is created by OpenShift Container Platform
is topology aware and should allow provisioning of volumes in different failure domains.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/installing/#configuring-vsphere-regions-zones_installing-vsphere-installer-provisioned-network-customizations">Configuring regions and zones for a VMware vCenter</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-vsphere-top-aware-post-install_persistent-storage-csi-vsphere">
<title>Creating vSphere storage topology postinstallation</title>
<section xml:id="_procedure-2">
<title>Procedure</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the VMware vCenter vSphere client GUI, define appropriate zone and region catagories and tags.</simpara>
<simpara>While vSphere allows you to create categories with any arbitrary name, OpenShift Container Platform strongly recommends use of <literal>openshift-region</literal> and <literal>openshift-zone</literal> names for defining topology categories.</simpara>
<simpara>For more information about vSphere categories and tags, see the VMware vSphere documentation.</simpara>
</listitem>
<listitem>
<simpara>In OpenShift Container Platform, create failure domains. See the <emphasis>Specifying multiple regions and zones for your cluster on vSphere</emphasis> section.</simpara>
</listitem>
<listitem>
<simpara>Create a tag to assign to datastores across failure domains:</simpara>
<simpara>When an OpenShift Container Platform spans more than one failure domain, the datastore might not be shared across those failure domains, which is where topology-aware provisioning of persistent volumes (PVs) is useful.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In vCenter, create a category for tagging the datastores. For example, <literal>openshift-zonal-datastore-cat</literal>. You can use any other category name, provided the category uniquely is used for tagging datastores participating in OpenShift Container Platform cluster. Also, ensure that <literal>StoragePod</literal>, <literal>Datastore</literal>, and <literal>Folder</literal> are selected as Associable Entities for the created category.</simpara>
</listitem>
<listitem>
<simpara>In vCenter, create a tag that uses the previously created category. This example uses the tag name <literal>openshift-zonal-datastore</literal>.</simpara>
</listitem>
<listitem>
<simpara>Assign the previously created tag (in this example <literal>openshift-zonal-datastore</literal>) to each datastore in a failure domain that would be considered for dynamic provisioning.</simpara>
<note>
<simpara>You can use any names you like for datastore categories and tags. The names used in this example are provided as recommendations. Ensure that the tags and categories that you define uniquely identify only datastores that are shared with all hosts in the OpenShift Container Platform cluster.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>As needed, create a storage policy that targets the tag-based datastores in each failure domain:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In vCenter, from the main menu, click <emphasis role="strong">Policies and Profiles</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Policies and Profiles</emphasis> page, in the navigation pane, click <emphasis role="strong">VM Storage Policies</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">CREATE</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type a name for the storage policy.</simpara>
</listitem>
<listitem>
<simpara>For the rules, choose Tag Placement rules and select the tag and category that targets the desired datastores (in this example, the <literal>openshift-zonal-datastore</literal> tag).</simpara>
<simpara>The datastores are listed in the storage compatibility table.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a new storage class that uses the new zoned storage policy:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Storage</emphasis> &gt; <emphasis role="strong">StorageClasses</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">StorageClasses</emphasis> page, click <emphasis role="strong">Create StorageClass</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type a name for the new storage class in <emphasis role="strong">Name</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Provisioner</emphasis>, select <emphasis role="strong">csi.vsphere.vmware.com</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Additional parameters</emphasis>, for the StoragePolicyName parameter, set <emphasis role="strong">Value</emphasis> to the name of the new zoned storage policy that you created earlier.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: zoned-sc <co xml:id="CO101-1"/>
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: zoned-storage-policy <co xml:id="CO101-2"/>
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO101-1">
<para>New topology aware storage class name.</para>
</callout>
<callout arearefs="CO101-2">
<para>Specify zoned storage policy.</para>
</callout>
</calloutlist>
<note>
<simpara>You can also create the storage class by editing the preceding YAML file and running the command <literal>oc create -f $FILE</literal>.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.14/html-single/postinstallation_configuration/#specifying-regions-zones-infrastructure-vsphere_post-install-vsphere-zones-regions-configuration">Specifying multiple regions and zones for your cluster on vSphere</link></simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vcenter-esxi-management/GUID-16422FF7-235B-4A44-92E2-532F6AED0923.html?hWord=N4IghgNiBcIC5gOYgL5A">VMware vSphere tag documentation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-vsphere-top-aware-infra-top_persistent-storage-csi-vsphere">
<title>Creating vSphere storage topology without an infra topology</title>
<note>
<simpara>OpenShift Container Platform recommends using the infrastructure object for specifying failure domains in a topology aware setup. Specifying failure domains in the infrastructure object and specify topology-categories in the <literal>ClusterCSIDriver</literal> object at the same time is an unsupported operation.</simpara>
</note>
<section xml:id="_procedure-3">
<title>Procedure</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>In the VMware vCenter vSphere client GUI, define appropriate zone and region catagories and tags.</simpara>
<simpara>While vSphere allows you to create categories with any arbitrary name, OpenShift Container Platform strongly recommends use of <literal>openshift-region</literal> and <literal>openshift-zone</literal> names for defining topology.</simpara>
<simpara>For more information about vSphere categories and tags, see the VMware vSphere documentation.</simpara>
</listitem>
<listitem>
<simpara>To allow the container storage interface (CSI) driver to detect this topology, edit the <literal>clusterCSIDriver</literal> object YAML file <literal>driverConfig</literal> section:</simpara>
<itemizedlist>
<listitem>
<simpara>Specify the <literal>openshift-zone</literal> and <literal>openshift-region</literal> categories that you created earlier.</simpara>
</listitem>
<listitem>
<simpara>Set <literal>driverType</literal> to <literal>vSphere</literal>.</simpara>
<programlisting language="terminal" linenumbering="unnumbered">~ $ oc edit clustercsidriver csi.vsphere.vmware.com -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
  name: csi.vsphere.vmware.com
spec:
  logLevel: Normal
  managementState: Managed
  observedConfig: null
  operatorLogLevel: Normal
  unsupportedConfigOverrides: null
  driverConfig:
    driverType: vSphere <co xml:id="CO102-1"/>
      vSphere:
        topologyCategories: <co xml:id="CO102-2"/>
        - openshift-zone
        - openshift-region</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO102-1">
<para>Ensure that <literal>driverType</literal> is set to <literal>vSphere</literal>.</para>
</callout>
<callout arearefs="CO102-2">
<para><literal>openshift-zone</literal> and <literal>openshift-region</literal> categories created earlier in vCenter.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Verify that <literal>CSINode</literal> object has topology keys by running the following commands:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">~ $ oc get csinode</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME DRIVERS AGE
co8-4s88d-infra-2m5vd 1 27m
co8-4s88d-master-0 1 70m
co8-4s88d-master-1 1 70m
co8-4s88d-master-2 1 70m
co8-4s88d-worker-j2hmg 1 47m
co8-4s88d-worker-mbb46 1 47m
co8-4s88d-worker-zlk7d 1 47m</programlisting>
</para>
</formalpara>
<programlisting language="terminal" linenumbering="unnumbered">~ $ oc get csinode co8-4s88d-worker-j2hmg -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
spec:
  drivers:
  - allocatable:
      count: 59
  name: csi-vsphere.vmware.com
  nodeID: co8-4s88d-worker-j2hmg
  topologyKeys: <co xml:id="CO103-1"/>
  - topology.csi.vmware.com/openshift-zone
  - topology.csi.vmware.com/openshift-region</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO103-1">
<para>Topology keys from vSphere <literal>openshift-zone</literal> and <literal>openshift-region</literal> catagories.</para>
</callout>
</calloutlist>
<note>
<simpara><literal>CSINode</literal> objects might take some time to receive updated topology information. After the driver is updated, <literal>CSINode</literal> objects should have topology keys in them.</simpara>
</note>
</listitem>
<listitem>
<simpara>Create a tag to assign to datastores across failure domains:</simpara>
<simpara>When an OpenShift Container Platform spans more than one failure domain, the datastore might not be shared across those failure domains, which is where topology-aware provisioning of persistent volumes (PVs) is useful.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In vCenter, create a category for tagging the datastores. For example, <literal>openshift-zonal-datastore-cat</literal>. You can use any other category name, provided the category uniquely is used for tagging datastores participating in OpenShift Container Platform cluster. Also, ensure that <literal>StoragePod</literal>, <literal>Datastore</literal>, and <literal>Folder</literal> are selected as Associable Entities for the created category.</simpara>
</listitem>
<listitem>
<simpara>In vCenter, create a tag that uses the previously created category. This example uses the tag name <literal>openshift-zonal-datastore</literal>.</simpara>
</listitem>
<listitem>
<simpara>Assign the previously created tag (in this example <literal>openshift-zonal-datastore</literal>) to each datastore in a failure domain that would be considered for dynamic provisioning.</simpara>
<note>
<simpara>You can use any names you like for categories and tags. The names used in this example are provided as recommendations. Ensure that the tags and categories that you define uniquely identify only datastores that are shared with all hosts in the OpenShift Container Platform cluster.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a storage policy that targets the tag-based datastores in each failure domain:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>In vCenter, from the main menu, click <emphasis role="strong">Policies and Profiles</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">Policies and Profiles</emphasis> page, in the navigation pane, click <emphasis role="strong">VM Storage Policies</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">CREATE</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type a name for the storage policy.</simpara>
</listitem>
<listitem>
<simpara>For the rules, choose Tag Placement rules and select the tag and category that targets the desired datastores (in this example, the <literal>openshift-zonal-datastore</literal> tag).</simpara>
<simpara>The datastores are listed in the storage compatibility table.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Create a new storage class that uses the new zoned storage policy:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Click <emphasis role="strong">Storage</emphasis> &gt; <emphasis role="strong">StorageClasses</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>On the <emphasis role="strong">StorageClasses</emphasis> page, click <emphasis role="strong">Create StorageClass</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Type a name for the new storage class in <emphasis role="strong">Name</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Provisioner</emphasis>, select <emphasis role="strong">csi.vsphere.vmware.com</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Under <emphasis role="strong">Additional parameters</emphasis>, for the StoragePolicyName parameter, set <emphasis role="strong">Value</emphasis> to the name of the new zoned storage policy that you created earlier.</simpara>
</listitem>
<listitem>
<simpara>Click <emphasis role="strong">Create</emphasis>.</simpara>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: zoned-sc <co xml:id="CO104-1"/>
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: zoned-storage-policy <co xml:id="CO104-2"/>
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO104-1">
<para>New topology aware storage class name.</para>
</callout>
<callout arearefs="CO104-2">
<para>Specify zoned storage policy.</para>
</callout>
</calloutlist>
<note>
<simpara>You can also create the storage class by editing the preceding YAML file and running the command <literal>oc create -f $FILE</literal>.</simpara>
</note>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link xlink:href="https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vcenter-esxi-management/GUID-16422FF7-235B-4A44-92E2-532F6AED0923.html?hWord=N4IghgNiBcIC5gOYgL5A">VMware vSphere tag documentation</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="persistent-storage-csi-vsphere-top-aware-results_persistent-storage-csi-vsphere">
<title>Results</title>
<simpara>Creating persistent volume claims (PVCs) and PVs from the topology aware storage class are truly zonal, and should use the datastore in their respective zone depending on how pods are scheduled:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">~ $ oc get pv &lt;pv-name&gt; -o yaml</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">...
nodeAffinity:
  required:
    nodeSelectorTerms:
    - matchExpressions:
      - key: topology.csi.vmware.com/openshift-zone <co xml:id="CO105-1"/>
        operator: In
        values:
        - &lt;openshift-zone&gt;
      -key: topology.csi.vmware.com/openshift-region <co xml:id="CO105-2"/>
        operator: In
        values:
        - &lt;openshift-region&gt;
...
peristentVolumeclaimPolicy: Delete
storageClassName: &lt;zoned-storage-class-name&gt; <co xml:id="CO105-3"/>
volumeMode: Filesystem
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO105-1 CO105-2">
<para>PV has zoned keys.</para>
</callout>
<callout arearefs="CO105-3">
<para>PV is using the zoned storage class.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="_additional-resources-6">
<title>Additional resources</title>
<itemizedlist>
<listitem>
<simpara><link linkend="persistent-storage-csi">Configuring CSI volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="generic-ephemeral-volumes">
<title>Generic ephemeral volumes</title>

<section xml:id="generic-ephemeral-vols-overview_generic-ephemeral-volumes">
<title>Overview</title>
<simpara>Generic ephemeral volumes are a type of ephemeral volume that can be provided by all storage drivers that support persistent volumes and dynamic provisioning. Generic ephemeral volumes are similar to <literal>emptyDir</literal> volumes in that they provide a per-pod directory for scratch data, which is usually empty after provisioning.</simpara>
<simpara>Generic ephemeral volumes are specified inline in the pod spec and follow the pod&#8217;s lifecycle. They are created and deleted along with the pod.</simpara>
<simpara>Generic ephemeral volumes have the following features:</simpara>
<itemizedlist>
<listitem>
<simpara>Storage can be local or network-attached.</simpara>
</listitem>
<listitem>
<simpara>Volumes can have a fixed size that pods are not able to exceed.</simpara>
</listitem>
<listitem>
<simpara>Volumes might have some initial data, depending on the driver and parameters.</simpara>
</listitem>
<listitem>
<simpara>Typical operations on volumes are supported, assuming that the driver supports them, including snapshotting, cloning, resizing, and storage capacity tracking.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Generic ephemeral volumes do not support offline snapshots and resize.</simpara>
<simpara>Due to this limitation, the following Container Storage Interface (CSI) drivers do not support the following features for generic ephemeral volumes:</simpara>
<itemizedlist>
<listitem>
<simpara>Azure Disk CSI driver does not support resize.</simpara>
</listitem>
<listitem>
<simpara>Cinder CSI driver does not support snapshot.</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="generic-ephemeral-vols-lifecycle_generic-ephemeral-volumes">
<title>Lifecycle and persistent volume claims</title>
<simpara>The parameters for a volume claim are allowed inside a volume source of a pod. Labels, annotations, and the whole set of fields for persistent volume claims (PVCs) are supported. When such a pod is created, the ephemeral volume controller then creates an actual PVC object (from the template shown in the <emphasis>Creating generic ephemeral volumes</emphasis> procedure) in the same namespace as the pod, and ensures that the PVC is deleted when the pod is deleted. This triggers volume binding and provisioning in one of two ways:</simpara>
<itemizedlist>
<listitem>
<simpara>Either immediately, if the storage class uses immediate volume binding.</simpara>
<simpara>With immediate binding, the scheduler is forced to select a node that has access to the volume after it is available.</simpara>
</listitem>
<listitem>
<simpara>When the pod is tentatively scheduled onto a node (<literal>WaitForFirstConsumervolume</literal> binding mode).</simpara>
<simpara>This volume binding option is recommended for generic ephemeral volumes because then the scheduler can choose a suitable node for the pod.</simpara>
</listitem>
</itemizedlist>
<simpara>In terms of resource ownership, a pod that has generic ephemeral storage is the owner of the PVCs that provide that ephemeral storage. When the pod is deleted, the Kubernetes garbage collector deletes the PVC, which then usually triggers deletion of the volume because the default reclaim policy of storage classes is to delete volumes. You can create quasi-ephemeral local storage by using a storage class with a reclaim policy of retain: the storage outlives the pod, and in this case, you must ensure that volume clean-up happens separately. While these PVCs exist, they can be used like any other PVC. In particular, they can be referenced as data source in volume cloning or snapshotting. The PVC object also holds the current status of the volume.</simpara>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara><link linkend="generic-ephemeral-vols-procedure_generic-ephemeral-volumes">Creating generic ephemeral volumes</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="generic-ephemeral-security_generic-ephemeral-volumes">
<title>Security</title>
<simpara>You can enable the generic ephemeral volume feature to allows users who can create pods to also create persistent volume claims (PVCs) indirectly. This feature works even if these users do not have permission to create PVCs directly. Cluster administrators must be aware of this. If this does not fit your security model, use an admission webhook that rejects objects such as pods that have a generic ephemeral volume.</simpara>
<simpara>The normal namespace quota for PVCs still applies, so even if users are allowed to use this new mechanism, they cannot use it to circumvent other policies.</simpara>
</section>
<section xml:id="generic-ephemeral-vols-pvc-naming_generic-ephemeral-volumes">
<title>Persistent volume claim naming</title>
<simpara>Automatically created persistent volume claims (PVCs) are named by a combination of the pod name and the volume name, with a hyphen (-) in the middle. This naming convention also introduces a potential conflict between different pods, and between pods and manually created PVCs.</simpara>
<simpara>For example, <literal>pod-a</literal> with volume <literal>scratch</literal> and <literal>pod</literal> with volume <literal>a-scratch</literal> both end up with the same PVC name, <literal>pod-a-scratch</literal>.</simpara>
<simpara>Such conflicts are detected, and a PVC is only used for an ephemeral volume if it was created for the pod. This check is based on the ownership relationship. An existing PVC is not overwritten or modified, but this does not resolve the conflict. Without the right PVC, a pod cannot start.</simpara>
<important>
<simpara>Be careful when naming pods and volumes inside the same namespace so that naming conflicts do not occur.</simpara>
</important>
</section>
<section xml:id="generic-ephemeral-vols-procedure_generic-ephemeral-volumes">
<title>Creating generic ephemeral volumes</title>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Create the <literal>pod</literal> object definition and save it to a file.</simpara>
</listitem>
<listitem>
<simpara>Include the generic ephemeral volume information in the file.</simpara>
<formalpara>
<title>my-example-pod-with-generic-vols.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: Pod
apiVersion: v1
metadata:
  name: my-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/mnt/storage"
        name: data
      command: [ "sleep", "1000000" ]
  volumes:
    - name: data <co xml:id="CO106-1"/>
      ephemeral:
        volumeClaimTemplate:
          metadata:
            labels:
              type: my-app-ephvol
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: "gp2-csi"
            resources:
              requests:
                storage: 1Gi</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO106-1">
<para>Generic ephemeral volume claim.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
</section>
</chapter>
<chapter xml:id="expanding-persistent-volumes">
<title>Expanding persistent volumes</title>

<section xml:id="add-volume-expansion_expanding-persistent-volumes">
<title>Enabling volume expansion support</title>
<simpara>Before you can expand persistent volumes, the <literal>StorageClass</literal> object must
have the <literal>allowVolumeExpansion</literal> field set to <literal>true</literal>.</simpara>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>Edit the <literal>StorageClass</literal> object and add the <literal>allowVolumeExpansion</literal> attribute by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc edit storageclass &lt;storage_class_name&gt; <co xml:id="CO107-1"/></programlisting>
<calloutlist>
<callout arearefs="CO107-1">
<para>Specifies the name of the storage class.</para>
</callout>
</calloutlist>
<simpara>The following example demonstrates adding this line at the bottom
of the storage class configuration.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
...
parameters:
  type: gp2
reclaimPolicy: Delete
allowVolumeExpansion: true <co xml:id="CO108-1"/></programlisting>
<calloutlist>
<callout arearefs="CO108-1">
<para>Setting this attribute to <literal>true</literal> allows PVCs to be
expanded after creation.</para>
</callout>
</calloutlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="expanding-csi-volumes_expanding-persistent-volumes">
<title>Expanding CSI volumes</title>
<simpara>You can use the Container Storage Interface (CSI) to expand storage volumes after they have already been created.</simpara>
<simpara>CSI volume expansion does not support the following:</simpara>
<itemizedlist>
<listitem>
<simpara>Recovering from failure when expanding volumes</simpara>
</listitem>
<listitem>
<simpara>Shrinking</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The underlying CSI driver supports resize.</simpara>
</listitem>
<listitem>
<simpara>Dynamic provisioning is used.</simpara>
</listitem>
<listitem>
<simpara>The controlling <literal>StorageClass</literal> object has <literal>allowVolumeExpansion</literal> set to <literal>true</literal>. For more information, see "Enabling volume expansion support."</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>For the persistent volume claim (PVC), set <literal>.spec.resources.requests.storage</literal> to the desired new size.</simpara>
</listitem>
<listitem>
<simpara>Watch the <literal>status.conditions</literal> field of the PVC to see if the resize has completed. OpenShift Container Platform adds the <literal>Resizing</literal> condition to the PVC during expansion, which is removed after expansion completes.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="expanding-flexvolume_expanding-persistent-volumes">
<title>Expanding FlexVolume with a supported driver</title>
<simpara>When using FlexVolume to connect to your back-end storage system, you can expand persistent storage volumes after they have already been created. This is done by manually updating the persistent volume claim (PVC) in OpenShift Container Platform.</simpara>
<simpara>FlexVolume allows expansion if the driver is set with <literal>RequiresFSResize</literal> to <literal>true</literal>. The FlexVolume can be expanded on pod restart.</simpara>
<simpara>Similar to other volume types, FlexVolume volumes can also be expanded when in use by a pod.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The underlying volume driver supports resize.</simpara>
</listitem>
<listitem>
<simpara>The driver is set with the <literal>RequiresFSResize</literal> capability to <literal>true</literal>.</simpara>
</listitem>
<listitem>
<simpara>Dynamic provisioning is used.</simpara>
</listitem>
<listitem>
<simpara>The controlling <literal>StorageClass</literal> object has <literal>allowVolumeExpansion</literal> set to <literal>true</literal>.</simpara>
</listitem>
</itemizedlist>
<itemizedlist>
<title>Procedure</title>
<listitem>
<simpara>To use resizing in the FlexVolume plugin, you must implement the <literal>ExpandableVolumePlugin</literal> interface using these methods:</simpara>
<variablelist>
<varlistentry>
<term><literal>RequiresFSResize</literal></term>
<listitem>
<simpara>If <literal>true</literal>, updates the capacity directly. If <literal>false</literal>, calls the <literal>ExpandFS</literal> method to finish the filesystem resize.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><literal>ExpandFS</literal></term>
<listitem>
<simpara>If <literal>true</literal>, calls <literal>ExpandFS</literal> to resize filesystem after physical volume expansion is done. The volume driver can also perform physical volume resize together with filesystem resize.</simpara>
</listitem>
</varlistentry>
</variablelist>
</listitem>
</itemizedlist>
<important>
<simpara>Because OpenShift Container Platform does not support installation of FlexVolume plugins on control plane nodes, it does not support control-plane expansion of FlexVolume.</simpara>
</important>
</section>
<section xml:id="expanding-local-volumes_expanding-persistent-volumes">
<title>Expanding local volumes</title>
<simpara>You can manually expand persistent volumes (PVs) and persistent volume claims (PVCs) created by using the local storage operator (LSO).</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Expand the underlying devices. Ensure that appropriate capacity is available on these devices.</simpara>
</listitem>
<listitem>
<simpara>Update the corresponding PV objects to match the new device sizes by editing the <literal>.spec.capacity</literal> field of the PV.</simpara>
</listitem>
<listitem>
<simpara>For the storage class that is used for binding the PVC to PVet, set <literal>allowVolumeExpansion:true</literal>.</simpara>
</listitem>
<listitem>
<simpara>For the PVC, set <literal>.spec.resources.requests.storage</literal> to match the new size.</simpara>
</listitem>
</orderedlist>
<simpara>Kubelet should automatically expand the underlying file system on the volume, if necessary, and update the status field of the PVC to reflect the new size.</simpara>
</section>
<section xml:id="expanding-pvc-filesystem_expanding-persistent-volumes">
<title>Expanding persistent volume claims (PVCs) with a file system</title>
<simpara>Expanding PVCs based on volume types that need file system resizing, such as GCE, EBS, and Cinder, is a two-step process. First, expand the volume objects in the cloud provider. Second, expand the file system on the node.</simpara>
<simpara>Expanding the file system on the node only happens when a new pod is started with the volume.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>The controlling <literal>StorageClass</literal> object must have <literal>allowVolumeExpansion</literal> set to <literal>true</literal>.</simpara>
</listitem>
</itemizedlist>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Edit the PVC and request a new size by editing <literal>spec.resources.requests</literal>. For example, the following expands the <literal>ebs</literal> PVC to 8 Gi:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: ebs
spec:
  storageClass: "storageClassWithFlagSet"
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi <co xml:id="CO109-1"/></programlisting>
<calloutlist role="small">
<callout arearefs="CO109-1">
<para>Updating <literal>spec.resources.requests</literal> to a larger amount expands the PVC.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>After the cloud provider object has finished resizing, the PVC is set to <literal>FileSystemResizePending</literal>. Check the condition by entering the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc describe pvc &lt;pvc_name&gt;</programlisting>
</listitem>
<listitem>
<simpara>When the cloud provider object has finished resizing, the <literal>PersistentVolume</literal> object reflects the newly requested size in <literal>PersistentVolume.Spec.Capacity</literal>. At this point, you can create or recreate a new pod from the PVC to finish the file system resizing. Once the pod is running, the newly requested size is available and the <literal>FileSystemResizePending</literal> condition is removed from the PVC.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="expanding-recovering-from-failure_expanding-persistent-volumes">
<title>Recovering from failure when expanding volumes</title>
<simpara>If expanding underlying storage fails, the OpenShift Container Platform administrator can manually recover the persistent volume claim (PVC) state and cancel the resize requests. Otherwise, the resize requests are continuously retried by the controller.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Mark the persistent volume (PV) that is bound to the PVC with the <literal>Retain</literal> reclaim policy. This can be done by editing the PV and changing <literal>persistentVolumeReclaimPolicy</literal> to <literal>Retain</literal>.</simpara>
</listitem>
<listitem>
<simpara>Delete the PVC.</simpara>
</listitem>
<listitem>
<simpara>Manually edit the PV and delete the <literal>claimRef</literal> entry from the PV specs to ensure that the newly created PVC can bind to the PV marked <literal>Retain</literal>. This marks the PV as <literal>Available</literal>.</simpara>
</listitem>
<listitem>
<simpara>Re-create the PVC in a smaller size, or a size that can be allocated by the underlying storage provider.</simpara>
</listitem>
<listitem>
<simpara>Set the <literal>volumeName</literal> field of the PVC to the name of the PV. This binds the PVC to the provisioned PV only.</simpara>
</listitem>
<listitem>
<simpara>Restore the reclaim policy on the PV.</simpara>
</listitem>
</orderedlist>
<itemizedlist role="_additional-resources">
<title>Additional resources</title>
<listitem>
<simpara>The controlling <literal>StorageClass</literal> object has <literal>allowVolumeExpansion</literal> set to <literal>true</literal> (see <link linkend="add-volume-expansion_expanding-persistent-volumes">Enabling volume expansion support</link>).</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="dynamic-provisioning">
<title>Dynamic provisioning</title>

<section xml:id="about_dynamic-provisioning">
<title>About dynamic provisioning</title>
<simpara>The <literal>StorageClass</literal> resource object describes and classifies storage that can
be requested, as well as provides a means for passing parameters for
dynamically provisioned storage on demand. <literal>StorageClass</literal> objects can also
serve as a management mechanism for controlling different levels of
storage and access to the storage. Cluster Administrators (<literal>cluster-admin</literal>)
 or Storage Administrators (<literal>storage-admin</literal>) define and create the
<literal>StorageClass</literal> objects that users can request without needing any detailed
knowledge about the underlying storage volume sources.</simpara>
<simpara>The OpenShift Container Platform persistent volume framework enables this functionality
and allows administrators to provision a cluster with persistent storage.
The framework also gives users a way to request those resources without
having any knowledge of the underlying infrastructure.</simpara>
<simpara>Many storage types are available for use as persistent volumes in
OpenShift Container Platform. While all of them can be statically provisioned by an
administrator, some types of storage are created dynamically using the
built-in provider and plugin APIs.</simpara>
</section>
<section xml:id="available-plug-ins_dynamic-provisioning">
<title>Available dynamic provisioning plugins</title>
<simpara>OpenShift Container Platform provides the following provisioner plugins, which have
generic implementations for dynamic provisioning that use the cluster&#8217;s
configured provider&#8217;s API to create new storage resources:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Storage type</entry>
<entry align="left" valign="top">Provisioner plugin name</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Red Hat OpenStack Platform (RHOSP) Cinder</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/cinder</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RHOSP Manila Container Storage Interface (CSI)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>manila.csi.openstack.org</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Once installed, the OpenStack Manila CSI Driver Operator and ManilaDriver automatically create the required storage classes for all available Manila share types needed for dynamic provisioning.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Amazon Elastic Block Store (Amazon EBS)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/aws-ebs</literal></simpara></entry>
<entry align="left" valign="top"><simpara>For dynamic provisioning when using multiple clusters in different zones,
tag each node with <literal>Key=kubernetes.io/cluster/&lt;cluster_name&gt;,Value=&lt;cluster_id&gt;</literal>
where <literal>&lt;cluster_name&gt;</literal> and <literal>&lt;cluster_id&gt;</literal> are unique per cluster.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure Disk</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/azure-disk</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Azure File</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/azure-file</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The <literal>persistent-volume-binder</literal> service account requires permissions to create
and get secrets to store the Azure storage account and keys.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GCE Persistent Disk (gcePD)</simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/gce-pd</literal></simpara></entry>
<entry align="left" valign="top"><simpara>In multi-zone configurations, it is advisable to run one OpenShift Container Platform
cluster per GCE project to avoid PVs from being created in zones where
no node in the current cluster exists.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>IBM Power&#174; Virtual Server Block</simpara></entry>
<entry align="left" valign="top"><simpara><literal>powervs.csi.ibm.com</literal></simpara></entry>
<entry align="left" valign="top"><simpara>After installation, the IBM Power&#174; Virtual Server Block CSI Driver Operator and IBM Power&#174; Virtual Server Block CSI Driver automatically create the required storage classes for dynamic provisioning.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link xlink:href="https://www.vmware.com/support/vsphere.html">VMware vSphere</link></simpara></entry>
<entry align="left" valign="top"><simpara><literal>kubernetes.io/vsphere-volume</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<important>
<simpara>Any chosen provisioner plugin also requires configuration for the relevant
cloud, host, or third-party provider as per the relevant documentation.</simpara>
</important>
</section>
<section xml:id="defining-storage-classes_dynamic-provisioning">
<title>Defining a storage class</title>
<simpara><literal>StorageClass</literal> objects are currently a globally scoped object and must be
created by <literal>cluster-admin</literal> or <literal>storage-admin</literal> users.</simpara>
<important>
<simpara>The Cluster Storage Operator might install a default storage class depending
on the platform in use. This storage class is owned and controlled by the
Operator. It cannot be deleted or modified beyond defining annotations
and labels. If different behavior is desired, you must define a custom
storage class.</simpara>
</important>
<simpara>The following sections describe the basic definition for a
<literal>StorageClass</literal> object and specific examples for each of the supported plugin types.</simpara>
<section xml:id="basic-storage-class-definition_dynamic-provisioning">
<title>Basic StorageClass object definition</title>
<simpara>The following resource shows the parameters and default values that you
use to configure a storage class. This example uses the AWS
ElasticBlockStore (EBS) object definition.</simpara>
<formalpara>
<title>Sample <literal>StorageClass</literal> definition</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass <co xml:id="CO110-1"/>
apiVersion: storage.k8s.io/v1 <co xml:id="CO110-2"/>
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO110-3"/>
  annotations: <co xml:id="CO110-4"/>
    storageclass.kubernetes.io/is-default-class: 'true'
    ...
provisioner: kubernetes.io/aws-ebs <co xml:id="CO110-5"/>
parameters: <co xml:id="CO110-6"/>
  type: gp3
...</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO110-1">
<para>(required) The API object type.</para>
</callout>
<callout arearefs="CO110-2">
<para>(required) The current apiVersion.</para>
</callout>
<callout arearefs="CO110-3">
<para>(required) The name of the storage class.</para>
</callout>
<callout arearefs="CO110-4">
<para>(optional) Annotations for the storage class.</para>
</callout>
<callout arearefs="CO110-5">
<para>(required) The type of provisioner associated with this storage class.</para>
</callout>
<callout arearefs="CO110-6">
<para>(optional) The parameters required for the specific provisioner, this
will change from plugin to plug-iin.</para>
</callout>
</calloutlist>
</section>
<section xml:id="storage-class-annotations_dynamic-provisioning">
<title>Storage class annotations</title>
<simpara>To set a storage class as the cluster-wide default, add
the following annotation to your storage class metadata:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">storageclass.kubernetes.io/is-default-class: "true"</programlisting>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
...</programlisting>
<simpara>This enables any persistent volume claim (PVC) that does not specify a
specific storage class to automatically be provisioned through the
default storage class. However, your cluster can have more than one storage class, but only one of them can be the default storage class.</simpara>
<note>
<simpara>The beta annotation <literal>storageclass.beta.kubernetes.io/is-default-class</literal> is
still working; however, it will be removed in a future release.</simpara>
</note>
<simpara>To set a storage class description, add the following annotation
to your storage class metadata:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kubernetes.io/description: My Storage Class Description</programlisting>
<simpara>For example:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    kubernetes.io/description: My Storage Class Description
...</programlisting>
</section>
<section xml:id="openstack-cinder-storage-class_dynamic-provisioning">
<title>RHOSP Cinder object definition</title>
<formalpara>
<title>cinder-storageclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO111-1"/>
provisioner: kubernetes.io/cinder
parameters:
  type: fast  <co xml:id="CO111-2"/>
  availability: nova <co xml:id="CO111-3"/>
  fsType: ext4 <co xml:id="CO111-4"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO111-1">
<para>Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO111-2">
<para>Volume type created in Cinder. Default is empty.</para>
</callout>
<callout arearefs="CO111-3">
<para>Availability Zone. If not specified, volumes are generally
round-robined across all active zones where the OpenShift Container Platform cluster
has a node.</para>
</callout>
<callout arearefs="CO111-4">
<para>File system that is created on dynamically provisioned volumes. This
value is copied to the <literal>fsType</literal> field of dynamically provisioned
persistent volumes and the file system is created when the volume is
mounted for the first time. The default value is <literal>ext4</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="openstack-manila-csi-definition_dynamic-provisioning">
<title>RHOSP Manila Container Storage Interface (CSI) object definition</title>
<simpara>Once installed, the OpenStack Manila CSI Driver Operator and ManilaDriver automatically create the required storage classes for all available Manila share types needed for dynamic provisioning.</simpara>
</section>
<section xml:id="aws-definition_dynamic-provisioning">
<title>AWS Elastic Block Store (EBS) object definition</title>
<formalpara>
<title>aws-ebs-storageclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO112-1"/>
provisioner: kubernetes.io/aws-ebs
parameters:
  type: io1 <co xml:id="CO112-2"/>
  iopsPerGB: "10" <co xml:id="CO112-3"/>
  encrypted: "true" <co xml:id="CO112-4"/>
  kmsKeyId: keyvalue <co xml:id="CO112-5"/>
  fsType: ext4 <co xml:id="CO112-6"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO112-1">
<para>(required) Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO112-2">
<para>(required) Select from <literal>io1</literal>, <literal>gp3</literal>, <literal>sc1</literal>, <literal>st1</literal>. The default is <literal>gp3</literal>.
See the
<link xlink:href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</link>
for valid Amazon Resource Name (ARN) values.</para>
</callout>
<callout arearefs="CO112-3">
<para>Optional: Only for <emphasis role="strong">io1</emphasis> volumes. I/O operations per second per GiB.
The AWS volume plugin multiplies this with the size of the requested
volume to compute IOPS of the volume. The value cap is 20,000 IOPS, which
is the maximum supported by AWS. See the
<link xlink:href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</link>
for further details.</para>
</callout>
<callout arearefs="CO112-4">
<para>Optional: Denotes whether to encrypt the EBS volume. Valid values
are <literal>true</literal> or <literal>false</literal>.</para>
</callout>
<callout arearefs="CO112-5">
<para>Optional: The full ARN of the key to use when encrypting the volume.
If none is supplied, but <literal>encypted</literal> is set to <literal>true</literal>, then AWS generates a
key. See the
<link xlink:href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</link>
for a valid ARN value.</para>
</callout>
<callout arearefs="CO112-6">
<para>Optional: File system that is created on dynamically provisioned
volumes. This value is copied to the <literal>fsType</literal> field of dynamically
provisioned persistent volumes and the file system is created when the
volume is mounted for the first time. The default value is <literal>ext4</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="azure-disk-definition_dynamic-provisioning">
<title>Azure Disk object definition</title>
<formalpara>
<title>azure-advanced-disk-storageclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO113-1"/>
provisioner: kubernetes.io/azure-disk
volumeBindingMode: WaitForFirstConsumer <co xml:id="CO113-2"/>
allowVolumeExpansion: true
parameters:
  kind: Managed <co xml:id="CO113-3"/>
  storageaccounttype: Premium_LRS <co xml:id="CO113-4"/>
reclaimPolicy: Delete</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO113-1">
<para>Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO113-2">
<para>Using <literal>WaitForFirstConsumer</literal> is strongly recommended. This provisions the volume while allowing enough storage to schedule the pod on a free worker node from an available zone.</para>
</callout>
<callout arearefs="CO113-3">
<para>Possible values are <literal>Shared</literal> (default), <literal>Managed</literal>, and <literal>Dedicated</literal>.</para>
<important>
<simpara>Red Hat only supports the use of <literal>kind: Managed</literal> in the storage class.</simpara>
<simpara>With <literal>Shared</literal> and <literal>Dedicated</literal>, Azure creates unmanaged disks, while OpenShift Container Platform creates a managed disk for machine OS (root) disks. But because Azure Disk does not allow the use of both managed and unmanaged disks on a node, unmanaged disks created with <literal>Shared</literal> or <literal>Dedicated</literal> cannot be attached to OpenShift Container Platform nodes.</simpara>
</important>
</callout>
<callout arearefs="CO113-4">
<para>Azure storage account SKU tier. Default is empty. Note that Premium VMs can attach both <literal>Standard_LRS</literal> and <literal>Premium_LRS</literal> disks, Standard VMs can only attach <literal>Standard_LRS</literal> disks, Managed VMs can only attach managed disks, and unmanaged VMs can only attach unmanaged disks.</para>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>If <literal>kind</literal> is set to <literal>Shared</literal>, Azure creates all unmanaged disks in a few shared storage accounts in the same resource group as the cluster.</simpara>
</listitem>
<listitem>
<simpara>If <literal>kind</literal> is set to <literal>Managed</literal>, Azure creates new managed disks.</simpara>
</listitem>
<listitem>
<simpara>If <literal>kind</literal> is set to <literal>Dedicated</literal> and a <literal>storageAccount</literal> is specified, Azure uses the specified storage account for the new unmanaged disk in the same resource group as the cluster. For this to work:</simpara>
<itemizedlist>
<listitem>
<simpara>The specified storage account must be in the same region.</simpara>
</listitem>
<listitem>
<simpara>Azure Cloud Provider must have write access to the storage account.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If <literal>kind</literal> is set to <literal>Dedicated</literal> and a <literal>storageAccount</literal> is not specified, Azure creates a new dedicated storage account for the new unmanaged disk in the same resource group as the cluster.</simpara>
</listitem>
</orderedlist>
</callout>
</calloutlist>
</section>
<section xml:id="azure-file-definition_dynamic-provisioning">
<title>Azure File object definition</title>
<simpara>The Azure File storage class uses secrets to store the Azure storage account name
and the storage account key that are required to create an Azure Files share. These
permissions are created as part of the following procedure.</simpara>
<orderedlist numeration="arabic">
<title>Procedure</title>
<listitem>
<simpara>Define a <literal>ClusterRole</literal> object that allows access to create and view secrets:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
#  name: system:azure-cloud-provider
  name: &lt;persistent-volume-binder-role&gt; <co xml:id="CO114-1"/>
rules:
- apiGroups: ['']
  resources: ['secrets']
  verbs:     ['get','create']</programlisting>
<calloutlist>
<callout arearefs="CO114-1">
<para>The name of the cluster role to view and create secrets.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Add the cluster role to the service account:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc adm policy add-cluster-role-to-user &lt;persistent-volume-binder-role&gt; system:serviceaccount:kube-system:persistent-volume-binder</programlisting>
</listitem>
<listitem>
<simpara>Create the Azure File <literal>StorageClass</literal> object:</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;azure-file&gt; <co xml:id="CO115-1"/>
provisioner: kubernetes.io/azure-file
parameters:
  location: eastus <co xml:id="CO115-2"/>
  skuName: Standard_LRS <co xml:id="CO115-3"/>
  storageAccount: &lt;storage-account&gt; <co xml:id="CO115-4"/>
reclaimPolicy: Delete
volumeBindingMode: Immediate</programlisting>
<calloutlist>
<callout arearefs="CO115-1">
<para>Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO115-2">
<para>Location of the Azure storage account, such as <literal>eastus</literal>. Default is empty, meaning that a new Azure storage account will be created in the OpenShift Container Platform cluster&#8217;s location.</para>
</callout>
<callout arearefs="CO115-3">
<para>SKU tier of the Azure storage account, such as <literal>Standard_LRS</literal>. Default is empty, meaning that a new Azure storage account will be created with the <literal>Standard_LRS</literal> SKU.</para>
</callout>
<callout arearefs="CO115-4">
<para>Name of the Azure storage account. If a storage account is provided, then
<literal>skuName</literal> and <literal>location</literal> are ignored. If no storage account is provided, then
the storage class searches for any storage account that is associated with the
resource group for any accounts that match the defined <literal>skuName</literal> and <literal>location</literal>.</para>
</callout>
</calloutlist>
</listitem>
</orderedlist>
<section xml:id="azure-file-considerations_dynamic-provisioning">
<title>Considerations when using Azure File</title>
<simpara>The following file system features are not supported by the default Azure File storage class:</simpara>
<itemizedlist>
<listitem>
<simpara>Symlinks</simpara>
</listitem>
<listitem>
<simpara>Hard links</simpara>
</listitem>
<listitem>
<simpara>Extended attributes</simpara>
</listitem>
<listitem>
<simpara>Sparse files</simpara>
</listitem>
<listitem>
<simpara>Named pipes</simpara>
</listitem>
</itemizedlist>
<simpara>Additionally, the owner user identifier (UID) of the Azure File mounted directory is different from the process UID of the container. The <literal>uid</literal> mount option can be specified in the <literal>StorageClass</literal> object to define
a specific user identifier to use for the mounted directory.</simpara>
<simpara>The following <literal>StorageClass</literal> object demonstrates modifying the user and group identifier, along with enabling symlinks for the mounted directory.</simpara>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: azure-file
mountOptions:
  - uid=1500 <co xml:id="CO116-1"/>
  - gid=1500 <co xml:id="CO116-2"/>
  - mfsymlinks <co xml:id="CO116-3"/>
provisioner: kubernetes.io/azure-file
parameters:
  location: eastus
  skuName: Standard_LRS
reclaimPolicy: Delete
volumeBindingMode: Immediate</programlisting>
<calloutlist>
<callout arearefs="CO116-1">
<para>Specifies the user identifier to use for the mounted directory.</para>
</callout>
<callout arearefs="CO116-2">
<para>Specifies the group identifier to use for the mounted directory.</para>
</callout>
<callout arearefs="CO116-3">
<para>Enables symlinks.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="gce-persistentdisk-storage-class_dynamic-provisioning">
<title>GCE PersistentDisk (gcePD) object definition</title>
<formalpara>
<title>gce-pd-storageclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO117-1"/>
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard <co xml:id="CO117-2"/>
  replication-type: none
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
reclaimPolicy: Delete</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO117-1">
<para>Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO117-2">
<para>Select either <literal>pd-standard</literal> or <literal>pd-ssd</literal>. The default is <literal>pd-standard</literal>.</para>
</callout>
</calloutlist>
</section>
<section xml:id="vsphere-definition_dynamic-provisioning">
<title>VMware vSphere object definition</title>
<formalpara>
<title>vsphere-storageclass.yaml</title>
<para>
<programlisting language="yaml" linenumbering="unnumbered">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <co xml:id="CO118-1"/>
provisioner: csi.vsphere.vmware.com <co xml:id="CO118-2"/></programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO118-1">
<para>Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.</para>
</callout>
<callout arearefs="CO118-2">
<para>For more information about using VMware vSphere CSI with OpenShift Container Platform,
see the
<link xlink:href="https://kubernetes.io/docs/concepts/storage/volumes/#vsphere-csi-migration">Kubernetes documentation</link>.</para>
</callout>
</calloutlist>
</section>
</section>
<section xml:id="change-default-storage-class_dynamic-provisioning">
<title>Changing the default storage class</title>
<simpara>Use the following procedure to change the default storage class.</simpara>
<simpara>For example, if you have two defined storage classes, <literal>gp3</literal> and <literal>standard</literal>, and you want to change the default storage class from <literal>gp3</literal> to <literal>standard</literal>.</simpara>
<itemizedlist>
<title>Prerequisites</title>
<listitem>
<simpara>Access to the cluster with cluster-admin privileges.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Procedure</title>
<para>To change the default storage class:</para>
</formalpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>List the storage classes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 TYPE
gp3 (default)        kubernetes.io/aws-ebs <co xml:id="CO119-1"/>
standard             kubernetes.io/aws-ebs</programlisting>
</para>
</formalpara>
<calloutlist>
<callout arearefs="CO119-1">
<para><literal>(default)</literal> indicates the default storage class.</para>
</callout>
</calloutlist>
</listitem>
<listitem>
<simpara>Make the desired storage class the default.</simpara>
<simpara>For the desired storage class, set the <literal>storageclass.kubernetes.io/is-default-class</literal> annotation to <literal>true</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</programlisting>
<note>
<simpara>You can have multiple default storage classes for a short time. However, you should ensure that only one default storage class exists eventually.</simpara>
<simpara>With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<literal>pvc.spec.storageClassName</literal>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <literal>MultipleDefaultStorageClasses</literal>.</simpara>
</note>
</listitem>
<listitem>
<simpara>Remove the default storage class setting from the old default storage class.</simpara>
<simpara>For the old default storage class, change the value of the <literal>storageclass.kubernetes.io/is-default-class</literal> annotation to <literal>false</literal> by running the following command:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc patch storageclass gp3 -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</programlisting>
</listitem>
<listitem>
<simpara>Verify the changes:</simpara>
<programlisting language="terminal" linenumbering="unnumbered">$ oc get storageclass</programlisting>
<formalpara>
<title>Example output</title>
<para>
<programlisting language="terminal" linenumbering="unnumbered">NAME                 TYPE
gp3                  kubernetes.io/aws-ebs
standard (default)   kubernetes.io/aws-ebs</programlisting>
</para>
</formalpara>
</listitem>
</orderedlist>
</section>
</chapter>
</book>